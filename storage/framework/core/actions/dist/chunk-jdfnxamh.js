import {
  require_lib as require_lib2,
  require_src
} from "./chunk-kxsrvkd8.js";
import {
  make
} from "./chunk-389b9wtx.js";
import {
  require_lib
} from "./chunk-e9syc5kq.js";
import {
  camelCase,
  kebabCase,
  pascalCase,
  plural,
  singular,
  slugify,
  snakeCase,
  toString
} from "./chunk-jycndeyj.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-1j66gxht.js";

// ../../../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS((exports, module) => {
  (function(global2, factory, m) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(module) : typeof define === "function" && define.amd ? define(["module"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }), global2.sourcemapCodec = ("default" in m.exports) ? m.exports.default : m.exports);
  })(exports, function(module2) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var sourcemap_codec_exports = {};
    __export(sourcemap_codec_exports, {
      decode: () => decode,
      decodeGeneratedRanges: () => decodeGeneratedRanges,
      decodeOriginalScopes: () => decodeOriginalScopes,
      encode: () => encode,
      encodeGeneratedRanges: () => encodeGeneratedRanges,
      encodeOriginalScopes: () => encodeOriginalScopes
    });
    module2.exports = __toCommonJS(sourcemap_codec_exports);
    var comma = 44;
    var semicolon = 59;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var intToChar = new Uint8Array(64);
    var charToInt = new Uint8Array(128);
    for (let i = 0;i < chars.length; i++) {
      const c = chars.charCodeAt(i);
      intToChar[i] = c;
      charToInt[c] = i;
    }
    function decodeInteger(reader, relative) {
      let value = 0;
      let shift = 0;
      let integer = 0;
      do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
      } while (integer & 32);
      const shouldNegate = value & 1;
      value >>>= 1;
      if (shouldNegate) {
        value = -2147483648 | -value;
      }
      return relative + value;
    }
    function encodeInteger(builder, num, relative) {
      let delta = num - relative;
      delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
      do {
        let clamped = delta & 31;
        delta >>>= 5;
        if (delta > 0)
          clamped |= 32;
        builder.write(intToChar[clamped]);
      } while (delta > 0);
      return num;
    }
    function hasMoreVlq(reader, max) {
      if (reader.pos >= max)
        return false;
      return reader.peek() !== comma;
    }
    var bufLength = 1024 * 16;
    var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder : typeof Buffer !== "undefined" ? {
      decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
      }
    } : {
      decode(buf) {
        let out = "";
        for (let i = 0;i < buf.length; i++) {
          out += String.fromCharCode(buf[i]);
        }
        return out;
      }
    };
    var StringWriter = class {
      constructor() {
        this.pos = 0;
        this.out = "";
        this.buffer = new Uint8Array(bufLength);
      }
      write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
          this.out += td.decode(buffer);
          this.pos = 0;
        }
      }
      flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
      }
    };
    var StringReader = class {
      constructor(buffer) {
        this.pos = 0;
        this.buffer = buffer;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return idx === -1 ? buffer.length : idx;
      }
    };
    var EMPTY = [];
    function decodeOriginalScopes(input) {
      const { length } = input;
      const reader = new StringReader(input);
      const scopes = [];
      const stack = [];
      let line = 0;
      for (;reader.pos < length; reader.pos++) {
        line = decodeInteger(reader, line);
        const column = decodeInteger(reader, 0);
        if (!hasMoreVlq(reader, length)) {
          const last = stack.pop();
          last[2] = line;
          last[3] = column;
          continue;
        }
        const kind = decodeInteger(reader, 0);
        const fields = decodeInteger(reader, 0);
        const hasName = fields & 1;
        const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
        let vars = EMPTY;
        if (hasMoreVlq(reader, length)) {
          vars = [];
          do {
            const varsIndex = decodeInteger(reader, 0);
            vars.push(varsIndex);
          } while (hasMoreVlq(reader, length));
        }
        scope.vars = vars;
        scopes.push(scope);
        stack.push(scope);
      }
      return scopes;
    }
    function encodeOriginalScopes(scopes) {
      const writer = new StringWriter;
      for (let i = 0;i < scopes.length; ) {
        i = _encodeOriginalScopes(scopes, i, writer, [0]);
      }
      return writer.flush();
    }
    function _encodeOriginalScopes(scopes, index, writer, state) {
      const scope = scopes[index];
      const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
      if (index > 0)
        writer.write(comma);
      state[0] = encodeInteger(writer, startLine, state[0]);
      encodeInteger(writer, startColumn, 0);
      encodeInteger(writer, kind, 0);
      const fields = scope.length === 6 ? 1 : 0;
      encodeInteger(writer, fields, 0);
      if (scope.length === 6)
        encodeInteger(writer, scope[5], 0);
      for (const v of vars) {
        encodeInteger(writer, v, 0);
      }
      for (index++;index < scopes.length; ) {
        const next = scopes[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
          break;
        }
        index = _encodeOriginalScopes(scopes, index, writer, state);
      }
      writer.write(comma);
      state[0] = encodeInteger(writer, endLine, state[0]);
      encodeInteger(writer, endColumn, 0);
      return index;
    }
    function decodeGeneratedRanges(input) {
      const { length } = input;
      const reader = new StringReader(input);
      const ranges = [];
      const stack = [];
      let genLine = 0;
      let definitionSourcesIndex = 0;
      let definitionScopeIndex = 0;
      let callsiteSourcesIndex = 0;
      let callsiteLine = 0;
      let callsiteColumn = 0;
      let bindingLine = 0;
      let bindingColumn = 0;
      do {
        const semi = reader.indexOf(";");
        let genColumn = 0;
        for (;reader.pos < semi; reader.pos++) {
          genColumn = decodeInteger(reader, genColumn);
          if (!hasMoreVlq(reader, semi)) {
            const last = stack.pop();
            last[2] = genLine;
            last[3] = genColumn;
            continue;
          }
          const fields = decodeInteger(reader, 0);
          const hasDefinition = fields & 1;
          const hasCallsite = fields & 2;
          const hasScope = fields & 4;
          let callsite = null;
          let bindings = EMPTY;
          let range;
          if (hasDefinition) {
            const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
            definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
            definitionSourcesIndex = defSourcesIndex;
            range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
          } else {
            range = [genLine, genColumn, 0, 0];
          }
          range.isScope = !!hasScope;
          if (hasCallsite) {
            const prevCsi = callsiteSourcesIndex;
            const prevLine = callsiteLine;
            callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
            const sameSource = prevCsi === callsiteSourcesIndex;
            callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
            callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
            callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
          }
          range.callsite = callsite;
          if (hasMoreVlq(reader, semi)) {
            bindings = [];
            do {
              bindingLine = genLine;
              bindingColumn = genColumn;
              const expressionsCount = decodeInteger(reader, 0);
              let expressionRanges;
              if (expressionsCount < -1) {
                expressionRanges = [[decodeInteger(reader, 0)]];
                for (let i = -1;i > expressionsCount; i--) {
                  const prevBl = bindingLine;
                  bindingLine = decodeInteger(reader, bindingLine);
                  bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                  const expression = decodeInteger(reader, 0);
                  expressionRanges.push([expression, bindingLine, bindingColumn]);
                }
              } else {
                expressionRanges = [[expressionsCount]];
              }
              bindings.push(expressionRanges);
            } while (hasMoreVlq(reader, semi));
          }
          range.bindings = bindings;
          ranges.push(range);
          stack.push(range);
        }
        genLine++;
        reader.pos = semi + 1;
      } while (reader.pos < length);
      return ranges;
    }
    function encodeGeneratedRanges(ranges) {
      if (ranges.length === 0)
        return "";
      const writer = new StringWriter;
      for (let i = 0;i < ranges.length; ) {
        i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
      }
      return writer.flush();
    }
    function _encodeGeneratedRanges(ranges, index, writer, state) {
      const range = ranges[index];
      const {
        0: startLine,
        1: startColumn,
        2: endLine,
        3: endColumn,
        isScope,
        callsite,
        bindings
      } = range;
      if (state[0] < startLine) {
        catchupLine(writer, state[0], startLine);
        state[0] = startLine;
        state[1] = 0;
      } else if (index > 0) {
        writer.write(comma);
      }
      state[1] = encodeInteger(writer, range[1], state[1]);
      const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
      encodeInteger(writer, fields, 0);
      if (range.length === 6) {
        const { 4: sourcesIndex, 5: scopesIndex } = range;
        if (sourcesIndex !== state[2]) {
          state[3] = 0;
        }
        state[2] = encodeInteger(writer, sourcesIndex, state[2]);
        state[3] = encodeInteger(writer, scopesIndex, state[3]);
      }
      if (callsite) {
        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
        if (sourcesIndex !== state[4]) {
          state[5] = 0;
          state[6] = 0;
        } else if (callLine !== state[5]) {
          state[6] = 0;
        }
        state[4] = encodeInteger(writer, sourcesIndex, state[4]);
        state[5] = encodeInteger(writer, callLine, state[5]);
        state[6] = encodeInteger(writer, callColumn, state[6]);
      }
      if (bindings) {
        for (const binding of bindings) {
          if (binding.length > 1)
            encodeInteger(writer, -binding.length, 0);
          const expression = binding[0][0];
          encodeInteger(writer, expression, 0);
          let bindingStartLine = startLine;
          let bindingStartColumn = startColumn;
          for (let i = 1;i < binding.length; i++) {
            const expRange = binding[i];
            bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
            bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
            encodeInteger(writer, expRange[0], 0);
          }
        }
      }
      for (index++;index < ranges.length; ) {
        const next = ranges[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
          break;
        }
        index = _encodeGeneratedRanges(ranges, index, writer, state);
      }
      if (state[0] < endLine) {
        catchupLine(writer, state[0], endLine);
        state[0] = endLine;
        state[1] = 0;
      } else {
        writer.write(comma);
      }
      state[1] = encodeInteger(writer, endColumn, state[1]);
      return index;
    }
    function catchupLine(writer, lastLine, line) {
      do {
        writer.write(semicolon);
      } while (++lastLine < line);
    }
    function decode(mappings) {
      const { length } = mappings;
      const reader = new StringReader(mappings);
      const decoded = [];
      let genColumn = 0;
      let sourcesIndex = 0;
      let sourceLine = 0;
      let sourceColumn = 0;
      let namesIndex = 0;
      do {
        const semi = reader.indexOf(";");
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while (reader.pos < semi) {
          let seg;
          genColumn = decodeInteger(reader, genColumn);
          if (genColumn < lastCol)
            sorted = false;
          lastCol = genColumn;
          if (hasMoreVlq(reader, semi)) {
            sourcesIndex = decodeInteger(reader, sourcesIndex);
            sourceLine = decodeInteger(reader, sourceLine);
            sourceColumn = decodeInteger(reader, sourceColumn);
            if (hasMoreVlq(reader, semi)) {
              namesIndex = decodeInteger(reader, namesIndex);
              seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
            } else {
              seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
            }
          } else {
            seg = [genColumn];
          }
          line.push(seg);
          reader.pos++;
        }
        if (!sorted)
          sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
      } while (reader.pos <= length);
      return decoded;
    }
    function sort(line) {
      line.sort(sortComparator);
    }
    function sortComparator(a, b) {
      return a[0] - b[0];
    }
    function encode(decoded) {
      const writer = new StringWriter;
      let sourcesIndex = 0;
      let sourceLine = 0;
      let sourceColumn = 0;
      let namesIndex = 0;
      for (let i = 0;i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0)
          writer.write(semicolon);
        if (line.length === 0)
          continue;
        let genColumn = 0;
        for (let j = 0;j < line.length; j++) {
          const segment = line[j];
          if (j > 0)
            writer.write(comma);
          genColumn = encodeInteger(writer, segment[0], genColumn);
          if (segment.length === 1)
            continue;
          sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
          sourceLine = encodeInteger(writer, segment[2], sourceLine);
          sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
          if (segment.length === 4)
            continue;
          namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
      }
      return writer.flush();
    }
  });
});

// ../../../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
  })(exports, function() {
    const schemeRegex = /^[\w+.-]+:\/\//;
    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function isAbsolutePath(input) {
      return input.startsWith("/");
    }
    function isFileUrl(input) {
      return input.startsWith("file:");
    }
    function isRelative(input) {
      return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
      const match = urlRegex.exec(input);
      return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
    }
    function parseFileUrl(input) {
      const match = fileRegex.exec(input);
      const path = match[2];
      return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
    }
    function makeUrl(scheme, user, host, port, path, query2, hash) {
      return {
        scheme,
        user,
        host,
        port,
        path,
        query: query2,
        hash,
        type: 7
      };
    }
    function parseUrl(input) {
      if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl("http:" + input);
        url2.scheme = "";
        url2.type = 6;
        return url2;
      }
      if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl("http://foo.com" + input);
        url2.scheme = "";
        url2.host = "";
        url2.type = 5;
        return url2;
      }
      if (isFileUrl(input))
        return parseFileUrl(input);
      if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
      const url = parseAbsoluteUrl("http://foo.com/" + input);
      url.scheme = "";
      url.host = "";
      url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
      return url;
    }
    function stripPathFilename(path) {
      if (path.endsWith("/.."))
        return path;
      const index = path.lastIndexOf("/");
      return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
      normalizePath(base, base.type);
      if (url.path === "/") {
        url.path = base.path;
      } else {
        url.path = stripPathFilename(base.path) + url.path;
      }
    }
    function normalizePath(url, type) {
      const rel = type <= 4;
      const pieces = url.path.split("/");
      let pointer = 1;
      let positive = 0;
      let addTrailingSlash = false;
      for (let i = 1;i < pieces.length; i++) {
        const piece = pieces[i];
        if (!piece) {
          addTrailingSlash = true;
          continue;
        }
        addTrailingSlash = false;
        if (piece === ".")
          continue;
        if (piece === "..") {
          if (positive) {
            addTrailingSlash = true;
            positive--;
            pointer--;
          } else if (rel) {
            pieces[pointer++] = piece;
          }
          continue;
        }
        pieces[pointer++] = piece;
        positive++;
      }
      let path = "";
      for (let i = 1;i < pointer; i++) {
        path += "/" + pieces[i];
      }
      if (!path || addTrailingSlash && !path.endsWith("/..")) {
        path += "/";
      }
      url.path = path;
    }
    function resolve(input, base) {
      if (!input && !base)
        return "";
      const url = parseUrl(input);
      let inputType = url.type;
      if (base && inputType !== 7) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch (inputType) {
          case 1:
            url.hash = baseUrl.hash;
          case 2:
            url.query = baseUrl.query;
          case 3:
          case 4:
            mergePaths(url, baseUrl);
          case 5:
            url.user = baseUrl.user;
            url.host = baseUrl.host;
            url.port = baseUrl.port;
          case 6:
            url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
          inputType = baseType;
      }
      normalizePath(url, inputType);
      const queryHash = url.query + url.hash;
      switch (inputType) {
        case 2:
        case 3:
          return queryHash;
        case 4: {
          const path = url.path.slice(1);
          if (!path)
            return queryHash || ".";
          if (isRelative(base || input) && !isRelative(path)) {
            return "./" + path + queryHash;
          }
          return path + queryHash;
        }
        case 5:
          return url.path + queryHash;
        default:
          return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
      }
    }
    return resolve;
  });
});

// ../../../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS((exports, module) => {
  (function(global2, factory, m) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(module, require_resolve_uri_umd(), require_sourcemap_codec_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/resolve-uri", "@jridgewell/sourcemap-codec"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.resolveURI, global2.sourcemapCodec), global2.traceMapping = ("default" in m.exports) ? m.exports.default : m.exports);
  })(exports, function(module2, require_resolveURI, require_sourcemapCodec) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var require_sourcemap_codec = __commonJS2({
      "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
        module22.exports = require_sourcemapCodec;
      }
    });
    var require_resolve_uri = __commonJS2({
      "umd:@jridgewell/resolve-uri"(exports2, module22) {
        module22.exports = require_resolveURI;
      }
    });
    var trace_mapping_exports = {};
    __export(trace_mapping_exports, {
      AnyMap: () => FlattenMap,
      FlattenMap: () => FlattenMap,
      GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
      LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
      TraceMap: () => TraceMap,
      allGeneratedPositionsFor: () => allGeneratedPositionsFor,
      decodedMap: () => decodedMap,
      decodedMappings: () => decodedMappings,
      eachMapping: () => eachMapping,
      encodedMap: () => encodedMap,
      encodedMappings: () => encodedMappings,
      generatedPositionFor: () => generatedPositionFor,
      isIgnored: () => isIgnored,
      originalPositionFor: () => originalPositionFor,
      presortedDecodedMap: () => presortedDecodedMap,
      sourceContentFor: () => sourceContentFor,
      traceSegment: () => traceSegment
    });
    module2.exports = __toCommonJS(trace_mapping_exports);
    var import_sourcemap_codec = __toESM2(require_sourcemap_codec());
    var import_resolve_uri = __toESM2(require_resolve_uri());
    function stripFilename(path) {
      if (!path)
        return "";
      const index = path.lastIndexOf("/");
      return path.slice(0, index + 1);
    }
    function resolver(mapUrl, sourceRoot) {
      const from = stripFilename(mapUrl);
      const prefix = sourceRoot ? sourceRoot + "/" : "";
      return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
    }
    var COLUMN = 0;
    var SOURCES_INDEX = 1;
    var SOURCE_LINE = 2;
    var SOURCE_COLUMN = 3;
    var NAMES_INDEX = 4;
    var REV_GENERATED_LINE = 1;
    var REV_GENERATED_COLUMN = 2;
    function maybeSort(mappings, owned) {
      const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
      if (unsortedIndex === mappings.length)
        return mappings;
      if (!owned)
        mappings = mappings.slice();
      for (let i = unsortedIndex;i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
      }
      return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start) {
      for (let i = start;i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
          return i;
      }
      return mappings.length;
    }
    function isSorted(line) {
      for (let j = 1;j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
          return false;
        }
      }
      return true;
    }
    function sortSegments(line, owned) {
      if (!owned)
        line = line.slice();
      return line.sort(sortComparator);
    }
    function sortComparator(a, b) {
      return a[COLUMN] - b[COLUMN];
    }
    var found = false;
    function binarySearch(haystack, needle, low, high) {
      while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
          found = true;
          return mid;
        }
        if (cmp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      found = false;
      return low - 1;
    }
    function upperBound(haystack, needle, index) {
      for (let i = index + 1;i < haystack.length; index = i++) {
        if (haystack[i][COLUMN] !== needle)
          break;
      }
      return index;
    }
    function lowerBound(haystack, needle, index) {
      for (let i = index - 1;i >= 0; index = i--) {
        if (haystack[i][COLUMN] !== needle)
          break;
      }
      return index;
    }
    function memoizedState() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function memoizedBinarySearch(haystack, needle, state, key) {
      const { lastKey, lastNeedle, lastIndex } = state;
      let low = 0;
      let high = haystack.length - 1;
      if (key === lastKey) {
        if (needle === lastNeedle) {
          found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
          return lastIndex;
        }
        if (needle >= lastNeedle) {
          low = lastIndex === -1 ? 0 : lastIndex;
        } else {
          high = lastIndex;
        }
      }
      state.lastKey = key;
      state.lastNeedle = needle;
      return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    function buildBySources(decoded, memos) {
      const sources = memos.map(buildNullArray);
      for (let i = 0;i < decoded.length; i++) {
        const line = decoded[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          if (seg.length === 1)
            continue;
          const sourceIndex2 = seg[SOURCES_INDEX];
          const sourceLine = seg[SOURCE_LINE];
          const sourceColumn = seg[SOURCE_COLUMN];
          const originalSource = sources[sourceIndex2];
          const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
          const memo = memos[sourceIndex2];
          let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
          memo.lastIndex = ++index;
          insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
        }
      }
      return sources;
    }
    function insert(array, index, value) {
      for (let i = array.length;i > index; i--) {
        array[i] = array[i - 1];
      }
      array[index] = value;
    }
    function buildNullArray() {
      return { __proto__: null };
    }
    function parse(map) {
      return typeof map === "string" ? JSON.parse(map) : map;
    }
    var FlattenMap = function(map, mapUrl) {
      const parsed = parse(map);
      if (!("sections" in parsed)) {
        return new TraceMap(parsed, mapUrl);
      }
      const mappings = [];
      const sources = [];
      const sourcesContent = [];
      const names = [];
      const ignoreList = [];
      recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
      const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
        ignoreList
      };
      return presortedDecodedMap(joined);
    };
    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
      const { sections } = input;
      for (let i = 0;i < sections.length; i++) {
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
          const nextOffset = sections[i + 1].offset;
          sl = Math.min(stopLine, lineOffset + nextOffset.line);
          if (sl === stopLine) {
            sc = Math.min(stopColumn, columnOffset + nextOffset.column);
          } else if (sl < stopLine) {
            sc = columnOffset + nextOffset.column;
          }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
      }
    }
    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
      const parsed = parse(input);
      if ("sections" in parsed)
        return recurse(...arguments);
      const map = new TraceMap(parsed, mapUrl);
      const sourcesOffset = sources.length;
      const namesOffset = names.length;
      const decoded = decodedMappings(map);
      const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
      append(sources, resolvedSources);
      append(names, map.names);
      if (contents)
        append(sourcesContent, contents);
      else
        for (let i = 0;i < resolvedSources.length; i++)
          sourcesContent.push(null);
      if (ignores)
        for (let i = 0;i < ignores.length; i++)
          ignoreList.push(ignores[i] + sourcesOffset);
      for (let i = 0;i < decoded.length; i++) {
        const lineI = lineOffset + i;
        if (lineI > stopLine)
          return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          const column = cOffset + seg[COLUMN];
          if (lineI === stopLine && column >= stopColumn)
            return;
          if (seg.length === 1) {
            out.push([column]);
            continue;
          }
          const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
          const sourceLine = seg[SOURCE_LINE];
          const sourceColumn = seg[SOURCE_COLUMN];
          out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
        }
      }
    }
    function append(arr, other) {
      for (let i = 0;i < other.length; i++)
        arr.push(other[i]);
    }
    function getLine(arr, index) {
      for (let i = arr.length;i <= index; i++)
        arr[i] = [];
      return arr[index];
    }
    var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
    var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
    var LEAST_UPPER_BOUND = -1;
    var GREATEST_LOWER_BOUND = 1;
    var TraceMap = class {
      constructor(map, mapUrl) {
        const isString = typeof map === "string";
        if (!isString && map._decodedMemo)
          return map;
        const parsed = parse(map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
        const resolve = resolver(mapUrl, sourceRoot);
        this.resolvedSources = sources.map(resolve);
        const { mappings } = parsed;
        if (typeof mappings === "string") {
          this._encoded = mappings;
          this._decoded = undefined;
        } else if (Array.isArray(mappings)) {
          this._encoded = undefined;
          this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) {
          throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        } else {
          throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        }
        this._decodedMemo = memoizedState();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
      }
    };
    function cast(map) {
      return map;
    }
    function encodedMappings(map) {
      var _a, _b;
      return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);
    }
    function decodedMappings(map) {
      var _a;
      return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));
    }
    function traceSegment(map, line, column) {
      const decoded = decodedMappings(map);
      if (line >= decoded.length)
        return null;
      const segments = decoded[line];
      const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
      return index === -1 ? null : segments[index];
    }
    function originalPositionFor(map, needle) {
      let { line, column, bias } = needle;
      line--;
      if (line < 0)
        throw new Error(LINE_GTR_ZERO);
      if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
      const decoded = decodedMappings(map);
      if (line >= decoded.length)
        return OMapping(null, null, null, null);
      const segments = decoded[line];
      const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
      if (index === -1)
        return OMapping(null, null, null, null);
      const segment = segments[index];
      if (segment.length === 1)
        return OMapping(null, null, null, null);
      const { names, resolvedSources } = map;
      return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
    }
    function generatedPositionFor(map, needle) {
      const { source, line, column, bias } = needle;
      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
    }
    function allGeneratedPositionsFor(map, needle) {
      const { source, line, column, bias } = needle;
      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
    }
    function eachMapping(map, cb) {
      const decoded = decodedMappings(map);
      const { names, resolvedSources } = map;
      for (let i = 0;i < decoded.length; i++) {
        const line = decoded[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          const generatedLine = i + 1;
          const generatedColumn = seg[0];
          let source = null;
          let originalLine = null;
          let originalColumn = null;
          let name = null;
          if (seg.length !== 1) {
            source = resolvedSources[seg[1]];
            originalLine = seg[2] + 1;
            originalColumn = seg[3];
          }
          if (seg.length === 5)
            name = names[seg[4]];
          cb({
            generatedLine,
            generatedColumn,
            source,
            originalLine,
            originalColumn,
            name
          });
        }
      }
    }
    function sourceIndex(map, source) {
      const { sources, resolvedSources } = map;
      let index = sources.indexOf(source);
      if (index === -1)
        index = resolvedSources.indexOf(source);
      return index;
    }
    function sourceContentFor(map, source) {
      const { sourcesContent } = map;
      if (sourcesContent == null)
        return null;
      const index = sourceIndex(map, source);
      return index === -1 ? null : sourcesContent[index];
    }
    function isIgnored(map, source) {
      const { ignoreList } = map;
      if (ignoreList == null)
        return false;
      const index = sourceIndex(map, source);
      return index === -1 ? false : ignoreList.includes(index);
    }
    function presortedDecodedMap(map, mapUrl) {
      const tracer = new TraceMap(clone(map, []), mapUrl);
      cast(tracer)._decoded = map.mappings;
      return tracer;
    }
    function decodedMap(map) {
      return clone(map, decodedMappings(map));
    }
    function encodedMap(map) {
      return clone(map, encodedMappings(map));
    }
    function clone(map, mappings) {
      return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings,
        ignoreList: map.ignoreList || map.x_google_ignoreList
      };
    }
    function OMapping(source, line, column, name) {
      return { source, line, column, name };
    }
    function GMapping(line, column) {
      return { line, column };
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
      let index = memoizedBinarySearch(segments, column, memo, line);
      if (found) {
        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
      } else if (bias === LEAST_UPPER_BOUND)
        index++;
      if (index === -1 || index === segments.length)
        return -1;
      return index;
    }
    function sliceGeneratedPositions(segments, memo, line, column, bias) {
      let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
      if (!found && bias === LEAST_UPPER_BOUND)
        min++;
      if (min === -1 || min === segments.length)
        return [];
      const matchedColumn = found ? column : segments[min][COLUMN];
      if (!found)
        min = lowerBound(segments, matchedColumn, min);
      const max = upperBound(segments, matchedColumn, min);
      const result = [];
      for (;min <= max; min++) {
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
      }
      return result;
    }
    function generatedPosition(map, source, line, column, bias, all) {
      var _a;
      line--;
      if (line < 0)
        throw new Error(LINE_GTR_ZERO);
      if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
      const { sources, resolvedSources } = map;
      let sourceIndex2 = sources.indexOf(source);
      if (sourceIndex2 === -1)
        sourceIndex2 = resolvedSources.indexOf(source);
      if (sourceIndex2 === -1)
        return all ? [] : GMapping(null, null);
      const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
      const segments = generated[sourceIndex2][line];
      if (segments == null)
        return all ? [] : GMapping(null, null);
      const memo = cast(map)._bySourceMemos[sourceIndex2];
      if (all)
        return sliceGeneratedPositions(segments, memo, line, column, bias);
      const index = traceSegmentInternal(segments, memo, line, column, bias);
      if (index === -1)
        return GMapping(null, null);
      const segment = segments[index];
      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
    }
  });
});

// ../../../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS((exports, module) => {
  (function(global2, factory, m) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(module, require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.sourcemapCodec, global2.traceMapping), global2.genMapping = ("default" in m.exports) ? m.exports.default : m.exports);
  })(exports, function(module2, require_sourcemapCodec, require_traceMapping) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var require_sourcemap_codec = __commonJS2({
      "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
        module22.exports = require_sourcemapCodec;
      }
    });
    var require_trace_mapping = __commonJS2({
      "umd:@jridgewell/trace-mapping"(exports2, module22) {
        module22.exports = require_traceMapping;
      }
    });
    var gen_mapping_exports = {};
    __export(gen_mapping_exports, {
      GenMapping: () => GenMapping,
      addMapping: () => addMapping,
      addSegment: () => addSegment,
      allMappings: () => allMappings,
      fromMap: () => fromMap,
      maybeAddMapping: () => maybeAddMapping,
      maybeAddSegment: () => maybeAddSegment,
      setIgnore: () => setIgnore,
      setSourceContent: () => setSourceContent,
      toDecodedMap: () => toDecodedMap,
      toEncodedMap: () => toEncodedMap
    });
    module2.exports = __toCommonJS(gen_mapping_exports);
    var SetArray = class {
      constructor() {
        this._indexes = { __proto__: null };
        this.array = [];
      }
    };
    function cast(set) {
      return set;
    }
    function get(setarr, key) {
      return cast(setarr)._indexes[key];
    }
    function put(setarr, key) {
      const index = get(setarr, key);
      if (index !== undefined)
        return index;
      const { array, _indexes: indexes } = cast(setarr);
      const length = array.push(key);
      return indexes[key] = length - 1;
    }
    function remove(setarr, key) {
      const index = get(setarr, key);
      if (index === undefined)
        return;
      const { array, _indexes: indexes } = cast(setarr);
      for (let i = index + 1;i < array.length; i++) {
        const k = array[i];
        array[i - 1] = k;
        indexes[k]--;
      }
      indexes[key] = undefined;
      array.pop();
    }
    var import_sourcemap_codec = __toESM2(require_sourcemap_codec());
    var import_trace_mapping = __toESM2(require_trace_mapping());
    var COLUMN = 0;
    var SOURCES_INDEX = 1;
    var SOURCE_LINE = 2;
    var SOURCE_COLUMN = 3;
    var NAMES_INDEX = 4;
    var NO_NAME = -1;
    var GenMapping = class {
      constructor({ file, sourceRoot } = {}) {
        this._names = new SetArray;
        this._sources = new SetArray;
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray;
      }
    };
    function cast2(map) {
      return map;
    }
    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
      return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    }
    function addMapping(map, mapping) {
      return addMappingInternal(false, map, mapping);
    }
    var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
      return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    var maybeAddMapping = (map, mapping) => {
      return addMappingInternal(true, map, mapping);
    };
    function setSourceContent(map, source, content) {
      const {
        _sources: sources,
        _sourcesContent: sourcesContent
      } = cast2(map);
      const index = put(sources, source);
      sourcesContent[index] = content;
    }
    function setIgnore(map, source, ignore = true) {
      const {
        _sources: sources,
        _sourcesContent: sourcesContent,
        _ignoreList: ignoreList
      } = cast2(map);
      const index = put(sources, source);
      if (index === sourcesContent.length)
        sourcesContent[index] = null;
      if (ignore)
        put(ignoreList, index);
      else
        remove(ignoreList, index);
    }
    function toDecodedMap(map) {
      const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names,
        _ignoreList: ignoreList
      } = cast2(map);
      removeEmptyFinalLines(mappings);
      return {
        version: 3,
        file: map.file || undefined,
        names: names.array,
        sourceRoot: map.sourceRoot || undefined,
        sources: sources.array,
        sourcesContent,
        mappings,
        ignoreList: ignoreList.array
      };
    }
    function toEncodedMap(map) {
      const decoded = toDecodedMap(map);
      return Object.assign({}, decoded, {
        mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
      });
    }
    function fromMap(input) {
      const map = new import_trace_mapping.TraceMap(input);
      const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
      putAll(cast2(gen)._names, map.names);
      putAll(cast2(gen)._sources, map.sources);
      cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
      cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
      if (map.ignoreList)
        putAll(cast2(gen)._ignoreList, map.ignoreList);
      return gen;
    }
    function allMappings(map) {
      const out = [];
      const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
      for (let i = 0;i < mappings.length; i++) {
        const line = mappings[i];
        for (let j = 0;j < line.length; j++) {
          const seg = line[j];
          const generated = { line: i + 1, column: seg[COLUMN] };
          let source = undefined;
          let original = undefined;
          let name = undefined;
          if (seg.length !== 1) {
            source = sources.array[seg[SOURCES_INDEX]];
            original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
            if (seg.length === 5)
              name = names.array[seg[NAMES_INDEX]];
          }
          out.push({ generated, source, original, name });
        }
      }
      return out;
    }
    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
      const {
        _mappings: mappings,
        _sources: sources,
        _sourcesContent: sourcesContent,
        _names: names
      } = cast2(map);
      const line = getIndex(mappings, genLine);
      const index = getColumnIndex(line, genColumn);
      if (!source) {
        if (skipable && skipSourceless(line, index))
          return;
        return insert(line, index, [genColumn]);
      }
      assert(sourceLine);
      assert(sourceColumn);
      const sourcesIndex = put(sources, source);
      const namesIndex = name ? put(names, name) : NO_NAME;
      if (sourcesIndex === sourcesContent.length)
        sourcesContent[sourcesIndex] = content != null ? content : null;
      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
      }
      return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
    }
    function assert(_val) {}
    function getIndex(arr, index) {
      for (let i = arr.length;i <= index; i++) {
        arr[i] = [];
      }
      return arr[index];
    }
    function getColumnIndex(line, genColumn) {
      let index = line.length;
      for (let i = index - 1;i >= 0; index = i--) {
        const current = line[i];
        if (genColumn >= current[COLUMN])
          break;
      }
      return index;
    }
    function insert(array, index, value) {
      for (let i = array.length;i > index; i--) {
        array[i] = array[i - 1];
      }
      array[index] = value;
    }
    function removeEmptyFinalLines(mappings) {
      const { length } = mappings;
      let len = length;
      for (let i = len - 1;i >= 0; len = i, i--) {
        if (mappings[i].length > 0)
          break;
      }
      if (len < length)
        mappings.length = len;
    }
    function putAll(setarr, array) {
      for (let i = 0;i < array.length; i++)
        put(setarr, array[i]);
    }
    function skipSourceless(line, index) {
      if (index === 0)
        return true;
      const prev = line[index - 1];
      return prev.length === 1;
    }
    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
      if (index === 0)
        return false;
      const prev = line[index - 1];
      if (prev.length === 1)
        return false;
      return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
    }
    function addMappingInternal(skipable, map, mapping) {
      const { generated, source, original, name, content } = mapping;
      if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
      }
      assert(original);
      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
    }
  });
});

// ../../../../node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _genMapping = require_gen_mapping_umd();
  var _traceMapping = require_trace_mapping_umd();

  class SourceMap {
    constructor(opts, code) {
      var _opts$sourceFileName;
      this._map = undefined;
      this._rawMappings = undefined;
      this._sourceFileName = undefined;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = undefined;
      const map = this._map = new _genMapping.GenMapping({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? undefined : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = undefined;
      if (opts.inputSourceMap) {
        this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
        const resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (let i = 0;i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? undefined : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
      } else if (typeof code === "object") {
        for (const sourceFileName of Object.keys(code)) {
          (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    get() {
      return (0, _genMapping.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, _genMapping.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
    }
    mark(generated, line, column, identifierName, identifierNamePos, filename) {
      var _originalMapping;
      this._rawMappings = undefined;
      let originalMapping;
      if (line != null) {
        if (this._inputMap) {
          originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
            line,
            column
          });
          if (!originalMapping.name && identifierNamePos) {
            const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
            if (originalIdentifierMapping.name) {
              identifierName = originalIdentifierMapping.name;
            }
          }
        } else {
          originalMapping = {
            source: (filename == null ? undefined : filename.replace(/\\/g, "/")) || this._sourceFileName,
            line,
            column
          };
        }
      }
      (0, _genMapping.maybeAddMapping)(this._map, {
        name: identifierName,
        generated,
        source: (_originalMapping = originalMapping) == null ? undefined : _originalMapping.source,
        original: originalMapping
      });
    }
  }
  exports.default = SourceMap;
});

// ../../../../node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Buffer2 {
    constructor(map, indentChar) {
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: undefined,
        identifierNamePos: undefined,
        line: undefined,
        column: undefined,
        filename: undefined
      };
      this._map = map;
      this._indentChar = indentChar;
      for (let i = 0;i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    _allocQueue() {
      const queue = this._queue;
      for (let i = 0;i < 16; i++) {
        queue.push({
          char: 0,
          repeat: 1,
          line: undefined,
          column: undefined,
          identifierName: undefined,
          identifierNamePos: undefined,
          filename: ""
        });
      }
    }
    _pushQueue(char, repeat, line, column, filename) {
      const cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      const item = this._queue[cursor];
      item.char = char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const map = this._map;
      const result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? undefined : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          const resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value) {
          Object.defineProperty(result, "map", {
            value,
            writable: true
          });
        },
        get rawMappings() {
          const mappings = map == null ? undefined : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value,
            writable: true
          });
        }
      };
      return result;
    }
    append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    }
    appendChar(char) {
      this._flush();
      this._appendChar(char, 1, this._sourcePosition);
    }
    queue(char) {
      if (char === 10) {
        while (this._queueCursor !== 0) {
          const char2 = this._queue[this._queueCursor - 1].char;
          if (char2 !== 32 && char2 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      const sourcePosition = this._sourcePosition;
      this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    queueIndentation(repeat) {
      if (repeat === 0)
        return;
      this._pushQueue(-1, repeat, undefined, undefined, undefined);
    }
    _flush() {
      const queueCursor = this._queueCursor;
      const queue = this._queue;
      for (let i = 0;i < queueCursor; i++) {
        const item = queue[i];
        this._appendChar(item.char, item.repeat, item);
      }
      this._queueCursor = 0;
    }
    _appendChar(char, repeat, sourcePos) {
      this._last = char;
      if (char === -1) {
        const fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== undefined) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
      }
      if (char !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
    }
    _append(str, sourcePos, maybeNewline) {
      const len = str.length;
      const position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      const {
        column,
        identifierName,
        identifierNamePos,
        filename
      } = sourcePos;
      let line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      let i = str.indexOf(`
`);
      let last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== undefined) {
          this._mark(++line, 0, null, null, filename);
        }
        i = str.indexOf(`
`, last);
      }
      position.column += len - last;
    }
    _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    removeTrailingNewline() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
        this._queueCursor--;
      }
    }
    removeLastSemicolon() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
        this._queueCursor--;
      }
    }
    getLastChar() {
      const queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    getNewlineCount() {
      const queueCursor = this._queueCursor;
      let count = 0;
      if (queueCursor === 0)
        return this._last === 10 ? 1 : 0;
      for (let i = queueCursor - 1;i >= 0; i--) {
        if (this._queue[i].char !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    endsWithCharAndNewline() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        const lastCp = queue[queueCursor - 1].char;
        if (lastCp !== 10)
          return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2].char;
        } else {
          return this._last;
        }
      }
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      const identifierName = loc.identifierName;
      const sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      this.source("end", loc);
    }
    source(prop, loc) {
      if (!this._map)
        return;
      this._normalizePosition(prop, loc, 0);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map)
        return;
      this._normalizePosition(prop, loc, columnOffset);
    }
    _normalizePosition(prop, loc, columnOffset) {
      const pos = loc[prop];
      const target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    }
    getCurrentColumn() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      let lastIndex = -1;
      let len = 0;
      for (let i = 0;i < queueCursor; i++) {
        const item = queue[i];
        if (item.char === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    getCurrentLine() {
      let count = 0;
      const queue = this._queue;
      for (let i = 0;i < this._queueCursor; i++) {
        if (queue[i].char === 10) {
          count++;
        }
      }
      return this._position.line + count;
    }
  }
  exports.default = Buffer2;
});

// ../../../../node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = shallowEqual;
  function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }
});

// ../../../../node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = deprecationWarning;
  var warnings = new Set;
  function deprecationWarning(oldName, newName, prefix = "", cacheKey = oldName) {
    if (warnings.has(cacheKey))
      return;
    warnings.add(cacheKey);
    const {
      internal,
      trace
    } = captureShortStackTrace(1, 2);
    if (internal) {
      return;
    }
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
  }
  function captureShortStackTrace(skip, length) {
    const {
      stackTraceLimit,
      prepareStackTrace
    } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace)
      return {
        internal: false,
        trace: ""
      };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map((frame) => `    at ${frame}`).join(`
`)
    };
  }
});

// ../../../../node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAccessor = isAccessor;
  exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
  exports.isArgumentPlaceholder = isArgumentPlaceholder;
  exports.isArrayExpression = isArrayExpression;
  exports.isArrayPattern = isArrayPattern;
  exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
  exports.isArrowFunctionExpression = isArrowFunctionExpression;
  exports.isAssignmentExpression = isAssignmentExpression;
  exports.isAssignmentPattern = isAssignmentPattern;
  exports.isAwaitExpression = isAwaitExpression;
  exports.isBigIntLiteral = isBigIntLiteral;
  exports.isBinary = isBinary;
  exports.isBinaryExpression = isBinaryExpression;
  exports.isBindExpression = isBindExpression;
  exports.isBlock = isBlock;
  exports.isBlockParent = isBlockParent;
  exports.isBlockStatement = isBlockStatement;
  exports.isBooleanLiteral = isBooleanLiteral;
  exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  exports.isBreakStatement = isBreakStatement;
  exports.isCallExpression = isCallExpression;
  exports.isCatchClause = isCatchClause;
  exports.isClass = isClass;
  exports.isClassAccessorProperty = isClassAccessorProperty;
  exports.isClassBody = isClassBody;
  exports.isClassDeclaration = isClassDeclaration;
  exports.isClassExpression = isClassExpression;
  exports.isClassImplements = isClassImplements;
  exports.isClassMethod = isClassMethod;
  exports.isClassPrivateMethod = isClassPrivateMethod;
  exports.isClassPrivateProperty = isClassPrivateProperty;
  exports.isClassProperty = isClassProperty;
  exports.isCompletionStatement = isCompletionStatement;
  exports.isConditional = isConditional;
  exports.isConditionalExpression = isConditionalExpression;
  exports.isContinueStatement = isContinueStatement;
  exports.isDebuggerStatement = isDebuggerStatement;
  exports.isDecimalLiteral = isDecimalLiteral;
  exports.isDeclaration = isDeclaration;
  exports.isDeclareClass = isDeclareClass;
  exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
  exports.isDeclareFunction = isDeclareFunction;
  exports.isDeclareInterface = isDeclareInterface;
  exports.isDeclareModule = isDeclareModule;
  exports.isDeclareModuleExports = isDeclareModuleExports;
  exports.isDeclareOpaqueType = isDeclareOpaqueType;
  exports.isDeclareTypeAlias = isDeclareTypeAlias;
  exports.isDeclareVariable = isDeclareVariable;
  exports.isDeclaredPredicate = isDeclaredPredicate;
  exports.isDecorator = isDecorator;
  exports.isDirective = isDirective;
  exports.isDirectiveLiteral = isDirectiveLiteral;
  exports.isDoExpression = isDoExpression;
  exports.isDoWhileStatement = isDoWhileStatement;
  exports.isEmptyStatement = isEmptyStatement;
  exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  exports.isEnumBody = isEnumBody;
  exports.isEnumBooleanBody = isEnumBooleanBody;
  exports.isEnumBooleanMember = isEnumBooleanMember;
  exports.isEnumDeclaration = isEnumDeclaration;
  exports.isEnumDefaultedMember = isEnumDefaultedMember;
  exports.isEnumMember = isEnumMember;
  exports.isEnumNumberBody = isEnumNumberBody;
  exports.isEnumNumberMember = isEnumNumberMember;
  exports.isEnumStringBody = isEnumStringBody;
  exports.isEnumStringMember = isEnumStringMember;
  exports.isEnumSymbolBody = isEnumSymbolBody;
  exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
  exports.isExportAllDeclaration = isExportAllDeclaration;
  exports.isExportDeclaration = isExportDeclaration;
  exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
  exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
  exports.isExportNamedDeclaration = isExportNamedDeclaration;
  exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  exports.isExportSpecifier = isExportSpecifier;
  exports.isExpression = isExpression;
  exports.isExpressionStatement = isExpressionStatement;
  exports.isExpressionWrapper = isExpressionWrapper;
  exports.isFile = isFile;
  exports.isFlow = isFlow;
  exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
  exports.isFlowDeclaration = isFlowDeclaration;
  exports.isFlowPredicate = isFlowPredicate;
  exports.isFlowType = isFlowType;
  exports.isFor = isFor;
  exports.isForInStatement = isForInStatement;
  exports.isForOfStatement = isForOfStatement;
  exports.isForStatement = isForStatement;
  exports.isForXStatement = isForXStatement;
  exports.isFunction = isFunction;
  exports.isFunctionDeclaration = isFunctionDeclaration;
  exports.isFunctionExpression = isFunctionExpression;
  exports.isFunctionParameter = isFunctionParameter;
  exports.isFunctionParent = isFunctionParent;
  exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  exports.isFunctionTypeParam = isFunctionTypeParam;
  exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
  exports.isIdentifier = isIdentifier;
  exports.isIfStatement = isIfStatement;
  exports.isImmutable = isImmutable;
  exports.isImport = isImport;
  exports.isImportAttribute = isImportAttribute;
  exports.isImportDeclaration = isImportDeclaration;
  exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
  exports.isImportExpression = isImportExpression;
  exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
  exports.isImportSpecifier = isImportSpecifier;
  exports.isIndexedAccessType = isIndexedAccessType;
  exports.isInferredPredicate = isInferredPredicate;
  exports.isInterfaceDeclaration = isInterfaceDeclaration;
  exports.isInterfaceExtends = isInterfaceExtends;
  exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  exports.isInterpreterDirective = isInterpreterDirective;
  exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  exports.isJSX = isJSX;
  exports.isJSXAttribute = isJSXAttribute;
  exports.isJSXClosingElement = isJSXClosingElement;
  exports.isJSXClosingFragment = isJSXClosingFragment;
  exports.isJSXElement = isJSXElement;
  exports.isJSXEmptyExpression = isJSXEmptyExpression;
  exports.isJSXExpressionContainer = isJSXExpressionContainer;
  exports.isJSXFragment = isJSXFragment;
  exports.isJSXIdentifier = isJSXIdentifier;
  exports.isJSXMemberExpression = isJSXMemberExpression;
  exports.isJSXNamespacedName = isJSXNamespacedName;
  exports.isJSXOpeningElement = isJSXOpeningElement;
  exports.isJSXOpeningFragment = isJSXOpeningFragment;
  exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
  exports.isJSXSpreadChild = isJSXSpreadChild;
  exports.isJSXText = isJSXText;
  exports.isLVal = isLVal;
  exports.isLabeledStatement = isLabeledStatement;
  exports.isLiteral = isLiteral;
  exports.isLogicalExpression = isLogicalExpression;
  exports.isLoop = isLoop;
  exports.isMemberExpression = isMemberExpression;
  exports.isMetaProperty = isMetaProperty;
  exports.isMethod = isMethod;
  exports.isMiscellaneous = isMiscellaneous;
  exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
  exports.isModuleDeclaration = isModuleDeclaration;
  exports.isModuleExpression = isModuleExpression;
  exports.isModuleSpecifier = isModuleSpecifier;
  exports.isNewExpression = isNewExpression;
  exports.isNoop = isNoop;
  exports.isNullLiteral = isNullLiteral;
  exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
  exports.isNumberLiteral = isNumberLiteral;
  exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
  exports.isNumericLiteral = isNumericLiteral;
  exports.isObjectExpression = isObjectExpression;
  exports.isObjectMember = isObjectMember;
  exports.isObjectMethod = isObjectMethod;
  exports.isObjectPattern = isObjectPattern;
  exports.isObjectProperty = isObjectProperty;
  exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
  exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
  exports.isObjectTypeIndexer = isObjectTypeIndexer;
  exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  exports.isObjectTypeProperty = isObjectTypeProperty;
  exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  exports.isOpaqueType = isOpaqueType;
  exports.isOptionalCallExpression = isOptionalCallExpression;
  exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  exports.isOptionalMemberExpression = isOptionalMemberExpression;
  exports.isParenthesizedExpression = isParenthesizedExpression;
  exports.isPattern = isPattern;
  exports.isPatternLike = isPatternLike;
  exports.isPipelineBareFunction = isPipelineBareFunction;
  exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  exports.isPipelineTopicExpression = isPipelineTopicExpression;
  exports.isPlaceholder = isPlaceholder;
  exports.isPrivate = isPrivate;
  exports.isPrivateName = isPrivateName;
  exports.isProgram = isProgram;
  exports.isProperty = isProperty;
  exports.isPureish = isPureish;
  exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  exports.isRecordExpression = isRecordExpression;
  exports.isRegExpLiteral = isRegExpLiteral;
  exports.isRegexLiteral = isRegexLiteral;
  exports.isRestElement = isRestElement;
  exports.isRestProperty = isRestProperty;
  exports.isReturnStatement = isReturnStatement;
  exports.isScopable = isScopable;
  exports.isSequenceExpression = isSequenceExpression;
  exports.isSpreadElement = isSpreadElement;
  exports.isSpreadProperty = isSpreadProperty;
  exports.isStandardized = isStandardized;
  exports.isStatement = isStatement;
  exports.isStaticBlock = isStaticBlock;
  exports.isStringLiteral = isStringLiteral;
  exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  exports.isStringTypeAnnotation = isStringTypeAnnotation;
  exports.isSuper = isSuper;
  exports.isSwitchCase = isSwitchCase;
  exports.isSwitchStatement = isSwitchStatement;
  exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  exports.isTSAnyKeyword = isTSAnyKeyword;
  exports.isTSArrayType = isTSArrayType;
  exports.isTSAsExpression = isTSAsExpression;
  exports.isTSBaseType = isTSBaseType;
  exports.isTSBigIntKeyword = isTSBigIntKeyword;
  exports.isTSBooleanKeyword = isTSBooleanKeyword;
  exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  exports.isTSConditionalType = isTSConditionalType;
  exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  exports.isTSConstructorType = isTSConstructorType;
  exports.isTSDeclareFunction = isTSDeclareFunction;
  exports.isTSDeclareMethod = isTSDeclareMethod;
  exports.isTSEntityName = isTSEntityName;
  exports.isTSEnumBody = isTSEnumBody;
  exports.isTSEnumDeclaration = isTSEnumDeclaration;
  exports.isTSEnumMember = isTSEnumMember;
  exports.isTSExportAssignment = isTSExportAssignment;
  exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  exports.isTSExternalModuleReference = isTSExternalModuleReference;
  exports.isTSFunctionType = isTSFunctionType;
  exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  exports.isTSImportType = isTSImportType;
  exports.isTSIndexSignature = isTSIndexSignature;
  exports.isTSIndexedAccessType = isTSIndexedAccessType;
  exports.isTSInferType = isTSInferType;
  exports.isTSInstantiationExpression = isTSInstantiationExpression;
  exports.isTSInterfaceBody = isTSInterfaceBody;
  exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  exports.isTSIntersectionType = isTSIntersectionType;
  exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  exports.isTSLiteralType = isTSLiteralType;
  exports.isTSMappedType = isTSMappedType;
  exports.isTSMethodSignature = isTSMethodSignature;
  exports.isTSModuleBlock = isTSModuleBlock;
  exports.isTSModuleDeclaration = isTSModuleDeclaration;
  exports.isTSNamedTupleMember = isTSNamedTupleMember;
  exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  exports.isTSNeverKeyword = isTSNeverKeyword;
  exports.isTSNonNullExpression = isTSNonNullExpression;
  exports.isTSNullKeyword = isTSNullKeyword;
  exports.isTSNumberKeyword = isTSNumberKeyword;
  exports.isTSObjectKeyword = isTSObjectKeyword;
  exports.isTSOptionalType = isTSOptionalType;
  exports.isTSParameterProperty = isTSParameterProperty;
  exports.isTSParenthesizedType = isTSParenthesizedType;
  exports.isTSPropertySignature = isTSPropertySignature;
  exports.isTSQualifiedName = isTSQualifiedName;
  exports.isTSRestType = isTSRestType;
  exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
  exports.isTSStringKeyword = isTSStringKeyword;
  exports.isTSSymbolKeyword = isTSSymbolKeyword;
  exports.isTSTemplateLiteralType = isTSTemplateLiteralType;
  exports.isTSThisType = isTSThisType;
  exports.isTSTupleType = isTSTupleType;
  exports.isTSType = isTSType;
  exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  exports.isTSTypeAnnotation = isTSTypeAnnotation;
  exports.isTSTypeAssertion = isTSTypeAssertion;
  exports.isTSTypeElement = isTSTypeElement;
  exports.isTSTypeLiteral = isTSTypeLiteral;
  exports.isTSTypeOperator = isTSTypeOperator;
  exports.isTSTypeParameter = isTSTypeParameter;
  exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  exports.isTSTypePredicate = isTSTypePredicate;
  exports.isTSTypeQuery = isTSTypeQuery;
  exports.isTSTypeReference = isTSTypeReference;
  exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
  exports.isTSUnionType = isTSUnionType;
  exports.isTSUnknownKeyword = isTSUnknownKeyword;
  exports.isTSVoidKeyword = isTSVoidKeyword;
  exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
  exports.isTemplateElement = isTemplateElement;
  exports.isTemplateLiteral = isTemplateLiteral;
  exports.isTerminatorless = isTerminatorless;
  exports.isThisExpression = isThisExpression;
  exports.isThisTypeAnnotation = isThisTypeAnnotation;
  exports.isThrowStatement = isThrowStatement;
  exports.isTopicReference = isTopicReference;
  exports.isTryStatement = isTryStatement;
  exports.isTupleExpression = isTupleExpression;
  exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
  exports.isTypeAlias = isTypeAlias;
  exports.isTypeAnnotation = isTypeAnnotation;
  exports.isTypeCastExpression = isTypeCastExpression;
  exports.isTypeParameter = isTypeParameter;
  exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
  exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
  exports.isTypeScript = isTypeScript;
  exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  exports.isUnaryExpression = isUnaryExpression;
  exports.isUnaryLike = isUnaryLike;
  exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
  exports.isUpdateExpression = isUpdateExpression;
  exports.isUserWhitespacable = isUserWhitespacable;
  exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  exports.isVariableDeclaration = isVariableDeclaration;
  exports.isVariableDeclarator = isVariableDeclarator;
  exports.isVariance = isVariance;
  exports.isVoidPattern = isVoidPattern;
  exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
  exports.isWhile = isWhile;
  exports.isWhileStatement = isWhileStatement;
  exports.isWithStatement = isWithStatement;
  exports.isYieldExpression = isYieldExpression;
  var _shallowEqual = require_shallowEqual();
  var _deprecationWarning = require_deprecationWarning();
  function isArrayExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isAssignmentExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AssignmentExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBinaryExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BinaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isInterpreterDirective(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterpreterDirective")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDirective(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Directive")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDirectiveLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DirectiveLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBlockStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BlockStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBreakStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BreakStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isCallExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "CallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isCatchClause(node, opts) {
    if (!node)
      return false;
    if (node.type !== "CatchClause")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isConditionalExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ConditionalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isContinueStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ContinueStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDebuggerStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DebuggerStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDoWhileStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DoWhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEmptyStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EmptyStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExpressionStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExpressionStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFile(node, opts) {
    if (!node)
      return false;
    if (node.type !== "File")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isForInStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForInStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isForStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isIdentifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Identifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isIfStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isLabeledStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "LabeledStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStringLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNumericLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumericLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNullLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBooleanLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isRegExpLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RegExpLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isLogicalExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "LogicalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isMemberExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNewExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NewExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isProgram(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Program")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectMethod(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isRestElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RestElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isReturnStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ReturnStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSequenceExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SequenceExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isParenthesizedExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ParenthesizedExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSwitchCase(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SwitchCase")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSwitchStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SwitchStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isThisExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThisExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isThrowStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThrowStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTryStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TryStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isUnaryExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UnaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isUpdateExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UpdateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isVariableDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VariableDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isVariableDeclarator(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VariableDeclarator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isWhileStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "WhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isWithStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "WithStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isAssignmentPattern(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AssignmentPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isArrayPattern(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrowFunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportAllDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportDefaultDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportNamedDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isForOfStatement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForOfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isMetaProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MetaProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassMethod(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectPattern(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSpreadElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SpreadElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSuper(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Super")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TaggedTemplateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTemplateElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TemplateElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTemplateLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TemplateLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isYieldExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "YieldExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isAwaitExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AwaitExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImport(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Import")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBigIntLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BigIntLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isOptionalCallExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalCallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassAccessorProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassAccessorProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassPrivateProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassPrivateProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassPrivateMethod(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassPrivateMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPrivateName(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PrivateName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStaticBlock(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StaticBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportAttribute(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AnyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClassImplements(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassImplements")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareClass(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareClass")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareFunction(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareInterface(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareInterface")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareModule(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareModule")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareModuleExports(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareModuleExports")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareTypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareOpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareVariable(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareVariable")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclaredPredicate(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclaredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExistsTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionTypeParam(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionTypeParam")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "GenericTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isInferredPredicate(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InferredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isInterfaceExtends(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceExtends")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IntersectionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MixedTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EmptyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullableTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumberLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumberTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeInternalSlot")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeCallProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeIndexer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeSpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isOpaqueType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "QualifiedTypeIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SymbolTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThisTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TupleTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeofTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeAlias(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeCastExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeCastExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeParameter(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UnionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isVariance(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Variance")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VoidTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumBooleanBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumBooleanBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumNumberBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumNumberBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumStringBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumStringBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumSymbolBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumSymbolBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumBooleanMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumBooleanMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumNumberMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumNumberMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumStringMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumStringMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumDefaultedMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isIndexedAccessType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isOptionalIndexedAccessType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXAttribute(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXClosingElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXClosingElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXEmptyExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXExpressionContainer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXSpreadChild(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXSpreadChild")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXIdentifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXMemberExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXNamespacedName(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXNamespacedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXOpeningElement(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXOpeningElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXSpreadAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXText(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXText")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXFragment(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXOpeningFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSXClosingFragment(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXClosingFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNoop(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Noop")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPlaceholder(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Placeholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "V8IntrinsicIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArgumentPlaceholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBindExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BindExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDecorator(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Decorator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDoExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DoExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isRecordExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RecordExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTupleExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TupleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDecimalLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DecimalLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isModuleExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ModuleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTopicReference(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelineTopicExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPipelineBareFunction(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelineBareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelinePrimaryTopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isVoidPattern(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VoidPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSParameterProperty(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSParameterProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSDeclareFunction(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSDeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSDeclareMethod(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSDeclareMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSQualifiedName(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSQualifiedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSCallSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConstructSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSPropertySignature(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSPropertySignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSMethodSignature(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSMethodSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSIndexSignature(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIndexSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSAnyKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSAnyKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSBooleanKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSBigIntKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIntrinsicKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNeverKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNeverKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNullKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNullKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNumberKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNumberKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSObjectKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSObjectKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSStringKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSStringKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSSymbolKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUndefinedKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUnknownKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSVoidKeyword(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSVoidKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSThisType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSThisType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSFunctionType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSFunctionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSConstructorType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConstructorType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeReference(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypePredicate(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypePredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeQuery(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeQuery")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeLiteral(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSArrayType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSArrayType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTupleType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTupleType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSOptionalType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSOptionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSRestType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSRestType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNamedTupleMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSUnionType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUnionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSIntersectionType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIntersectionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSConditionalType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConditionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSInferType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInferType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSParenthesizedType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSParenthesizedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeOperator(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeOperator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSMappedType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSMappedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTemplateLiteralType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTemplateLiteralType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSLiteralType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSLiteralType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExpressionWithTypeArguments")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSInterfaceBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInterfaceBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAliasDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSInstantiationExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInstantiationExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSAsExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSAsExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSSatisfiesExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSSatisfiesExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeAssertion(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAssertion")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSEnumBody(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSEnumBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSEnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSEnumMember(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSEnumMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSModuleDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSModuleBlock(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSModuleBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSImportType(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSImportType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSImportEqualsDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExternalModuleReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNonNullExpression(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNonNullExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSExportAssignment(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExportAssignment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNamespaceExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeParameter(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStandardized(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExpression(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBinary(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isScopable(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBlockParent(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isBlock(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isStatement(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTerminatorless(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isCompletionStatement(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isConditional(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isLoop(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isWhile(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExpressionWrapper(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFor(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isForXStatement(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunction(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionParent(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPureish(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isDeclaration(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (node.expectedNode === "Declaration")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFunctionParameter(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPatternLike(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isLVal(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "OptionalMemberExpression":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSEntityName(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isLiteral(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImmutable(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isUserWhitespacable(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isMethod(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isObjectMember(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isProperty(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isUnaryLike(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPattern(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Pattern")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isClass(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isImportOrExportDeclaration(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isExportDeclaration(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isModuleSpecifier(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isAccessor(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isPrivate(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFlow(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFlowType(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFlowDeclaration(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isFlowPredicate(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumBody(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isEnumMember(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isJSX(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isMiscellaneous(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTypeScript(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSTypeElement(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSType(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isTSBaseType(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isNumberLiteral(node, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node)
      return false;
    if (node.type !== "NumberLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isRegexLiteral(node, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node)
      return false;
    if (node.type !== "RegexLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isRestProperty(node, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node)
      return false;
    if (node.type !== "RestProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isSpreadProperty(node, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node)
      return false;
    if (node.type !== "SpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  }
  function isModuleDeclaration(node, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matchesPattern;
  var _index = require_generated();
  function isMemberExpressionLike(node) {
    return (0, _index.isMemberExpression)(node) || (0, _index.isMetaProperty)(node);
  }
  function matchesPattern(member, match, allowPartial) {
    if (!isMemberExpressionLike(member))
      return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for (node = member;isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {
      var _object;
      nodes.push(node.property);
    }
    nodes.push(node);
    if (nodes.length < parts.length)
      return false;
    if (!allowPartial && nodes.length > parts.length)
      return false;
    for (let i = 0, j = nodes.length - 1;i < parts.length; i++, j--) {
      const node2 = nodes[j];
      let value;
      if ((0, _index.isIdentifier)(node2)) {
        value = node2.name;
      } else if ((0, _index.isStringLiteral)(node2)) {
        value = node2.value;
      } else if ((0, _index.isThisExpression)(node2)) {
        value = "this";
      } else if ((0, _index.isSuper)(node2)) {
        value = "super";
      } else if ((0, _index.isPrivateName)(node2)) {
        value = "#" + node2.id.name;
      } else {
        return false;
      }
      if (parts[i] !== value)
        return false;
    }
    return true;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildMatchMemberExpression;
  var _matchesPattern = require_matchesPattern();
  function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
  var _default = exports.default = isReactComponent;
});

// ../../../../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCompatTag;
  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isType;
  var _index = require_definitions();
  function isType(nodeType, targetType) {
    if (nodeType === targetType)
      return true;
    if (nodeType == null)
      return false;
    if (_index.ALIAS_KEYS[targetType])
      return false;
    const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases != null && aliases.includes(nodeType))
      return true;
    return false;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPlaceholderType;
  var _index = require_definitions();
  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType)
      return true;
    const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases != null && aliases.includes(targetType))
      return true;
    return false;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = is;
  var _shallowEqual = require_shallowEqual();
  var _isType = require_isType();
  var _isPlaceholderType = require_isPlaceholderType();
  var _index = require_definitions();
  function is(type, node, opts) {
    if (!node)
      return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }
      return false;
    }
    if (opts === undefined) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
});

// ../../../../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierName = isIdentifierName;
  exports.isIdentifierStart = isIdentifierStart;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length;i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let i = 0;i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
});

// ../../../../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isKeyword = isKeyword;
  exports.isReservedWord = isReservedWord;
  exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports.isStrictBindReservedWord = isStrictBindReservedWord;
  exports.isStrictReservedWord = isStrictReservedWord;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
});

// ../../../../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// ../../../../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidIdentifier;
  var _helperValidatorIdentifier = require_lib3();
  function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string")
      return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  }
});

// ../../../../node_modules/@babel/helper-string-parser/lib/index.js
var require_lib4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.readCodePoint = readCodePoint;
  exports.readInt = readInt;
  exports.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (;; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + `
`;
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res(`
`);
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({
          code,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len;i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code,
      pos
    };
  }
});

// ../../../../node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = undefined;
  var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
  var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
  var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  var INHERIT_KEYS = exports.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  {
    exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// ../../../../node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = undefined;
  exports.arrayOf = arrayOf;
  exports.arrayOfType = arrayOfType;
  exports.assertEach = assertEach;
  exports.assertNodeOrValueType = assertNodeOrValueType;
  exports.assertNodeType = assertNodeType;
  exports.assertOneOf = assertOneOf;
  exports.assertOptionalChainStart = assertOptionalChainStart;
  exports.assertShape = assertShape;
  exports.assertValueType = assertValueType;
  exports.chain = chain;
  exports.default = defineType;
  exports.defineAliasedType = defineAliasedType;
  exports.validate = validate;
  exports.validateArrayOfType = validateArrayOfType;
  exports.validateOptional = validateOptional;
  exports.validateOptionalType = validateOptionalType;
  exports.validateType = validateType;
  var _is = require_is();
  var _validate = require_validate();
  var VISITOR_KEYS = exports.VISITOR_KEYS = {};
  var ALIAS_KEYS = exports.ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = exports.NODE_FIELDS = {};
  var BUILDER_KEYS = exports.BUILDER_KEYS = {};
  var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate(validate2) {
    return {
      validate: validate2
    };
  }
  function validateType(...typeNames) {
    return validate(assertNodeType(...typeNames));
  }
  function validateOptional(validate2) {
    return {
      validate: validate2,
      optional: true
    };
  }
  function validateOptionalType(...typeNames) {
    return {
      validate: assertNodeType(...typeNames),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(...typeNames) {
    return arrayOf(assertNodeType(...typeNames));
  }
  function validateArrayOfType(...typeNames) {
    return validate(arrayOfType(...typeNames));
  }
  function assertEach(callback) {
    const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {};
    function validator(node, key, val) {
      if (!Array.isArray(val))
        return;
      let i = 0;
      const subKey = {
        toString() {
          return `${key}[${i}]`;
        }
      };
      for (;i < val.length; i++) {
        const v = val[i];
        callback(node, subKey, v);
        childValidator(node, subKey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf(...values) {
    function validate2(node, key, val) {
      if (!values.includes(val)) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }
    validate2.oneOf = values;
    return validate2;
  }
  var allExpandedTypes = exports.allExpandedTypes = [];
  function assertNodeType(...types) {
    const expandedTypes = new Set;
    allExpandedTypes.push({
      types,
      set: expandedTypes
    });
    function validate2(node, key, val) {
      const valType = val == null ? undefined : val.type;
      if (valType != null) {
        if (expandedTypes.has(valType)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
        if (valType === "Placeholder") {
          for (const type of types) {
            if ((0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node, key, val);
              return;
            }
          }
        }
      }
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(valType)}`);
    }
    validate2.oneOfNodeTypes = types;
    return validate2;
  }
  function assertNodeOrValueType(...types) {
    function validate2(node, key, val) {
      const primitiveType = getType(val);
      for (const type of types) {
        if (primitiveType === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? undefined : val.type)}`);
    }
    validate2.oneOfNodeOrValueTypes = types;
    return validate2;
  }
  function assertValueType(type) {
    function validate2(node, key, val) {
      if (getType(val) === type) {
        return;
      }
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate2.type = type;
    return validate2;
  }
  function assertShape(shape) {
    const keys = Object.keys(shape);
    function validate2(node, key, val) {
      const errors = [];
      for (const property of keys) {
        try {
          (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join(`
`)}`);
      }
    }
    validate2.shapeOf = shape;
    return validate2;
  }
  function assertOptionalChainStart() {
    function validate2(node) {
      var _current;
      let current = node;
      while (node) {
        const {
          type
        } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional)
            return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional)
            return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? undefined : _current.type}`);
    }
    return validate2;
  }
  function chain(...fns) {
    function validate2(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate2.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    return validate2;
  }
  var validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
  var validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);
  var store = {};
  function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$;
        if (opts.inherits)
          defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? undefined : _store$opts$inherits$.slice();
        defined != null || (defined = []);
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      defineType(type, opts);
    };
  }
  function defineType(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);
        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (!validTypeOpts.has(k)) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== undefined && !builder.includes(key)) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (!validFieldKeys.has(k)) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  }
});

// ../../../../node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = undefined;
  var _is = require_is();
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib3();
  var _helperStringParser = require_lib4();
  var _index = require_constants();
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
          const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils.assertOneOf)("=");
          return function(node, key, val) {
            const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }(), {
          oneOf: _index.ASSIGNMENT_OPERATORS
        })
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.operator === "in" ? inOp : expression;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  var functionCommon = () => ({
    params: (0, _utils.validateArrayOfType)("FunctionParameter"),
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  exports.functionCommon = functionCommon;
  var functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  });
  exports.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function() {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  var patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  exports.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (!(0, _isValidIdentifier.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node) {
      const match = /\.(\w+)$/.exec(key.toString());
      if (!match)
        return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp))
          return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
          return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp))
          return;
        if ((0, _is.default)("Method", parent, nonComp))
          return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent))
          return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node
        }))
          return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, {
          meta: node
        }))
          return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
        throw new TypeError(`"${node.name}" is not a valid identifier`);
      }
    } : undefined
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
          if (1 / val < 0 || !Number.isFinite(val)) {
            const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);
            {}
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string"),
        default: ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        default: false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, shorthand) {
          if (!shorthand)
            return;
          if (node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
          if (!(0, _is.default)("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      const expression = (0, _utils.assertNodeType)("Expression");
      return function(parent, key, node) {
        const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
      const match = /(\w+)\[(\d+)\]/.exec(key.toString());
      if (!match)
        throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    } : undefined
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, _utils.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: (0, _utils.validateArrayOfType)("SwitchCase")
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, _utils.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      const withoutInit = (0, _utils.assertNodeType)("Identifier", "Placeholder");
      const constOrLetOrVar = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder");
      const usingOrAwaitUsing = (0, _utils.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
      return function(parent, key, node) {
        const {
          kind,
          declarations
        } = node;
        const parentIsForX = (0, _is.default)("ForXStatement", parent, {
          left: node
        });
        if (parentIsForX) {
          if (declarations.length !== 1) {
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          }
        }
        for (const decl of declarations) {
          if (kind === "const" || kind === "let" || kind === "var") {
            if (!parentIsForX && !decl.init) {
              withoutInit(decl, "id", decl.id);
            } else {
              constOrLetOrVar(decl, "id", decl.id);
            }
          } else {
            usingOrAwaitUsing(decl, "id", decl.id);
          }
        }
      };
    })() : undefined
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "VoidPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern")
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function() {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  var importAttributes = exports.importAttributes = {
    attributes: {
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: true,
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    }
  };
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, importAttributes)
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: true,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, _utils.assertNodeType)("Declaration")
      }
    }, importAttributes, {
      specifiers: {
        default: [],
        validate: (0, _utils.arrayOf)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return sourced;
          return Object.assign(function(node, key, val) {
            const validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          });
        }())
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    })
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(node, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, importAttributes, {
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    })
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!(0, _is.default)("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, _utils.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils.chain)(function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: (0, _utils.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      ["typeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node) {
          const raw = node.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          };
          const {
            str,
            firstInvalidLoc
          } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
            unterminated() {
              unterminatedCalled = true;
            },
            strictNumericEscape: error,
            invalidEscapeSequence: error,
            numericSeparatorInEscapeSequence: error,
            unexpectedNumericSeparator: error,
            invalidDigit: error,
            invalidCodePoint: error
          });
          if (!unterminatedCalled)
            throw new Error("Invalid raw");
          node.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        default: false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  defineType("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS(() => {
  var _core = require_core();
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("Flow");
  var defineInterfaceishType = (name) => {
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }, _core.importAttributes)
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, _core.importAttributes)
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)("Identifier", "StringLiteral"),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS(() => {
  var _utils = require_utils();
  var defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = undefined;
  var _utils = require_utils();
  var PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length)
      PLACEHOLDERS_ALIAS[type] = alias;
  }
  var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS(() => {
  var _utils = require_utils();
  var _placeholders = require_placeholders();
  var _core = require_core();
  var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }, (0, _core.patternLikeCommon)())
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS(() => {
  var _utils = require_utils();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  {
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
  }
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS(() => {
  var _utils = require_utils();
  var _core = require_core();
  var _is = require_is();
  var defineType = (0, _utils.defineAliasedType)("TypeScript");
  var bool = (0, _utils.assertValueType)("boolean");
  var tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  var signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  });
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, _utils.validateOptional)(bool)
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: true,
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: (0, _utils.assertValueType)("string")
      },
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }, {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    })
  });
  defineType("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(parent, key, node) {
            if ((0, _is.default)("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        }()
      }
    }
  });
  {
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
  }
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSEnumMember")
    }
  });
  {
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
  }
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, _utils.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, _utils.validateOptional)(bool)
    }, {
      global: (0, _utils.validateOptional)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, _utils.assertNodeType)("ObjectExpression"),
        optional: true
      }
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, _utils.validate)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    })
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSType")
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSTypeParameter")
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      in: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      const: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
});

// ../../../../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEPRECATED_ALIASES = undefined;
  var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../../../../node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.BUILDER_KEYS;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_ALIASES", {
    enumerable: true,
    get: function() {
      return _deprecatedAliases.DEPRECATED_ALIASES;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.DEPRECATED_KEYS;
    }
  });
  Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.FLIPPED_ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_FIELDS;
    }
  });
  Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_PARENT_VALIDATIONS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_ALIAS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  });
  exports.TYPES = undefined;
  Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.VISITOR_KEYS;
    }
  });
  require_core();
  require_flow();
  require_jsx();
  require_misc();
  require_experimental();
  require_typescript();
  var _utils = require_utils();
  var _placeholders = require_placeholders();
  var _deprecatedAliases = require_deprecated_aliases();
  Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
    _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
  });
  for (const {
    types,
    set
  } of _utils.allExpandedTypes) {
    for (const type of types) {
      const aliases = _utils.FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        aliases.forEach(set.add, set);
      } else {
        set.add(type);
      }
    }
  }
  var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
});

// ../../../../node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validate;
  exports.validateChild = validateChild;
  exports.validateField = validateField;
  exports.validateInternal = validateInternal;
  var _index = require_definitions();
  function validate(node, key, val) {
    if (!node)
      return;
    const fields = _index.NODE_FIELDS[node.type];
    if (!fields)
      return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateInternal(field, node, key, val, maybeNode) {
    if (!(field != null && field.validate))
      return;
    if (field.optional && val == null)
      return;
    field.validate(node, key, val);
    if (maybeNode) {
      var _NODE_PARENT_VALIDATI;
      const type = val.type;
      if (type == null)
        return;
      (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
    }
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate))
      return;
    if (field.optional && val == null)
      return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    var _NODE_PARENT_VALIDATI2;
    const type = val == null ? undefined : val.type;
    if (type == null)
      return;
    (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
  }
});

// ../../../../node_modules/@babel/types/lib/builders/generated/lowercase.js
var require_lowercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.anyTypeAnnotation = anyTypeAnnotation;
  exports.argumentPlaceholder = argumentPlaceholder;
  exports.arrayExpression = arrayExpression;
  exports.arrayPattern = arrayPattern;
  exports.arrayTypeAnnotation = arrayTypeAnnotation;
  exports.arrowFunctionExpression = arrowFunctionExpression;
  exports.assignmentExpression = assignmentExpression;
  exports.assignmentPattern = assignmentPattern;
  exports.awaitExpression = awaitExpression;
  exports.bigIntLiteral = bigIntLiteral;
  exports.binaryExpression = binaryExpression;
  exports.bindExpression = bindExpression;
  exports.blockStatement = blockStatement;
  exports.booleanLiteral = booleanLiteral;
  exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  exports.booleanTypeAnnotation = booleanTypeAnnotation;
  exports.breakStatement = breakStatement;
  exports.callExpression = callExpression;
  exports.catchClause = catchClause;
  exports.classAccessorProperty = classAccessorProperty;
  exports.classBody = classBody;
  exports.classDeclaration = classDeclaration;
  exports.classExpression = classExpression;
  exports.classImplements = classImplements;
  exports.classMethod = classMethod;
  exports.classPrivateMethod = classPrivateMethod;
  exports.classPrivateProperty = classPrivateProperty;
  exports.classProperty = classProperty;
  exports.conditionalExpression = conditionalExpression;
  exports.continueStatement = continueStatement;
  exports.debuggerStatement = debuggerStatement;
  exports.decimalLiteral = decimalLiteral;
  exports.declareClass = declareClass;
  exports.declareExportAllDeclaration = declareExportAllDeclaration;
  exports.declareExportDeclaration = declareExportDeclaration;
  exports.declareFunction = declareFunction;
  exports.declareInterface = declareInterface;
  exports.declareModule = declareModule;
  exports.declareModuleExports = declareModuleExports;
  exports.declareOpaqueType = declareOpaqueType;
  exports.declareTypeAlias = declareTypeAlias;
  exports.declareVariable = declareVariable;
  exports.declaredPredicate = declaredPredicate;
  exports.decorator = decorator;
  exports.directive = directive;
  exports.directiveLiteral = directiveLiteral;
  exports.doExpression = doExpression;
  exports.doWhileStatement = doWhileStatement;
  exports.emptyStatement = emptyStatement;
  exports.emptyTypeAnnotation = emptyTypeAnnotation;
  exports.enumBooleanBody = enumBooleanBody;
  exports.enumBooleanMember = enumBooleanMember;
  exports.enumDeclaration = enumDeclaration;
  exports.enumDefaultedMember = enumDefaultedMember;
  exports.enumNumberBody = enumNumberBody;
  exports.enumNumberMember = enumNumberMember;
  exports.enumStringBody = enumStringBody;
  exports.enumStringMember = enumStringMember;
  exports.enumSymbolBody = enumSymbolBody;
  exports.existsTypeAnnotation = existsTypeAnnotation;
  exports.exportAllDeclaration = exportAllDeclaration;
  exports.exportDefaultDeclaration = exportDefaultDeclaration;
  exports.exportDefaultSpecifier = exportDefaultSpecifier;
  exports.exportNamedDeclaration = exportNamedDeclaration;
  exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
  exports.exportSpecifier = exportSpecifier;
  exports.expressionStatement = expressionStatement;
  exports.file = file;
  exports.forInStatement = forInStatement;
  exports.forOfStatement = forOfStatement;
  exports.forStatement = forStatement;
  exports.functionDeclaration = functionDeclaration;
  exports.functionExpression = functionExpression;
  exports.functionTypeAnnotation = functionTypeAnnotation;
  exports.functionTypeParam = functionTypeParam;
  exports.genericTypeAnnotation = genericTypeAnnotation;
  exports.identifier = identifier;
  exports.ifStatement = ifStatement;
  exports.import = _import;
  exports.importAttribute = importAttribute;
  exports.importDeclaration = importDeclaration;
  exports.importDefaultSpecifier = importDefaultSpecifier;
  exports.importExpression = importExpression;
  exports.importNamespaceSpecifier = importNamespaceSpecifier;
  exports.importSpecifier = importSpecifier;
  exports.indexedAccessType = indexedAccessType;
  exports.inferredPredicate = inferredPredicate;
  exports.interfaceDeclaration = interfaceDeclaration;
  exports.interfaceExtends = interfaceExtends;
  exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
  exports.interpreterDirective = interpreterDirective;
  exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
  exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
  exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
  exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
  exports.jSXElement = exports.jsxElement = jsxElement;
  exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
  exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
  exports.jSXFragment = exports.jsxFragment = jsxFragment;
  exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
  exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
  exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
  exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
  exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
  exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
  exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
  exports.jSXText = exports.jsxText = jsxText;
  exports.labeledStatement = labeledStatement;
  exports.logicalExpression = logicalExpression;
  exports.memberExpression = memberExpression;
  exports.metaProperty = metaProperty;
  exports.mixedTypeAnnotation = mixedTypeAnnotation;
  exports.moduleExpression = moduleExpression;
  exports.newExpression = newExpression;
  exports.noop = noop;
  exports.nullLiteral = nullLiteral;
  exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  exports.nullableTypeAnnotation = nullableTypeAnnotation;
  exports.numberLiteral = NumberLiteral;
  exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  exports.numberTypeAnnotation = numberTypeAnnotation;
  exports.numericLiteral = numericLiteral;
  exports.objectExpression = objectExpression;
  exports.objectMethod = objectMethod;
  exports.objectPattern = objectPattern;
  exports.objectProperty = objectProperty;
  exports.objectTypeAnnotation = objectTypeAnnotation;
  exports.objectTypeCallProperty = objectTypeCallProperty;
  exports.objectTypeIndexer = objectTypeIndexer;
  exports.objectTypeInternalSlot = objectTypeInternalSlot;
  exports.objectTypeProperty = objectTypeProperty;
  exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
  exports.opaqueType = opaqueType;
  exports.optionalCallExpression = optionalCallExpression;
  exports.optionalIndexedAccessType = optionalIndexedAccessType;
  exports.optionalMemberExpression = optionalMemberExpression;
  exports.parenthesizedExpression = parenthesizedExpression;
  exports.pipelineBareFunction = pipelineBareFunction;
  exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  exports.pipelineTopicExpression = pipelineTopicExpression;
  exports.placeholder = placeholder;
  exports.privateName = privateName;
  exports.program = program;
  exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  exports.recordExpression = recordExpression;
  exports.regExpLiteral = regExpLiteral;
  exports.regexLiteral = RegexLiteral;
  exports.restElement = restElement;
  exports.restProperty = RestProperty;
  exports.returnStatement = returnStatement;
  exports.sequenceExpression = sequenceExpression;
  exports.spreadElement = spreadElement;
  exports.spreadProperty = SpreadProperty;
  exports.staticBlock = staticBlock;
  exports.stringLiteral = stringLiteral;
  exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  exports.stringTypeAnnotation = stringTypeAnnotation;
  exports.super = _super;
  exports.switchCase = switchCase;
  exports.switchStatement = switchStatement;
  exports.symbolTypeAnnotation = symbolTypeAnnotation;
  exports.taggedTemplateExpression = taggedTemplateExpression;
  exports.templateElement = templateElement;
  exports.templateLiteral = templateLiteral;
  exports.thisExpression = thisExpression;
  exports.thisTypeAnnotation = thisTypeAnnotation;
  exports.throwStatement = throwStatement;
  exports.topicReference = topicReference;
  exports.tryStatement = tryStatement;
  exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
  exports.tSArrayType = exports.tsArrayType = tsArrayType;
  exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
  exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
  exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
  exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
  exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
  exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
  exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
  exports.tSEnumBody = exports.tsEnumBody = tsEnumBody;
  exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
  exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
  exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
  exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
  exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
  exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  exports.tSImportType = exports.tsImportType = tsImportType;
  exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
  exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
  exports.tSInferType = exports.tsInferType = tsInferType;
  exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
  exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
  exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
  exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
  exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
  exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
  exports.tSMappedType = exports.tsMappedType = tsMappedType;
  exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
  exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
  exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
  exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
  exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
  exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
  exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
  exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
  exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
  exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
  exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
  exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
  exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
  exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
  exports.tSRestType = exports.tsRestType = tsRestType;
  exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
  exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
  exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
  exports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;
  exports.tSThisType = exports.tsThisType = tsThisType;
  exports.tSTupleType = exports.tsTupleType = tsTupleType;
  exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
  exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
  exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
  exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
  exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
  exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
  exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
  exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
  exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
  exports.tSUnionType = exports.tsUnionType = tsUnionType;
  exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
  exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
  exports.tupleExpression = tupleExpression;
  exports.tupleTypeAnnotation = tupleTypeAnnotation;
  exports.typeAlias = typeAlias;
  exports.typeAnnotation = typeAnnotation;
  exports.typeCastExpression = typeCastExpression;
  exports.typeParameter = typeParameter;
  exports.typeParameterDeclaration = typeParameterDeclaration;
  exports.typeParameterInstantiation = typeParameterInstantiation;
  exports.typeofTypeAnnotation = typeofTypeAnnotation;
  exports.unaryExpression = unaryExpression;
  exports.unionTypeAnnotation = unionTypeAnnotation;
  exports.updateExpression = updateExpression;
  exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  exports.variableDeclaration = variableDeclaration;
  exports.variableDeclarator = variableDeclarator;
  exports.variance = variance;
  exports.voidPattern = voidPattern;
  exports.voidTypeAnnotation = voidTypeAnnotation;
  exports.whileStatement = whileStatement;
  exports.withStatement = withStatement;
  exports.yieldExpression = yieldExpression;
  var _validate = require_validate();
  var _deprecationWarning = require_deprecationWarning();
  var utils = require_utils();
  var {
    validateInternal: validate
  } = _validate;
  var {
    NODE_FIELDS
  } = utils;
  function bigIntLiteral(value) {
    if (typeof value === "bigint") {
      value = value.toString();
    }
    const node = {
      type: "BigIntLiteral",
      value
    };
    const defs = NODE_FIELDS.BigIntLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function arrayExpression(elements = []) {
    const node = {
      type: "ArrayExpression",
      elements
    };
    const defs = NODE_FIELDS.ArrayExpression;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function assignmentExpression(operator, left, right) {
    const node = {
      type: "AssignmentExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function binaryExpression(operator, left, right) {
    const node = {
      type: "BinaryExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.BinaryExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function interpreterDirective(value) {
    const node = {
      type: "InterpreterDirective",
      value
    };
    const defs = NODE_FIELDS.InterpreterDirective;
    validate(defs.value, node, "value", value);
    return node;
  }
  function directive(value) {
    const node = {
      type: "Directive",
      value
    };
    const defs = NODE_FIELDS.Directive;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function directiveLiteral(value) {
    const node = {
      type: "DirectiveLiteral",
      value
    };
    const defs = NODE_FIELDS.DirectiveLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function blockStatement(body, directives = []) {
    const node = {
      type: "BlockStatement",
      body,
      directives
    };
    const defs = NODE_FIELDS.BlockStatement;
    validate(defs.body, node, "body", body, 1);
    validate(defs.directives, node, "directives", directives, 1);
    return node;
  }
  function breakStatement(label = null) {
    const node = {
      type: "BreakStatement",
      label
    };
    const defs = NODE_FIELDS.BreakStatement;
    validate(defs.label, node, "label", label, 1);
    return node;
  }
  function callExpression(callee, _arguments) {
    const node = {
      type: "CallExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.CallExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function catchClause(param = null, body) {
    const node = {
      type: "CatchClause",
      param,
      body
    };
    const defs = NODE_FIELDS.CatchClause;
    validate(defs.param, node, "param", param, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function conditionalExpression(test, consequent, alternate) {
    const node = {
      type: "ConditionalExpression",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.ConditionalExpression;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    validate(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function continueStatement(label = null) {
    const node = {
      type: "ContinueStatement",
      label
    };
    const defs = NODE_FIELDS.ContinueStatement;
    validate(defs.label, node, "label", label, 1);
    return node;
  }
  function debuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  }
  function doWhileStatement(test, body) {
    const node = {
      type: "DoWhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.DoWhileStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function emptyStatement() {
    return {
      type: "EmptyStatement"
    };
  }
  function expressionStatement(expression) {
    const node = {
      type: "ExpressionStatement",
      expression
    };
    const defs = NODE_FIELDS.ExpressionStatement;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function file(program2, comments = null, tokens = null) {
    const node = {
      type: "File",
      program: program2,
      comments,
      tokens
    };
    const defs = NODE_FIELDS.File;
    validate(defs.program, node, "program", program2, 1);
    validate(defs.comments, node, "comments", comments, 1);
    validate(defs.tokens, node, "tokens", tokens);
    return node;
  }
  function forInStatement(left, right, body) {
    const node = {
      type: "ForInStatement",
      left,
      right,
      body
    };
    const defs = NODE_FIELDS.ForInStatement;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function forStatement(init = null, test = null, update = null, body) {
    const node = {
      type: "ForStatement",
      init,
      test,
      update,
      body
    };
    const defs = NODE_FIELDS.ForStatement;
    validate(defs.init, node, "init", init, 1);
    validate(defs.test, node, "test", test, 1);
    validate(defs.update, node, "update", update, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function functionDeclaration(id = null, params, body, generator = false, async = false) {
    const node = {
      type: "FunctionDeclaration",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function functionExpression(id = null, params, body, generator = false, async = false) {
    const node = {
      type: "FunctionExpression",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionExpression;
    validate(defs.id, node, "id", id, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function identifier(name) {
    const node = {
      type: "Identifier",
      name
    };
    const defs = NODE_FIELDS.Identifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function ifStatement(test, consequent, alternate = null) {
    const node = {
      type: "IfStatement",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.IfStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    validate(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function labeledStatement(label, body) {
    const node = {
      type: "LabeledStatement",
      label,
      body
    };
    const defs = NODE_FIELDS.LabeledStatement;
    validate(defs.label, node, "label", label, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function stringLiteral(value) {
    const node = {
      type: "StringLiteral",
      value
    };
    const defs = NODE_FIELDS.StringLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function numericLiteral(value) {
    const node = {
      type: "NumericLiteral",
      value
    };
    const defs = NODE_FIELDS.NumericLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function nullLiteral() {
    return {
      type: "NullLiteral"
    };
  }
  function booleanLiteral(value) {
    const node = {
      type: "BooleanLiteral",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function regExpLiteral(pattern, flags = "") {
    const node = {
      type: "RegExpLiteral",
      pattern,
      flags
    };
    const defs = NODE_FIELDS.RegExpLiteral;
    validate(defs.pattern, node, "pattern", pattern);
    validate(defs.flags, node, "flags", flags);
    return node;
  }
  function logicalExpression(operator, left, right) {
    const node = {
      type: "LogicalExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.LogicalExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function memberExpression(object, property, computed = false, optional = null) {
    const node = {
      type: "MemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.MemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function newExpression(callee, _arguments) {
    const node = {
      type: "NewExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.NewExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function program(body, directives = [], sourceType = "script", interpreter = null) {
    const node = {
      type: "Program",
      body,
      directives,
      sourceType,
      interpreter
    };
    const defs = NODE_FIELDS.Program;
    validate(defs.body, node, "body", body, 1);
    validate(defs.directives, node, "directives", directives, 1);
    validate(defs.sourceType, node, "sourceType", sourceType);
    validate(defs.interpreter, node, "interpreter", interpreter, 1);
    return node;
  }
  function objectExpression(properties) {
    const node = {
      type: "ObjectExpression",
      properties
    };
    const defs = NODE_FIELDS.ObjectExpression;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    const node = {
      type: "ObjectMethod",
      kind,
      key,
      params,
      body,
      computed,
      generator,
      async
    };
    const defs = NODE_FIELDS.ObjectMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
    const node = {
      type: "ObjectProperty",
      key,
      value,
      computed,
      shorthand,
      decorators
    };
    const defs = NODE_FIELDS.ObjectProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.shorthand, node, "shorthand", shorthand);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function restElement(argument) {
    const node = {
      type: "RestElement",
      argument
    };
    const defs = NODE_FIELDS.RestElement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function returnStatement(argument = null) {
    const node = {
      type: "ReturnStatement",
      argument
    };
    const defs = NODE_FIELDS.ReturnStatement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function sequenceExpression(expressions) {
    const node = {
      type: "SequenceExpression",
      expressions
    };
    const defs = NODE_FIELDS.SequenceExpression;
    validate(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function parenthesizedExpression(expression) {
    const node = {
      type: "ParenthesizedExpression",
      expression
    };
    const defs = NODE_FIELDS.ParenthesizedExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function switchCase(test = null, consequent) {
    const node = {
      type: "SwitchCase",
      test,
      consequent
    };
    const defs = NODE_FIELDS.SwitchCase;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    return node;
  }
  function switchStatement(discriminant, cases) {
    const node = {
      type: "SwitchStatement",
      discriminant,
      cases
    };
    const defs = NODE_FIELDS.SwitchStatement;
    validate(defs.discriminant, node, "discriminant", discriminant, 1);
    validate(defs.cases, node, "cases", cases, 1);
    return node;
  }
  function thisExpression() {
    return {
      type: "ThisExpression"
    };
  }
  function throwStatement(argument) {
    const node = {
      type: "ThrowStatement",
      argument
    };
    const defs = NODE_FIELDS.ThrowStatement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function tryStatement(block, handler = null, finalizer = null) {
    const node = {
      type: "TryStatement",
      block,
      handler,
      finalizer
    };
    const defs = NODE_FIELDS.TryStatement;
    validate(defs.block, node, "block", block, 1);
    validate(defs.handler, node, "handler", handler, 1);
    validate(defs.finalizer, node, "finalizer", finalizer, 1);
    return node;
  }
  function unaryExpression(operator, argument, prefix = true) {
    const node = {
      type: "UnaryExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UnaryExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function updateExpression(operator, argument, prefix = false) {
    const node = {
      type: "UpdateExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UpdateExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function variableDeclaration(kind, declarations) {
    const node = {
      type: "VariableDeclaration",
      kind,
      declarations
    };
    const defs = NODE_FIELDS.VariableDeclaration;
    validate(defs.kind, node, "kind", kind);
    validate(defs.declarations, node, "declarations", declarations, 1);
    return node;
  }
  function variableDeclarator(id, init = null) {
    const node = {
      type: "VariableDeclarator",
      id,
      init
    };
    const defs = NODE_FIELDS.VariableDeclarator;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function whileStatement(test, body) {
    const node = {
      type: "WhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.WhileStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function withStatement(object, body) {
    const node = {
      type: "WithStatement",
      object,
      body
    };
    const defs = NODE_FIELDS.WithStatement;
    validate(defs.object, node, "object", object, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function assignmentPattern(left, right) {
    const node = {
      type: "AssignmentPattern",
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentPattern;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function arrayPattern(elements) {
    const node = {
      type: "ArrayPattern",
      elements
    };
    const defs = NODE_FIELDS.ArrayPattern;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function arrowFunctionExpression(params, body, async = false) {
    const node = {
      type: "ArrowFunctionExpression",
      params,
      body,
      async,
      expression: null
    };
    const defs = NODE_FIELDS.ArrowFunctionExpression;
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.async, node, "async", async);
    return node;
  }
  function classBody(body) {
    const node = {
      type: "ClassBody",
      body
    };
    const defs = NODE_FIELDS.ClassBody;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function classExpression(id = null, superClass = null, body, decorators = null) {
    const node = {
      type: "ClassExpression",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassExpression;
    validate(defs.id, node, "id", id, 1);
    validate(defs.superClass, node, "superClass", superClass, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function classDeclaration(id = null, superClass = null, body, decorators = null) {
    const node = {
      type: "ClassDeclaration",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.superClass, node, "superClass", superClass, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function exportAllDeclaration(source) {
    const node = {
      type: "ExportAllDeclaration",
      source
    };
    const defs = NODE_FIELDS.ExportAllDeclaration;
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function exportDefaultDeclaration(declaration) {
    const node = {
      type: "ExportDefaultDeclaration",
      declaration
    };
    const defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    return node;
  }
  function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    const node = {
      type: "ExportNamedDeclaration",
      declaration,
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ExportNamedDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function exportSpecifier(local, exported) {
    const node = {
      type: "ExportSpecifier",
      local,
      exported
    };
    const defs = NODE_FIELDS.ExportSpecifier;
    validate(defs.local, node, "local", local, 1);
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function forOfStatement(left, right, body, _await = false) {
    const node = {
      type: "ForOfStatement",
      left,
      right,
      body,
      await: _await
    };
    const defs = NODE_FIELDS.ForOfStatement;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.await, node, "await", _await);
    return node;
  }
  function importDeclaration(specifiers, source) {
    const node = {
      type: "ImportDeclaration",
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ImportDeclaration;
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function importDefaultSpecifier(local) {
    const node = {
      type: "ImportDefaultSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate(defs.local, node, "local", local, 1);
    return node;
  }
  function importNamespaceSpecifier(local) {
    const node = {
      type: "ImportNamespaceSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate(defs.local, node, "local", local, 1);
    return node;
  }
  function importSpecifier(local, imported) {
    const node = {
      type: "ImportSpecifier",
      local,
      imported
    };
    const defs = NODE_FIELDS.ImportSpecifier;
    validate(defs.local, node, "local", local, 1);
    validate(defs.imported, node, "imported", imported, 1);
    return node;
  }
  function importExpression(source, options = null) {
    const node = {
      type: "ImportExpression",
      source,
      options
    };
    const defs = NODE_FIELDS.ImportExpression;
    validate(defs.source, node, "source", source, 1);
    validate(defs.options, node, "options", options, 1);
    return node;
  }
  function metaProperty(meta, property) {
    const node = {
      type: "MetaProperty",
      meta,
      property
    };
    const defs = NODE_FIELDS.MetaProperty;
    validate(defs.meta, node, "meta", meta, 1);
    validate(defs.property, node, "property", property, 1);
    return node;
  }
  function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    const node = {
      type: "ClassMethod",
      kind,
      key,
      params,
      body,
      computed,
      static: _static,
      generator,
      async
    };
    const defs = NODE_FIELDS.ClassMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.static, node, "static", _static);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function objectPattern(properties) {
    const node = {
      type: "ObjectPattern",
      properties
    };
    const defs = NODE_FIELDS.ObjectPattern;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function spreadElement(argument) {
    const node = {
      type: "SpreadElement",
      argument
    };
    const defs = NODE_FIELDS.SpreadElement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _super() {
    return {
      type: "Super"
    };
  }
  function taggedTemplateExpression(tag, quasi) {
    const node = {
      type: "TaggedTemplateExpression",
      tag,
      quasi
    };
    const defs = NODE_FIELDS.TaggedTemplateExpression;
    validate(defs.tag, node, "tag", tag, 1);
    validate(defs.quasi, node, "quasi", quasi, 1);
    return node;
  }
  function templateElement(value, tail = false) {
    const node = {
      type: "TemplateElement",
      value,
      tail
    };
    const defs = NODE_FIELDS.TemplateElement;
    validate(defs.value, node, "value", value);
    validate(defs.tail, node, "tail", tail);
    return node;
  }
  function templateLiteral(quasis, expressions) {
    const node = {
      type: "TemplateLiteral",
      quasis,
      expressions
    };
    const defs = NODE_FIELDS.TemplateLiteral;
    validate(defs.quasis, node, "quasis", quasis, 1);
    validate(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function yieldExpression(argument = null, delegate = false) {
    const node = {
      type: "YieldExpression",
      argument,
      delegate
    };
    const defs = NODE_FIELDS.YieldExpression;
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.delegate, node, "delegate", delegate);
    return node;
  }
  function awaitExpression(argument) {
    const node = {
      type: "AwaitExpression",
      argument
    };
    const defs = NODE_FIELDS.AwaitExpression;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _import() {
    return {
      type: "Import"
    };
  }
  function exportNamespaceSpecifier(exported) {
    const node = {
      type: "ExportNamespaceSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function optionalMemberExpression(object, property, computed = false, optional) {
    const node = {
      type: "OptionalMemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.OptionalMemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function optionalCallExpression(callee, _arguments, optional) {
    const node = {
      type: "OptionalCallExpression",
      callee,
      arguments: _arguments,
      optional
    };
    const defs = NODE_FIELDS.OptionalCallExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
      type: "ClassProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.static, node, "static", _static);
    return node;
  }
  function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node = {
      type: "ClassAccessorProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassAccessorProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.static, node, "static", _static);
    return node;
  }
  function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    const node = {
      type: "ClassPrivateProperty",
      key,
      value,
      decorators,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.static, node, "static", _static);
    return node;
  }
  function classPrivateMethod(kind = "method", key, params, body, _static = false) {
    const node = {
      type: "ClassPrivateMethod",
      kind,
      key,
      params,
      body,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.static, node, "static", _static);
    return node;
  }
  function privateName(id) {
    const node = {
      type: "PrivateName",
      id
    };
    const defs = NODE_FIELDS.PrivateName;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function staticBlock(body) {
    const node = {
      type: "StaticBlock",
      body
    };
    const defs = NODE_FIELDS.StaticBlock;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function importAttribute(key, value) {
    const node = {
      type: "ImportAttribute",
      key,
      value
    };
    const defs = NODE_FIELDS.ImportAttribute;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function anyTypeAnnotation() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function arrayTypeAnnotation(elementType) {
    const node = {
      type: "ArrayTypeAnnotation",
      elementType
    };
    const defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function booleanTypeAnnotation() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function booleanLiteralTypeAnnotation(value) {
    const node = {
      type: "BooleanLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function nullLiteralTypeAnnotation() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function classImplements(id, typeParameters = null) {
    const node = {
      type: "ClassImplements",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.ClassImplements;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function declareClass(id, typeParameters = null, _extends = null, body) {
    const node = {
      type: "DeclareClass",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareClass;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.extends, node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function declareFunction(id) {
    const node = {
      type: "DeclareFunction",
      id
    };
    const defs = NODE_FIELDS.DeclareFunction;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function declareInterface(id, typeParameters = null, _extends = null, body) {
    const node = {
      type: "DeclareInterface",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareInterface;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.extends, node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function declareModule(id, body, kind = null) {
    const node = {
      type: "DeclareModule",
      id,
      body,
      kind
    };
    const defs = NODE_FIELDS.DeclareModule;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.kind, node, "kind", kind);
    return node;
  }
  function declareModuleExports(typeAnnotation2) {
    const node = {
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.DeclareModuleExports;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function declareTypeAlias(id, typeParameters = null, right) {
    const node = {
      type: "DeclareTypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.DeclareTypeAlias;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function declareOpaqueType(id, typeParameters = null, supertype = null) {
    const node = {
      type: "DeclareOpaqueType",
      id,
      typeParameters,
      supertype
    };
    const defs = NODE_FIELDS.DeclareOpaqueType;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.supertype, node, "supertype", supertype, 1);
    return node;
  }
  function declareVariable(id) {
    const node = {
      type: "DeclareVariable",
      id
    };
    const defs = NODE_FIELDS.DeclareVariable;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
    const node = {
      type: "DeclareExportDeclaration",
      declaration,
      specifiers,
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declareExportAllDeclaration(source, attributes = null) {
    const node = {
      type: "DeclareExportAllDeclaration",
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate(defs.source, node, "source", source, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declaredPredicate(value) {
    const node = {
      type: "DeclaredPredicate",
      value
    };
    const defs = NODE_FIELDS.DeclaredPredicate;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function existsTypeAnnotation() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    const node = {
      type: "FunctionTypeAnnotation",
      typeParameters,
      params,
      rest,
      returnType
    };
    const defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.rest, node, "rest", rest, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function functionTypeParam(name = null, typeAnnotation2) {
    const node = {
      type: "FunctionTypeParam",
      name,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.FunctionTypeParam;
    validate(defs.name, node, "name", name, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function genericTypeAnnotation(id, typeParameters = null) {
    const node = {
      type: "GenericTypeAnnotation",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.GenericTypeAnnotation;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function inferredPredicate() {
    return {
      type: "InferredPredicate"
    };
  }
  function interfaceExtends(id, typeParameters = null) {
    const node = {
      type: "InterfaceExtends",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.InterfaceExtends;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node = {
      type: "InterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.extends, node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function interfaceTypeAnnotation(_extends = null, body) {
    const node = {
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate(defs.extends, node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function intersectionTypeAnnotation(types) {
    const node = {
      type: "IntersectionTypeAnnotation",
      types
    };
    const defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function mixedTypeAnnotation() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function emptyTypeAnnotation() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function nullableTypeAnnotation(typeAnnotation2) {
    const node = {
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.NullableTypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function numberLiteralTypeAnnotation(value) {
    const node = {
      type: "NumberLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function numberTypeAnnotation() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    const node = {
      type: "ObjectTypeAnnotation",
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact
    };
    const defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate(defs.properties, node, "properties", properties, 1);
    validate(defs.indexers, node, "indexers", indexers, 1);
    validate(defs.callProperties, node, "callProperties", callProperties, 1);
    validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
    validate(defs.exact, node, "exact", exact);
    return node;
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    const node = {
      type: "ObjectTypeInternalSlot",
      id,
      value,
      optional,
      static: _static,
      method
    };
    const defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate(defs.id, node, "id", id, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.optional, node, "optional", optional);
    validate(defs.static, node, "static", _static);
    validate(defs.method, node, "method", method);
    return node;
  }
  function objectTypeCallProperty(value) {
    const node = {
      type: "ObjectTypeCallProperty",
      value,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function objectTypeIndexer(id = null, key, value, variance2 = null) {
    const node = {
      type: "ObjectTypeIndexer",
      id,
      key,
      value,
      variance: variance2,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeIndexer;
    validate(defs.id, node, "id", id, 1);
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.variance, node, "variance", variance2, 1);
    return node;
  }
  function objectTypeProperty(key, value, variance2 = null) {
    const node = {
      type: "ObjectTypeProperty",
      key,
      value,
      variance: variance2,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.variance, node, "variance", variance2, 1);
    return node;
  }
  function objectTypeSpreadProperty(argument) {
    const node = {
      type: "ObjectTypeSpreadProperty",
      argument
    };
    const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    const node = {
      type: "OpaqueType",
      id,
      typeParameters,
      supertype,
      impltype
    };
    const defs = NODE_FIELDS.OpaqueType;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.supertype, node, "supertype", supertype, 1);
    validate(defs.impltype, node, "impltype", impltype, 1);
    return node;
  }
  function qualifiedTypeIdentifier(id, qualification) {
    const node = {
      type: "QualifiedTypeIdentifier",
      id,
      qualification
    };
    const defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate(defs.id, node, "id", id, 1);
    validate(defs.qualification, node, "qualification", qualification, 1);
    return node;
  }
  function stringLiteralTypeAnnotation(value) {
    const node = {
      type: "StringLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function stringTypeAnnotation() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function symbolTypeAnnotation() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function thisTypeAnnotation() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function tupleTypeAnnotation(types) {
    const node = {
      type: "TupleTypeAnnotation",
      types
    };
    const defs = NODE_FIELDS.TupleTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function typeofTypeAnnotation(argument) {
    const node = {
      type: "TypeofTypeAnnotation",
      argument
    };
    const defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function typeAlias(id, typeParameters = null, right) {
    const node = {
      type: "TypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.TypeAlias;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function typeAnnotation(typeAnnotation2) {
    const node = {
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function typeCastExpression(expression, typeAnnotation2) {
    const node = {
      type: "TypeCastExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeCastExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function typeParameter(bound = null, _default = null, variance2 = null) {
    const node = {
      type: "TypeParameter",
      bound,
      default: _default,
      variance: variance2,
      name: null
    };
    const defs = NODE_FIELDS.TypeParameter;
    validate(defs.bound, node, "bound", bound, 1);
    validate(defs.default, node, "default", _default, 1);
    validate(defs.variance, node, "variance", variance2, 1);
    return node;
  }
  function typeParameterDeclaration(params) {
    const node = {
      type: "TypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TypeParameterDeclaration;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function typeParameterInstantiation(params) {
    const node = {
      type: "TypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TypeParameterInstantiation;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function unionTypeAnnotation(types) {
    const node = {
      type: "UnionTypeAnnotation",
      types
    };
    const defs = NODE_FIELDS.UnionTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function variance(kind) {
    const node = {
      type: "Variance",
      kind
    };
    const defs = NODE_FIELDS.Variance;
    validate(defs.kind, node, "kind", kind);
    return node;
  }
  function voidTypeAnnotation() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function enumDeclaration(id, body) {
    const node = {
      type: "EnumDeclaration",
      id,
      body
    };
    const defs = NODE_FIELDS.EnumDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function enumBooleanBody(members) {
    const node = {
      type: "EnumBooleanBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumBooleanBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumNumberBody(members) {
    const node = {
      type: "EnumNumberBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumNumberBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumStringBody(members) {
    const node = {
      type: "EnumStringBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumStringBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumSymbolBody(members) {
    const node = {
      type: "EnumSymbolBody",
      members,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumSymbolBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumBooleanMember(id) {
    const node = {
      type: "EnumBooleanMember",
      id,
      init: null
    };
    const defs = NODE_FIELDS.EnumBooleanMember;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function enumNumberMember(id, init) {
    const node = {
      type: "EnumNumberMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumNumberMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function enumStringMember(id, init) {
    const node = {
      type: "EnumStringMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumStringMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function enumDefaultedMember(id) {
    const node = {
      type: "EnumDefaultedMember",
      id
    };
    const defs = NODE_FIELDS.EnumDefaultedMember;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function indexedAccessType(objectType, indexType) {
    const node = {
      type: "IndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.IndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function optionalIndexedAccessType(objectType, indexType) {
    const node = {
      type: "OptionalIndexedAccessType",
      objectType,
      indexType,
      optional: null
    };
    const defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function jsxAttribute(name, value = null) {
    const node = {
      type: "JSXAttribute",
      name,
      value
    };
    const defs = NODE_FIELDS.JSXAttribute;
    validate(defs.name, node, "name", name, 1);
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function jsxClosingElement(name) {
    const node = {
      type: "JSXClosingElement",
      name
    };
    const defs = NODE_FIELDS.JSXClosingElement;
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
    const node = {
      type: "JSXElement",
      openingElement,
      closingElement,
      children,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXElement;
    validate(defs.openingElement, node, "openingElement", openingElement, 1);
    validate(defs.closingElement, node, "closingElement", closingElement, 1);
    validate(defs.children, node, "children", children, 1);
    validate(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxEmptyExpression() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function jsxExpressionContainer(expression) {
    const node = {
      type: "JSXExpressionContainer",
      expression
    };
    const defs = NODE_FIELDS.JSXExpressionContainer;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxSpreadChild(expression) {
    const node = {
      type: "JSXSpreadChild",
      expression
    };
    const defs = NODE_FIELDS.JSXSpreadChild;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxIdentifier(name) {
    const node = {
      type: "JSXIdentifier",
      name
    };
    const defs = NODE_FIELDS.JSXIdentifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function jsxMemberExpression(object, property) {
    const node = {
      type: "JSXMemberExpression",
      object,
      property
    };
    const defs = NODE_FIELDS.JSXMemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    return node;
  }
  function jsxNamespacedName(namespace, name) {
    const node = {
      type: "JSXNamespacedName",
      namespace,
      name
    };
    const defs = NODE_FIELDS.JSXNamespacedName;
    validate(defs.namespace, node, "namespace", namespace, 1);
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxOpeningElement(name, attributes, selfClosing = false) {
    const node = {
      type: "JSXOpeningElement",
      name,
      attributes,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXOpeningElement;
    validate(defs.name, node, "name", name, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    validate(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxSpreadAttribute(argument) {
    const node = {
      type: "JSXSpreadAttribute",
      argument
    };
    const defs = NODE_FIELDS.JSXSpreadAttribute;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function jsxText(value) {
    const node = {
      type: "JSXText",
      value
    };
    const defs = NODE_FIELDS.JSXText;
    validate(defs.value, node, "value", value);
    return node;
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    const node = {
      type: "JSXFragment",
      openingFragment,
      closingFragment,
      children
    };
    const defs = NODE_FIELDS.JSXFragment;
    validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
    validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
    validate(defs.children, node, "children", children, 1);
    return node;
  }
  function jsxOpeningFragment() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function jsxClosingFragment() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function noop() {
    return {
      type: "Noop"
    };
  }
  function placeholder(expectedNode, name) {
    const node = {
      type: "Placeholder",
      expectedNode,
      name
    };
    const defs = NODE_FIELDS.Placeholder;
    validate(defs.expectedNode, node, "expectedNode", expectedNode);
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function v8IntrinsicIdentifier(name) {
    const node = {
      type: "V8IntrinsicIdentifier",
      name
    };
    const defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function argumentPlaceholder() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function bindExpression(object, callee) {
    const node = {
      type: "BindExpression",
      object,
      callee
    };
    const defs = NODE_FIELDS.BindExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function decorator(expression) {
    const node = {
      type: "Decorator",
      expression
    };
    const defs = NODE_FIELDS.Decorator;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function doExpression(body, async = false) {
    const node = {
      type: "DoExpression",
      body,
      async
    };
    const defs = NODE_FIELDS.DoExpression;
    validate(defs.body, node, "body", body, 1);
    validate(defs.async, node, "async", async);
    return node;
  }
  function exportDefaultSpecifier(exported) {
    const node = {
      type: "ExportDefaultSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function recordExpression(properties) {
    const node = {
      type: "RecordExpression",
      properties
    };
    const defs = NODE_FIELDS.RecordExpression;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function tupleExpression(elements = []) {
    const node = {
      type: "TupleExpression",
      elements
    };
    const defs = NODE_FIELDS.TupleExpression;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function decimalLiteral(value) {
    const node = {
      type: "DecimalLiteral",
      value
    };
    const defs = NODE_FIELDS.DecimalLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function moduleExpression(body) {
    const node = {
      type: "ModuleExpression",
      body
    };
    const defs = NODE_FIELDS.ModuleExpression;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function topicReference() {
    return {
      type: "TopicReference"
    };
  }
  function pipelineTopicExpression(expression) {
    const node = {
      type: "PipelineTopicExpression",
      expression
    };
    const defs = NODE_FIELDS.PipelineTopicExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function pipelineBareFunction(callee) {
    const node = {
      type: "PipelineBareFunction",
      callee
    };
    const defs = NODE_FIELDS.PipelineBareFunction;
    validate(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function pipelinePrimaryTopicReference() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function voidPattern() {
    return {
      type: "VoidPattern"
    };
  }
  function tsParameterProperty(parameter) {
    const node = {
      type: "TSParameterProperty",
      parameter
    };
    const defs = NODE_FIELDS.TSParameterProperty;
    validate(defs.parameter, node, "parameter", parameter, 1);
    return node;
  }
  function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    const node = {
      type: "TSDeclareFunction",
      id,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareFunction;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    const node = {
      type: "TSDeclareMethod",
      decorators,
      key,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareMethod;
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsQualifiedName(left, right) {
    const node = {
      type: "TSQualifiedName",
      left,
      right
    };
    const defs = NODE_FIELDS.TSQualifiedName;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSCallSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSConstructSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsPropertySignature(key, typeAnnotation2 = null) {
    const node = {
      type: "TSPropertySignature",
      key,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSPropertySignature;
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSMethodSignature",
      key,
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2,
      kind: null
    };
    const defs = NODE_FIELDS.TSMethodSignature;
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsIndexSignature(parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSIndexSignature",
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSIndexSignature;
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsAnyKeyword() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function tsBooleanKeyword() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function tsBigIntKeyword() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function tsIntrinsicKeyword() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function tsNeverKeyword() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function tsNullKeyword() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tsNumberKeyword() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function tsObjectKeyword() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function tsStringKeyword() {
    return {
      type: "TSStringKeyword"
    };
  }
  function tsSymbolKeyword() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function tsUndefinedKeyword() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function tsUnknownKeyword() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function tsVoidKeyword() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function tsThisType() {
    return {
      type: "TSThisType"
    };
  }
  function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSFunctionType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSFunctionType;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node = {
      type: "TSConstructorType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructorType;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsTypeReference(typeName, typeParameters = null) {
    const node = {
      type: "TSTypeReference",
      typeName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeReference;
    validate(defs.typeName, node, "typeName", typeName, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
    const node = {
      type: "TSTypePredicate",
      parameterName,
      typeAnnotation: typeAnnotation2,
      asserts
    };
    const defs = NODE_FIELDS.TSTypePredicate;
    validate(defs.parameterName, node, "parameterName", parameterName, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.asserts, node, "asserts", asserts);
    return node;
  }
  function tsTypeQuery(exprName, typeParameters = null) {
    const node = {
      type: "TSTypeQuery",
      exprName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeQuery;
    validate(defs.exprName, node, "exprName", exprName, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypeLiteral(members) {
    const node = {
      type: "TSTypeLiteral",
      members
    };
    const defs = NODE_FIELDS.TSTypeLiteral;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsArrayType(elementType) {
    const node = {
      type: "TSArrayType",
      elementType
    };
    const defs = NODE_FIELDS.TSArrayType;
    validate(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function tsTupleType(elementTypes) {
    const node = {
      type: "TSTupleType",
      elementTypes
    };
    const defs = NODE_FIELDS.TSTupleType;
    validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
    return node;
  }
  function tsOptionalType(typeAnnotation2) {
    const node = {
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSOptionalType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsRestType(typeAnnotation2) {
    const node = {
      type: "TSRestType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSRestType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsNamedTupleMember(label, elementType, optional = false) {
    const node = {
      type: "TSNamedTupleMember",
      label,
      elementType,
      optional
    };
    const defs = NODE_FIELDS.TSNamedTupleMember;
    validate(defs.label, node, "label", label, 1);
    validate(defs.elementType, node, "elementType", elementType, 1);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function tsUnionType(types) {
    const node = {
      type: "TSUnionType",
      types
    };
    const defs = NODE_FIELDS.TSUnionType;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsIntersectionType(types) {
    const node = {
      type: "TSIntersectionType",
      types
    };
    const defs = NODE_FIELDS.TSIntersectionType;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    const node = {
      type: "TSConditionalType",
      checkType,
      extendsType,
      trueType,
      falseType
    };
    const defs = NODE_FIELDS.TSConditionalType;
    validate(defs.checkType, node, "checkType", checkType, 1);
    validate(defs.extendsType, node, "extendsType", extendsType, 1);
    validate(defs.trueType, node, "trueType", trueType, 1);
    validate(defs.falseType, node, "falseType", falseType, 1);
    return node;
  }
  function tsInferType(typeParameter2) {
    const node = {
      type: "TSInferType",
      typeParameter: typeParameter2
    };
    const defs = NODE_FIELDS.TSInferType;
    validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
    return node;
  }
  function tsParenthesizedType(typeAnnotation2) {
    const node = {
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSParenthesizedType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsTypeOperator(typeAnnotation2, operator) {
    const node = {
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation2,
      operator
    };
    const defs = NODE_FIELDS.TSTypeOperator;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.operator, node, "operator", operator);
    return node;
  }
  function tsIndexedAccessType(objectType, indexType) {
    const node = {
      type: "TSIndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.TSIndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
    const node = {
      type: "TSMappedType",
      typeParameter: typeParameter2,
      typeAnnotation: typeAnnotation2,
      nameType
    };
    const defs = NODE_FIELDS.TSMappedType;
    validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.nameType, node, "nameType", nameType, 1);
    return node;
  }
  function tsTemplateLiteralType(quasis, types) {
    const node = {
      type: "TSTemplateLiteralType",
      quasis,
      types
    };
    const defs = NODE_FIELDS.TSTemplateLiteralType;
    validate(defs.quasis, node, "quasis", quasis, 1);
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsLiteralType(literal) {
    const node = {
      type: "TSLiteralType",
      literal
    };
    const defs = NODE_FIELDS.TSLiteralType;
    validate(defs.literal, node, "literal", literal, 1);
    return node;
  }
  function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    const node = {
      type: "TSExpressionWithTypeArguments",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node = {
      type: "TSInterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.extends, node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsInterfaceBody(body) {
    const node = {
      type: "TSInterfaceBody",
      body
    };
    const defs = NODE_FIELDS.TSInterfaceBody;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
    const node = {
      type: "TSTypeAliasDeclaration",
      id,
      typeParameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsInstantiationExpression(expression, typeParameters = null) {
    const node = {
      type: "TSInstantiationExpression",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSInstantiationExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsAsExpression(expression, typeAnnotation2) {
    const node = {
      type: "TSAsExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSAsExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsSatisfiesExpression(expression, typeAnnotation2) {
    const node = {
      type: "TSSatisfiesExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSSatisfiesExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsTypeAssertion(typeAnnotation2, expression) {
    const node = {
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation2,
      expression
    };
    const defs = NODE_FIELDS.TSTypeAssertion;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsEnumBody(members) {
    const node = {
      type: "TSEnumBody",
      members
    };
    const defs = NODE_FIELDS.TSEnumBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumDeclaration(id, members) {
    const node = {
      type: "TSEnumDeclaration",
      id,
      members
    };
    const defs = NODE_FIELDS.TSEnumDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumMember(id, initializer = null) {
    const node = {
      type: "TSEnumMember",
      id,
      initializer
    };
    const defs = NODE_FIELDS.TSEnumMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.initializer, node, "initializer", initializer, 1);
    return node;
  }
  function tsModuleDeclaration(id, body) {
    const node = {
      type: "TSModuleDeclaration",
      id,
      body,
      kind: null
    };
    const defs = NODE_FIELDS.TSModuleDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsModuleBlock(body) {
    const node = {
      type: "TSModuleBlock",
      body
    };
    const defs = NODE_FIELDS.TSModuleBlock;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsImportType(argument, qualifier = null, typeParameters = null) {
    const node = {
      type: "TSImportType",
      argument,
      qualifier,
      typeParameters
    };
    const defs = NODE_FIELDS.TSImportType;
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.qualifier, node, "qualifier", qualifier, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    const node = {
      type: "TSImportEqualsDeclaration",
      id,
      moduleReference,
      isExport: null
    };
    const defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
    return node;
  }
  function tsExternalModuleReference(expression) {
    const node = {
      type: "TSExternalModuleReference",
      expression
    };
    const defs = NODE_FIELDS.TSExternalModuleReference;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNonNullExpression(expression) {
    const node = {
      type: "TSNonNullExpression",
      expression
    };
    const defs = NODE_FIELDS.TSNonNullExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsExportAssignment(expression) {
    const node = {
      type: "TSExportAssignment",
      expression
    };
    const defs = NODE_FIELDS.TSExportAssignment;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNamespaceExportDeclaration(id) {
    const node = {
      type: "TSNamespaceExportDeclaration",
      id
    };
    const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function tsTypeAnnotation(typeAnnotation2) {
    const node = {
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1);
    return node;
  }
  function tsTypeParameterInstantiation(params) {
    const node = {
      type: "TSTypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameterDeclaration(params) {
    const node = {
      type: "TSTypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameter(constraint = null, _default = null, name) {
    const node = {
      type: "TSTypeParameter",
      constraint,
      default: _default,
      name
    };
    const defs = NODE_FIELDS.TSTypeParameter;
    validate(defs.constraint, node, "constraint", constraint, 1);
    validate(defs.default, node, "default", _default, 1);
    validate(defs.name, node, "name", name);
    return node;
  }
  function NumberLiteral(value) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
  }
  function RegexLiteral(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  }
});

// ../../../../node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.JSXIdentifier = exports.JSXFragment = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = exports.JSXAttribute = exports.IntersectionTypeAnnotation = exports.InterpreterDirective = exports.InterfaceTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.InferredPredicate = exports.IndexedAccessType = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportExpression = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportAttribute = exports.Import = exports.IfStatement = exports.Identifier = exports.GenericTypeAnnotation = exports.FunctionTypeParam = exports.FunctionTypeAnnotation = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.File = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamespaceSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultSpecifier = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.ExistsTypeAnnotation = exports.EnumSymbolBody = exports.EnumStringMember = exports.EnumStringBody = exports.EnumNumberMember = exports.EnumNumberBody = exports.EnumDefaultedMember = exports.EnumDeclaration = exports.EnumBooleanMember = exports.EnumBooleanBody = exports.EmptyTypeAnnotation = exports.EmptyStatement = exports.DoWhileStatement = exports.DoExpression = exports.DirectiveLiteral = exports.Directive = exports.Decorator = exports.DeclaredPredicate = exports.DeclareVariable = exports.DeclareTypeAlias = exports.DeclareOpaqueType = exports.DeclareModuleExports = exports.DeclareModule = exports.DeclareInterface = exports.DeclareFunction = exports.DeclareExportDeclaration = exports.DeclareExportAllDeclaration = exports.DeclareClass = exports.DecimalLiteral = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassProperty = exports.ClassPrivateProperty = exports.ClassPrivateMethod = exports.ClassMethod = exports.ClassImplements = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ClassAccessorProperty = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BooleanTypeAnnotation = exports.BooleanLiteralTypeAnnotation = exports.BooleanLiteral = exports.BlockStatement = exports.BindExpression = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayTypeAnnotation = exports.ArrayPattern = exports.ArrayExpression = exports.ArgumentPlaceholder = exports.AnyTypeAnnotation = undefined;
  exports.TSNumberKeyword = exports.TSNullKeyword = exports.TSNonNullExpression = exports.TSNeverKeyword = exports.TSNamespaceExportDeclaration = exports.TSNamedTupleMember = exports.TSModuleDeclaration = exports.TSModuleBlock = exports.TSMethodSignature = exports.TSMappedType = exports.TSLiteralType = exports.TSIntrinsicKeyword = exports.TSIntersectionType = exports.TSInterfaceDeclaration = exports.TSInterfaceBody = exports.TSInstantiationExpression = exports.TSInferType = exports.TSIndexedAccessType = exports.TSIndexSignature = exports.TSImportType = exports.TSImportEqualsDeclaration = exports.TSFunctionType = exports.TSExternalModuleReference = exports.TSExpressionWithTypeArguments = exports.TSExportAssignment = exports.TSEnumMember = exports.TSEnumDeclaration = exports.TSEnumBody = exports.TSDeclareMethod = exports.TSDeclareFunction = exports.TSConstructorType = exports.TSConstructSignatureDeclaration = exports.TSConditionalType = exports.TSCallSignatureDeclaration = exports.TSBooleanKeyword = exports.TSBigIntKeyword = exports.TSAsExpression = exports.TSArrayType = exports.TSAnyKeyword = exports.SymbolTypeAnnotation = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StringTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringLiteral = exports.StaticBlock = exports.SpreadProperty = exports.SpreadElement = exports.SequenceExpression = exports.ReturnStatement = exports.RestProperty = exports.RestElement = exports.RegexLiteral = exports.RegExpLiteral = exports.RecordExpression = exports.QualifiedTypeIdentifier = exports.Program = exports.PrivateName = exports.Placeholder = exports.PipelineTopicExpression = exports.PipelinePrimaryTopicReference = exports.PipelineBareFunction = exports.ParenthesizedExpression = exports.OptionalMemberExpression = exports.OptionalIndexedAccessType = exports.OptionalCallExpression = exports.OpaqueType = exports.ObjectTypeSpreadProperty = exports.ObjectTypeProperty = exports.ObjectTypeInternalSlot = exports.ObjectTypeIndexer = exports.ObjectTypeCallProperty = exports.ObjectTypeAnnotation = exports.ObjectProperty = exports.ObjectPattern = exports.ObjectMethod = exports.ObjectExpression = exports.NumericLiteral = exports.NumberTypeAnnotation = exports.NumberLiteralTypeAnnotation = exports.NumberLiteral = exports.NullableTypeAnnotation = exports.NullLiteralTypeAnnotation = exports.NullLiteral = exports.Noop = exports.NewExpression = exports.ModuleExpression = exports.MixedTypeAnnotation = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.LabeledStatement = exports.JSXText = exports.JSXSpreadChild = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXMemberExpression = undefined;
  exports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VoidTypeAnnotation = exports.VoidPattern = exports.Variance = exports.VariableDeclarator = exports.VariableDeclaration = exports.V8IntrinsicIdentifier = exports.UpdateExpression = exports.UnionTypeAnnotation = exports.UnaryExpression = exports.TypeofTypeAnnotation = exports.TypeParameterInstantiation = exports.TypeParameterDeclaration = exports.TypeParameter = exports.TypeCastExpression = exports.TypeAnnotation = exports.TypeAlias = exports.TupleTypeAnnotation = exports.TupleExpression = exports.TryStatement = exports.TopicReference = exports.ThrowStatement = exports.ThisTypeAnnotation = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.TSVoidKeyword = exports.TSUnknownKeyword = exports.TSUnionType = exports.TSUndefinedKeyword = exports.TSTypeReference = exports.TSTypeQuery = exports.TSTypePredicate = exports.TSTypeParameterInstantiation = exports.TSTypeParameterDeclaration = exports.TSTypeParameter = exports.TSTypeOperator = exports.TSTypeLiteral = exports.TSTypeAssertion = exports.TSTypeAnnotation = exports.TSTypeAliasDeclaration = exports.TSTupleType = exports.TSThisType = exports.TSTemplateLiteralType = exports.TSSymbolKeyword = exports.TSStringKeyword = exports.TSSatisfiesExpression = exports.TSRestType = exports.TSQualifiedName = exports.TSPropertySignature = exports.TSParenthesizedType = exports.TSParameterProperty = exports.TSOptionalType = exports.TSObjectKeyword = undefined;
  var b = require_lowercase();
  var _deprecationWarning = require_deprecationWarning();
  function alias(lowercase) {
    {
      return b[lowercase];
    }
  }
  var ArrayExpression = exports.ArrayExpression = alias("arrayExpression");
  var AssignmentExpression = exports.AssignmentExpression = alias("assignmentExpression");
  var BinaryExpression = exports.BinaryExpression = alias("binaryExpression");
  var InterpreterDirective = exports.InterpreterDirective = alias("interpreterDirective");
  var Directive = exports.Directive = alias("directive");
  var DirectiveLiteral = exports.DirectiveLiteral = alias("directiveLiteral");
  var BlockStatement = exports.BlockStatement = alias("blockStatement");
  var BreakStatement = exports.BreakStatement = alias("breakStatement");
  var CallExpression = exports.CallExpression = alias("callExpression");
  var CatchClause = exports.CatchClause = alias("catchClause");
  var ConditionalExpression = exports.ConditionalExpression = alias("conditionalExpression");
  var ContinueStatement = exports.ContinueStatement = alias("continueStatement");
  var DebuggerStatement = exports.DebuggerStatement = alias("debuggerStatement");
  var DoWhileStatement = exports.DoWhileStatement = alias("doWhileStatement");
  var EmptyStatement = exports.EmptyStatement = alias("emptyStatement");
  var ExpressionStatement = exports.ExpressionStatement = alias("expressionStatement");
  var File = exports.File = alias("file");
  var ForInStatement = exports.ForInStatement = alias("forInStatement");
  var ForStatement = exports.ForStatement = alias("forStatement");
  var FunctionDeclaration = exports.FunctionDeclaration = alias("functionDeclaration");
  var FunctionExpression = exports.FunctionExpression = alias("functionExpression");
  var Identifier = exports.Identifier = alias("identifier");
  var IfStatement = exports.IfStatement = alias("ifStatement");
  var LabeledStatement = exports.LabeledStatement = alias("labeledStatement");
  var StringLiteral = exports.StringLiteral = alias("stringLiteral");
  var NumericLiteral = exports.NumericLiteral = alias("numericLiteral");
  var NullLiteral = exports.NullLiteral = alias("nullLiteral");
  var BooleanLiteral = exports.BooleanLiteral = alias("booleanLiteral");
  var RegExpLiteral = exports.RegExpLiteral = alias("regExpLiteral");
  var LogicalExpression = exports.LogicalExpression = alias("logicalExpression");
  var MemberExpression = exports.MemberExpression = alias("memberExpression");
  var NewExpression = exports.NewExpression = alias("newExpression");
  var Program = exports.Program = alias("program");
  var ObjectExpression = exports.ObjectExpression = alias("objectExpression");
  var ObjectMethod = exports.ObjectMethod = alias("objectMethod");
  var ObjectProperty = exports.ObjectProperty = alias("objectProperty");
  var RestElement = exports.RestElement = alias("restElement");
  var ReturnStatement = exports.ReturnStatement = alias("returnStatement");
  var SequenceExpression = exports.SequenceExpression = alias("sequenceExpression");
  var ParenthesizedExpression = exports.ParenthesizedExpression = alias("parenthesizedExpression");
  var SwitchCase = exports.SwitchCase = alias("switchCase");
  var SwitchStatement = exports.SwitchStatement = alias("switchStatement");
  var ThisExpression = exports.ThisExpression = alias("thisExpression");
  var ThrowStatement = exports.ThrowStatement = alias("throwStatement");
  var TryStatement = exports.TryStatement = alias("tryStatement");
  var UnaryExpression = exports.UnaryExpression = alias("unaryExpression");
  var UpdateExpression = exports.UpdateExpression = alias("updateExpression");
  var VariableDeclaration = exports.VariableDeclaration = alias("variableDeclaration");
  var VariableDeclarator = exports.VariableDeclarator = alias("variableDeclarator");
  var WhileStatement = exports.WhileStatement = alias("whileStatement");
  var WithStatement = exports.WithStatement = alias("withStatement");
  var AssignmentPattern = exports.AssignmentPattern = alias("assignmentPattern");
  var ArrayPattern = exports.ArrayPattern = alias("arrayPattern");
  var ArrowFunctionExpression = exports.ArrowFunctionExpression = alias("arrowFunctionExpression");
  var ClassBody = exports.ClassBody = alias("classBody");
  var ClassExpression = exports.ClassExpression = alias("classExpression");
  var ClassDeclaration = exports.ClassDeclaration = alias("classDeclaration");
  var ExportAllDeclaration = exports.ExportAllDeclaration = alias("exportAllDeclaration");
  var ExportDefaultDeclaration = exports.ExportDefaultDeclaration = alias("exportDefaultDeclaration");
  var ExportNamedDeclaration = exports.ExportNamedDeclaration = alias("exportNamedDeclaration");
  var ExportSpecifier = exports.ExportSpecifier = alias("exportSpecifier");
  var ForOfStatement = exports.ForOfStatement = alias("forOfStatement");
  var ImportDeclaration = exports.ImportDeclaration = alias("importDeclaration");
  var ImportDefaultSpecifier = exports.ImportDefaultSpecifier = alias("importDefaultSpecifier");
  var ImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = alias("importNamespaceSpecifier");
  var ImportSpecifier = exports.ImportSpecifier = alias("importSpecifier");
  var ImportExpression = exports.ImportExpression = alias("importExpression");
  var MetaProperty = exports.MetaProperty = alias("metaProperty");
  var ClassMethod = exports.ClassMethod = alias("classMethod");
  var ObjectPattern = exports.ObjectPattern = alias("objectPattern");
  var SpreadElement = exports.SpreadElement = alias("spreadElement");
  var Super = exports.Super = alias("super");
  var TaggedTemplateExpression = exports.TaggedTemplateExpression = alias("taggedTemplateExpression");
  var TemplateElement = exports.TemplateElement = alias("templateElement");
  var TemplateLiteral = exports.TemplateLiteral = alias("templateLiteral");
  var YieldExpression = exports.YieldExpression = alias("yieldExpression");
  var AwaitExpression = exports.AwaitExpression = alias("awaitExpression");
  var Import = exports.Import = alias("import");
  var BigIntLiteral = exports.BigIntLiteral = alias("bigIntLiteral");
  var ExportNamespaceSpecifier = exports.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier");
  var OptionalMemberExpression = exports.OptionalMemberExpression = alias("optionalMemberExpression");
  var OptionalCallExpression = exports.OptionalCallExpression = alias("optionalCallExpression");
  var ClassProperty = exports.ClassProperty = alias("classProperty");
  var ClassAccessorProperty = exports.ClassAccessorProperty = alias("classAccessorProperty");
  var ClassPrivateProperty = exports.ClassPrivateProperty = alias("classPrivateProperty");
  var ClassPrivateMethod = exports.ClassPrivateMethod = alias("classPrivateMethod");
  var PrivateName = exports.PrivateName = alias("privateName");
  var StaticBlock = exports.StaticBlock = alias("staticBlock");
  var ImportAttribute = exports.ImportAttribute = alias("importAttribute");
  var AnyTypeAnnotation = exports.AnyTypeAnnotation = alias("anyTypeAnnotation");
  var ArrayTypeAnnotation = exports.ArrayTypeAnnotation = alias("arrayTypeAnnotation");
  var BooleanTypeAnnotation = exports.BooleanTypeAnnotation = alias("booleanTypeAnnotation");
  var BooleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation");
  var NullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation");
  var ClassImplements = exports.ClassImplements = alias("classImplements");
  var DeclareClass = exports.DeclareClass = alias("declareClass");
  var DeclareFunction = exports.DeclareFunction = alias("declareFunction");
  var DeclareInterface = exports.DeclareInterface = alias("declareInterface");
  var DeclareModule = exports.DeclareModule = alias("declareModule");
  var DeclareModuleExports = exports.DeclareModuleExports = alias("declareModuleExports");
  var DeclareTypeAlias = exports.DeclareTypeAlias = alias("declareTypeAlias");
  var DeclareOpaqueType = exports.DeclareOpaqueType = alias("declareOpaqueType");
  var DeclareVariable = exports.DeclareVariable = alias("declareVariable");
  var DeclareExportDeclaration = exports.DeclareExportDeclaration = alias("declareExportDeclaration");
  var DeclareExportAllDeclaration = exports.DeclareExportAllDeclaration = alias("declareExportAllDeclaration");
  var DeclaredPredicate = exports.DeclaredPredicate = alias("declaredPredicate");
  var ExistsTypeAnnotation = exports.ExistsTypeAnnotation = alias("existsTypeAnnotation");
  var FunctionTypeAnnotation = exports.FunctionTypeAnnotation = alias("functionTypeAnnotation");
  var FunctionTypeParam = exports.FunctionTypeParam = alias("functionTypeParam");
  var GenericTypeAnnotation = exports.GenericTypeAnnotation = alias("genericTypeAnnotation");
  var InferredPredicate = exports.InferredPredicate = alias("inferredPredicate");
  var InterfaceExtends = exports.InterfaceExtends = alias("interfaceExtends");
  var InterfaceDeclaration = exports.InterfaceDeclaration = alias("interfaceDeclaration");
  var InterfaceTypeAnnotation = exports.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation");
  var IntersectionTypeAnnotation = exports.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation");
  var MixedTypeAnnotation = exports.MixedTypeAnnotation = alias("mixedTypeAnnotation");
  var EmptyTypeAnnotation = exports.EmptyTypeAnnotation = alias("emptyTypeAnnotation");
  var NullableTypeAnnotation = exports.NullableTypeAnnotation = alias("nullableTypeAnnotation");
  var NumberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation");
  var NumberTypeAnnotation = exports.NumberTypeAnnotation = alias("numberTypeAnnotation");
  var ObjectTypeAnnotation = exports.ObjectTypeAnnotation = alias("objectTypeAnnotation");
  var ObjectTypeInternalSlot = exports.ObjectTypeInternalSlot = alias("objectTypeInternalSlot");
  var ObjectTypeCallProperty = exports.ObjectTypeCallProperty = alias("objectTypeCallProperty");
  var ObjectTypeIndexer = exports.ObjectTypeIndexer = alias("objectTypeIndexer");
  var ObjectTypeProperty = exports.ObjectTypeProperty = alias("objectTypeProperty");
  var ObjectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty");
  var OpaqueType = exports.OpaqueType = alias("opaqueType");
  var QualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier");
  var StringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation");
  var StringTypeAnnotation = exports.StringTypeAnnotation = alias("stringTypeAnnotation");
  var SymbolTypeAnnotation = exports.SymbolTypeAnnotation = alias("symbolTypeAnnotation");
  var ThisTypeAnnotation = exports.ThisTypeAnnotation = alias("thisTypeAnnotation");
  var TupleTypeAnnotation = exports.TupleTypeAnnotation = alias("tupleTypeAnnotation");
  var TypeofTypeAnnotation = exports.TypeofTypeAnnotation = alias("typeofTypeAnnotation");
  var TypeAlias = exports.TypeAlias = alias("typeAlias");
  var TypeAnnotation = exports.TypeAnnotation = alias("typeAnnotation");
  var TypeCastExpression = exports.TypeCastExpression = alias("typeCastExpression");
  var TypeParameter = exports.TypeParameter = alias("typeParameter");
  var TypeParameterDeclaration = exports.TypeParameterDeclaration = alias("typeParameterDeclaration");
  var TypeParameterInstantiation = exports.TypeParameterInstantiation = alias("typeParameterInstantiation");
  var UnionTypeAnnotation = exports.UnionTypeAnnotation = alias("unionTypeAnnotation");
  var Variance = exports.Variance = alias("variance");
  var VoidTypeAnnotation = exports.VoidTypeAnnotation = alias("voidTypeAnnotation");
  var EnumDeclaration = exports.EnumDeclaration = alias("enumDeclaration");
  var EnumBooleanBody = exports.EnumBooleanBody = alias("enumBooleanBody");
  var EnumNumberBody = exports.EnumNumberBody = alias("enumNumberBody");
  var EnumStringBody = exports.EnumStringBody = alias("enumStringBody");
  var EnumSymbolBody = exports.EnumSymbolBody = alias("enumSymbolBody");
  var EnumBooleanMember = exports.EnumBooleanMember = alias("enumBooleanMember");
  var EnumNumberMember = exports.EnumNumberMember = alias("enumNumberMember");
  var EnumStringMember = exports.EnumStringMember = alias("enumStringMember");
  var EnumDefaultedMember = exports.EnumDefaultedMember = alias("enumDefaultedMember");
  var IndexedAccessType = exports.IndexedAccessType = alias("indexedAccessType");
  var OptionalIndexedAccessType = exports.OptionalIndexedAccessType = alias("optionalIndexedAccessType");
  var JSXAttribute = exports.JSXAttribute = alias("jsxAttribute");
  var JSXClosingElement = exports.JSXClosingElement = alias("jsxClosingElement");
  var JSXElement = exports.JSXElement = alias("jsxElement");
  var JSXEmptyExpression = exports.JSXEmptyExpression = alias("jsxEmptyExpression");
  var JSXExpressionContainer = exports.JSXExpressionContainer = alias("jsxExpressionContainer");
  var JSXSpreadChild = exports.JSXSpreadChild = alias("jsxSpreadChild");
  var JSXIdentifier = exports.JSXIdentifier = alias("jsxIdentifier");
  var JSXMemberExpression = exports.JSXMemberExpression = alias("jsxMemberExpression");
  var JSXNamespacedName = exports.JSXNamespacedName = alias("jsxNamespacedName");
  var JSXOpeningElement = exports.JSXOpeningElement = alias("jsxOpeningElement");
  var JSXSpreadAttribute = exports.JSXSpreadAttribute = alias("jsxSpreadAttribute");
  var JSXText = exports.JSXText = alias("jsxText");
  var JSXFragment = exports.JSXFragment = alias("jsxFragment");
  var JSXOpeningFragment = exports.JSXOpeningFragment = alias("jsxOpeningFragment");
  var JSXClosingFragment = exports.JSXClosingFragment = alias("jsxClosingFragment");
  var Noop = exports.Noop = alias("noop");
  var Placeholder = exports.Placeholder = alias("placeholder");
  var V8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier");
  var ArgumentPlaceholder = exports.ArgumentPlaceholder = alias("argumentPlaceholder");
  var BindExpression = exports.BindExpression = alias("bindExpression");
  var Decorator = exports.Decorator = alias("decorator");
  var DoExpression = exports.DoExpression = alias("doExpression");
  var ExportDefaultSpecifier = exports.ExportDefaultSpecifier = alias("exportDefaultSpecifier");
  var RecordExpression = exports.RecordExpression = alias("recordExpression");
  var TupleExpression = exports.TupleExpression = alias("tupleExpression");
  var DecimalLiteral = exports.DecimalLiteral = alias("decimalLiteral");
  var ModuleExpression = exports.ModuleExpression = alias("moduleExpression");
  var TopicReference = exports.TopicReference = alias("topicReference");
  var PipelineTopicExpression = exports.PipelineTopicExpression = alias("pipelineTopicExpression");
  var PipelineBareFunction = exports.PipelineBareFunction = alias("pipelineBareFunction");
  var PipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference");
  var VoidPattern = exports.VoidPattern = alias("voidPattern");
  var TSParameterProperty = exports.TSParameterProperty = alias("tsParameterProperty");
  var TSDeclareFunction = exports.TSDeclareFunction = alias("tsDeclareFunction");
  var TSDeclareMethod = exports.TSDeclareMethod = alias("tsDeclareMethod");
  var TSQualifiedName = exports.TSQualifiedName = alias("tsQualifiedName");
  var TSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration");
  var TSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration");
  var TSPropertySignature = exports.TSPropertySignature = alias("tsPropertySignature");
  var TSMethodSignature = exports.TSMethodSignature = alias("tsMethodSignature");
  var TSIndexSignature = exports.TSIndexSignature = alias("tsIndexSignature");
  var TSAnyKeyword = exports.TSAnyKeyword = alias("tsAnyKeyword");
  var TSBooleanKeyword = exports.TSBooleanKeyword = alias("tsBooleanKeyword");
  var TSBigIntKeyword = exports.TSBigIntKeyword = alias("tsBigIntKeyword");
  var TSIntrinsicKeyword = exports.TSIntrinsicKeyword = alias("tsIntrinsicKeyword");
  var TSNeverKeyword = exports.TSNeverKeyword = alias("tsNeverKeyword");
  var TSNullKeyword = exports.TSNullKeyword = alias("tsNullKeyword");
  var TSNumberKeyword = exports.TSNumberKeyword = alias("tsNumberKeyword");
  var TSObjectKeyword = exports.TSObjectKeyword = alias("tsObjectKeyword");
  var TSStringKeyword = exports.TSStringKeyword = alias("tsStringKeyword");
  var TSSymbolKeyword = exports.TSSymbolKeyword = alias("tsSymbolKeyword");
  var TSUndefinedKeyword = exports.TSUndefinedKeyword = alias("tsUndefinedKeyword");
  var TSUnknownKeyword = exports.TSUnknownKeyword = alias("tsUnknownKeyword");
  var TSVoidKeyword = exports.TSVoidKeyword = alias("tsVoidKeyword");
  var TSThisType = exports.TSThisType = alias("tsThisType");
  var TSFunctionType = exports.TSFunctionType = alias("tsFunctionType");
  var TSConstructorType = exports.TSConstructorType = alias("tsConstructorType");
  var TSTypeReference = exports.TSTypeReference = alias("tsTypeReference");
  var TSTypePredicate = exports.TSTypePredicate = alias("tsTypePredicate");
  var TSTypeQuery = exports.TSTypeQuery = alias("tsTypeQuery");
  var TSTypeLiteral = exports.TSTypeLiteral = alias("tsTypeLiteral");
  var TSArrayType = exports.TSArrayType = alias("tsArrayType");
  var TSTupleType = exports.TSTupleType = alias("tsTupleType");
  var TSOptionalType = exports.TSOptionalType = alias("tsOptionalType");
  var TSRestType = exports.TSRestType = alias("tsRestType");
  var TSNamedTupleMember = exports.TSNamedTupleMember = alias("tsNamedTupleMember");
  var TSUnionType = exports.TSUnionType = alias("tsUnionType");
  var TSIntersectionType = exports.TSIntersectionType = alias("tsIntersectionType");
  var TSConditionalType = exports.TSConditionalType = alias("tsConditionalType");
  var TSInferType = exports.TSInferType = alias("tsInferType");
  var TSParenthesizedType = exports.TSParenthesizedType = alias("tsParenthesizedType");
  var TSTypeOperator = exports.TSTypeOperator = alias("tsTypeOperator");
  var TSIndexedAccessType = exports.TSIndexedAccessType = alias("tsIndexedAccessType");
  var TSMappedType = exports.TSMappedType = alias("tsMappedType");
  var TSTemplateLiteralType = exports.TSTemplateLiteralType = alias("tsTemplateLiteralType");
  var TSLiteralType = exports.TSLiteralType = alias("tsLiteralType");
  var TSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments");
  var TSInterfaceDeclaration = exports.TSInterfaceDeclaration = alias("tsInterfaceDeclaration");
  var TSInterfaceBody = exports.TSInterfaceBody = alias("tsInterfaceBody");
  var TSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration");
  var TSInstantiationExpression = exports.TSInstantiationExpression = alias("tsInstantiationExpression");
  var TSAsExpression = exports.TSAsExpression = alias("tsAsExpression");
  var TSSatisfiesExpression = exports.TSSatisfiesExpression = alias("tsSatisfiesExpression");
  var TSTypeAssertion = exports.TSTypeAssertion = alias("tsTypeAssertion");
  var TSEnumBody = exports.TSEnumBody = alias("tsEnumBody");
  var TSEnumDeclaration = exports.TSEnumDeclaration = alias("tsEnumDeclaration");
  var TSEnumMember = exports.TSEnumMember = alias("tsEnumMember");
  var TSModuleDeclaration = exports.TSModuleDeclaration = alias("tsModuleDeclaration");
  var TSModuleBlock = exports.TSModuleBlock = alias("tsModuleBlock");
  var TSImportType = exports.TSImportType = alias("tsImportType");
  var TSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration");
  var TSExternalModuleReference = exports.TSExternalModuleReference = alias("tsExternalModuleReference");
  var TSNonNullExpression = exports.TSNonNullExpression = alias("tsNonNullExpression");
  var TSExportAssignment = exports.TSExportAssignment = alias("tsExportAssignment");
  var TSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration");
  var TSTypeAnnotation = exports.TSTypeAnnotation = alias("tsTypeAnnotation");
  var TSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation");
  var TSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration");
  var TSTypeParameter = exports.TSTypeParameter = alias("tsTypeParameter");
  var NumberLiteral = exports.NumberLiteral = b.numberLiteral;
  var RegexLiteral = exports.RegexLiteral = b.regexLiteral;
  var RestProperty = exports.RestProperty = b.restProperty;
  var SpreadProperty = exports.SpreadProperty = b.spreadProperty;
});

// ../../../../node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _lowercase = require_lowercase();
  Object.keys(_lowercase).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _lowercase[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _lowercase[key];
      }
    });
  });
  var _uppercase = require_uppercase();
  Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _uppercase[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _uppercase[key];
      }
    });
  });
});

// ../../../../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cleanJSXElementLiteralChild;
  var _index = require_generated2();
  var _index2 = require_lib5();
  function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0;i < lines.length; i++) {
      if (/[^ \t]/.exec(lines[i])) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0;i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^ +/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/ +$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str)
      args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  }
});

// ../../../../node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildChildren;
  var _index = require_generated();
  var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
  function buildChildren(node) {
    const elements = [];
    for (let i = 0;i < node.children.length; i++) {
      let child = node.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child))
        continue;
      elements.push(child);
    }
    return elements;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNode;
  var _index = require_definitions();
  function isNode(node) {
    return !!(node && _index.VISITOR_KEYS[node.type]);
  }
});

// ../../../../node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertNode;
  var _isNode = require_isNode();
  function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;
      const type = (_node$type = node == null ? undefined : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }
});

// ../../../../node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertAccessor = assertAccessor;
  exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
  exports.assertArrayExpression = assertArrayExpression;
  exports.assertArrayPattern = assertArrayPattern;
  exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
  exports.assertAssignmentExpression = assertAssignmentExpression;
  exports.assertAssignmentPattern = assertAssignmentPattern;
  exports.assertAwaitExpression = assertAwaitExpression;
  exports.assertBigIntLiteral = assertBigIntLiteral;
  exports.assertBinary = assertBinary;
  exports.assertBinaryExpression = assertBinaryExpression;
  exports.assertBindExpression = assertBindExpression;
  exports.assertBlock = assertBlock;
  exports.assertBlockParent = assertBlockParent;
  exports.assertBlockStatement = assertBlockStatement;
  exports.assertBooleanLiteral = assertBooleanLiteral;
  exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  exports.assertBreakStatement = assertBreakStatement;
  exports.assertCallExpression = assertCallExpression;
  exports.assertCatchClause = assertCatchClause;
  exports.assertClass = assertClass;
  exports.assertClassAccessorProperty = assertClassAccessorProperty;
  exports.assertClassBody = assertClassBody;
  exports.assertClassDeclaration = assertClassDeclaration;
  exports.assertClassExpression = assertClassExpression;
  exports.assertClassImplements = assertClassImplements;
  exports.assertClassMethod = assertClassMethod;
  exports.assertClassPrivateMethod = assertClassPrivateMethod;
  exports.assertClassPrivateProperty = assertClassPrivateProperty;
  exports.assertClassProperty = assertClassProperty;
  exports.assertCompletionStatement = assertCompletionStatement;
  exports.assertConditional = assertConditional;
  exports.assertConditionalExpression = assertConditionalExpression;
  exports.assertContinueStatement = assertContinueStatement;
  exports.assertDebuggerStatement = assertDebuggerStatement;
  exports.assertDecimalLiteral = assertDecimalLiteral;
  exports.assertDeclaration = assertDeclaration;
  exports.assertDeclareClass = assertDeclareClass;
  exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  exports.assertDeclareFunction = assertDeclareFunction;
  exports.assertDeclareInterface = assertDeclareInterface;
  exports.assertDeclareModule = assertDeclareModule;
  exports.assertDeclareModuleExports = assertDeclareModuleExports;
  exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
  exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
  exports.assertDeclareVariable = assertDeclareVariable;
  exports.assertDeclaredPredicate = assertDeclaredPredicate;
  exports.assertDecorator = assertDecorator;
  exports.assertDirective = assertDirective;
  exports.assertDirectiveLiteral = assertDirectiveLiteral;
  exports.assertDoExpression = assertDoExpression;
  exports.assertDoWhileStatement = assertDoWhileStatement;
  exports.assertEmptyStatement = assertEmptyStatement;
  exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  exports.assertEnumBody = assertEnumBody;
  exports.assertEnumBooleanBody = assertEnumBooleanBody;
  exports.assertEnumBooleanMember = assertEnumBooleanMember;
  exports.assertEnumDeclaration = assertEnumDeclaration;
  exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
  exports.assertEnumMember = assertEnumMember;
  exports.assertEnumNumberBody = assertEnumNumberBody;
  exports.assertEnumNumberMember = assertEnumNumberMember;
  exports.assertEnumStringBody = assertEnumStringBody;
  exports.assertEnumStringMember = assertEnumStringMember;
  exports.assertEnumSymbolBody = assertEnumSymbolBody;
  exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  exports.assertExportAllDeclaration = assertExportAllDeclaration;
  exports.assertExportDeclaration = assertExportDeclaration;
  exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
  exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  exports.assertExportSpecifier = assertExportSpecifier;
  exports.assertExpression = assertExpression;
  exports.assertExpressionStatement = assertExpressionStatement;
  exports.assertExpressionWrapper = assertExpressionWrapper;
  exports.assertFile = assertFile;
  exports.assertFlow = assertFlow;
  exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  exports.assertFlowDeclaration = assertFlowDeclaration;
  exports.assertFlowPredicate = assertFlowPredicate;
  exports.assertFlowType = assertFlowType;
  exports.assertFor = assertFor;
  exports.assertForInStatement = assertForInStatement;
  exports.assertForOfStatement = assertForOfStatement;
  exports.assertForStatement = assertForStatement;
  exports.assertForXStatement = assertForXStatement;
  exports.assertFunction = assertFunction;
  exports.assertFunctionDeclaration = assertFunctionDeclaration;
  exports.assertFunctionExpression = assertFunctionExpression;
  exports.assertFunctionParameter = assertFunctionParameter;
  exports.assertFunctionParent = assertFunctionParent;
  exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  exports.assertFunctionTypeParam = assertFunctionTypeParam;
  exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  exports.assertIdentifier = assertIdentifier;
  exports.assertIfStatement = assertIfStatement;
  exports.assertImmutable = assertImmutable;
  exports.assertImport = assertImport;
  exports.assertImportAttribute = assertImportAttribute;
  exports.assertImportDeclaration = assertImportDeclaration;
  exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  exports.assertImportExpression = assertImportExpression;
  exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  exports.assertImportSpecifier = assertImportSpecifier;
  exports.assertIndexedAccessType = assertIndexedAccessType;
  exports.assertInferredPredicate = assertInferredPredicate;
  exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
  exports.assertInterfaceExtends = assertInterfaceExtends;
  exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  exports.assertInterpreterDirective = assertInterpreterDirective;
  exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  exports.assertJSX = assertJSX;
  exports.assertJSXAttribute = assertJSXAttribute;
  exports.assertJSXClosingElement = assertJSXClosingElement;
  exports.assertJSXClosingFragment = assertJSXClosingFragment;
  exports.assertJSXElement = assertJSXElement;
  exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
  exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
  exports.assertJSXFragment = assertJSXFragment;
  exports.assertJSXIdentifier = assertJSXIdentifier;
  exports.assertJSXMemberExpression = assertJSXMemberExpression;
  exports.assertJSXNamespacedName = assertJSXNamespacedName;
  exports.assertJSXOpeningElement = assertJSXOpeningElement;
  exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
  exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  exports.assertJSXSpreadChild = assertJSXSpreadChild;
  exports.assertJSXText = assertJSXText;
  exports.assertLVal = assertLVal;
  exports.assertLabeledStatement = assertLabeledStatement;
  exports.assertLiteral = assertLiteral;
  exports.assertLogicalExpression = assertLogicalExpression;
  exports.assertLoop = assertLoop;
  exports.assertMemberExpression = assertMemberExpression;
  exports.assertMetaProperty = assertMetaProperty;
  exports.assertMethod = assertMethod;
  exports.assertMiscellaneous = assertMiscellaneous;
  exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  exports.assertModuleDeclaration = assertModuleDeclaration;
  exports.assertModuleExpression = assertModuleExpression;
  exports.assertModuleSpecifier = assertModuleSpecifier;
  exports.assertNewExpression = assertNewExpression;
  exports.assertNoop = assertNoop;
  exports.assertNullLiteral = assertNullLiteral;
  exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  exports.assertNumberLiteral = assertNumberLiteral;
  exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  exports.assertNumericLiteral = assertNumericLiteral;
  exports.assertObjectExpression = assertObjectExpression;
  exports.assertObjectMember = assertObjectMember;
  exports.assertObjectMethod = assertObjectMethod;
  exports.assertObjectPattern = assertObjectPattern;
  exports.assertObjectProperty = assertObjectProperty;
  exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
  exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  exports.assertObjectTypeProperty = assertObjectTypeProperty;
  exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  exports.assertOpaqueType = assertOpaqueType;
  exports.assertOptionalCallExpression = assertOptionalCallExpression;
  exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
  exports.assertParenthesizedExpression = assertParenthesizedExpression;
  exports.assertPattern = assertPattern;
  exports.assertPatternLike = assertPatternLike;
  exports.assertPipelineBareFunction = assertPipelineBareFunction;
  exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
  exports.assertPlaceholder = assertPlaceholder;
  exports.assertPrivate = assertPrivate;
  exports.assertPrivateName = assertPrivateName;
  exports.assertProgram = assertProgram;
  exports.assertProperty = assertProperty;
  exports.assertPureish = assertPureish;
  exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  exports.assertRecordExpression = assertRecordExpression;
  exports.assertRegExpLiteral = assertRegExpLiteral;
  exports.assertRegexLiteral = assertRegexLiteral;
  exports.assertRestElement = assertRestElement;
  exports.assertRestProperty = assertRestProperty;
  exports.assertReturnStatement = assertReturnStatement;
  exports.assertScopable = assertScopable;
  exports.assertSequenceExpression = assertSequenceExpression;
  exports.assertSpreadElement = assertSpreadElement;
  exports.assertSpreadProperty = assertSpreadProperty;
  exports.assertStandardized = assertStandardized;
  exports.assertStatement = assertStatement;
  exports.assertStaticBlock = assertStaticBlock;
  exports.assertStringLiteral = assertStringLiteral;
  exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
  exports.assertSuper = assertSuper;
  exports.assertSwitchCase = assertSwitchCase;
  exports.assertSwitchStatement = assertSwitchStatement;
  exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  exports.assertTSAnyKeyword = assertTSAnyKeyword;
  exports.assertTSArrayType = assertTSArrayType;
  exports.assertTSAsExpression = assertTSAsExpression;
  exports.assertTSBaseType = assertTSBaseType;
  exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
  exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
  exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  exports.assertTSConditionalType = assertTSConditionalType;
  exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  exports.assertTSConstructorType = assertTSConstructorType;
  exports.assertTSDeclareFunction = assertTSDeclareFunction;
  exports.assertTSDeclareMethod = assertTSDeclareMethod;
  exports.assertTSEntityName = assertTSEntityName;
  exports.assertTSEnumBody = assertTSEnumBody;
  exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
  exports.assertTSEnumMember = assertTSEnumMember;
  exports.assertTSExportAssignment = assertTSExportAssignment;
  exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
  exports.assertTSFunctionType = assertTSFunctionType;
  exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  exports.assertTSImportType = assertTSImportType;
  exports.assertTSIndexSignature = assertTSIndexSignature;
  exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
  exports.assertTSInferType = assertTSInferType;
  exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
  exports.assertTSInterfaceBody = assertTSInterfaceBody;
  exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  exports.assertTSIntersectionType = assertTSIntersectionType;
  exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  exports.assertTSLiteralType = assertTSLiteralType;
  exports.assertTSMappedType = assertTSMappedType;
  exports.assertTSMethodSignature = assertTSMethodSignature;
  exports.assertTSModuleBlock = assertTSModuleBlock;
  exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
  exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
  exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  exports.assertTSNeverKeyword = assertTSNeverKeyword;
  exports.assertTSNonNullExpression = assertTSNonNullExpression;
  exports.assertTSNullKeyword = assertTSNullKeyword;
  exports.assertTSNumberKeyword = assertTSNumberKeyword;
  exports.assertTSObjectKeyword = assertTSObjectKeyword;
  exports.assertTSOptionalType = assertTSOptionalType;
  exports.assertTSParameterProperty = assertTSParameterProperty;
  exports.assertTSParenthesizedType = assertTSParenthesizedType;
  exports.assertTSPropertySignature = assertTSPropertySignature;
  exports.assertTSQualifiedName = assertTSQualifiedName;
  exports.assertTSRestType = assertTSRestType;
  exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  exports.assertTSStringKeyword = assertTSStringKeyword;
  exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
  exports.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
  exports.assertTSThisType = assertTSThisType;
  exports.assertTSTupleType = assertTSTupleType;
  exports.assertTSType = assertTSType;
  exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
  exports.assertTSTypeAssertion = assertTSTypeAssertion;
  exports.assertTSTypeElement = assertTSTypeElement;
  exports.assertTSTypeLiteral = assertTSTypeLiteral;
  exports.assertTSTypeOperator = assertTSTypeOperator;
  exports.assertTSTypeParameter = assertTSTypeParameter;
  exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  exports.assertTSTypePredicate = assertTSTypePredicate;
  exports.assertTSTypeQuery = assertTSTypeQuery;
  exports.assertTSTypeReference = assertTSTypeReference;
  exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  exports.assertTSUnionType = assertTSUnionType;
  exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
  exports.assertTSVoidKeyword = assertTSVoidKeyword;
  exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  exports.assertTemplateElement = assertTemplateElement;
  exports.assertTemplateLiteral = assertTemplateLiteral;
  exports.assertTerminatorless = assertTerminatorless;
  exports.assertThisExpression = assertThisExpression;
  exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
  exports.assertThrowStatement = assertThrowStatement;
  exports.assertTopicReference = assertTopicReference;
  exports.assertTryStatement = assertTryStatement;
  exports.assertTupleExpression = assertTupleExpression;
  exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  exports.assertTypeAlias = assertTypeAlias;
  exports.assertTypeAnnotation = assertTypeAnnotation;
  exports.assertTypeCastExpression = assertTypeCastExpression;
  exports.assertTypeParameter = assertTypeParameter;
  exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  exports.assertTypeScript = assertTypeScript;
  exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  exports.assertUnaryExpression = assertUnaryExpression;
  exports.assertUnaryLike = assertUnaryLike;
  exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  exports.assertUpdateExpression = assertUpdateExpression;
  exports.assertUserWhitespacable = assertUserWhitespacable;
  exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  exports.assertVariableDeclaration = assertVariableDeclaration;
  exports.assertVariableDeclarator = assertVariableDeclarator;
  exports.assertVariance = assertVariance;
  exports.assertVoidPattern = assertVoidPattern;
  exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  exports.assertWhile = assertWhile;
  exports.assertWhileStatement = assertWhileStatement;
  exports.assertWithStatement = assertWithStatement;
  exports.assertYieldExpression = assertYieldExpression;
  var _is = require_is();
  var _deprecationWarning = require_deprecationWarning();
  function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
    }
  }
  function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
  }
  function assertImportExpression(node, opts) {
    assert("ImportExpression", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
  }
  function assertClassAccessorProperty(node, opts) {
    assert("ClassAccessorProperty", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  }
  function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
  }
  function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
  }
  function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
  }
  function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
  }
  function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }
  function assertVoidPattern(node, opts) {
    assert("VoidPattern", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
  }
  function assertTSTemplateLiteralType(node, opts) {
    assert("TSTemplateLiteralType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSInstantiationExpression(node, opts) {
    assert("TSInstantiationExpression", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
  }
  function assertTSSatisfiesExpression(node, opts) {
    assert("TSSatisfiesExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
  }
  function assertTSEnumBody(node, opts) {
    assert("TSEnumBody", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
  }
  function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
  }
  function assertExpression(node, opts) {
    assert("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
  }
  function assertFunction(node, opts) {
    assert("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
  }
  function assertFunctionParameter(node, opts) {
    assert("FunctionParameter", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert("Class", node, opts);
  }
  function assertImportOrExportDeclaration(node, opts) {
    assert("ImportOrExportDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
  }
  function assertAccessor(node, opts) {
    assert("Accessor", node, opts);
  }
  function assertPrivate(node, opts) {
    assert("Private", node, opts);
  }
  function assertFlow(node, opts) {
    assert("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert("JSX", node, opts);
  }
  function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
  }
  function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node, opts);
  }
});

// ../../../../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated2();
  var _default = exports.default = createTypeAnnotationBasedOnTypeof;
  function createTypeAnnotationBasedOnTypeof(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
  function getQualifiedName(node) {
    return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
  }
  function removeTypeDuplicates(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      if (!node)
        continue;
      if (types.includes(node)) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node)) {
        return [node];
      }
      if ((0, _index.isFlowBaseAnnotation)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push(...node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node)) {
        const name = getQualifiedName(node.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params.push(...node.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  }
});

// ../../../../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createFlowUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
  function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
  function getQualifiedName(node) {
    return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? "this" : `${node.right.name}.${getQualifiedName(node.left)}`;
  }
  function removeTypeDuplicates(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      if (!node)
        continue;
      if (types.includes(node)) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node)) {
        return [node];
      }
      if ((0, _index.isTSBaseType)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isTSUnionType)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push(...node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      const typeArgumentsKey = "typeParameters";
      if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
        const typeArguments = node[typeArgumentsKey];
        const name = getQualifiedName(node.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          const existingTypeArguments = existing[typeArgumentsKey];
          if (existingTypeArguments) {
            existingTypeArguments.params.push(...typeArguments.params);
            existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
          } else {
            existing = typeArguments;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  }
});

// ../../../../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTSUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates2();
  var _index2 = require_generated();
  function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type) => {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  }
});

// ../../../../node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildUndefinedNode = buildUndefinedNode;
  var _index = require_generated2();
  function buildUndefinedNode() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  }
});

// ../../../../node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneNode;
  var _index = require_definitions();
  var _index2 = require_generated();
  var {
    hasOwn
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc, new Map);
  }
  function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
    if (!node)
      return node;
    const {
      type
    } = node;
    const newNode = {
      type: node.type
    };
    if ((0, _index2.isIdentifier)(node)) {
      newNode.name = node.name;
      if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }
      if (hasOwn(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
      }
      if (hasOwn(node, "decorators")) {
        newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
      }
    } else if (!hasOwn(_index.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_index.NODE_FIELDS[type])) {
        if (hasOwn(node, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }
    if (hasOwn(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }
    if (hasOwn(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map((comment) => {
      const cache = commentsCache.get(comment);
      if (cache)
        return cache;
      const {
        type,
        value,
        loc
      } = comment;
      const ret = {
        type,
        value,
        loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }
});

// ../../../../node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = clone;
  var _cloneNode = require_cloneNode();
  function clone(node) {
    return (0, _cloneNode.default)(node, false);
  }
});

// ../../../../node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeep;
  var _cloneNode = require_cloneNode();
  function cloneDeep(node) {
    return (0, _cloneNode.default)(node);
  }
});

// ../../../../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeepWithoutLoc;
  var _cloneNode = require_cloneNode();
  function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode.default)(node, true, true);
  }
});

// ../../../../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneWithoutLoc;
  var _cloneNode = require_cloneNode();
  function cloneWithoutLoc(node) {
    return (0, _cloneNode.default)(node, false, true);
  }
});

// ../../../../node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComments;
  function addComments(node, type, comments) {
    if (!comments || !node)
      return node;
    const key = `${type}Comments`;
    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key].push(...comments);
      }
    } else {
      node[key] = comments;
    }
    return node;
  }
});

// ../../../../node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComment;
  var _addComments = require_addComments();
  function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }
});

// ../../../../node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherit;
  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }
});

// ../../../../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritInnerComments;
  var _inherit = require_inherit();
  function inheritInnerComments(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  }
});

// ../../../../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritLeadingComments;
  var _inherit = require_inherit();
  function inheritLeadingComments(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  }
});

// ../../../../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritTrailingComments;
  var _inherit = require_inherit();
  function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  }
});

// ../../../../node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritsComments;
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritInnerComments = require_inheritInnerComments();
  function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }
});

// ../../../../node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeComments;
  var _index = require_constants();
  function removeComments(node) {
    _index.COMMENT_KEYS.forEach((key) => {
      node[key] = null;
    });
    return node;
  }
});

// ../../../../node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTIONPARAMETER_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = undefined;
  var _index = require_definitions();
  var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  var FUNCTIONPARAMETER_TYPES = exports.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParameter"];
  var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
});

// ../../../../node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBlock;
  var _index = require_generated();
  var _index2 = require_generated2();
  function toBlock(node, parent) {
    if ((0, _index.isBlockStatement)(node)) {
      return node;
    }
    let blockNodes = [];
    if ((0, _index.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node)) {
        if ((0, _index.isFunction)(parent)) {
          node = (0, _index2.returnStatement)(node);
        } else {
          node = (0, _index2.expressionStatement)(node);
        }
      }
      blockNodes = [node];
    }
    return (0, _index2.blockStatement)(blockNodes);
  }
});

// ../../../../node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ensureBlock;
  var _toBlock = require_toBlock();
  function ensureBlock(node, key = "body") {
    const result = (0, _toBlock.default)(node[key], node);
    node[key] = result;
    return result;
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toIdentifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib3();
  function toIdentifier(input) {
    input = input + "";
    let name = "";
    for (const c of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBindingIdentifierName;
  var _toIdentifier = require_toIdentifier();
  function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments")
      name = "_" + name;
    return name;
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toComputedKey;
  var _index = require_generated();
  var _index2 = require_generated2();
  function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _index.isIdentifier)(key))
      key = (0, _index2.stringLiteral)(key.name);
    return key;
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _default = exports.default = toExpression;
  function toExpression(node) {
    if ((0, _index.isExpressionStatement)(node)) {
      node = node.expression;
    }
    if ((0, _index.isExpression)(node)) {
      return node;
    }
    if ((0, _index.isClass)(node)) {
      node.type = "ClassExpression";
      node.abstract = false;
    } else if ((0, _index.isFunction)(node)) {
      node.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node)) {
      throw new Error(`cannot turn ${node.type} to an expression`);
    }
    return node;
  }
});

// ../../../../node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverseFast;
  var _index = require_definitions();
  var _skip = Symbol();
  var _stop = Symbol();
  function traverseFast(node, enter, opts) {
    if (!node)
      return false;
    const keys = _index.VISITOR_KEYS[node.type];
    if (!keys)
      return false;
    opts = opts || {};
    const ret = enter(node, opts);
    if (ret !== undefined) {
      switch (ret) {
        case _skip:
          return false;
        case _stop:
          return true;
      }
    }
    for (const key of keys) {
      const subNode = node[key];
      if (!subNode)
        continue;
      if (Array.isArray(subNode)) {
        for (const node2 of subNode) {
          if (traverseFast(node2, enter, opts))
            return true;
        }
      } else {
        if (traverseFast(subNode, enter, opts))
          return true;
      }
    }
    return false;
  }
  traverseFast.skip = _skip;
  traverseFast.stop = _stop;
});

// ../../../../node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeProperties;
  var _index = require_constants();
  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
  function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node[key] != null)
        node[key] = undefined;
    }
    for (const key of Object.keys(node)) {
      if (key[0] === "_" && node[key] != null)
        node[key] = undefined;
    }
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols) {
      node[sym] = null;
    }
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removePropertiesDeep;
  var _traverseFast = require_traverseFast();
  var _removeProperties = require_removeProperties();
  function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toKeyAlias;
  var _index = require_generated();
  var _cloneNode = require_cloneNode();
  var _removePropertiesDeep = require_removePropertiesDeep();
  function toKeyAlias(node, key = node.key) {
    let alias;
    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    }
    if (node.computed) {
      alias = `[${alias}]`;
    }
    if (node.static) {
      alias = `static:${alias}`;
    }
    return alias;
  }
  toKeyAlias.uid = 0;
  toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };
});

// ../../../../node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _index2 = require_generated2();
  var _default = exports.default = toStatement;
  function toStatement(node, ignore) {
    if ((0, _index.isStatement)(node)) {
      return node;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _index.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node)) {
      return (0, _index2.expressionStatement)(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
    }
    node.type = newType;
    return node;
  }
});

// ../../../../node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _isValidIdentifier = require_isValidIdentifier();
  var _index = require_generated2();
  var _default = exports.default = valueToNode;
  var objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode(value) {
    if (value === undefined) {
      return (0, _index.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _index.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _index.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _index.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (typeof value === "bigint") {
      if (value < 0) {
        return (0, _index.unaryExpression)("-", (0, _index.bigIntLiteral)(-value));
      } else {
        return (0, _index.bigIntLiteral)(value);
      }
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = /\/([a-z]*)$/.exec(value.toString())[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _index.arrayExpression)(value.map(valueToNode));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey, computed = false;
        if ((0, _isValidIdentifier.default)(key)) {
          if (key === "__proto__") {
            computed = true;
            nodeKey = (0, _index.stringLiteral)(key);
          } else {
            nodeKey = (0, _index.identifier)(key);
          }
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key]), computed));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = appendToMemberExpression;
  var _index = require_generated2();
  function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherits;
  var _index = require_constants();
  var _inheritsComments = require_inheritsComments();
  function inherits(child, parent) {
    if (!child || !parent)
      return child;
    for (const key of _index.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _index.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  }
});

// ../../../../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prependToMemberExpression;
  var _index = require_generated2();
  var _index2 = require_lib5();
  function prependToMemberExpression(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  }
});

// ../../../../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getAssignmentIdentifiers;
  function getAssignmentIdentifiers(node) {
    const search = [].concat(node);
    const ids = Object.create(null);
    while (search.length) {
      const id = search.pop();
      if (!id)
        continue;
      switch (id.type) {
        case "ArrayPattern":
          search.push(...id.elements);
          break;
        case "AssignmentExpression":
        case "AssignmentPattern":
        case "ForInStatement":
        case "ForOfStatement":
          search.push(id.left);
          break;
        case "ObjectPattern":
          search.push(...id.properties);
          break;
        case "ObjectProperty":
          search.push(id.value);
          break;
        case "RestElement":
        case "UpdateExpression":
          search.push(id.argument);
          break;
        case "UnaryExpression":
          if (id.operator === "delete") {
            search.push(id.argument);
          }
          break;
        case "Identifier":
          ids[id.name] = id;
          break;
        default:
          break;
      }
    }
    return ids;
  }
});

// ../../../../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getBindingIdentifiers;
  var _index = require_generated();
  function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node);
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id)
        continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
        continue;
      }
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      const keys2 = getBindingIdentifiers.keys[id.type];
      if (keys2) {
        for (let i = 0;i < keys2.length; i++) {
          const key = keys2[i];
          const nodes = id[key];
          if (nodes) {
            if (Array.isArray(nodes)) {
              search.push(...nodes);
            } else {
              search.push(nodes);
            }
          }
        }
      }
    }
    return ids;
  }
  var keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  getBindingIdentifiers.keys = keys;
});

// ../../../../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _default = exports.default = getOuterBindingIdentifiers;
  function getOuterBindingIdentifiers(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
  }
});

// ../../../../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getFunctionName;
  var _index = require_generated();
  function getNameFromLiteralId(id) {
    if ((0, _index.isNullLiteral)(id)) {
      return "null";
    }
    if ((0, _index.isRegExpLiteral)(id)) {
      return `/${id.pattern}/${id.flags}`;
    }
    if ((0, _index.isTemplateLiteral)(id)) {
      return id.quasis.map((quasi) => quasi.value.raw).join("");
    }
    if (id.value !== undefined) {
      return String(id.value);
    }
    return null;
  }
  function getObjectMemberKey(node) {
    if (!node.computed || (0, _index.isLiteral)(node.key)) {
      return node.key;
    }
  }
  function getFunctionName(node, parent) {
    if ("id" in node && node.id) {
      return {
        name: node.id.name,
        originalNode: node.id
      };
    }
    let prefix = "";
    let id;
    if ((0, _index.isObjectProperty)(parent, {
      value: node
    })) {
      id = getObjectMemberKey(parent);
    } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {
      id = getObjectMemberKey(node);
      if (node.kind === "get")
        prefix = "get ";
      else if (node.kind === "set")
        prefix = "set ";
    } else if ((0, _index.isVariableDeclarator)(parent, {
      init: node
    })) {
      id = parent.id;
    } else if ((0, _index.isAssignmentExpression)(parent, {
      operator: "=",
      right: node
    })) {
      id = parent.left;
    }
    if (!id)
      return null;
    const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
    if (name == null)
      return null;
    return {
      name: prefix + name,
      originalNode: id
    };
  }
});

// ../../../../node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverse;
  var _index = require_definitions();
  function traverse(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
  }
  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _index.VISITOR_KEYS[node.type];
    if (!keys)
      return;
    if (enter)
      enter(node, ancestors, state);
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) {
        for (let i = 0;i < subNode.length; i++) {
          const child = subNode[i];
          if (!child)
            continue;
          ancestors.push({
            node,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit)
      exit(node, ancestors, state);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBinding;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0;i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.includes(node))
            return true;
        } else {
          if (val === node)
            return true;
        }
      }
    }
    return false;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLet;
  var _index = require_generated();
  {
    BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  }
  var BLOCK_SCOPED_SYMBOL;
  function isLet(node) {
    {
      return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBlockScoped;
  var _index = require_generated();
  var _isLet = require_isLet();
  function isBlockScoped(node) {
    return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isImmutable;
  var _isType = require_isType();
  var _index = require_generated();
  function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable"))
      return true;
    if ((0, _index.isIdentifier)(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNodesEquivalent;
  var _index = require_definitions();
  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _index.VISITOR_KEYS[a.type];
    for (const field of fields) {
      const val_a = a[field];
      const val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0;i < val_a.length; i++) {
          if (!isNodesEquivalent(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isReferenced;
  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }
        return parent.object === node;
      case "JSXMemberExpression":
        return parent.object === node;
      case "VariableDeclarator":
        return parent.init === node;
      case "ArrowFunctionExpression":
        return parent.body === node;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;
      case "AssignmentExpression":
        return parent.right === node;
      case "AssignmentPattern":
        return parent.right === node;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node;
      case "TSEnumMember":
        return parent.id !== node;
      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isScope;
  var _index = require_generated();
  function isScope(node, parent) {
    if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSpecifierDefault;
  var _index = require_generated();
  function isSpecifierDefault(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidES3Identifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }
});

// ../../../../node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVar;
  var _index = require_generated();
  {
    BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  }
  var BLOCK_SCOPED_SYMBOL;
  function isVar(node) {
    {
      return (0, _index.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[BLOCK_SCOPED_SYMBOL];
    }
  }
});

// ../../../../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gatherSequenceExpressions;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _index = require_generated();
  var _index2 = require_generated2();
  var _productions = require_productions();
  var _cloneNode = require_cloneNode();
  function gatherSequenceExpressions(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes) {
      if (!(0, _index.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }
      if ((0, _index.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _index.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _index.isVariableDeclaration)(node)) {
        if (node.kind !== "var")
          return;
        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }
          if (declar.init) {
            exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _index.isIfStatement)(node)) {
        const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();
        const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();
        if (!consequent || !alternate)
          return;
        exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
      } else if ((0, _index.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions(node.body, declars);
        if (!body)
          return;
        exprs.push(body);
      } else if ((0, _index.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push((0, _productions.buildUndefinedNode)());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  }
});

// ../../../../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toSequenceExpression;
  var _gatherSequenceExpressions = require_gatherSequenceExpressions();
  function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length))
      return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
    if (!result)
      return;
    for (const declar of declars) {
      scope.push(declar);
    }
    return result;
  }
});

// ../../../../node_modules/@babel/types/lib/index.js
var require_lib5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getAssignmentIdentifiers: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    getFunctionName: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true,
    __internal__deprecationWarning: true
  };
  Object.defineProperty(exports, "__internal__deprecationWarning", {
    enumerable: true,
    get: function() {
      return _deprecationWarning.default;
    }
  });
  Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
      return _addComment.default;
    }
  });
  Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
      return _addComments.default;
    }
  });
  Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
      return _appendToMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
      return _assertNode.default;
    }
  });
  Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
      return _buildMatchMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
      return _clone.default;
    }
  });
  Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
      return _cloneDeep.default;
    }
  });
  Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneDeepWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
      return _cloneNode.default;
    }
  });
  Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
      return _createTSUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
      return _createTypeAnnotationBasedOnTypeof.default;
    }
  });
  Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
      return _ensureBlock.default;
    }
  });
  Object.defineProperty(exports, "getAssignmentIdentifiers", {
    enumerable: true,
    get: function() {
      return _getAssignmentIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "getFunctionName", {
    enumerable: true,
    get: function() {
      return _getFunctionName.default;
    }
  });
  Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getOuterBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
      return _inheritInnerComments.default;
    }
  });
  Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
      return _inheritLeadingComments.default;
    }
  });
  Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
      return _inheritTrailingComments.default;
    }
  });
  Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
      return _inherits.default;
    }
  });
  Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
      return _inheritsComments.default;
    }
  });
  Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
      return _is.default;
    }
  });
  Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
      return _isBinding.default;
    }
  });
  Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
      return _isBlockScoped.default;
    }
  });
  Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
      return _isImmutable.default;
    }
  });
  Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
      return _isLet.default;
    }
  });
  Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
      return _isNode.default;
    }
  });
  Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
      return _isNodesEquivalent.default;
    }
  });
  Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
      return _isPlaceholderType.default;
    }
  });
  Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
      return _isReferenced.default;
    }
  });
  Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
      return _isScope.default;
    }
  });
  Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
      return _isSpecifierDefault.default;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _isType.default;
    }
  });
  Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
      return _isValidES3Identifier.default;
    }
  });
  Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
      return _isValidIdentifier.default;
    }
  });
  Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
      return _isVar.default;
    }
  });
  Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
      return _matchesPattern.default;
    }
  });
  Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
      return _prependToMemberExpression.default;
    }
  });
  exports.react = undefined;
  Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
      return _removeComments.default;
    }
  });
  Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
      return _removeProperties.default;
    }
  });
  Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
      return _removePropertiesDeep.default;
    }
  });
  Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
      return _removeTypeDuplicates.default;
    }
  });
  Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
      return _shallowEqual.default;
    }
  });
  Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
      return _toBindingIdentifierName.default;
    }
  });
  Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
      return _toBlock.default;
    }
  });
  Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
      return _toComputedKey.default;
    }
  });
  Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
      return _toExpression.default;
    }
  });
  Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
      return _toIdentifier.default;
    }
  });
  Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
      return _toKeyAlias.default;
    }
  });
  Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
      return _toStatement.default;
    }
  });
  Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
      return _traverse.default;
    }
  });
  Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
      return _traverseFast.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
      return _valueToNode.default;
    }
  });
  var _isReactComponent = require_isReactComponent();
  var _isCompatTag = require_isCompatTag();
  var _buildChildren = require_buildChildren();
  var _assertNode = require_assertNode();
  var _index = require_generated3();
  Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index[key];
      }
    });
  });
  var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
  var _createFlowUnionType = require_createFlowUnionType();
  var _createTSUnionType = require_createTSUnionType();
  var _productions = require_productions();
  Object.keys(_productions).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _productions[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _productions[key];
      }
    });
  });
  var _index2 = require_generated2();
  Object.keys(_index2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index2[key];
      }
    });
  });
  var _cloneNode = require_cloneNode();
  var _clone = require_clone();
  var _cloneDeep = require_cloneDeep();
  var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
  var _cloneWithoutLoc = require_cloneWithoutLoc();
  var _addComment = require_addComment();
  var _addComments = require_addComments();
  var _inheritInnerComments = require_inheritInnerComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritsComments = require_inheritsComments();
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _removeComments = require_removeComments();
  var _index3 = require_generated4();
  Object.keys(_index3).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index3[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index3[key];
      }
    });
  });
  var _index4 = require_constants();
  Object.keys(_index4).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index4[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index4[key];
      }
    });
  });
  var _ensureBlock = require_ensureBlock();
  var _toBindingIdentifierName = require_toBindingIdentifierName();
  var _toBlock = require_toBlock();
  var _toComputedKey = require_toComputedKey();
  var _toExpression = require_toExpression();
  var _toIdentifier = require_toIdentifier();
  var _toKeyAlias = require_toKeyAlias();
  var _toStatement = require_toStatement();
  var _valueToNode = require_valueToNode();
  var _index5 = require_definitions();
  Object.keys(_index5).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index5[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index5[key];
      }
    });
  });
  var _appendToMemberExpression = require_appendToMemberExpression();
  var _inherits = require_inherits();
  var _prependToMemberExpression = require_prependToMemberExpression();
  var _removeProperties = require_removeProperties();
  var _removePropertiesDeep = require_removePropertiesDeep();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
  var _getAssignmentIdentifiers = require_getAssignmentIdentifiers();
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
  var _getFunctionName = require_getFunctionName();
  var _traverse = require_traverse();
  Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _traverse[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _traverse[key];
      }
    });
  });
  var _traverseFast = require_traverseFast();
  var _shallowEqual = require_shallowEqual();
  var _is = require_is();
  var _isBinding = require_isBinding();
  var _isBlockScoped = require_isBlockScoped();
  var _isImmutable = require_isImmutable();
  var _isLet = require_isLet();
  var _isNode = require_isNode();
  var _isNodesEquivalent = require_isNodesEquivalent();
  var _isPlaceholderType = require_isPlaceholderType();
  var _isReferenced = require_isReferenced();
  var _isScope = require_isScope();
  var _isSpecifierDefault = require_isSpecifierDefault();
  var _isType = require_isType();
  var _isValidES3Identifier = require_isValidES3Identifier();
  var _isValidIdentifier = require_isValidIdentifier();
  var _isVar = require_isVar();
  var _matchesPattern = require_matchesPattern();
  var _validate = require_validate();
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var _index6 = require_generated();
  Object.keys(_index6).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index6[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index6[key];
      }
    });
  });
  var _deprecationWarning = require_deprecationWarning();
  var _toSequenceExpression = require_toSequenceExpression();
  var react = exports.react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
  };
  {
    exports.toSequenceExpression = _toSequenceExpression.default;
  }
  if (process.env.BABEL_TYPES_8_BREAKING) {
    console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
  }
});

// ../../../../node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.nodes = undefined;
  var _t = require_lib5();
  var {
    FLIPPED_ALIAS_KEYS,
    isArrayExpression,
    isAssignmentExpression,
    isBinary,
    isBlockStatement,
    isCallExpression,
    isFunction,
    isIdentifier,
    isLiteral,
    isMemberExpression,
    isObjectExpression,
    isOptionalCallExpression,
    isOptionalMemberExpression,
    isStringLiteral
  } = _t;
  function crawlInternal(node, state) {
    if (!node)
      return state;
    if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
      crawlInternal(node.object, state);
      if (node.computed)
        crawlInternal(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      crawlInternal(node.left, state);
      crawlInternal(node.right, state);
    } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
      state.hasCall = true;
      crawlInternal(node.callee, state);
    } else if (isFunction(node)) {
      state.hasFunction = true;
    } else if (isIdentifier(node)) {
      state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    }
    return state;
  }
  function crawl(node) {
    return crawlInternal(node, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function isHelper(node) {
    if (!node)
      return false;
    if (isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier(node)) {
      return node.name === "require" || node.name.charCodeAt(0) === 95;
    } else if (isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }
  function isType(node) {
    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
  }
  var nodes = exports.nodes = {
    AssignmentExpression(node) {
      const state = crawl(node.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
    },
    SwitchCase(node, parent) {
      return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    },
    LogicalExpression(node) {
      if (isFunction(node.left) || isFunction(node.right)) {
        return 2;
      }
    },
    Literal(node) {
      if (isStringLiteral(node) && node.value === "use strict") {
        return 2;
      }
    },
    CallExpression(node) {
      if (isFunction(node.callee) || isHelper(node)) {
        return 1 | 2;
      }
    },
    OptionalCallExpression(node) {
      if (isFunction(node.callee)) {
        return 1 | 2;
      }
    },
    VariableDeclaration(node) {
      for (let i = 0;i < node.declarations.length; i++) {
        const declar = node.declarations[i];
        let enabled = isHelper(declar.id) && !isType(declar.init);
        if (!enabled && declar.init) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
    },
    IfStatement(node) {
      if (isBlockStatement(node.consequent)) {
        return 1 | 2;
      }
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
    if (parent.properties[0] === node) {
      return 1;
    }
  };
  nodes.ObjectTypeCallProperty = function(node, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeIndexer = function(node, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeInternalSlot = function(node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
      const ret = amounts ? 1 | 2 : 0;
      nodes[type2] = () => ret;
    });
  });
});

// ../../../../node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AssignmentExpression = AssignmentExpression;
  exports.Binary = Binary;
  exports.BinaryExpression = BinaryExpression;
  exports.ClassExpression = ClassExpression;
  exports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;
  exports.DoExpression = DoExpression;
  exports.FunctionExpression = FunctionExpression;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.Identifier = Identifier;
  exports.LogicalExpression = LogicalExpression;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  exports.ObjectExpression = ObjectExpression;
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
  exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
  exports.SequenceExpression = SequenceExpression;
  exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
  exports.TSConditionalType = TSConditionalType;
  exports.TSConstructorType = exports.TSFunctionType = TSFunctionType;
  exports.TSInferType = TSInferType;
  exports.TSInstantiationExpression = TSInstantiationExpression;
  exports.TSIntersectionType = TSIntersectionType;
  exports.UnaryLike = exports.TSTypeAssertion = UnaryLike;
  exports.TSTypeOperator = TSTypeOperator;
  exports.TSUnionType = TSUnionType;
  exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.UpdateExpression = UpdateExpression;
  exports.AwaitExpression = exports.YieldExpression = YieldExpression;
  var _t = require_lib5();
  var _index = require_node();
  var {
    isArrayTypeAnnotation,
    isBinaryExpression,
    isCallExpression,
    isForOfStatement,
    isIndexedAccessType,
    isMemberExpression,
    isObjectPattern,
    isOptionalMemberExpression,
    isYieldExpression,
    isStatement
  } = _t;
  var PRECEDENCE = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function getBinaryPrecedence(node, nodeType) {
    if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
      return PRECEDENCE.get(node.operator);
    }
    if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
      return PRECEDENCE.get("in");
    }
  }
  function isTSTypeExpression(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  }
  var isClassExtendsClause = (node, parent) => {
    const parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
  };
  var hasPostfixPart = (node, parent) => {
    const parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
  };
  function NullableTypeAnnotation(node, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation(node, parent, tokenContext) {
    const parentType = parent.type;
    return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
  }
  function UpdateExpression(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }
  function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
  }
  function ObjectExpression(node, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
  }
  function DoExpression(node, parent, tokenContext) {
    return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
  }
  function Binary(node, parent) {
    const parentType = parent.type;
    if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node;
    }
    if (isClassExtendsClause(node, parent)) {
      return true;
    }
    if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    const parentPos = getBinaryPrecedence(parent, parentType);
    if (parentPos != null) {
      const nodePos = getBinaryPrecedence(node, node.type);
      if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
        return true;
      }
    }
    return;
  }
  function UnionTypeAnnotation(node, parent) {
    const parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  }
  function OptionalIndexedAccessType(node, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node;
  }
  function TSAsExpression(node, parent) {
    if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
      return true;
    }
    if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
      return true;
    }
    return Binary(node, parent);
  }
  function TSConditionalType(node, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
      return true;
    }
    if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
      return true;
    }
    if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
      return true;
    }
    return false;
  }
  function TSUnionType(node, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSIntersectionType(node, parent) {
    const parentType = parent.type;
    return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInferType(node, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
      return true;
    }
    if (node.typeParameter.constraint) {
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
    }
    return false;
  }
  function TSTypeOperator(node, parent) {
    const parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInstantiationExpression(node, parent) {
    const parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  }
  function TSFunctionType(node, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
  }
  function BinaryExpression(node, parent, tokenContext) {
    return node.operator === "in" && Boolean(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);
  }
  function SequenceExpression(node, parent) {
    const parentType = parent.type;
    if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
      return false;
    }
    if (parentType === "ClassDeclaration") {
      return true;
    }
    if (parentType === "ForOfStatement") {
      return parent.right === node;
    }
    if (parentType === "ExportDefaultDeclaration") {
      return true;
    }
    return !isStatement(parent);
  }
  function YieldExpression(node, parent) {
    const parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
  }
  function ClassExpression(node, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
  }
  function FunctionExpression(node, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function ConditionalExpression(node, parent) {
    const parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression(node, parent) {
    return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;
  }
  function AssignmentExpression(node, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression(node, parent);
    }
  }
  function LogicalExpression(node, parent) {
    const parentType = parent.type;
    if (isTSTypeExpression(parentType))
      return true;
    if (parentType !== "LogicalExpression")
      return false;
    switch (node.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  }
  function Identifier(node, parent, tokenContext, getRawIdentifier) {
    var _node$extra;
    const parentType = parent.type;
    if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
      const rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
      return false;
    }
    if (node.name === "let") {
      const isFollowedByBracket = isMemberExpression(parent, {
        object: node,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node,
        computed: true,
        optional: false
      });
      if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {
        return true;
      }
      return Boolean(tokenContext & _index.TokenContext.forOfHead);
    }
    return node.name === "async" && isForOfStatement(parent, {
      left: node,
      await: false
    });
  }
});

// ../../../../node_modules/@babel/generator/lib/node/index.js
var require_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenContext = undefined;
  exports.isLastChild = isLastChild;
  exports.needsParens = needsParens;
  exports.needsWhitespace = needsWhitespace;
  exports.needsWhitespaceAfter = needsWhitespaceAfter;
  exports.needsWhitespaceBefore = needsWhitespaceBefore;
  var whitespace = require_whitespace();
  var parens = require_parentheses();
  var _t = require_lib5();
  var {
    FLIPPED_ALIAS_KEYS,
    VISITOR_KEYS,
    isCallExpression,
    isDecorator,
    isExpressionStatement,
    isMemberExpression,
    isNewExpression,
    isParenthesizedExpression
  } = _t;
  var TokenContext = exports.TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function expandAliases(obj) {
    const map = new Map;
    function add(type, func) {
      const fn = map.get(type);
      map.set(type, fn ? function(node, parent, stack, getRawIdentifier) {
        var _fn;
        return (_fn = fn(node, parent, stack, getRawIdentifier)) != null ? _fn : func(node, parent, stack, getRawIdentifier);
      } : func);
    }
    for (const type of Object.keys(obj)) {
      const aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  }
  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
  function isOrHasCallExpression(node) {
    if (isCallExpression(node)) {
      return true;
    }
    return isMemberExpression(node) && isOrHasCallExpression(node.object);
  }
  function needsWhitespace(node, parent, type) {
    var _expandedWhitespaceNo;
    if (!node)
      return false;
    if (isExpressionStatement(node)) {
      node = node.expression;
    }
    const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? undefined : _expandedWhitespaceNo(node, parent);
    if (typeof flag === "number") {
      return (flag & type) !== 0;
    }
    return false;
  }
  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, 1);
  }
  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, 2);
  }
  function needsParens(node, parent, tokenContext, getRawIdentifier) {
    var _expandedParens$get;
    if (!parent)
      return false;
    if (isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node))
        return true;
    }
    if (isDecorator(parent)) {
      return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
    }
    return (_expandedParens$get = expandedParens.get(node.type)) == null ? undefined : _expandedParens$get(node, parent, tokenContext, getRawIdentifier);
  }
  function isDecoratorMemberExpression(node) {
    switch (node.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
      default:
        return false;
    }
  }
  function isLastChild(parent, child) {
    const visitorKeys = VISITOR_KEYS[parent.type];
    for (let i = visitorKeys.length - 1;i >= 0; i--) {
      const val = parent[visitorKeys[i]];
      if (val === child) {
        return true;
      } else if (Array.isArray(val)) {
        let j = val.length - 1;
        while (j >= 0 && val[j] === null)
          j--;
        return j >= 0 && val[j] === child;
      } else if (val) {
        return false;
      }
    }
    return false;
  }
});

// ../../../../node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenMap = undefined;
  var _t = require_lib5();
  var {
    traverseFast,
    VISITOR_KEYS
  } = _t;

  class TokenMap {
    constructor(ast, tokens, source) {
      this._tokens = undefined;
      this._source = undefined;
      this._nodesToTokenIndexes = new Map;
      this._nodesOccurrencesCountCache = new Map;
      this._tokensCache = new Map;
      this._tokens = tokens;
      this._source = source;
      traverseFast(ast, (node) => {
        const indexes = this._getTokensIndexesOfNode(node);
        if (indexes.length > 0)
          this._nodesToTokenIndexes.set(node, indexes);
      });
      this._tokensCache = null;
    }
    has(node) {
      return this._nodesToTokenIndexes.has(node);
    }
    getIndexes(node) {
      return this._nodesToTokenIndexes.get(node);
    }
    find(node, condition) {
      const indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        for (let k = 0;k < indexes.length; k++) {
          const index = indexes[k];
          const tok = this._tokens[index];
          if (condition(tok, index))
            return tok;
        }
      }
      return null;
    }
    findLastIndex(node, condition) {
      const indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        for (let k = indexes.length - 1;k >= 0; k--) {
          const index = indexes[k];
          const tok = this._tokens[index];
          if (condition(tok, index))
            return index;
        }
      }
      return -1;
    }
    findMatching(node, test, occurrenceCount = 0) {
      const indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        let i = 0;
        const count = occurrenceCount;
        if (count > 1) {
          const cache = this._nodesOccurrencesCountCache.get(node);
          if (cache && cache.test === test && cache.count < count) {
            i = cache.i + 1;
            occurrenceCount -= cache.count + 1;
          }
        }
        for (;i < indexes.length; i++) {
          const tok = this._tokens[indexes[i]];
          if (this.matchesOriginal(tok, test)) {
            if (occurrenceCount === 0) {
              if (count > 0) {
                this._nodesOccurrencesCountCache.set(node, {
                  test,
                  count,
                  i
                });
              }
              return tok;
            }
            occurrenceCount--;
          }
        }
      }
      return null;
    }
    matchesOriginal(token, test) {
      if (token.end - token.start !== test.length)
        return false;
      if (token.value != null)
        return token.value === test;
      return this._source.startsWith(test, token.start);
    }
    startMatches(node, test) {
      const indexes = this._nodesToTokenIndexes.get(node);
      if (!indexes)
        return false;
      const tok = this._tokens[indexes[0]];
      if (tok.start !== node.start)
        return false;
      return this.matchesOriginal(tok, test);
    }
    endMatches(node, test) {
      const indexes = this._nodesToTokenIndexes.get(node);
      if (!indexes)
        return false;
      const tok = this._tokens[indexes[indexes.length - 1]];
      if (tok.end !== node.end)
        return false;
      return this.matchesOriginal(tok, test);
    }
    _getTokensIndexesOfNode(node) {
      if (node.start == null || node.end == null)
        return [];
      const {
        first,
        last
      } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
      let low = first;
      const children = childrenIterator(node);
      if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
        children.next();
      }
      const indexes = [];
      for (const child of children) {
        if (child == null)
          continue;
        if (child.start == null || child.end == null)
          continue;
        const childTok = this._findTokensOfNode(child, low, last);
        const high = childTok.first;
        for (let k = low;k < high; k++)
          indexes.push(k);
        low = childTok.last + 1;
      }
      for (let k = low;k <= last; k++)
        indexes.push(k);
      return indexes;
    }
    _findTokensOfNode(node, low, high) {
      const cached = this._tokensCache.get(node);
      if (cached)
        return cached;
      const first = this._findFirstTokenOfNode(node.start, low, high);
      const last = this._findLastTokenOfNode(node.end, first, high);
      this._tokensCache.set(node, {
        first,
        last
      });
      return {
        first,
        last
      };
    }
    _findFirstTokenOfNode(start, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (start < this._tokens[mid].start) {
          high = mid - 1;
        } else if (start > this._tokens[mid].start) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return low;
    }
    _findLastTokenOfNode(end, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (end < this._tokens[mid].end) {
          high = mid - 1;
        } else if (end > this._tokens[mid].end) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return high;
    }
  }
  exports.TokenMap = TokenMap;
  function* childrenIterator(node) {
    if (node.type === "TemplateLiteral") {
      yield node.quasis[0];
      for (let i = 1;i < node.quasis.length; i++) {
        yield node.expressions[i - 1];
        yield node.quasis[i];
      }
      return;
    }
    const keys = VISITOR_KEYS[node.type];
    for (const key of keys) {
      const child = node[key];
      if (!child)
        continue;
      if (Array.isArray(child)) {
        yield* child;
      } else {
        yield child;
      }
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TaggedTemplateExpression = TaggedTemplateExpression;
  exports.TemplateElement = TemplateElement;
  exports.TemplateLiteral = TemplateLiteral;
  exports._printTemplate = _printTemplate;
  function TaggedTemplateExpression(node) {
    this.print(node.tag);
    {
      this.print(node.typeParameters);
    }
    this.print(node.quasi);
  }
  function TemplateElement() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function _printTemplate(node, substitutions) {
    const quasis = node.quasis;
    let partRaw = "`";
    for (let i = 0;i < quasis.length - 1; i++) {
      partRaw += quasis[i].value.raw;
      this.token(partRaw + "${", true);
      this.print(substitutions[i]);
      partRaw = "}";
      if (this.tokenMap) {
        const token = this.tokenMap.findMatching(node, "}", i);
        if (token)
          this._catchUpTo(token.loc.start);
      }
    }
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + "`", true);
  }
  function TemplateLiteral(node) {
    this._printTemplate(node, node.expressions);
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
  exports.AssignmentPattern = AssignmentPattern;
  exports.AwaitExpression = AwaitExpression;
  exports.BindExpression = BindExpression;
  exports.CallExpression = CallExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.Decorator = Decorator;
  exports.DoExpression = DoExpression;
  exports.EmptyStatement = EmptyStatement;
  exports.ExpressionStatement = ExpressionStatement;
  exports.Import = Import;
  exports.MemberExpression = MemberExpression;
  exports.MetaProperty = MetaProperty;
  exports.ModuleExpression = ModuleExpression;
  exports.NewExpression = NewExpression;
  exports.OptionalCallExpression = OptionalCallExpression;
  exports.OptionalMemberExpression = OptionalMemberExpression;
  exports.ParenthesizedExpression = ParenthesizedExpression;
  exports.PrivateName = PrivateName;
  exports.SequenceExpression = SequenceExpression;
  exports.Super = Super;
  exports.ThisExpression = ThisExpression;
  exports.UnaryExpression = UnaryExpression;
  exports.UpdateExpression = UpdateExpression;
  exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  exports.YieldExpression = YieldExpression;
  exports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
  var _t = require_lib5();
  var _index = require_node();
  var {
    isCallExpression,
    isLiteral,
    isMemberExpression,
    isNewExpression,
    isPattern
  } = _t;
  function UnaryExpression(node) {
    const {
      operator
    } = node;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node.argument);
  }
  function DoExpression(node) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node.body);
  }
  function ParenthesizedExpression(node) {
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.print(node.expression);
    exit();
    this.rightParens(node);
  }
  function UpdateExpression(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument);
    } else {
      this.print(node.argument, true);
      this.token(node.operator);
    }
  }
  function ConditionalExpression(node) {
    this.print(node.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.alternate);
  }
  function NewExpression(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee);
    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
      callee: node
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
      return;
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function SequenceExpression(node) {
    this.printList(node.expressions);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function _shouldPrintDecoratorsBeforeExport(node) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node.start === "number" && node.start === node.declaration.start;
  }
  function Decorator(node) {
    this.tokenChar(64);
    this.print(node.expression);
    this.newline();
  }
  function OptionalMemberExpression(node) {
    let {
      computed
    } = node;
    const {
      optional,
      property
    } = node;
    this.print(node.object);
    if (!computed && isMemberExpression(property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral(property) && typeof property.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property);
    }
  }
  function OptionalCallExpression(node) {
    this.print(node.callee);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    this.print(node.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments);
    exit();
    this.rightParens(node);
  }
  function CallExpression(node) {
    this.print(node.callee);
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function Import() {
    this.word("import");
  }
  function AwaitExpression(node) {
    this.word("await");
    this.space();
    this.print(node.argument);
  }
  function YieldExpression(node) {
    if (node.delegate) {
      this.word("yield", true);
      this.tokenChar(42);
      if (node.argument) {
        this.space();
        this.print(node.argument);
      }
    } else if (node.argument) {
      this.word("yield", true);
      this.space();
      this.print(node.argument);
    } else {
      this.word("yield");
    }
  }
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node) {
    this.tokenContext |= _index.TokenContext.expressionStatement;
    this.print(node.expression);
    this.semicolon();
  }
  function AssignmentPattern(node) {
    this.print(node.left);
    if (node.left.type === "Identifier" || isPattern(node.left)) {
      if (node.left.optional)
        this.tokenChar(63);
      this.print(node.left.typeAnnotation);
    }
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
  }
  function AssignmentExpression(node) {
    this.print(node.left);
    this.space();
    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
      this._endsWithDiv = node.operator === "/";
    }
    this.space();
    this.print(node.right);
  }
  function BindExpression(node) {
    this.print(node.object);
    this.token("::");
    this.print(node.callee);
  }
  function MemberExpression(node) {
    this.print(node.object);
    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    let computed = node.computed;
    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }
    if (computed) {
      const exit = this.enterDelimited();
      this.tokenChar(91);
      this.print(node.property);
      this.tokenChar(93);
      exit();
    } else {
      this.tokenChar(46);
      this.print(node.property);
    }
  }
  function MetaProperty(node) {
    this.print(node.meta);
    this.tokenChar(46);
    this.print(node.property);
  }
  function PrivateName(node) {
    this.tokenChar(35);
    this.print(node.id);
  }
  function V8IntrinsicIdentifier(node) {
    this.tokenChar(37);
    this.word(node.name);
  }
  function ModuleExpression(node) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {
      body
    } = node;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body);
    this.dedent();
    this.rightBrace(node);
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BreakStatement = BreakStatement;
  exports.CatchClause = CatchClause;
  exports.ContinueStatement = ContinueStatement;
  exports.DebuggerStatement = DebuggerStatement;
  exports.DoWhileStatement = DoWhileStatement;
  exports.ForOfStatement = exports.ForInStatement = undefined;
  exports.ForStatement = ForStatement;
  exports.IfStatement = IfStatement;
  exports.LabeledStatement = LabeledStatement;
  exports.ReturnStatement = ReturnStatement;
  exports.SwitchCase = SwitchCase;
  exports.SwitchStatement = SwitchStatement;
  exports.ThrowStatement = ThrowStatement;
  exports.TryStatement = TryStatement;
  exports.VariableDeclaration = VariableDeclaration;
  exports.VariableDeclarator = VariableDeclarator;
  exports.WhileStatement = WhileStatement;
  exports.WithStatement = WithStatement;
  var _t = require_lib5();
  var {
    isFor,
    isForStatement,
    isIfStatement,
    isStatement
  } = _t;
  function WithStatement(node) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node.object);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function IfStatement(node) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.space();
    const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node.consequent);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node.alternate) {
      if (this.endsWith(125))
        this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate);
    }
  }
  function getLastStatement(statement) {
    const {
      body
    } = statement;
    if (isStatement(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  }
  function ForStatement(node) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    {
      const exit = this.enterForStatementInit();
      this.print(node.init);
      exit();
    }
    this.tokenChar(59);
    if (node.test) {
      this.space();
      this.print(node.test);
    }
    this.token(";", false, 1);
    if (node.update) {
      this.space();
      this.print(node.update);
    }
    this.tokenChar(41);
    this.printBlock(node);
  }
  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function ForXStatement(node) {
    this.word("for");
    this.space();
    const isForOf = node.type === "ForOfStatement";
    if (isForOf && node.await) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
      const exit = this.enterForXStatementInit(isForOf);
      this.print(node.left);
      exit == null || exit();
    }
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node.right);
    this.tokenChar(41);
    this.printBlock(node);
  }
  var ForInStatement = exports.ForInStatement = ForXStatement;
  var ForOfStatement = exports.ForOfStatement = ForXStatement;
  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.semicolon();
  }
  function printStatementAfterKeyword(printer, node) {
    if (node) {
      printer.space();
      printer.printTerminatorless(node);
    }
    printer.semicolon();
  }
  function BreakStatement(node) {
    this.word("break");
    printStatementAfterKeyword(this, node.label);
  }
  function ContinueStatement(node) {
    this.word("continue");
    printStatementAfterKeyword(this, node.label);
  }
  function ReturnStatement(node) {
    this.word("return");
    printStatementAfterKeyword(this, node.argument);
  }
  function ThrowStatement(node) {
    this.word("throw");
    printStatementAfterKeyword(this, node.argument);
  }
  function LabeledStatement(node) {
    this.print(node.label);
    this.tokenChar(58);
    this.space();
    this.print(node.body);
  }
  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block);
    this.space();
    if (node.handlers) {
      this.print(node.handlers[0]);
    } else {
      this.print(node.handler);
    }
    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer);
    }
  }
  function CatchClause(node) {
    this.word("catch");
    this.space();
    if (node.param) {
      this.tokenChar(40);
      this.print(node.param);
      this.print(node.param.typeAnnotation);
      this.tokenChar(41);
      this.space();
    }
    this.print(node.body);
  }
  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node.cases, true, undefined, function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas)
        return -1;
    });
    this.rightBrace(node);
  }
  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, true);
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }
  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    const {
      kind
    } = node;
    if (kind === "await using") {
      this.word("await");
      this.space();
      this.word("using", true);
    } else {
      this.word(kind, kind === "using");
    }
    this.space();
    let hasInits = false;
    if (!isFor(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    this.printList(node.declarations, undefined, undefined, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
      this.token(",", false, occurrenceCount);
      this.newline();
    } : undefined);
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node)
          return;
      } else {
        if (parent.left === node)
          return;
      }
    }
    this.semicolon();
  }
  function VariableDeclarator(node) {
    this.print(node.id);
    if (node.definite)
      this.tokenChar(33);
    this.print(node.id.typeAnnotation);
    if (node.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.init);
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ClassAccessorProperty = ClassAccessorProperty;
  exports.ClassBody = ClassBody;
  exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
  exports.ClassMethod = ClassMethod;
  exports.ClassPrivateMethod = ClassPrivateMethod;
  exports.ClassPrivateProperty = ClassPrivateProperty;
  exports.ClassProperty = ClassProperty;
  exports.StaticBlock = StaticBlock;
  exports._classMethodHead = _classMethodHead;
  var _t = require_lib5();
  var {
    isExportDefaultDeclaration,
    isExportNamedDeclaration
  } = _t;
  function ClassDeclaration(node, parent) {
    const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node.decorators);
    }
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    if (node.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node.id) {
      this.space();
      this.print(node.id);
    }
    this.print(node.typeParameters);
    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass);
      this.print(node.superTypeParameters);
    }
    if (node.implements) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements);
    }
    this.space();
    this.print(node.body);
  }
  function ClassBody(node) {
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      const separator = classBodyEmptySemicolonsPrinter(this, node);
      separator == null || separator(-1);
      const exit = this.enterDelimited();
      this.printJoin(node.body, true, true, separator, true);
      exit();
      if (!this.endsWith(10))
        this.newline();
      this.rightBrace(node);
    }
  }
  function classBodyEmptySemicolonsPrinter(printer, node) {
    if (!printer.tokenMap || node.start == null || node.end == null) {
      return null;
    }
    const indexes = printer.tokenMap.getIndexes(node);
    if (!indexes)
      return null;
    let k = 1;
    let occurrenceCount = 0;
    let nextLocIndex = 0;
    const advanceNextLocIndex = () => {
      while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
        nextLocIndex++;
      }
    };
    advanceNextLocIndex();
    return (i) => {
      if (nextLocIndex <= i) {
        nextLocIndex = i + 1;
        advanceNextLocIndex();
      }
      const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
      let tok;
      while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
        printer.token(";", undefined, occurrenceCount++);
        k++;
      }
    };
  }
  function ClassProperty(node) {
    this.printJoin(node.decorators);
    if (!node.static && !this.format.preserveFormat) {
      var _node$key$loc;
      const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? undefined : _node$key$loc.line;
      if (endLine)
        this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassAccessorProperty(node) {
    var _node$key$loc2;
    this.printJoin(node.decorators);
    const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? undefined : _node$key$loc2.line;
    if (endLine)
      this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node);
    this.word("accessor", true);
    this.space();
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators);
    this.tsPrintClassMemberModifiers(node);
    this.print(node.key);
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function ClassPrivateMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators);
    if (!this.format.preserveFormat) {
      var _node$key$loc3;
      const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? undefined : _node$key$loc3.line;
      if (endLine)
        this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    this._methodHead(node);
  }
  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node.body, true);
      this.rightBrace(node);
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrowFunctionExpression = ArrowFunctionExpression;
  exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
  exports._functionHead = _functionHead;
  exports._methodHead = _methodHead;
  exports._param = _param;
  exports._parameters = _parameters;
  exports._params = _params;
  exports._predicate = _predicate;
  exports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
  var _t = require_lib5();
  var _index = require_node();
  var {
    isIdentifier
  } = _t;
  function _params(node, idNode, parentNode) {
    this.print(node.typeParameters);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node.params, ")");
    const noLineTerminator = node.type === "ArrowFunctionExpression";
    this.print(node.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  }
  function _parameters(parameters, endToken) {
    const exit = this.enterDelimited();
    const trailingComma = this.shouldPrintTrailingComma(endToken);
    const paramLength = parameters.length;
    for (let i = 0;i < paramLength; i++) {
      this._param(parameters[i]);
      if (trailingComma || i < paramLength - 1) {
        this.token(",", null, i);
        this.space();
      }
    }
    this.token(endToken);
    exit();
  }
  function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation);
  }
  function _methodHead(node) {
    const kind = node.kind;
    const key = node.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.tokenChar(42);
      }
    }
    if (node.computed) {
      this.tokenChar(91);
      this.print(key);
      this.tokenChar(93);
    } else {
      this.print(key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    this._params(node, node.computed && node.key.type !== "StringLiteral" ? undefined : node.key, undefined);
  }
  function _predicate(node, noLineTerminatorAfter) {
    if (node.predicate) {
      if (!node.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node.predicate, noLineTerminatorAfter);
    }
  }
  function _functionHead(node, parent) {
    if (node.async) {
      this.word("async");
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.space();
    }
    this.word("function");
    if (node.generator) {
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.tokenChar(42);
    }
    this.space();
    if (node.id) {
      this.print(node.id);
    }
    this._params(node, node.id, parent);
    if (node.type !== "TSDeclareFunction") {
      this._predicate(node);
    }
  }
  function FunctionExpression(node, parent) {
    this._functionHead(node, parent);
    this.space();
    this.print(node.body);
  }
  function ArrowFunctionExpression(node, parent) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (this._shouldPrintArrowParamsParens(node)) {
      this._params(node, undefined, parent);
    } else {
      this.print(node.params[0], true);
    }
    this._predicate(node, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.tokenContext |= _index.TokenContext.arrowBody;
    this.print(node.body);
  }
  function _shouldPrintArrowParamsParens(node) {
    var _firstParam$leadingCo, _firstParam$trailingC;
    if (node.params.length !== 1)
      return true;
    if (node.typeParameters || node.returnType || node.predicate) {
      return true;
    }
    const firstParam = node.params[0];
    if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
      return true;
    }
    if (this.tokenMap) {
      if (node.loc == null)
        return true;
      if (this.tokenMap.findMatching(node, "(") !== null)
        return true;
      const arrowToken = this.tokenMap.findMatching(node, "=>");
      if ((arrowToken == null ? undefined : arrowToken.loc) == null)
        return true;
      return arrowToken.loc.start.line !== node.loc.start.line;
    }
    if (this.format.retainLines)
      return true;
    return false;
  }
  function _getFuncIdName(idNode, parent) {
    let id = idNode;
    if (!id && parent) {
      const parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id)
      return;
    let nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? undefined : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? undefined : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? undefined : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? undefined : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExportAllDeclaration = ExportAllDeclaration;
  exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
  exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
  exports.ExportNamedDeclaration = ExportNamedDeclaration;
  exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  exports.ExportSpecifier = ExportSpecifier;
  exports.ImportAttribute = ImportAttribute;
  exports.ImportDeclaration = ImportDeclaration;
  exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
  exports.ImportExpression = ImportExpression;
  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  exports.ImportSpecifier = ImportSpecifier;
  exports._printAttributes = _printAttributes;
  var _t = require_lib5();
  var _index = require_node();
  var {
    isClassDeclaration,
    isExportDefaultSpecifier,
    isExportNamespaceSpecifier,
    isImportDefaultSpecifier,
    isImportNamespaceSpecifier,
    isStatement
  } = _t;
  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }
    this.print(node.imported);
    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
  }
  function ImportDefaultSpecifier(node) {
    this.print(node.local);
  }
  function ExportDefaultSpecifier(node) {
    this.print(node.exported);
  }
  function ExportSpecifier(node) {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node.local);
    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
  }
  function ExportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported);
  }
  var warningShown = false;
  function _printAttributes(node, hasPreviousBrace) {
    var _node$extra;
    const {
      importAttributesKeyword
    } = this.format;
    const {
      attributes,
      assertions
    } = node;
    if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {
      warningShown = true;
      console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
    }
    const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
      this.printList(attributes || assertions);
      return;
    }
    const occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token("{", null, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
    this.space();
    this.token("}", null, occurrenceCount);
  }
  function ExportAllDeclaration(node) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, false);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function maybePrintDecoratorsBeforeExport(printer, node) {
    if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
      printer.printJoin(node.declaration.decorators);
    }
  }
  function ExportNamedDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.space();
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement(declar))
        this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      let hasSpecial = false;
      for (;; ) {
        const first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        hasBrace = true;
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, this.shouldPrintTrailingComma("}"));
          this.space();
        }
        this.tokenChar(125);
      }
      if (node.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
          this.print(node.source, true);
          this.space();
          this._printAttributes(node, hasBrace);
        } else {
          this.print(node.source);
        }
      }
      this.semicolon();
    }
  }
  function ExportDefaultDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    this.tokenContext |= _index.TokenContext.exportDefault;
    const declar = node.declaration;
    this.print(declar);
    if (!isStatement(declar))
      this.semicolon();
  }
  function ImportDeclaration(node) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node.importKind);
      this.space();
    } else if (node.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node.phase);
      this.space();
    }
    const specifiers = node.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      const first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift());
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    let hasBrace = false;
    if (specifiers.length) {
      hasBrace = true;
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, this.shouldPrintTrailingComma("}"));
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      hasBrace = true;
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, hasBrace);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function ImportAttribute(node) {
    this.print(node.key);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ImportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.local);
  }
  function ImportExpression(node) {
    this.word("import");
    if (node.phase) {
      this.tokenChar(46);
      this.word(node.phase);
    }
    this.tokenChar(40);
    const shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
    this.print(node.source);
    if (node.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node.options);
    }
    if (shouldPrintTrailingComma) {
      this.tokenChar(44);
    }
    this.rightParens(node);
  }
});

// ../../../../node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS((exports, module) => {
  var object = {};
  var hasOwnProperty2 = object.hasOwnProperty;
  var forOwn = (object2, callback) => {
    for (const key in object2) {
      if (hasOwnProperty2.call(object2, key)) {
        callback(key, object2[key]);
      }
    }
  };
  var extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };
  var forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  var fourHexEscape = (hex) => {
    return "\\u" + ("0000" + hex).slice(-4);
  };
  var hexadecimal = (code, lowercase) => {
    let hexadecimal2 = code.toString(16);
    if (lowercase)
      return hexadecimal2;
    return hexadecimal2.toUpperCase();
  };
  var toString2 = object.toString;
  var isArray = Array.isArray;
  var isBuffer = (value) => {
    return typeof Buffer === "function" && Buffer.isBuffer(value);
  };
  var isObject = (value) => {
    return toString2.call(value) == "[object Object]";
  };
  var isString = (value) => {
    return typeof value == "string" || toString2.call(value) == "[object String]";
  };
  var isNumber = (value) => {
    return typeof value == "number" || toString2.call(value) == "[object Number]";
  };
  var isBigInt = (value) => {
    return typeof value == "bigint";
  };
  var isFunction = (value) => {
    return typeof value == "function";
  };
  var isMap = (value) => {
    return toString2.call(value) == "[object Map]";
  };
  var isSet = (value) => {
    return toString2.call(value) == "[object Set]";
  };
  var singleEscapes = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t"
  };
  var regexSingleEscape = /[\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
  var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
  var jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    const defaults = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: "single",
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: "decimal",
      indent: "\t",
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false
    };
    const json = options && options.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
      options.quotes = "single";
    }
    const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
    const compact = options.compact;
    const lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel);
    let oldIndent = "";
    const inline1 = options.__inline1__;
    const inline2 = options.__inline2__;
    const newLine = compact ? "" : `
`;
    let result;
    let isEmpty = true;
    const useBinNumbers = options.numbers == "binary";
    const useOctNumbers = options.numbers == "octal";
    const useDecNumbers = options.numbers == "decimal";
    const useHexNumbers = options.numbers == "hexadecimal";
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value) => {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      } else if (isNumber(argument) || isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        let result2;
        if (useDecNumbers) {
          result2 = String(argument);
        } else if (useHexNumbers) {
          let hexadecimal2 = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal2 = hexadecimal2.toUpperCase();
          }
          result2 = "0x" + hexadecimal2;
        } else if (useBinNumbers) {
          result2 = "0b" + argument.toString(2);
        } else if (useOctNumbers) {
          result2 = "0o" + argument.toString(8);
        }
        if (isBigInt(argument)) {
          return result2 + "n";
        }
        return result2;
      } else if (isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        return argument + "n";
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
        });
        if (isEmpty) {
          return "{}";
        }
        return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
      }
    }
    const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
      if (pair) {
        if (options.minimal)
          return pair;
        const first = pair.charCodeAt(0);
        const second = pair.charCodeAt(1);
        if (options.es6) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          const hex2 = hexadecimal(codePoint, lowercaseHex);
          return "\\u{" + hex2 + "}";
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone) {
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      }
      if (char == "\x00" && !json && !regexDigit.test(string.charAt(index + 1))) {
        return "\\0";
      }
      if (quoteChar) {
        if (quoteChar == quote || options.escapeEverything) {
          return "\\" + quoteChar;
        }
        return quoteChar;
      }
      if (regexSingleEscape.test(char)) {
        return singleEscapes[char];
      }
      if (options.minimal && !regexWhitespace.test(char)) {
        return char;
      }
      const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
      if (json || hex.length > 2) {
        return fourHexEscape(hex);
      }
      return "\\x" + ("00" + hex).slice(-2);
    });
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options.isScriptContext) {
      result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    return result;
  };
  jsesc.version = "3.0.2";
  module.exports = jsesc;
});

// ../../../../node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArgumentPlaceholder = ArgumentPlaceholder;
  exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
  exports.BigIntLiteral = BigIntLiteral;
  exports.BooleanLiteral = BooleanLiteral;
  exports.Identifier = Identifier;
  exports.NullLiteral = NullLiteral;
  exports.NumericLiteral = NumericLiteral;
  exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
  exports.ObjectMethod = ObjectMethod;
  exports.ObjectProperty = ObjectProperty;
  exports.PipelineBareFunction = PipelineBareFunction;
  exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
  exports.PipelineTopicExpression = PipelineTopicExpression;
  exports.RecordExpression = RecordExpression;
  exports.RegExpLiteral = RegExpLiteral;
  exports.SpreadElement = exports.RestElement = RestElement;
  exports.StringLiteral = StringLiteral;
  exports.TopicReference = TopicReference;
  exports.TupleExpression = TupleExpression;
  exports.VoidPattern = VoidPattern;
  exports._getRawIdentifier = _getRawIdentifier;
  var _t = require_lib5();
  var _jsesc = require_jsesc();
  var {
    isAssignmentPattern,
    isIdentifier
  } = _t;
  var lastRawIdentNode = null;
  var lastRawIdentResult = "";
  function _getRawIdentifier(node) {
    if (node === lastRawIdentNode)
      return lastRawIdentResult;
    lastRawIdentNode = node;
    const {
      name
    } = node;
    const token = this.tokenMap.find(node, (tok) => tok.value === name);
    if (token) {
      lastRawIdentResult = this._originalCode.slice(token.start, token.end);
      return lastRawIdentResult;
    }
    return lastRawIdentResult = node.name;
  }
  function Identifier(node) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node.loc) == null ? undefined : _node$loc.identifierName) || node.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
  }
  function ArgumentPlaceholder() {
    this.tokenChar(63);
  }
  function RestElement(node) {
    this.token("...");
    this.print(node.argument);
  }
  function ObjectExpression(node) {
    const props = node.properties;
    this.tokenChar(123);
    if (props.length) {
      const exit = this.enterDelimited();
      this.space();
      this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
      this.space();
      exit();
    }
    this.sourceWithOffset("end", node.loc, -1);
    this.tokenChar(125);
  }
  function ObjectMethod(node) {
    this.printJoin(node.decorators);
    this._methodHead(node);
    this.space();
    this.print(node.body);
  }
  function ObjectProperty(node) {
    this.printJoin(node.decorators);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value);
        return;
      }
      this.print(node.key);
      if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ArrayExpression(node) {
    const elems = node.elements;
    const len = elems.length;
    this.tokenChar(91);
    const exit = this.enterDelimited();
    for (let i = 0;i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0)
          this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
          this.token(",", false, i);
        }
      } else {
        this.token(",", false, i);
      }
    }
    exit();
    this.tokenChar(93);
  }
  function RecordExpression(node) {
    const props = node.properties;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      } else {
        startToken = "#{";
        endToken = "}";
      }
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
      this.space();
    }
    this.token(endToken);
  }
  function TupleExpression(node) {
    const elems = node.elements;
    const len = elems.length;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      }
    }
    this.token(startToken);
    for (let i = 0;i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0)
          this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
          this.token(",", false, i);
        }
      }
    }
    this.token(endToken);
  }
  function RegExpLiteral(node) {
    this.word(`/${node.pattern}/${node.flags}`);
  }
  function BooleanLiteral(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral() {
    this.word("null");
  }
  function NumericLiteral(node) {
    const raw = this.getPossibleRaw(node);
    const opts = this.format.jsescOption;
    const value = node.value;
    const str = value + "";
    if (opts.numbers) {
      this.number(_jsesc(value, opts), value);
    } else if (raw == null) {
      this.number(str, value);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value);
    } else {
      this.number(raw, value);
    }
  }
  function StringLiteral(node) {
    const raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    const val = _jsesc(node.value, this.format.jsescOption);
    this.token(val);
  }
  function BigIntLiteral(node) {
    const raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.word(raw);
      return;
    }
    this.word(node.value + "n");
  }
  var validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
  function TopicReference() {
    const {
      topicToken
    } = this.format;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      const givenTopicTokenJSON = JSON.stringify(topicToken);
      const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
      throw new Error(`The "topicToken" generator option must be one of ` + `${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
    }
  }
  function PipelineTopicExpression(node) {
    this.print(node.expression);
  }
  function PipelineBareFunction(node) {
    this.print(node.callee);
  }
  function PipelinePrimaryTopicReference() {
    this.tokenChar(35);
  }
  function VoidPattern() {
    this.word("void");
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnyTypeAnnotation = AnyTypeAnnotation;
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
  exports.DeclareClass = DeclareClass;
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
  exports.DeclareExportDeclaration = DeclareExportDeclaration;
  exports.DeclareFunction = DeclareFunction;
  exports.DeclareInterface = DeclareInterface;
  exports.DeclareModule = DeclareModule;
  exports.DeclareModuleExports = DeclareModuleExports;
  exports.DeclareOpaqueType = DeclareOpaqueType;
  exports.DeclareTypeAlias = DeclareTypeAlias;
  exports.DeclareVariable = DeclareVariable;
  exports.DeclaredPredicate = DeclaredPredicate;
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
  exports.EnumBooleanBody = EnumBooleanBody;
  exports.EnumBooleanMember = EnumBooleanMember;
  exports.EnumDeclaration = EnumDeclaration;
  exports.EnumDefaultedMember = EnumDefaultedMember;
  exports.EnumNumberBody = EnumNumberBody;
  exports.EnumNumberMember = EnumNumberMember;
  exports.EnumStringBody = EnumStringBody;
  exports.EnumStringMember = EnumStringMember;
  exports.EnumSymbolBody = EnumSymbolBody;
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.FunctionTypeParam = FunctionTypeParam;
  exports.IndexedAccessType = IndexedAccessType;
  exports.InferredPredicate = InferredPredicate;
  exports.InterfaceDeclaration = InterfaceDeclaration;
  exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
  exports.MixedTypeAnnotation = MixedTypeAnnotation;
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _types2.NumericLiteral;
    }
  });
  exports.NumberTypeAnnotation = NumberTypeAnnotation;
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
  exports.ObjectTypeIndexer = ObjectTypeIndexer;
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
  exports.ObjectTypeProperty = ObjectTypeProperty;
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
  exports.OpaqueType = OpaqueType;
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _types2.StringLiteral;
    }
  });
  exports.StringTypeAnnotation = StringTypeAnnotation;
  exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
  exports.ThisTypeAnnotation = ThisTypeAnnotation;
  exports.TupleTypeAnnotation = TupleTypeAnnotation;
  exports.TypeAlias = TypeAlias;
  exports.TypeAnnotation = TypeAnnotation;
  exports.TypeCastExpression = TypeCastExpression;
  exports.TypeParameter = TypeParameter;
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
  exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.Variance = Variance;
  exports.VoidTypeAnnotation = VoidTypeAnnotation;
  exports._interfaceish = _interfaceish;
  exports._variance = _variance;
  var _t = require_lib5();
  var _modules = require_modules();
  var _index = require_node();
  var _types2 = require_types();
  var {
    isDeclareExportDeclaration,
    isStatement
  } = _t;
  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("class");
    this.space();
    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("function");
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation.typeAnnotation);
    if (node.predicate) {
      this.space();
      this.print(node.predicate);
    }
    this.semicolon();
  }
  function InferredPredicate() {
    this.tokenChar(37);
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.tokenChar(37);
    this.word("checks");
    this.tokenChar(40);
    this.print(node.value);
    this.tokenChar(41);
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id);
    this.space();
    this.print(node.body);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.tokenChar(46);
    this.word("exports");
    this.print(node.typeAnnotation);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("var");
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();
    if (node.default) {
      this.word("default");
      this.space();
    }
    FlowExportDeclaration.call(this, node);
  }
  function DeclareExportAllDeclaration(node) {
    this.word("declare");
    this.space();
    _modules.ExportAllDeclaration.call(this, node);
  }
  function EnumDeclaration(node) {
    const {
      id,
      body
    } = node;
    this.word("enum");
    this.space();
    this.print(id);
    this.print(body);
  }
  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }
    context.space();
  }
  function enumBody(context, node) {
    const {
      members
    } = node;
    context.token("{");
    context.indent();
    context.newline();
    for (const member of members) {
      context.print(member);
      context.newline();
    }
    if (node.hasUnknownMembers) {
      context.token("...");
      context.newline();
    }
    context.dedent();
    context.token("}");
  }
  function EnumBooleanBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }
  function EnumNumberBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }
  function EnumStringBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }
  function EnumSymbolBody(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }
  function EnumDefaultedMember(node) {
    const {
      id
    } = node;
    this.print(id);
    this.tokenChar(44);
  }
  function enumInitializedMember(context, node) {
    context.print(node.id);
    context.space();
    context.token("=");
    context.space();
    context.print(node.init);
    context.token(",");
  }
  function EnumBooleanMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumNumberMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumStringMember(node) {
    enumInitializedMember(this, node);
  }
  function FlowExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement(declar))
        this.semicolon();
    } else {
      this.tokenChar(123);
      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers);
        this.space();
      }
      this.tokenChar(125);
      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source);
      }
      this.semicolon();
    }
  }
  function ExistsTypeAnnotation() {
    this.tokenChar(42);
  }
  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters);
    this.tokenChar(40);
    if (node.this) {
      this.word("this");
      this.tokenChar(58);
      this.space();
      this.print(node.this.typeAnnotation);
      if (node.params.length || node.rest) {
        this.tokenChar(44);
        this.space();
      }
    }
    this.printList(node.params);
    if (node.rest) {
      if (node.params.length) {
        this.tokenChar(44);
        this.space();
      }
      this.token("...");
      this.print(node.rest);
    }
    this.tokenChar(41);
    const type = parent == null ? undefined : parent.type;
    if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
      this.tokenChar(58);
    } else {
      this.space();
      this.token("=>");
    }
    this.space();
    this.print(node.returnType);
  }
  function FunctionTypeParam(node) {
    this.print(node.name);
    if (node.optional)
      this.tokenChar(63);
    if (node.name) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.typeAnnotation);
  }
  function InterfaceExtends(node) {
    this.print(node.id);
    this.print(node.typeParameters, true);
  }
  function _interfaceish(node) {
    var _node$extends;
    this.print(node.id);
    this.print(node.typeParameters);
    if ((_node$extends = node.extends) != null && _node$extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends);
    }
    if (node.type === "DeclareClass") {
      var _node$mixins, _node$implements;
      if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
        this.space();
        this.word("mixins");
        this.space();
        this.printList(node.mixins);
      }
      if ((_node$implements = node.implements) != null && _node$implements.length) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements);
      }
    }
    this.space();
    this.print(node.body);
  }
  function _variance(node) {
    var _node$variance;
    const kind = (_node$variance = node.variance) == null ? undefined : _node$variance.kind;
    if (kind != null) {
      if (kind === "plus") {
        this.tokenChar(43);
      } else if (kind === "minus") {
        this.tokenChar(45);
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();
    this._interfaceish(node);
  }
  function andSeparator(occurrenceCount) {
    this.space();
    this.token("&", false, occurrenceCount);
    this.space();
  }
  function InterfaceTypeAnnotation(node) {
    var _node$extends2;
    this.word("interface");
    if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends);
    }
    this.space();
    this.print(node.body);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, undefined, undefined, andSeparator);
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation(node) {
    this.tokenChar(63);
    this.print(node.typeAnnotation);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.tokenChar(91);
    this.printList(node.types);
    this.tokenChar(93);
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
    this.semicolon();
  }
  function TypeAnnotation(node, parent) {
    this.tokenChar(58);
    this.space();
    if (parent.type === "ArrowFunctionExpression") {
      this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
    } else if (node.optional) {
      this.tokenChar(63);
    }
    this.print(node.typeAnnotation);
  }
  function TypeParameterInstantiation(node) {
    this.tokenChar(60);
    this.printList(node.params);
    this.tokenChar(62);
  }
  function TypeParameter(node) {
    this._variance(node);
    this.word(node.name);
    if (node.bound) {
      this.print(node.bound);
    }
    if (node.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.default);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    if (node.supertype) {
      this.tokenChar(58);
      this.space();
      this.print(node.supertype);
    }
    if (node.impltype) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.impltype);
    }
    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    if (node.exact) {
      this.token("{|");
    } else {
      this.tokenChar(123);
    }
    const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
    if (props.length) {
      this.newline();
      this.space();
      this.printJoin(props, true, true, undefined, undefined, function addNewlines(leading) {
        if (leading && !props[0])
          return 1;
      }, () => {
        if (props.length !== 1 || node.inexact) {
          this.tokenChar(44);
          this.space();
        }
      });
      this.space();
    }
    if (node.inexact) {
      this.indent();
      this.token("...");
      if (props.length) {
        this.newline();
      }
      this.dedent();
    }
    if (node.exact) {
      this.token("|}");
    } else {
      this.tokenChar(125);
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.tokenChar(91);
    this.tokenChar(91);
    this.print(node.id);
    this.tokenChar(93);
    this.tokenChar(93);
    if (node.optional)
      this.tokenChar(63);
    if (!node.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeCallProperty(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeIndexer(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.tokenChar(91);
    if (node.id) {
      this.print(node.id);
      this.tokenChar(58);
      this.space();
    }
    this.print(node.key);
    this.tokenChar(93);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }
    if (node.static) {
      this.word("static");
      this.space();
    }
    if (node.kind === "get" || node.kind === "set") {
      this.word(node.kind);
      this.space();
    }
    this._variance(node);
    this.print(node.key);
    if (node.optional)
      this.tokenChar(63);
    if (!node.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification);
    this.tokenChar(46);
    this.print(node.id);
  }
  function SymbolTypeAnnotation() {
    this.word("symbol");
  }
  function orSeparator(occurrenceCount) {
    this.space();
    this.token("|", false, occurrenceCount);
    this.space();
  }
  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, undefined, undefined, orSeparator);
  }
  function TypeCastExpression(node) {
    this.tokenChar(40);
    this.print(node.expression);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.tokenChar(43);
    } else {
      this.tokenChar(45);
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }
  function IndexedAccessType(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
  function OptionalIndexedAccessType(node) {
    this.print(node.objectType);
    if (node.optional) {
      this.token("?.");
    }
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BlockStatement = BlockStatement;
  exports.Directive = Directive;
  exports.DirectiveLiteral = DirectiveLiteral;
  exports.File = File;
  exports.InterpreterDirective = InterpreterDirective;
  exports.Placeholder = Placeholder;
  exports.Program = Program;
  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter);
    }
    this.print(node.program);
  }
  function Program(node) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = (_node$directives = node.directives) == null ? undefined : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      const newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, undefined, newline);
      if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body);
  }
  function BlockStatement(node) {
    var _node$directives2;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    const directivesLen = (_node$directives2 = node.directives) == null ? undefined : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      const newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, true, newline);
      if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body, true);
    exit();
    this.rightBrace(node);
  }
  function Directive(node) {
    this.print(node.value);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node) {
    const raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    const {
      value
    } = node;
    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token(`'${value}'`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node) {
    this.token(`#!${node.value}`);
    this.newline(1, true);
  }
  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");
    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.JSXAttribute = JSXAttribute;
  exports.JSXClosingElement = JSXClosingElement;
  exports.JSXClosingFragment = JSXClosingFragment;
  exports.JSXElement = JSXElement;
  exports.JSXEmptyExpression = JSXEmptyExpression;
  exports.JSXExpressionContainer = JSXExpressionContainer;
  exports.JSXFragment = JSXFragment;
  exports.JSXIdentifier = JSXIdentifier;
  exports.JSXMemberExpression = JSXMemberExpression;
  exports.JSXNamespacedName = JSXNamespacedName;
  exports.JSXOpeningElement = JSXOpeningElement;
  exports.JSXOpeningFragment = JSXOpeningFragment;
  exports.JSXSpreadAttribute = JSXSpreadAttribute;
  exports.JSXSpreadChild = JSXSpreadChild;
  exports.JSXText = JSXText;
  function JSXAttribute(node) {
    this.print(node.name);
    if (node.value) {
      this.tokenChar(61);
      this.print(node.value);
    }
  }
  function JSXIdentifier(node) {
    this.word(node.name);
  }
  function JSXNamespacedName(node) {
    this.print(node.namespace);
    this.tokenChar(58);
    this.print(node.name);
  }
  function JSXMemberExpression(node) {
    this.print(node.object);
    this.tokenChar(46);
    this.print(node.property);
  }
  function JSXSpreadAttribute(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.argument);
    this.rightBrace(node);
  }
  function JSXExpressionContainer(node) {
    this.tokenChar(123);
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXSpreadChild(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXText(node) {
    const raw = this.getPossibleRaw(node);
    if (raw !== undefined) {
      this.token(raw, true);
    } else {
      this.token(node.value, true);
    }
  }
  function JSXElement(node) {
    const open = node.openingElement;
    this.print(open);
    if (open.selfClosing)
      return;
    this.indent();
    for (const child of node.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node.closingElement);
  }
  function spaceSeparator() {
    this.space();
  }
  function JSXOpeningElement(node) {
    this.tokenChar(60);
    this.print(node.name);
    {
      if (node.typeArguments) {
        this.print(node.typeArguments);
      }
      this.print(node.typeParameters);
    }
    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, undefined, undefined, spaceSeparator);
    }
    if (node.selfClosing) {
      this.space();
      this.tokenChar(47);
    }
    this.tokenChar(62);
  }
  function JSXClosingElement(node) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node.name);
    this.tokenChar(62);
  }
  function JSXEmptyExpression() {
    this.printInnerComments();
  }
  function JSXFragment(node) {
    this.print(node.openingFragment);
    this.indent();
    for (const child of node.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node.closingFragment);
  }
  function JSXOpeningFragment() {
    this.tokenChar(60);
    this.tokenChar(62);
  }
  function JSXClosingFragment() {
    this.token("</");
    this.tokenChar(62);
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TSAnyKeyword = TSAnyKeyword;
  exports.TSArrayType = TSArrayType;
  exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
  exports.TSBigIntKeyword = TSBigIntKeyword;
  exports.TSBooleanKeyword = TSBooleanKeyword;
  exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  exports.TSInterfaceHeritage = exports.TSClassImplements = TSClassImplements;
  exports.TSConditionalType = TSConditionalType;
  exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  exports.TSConstructorType = TSConstructorType;
  exports.TSDeclareFunction = TSDeclareFunction;
  exports.TSDeclareMethod = TSDeclareMethod;
  exports.TSEnumBody = TSEnumBody;
  exports.TSEnumDeclaration = TSEnumDeclaration;
  exports.TSEnumMember = TSEnumMember;
  exports.TSExportAssignment = TSExportAssignment;
  exports.TSExternalModuleReference = TSExternalModuleReference;
  exports.TSFunctionType = TSFunctionType;
  exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  exports.TSImportType = TSImportType;
  exports.TSIndexSignature = TSIndexSignature;
  exports.TSIndexedAccessType = TSIndexedAccessType;
  exports.TSInferType = TSInferType;
  exports.TSInstantiationExpression = TSInstantiationExpression;
  exports.TSInterfaceBody = TSInterfaceBody;
  exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
  exports.TSIntersectionType = TSIntersectionType;
  exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
  exports.TSLiteralType = TSLiteralType;
  exports.TSMappedType = TSMappedType;
  exports.TSMethodSignature = TSMethodSignature;
  exports.TSModuleBlock = TSModuleBlock;
  exports.TSModuleDeclaration = TSModuleDeclaration;
  exports.TSNamedTupleMember = TSNamedTupleMember;
  exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  exports.TSNeverKeyword = TSNeverKeyword;
  exports.TSNonNullExpression = TSNonNullExpression;
  exports.TSNullKeyword = TSNullKeyword;
  exports.TSNumberKeyword = TSNumberKeyword;
  exports.TSObjectKeyword = TSObjectKeyword;
  exports.TSOptionalType = TSOptionalType;
  exports.TSParameterProperty = TSParameterProperty;
  exports.TSParenthesizedType = TSParenthesizedType;
  exports.TSPropertySignature = TSPropertySignature;
  exports.TSQualifiedName = TSQualifiedName;
  exports.TSRestType = TSRestType;
  exports.TSStringKeyword = TSStringKeyword;
  exports.TSSymbolKeyword = TSSymbolKeyword;
  exports.TSTemplateLiteralType = TSTemplateLiteralType;
  exports.TSThisType = TSThisType;
  exports.TSTupleType = TSTupleType;
  exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  exports.TSTypeAnnotation = TSTypeAnnotation;
  exports.TSTypeAssertion = TSTypeAssertion;
  exports.TSTypeLiteral = TSTypeLiteral;
  exports.TSTypeOperator = TSTypeOperator;
  exports.TSTypeParameter = TSTypeParameter;
  exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  exports.TSTypePredicate = TSTypePredicate;
  exports.TSTypeQuery = TSTypeQuery;
  exports.TSTypeReference = TSTypeReference;
  exports.TSUndefinedKeyword = TSUndefinedKeyword;
  exports.TSUnionType = TSUnionType;
  exports.TSUnknownKeyword = TSUnknownKeyword;
  exports.TSVoidKeyword = TSVoidKeyword;
  exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
  exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  function TSTypeAnnotation(node, parent) {
    this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
    this.space();
    if (node.optional)
      this.tokenChar(63);
    this.print(node.typeAnnotation);
  }
  function TSTypeParameterInstantiation(node, parent) {
    this.tokenChar(60);
    let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
    if (this.tokenMap && node.start != null && node.end != null) {
      printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t) => this.tokenMap.matchesOriginal(t, ",")));
      printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
    }
    this.printList(node.params, printTrailingSeparator);
    this.tokenChar(62);
  }
  function TSTypeParameter(node) {
    if (node.const) {
      this.word("const");
      this.space();
    }
    if (node.in) {
      this.word("in");
      this.space();
    }
    if (node.out) {
      this.word("out");
      this.space();
    }
    this.word(node.name);
    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint);
    }
    if (node.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.default);
    }
  }
  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }
    if (node.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node.parameter);
  }
  function TSDeclareFunction(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node, parent);
    this.semicolon();
  }
  function TSDeclareMethod(node) {
    this._classMethodHead(node);
    this.semicolon();
  }
  function TSQualifiedName(node) {
    this.print(node.left);
    this.tokenChar(46);
    this.print(node.right);
  }
  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function maybePrintTrailingCommaOrSemicolon(printer, node) {
    if (!printer.tokenMap || !node.start || !node.end) {
      printer.semicolon();
      return;
    }
    if (printer.tokenMap.endMatches(node, ",")) {
      printer.token(",");
    } else if (printer.tokenMap.endMatches(node, ";")) {
      printer.semicolon();
    }
  }
  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSPropertySignature(node) {
    const {
      readonly
    } = node;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.tokenChar(91);
    }
    this.print(node.key);
    if (node.computed) {
      this.tokenChar(93);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
  }
  function TSMethodSignature(node) {
    const {
      kind
    } = node;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSIndexSignature(node) {
    const {
      readonly,
      static: isStatic
    } = node;
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node.parameters, "]");
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType(node) {
    if (node.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    const {
      typeParameters
    } = node;
    const parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    this.space();
    const returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function TSTypeReference(node) {
    const typeArguments = node.typeParameters;
    this.print(node.typeName, !!typeArguments);
    this.print(typeArguments);
  }
  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node.parameterName);
    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
    const typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSTypeLiteral(node) {
    printBraced(this, node, () => this.printJoin(node.members, true, true));
  }
  function TSArrayType(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function TSTupleType(node) {
    this.tokenChar(91);
    this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
    this.tokenChar(93);
  }
  function TSOptionalType(node) {
    this.print(node.typeAnnotation);
    this.tokenChar(63);
  }
  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation);
  }
  function TSNamedTupleMember(node) {
    this.print(node.label);
    if (node.optional)
      this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node.elementType);
  }
  function TSUnionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "|");
  }
  function TSIntersectionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "&");
  }
  function tsPrintUnionOrIntersectionType(printer, node, sep) {
    var _printer$tokenMap;
    let hasLeadingToken = 0;
    if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
      hasLeadingToken = 1;
      printer.token(sep);
    }
    printer.printJoin(node.types, undefined, undefined, function(i) {
      this.space();
      this.token(sep, null, i + hasLeadingToken);
      this.space();
    });
  }
  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.falseType);
  }
  function TSInferType(node) {
    this.word("infer");
    this.print(node.typeParameter);
  }
  function TSParenthesizedType(node) {
    this.tokenChar(40);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
  }
  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation);
  }
  function TSIndexedAccessType(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
  function TSMappedType(node) {
    const {
      nameType,
      optional,
      readonly,
      typeAnnotation
    } = node;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    {
      this.word(node.typeParameter.name);
    }
    this.space();
    this.word("in");
    this.space();
    {
      this.print(node.typeParameter.constraint);
    }
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    if (typeAnnotation) {
      this.tokenChar(58);
      this.space();
      this.print(typeAnnotation);
    }
    this.space();
    exit();
    this.tokenChar(125);
  }
  function tokenIfPlusMinus(self2, tok) {
    if (tok !== true) {
      self2.token(tok);
    }
  }
  function TSTemplateLiteralType(node) {
    this._printTemplate(node, node.types);
  }
  function TSLiteralType(node) {
    this.print(node.literal);
  }
  function TSClassImplements(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
  }
  function TSInterfaceDeclaration(node) {
    const {
      declare,
      id,
      typeParameters,
      extends: extendz,
      body
    } = node;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id);
    this.print(typeParameters);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz);
    }
    this.space();
    this.print(body);
  }
  function TSInterfaceBody(node) {
    printBraced(this, node, () => this.printJoin(node.body, true, true));
  }
  function TSTypeAliasDeclaration(node) {
    const {
      declare,
      id,
      typeParameters,
      typeAnnotation
    } = node;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation);
    this.semicolon();
  }
  function TSTypeExpression(node) {
    const {
      type,
      expression,
      typeAnnotation
    } = node;
    this.print(expression, true);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation);
  }
  function TSTypeAssertion(node) {
    const {
      typeAnnotation,
      expression
    } = node;
    this.tokenChar(60);
    this.print(typeAnnotation);
    this.tokenChar(62);
    this.space();
    this.print(expression);
  }
  function TSInstantiationExpression(node) {
    this.print(node.expression);
    {
      this.print(node.typeParameters);
    }
  }
  function TSEnumDeclaration(node) {
    const {
      declare,
      const: isConst,
      id
    } = node;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id);
    this.space();
    {
      TSEnumBody.call(this, node);
    }
  }
  function TSEnumBody(node) {
    printBraced(this, node, () => {
      var _this$shouldPrintTrai;
      return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
    });
  }
  function TSEnumMember(node) {
    const {
      id,
      initializer
    } = node;
    this.print(id);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer);
    }
  }
  function TSModuleDeclaration(node) {
    const {
      declare,
      id,
      kind
    } = node;
    if (declare) {
      this.word("declare");
      this.space();
    }
    {
      if (!node.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node.body) {
        this.semicolon();
        return;
      }
      let body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
  }
  function TSModuleBlock(node) {
    printBraced(this, node, () => this.printSequence(node.body, true));
  }
  function TSImportType(node) {
    const {
      argument,
      qualifier,
      options
    } = node;
    this.word("import");
    this.tokenChar(40);
    this.print(argument);
    if (options) {
      this.tokenChar(44);
      this.print(options);
    }
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier);
    }
    const typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSImportEqualsDeclaration(node) {
    const {
      id,
      moduleReference
    } = node;
    if (node.isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
  }
  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression);
    this.tokenChar(41);
  }
  function TSNonNullExpression(node) {
    this.print(node.expression);
    this.tokenChar(33);
  }
  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.expression);
    this.semicolon();
  }
  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id);
    this.semicolon();
  }
  function tsPrintSignatureDeclarationBase(node) {
    const {
      typeParameters
    } = node;
    const parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    const returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function tsPrintClassMemberModifiers(node) {
    const isPrivateField = node.type === "ClassPrivateProperty";
    const isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
    printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
    if (node.static) {
      this.word("static");
      this.space();
    }
    printModifiersList(this, node, [!isPrivateField && node.abstract && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
  }
  function printBraced(printer, node, cb) {
    printer.token("{");
    const exit = printer.enterDelimited();
    cb();
    exit();
    printer.rightBrace(node);
  }
  function printModifiersList(printer, node, modifiers) {
    var _printer$tokenMap2;
    const modifiersSet = new Set;
    for (const modifier of modifiers) {
      if (modifier)
        modifiersSet.add(modifier);
    }
    (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => {
      if (modifiersSet.has(tok.value)) {
        printer.token(tok.value);
        printer.space();
        modifiersSet.delete(tok.value);
        return modifiersSet.size === 0;
      }
    });
    for (const modifier of modifiersSet) {
      printer.word(modifier);
      printer.space();
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _templateLiterals = require_template_literals();
  Object.keys(_templateLiterals).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _templateLiterals[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _templateLiterals[key];
      }
    });
  });
  var _expressions = require_expressions();
  Object.keys(_expressions).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _expressions[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _expressions[key];
      }
    });
  });
  var _statements = require_statements();
  Object.keys(_statements).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _statements[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _statements[key];
      }
    });
  });
  var _classes = require_classes();
  Object.keys(_classes).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _classes[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _classes[key];
      }
    });
  });
  var _methods = require_methods();
  Object.keys(_methods).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _methods[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _methods[key];
      }
    });
  });
  var _modules = require_modules();
  Object.keys(_modules).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _modules[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _modules[key];
      }
    });
  });
  var _types = require_types();
  Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _types[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _types[key];
      }
    });
  });
  var _flow = require_flow2();
  Object.keys(_flow).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _flow[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _flow[key];
      }
    });
  });
  var _base = require_base();
  Object.keys(_base).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _base[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _base[key];
      }
    });
  });
  var _jsx = require_jsx2();
  Object.keys(_jsx).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _jsx[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _jsx[key];
      }
    });
  });
  var _typescript = require_typescript2();
  Object.keys(_typescript).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _typescript[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _typescript[key];
      }
    });
  });
});

// ../../../../node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addDeprecatedGenerators = addDeprecatedGenerators;
  function addDeprecatedGenerators(PrinterClass) {
    {
      const deprecatedBabel7Generators = {
        Noop() {},
        TSExpressionWithTypeArguments(node) {
          this.print(node.expression);
          this.print(node.typeParameters);
        },
        DecimalLiteral(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw !== undefined) {
            this.word(raw);
            return;
          }
          this.word(node.value + "m");
        }
      };
      Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
    }
  }
});

// ../../../../node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _buffer = require_buffer();
  var _index = require_node();
  var n = _index;
  var _t = require_lib5();
  var _tokenMap = require_token_map();
  var generatorFunctions = require_generators();
  var _deprecated = require_deprecated();
  var {
    isExpression,
    isFunction,
    isStatement,
    isClassBody,
    isTSInterfaceBody,
    isTSEnumMember
  } = _t;
  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
  var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
  function commentIsNewline(c) {
    return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
  }
  var {
    needsParens
  } = n;

  class Printer {
    constructor(format, map, tokens, originalCode) {
      this.tokenContext = _index.TokenContext.normal;
      this._tokens = null;
      this._originalCode = null;
      this._currentNode = null;
      this._indent = 0;
      this._indentRepeat = 0;
      this._insideAux = false;
      this._noLineTerminator = false;
      this._noLineTerminatorAfterNode = null;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new Set;
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this._endsWithDiv = false;
      this._lastCommentLine = 0;
      this._endsWithInnerRaw = false;
      this._indentInnerComments = true;
      this.tokenMap = null;
      this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
      this._printSemicolonBeforeNextNode = -1;
      this._printSemicolonBeforeNextToken = -1;
      this.format = format;
      this._tokens = tokens;
      this._originalCode = originalCode;
      this._indentRepeat = format.indent.style.length;
      this._inputMap = map == null ? undefined : map._inputMap;
      this._buf = new _buffer.default(map, format.indent.style[0]);
    }
    enterForStatementInit() {
      this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate;
      return () => this.tokenContext = _index.TokenContext.normal;
    }
    enterForXStatementInit(isForOf) {
      if (isForOf) {
        this.tokenContext |= _index.TokenContext.forOfHead;
        return null;
      } else {
        this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = _index.TokenContext.normal;
      }
    }
    enterDelimited() {
      const oldTokenContext = this.tokenContext;
      const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
      if (!(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
        return () => {};
      }
      this._noLineTerminatorAfterNode = null;
      this.tokenContext = _index.TokenContext.normal;
      return () => {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        this.tokenContext = oldTokenContext;
      };
    }
    generate(ast) {
      if (this.format.preserveFormat) {
        this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
      }
      this.print(ast);
      this._maybeAddAuxComment();
      return this._buf.get();
    }
    indent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent++;
    }
    dedent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent--;
    }
    semicolon(force = false) {
      this._maybeAddAuxComment();
      if (force) {
        this._appendChar(59);
        this._noLineTerminator = false;
        return;
      }
      if (this.tokenMap) {
        const node = this._currentNode;
        if (node.start != null && node.end != null) {
          if (!this.tokenMap.endMatches(node, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          const indexes = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
        }
      }
      this._queue(59);
      this._noLineTerminator = false;
    }
    rightBrace(node) {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
    rightParens(node) {
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(41);
    }
    space(force = false) {
      const {
        format
      } = this;
      if (format.compact || format.preserveFormat)
        return;
      if (force) {
        this._space();
      } else if (this._buf.hasContent()) {
        const lastCp = this.getLastChar();
        if (lastCp !== 32 && lastCp !== 10) {
          this._space();
        }
      }
    }
    word(str, noLineTerminatorAfter = false) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap)
        this._catchUpToCurrentToken(str);
      if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
        this._space();
      }
      this._append(str, false);
      this._endsWithWord = true;
      this._noLineTerminator = noLineTerminatorAfter;
    }
    number(str, number) {
      function isNonDecimalLiteral(str2) {
        if (str2.length > 2 && str2.charCodeAt(0) === 48) {
          const secondChar = str2.charCodeAt(1);
          return secondChar === 98 || secondChar === 111 || secondChar === 120;
        }
        return false;
      }
      this.word(str);
      this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    token(str, maybeNewline = false, occurrenceCount = 0) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str, occurrenceCount);
      this._maybeAddAuxComment();
      if (this.tokenMap)
        this._catchUpToCurrentToken(str, occurrenceCount);
      const lastChar = this.getLastChar();
      const strFirst = str.charCodeAt(0);
      if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
        this._space();
      }
      this._append(str, maybeNewline);
      this._noLineTerminator = false;
    }
    tokenChar(char) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      const str = String.fromCharCode(char);
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap)
        this._catchUpToCurrentToken(str);
      const lastChar = this.getLastChar();
      if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
        this._space();
      }
      this._appendChar(char);
      this._noLineTerminator = false;
    }
    newline(i = 1, force) {
      if (i <= 0)
        return;
      if (!force) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      if (i > 2)
        i = 2;
      i -= this._buf.getNewlineCount();
      for (let j = 0;j < i; j++) {
        this._newline();
      }
      return;
    }
    endsWith(char) {
      return this.getLastChar() === char;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp("start", loc);
      this._buf.exactSource(loc, cb);
    }
    source(prop, loc) {
      if (!loc)
        return;
      this._catchUp(prop, loc);
      this._buf.source(prop, loc);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!loc || this.format.preserveFormat)
        return;
      this._catchUp(prop, loc);
      this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    sourceIdentifierName(identifierName, pos) {
      if (!this._buf._canMarkIdName)
        return;
      const sourcePosition = this._buf._sourcePosition;
      sourcePosition.identifierNamePos = pos;
      sourcePosition.identifierName = identifierName;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(str, occurrenceCount = 0) {
      const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
      if (token)
        this._catchUpTo(token.loc.start);
      if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
        this._buf.appendChar(59);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      this._printSemicolonBeforeNextToken = -1;
      this._printSemicolonBeforeNextNode = -1;
    }
    _append(str, maybeNewline) {
      this._maybeIndent(str.charCodeAt(0));
      this._buf.append(str, maybeNewline);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _appendChar(char) {
      this._maybeIndent(char);
      this._buf.appendChar(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _queue(char) {
      this._maybeIndent(char);
      this._buf.queue(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _maybeIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        this._buf.queueIndentation(this._getIndent());
      }
    }
    _shouldIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        return true;
      }
    }
    catchUp(line) {
      if (!this.format.retainLines)
        return;
      const count = line - this._buf.getCurrentLine();
      for (let i = 0;i < count; i++) {
        this._newline();
      }
    }
    _catchUp(prop, loc) {
      const {
        format
      } = this;
      if (!format.preserveFormat) {
        if (format.retainLines && loc != null && loc[prop]) {
          this.catchUp(loc[prop].line);
        }
        return;
      }
      const pos = loc == null ? undefined : loc[prop];
      if (pos != null)
        this._catchUpTo(pos);
    }
    _catchUpTo({
      line,
      column,
      index
    }) {
      const count = line - this._buf.getCurrentLine();
      if (count > 0 && this._noLineTerminator) {
        return;
      }
      for (let i = 0;i < count; i++) {
        this._newline();
      }
      const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
      if (spacesCount > 0) {
        const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
        this._append(spaces, false);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(node) {
      this._noLineTerminator = true;
      this.print(node);
    }
    print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
      var _node$extra, _node$leadingComments, _node$leadingComments2;
      if (!node)
        return;
      this._endsWithInnerRaw = false;
      const nodeType = node.type;
      const format = this.format;
      const oldConcise = format.concise;
      if (node._compact) {
        format.concise = true;
      }
      const printMethod = this[nodeType];
      if (printMethod === undefined) {
        throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
      }
      const parent = this._currentNode;
      this._currentNode = node;
      if (this.tokenMap) {
        this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
      }
      const oldInAux = this._insideAux;
      this._insideAux = node.loc == null;
      this._maybeAddAuxComment(this._insideAux && !oldInAux);
      const parenthesized = (_node$extra = node.extra) == null ? undefined : _node$extra.parenthesized;
      let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : undefined);
      if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
        const parentType = parent == null ? undefined : parent.type;
        switch (parentType) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (parent.callee !== node)
              break;
          default:
            shouldPrintParens = true;
        }
      }
      let indentParenthesized = false;
      if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
        shouldPrintParens = true;
        indentParenthesized = true;
      }
      let oldNoLineTerminatorAfterNode;
      let oldTokenContext;
      if (!shouldPrintParens) {
        noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
        if (noLineTerminatorAfter) {
          var _node$trailingComment;
          if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
            if (isExpression(node))
              shouldPrintParens = true;
          } else {
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = node;
          }
        }
      }
      if (shouldPrintParens) {
        this.tokenChar(40);
        if (indentParenthesized)
          this.indent();
        this._endsWithInnerRaw = false;
        if (this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate) {
          oldTokenContext = this.tokenContext;
          this.tokenContext = _index.TokenContext.normal;
        }
        oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        this._noLineTerminatorAfterNode = null;
      }
      this._lastCommentLine = 0;
      this._printLeadingComments(node, parent);
      const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
      this.exactSource(loc, printMethod.bind(this, node, parent));
      if (shouldPrintParens) {
        this._printTrailingComments(node, parent);
        if (indentParenthesized) {
          this.dedent();
          this.newline();
        }
        this.tokenChar(41);
        this._noLineTerminator = noLineTerminatorAfter;
        if (oldTokenContext)
          this.tokenContext = oldTokenContext;
      } else if (noLineTerminatorAfter && !this._noLineTerminator) {
        this._noLineTerminator = true;
        this._printTrailingComments(node, parent);
      } else {
        this._printTrailingComments(node, parent, trailingCommentsLineOffset);
      }
      this._currentNode = parent;
      format.concise = oldConcise;
      this._insideAux = oldInAux;
      if (oldNoLineTerminatorAfterNode !== undefined) {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
      }
      this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode)
        this._printAuxBeforeComment();
      if (!this._insideAux)
        this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = true;
      const comment = this.format.auxiliaryCommentBefore;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = false;
      const comment = this.format.auxiliaryCommentAfter;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    getPossibleRaw(node) {
      const extra = node.extra;
      if ((extra == null ? undefined : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    }
    printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
      if (!(nodes != null && nodes.length))
        return;
      if (indent == null && this.format.retainLines) {
        var _nodes$0$loc;
        const startLine = (_nodes$0$loc = nodes[0].loc) == null ? undefined : _nodes$0$loc.start.line;
        if (startLine != null && startLine !== this._buf.getCurrentLine()) {
          indent = true;
        }
      }
      if (indent)
        this.indent();
      const newlineOpts = {
        addNewlines,
        nextNodeStartLine: 0
      };
      const boundSeparator = separator == null ? undefined : separator.bind(this);
      const len = nodes.length;
      for (let i = 0;i < len; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (statement)
          this._printNewline(i === 0, newlineOpts);
        this.print(node, undefined, trailingCommentsLineOffset || 0);
        iterator == null || iterator(node, i);
        if (boundSeparator != null) {
          if (i < len - 1)
            boundSeparator(i, false);
          else if (printTrailingSeparator)
            boundSeparator(i, true);
        }
        if (statement) {
          var _node$trailingComment2;
          if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
            this._lastCommentLine = 0;
          }
          if (i + 1 === len) {
            this.newline(1);
          } else {
            var _nextNode$loc;
            const nextNode = nodes[i + 1];
            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? undefined : _nextNode$loc.start.line) || 0;
            this._printNewline(true, newlineOpts);
          }
        }
      }
      if (indent)
        this.dedent();
    }
    printAndIndentOnComments(node) {
      const indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent)
        this.indent();
      this.print(node);
      if (indent)
        this.dedent();
    }
    printBlock(parent) {
      const node = parent.body;
      if (node.type !== "EmptyStatement") {
        this.space();
      }
      this.print(node);
    }
    _printTrailingComments(node, parent, lineOffset) {
      const {
        innerComments,
        trailingComments
      } = node;
      if (innerComments != null && innerComments.length) {
        this._printComments(2, innerComments, node, parent, lineOffset);
      }
      if (trailingComments != null && trailingComments.length) {
        this._printComments(2, trailingComments, node, parent, lineOffset);
      }
    }
    _printLeadingComments(node, parent) {
      const comments = node.leadingComments;
      if (!(comments != null && comments.length))
        return;
      this._printComments(0, comments, node, parent);
    }
    _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
      if (this._endsWithInnerRaw) {
        var _this$tokenMap;
        this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? undefined : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
      }
      this._endsWithInnerRaw = true;
      this._indentInnerComments = true;
    }
    printInnerComments(nextToken) {
      const node = this._currentNode;
      const comments = node.innerComments;
      if (!(comments != null && comments.length))
        return;
      const hasSpace = this.endsWith(32);
      const indent = this._indentInnerComments;
      const printedCommentsCount = this._printedComments.size;
      if (indent)
        this.indent();
      this._printComments(1, comments, node, undefined, undefined, nextToken);
      if (hasSpace && printedCommentsCount !== this._printedComments.size) {
        this.space();
      }
      if (indent)
        this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
      this.printJoin(nodes, true, indent != null ? indent : false, undefined, undefined, addNewlines, undefined, trailingCommentsLineOffset);
    }
    printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
      this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, undefined, iterator);
    }
    shouldPrintTrailingComma(listEnd) {
      if (!this.tokenMap)
        return null;
      const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
      if (listEndIndex <= 0)
        return null;
      return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
    }
    _printNewline(newLine, opts) {
      const format = this.format;
      if (format.retainLines || format.compact)
        return;
      if (format.concise) {
        this.space();
        return;
      }
      if (!newLine) {
        return;
      }
      const startLine = opts.nextNodeStartLine;
      const lastCommentLine = this._lastCommentLine;
      if (startLine > 0 && lastCommentLine > 0) {
        const offset = startLine - lastCommentLine;
        if (offset >= 0) {
          this.newline(offset || 1);
          return;
        }
      }
      if (this._buf.hasContent()) {
        this.newline(1);
      }
    }
    _shouldPrintComment(comment, nextToken) {
      if (comment.ignore)
        return 0;
      if (this._printedComments.has(comment))
        return 0;
      if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
        return 2;
      }
      if (nextToken && this.tokenMap) {
        const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
        if (commentTok && commentTok.start > nextToken.start) {
          return 2;
        }
      }
      this._printedComments.add(comment);
      if (!this.format.shouldPrintComment(comment.value)) {
        return 0;
      }
      return 1;
    }
    _printComment(comment, skipNewLines) {
      const noLineTerminator = this._noLineTerminator;
      const isBlockComment = comment.type === "CommentBlock";
      const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
        this.newline(1);
      }
      const lastCharCode = this.getLastChar();
      if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
        this.space();
      }
      let val;
      if (isBlockComment) {
        val = `/*${comment.value}*/`;
        if (this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          const offset = (_comment$loc = comment.loc) == null ? undefined : _comment$loc.start.column;
          if (offset) {
            const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, `
`);
          }
          if (this.format.concise) {
            val = val.replace(/\n(?!$)/g, `
`);
          } else {
            let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            if (this._shouldIndent(47) || this.format.retainLines) {
              indentSize += this._getIndent();
            }
            val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
          }
        }
      } else if (!noLineTerminator) {
        val = `//${comment.value}`;
      } else {
        val = `/*${comment.value}*/`;
      }
      if (this._endsWithDiv)
        this._space();
      if (this.tokenMap) {
        const {
          _printSemicolonBeforeNextToken,
          _printSemicolonBeforeNextNode
        } = this;
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
        this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
        this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
      } else {
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
      }
      if (!isBlockComment && !noLineTerminator) {
        this.newline(1, true);
      }
      if (printNewLines && skipNewLines !== 3) {
        this.newline(1);
      }
    }
    _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
      const nodeLoc = node.loc;
      const len = comments.length;
      let hasLoc = !!nodeLoc;
      const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
      const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
      let lastLine = 0;
      let leadingCommentNewline = 0;
      const maybeNewline = this._noLineTerminator ? function() {} : this.newline.bind(this);
      for (let i = 0;i < len; i++) {
        const comment = comments[i];
        const shouldPrint = this._shouldPrintComment(comment, nextToken);
        if (shouldPrint === 2) {
          hasLoc = false;
          break;
        }
        if (hasLoc && comment.loc && shouldPrint === 1) {
          const commentStartLine = comment.loc.start.line;
          const commentEndLine = comment.loc.end.line;
          if (type === 0) {
            let offset = 0;
            if (i === 0) {
              if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                offset = leadingCommentNewline = 1;
              }
            } else {
              offset = commentStartLine - lastLine;
            }
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
              lastLine = nodeStartLine;
            }
          } else if (type === 1) {
            const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.min(1, nodeEndLine - lastLine));
              lastLine = nodeEndLine;
            }
          } else {
            const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
          }
        } else {
          hasLoc = false;
          if (shouldPrint !== 1) {
            continue;
          }
          if (len === 1) {
            const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
            const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
            if (type === 0) {
              this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                body: node
              }) ? 1 : 0);
            } else if (shouldSkipNewline && type === 2) {
              this._printComment(comment, 1);
            } else {
              this._printComment(comment, 0);
            }
          } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
          } else {
            this._printComment(comment, 0);
          }
        }
      }
      if (type === 2 && hasLoc && lastLine) {
        this._lastCommentLine = lastLine;
      }
    }
  }
  Object.assign(Printer.prototype, generatorFunctions);
  {
    (0, _deprecated.addDeprecatedGenerators)(Printer);
  }
  var _default = exports.default = Printer;
  function commaSeparator(occurrenceCount, last) {
    this.token(",", false, occurrenceCount);
    if (!last)
      this.space();
  }
});

// ../../../../node_modules/@babel/generator/lib/index.js
var require_lib6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.generate = generate;
  var _sourceMap = require_source_map();
  var _printer = require_printer();
  function normalizeOptions(code, opts, ast) {
    if (opts.experimental_preserveFormat) {
      if (typeof code !== "string") {
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      }
      if (!opts.retainLines) {
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      }
      if (opts.compact && opts.compact !== "auto") {
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      }
      if (opts.minified) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      }
      if (opts.jsescOption) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      }
      if (!Array.isArray(ast.tokens)) {
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
      }
    }
    const format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      preserveFormat: opts.experimental_preserveFormat,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      topicToken: opts.topicToken,
      importAttributesKeyword: opts.importAttributesKeyword
    };
    {
      var _opts$recordAndTupleS;
      format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format.jsescOption.json = opts.jsonCompatibleStrings;
      format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
    }
    if (format.minified) {
      format.compact = true;
      format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
      format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
    }
    if (format.compact === "auto") {
      format.compact = typeof code === "string" && code.length > 500000;
      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
      }
    }
    if (format.compact || format.preserveFormat) {
      format.indent.adjustMultilineComment = false;
    }
    const {
      auxiliaryCommentBefore,
      auxiliaryCommentAfter,
      shouldPrintComment
    } = format;
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
      format.auxiliaryCommentBefore = undefined;
    }
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
      format.auxiliaryCommentAfter = undefined;
    }
    return format;
  }
  {
    exports.CodeGenerator = class CodeGenerator {
      constructor(ast, opts = {}, code) {
        this._ast = undefined;
        this._format = undefined;
        this._map = undefined;
        this._ast = ast;
        this._format = normalizeOptions(code, opts, ast);
        this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      }
      generate() {
        const printer = new _printer.default(this._format, this._map);
        return printer.generate(this._ast);
      }
    };
  }
  function generate(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts, ast);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    const printer = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
    return printer.generate(ast);
  }
  var _default = exports.default = generate;
});

// ../../../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = undefined;
  var ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
  var ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"];
  var BindingIdentifier = exports.BindingIdentifier = ["Identifier"];
  var Statement = exports.Statement = ["Statement"];
  var Expression = exports.Expression = ["Expression"];
  var Scope = exports.Scope = ["Scopable", "Pattern"];
  var Referenced = exports.Referenced = null;
  var BlockScoped = exports.BlockScoped = null;
  var Var = exports.Var = ["VariableDeclaration"];
  var User2 = exports.User = null;
  var Generated = exports.Generated = null;
  var Pure = exports.Pure = null;
  var Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  var RestProperty = exports.RestProperty = ["RestElement"];
  var SpreadProperty = exports.SpreadProperty = ["RestElement"];
  var ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"];
  var NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  var ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];
});

// ../../../../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isBindingIdentifier = isBindingIdentifier;
  exports.isBlockScoped = isBlockScoped;
  exports.isExpression = isExpression;
  exports.isFlow = isFlow;
  exports.isForAwaitStatement = isForAwaitStatement;
  exports.isGenerated = isGenerated;
  exports.isPure = isPure;
  exports.isReferenced = isReferenced;
  exports.isReferencedIdentifier = isReferencedIdentifier;
  exports.isReferencedMemberExpression = isReferencedMemberExpression;
  exports.isRestProperty = isRestProperty;
  exports.isScope = isScope;
  exports.isSpreadProperty = isSpreadProperty;
  exports.isStatement = isStatement;
  exports.isUser = isUser;
  exports.isVar = isVar;
  var _t = require_lib5();
  var {
    isBinding,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement,
    isForXStatement,
    isIdentifier,
    isImportDeclaration,
    isImportSpecifier,
    isJSXIdentifier,
    isJSXMemberExpression,
    isMemberExpression,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration,
    react,
    isForOfStatement
  } = _t;
  var {
    isCompatTag
  } = react;
  function isReferencedIdentifier(opts) {
    const {
      node,
      parent
    } = this;
    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
      if (isJSXIdentifier(node, opts)) {
        if (isCompatTag(node.name))
          return false;
      } else {
        return false;
      }
    }
    return nodeIsReferenced(node, parent, this.parentPath.parent);
  }
  function isReferencedMemberExpression() {
    const {
      node,
      parent
    } = this;
    return isMemberExpression(node) && nodeIsReferenced(node, parent);
  }
  function isBindingIdentifier() {
    const {
      node,
      parent
    } = this;
    const grandparent = this.parentPath.parent;
    return isIdentifier(node) && isBinding(node, parent, grandparent);
  }
  function isStatement() {
    const {
      node,
      parent
    } = this;
    if (nodeIsStatement(node)) {
      if (isVariableDeclaration(node)) {
        if (isForXStatement(parent, {
          left: node
        }))
          return false;
        if (isForStatement(parent, {
          init: node
        }))
          return false;
      }
      return true;
    } else {
      return false;
    }
  }
  function isExpression() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  }
  function isScope() {
    return nodeIsScope(this.node, this.parent);
  }
  function isReferenced() {
    return nodeIsReferenced(this.node, this.parent);
  }
  function isBlockScoped() {
    return nodeIsBlockScoped(this.node);
  }
  function isVar() {
    return nodeIsVar(this.node);
  }
  function isUser() {
    return this.node && !!this.node.loc;
  }
  function isGenerated() {
    return !this.isUser();
  }
  function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  }
  function isFlow() {
    const {
      node
    } = this;
    if (nodeIsFlow(node)) {
      return true;
    } else if (isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
  function isRestProperty() {
    var _this$parentPath;
    return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? undefined : _this$parentPath.isObjectPattern());
  }
  function isSpreadProperty() {
    var _this$parentPath2;
    return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? undefined : _this$parentPath2.isObjectExpression());
  }
  function isForAwaitStatement() {
    return isForOfStatement(this.node, {
      await: true
    });
  }
  {
    exports.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
});

// ../../../../node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.environmentVisitor = environmentVisitor;
  exports.explode = explode$1;
  exports.isExplodedVisitor = isExplodedVisitor;
  exports.merge = merge;
  exports.verify = verify$1;
  var virtualTypes = require_virtual_types();
  var virtualTypesValidators = require_virtual_types_validator();
  var _t = require_lib5();
  var _context = require_context2();
  var {
    DEPRECATED_KEYS,
    DEPRECATED_ALIASES,
    FLIPPED_ALIAS_KEYS,
    TYPES,
    __internal__deprecationWarning: deprecationWarning
  } = _t;
  function isVirtualType(type) {
    return type in virtualTypes;
  }
  function isExplodedVisitor(visitor) {
    return visitor == null ? undefined : visitor._exploded;
  }
  function explode$1(visitor) {
    if (isExplodedVisitor(visitor))
      return visitor;
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      const parts = nodeType.split("|");
      if (parts.length === 1)
        continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const part of parts) {
        visitor[part] = fns;
      }
    }
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      if (!isVirtualType(nodeType))
        continue;
      const fns = visitor[nodeType];
      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(nodeType, fns[type]);
      }
      delete visitor[nodeType];
      const types = virtualTypes[nodeType];
      if (types !== null) {
        for (const type of types) {
          if (visitor[type]) {
            mergePair(visitor[type], fns);
          } else {
            visitor[type] = fns;
          }
        }
      } else {
        mergePair(visitor, fns);
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      let aliases = FLIPPED_ALIAS_KEYS[nodeType];
      if (nodeType in DEPRECATED_KEYS) {
        const deprecatedKey = DEPRECATED_KEYS[nodeType];
        deprecationWarning(nodeType, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (nodeType in DEPRECATED_ALIASES) {
        const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
        deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
      }
      if (!aliases)
        continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const alias of aliases) {
        const existing = visitor[alias];
        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType))
        continue;
      ensureCallbackArrays(visitor[nodeType]);
    }
    return visitor;
  }
  function verify$1(visitor) {
    if (visitor._verified)
      return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }
    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType))
        continue;
      if (!TYPES.includes(nodeType)) {
        throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.28.0"}`);
      }
      const visitors = visitor[nodeType];
      if (typeof visitors === "object") {
        for (const visitorKey of Object.keys(visitors)) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + `${nodeType} that has the invalid property ${visitorKey}`);
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path, val) {
    const fns = [].concat(val);
    for (const fn of fns) {
      if (typeof fn !== "function") {
        throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
      }
    }
  }
  function merge(visitors, states = [], wrapper) {
    const mergedVisitor = {
      _verified: true,
      _exploded: true
    };
    {
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: false
      });
      Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: false
      });
    }
    for (let i = 0;i < visitors.length; i++) {
      const visitor = explode$1(visitors[i]);
      const state = states[i];
      let topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (const key of Object.keys(visitor)) {
        if (shouldIgnoreKey(key))
          continue;
        let typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    for (const phase of ["enter", "exit"]) {
      let fns = oldVisitor[phase];
      if (!Array.isArray(fns))
        continue;
      fns = fns.map(function(fn) {
        let newFn = fn;
        if (state) {
          newFn = function(path) {
            fn.call(state, path, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? undefined : state.key, phase, newFn);
        }
        if (newFn !== fn) {
          newFn.toString = () => fn.toString();
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key))
        continue;
      const fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter))
      obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit))
      obj.exit = [obj.exit];
  }
  function wrapCheck(nodeType, fn) {
    const fnKey = `is${nodeType}`;
    const validator = virtualTypesValidators[fnKey];
    const newFn = function(path) {
      if (validator.call(path)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = () => fn.toString();
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_")
      return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip")
      return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  }
  function mergePair(dest, src) {
    for (const phase of ["enter", "exit"]) {
      if (!src[phase])
        continue;
      dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
  }
  var _environmentVisitor = {
    FunctionParent(path) {
      if (path.isArrowFunctionExpression())
        return;
      path.skip();
      if (path.isMethod()) {
        if (!path.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    },
    Property(path) {
      if (path.isObjectProperty())
        return;
      path.skip();
      if (!path.requeueComputedKeyAndDecorators) {
        _context.requeueComputedKeyAndDecorators.call(path);
      } else {
        path.requeueComputedKeyAndDecorators();
      }
    }
  };
  function environmentVisitor(visitor) {
    return merge([_environmentVisitor, visitor]);
  }
});

// ../../../../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var t = require_lib5();
  var _t = t;
  var _traverseNode = require_traverse_node();
  var _visitors = require_visitors();
  var _context = require_context2();
  var {
    getAssignmentIdentifiers
  } = _t;
  var renameVisitor = {
    ReferencedIdentifier({
      node
    }, state) {
      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      }
    },
    ObjectProperty({
      node,
      scope
    }, state) {
      const {
        name
      } = node.key;
      if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
        node.shorthand = false;
        {
          var _node$extra;
          if ((_node$extra = node.extra) != null && _node$extra.shorthand)
            node.extra.shorthand = false;
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
      if (path.isVariableDeclaration())
        return;
      const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
      for (const name in ids) {
        if (name === state.oldName)
          ids[name].name = state.newName;
      }
    }
  };

  class Renamer {
    constructor(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }
    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;
      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }
      if (maybeExportDeclar.isExportDefaultDeclaration()) {
        const {
          declaration
        } = maybeExportDeclar.node;
        if (t.isDeclaration(declaration) && !declaration.id) {
          return;
        }
      }
      if (maybeExportDeclar.isExportAllDeclaration()) {
        return;
      }
      maybeExportDeclar.splitExportDeclaration();
    }
    maybeConvertFromClassFunctionDeclaration(path) {
      return path;
    }
    maybeConvertFromClassFunctionExpression(path) {
      return path;
    }
    rename() {
      const {
        binding,
        oldName,
        newName
      } = this;
      const {
        scope,
        path
      } = binding;
      const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
      if (parentDeclar) {
        const bindingIds = parentDeclar.getOuterBindingIdentifiers();
        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }
      const blockToTraverse = arguments[0] || scope.block;
      const skipKeys = {
        discriminant: true
      };
      if (t.isMethod(blockToTraverse)) {
        if (blockToTraverse.computed) {
          skipKeys.key = true;
        }
        if (!t.isObjectMethod(blockToTraverse)) {
          skipKeys.decorators = true;
        }
      }
      (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
      if (!arguments[0]) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }
      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(path);
        this.maybeConvertFromClassFunctionExpression(path);
      }
    }
  }
  exports.default = Renamer;
});

// ../../../../node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Binding {
    constructor({
      identifier,
      scope,
      path,
      kind
    }) {
      this.identifier = undefined;
      this.scope = undefined;
      this.path = undefined;
      this.kind = undefined;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isInitInLoop(path)) {
        this.reassign(path);
      }
      this.clearValue();
    }
    deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }
    setValue(value) {
      if (this.hasDeoptedValue)
        return;
      this.hasValue = true;
      this.value = value;
    }
    clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }
    reassign(path) {
      this.constant = false;
      if (this.constantViolations.includes(path)) {
        return;
      }
      this.constantViolations.push(path);
    }
    reference(path) {
      if (this.referencePaths.includes(path)) {
        return;
      }
      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    }
    dereference() {
      this.references--;
      this.referenced = !!this.references;
    }
  }
  exports.default = Binding;
  function isInitInLoop(path) {
    const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
    for (let {
      parentPath,
      key
    } = path;parentPath; {
      parentPath,
      key
    } = parentPath) {
      if (parentPath.isFunctionParent())
        return false;
      if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop()) {
        return true;
      }
    }
    return false;
  }
});

// ../../../../node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.clear = clear;
  exports.clearPath = clearPath;
  exports.clearScope = clearScope;
  exports.getCachedPaths = getCachedPaths;
  exports.getOrCreateCachedPaths = getOrCreateCachedPaths;
  exports.scope = exports.path = undefined;
  var pathsCache = exports.path = new WeakMap;
  var scope = exports.scope = new WeakMap;
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    exports.path = pathsCache = new WeakMap;
  }
  function clearScope() {
    exports.scope = scope = new WeakMap;
  }
  function getCachedPaths(path) {
    const {
      parent,
      parentPath
    } = path;
    return pathsCache.get(parent);
  }
  function getOrCreateCachedPaths(node, parentPath) {
    let paths = pathsCache.get(node);
    if (!paths)
      pathsCache.set(node, paths = new Map);
    return paths;
  }
});

// ../../../../node_modules/@babel/helper-globals/data/builtin-lower.json
var require_builtin_lower = __commonJS((exports, module) => {
  module.exports = [
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "eval",
    "globalThis",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "undefined",
    "unescape"
  ];
});

// ../../../../node_modules/@babel/helper-globals/data/builtin-upper.json
var require_builtin_upper = __commonJS((exports, module) => {
  module.exports = [
    "AggregateError",
    "Array",
    "ArrayBuffer",
    "Atomics",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "Error",
    "EvalError",
    "FinalizationRegistry",
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Intl",
    "Iterator",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "Promise",
    "Proxy",
    "RangeError",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "Set",
    "SharedArrayBuffer",
    "String",
    "Symbol",
    "SyntaxError",
    "TypeError",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "URIError",
    "WeakMap",
    "WeakRef",
    "WeakSet"
  ];
});

// ../../../../node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _renamer = require_renamer();
  var _index = require_lib9();
  var _binding = require_binding();
  var _t = require_lib5();
  var t = _t;
  var _cache = require_cache();
  var globalsBuiltinLower = require_builtin_lower();
  var globalsBuiltinUpper = require_builtin_upper();
  var {
    assignmentExpression,
    callExpression,
    cloneNode,
    getBindingIdentifiers,
    identifier,
    isArrayExpression,
    isBinary,
    isCallExpression,
    isClass,
    isClassBody,
    isClassDeclaration,
    isExportAllDeclaration,
    isExportDefaultDeclaration,
    isExportNamedDeclaration,
    isFunctionDeclaration,
    isIdentifier,
    isImportDeclaration,
    isLiteral,
    isMemberExpression,
    isMethod,
    isModuleSpecifier,
    isNullLiteral,
    isObjectExpression,
    isProperty,
    isPureish,
    isRegExpLiteral,
    isSuper,
    isTaggedTemplateExpression,
    isTemplateLiteral,
    isThisExpression,
    isUnaryExpression,
    isVariableDeclaration,
    expressionStatement,
    matchesPattern,
    memberExpression,
    numericLiteral,
    toIdentifier,
    variableDeclaration,
    variableDeclarator,
    isRecordExpression,
    isTupleExpression,
    isObjectProperty,
    isTopicReference,
    isMetaProperty,
    isPrivateName,
    isExportDeclaration,
    buildUndefinedNode,
    sequenceExpression
  } = _t;
  function gatherNodeParts(node, parts) {
    switch (node == null ? undefined : node.type) {
      default:
        if (isImportDeclaration(node) || isExportDeclaration(node)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
            gatherNodeParts(node.source, parts);
          } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const e of node.specifiers)
              gatherNodeParts(e, parts);
          } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
          parts.push(node.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const e of node.properties) {
          gatherNodeParts(e, parts);
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
      case "ImportExpression":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }
  function resetScope(scope) {
    {
      scope.references = Object.create(null);
      scope.uids = Object.create(null);
    }
    scope.bindings = Object.create(null);
    scope.globals = Object.create(null);
  }
  {
    NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
  var NOT_LOCAL_BINDING;
  var collectorVisitor = {
    ForStatement(path) {
      const declar = path.get("init");
      if (declar.isVar()) {
        const {
          scope
        } = path;
        const parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration(path) {
      if (path.isBlockScoped())
        return;
      if (path.isImportDeclaration())
        return;
      if (path.isExportDeclaration())
        return;
      const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ImportDeclaration(path) {
      const parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    TSImportEqualsDeclaration(path) {
      const parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier(path, state) {
      if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {
        return;
      }
      if (path.parentPath.isTSImportEqualsDeclaration())
        return;
      state.references.push(path);
    },
    ForXStatement(path, state) {
      const left = path.get("left");
      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      } else if (left.isVar()) {
        const {
          scope
        } = path;
        const parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", left);
      }
    },
    ExportDeclaration: {
      exit(path) {
        const {
          node,
          scope
        } = path;
        if (isExportAllDeclaration(node))
          return;
        const declar = node.declaration;
        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id)
            return;
          const binding = scope.getBinding(id.name);
          binding == null || binding.reference(path);
        } else if (isVariableDeclaration(declar)) {
          for (const decl of declar.declarations) {
            for (const name of Object.keys(getBindingIdentifiers(decl))) {
              const binding = scope.getBinding(name);
              binding == null || binding.reference(path);
            }
          }
        }
      }
    },
    LabeledStatement(path) {
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped(path) {
      let scope = path.scope;
      if (scope.path === path)
        scope = scope.parent;
      const parent = scope.getBlockParent();
      parent.registerDeclaration(path);
      if (path.isClassDeclaration() && path.node.id) {
        const id = path.node.id;
        const name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function(path) {
      const params = path.get("params");
      for (const param of params) {
        path.scope.registerBinding("param", param);
      }
      if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    ClassExpression(path) {
      if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    TSTypeAnnotation(path) {
      path.skip();
    }
  };
  var scopeVisitor;
  var uid = 0;

  class Scope {
    constructor(path) {
      this.uid = undefined;
      this.path = undefined;
      this.block = undefined;
      this.inited = undefined;
      this.labels = undefined;
      this.bindings = undefined;
      this.referencesSet = undefined;
      this.globals = undefined;
      this.uidsSet = undefined;
      this.data = undefined;
      this.crawling = undefined;
      const {
        node
      } = path;
      const cached = _cache.scope.get(node);
      if ((cached == null ? undefined : cached.path) === path) {
        return cached;
      }
      _cache.scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map;
      this.inited = false;
      {
        Object.defineProperties(this, {
          references: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.create(null)
          },
          uids: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.create(null)
          }
        });
      }
    }
    get parent() {
      var _parent;
      let parent, path = this.path;
      do {
        var _path;
        const shouldSkip = path.key === "key" || path.listKey === "decorators";
        path = path.parentPath;
        if (shouldSkip && path.isMethod())
          path = path.parentPath;
        if ((_path = path) != null && _path.isScope())
          parent = path;
      } while (path && !parent);
      return (_parent = parent) == null ? undefined : _parent.scope;
    }
    get references() {
      throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
    }
    get uids() {
      throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
    }
    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      this.push({
        id
      });
      return cloneNode(id);
    }
    generateUidIdentifier(name) {
      return identifier(this.generateUid(name));
    }
    generateUid(name = "temp") {
      name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
      let uid2;
      let i = 0;
      do {
        uid2 = `_${name}`;
        if (i >= 11)
          uid2 += i - 1;
        else if (i >= 9)
          uid2 += i - 9;
        else if (i >= 1)
          uid2 += i + 1;
        i++;
      } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
      const program = this.getProgramParent();
      {
        program.references[uid2] = true;
        program.uids[uid2] = true;
      }
      return uid2;
    }
    generateUidBasedOnNode(node, defaultName) {
      const parts = [];
      gatherNodeParts(node, parts);
      let id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(node, defaultName) {
      return identifier(this.generateUidBasedOnNode(node, defaultName));
    }
    isStatic(node) {
      if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
        return true;
      }
      if (isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }
      return false;
    }
    maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        const id = this.generateUidIdentifierBasedOnNode(node);
        if (!dontPush) {
          this.push({
            id
          });
          return cloneNode(id);
        }
        return id;
      }
    }
    checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param")
        return;
      if (local.kind === "local")
        return;
      const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
      if (duplicate) {
        throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
    }
    rename(oldName, newName) {
      const binding = this.getBinding(oldName);
      if (binding) {
        newName || (newName = this.generateUidIdentifier(oldName).name);
        const renamer = new _renamer.default(binding, oldName, newName);
        {
          renamer.rename(arguments[2]);
        }
      }
    }
    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope = this;
      do {
        console.log("#", scope.block.type);
        for (const name of Object.keys(scope.bindings)) {
          const binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);
      console.log(sep);
    }
    hasLabel(name) {
      return !!this.getLabel(name);
    }
    getLabel(name) {
      return this.labels.get(name);
    }
    registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    }
    registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        const declarations = path.get("declarations");
        const {
          kind
        } = path.node;
        for (const declar of declarations) {
          this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        if (path.node.declare)
          return;
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
        const specifiers = path.get("specifiers");
        for (const specifier of specifiers) {
          const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
          this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        const declar = path.get("declaration");
        if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
          this.registerDeclaration(declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    }
    buildUndefinedNode() {
      return buildUndefinedNode();
    }
    registerConstantViolation(path) {
      const ids = path.getAssignmentIdentifiers();
      for (const name of Object.keys(ids)) {
        var _this$getBinding;
        (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
      }
    }
    registerBinding(kind, path, bindingPath = path) {
      if (!kind)
        throw new ReferenceError("no `kind`");
      if (path.isVariableDeclaration()) {
        const declarators = path.get("declarations");
        for (const declar of declarators) {
          this.registerBinding(kind, declar);
        }
        return;
      }
      const parent = this.getProgramParent();
      const ids = path.getOuterBindingIdentifiers(true);
      for (const name of Object.keys(ids)) {
        {
          parent.references[name] = true;
        }
        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id)
              continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          if (local) {
            local.reassign(bindingPath);
          } else {
            this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }
    }
    addGlobal(node) {
      this.globals[node.name] = node;
    }
    hasUid(name) {
      {
        let scope = this;
        do {
          if (scope.uids[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }
    }
    hasGlobal(name) {
      let scope = this;
      do {
        if (scope.globals[name])
          return true;
      } while (scope = scope.parent);
      return false;
    }
    hasReference(name) {
      {
        return !!this.getProgramParent().references[name];
      }
    }
    isPure(node, constantsOnly) {
      if (isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        if (!binding)
          return false;
        if (constantsOnly)
          return binding.constant;
        return true;
      } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
        return true;
      } else if (isClass(node)) {
        var _node$decorators;
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }
        if (((_node$decorators = node.decorators) == null ? undefined : _node$decorators.length) > 0) {
          return false;
        }
        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody(node)) {
        for (const method of node.body) {
          if (!this.isPure(method, constantsOnly))
            return false;
        }
        return true;
      } else if (isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression(node) || isTupleExpression(node)) {
        for (const elem of node.elements) {
          if (elem !== null && !this.isPure(elem, constantsOnly))
            return false;
        }
        return true;
      } else if (isObjectExpression(node) || isRecordExpression(node)) {
        for (const prop of node.properties) {
          if (!this.isPure(prop, constantsOnly))
            return false;
        }
        return true;
      } else if (isMethod(node)) {
        var _node$decorators2;
        if (node.computed && !this.isPure(node.key, constantsOnly))
          return false;
        if (((_node$decorators2 = node.decorators) == null ? undefined : _node$decorators2.length) > 0) {
          return false;
        }
        return true;
      } else if (isProperty(node)) {
        var _node$decorators3;
        if (node.computed && !this.isPure(node.key, constantsOnly))
          return false;
        if (((_node$decorators3 = node.decorators) == null ? undefined : _node$decorators3.length) > 0) {
          return false;
        }
        if (isObjectProperty(node) || node.static) {
          if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
            return false;
          }
        }
        return true;
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        for (const expression of node.expressions) {
          if (!this.isPure(expression, constantsOnly))
            return false;
        }
        return true;
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
          noGlobals: true
        }) && this.isPure(node.quasi, constantsOnly);
      } else if (isMemberExpression(node)) {
        return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
          noGlobals: true
        });
      } else if (isCallExpression(node)) {
        return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
          noGlobals: true
        }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);
      } else {
        return isPureish(node);
      }
    }
    setData(key, val) {
      return this.data[key] = val;
    }
    getData(key) {
      let scope = this;
      do {
        const data = scope.data[key];
        if (data != null)
          return data;
      } while (scope = scope.parent);
    }
    removeData(key) {
      let scope = this;
      do {
        const data = scope.data[key];
        if (data != null)
          scope.data[key] = null;
      } while (scope = scope.parent);
    }
    init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }
    crawl() {
      const path = this.path;
      resetScope(this);
      this.data = Object.create(null);
      let scope = this;
      do {
        if (scope.crawling)
          return;
        if (scope.path.isProgram()) {
          break;
        }
      } while (scope = scope.parent);
      const programParent = scope;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
        Scope(path2) {
          resetScope(path2.scope);
        }
      }, collectorVisitor]));
      if (path.type !== "Program") {
        for (const visit of scopeVisitor.enter) {
          visit.call(state, path, state);
        }
        const typeVisitors = scopeVisitor[path.type];
        if (typeVisitors) {
          for (const visit of typeVisitors.enter) {
            visit.call(state, path, state);
          }
        }
      }
      path.traverse(scopeVisitor, state);
      this.crawling = false;
      for (const path2 of state.assignments) {
        const ids = path2.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          if (path2.scope.getBinding(name))
            continue;
          programParent.addGlobal(ids[name]);
        }
        path2.scope.registerConstantViolation(path2);
      }
      for (const ref of state.references) {
        const binding = ref.scope.getBinding(ref.node.name);
        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }
      for (const path2 of state.constantViolations) {
        path2.scope.registerConstantViolation(path2);
      }
    }
    push(opts) {
      let path = this.path;
      if (path.isPattern()) {
        path = this.getPatternParent().path;
      } else if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }
      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }
      const {
        init,
        unique,
        kind = "var",
        id
      } = opts;
      if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
        callee: path.node
      }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
        path.pushContainer("params", id);
        path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
        return;
      }
      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }
      const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      const dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path.getData(dataKey);
      if (!declarPath) {
        const declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;
        [declarPath] = path.unshiftContainer("body", [declar]);
        if (!unique)
          path.setData(dataKey, declarPath);
      }
      const declarator = variableDeclarator(id, init);
      const len = declarPath.node.declarations.push(declarator);
      path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    }
    getProgramParent() {
      let scope = this;
      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let scope = this;
      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      return null;
    }
    getBlockParent() {
      let scope = this;
      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let scope = this;
      do {
        if (!scope.path.isPattern()) {
          return scope.getBlockParent();
        }
      } while (scope = scope.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const ids = Object.create(null);
      let scope = this;
      do {
        for (const key of Object.keys(scope.bindings)) {
          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }
        scope = scope.parent;
      } while (scope);
      return ids;
    }
    bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    }
    getBinding(name) {
      let scope = this;
      let previousPath;
      do {
        const binding = scope.getOwnBinding(name);
        if (binding) {
          var _previousPath;
          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {} else {
            return binding;
          }
        } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }
        previousPath = scope.path;
      } while (scope = scope.parent);
    }
    getOwnBinding(name) {
      return this.bindings[name];
    }
    getBindingIdentifier(name) {
      var _this$getBinding2;
      return (_this$getBinding2 = this.getBinding(name)) == null ? undefined : _this$getBinding2.identifier;
    }
    getOwnBindingIdentifier(name) {
      const binding = this.bindings[name];
      return binding == null ? undefined : binding.identifier;
    }
    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
    hasBinding(name, opts) {
      if (!name)
        return false;
      let noGlobals;
      let noUids;
      let upToScope;
      if (typeof opts === "object") {
        noGlobals = opts.noGlobals;
        noUids = opts.noUids;
        upToScope = opts.upToScope;
      } else if (typeof opts === "boolean") {
        noGlobals = opts;
      }
      let scope = this;
      do {
        if (upToScope === scope) {
          break;
        }
        if (scope.hasOwnBinding(name)) {
          return true;
        }
      } while (scope = scope.parent);
      if (!noUids && this.hasUid(name))
        return true;
      if (!noGlobals && Scope.globals.includes(name))
        return true;
      if (!noGlobals && Scope.contextVariables.includes(name))
        return true;
      return false;
    }
    parentHasBinding(name, opts) {
      var _this$parent;
      return (_this$parent = this.parent) == null ? undefined : _this$parent.hasBinding(name, opts);
    }
    moveBindingTo(name, scope) {
      const info = this.getBinding(name);
      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    }
    removeOwnBinding(name) {
      delete this.bindings[name];
    }
    removeBinding(name) {
      var _this$getBinding3;
      (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
      {
        let scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
    }
    hoistVariables(emit = (id) => this.push({
      id
    })) {
      this.crawl();
      const seen = new Set;
      for (const name of Object.keys(this.bindings)) {
        const binding = this.bindings[name];
        if (!binding)
          continue;
        const {
          path
        } = binding;
        if (!path.isVariableDeclarator())
          continue;
        const {
          parent,
          parentPath
        } = path;
        if (parent.kind !== "var" || seen.has(parent))
          continue;
        seen.add(path.parent);
        let firstId;
        const init = [];
        for (const decl of parent.declarations) {
          firstId != null || (firstId = decl.id);
          if (decl.init) {
            init.push(assignmentExpression("=", decl.id, decl.init));
          }
          const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
          for (const name2 of ids) {
            emit(identifier(name2), decl.init != null);
          }
        }
        if (parentPath.parentPath.isFor({
          left: parent
        })) {
          parentPath.replaceWith(firstId);
        } else if (init.length === 0) {
          parentPath.remove();
        } else {
          const expr = init.length === 1 ? init[0] : sequenceExpression(init);
          if (parentPath.parentPath.isForStatement({
            init: parent
          })) {
            parentPath.replaceWith(expr);
          } else {
            parentPath.replaceWith(expressionStatement(expr));
          }
        }
      }
    }
  }
  exports.default = Scope;
  Scope.globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  {
    Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };
    Scope.prototype.traverse = function(node, opts, state) {
      (0, _index.default)(node, opts, this, state, this.path);
    };
    Scope.prototype._generateUid = function _generateUid(name, i) {
      let id = name;
      if (i > 1)
        id += i;
      return `_${id}`;
    };
    Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
      if (isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }
      if (isArrayExpression(node)) {
        return node;
      }
      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      }
      let helperName;
      const args = [node];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression(this.path.hub.addHelper(helperName), args);
    };
    Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
      const ids = Object.create(null);
      for (const kind of kinds) {
        let scope = this;
        do {
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            if (binding.kind === kind)
              ids[name] = binding;
          }
          scope = scope.parent;
        } while (scope);
      }
      return ids;
    };
    Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.hub;
        }
      }
    });
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.find = find;
  exports.findParent = findParent;
  exports.getAncestry = getAncestry;
  exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  exports.getFunctionParent = getFunctionParent;
  exports.getStatementParent = getStatementParent;
  exports.inType = inType;
  exports.isAncestor = isAncestor;
  exports.isDescendant = isDescendant;
  var _t = require_lib5();
  var {
    VISITOR_KEYS
  } = _t;
  function findParent(callback) {
    let path = this;
    while (path = path.parentPath) {
      if (callback(path))
        return path;
    }
    return null;
  }
  function find(callback) {
    let path = this;
    do {
      if (callback(path))
        return path;
    } while (path = path.parentPath);
    return null;
  }
  function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
  }
  function getStatementParent() {
    let path = this;
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);
    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
      let earliest;
      const keys = VISITOR_KEYS[deepest.type];
      for (const ancestry of ancestries) {
        const path = ancestry[i + 1];
        if (!earliest) {
          earliest = path;
          continue;
        }
        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }
        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path.parentKey);
        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }
      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map((path) => {
      const ancestry = [];
      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== this);
      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }
      return ancestry;
    });
    const first = ancestries[0];
    depthLoop:
      for (let i = 0;i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    let path = this;
    const paths = [];
    do {
      paths.push(path);
    } while (path = path.parentPath);
    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
  }
  function inType(...candidateTypes) {
    let path = this;
    while (path) {
      if (candidateTypes.includes(path.node.type))
        return true;
      path = path.parentPath;
    }
    return false;
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createUnionType = createUnionType;
  var _t = require_lib5();
  var {
    createFlowUnionType,
    createTSUnionType,
    createUnionTypeAnnotation,
    isFlowType,
    isTSType
  } = _t;
  function createUnionType(types) {
    {
      if (types.every((v) => isFlowType(v))) {
        if (createFlowUnionType) {
          return createFlowUnionType(types);
        }
        return createUnionTypeAnnotation(types);
      } else if (types.every((v) => isTSType(v))) {
        if (createTSUnionType) {
          return createTSUnionType(types);
        }
      }
    }
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _t = require_lib5();
  var _util = require_util();
  var {
    BOOLEAN_NUMBER_BINARY_OPERATORS,
    createTypeAnnotationBasedOnTypeof,
    numberTypeAnnotation,
    voidTypeAnnotation
  } = _t;
  function _default(node) {
    if (!this.isReferenced())
      return;
    const binding = this.scope.getBinding(node.name);
    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }
    if (node.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node.name === "arguments") {}
  }
  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    const types = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    const testType = getConditionalAnnotation(binding, path, name);
    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
      types.push(testType.typeAnnotation);
    }
    if (constantViolations.length) {
      constantViolations.push(...functionConstantViolations);
      for (const violation of constantViolations) {
        types.push(violation.getTypeAnnotation());
      }
    }
    if (!types.length) {
      return;
    }
    return (0, _util.createUnionType)(types);
  }
  function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter((violation) => {
      violation = violation.resolve();
      const status = violation._guessExecutionStatusRelativeTo(path);
      if (functions && status === "unknown")
        functions.push(violation);
      return status === "before";
    });
  }
  function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator;
    const right = path.get("right").resolve();
    const left = path.get("left").resolve();
    let target;
    if (left.isIdentifier({
      name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name
    })) {
      target = left;
    }
    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }
      if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      }
      return;
    }
    if (operator !== "===" && operator !== "==")
      return;
    let typeofPath;
    let typePath;
    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }
    if (!typeofPath)
      return;
    if (!typeofPath.get("argument").isIdentifier({
      name
    }))
      return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral())
      return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== "string")
      return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  }
  function getParentConditionalPath(binding, path, name) {
    let parentPath;
    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }
        return parentPath;
      }
      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding)
          return;
      }
      path = parentPath;
    }
  }
  function getConditionalAnnotation(binding, path, name) {
    const ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement)
      return;
    const test = ifStatement.get("test");
    const paths = [test];
    const types = [];
    for (let i = 0;i < paths.length; i++) {
      const path2 = paths[i];
      if (path2.isLogicalExpression()) {
        if (path2.node.operator === "&&") {
          paths.push(path2.get("left"));
          paths.push(path2.get("right"));
        }
      } else if (path2.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path2);
        if (type)
          types.push(type);
      }
    }
    if (types.length) {
      return {
        typeAnnotation: (0, _util.createUnionType)(types),
        ifStatement
      };
    }
    return getConditionalAnnotation(binding, ifStatement, name);
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrayExpression = ArrayExpression;
  exports.AssignmentExpression = AssignmentExpression;
  exports.BinaryExpression = BinaryExpression;
  exports.BooleanLiteral = BooleanLiteral;
  exports.CallExpression = CallExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
      return _infererReference.default;
    }
  });
  exports.LogicalExpression = LogicalExpression;
  exports.NewExpression = NewExpression;
  exports.NullLiteral = NullLiteral;
  exports.NumericLiteral = NumericLiteral;
  exports.ObjectExpression = ObjectExpression;
  exports.ParenthesizedExpression = ParenthesizedExpression;
  exports.RegExpLiteral = RegExpLiteral;
  exports.RestElement = RestElement;
  exports.SequenceExpression = SequenceExpression;
  exports.StringLiteral = StringLiteral;
  exports.TSAsExpression = TSAsExpression;
  exports.TSNonNullExpression = TSNonNullExpression;
  exports.TaggedTemplateExpression = TaggedTemplateExpression;
  exports.TemplateLiteral = TemplateLiteral;
  exports.TypeCastExpression = TypeCastExpression;
  exports.UnaryExpression = UnaryExpression;
  exports.UpdateExpression = UpdateExpression;
  exports.VariableDeclarator = VariableDeclarator;
  var _t = require_lib5();
  var _infererReference = require_inferer_reference();
  var _util = require_util();
  var {
    BOOLEAN_BINARY_OPERATORS,
    BOOLEAN_UNARY_OPERATORS,
    NUMBER_BINARY_OPERATORS,
    NUMBER_UNARY_OPERATORS,
    STRING_UNARY_OPERATORS,
    anyTypeAnnotation,
    arrayTypeAnnotation,
    booleanTypeAnnotation,
    buildMatchMemberExpression,
    genericTypeAnnotation,
    identifier,
    nullLiteralTypeAnnotation,
    numberTypeAnnotation,
    stringTypeAnnotation,
    tupleTypeAnnotation,
    unionTypeAnnotation,
    voidTypeAnnotation,
    isIdentifier
  } = _t;
  function VariableDeclarator() {
    if (!this.get("id").isIdentifier())
      return;
    return this.get("init").getTypeAnnotation();
  }
  function TypeCastExpression(node) {
    return node.typeAnnotation;
  }
  TypeCastExpression.validParent = true;
  function TSAsExpression(node) {
    return node.typeAnnotation;
  }
  TSAsExpression.validParent = true;
  function TSNonNullExpression() {
    return this.get("expression").getTypeAnnotation();
  }
  function NewExpression(node) {
    if (node.callee.type === "Identifier") {
      return genericTypeAnnotation(node.callee);
    }
  }
  function TemplateLiteral() {
    return stringTypeAnnotation();
  }
  function UnaryExpression(node) {
    const operator = node.operator;
    if (operator === "void") {
      return voidTypeAnnotation();
    } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
      return numberTypeAnnotation();
    } else if (STRING_UNARY_OPERATORS.includes(operator)) {
      return stringTypeAnnotation();
    } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
      return booleanTypeAnnotation();
    }
  }
  function BinaryExpression(node) {
    const operator = node.operator;
    if (NUMBER_BINARY_OPERATORS.includes(operator)) {
      return numberTypeAnnotation();
    } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
      return booleanTypeAnnotation();
    } else if (operator === "+") {
      const right = this.get("right");
      const left = this.get("left");
      if (left.isBaseType("number") && right.isBaseType("number")) {
        return numberTypeAnnotation();
      } else if (left.isBaseType("string") || right.isBaseType("string")) {
        return stringTypeAnnotation();
      }
      return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
    }
  }
  function LogicalExpression() {
    const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, _util.createUnionType)(argumentTypes);
  }
  function ConditionalExpression() {
    const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, _util.createUnionType)(argumentTypes);
  }
  function SequenceExpression() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function ParenthesizedExpression() {
    return this.get("expression").getTypeAnnotation();
  }
  function AssignmentExpression() {
    return this.get("right").getTypeAnnotation();
  }
  function UpdateExpression(node) {
    const operator = node.operator;
    if (operator === "++" || operator === "--") {
      return numberTypeAnnotation();
    }
  }
  function StringLiteral() {
    return stringTypeAnnotation();
  }
  function NumericLiteral() {
    return numberTypeAnnotation();
  }
  function BooleanLiteral() {
    return booleanTypeAnnotation();
  }
  function NullLiteral() {
    return nullLiteralTypeAnnotation();
  }
  function RegExpLiteral() {
    return genericTypeAnnotation(identifier("RegExp"));
  }
  function ObjectExpression() {
    return genericTypeAnnotation(identifier("Object"));
  }
  function ArrayExpression() {
    return genericTypeAnnotation(identifier("Array"));
  }
  function RestElement() {
    return ArrayExpression();
  }
  RestElement.validParent = true;
  function Func() {
    return genericTypeAnnotation(identifier("Function"));
  }
  var isArrayFrom = buildMatchMemberExpression("Array.from");
  var isObjectKeys = buildMatchMemberExpression("Object.keys");
  var isObjectValues = buildMatchMemberExpression("Object.values");
  var isObjectEntries = buildMatchMemberExpression("Object.entries");
  function CallExpression() {
    const {
      callee
    } = this.node;
    if (isObjectKeys(callee)) {
      return arrayTypeAnnotation(stringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
      name: "Array"
    })) {
      return arrayTypeAnnotation(anyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
    }
    return resolveCall(this.get("callee"));
  }
  function TaggedTemplateExpression() {
    return resolveCall(this.get("tag"));
  }
  function resolveCall(callee) {
    callee = callee.resolve();
    if (callee.isFunction()) {
      const {
        node
      } = callee;
      if (node.async) {
        if (node.generator) {
          return genericTypeAnnotation(identifier("AsyncIterator"));
        } else {
          return genericTypeAnnotation(identifier("Promise"));
        }
      } else {
        if (node.generator) {
          return genericTypeAnnotation(identifier("Iterator"));
        } else if (callee.node.returnType) {
          return callee.node.returnType;
        } else {}
      }
    }
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._getTypeAnnotation = _getTypeAnnotation;
  exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  exports.couldBeBaseType = couldBeBaseType;
  exports.getTypeAnnotation = getTypeAnnotation;
  exports.isBaseType = isBaseType;
  exports.isGenericType = isGenericType;
  var inferers = require_inferers();
  var _t = require_lib5();
  var {
    anyTypeAnnotation,
    isAnyTypeAnnotation,
    isArrayTypeAnnotation,
    isBooleanTypeAnnotation,
    isEmptyTypeAnnotation,
    isFlowBaseAnnotation,
    isGenericTypeAnnotation,
    isIdentifier,
    isMixedTypeAnnotation,
    isNumberTypeAnnotation,
    isStringTypeAnnotation,
    isTSArrayType,
    isTSTypeAnnotation,
    isTSTypeReference,
    isTupleTypeAnnotation,
    isTypeAnnotation,
    isUnionTypeAnnotation,
    isVoidTypeAnnotation,
    stringTypeAnnotation,
    voidTypeAnnotation
  } = _t;
  function getTypeAnnotation() {
    let type = this.getData("typeAnnotation");
    if (type != null) {
      return type;
    }
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
    if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
      type = type.typeAnnotation;
    }
    this.setData("typeAnnotation", type);
    return type;
  }
  var typeAnnotationInferringNodes = new WeakSet;
  function _getTypeAnnotation() {
    const node = this.node;
    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }
        return voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }
    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }
    typeAnnotationInferringNodes.add(node);
    try {
      var _inferer;
      let inferer = inferers[node.type];
      if (inferer) {
        return inferer.call(this, node);
      }
      inferer = inferers[this.parentPath.type];
      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }
  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  }
  function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type))
      return true;
    if (isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();
    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
    return false;
  }
  function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    if (genericName === "Array") {
      if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
        return true;
      }
    }
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
      name: genericName
    });
  }
});

// ../../../../node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// ../../../../node_modules/js-tokens/index.js
var require_js_tokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  exports.matchToToken = function(match) {
    var token = { type: "invalid", value: match[0], closed: undefined };
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
});

// ../../../../node_modules/@babel/code-frame/lib/index.js
var require_lib7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var picocolors = require_picocolors();
  var jsTokens = require_js_tokens();
  var helperValidatorIdentifier = require_lib3();
  function isColorSupported() {
    return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
  }
  var compose = (f, g) => (v) => f(g(v));
  function buildDefs(colors) {
    return {
      keyword: colors.cyan,
      capitalized: colors.yellow,
      jsxIdentifier: colors.yellow,
      punctuator: colors.yellow,
      number: colors.magenta,
      string: colors.green,
      regex: colors.magenta,
      comment: colors.gray,
      invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
      gutter: colors.gray,
      marker: compose(colors.red, colors.bold),
      message: compose(colors.red, colors.bold),
      reset: colors.reset
    };
  }
  var defsOn = buildDefs(picocolors.createColors(true));
  var defsOff = buildDefs(picocolors.createColors(false));
  function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
  }
  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = jsTokens.default.exec(text)) {
        const token = jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  function highlight(text) {
    if (text === "")
      return "";
    const defs = getDefs(true);
    let highlighted = "";
    for (const {
      type,
      value
    } of tokenize(text)) {
      if (type in defs) {
        highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join(`
`);
      } else {
        highlighted += value;
      }
    }
    return highlighted;
  }
  var deprecationWarningShown = false;
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0;i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
      const number = start + 1 + index2;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = [`
 `, defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + defs.message(opts.message);
          }
        }
        return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join(`
`);
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (shouldHighlight) {
      return defs.reset(frame);
    } else {
      return frame;
    }
  }
  function index(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
  exports.codeFrameColumns = codeFrameColumns;
  exports.default = index;
  exports.highlight = highlight;
});

// ../../../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hooks = undefined;
  var hooks = exports.hooks = [function(self2, parent) {
    const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function(self2, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function(self2, parent) {
    if (parent.isBinary()) {
      if (self2.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  }, function(self2, parent) {
    if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self2.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];
});

// ../../../../node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._assertUnremoved = _assertUnremoved;
  exports._callRemovalHooks = _callRemovalHooks;
  exports._markRemoved = _markRemoved;
  exports._remove = _remove;
  exports._removeFromScope = _removeFromScope;
  exports.remove = remove;
  var _removalHooks = require_removal_hooks();
  var _cache = require_cache();
  var _replacement = require_replacement();
  var _index = require_path();
  var _t = require_lib5();
  var _modification = require_modification();
  var _context = require_context2();
  var {
    getBindingIdentifiers
  } = _t;
  function remove() {
    var _this$opts;
    _assertUnremoved.call(this);
    _context.resync.call(this);
    if (_callRemovalHooks.call(this)) {
      _markRemoved.call(this);
      return;
    }
    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      _removeFromScope.call(this);
    }
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
  }
  function _removeFromScope() {
    const bindings = getBindingIdentifiers(this.node, false, false, true);
    Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
  }
  function _callRemovalHooks() {
    if (this.parentPath) {
      for (const fn of _removalHooks.hooks) {
        if (fn(this, this.parentPath))
          return true;
      }
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      _modification.updateSiblingKeys.call(this, this.key, -1);
    } else {
      _replacement._replaceWith.call(this, null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
    if (this.parent) {
      var _getCachedPaths;
      (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    }
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _t = require_lib5();
  var _t2 = _t;
  var {
    react
  } = _t;
  var {
    cloneNode,
    jsxExpressionContainer,
    variableDeclaration,
    variableDeclarator
  } = _t2;
  var referenceVisitor = {
    ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }
      if (path.node.name === "this") {
        let scope = path.scope;
        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);
        if (scope)
          state.breakOnScopePaths.push(scope.path);
      }
      const binding = path.scope.getBinding(path.node.name);
      if (!binding)
        return;
      for (const violation of binding.constantViolations) {
        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }
      if (binding !== state.scope.getBinding(path.node.name))
        return;
      state.bindings[path.node.name] = binding;
    }
  };

  class PathHoister {
    constructor(path, scope) {
      this.breakOnScopePaths = undefined;
      this.bindings = undefined;
      this.mutableBinding = undefined;
      this.scopes = undefined;
      this.scope = undefined;
      this.path = undefined;
      this.attachAfter = undefined;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }
    isCompatibleScope(scope) {
      for (const key of Object.keys(this.bindings)) {
        const binding = this.bindings[key];
        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }
      return true;
    }
    getCompatibleScopes() {
      let scope = this.path.scope;
      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }
        if (this.breakOnScopePaths.includes(scope.path)) {
          break;
        }
      } while (scope = scope.parent);
    }
    getAttachmentPath() {
      let path = this._getAttachmentPath();
      if (!path)
        return;
      let targetScope = path.scope;
      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }
      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (const name of Object.keys(this.bindings)) {
          if (!targetScope.hasOwnBinding(name))
            continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }
          const bindingParentPath = this.getAttachmentParentForPath(binding.path);
          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;
            for (const violationPath of binding.constantViolations) {
              if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                path = violationPath;
              }
            }
          }
        }
      }
      return path;
    }
    _getAttachmentPath() {
      const scopes = this.scopes;
      const scope = scopes.pop();
      if (!scope)
        return;
      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope)
            return;
          const bodies = scope.path.get("body").get("body");
          for (let i = 0;i < bodies.length; i++) {
            if (bodies[i].node._blockHoist)
              continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const scope = this.scopes.pop();
      if (scope)
        return this.getAttachmentParentForPath(scope.path);
    }
    getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    }
    hasOwnParamBindings(scope) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope.hasOwnBinding(name))
          continue;
        const binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant)
          return true;
      }
      return false;
    }
    run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding)
        return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo)
        return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent())
        return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = variableDeclarator(uid, this.path.node);
      const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
      const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
      const parent = this.path.parentPath;
      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }
      this.path.replaceWith(cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  }
  exports.default = PathHoister;
});

// ../../../../node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._containerInsert = _containerInsert;
  exports._containerInsertAfter = _containerInsertAfter;
  exports._containerInsertBefore = _containerInsertBefore;
  exports._verifyNodeList = _verifyNodeList;
  exports.insertAfter = insertAfter;
  exports.insertBefore = insertBefore;
  exports.pushContainer = pushContainer;
  exports.unshiftContainer = unshiftContainer;
  exports.updateSiblingKeys = updateSiblingKeys;
  var _cache = require_cache();
  var _index = require_path();
  var _context = require_context2();
  var _removal = require_removal();
  var _t = require_lib5();
  var _hoister = require_hoister();
  var {
    arrowFunctionExpression,
    assertExpression,
    assignmentExpression,
    blockStatement,
    callExpression,
    cloneNode,
    expressionStatement,
    isAssignmentExpression,
    isCallExpression,
    isExportNamedDeclaration,
    isExpression,
    isIdentifier,
    isSequenceExpression,
    isSuper,
    thisExpression
  } = _t;
  function insertBefore(nodes_) {
    _removal._assertUnremoved.call(this);
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node)
        nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertBefore.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    updateSiblingKeys.call(this, from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);
    for (let i = 0;i < nodes.length; i++) {
      var _this$context;
      const to = from + i;
      const path = this.getSibling(to);
      paths.push(path);
      if ((_this$context = this.context) != null && _this$context.queue) {
        _context.pushContext.call(path, this.context);
      }
    }
    const contexts = _context._getQueueContexts.call(this);
    for (const path of paths) {
      _context.setScope.call(path);
      path.debug("Inserted.");
      for (const context of contexts) {
        context.maybeQueue(path, true);
      }
    }
    return paths;
  }
  function _containerInsertBefore(nodes) {
    return _containerInsert.call(this, this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return _containerInsert.call(this, this.key + 1, nodes);
  }
  var last = (arr) => arr[arr.length - 1];
  function isHiddenInSequenceExpression(path) {
    return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
  }
  function isAlmostConstantAssignment(node, scope) {
    if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
      return false;
    }
    const blockScope = scope.getBlockParent();
    return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
  }
  function insertAfter(nodes_) {
    _removal._assertUnremoved.call(this);
    if (this.isSequenceExpression()) {
      return last(this.get("expressions")).insertAfter(nodes_);
    }
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map((node) => {
        return isExpression(node) ? expressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      const self2 = this;
      if (self2.node) {
        const node = self2.node;
        let {
          scope
        } = this;
        if (scope.path.isPattern()) {
          assertExpression(node);
          self2.replaceWith(callExpression(arrowFunctionExpression([], node), []));
          self2.get("callee.body").insertAfter(nodes);
          return [self2];
        }
        if (isHiddenInSequenceExpression(self2)) {
          nodes.unshift(node);
        } else if (isCallExpression(node) && isSuper(node.callee)) {
          nodes.unshift(node);
          nodes.push(thisExpression());
        } else if (isAlmostConstantAssignment(node, scope)) {
          nodes.unshift(node);
          nodes.push(cloneNode(node.left));
        } else if (scope.isPure(node, true)) {
          nodes.push(node);
        } else {
          if (parentPath.isMethod({
            computed: true,
            key: node
          })) {
            scope = scope.parent;
          }
          const temp = scope.generateDeclaredUidIdentifier();
          nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
          nodes.push(expressionStatement(cloneNode(temp)));
        }
      }
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertAfter.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent)
      return;
    const paths = (0, _cache.getCachedPaths)(this);
    if (!paths)
      return;
    for (const [, path] of paths) {
      if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      let msg;
      if (!node) {
        msg = "has falsy node";
      } else if (typeof node !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof _index.default) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        const type = Array.isArray(node) ? "array" : typeof node;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }
    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    nodes = _verifyNodeList.call(this, nodes);
    const path = _index.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey,
      key: 0
    }).setContext(this.context);
    return _containerInsertBefore.call(path, nodes);
  }
  function pushContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes);
    const container = this.node[listKey];
    const path = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: container.length
    }).setContext(this.context);
    return path.replaceWithMultiple(verifiedNodes);
  }
  {
    exports.hoist = function hoist(scope = this.scope) {
      const hoister = new _hoister.default(this, scope);
      return hoister.run();
    };
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._replaceWith = _replaceWith;
  exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
  exports.replaceInline = replaceInline;
  exports.replaceWith = replaceWith;
  exports.replaceWithMultiple = replaceWithMultiple;
  exports.replaceWithSourceString = replaceWithSourceString;
  var _codeFrame = require_lib7();
  var _index = require_lib9();
  var _index2 = require_path();
  var _cache = require_cache();
  var _modification = require_modification();
  var _parser = require_lib();
  var _t = require_lib5();
  var _context = require_context2();
  var {
    FUNCTION_TYPES,
    arrowFunctionExpression,
    assignmentExpression,
    awaitExpression,
    blockStatement,
    buildUndefinedNode,
    callExpression,
    cloneNode,
    conditionalExpression,
    expressionStatement,
    getBindingIdentifiers,
    identifier,
    inheritLeadingComments,
    inheritTrailingComments,
    inheritsComments,
    isBlockStatement,
    isEmptyStatement,
    isExpression,
    isExpressionStatement,
    isIfStatement,
    isProgram,
    isStatement,
    isVariableDeclaration,
    removeComments,
    returnStatement,
    sequenceExpression,
    validate,
    yieldExpression
  } = _t;
  function replaceWithMultiple(nodes) {
    var _getCachedPaths;
    _context.resync.call(this);
    nodes = _modification._verifyNodeList.call(this, nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
    return paths;
  }
  function replaceWithSourceString(replacement) {
    _context.resync.call(this);
    let ast;
    try {
      replacement = `(${replacement})`;
      ast = (0, _parser.parse)(replacement);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += ` - make sure this is an expression.
` + (0, _codeFrame.codeFrameColumns)(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }
      throw err;
    }
    const expressionAST = ast.program.body[0].expression;
    _index.default.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
  }
  function replaceWith(replacementPath) {
    _context.resync.call(this);
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement) {
      return [this];
    }
    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    let nodePath = "";
    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = expressionStatement(replacement);
        nodePath = "expression";
      }
    }
    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }
    const oldNode = this.node;
    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }
    _replaceWith.call(this, replacement);
    this.type = replacement.type;
    _context.setScope.call(this);
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node) {
    var _getCachedPaths2;
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      validate(this.parent, this.key, [node]);
    } else {
      validate(this.parent, this.key, node);
    }
    this.debug(`Replace with ${node == null ? undefined : node.type}`);
    (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node, this).delete(this.node);
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    _context.resync.call(this);
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
    if (nodesAsSingleExpression) {
      for (const id of declars)
        this.scope.push({
          id
        });
      return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
    }
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent == null ? undefined : functionParent.node.async;
    const isParentGenerator = functionParent == null ? undefined : functionParent.node.generator;
    const container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    const callee = this.get("callee");
    callee.get("body").scope.hoistVariables((id) => this.scope.push({
      id
    }));
    const completionRecords = callee.getCompletionRecords();
    for (const path of completionRecords) {
      if (!path.isExpressionStatement())
        continue;
      const loop = path.findParent((path2) => path2.isLoop());
      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");
        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier(uid.name);
        }
        path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(returnStatement(path.node.expression));
      }
    }
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
    if (needToAwaitFunction) {
      newCallee.set("async", true);
      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }
    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }
    return newCallee.get("body.body");
  }
  function gatherSequenceExpressions(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes) {
      if (!isEmptyStatement(node)) {
        ensureLastUndefined = false;
      }
      if (isExpression(node)) {
        exprs.push(node);
      } else if (isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (isVariableDeclaration(node)) {
        if (node.kind !== "var")
          return;
        for (const declar of node.declarations) {
          const bindings = getBindingIdentifiers(declar);
          for (const key of Object.keys(bindings)) {
            declars.push(cloneNode(bindings[key]));
          }
          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if (isIfStatement(node)) {
        const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
        const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
        if (!consequent || !alternate)
          return;
        exprs.push(conditionalExpression(node.test, consequent, alternate));
      } else if (isBlockStatement(node)) {
        const body = gatherSequenceExpressions(node.body, declars);
        if (!body)
          return;
        exprs.push(body);
      } else if (isEmptyStatement(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined)
      exprs.push(buildUndefinedNode());
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }
  function replaceInline(nodes) {
    _context.resync.call(this);
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = _modification._verifyNodeList.call(this, nodes);
        const paths = _modification._containerInsertAfter.call(this, nodes);
        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.evaluate = evaluate;
  exports.evaluateTruthy = evaluateTruthy;
  var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
  var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
  var INVALID_METHODS = ["random"];
  function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
  }
  function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
  }
  function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
  }
  function evaluateTruthy() {
    const res = this.evaluate();
    if (res.confident)
      return !!res.value;
  }
  function deopt(path, state) {
    if (!state.confident)
      return;
    state.deoptPath = path;
    state.confident = false;
  }
  var Globals = new Map([["undefined", undefined], ["Infinity", Infinity], ["NaN", NaN]]);
  function evaluateCached(path, state) {
    const {
      node
    } = path;
    const {
      seen
    } = state;
    if (seen.has(node)) {
      const existing = seen.get(node);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      const item = {
        resolved: false
      };
      seen.set(node, item);
      const val = _evaluate(path, state);
      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }
  function _evaluate(path, state) {
    if (!state.confident)
      return;
    if (path.isSequenceExpression()) {
      const exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }
    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return path.node.value;
    }
    if (path.isNullLiteral()) {
      return null;
    }
    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, path.node.quasis, state);
    }
    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      const object = path.get("tag.object");
      const {
        node: {
          name
        }
      } = object;
      const property = path.get("tag.property");
      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }
    if (path.isConditionalExpression()) {
      const testResult = evaluateCached(path.get("test"), state);
      if (!state.confident)
        return;
      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }
    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }
    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: path.node
    })) {
      const property = path.get("property");
      const object = path.get("object");
      if (object.isLiteral()) {
        const value = object.node.value;
        const type = typeof value;
        let key = null;
        if (path.node.computed) {
          key = evaluateCached(property, state);
          if (!state.confident)
            return;
        } else if (property.isIdentifier()) {
          key = property.node.name;
        }
        if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
          return value[key];
        }
      }
    }
    if (path.isReferencedIdentifier()) {
      const binding = path.scope.getBinding(path.node.name);
      if (binding) {
        if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
          deopt(binding.path, state);
          return;
        }
        const bindingPathScope = binding.path.scope;
        if (binding.kind === "var" && bindingPathScope !== binding.scope) {
          let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
          for (let scope = bindingPathScope.parent;scope; scope = scope.parent) {
            var _scope$path$parentPat;
            if (scope === path.scope) {
              if (hasUnsafeBlock) {
                deopt(binding.path, state);
                return;
              }
              break;
            }
            if ((_scope$path$parentPat = scope.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {
              hasUnsafeBlock = true;
            }
          }
        }
        if (binding.hasValue) {
          return binding.value;
        }
      }
      const name = path.node.name;
      if (Globals.has(name)) {
        if (!binding) {
          return Globals.get(name);
        }
        deopt(binding.path, state);
        return;
      }
      const resolved = path.resolve();
      if (resolved === path) {
        deopt(path, state);
        return;
      }
      const value = evaluateCached(resolved, state);
      if (typeof value === "object" && value !== null && binding.references > 1) {
        deopt(resolved, state);
        return;
      }
      return value;
    }
    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (path.node.operator === "void") {
        return;
      }
      const argument = path.get("argument");
      if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }
      const arg = evaluateCached(argument, state);
      if (!state.confident)
        return;
      switch (path.node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg;
      }
    }
    if (path.isArrayExpression()) {
      const arr = [];
      const elems = path.get("elements");
      for (const elem of elems) {
        const elemValue = elem.evaluate();
        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          deopt(elemValue.deopt, state);
          return;
        }
      }
      return arr;
    }
    if (path.isObjectExpression()) {
      const obj = {};
      const props = path.get("properties");
      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          deopt(prop, state);
          return;
        }
        const keyPath = prop.get("key");
        let key;
        if (prop.node.computed) {
          key = keyPath.evaluate();
          if (!key.confident) {
            deopt(key.deopt, state);
            return;
          }
          key = key.value;
        } else if (keyPath.isIdentifier()) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get("value");
        let value = valuePath.evaluate();
        if (!value.confident) {
          deopt(value.deopt, state);
          return;
        }
        value = value.value;
        obj[key] = value;
      }
      return obj;
    }
    if (path.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left = evaluateCached(path.get("left"), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right = evaluateCached(path.get("right"), state);
      const rightConfident = state.confident;
      switch (path.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident)
            return;
          return left || right;
        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident)
            return;
          return left && right;
        case "??":
          state.confident = leftConfident && (left != null || rightConfident);
          if (!state.confident)
            return;
          return left != null ? left : right;
      }
    }
    if (path.isBinaryExpression()) {
      const left = evaluateCached(path.get("left"), state);
      if (!state.confident)
        return;
      const right = evaluateCached(path.get("right"), state);
      if (!state.confident)
        return;
      switch (path.node.operator) {
        case "-":
          return left - right;
        case "+":
          return left + right;
        case "/":
          return left / right;
        case "*":
          return left * right;
        case "%":
          return left % right;
        case "**":
          return Math.pow(left, right);
        case "<":
          return left < right;
        case ">":
          return left > right;
        case "<=":
          return left <= right;
        case ">=":
          return left >= right;
        case "==":
          return left == right;
        case "!=":
          return left != right;
        case "===":
          return left === right;
        case "!==":
          return left !== right;
        case "|":
          return left | right;
        case "&":
          return left & right;
        case "^":
          return left ^ right;
        case "<<":
          return left << right;
        case ">>":
          return left >> right;
        case ">>>":
          return left >>> right;
      }
    }
    if (path.isCallExpression()) {
      const callee = path.get("callee");
      let context;
      let func;
      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
        func = global[callee.node.name];
      }
      if (callee.isMemberExpression()) {
        const object = callee.get("object");
        const property = callee.get("property");
        if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
          context = global[object.node.name];
          const key = property.node.name;
          if (hasOwnProperty.call(context, key)) {
            func = context[key];
          }
        }
        if (object.isLiteral() && property.isIdentifier()) {
          const type = typeof object.node.value;
          if (type === "string" || type === "number") {
            context = object.node.value;
            func = context[property.node.name];
          }
        }
      }
      if (func) {
        const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
        if (!state.confident)
          return;
        return func.apply(context, args);
      }
    }
    deopt(path, state);
  }
  function evaluateQuasis(path, quasis, state, raw = false) {
    let str = "";
    let i = 0;
    const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
    for (const elem of quasis) {
      if (!state.confident)
        break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr)
        str += String(evaluateCached(expr, state));
    }
    if (!state.confident)
      return;
    return str;
  }
  function evaluate() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: new Map
    };
    let value = evaluateCached(this, state);
    if (!state.confident)
      value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value
    };
  }
});

// ../../../../node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.statements = exports.statement = exports.smart = exports.program = exports.expression = undefined;
  var _t = require_lib5();
  var {
    assertExpressionStatement
  } = _t;
  function makeStatementFormatter(fn) {
    return {
      code: (str) => `/* @babel/template */;
${str}`,
      validate: () => {},
      unwrap: (ast) => {
        return fn(ast.program.body.slice(1));
      }
    };
  }
  var smart = exports.smart = makeStatementFormatter((body) => {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  var statements = exports.statements = makeStatementFormatter((body) => body);
  var statement = exports.statement = makeStatementFormatter((body) => {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  var expression = exports.expression = {
    code: (str) => `(
${str}
)`,
    validate: (ast) => {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: ({
      program: program2
    }) => {
      const [stmt] = program2.body;
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  var program = exports.program = {
    code: (str) => str,
    validate: () => {},
    unwrap: (ast) => ast.program
  };
});

// ../../../../node_modules/@babel/template/lib/options.js
var require_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.merge = merge;
  exports.normalizeReplacements = normalizeReplacements;
  exports.validate = validate;
  var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function _objectWithoutPropertiesLoose(r, e) {
    if (r == null)
      return {};
    var t = {};
    for (var n in r)
      if ({}.hasOwnProperty.call(r, n)) {
        if (e.indexOf(n) !== -1)
          continue;
        t[n] = r[n];
      }
    return t;
  }
  function merge(a, b) {
    const {
      placeholderWhitelist = a.placeholderWhitelist,
      placeholderPattern = a.placeholderPattern,
      preserveComments = a.preserveComments,
      syntacticPlaceholders = a.syntacticPlaceholders
    } = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    };
  }
  function validate(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }
    const _ref = opts || {}, {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    return {
      parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement, i) => {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
});

// ../../../../node_modules/@babel/template/lib/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parseAndBuildMetadata;
  var _t = require_lib5();
  var _parser = require_lib();
  var _codeFrame = require_lib7();
  var {
    isCallExpression,
    isExpressionStatement,
    isFunction,
    isIdentifier,
    isJSXIdentifier,
    isNewExpression,
    isPlaceholder,
    isStatement,
    isStringLiteral,
    removePropertiesDeep,
    traverse
  } = _t;
  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments
    });
    formatter.validate(ast);
    const state = {
      syntactic: {
        placeholders: [],
        placeholderNames: new Set
      },
      legacy: {
        placeholders: [],
        placeholderNames: new Set
      },
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders
    };
    traverse(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  }
  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      }
      name = node.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
      name = node.name;
    } else if (isStringLiteral(node)) {
      name = node.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    const {
      node: parent,
      key
    } = ancestors[ancestors.length - 1];
    let type;
    if (isStringLiteral(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }
    const {
      placeholders,
      placeholderNames
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    placeholders.push({
      name,
      type,
      resolve: (ast) => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }
  function resolveAncestors(ast, ancestors) {
    let parent = ast;
    for (let i = 0;i < ancestors.length - 1; i++) {
      const {
        key: key2,
        index: index2
      } = ancestors[i];
      if (index2 === undefined) {
        parent = parent[key2];
      } else {
        parent = parent[key2][index2];
      }
    }
    const {
      key,
      index
    } = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index
    };
  }
  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowAwaitOutsideFunction: true,
      allowReturnOutsideFunction: true,
      allowNewTargetOutsideFunction: true,
      allowSuperOutsideMethod: true,
      allowYieldOutsideFunction: true,
      sourceType: "module"
    }, parserOpts, {
      plugins
    });
    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += `
` + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  }
});

// ../../../../node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = populatePlaceholders;
  var _t = require_lib5();
  var {
    blockStatement,
    cloneNode,
    emptyStatement,
    expressionStatement,
    identifier,
    isStatement,
    isStringLiteral,
    stringLiteral,
    validate
  } = _t;
  function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach((placeholder) => {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      });
      Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach((placeholder) => {
      try {
        var _ref;
        applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
        throw e;
      }
    });
    return ast;
  }
  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map((node) => cloneNode(node));
      } else if (typeof replacement === "object") {
        replacement = cloneNode(replacement);
      }
    }
    const {
      parent,
      key,
      index
    } = placeholder.resolve(ast);
    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral(replacement);
      }
      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement(identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }
          if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (index === undefined)
        throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    function set(parent2, key2, value) {
      const node = parent2[key2];
      parent2[key2] = value;
      if (node.type === "Identifier" || node.type === "Placeholder") {
        if (node.typeAnnotation) {
          value.typeAnnotation = node.typeAnnotation;
        }
        if (node.optional) {
          value.optional = node.optional;
        }
        if (node.decorators) {
          value.decorators = node.decorators;
        }
      }
    }
    if (index === undefined) {
      validate(parent, key, replacement);
      set(parent, key, replacement);
    } else {
      const items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice(index, 1, ...replacement);
        } else {
          set(items, index, replacement);
        }
      } else {
        set(items, index, replacement);
      }
      validate(parent, key, items);
      parent[key] = items;
    }
  }
});

// ../../../../node_modules/@babel/template/lib/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = stringTemplate;
  var _options = require_options();
  var _parse = require_parse();
  var _populate = require_populate();
  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg) => {
      const replacements = (0, _options.normalizeReplacements)(arg);
      if (!metadata)
        metadata = (0, _parse.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
  }
});

// ../../../../node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = literalTemplate;
  var _options = require_options();
  var _parse = require_parse();
  var _populate = require_populate();
  function literalTemplate(formatter, tpl, opts) {
    const {
      metadata,
      names
    } = buildLiteralData(formatter, tpl, opts);
    return (arg) => {
      const defaultReplacements = {};
      arg.forEach((replacement, i) => {
        defaultReplacements[names[i]] = replacement;
      });
      return (arg2) => {
        const replacements = (0, _options.normalizeReplacements)(arg2);
        if (replacements) {
          Object.keys(replacements).forEach((key) => {
            if (hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }
  function buildLiteralData(formatter, tpl, opts) {
    let prefix = "BABEL_TPL$";
    const raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    const {
      names,
      code
    } = buildTemplateCode(tpl, prefix);
    const metadata = (0, _parse.default)(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata,
      names
    };
  }
  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for (let i = 1;i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value);
      code += value + tpl[i];
    }
    return {
      names,
      code
    };
  }
});

// ../../../../node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTemplateBuilder;
  var _options = require_options();
  var _string = require_string();
  var _literal = require_literal();
  var NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = new WeakMap;
    const templateAstCache = new WeakMap;
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1)
          throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        let builder = templateFnCache.get(tpl);
        if (!builder) {
          builder = (0, _literal.default)(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }
        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0)
          throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1)
            throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          let builder = templateAstCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }
          return builder(args)();
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }
    });
  }
  function extendedTrace(fn) {
    let rootStack = "";
    try {
      throw new Error;
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split(`
`).slice(3).join(`
`);
      }
    }
    return (arg) => {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += `
    =============
${rootStack}`;
        throw err;
      }
    };
  }
});

// ../../../../node_modules/@babel/template/lib/index.js
var require_lib8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = undefined;
  var formatters = require_formatters();
  var _builder = require_builder();
  var smart = exports.smart = (0, _builder.default)(formatters.smart);
  var statement = exports.statement = (0, _builder.default)(formatters.statement);
  var statements = exports.statements = (0, _builder.default)(formatters.statements);
  var expression = exports.expression = (0, _builder.default)(formatters.expression);
  var program = exports.program = (0, _builder.default)(formatters.program);
  var _default = exports.default = Object.assign(smart.bind(undefined), {
    smart,
    statement,
    statements,
    expression,
    program,
    ast: smart.ast
  });
});

// ../../../../node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.arrowFunctionToExpression = arrowFunctionToExpression;
  exports.ensureBlock = ensureBlock;
  exports.ensureFunctionName = ensureFunctionName;
  exports.splitExportDeclaration = splitExportDeclaration;
  exports.toComputedKey = toComputedKey;
  exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  var _t = require_lib5();
  var _template = require_lib8();
  var _visitors = require_visitors();
  var _context = require_context2();
  var {
    arrowFunctionExpression,
    assignmentExpression,
    binaryExpression,
    blockStatement,
    callExpression,
    conditionalExpression,
    expressionStatement,
    identifier,
    isIdentifier,
    jsxIdentifier,
    logicalExpression,
    LOGICAL_OPERATORS,
    memberExpression,
    metaProperty,
    numericLiteral,
    objectExpression,
    restElement,
    returnStatement,
    sequenceExpression,
    spreadElement,
    stringLiteral,
    super: _super,
    thisExpression,
    toExpression,
    unaryExpression,
    toBindingIdentifierName,
    isFunction,
    isAssignmentPattern,
    isRestElement,
    getFunctionName,
    cloneNode,
    variableDeclaration,
    variableDeclarator,
    exportNamedDeclaration,
    exportSpecifier,
    inherits
  } = _t;
  function toComputedKey() {
    let key;
    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!this.node.computed) {
      if (isIdentifier(key))
        key = stringLiteral(key.name);
    }
    return key;
  }
  function ensureBlock() {
    const body = this.get("body");
    const bodyNode = body.node;
    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }
    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }
    if (body.isBlockStatement()) {
      return bodyNode;
    }
    const statements = [];
    let stringPath = "body";
    let key;
    let listKey;
    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";
      if (this.isFunction()) {
        key = "argument";
        statements.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(expressionStatement(body.node));
      }
    }
    this.node.body = blockStatement(statements);
    const parentPath = this.get(stringPath);
    _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  {
    exports.arrowFunctionToShadowed = function() {
      if (!this.isArrowFunctionExpression())
        return;
      this.arrowFunctionToExpression();
    };
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }
    hoistFunctionEnvironment(this);
  }
  function setType(path, type) {
    path.node.type = type;
  }
  function arrowFunctionToExpression({
    allowInsertArrow = true,
    allowInsertArrowWithRest = allowInsertArrow,
    noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? undefined : _arguments$.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }
    let self2 = this;
    if (!noNewArrows) {
      var _self$ensureFunctionN;
      self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
    }
    const {
      thisBinding,
      fnPath: fn
    } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    fn.ensureBlock();
    setType(fn, "FunctionExpression");
    if (!noNewArrows) {
      const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
      if (checkBinding) {
        fn.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }
      fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
      fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
      return fn.get("callee.object");
    }
    return fn;
  }
  var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      allSuperCalls
    }) {
      if (!child.get("callee").isSuper())
        return;
      allSuperCalls.push(child);
    }
  });
  function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
      if (p.isArrowFunctionExpression()) {
        arrowParent != null || (arrowParent = p);
        return false;
      }
      return p.isFunction() || p.isProgram() || p.isClassProperty({
        static: false
      }) || p.isClassPrivateProperty({
        static: false
      });
    });
    const inConstructor = thisEnvFn.isClassMethod({
      kind: "constructor"
    });
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
      if (arrowParent) {
        thisEnvFn = arrowParent;
      } else if (allowInsertArrow) {
        fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
        thisEnvFn = fnPath.get("callee");
        fnPath = thisEnvFn.get("body");
      } else {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
    }
    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    } = getScopeInformation(fnPath);
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      if (!allowInsertArrowWithRest) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const allSuperCalls = [];
      thisEnvFn.traverse(getSuperCallsVisitor, {
        allSuperCalls
      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach((superCall) => {
        const callee = identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
        const args = () => identifier("arguments");
        if (thisEnvFn.scope.path.isProgram()) {
          return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
        } else {
          return args();
        }
      });
      argumentsPaths.forEach((argumentsChild) => {
        const argsRef = identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
      newTargetPaths.forEach((targetChild) => {
        const targetRef = identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
      flatSuperProps.forEach((superProp) => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name;
        const superParentPath = superProp.parentPath;
        const isAssignment = superParentPath.isAssignmentExpression({
          left: superProp.node
        });
        const isCall = superParentPath.isCallExpression({
          callee: superProp.node
        });
        const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
          tag: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          const value = superParentPath.node.right;
          args.push(value);
        }
        const call = callExpression(identifier(superBinding), args);
        if (isCall) {
          superParentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier("call")));
          thisPaths.push(superParentPath.get("arguments.0"));
        } else if (isAssignment) {
          superParentPath.replaceWith(call);
        } else if (isTaggedTemplate) {
          superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
          thisPaths.push(superProp.get("arguments.0"));
        } else {
          superProp.replaceWith(call);
        }
      });
    }
    let thisBinding;
    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);
      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach((thisChild) => {
          const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows)
          thisBinding = null;
      }
    }
    return {
      thisBinding,
      fnPath
    };
  }
  function isLogicalOp(op) {
    return LOGICAL_OPERATORS.includes(op);
  }
  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      const assignmentPath = superProp.parentPath;
      const op = assignmentPath.node.operator.slice(0, -1);
      const value = assignmentPath.node.right;
      const isLogicalAssignment = isLogicalOp(op);
      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const object = superProp.node.object;
        const property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
      } else {
        const object = superProp.node.object;
        const property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, property));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
      }
      if (isLogicalAssignment) {
        assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
      } else {
        assignmentPath.node.operator = "=";
      }
      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier(tmp.name));
      }
      updateExpr.replaceWith(sequenceExpression(parts));
      const left = updateExpr.get("expressions.0.right");
      const right = updateExpr.get("expressions.1.left");
      return [left, right];
    }
    return [superProp];
    function rightExpression(op, left, right) {
      if (op === "=") {
        return assignmentExpression("=", left, right);
      } else {
        return binaryExpression(op, left, right);
      }
    }
  }
  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }
  var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      supers,
      thisBinding
    }) {
      if (!child.get("callee").isSuper())
        return;
      if (supers.has(child.node))
        return;
      supers.add(child.node);
      child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
    }
  });
  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", (thisBinding) => {
      if (!inConstructor || !hasSuperClass(thisEnvFn))
        return thisExpression();
      thisEnvFn.traverse(assignSuperThisVisitor, {
        supers: new WeakSet,
        thisBinding
      });
    });
  }
  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
    });
  }
  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
      const argsList = [];
      let fnBody;
      if (propName) {
        fnBody = memberExpression(_super(), identifier(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier(method.name), true);
      }
      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
      }
      return arrowFunctionExpression(argsList, fnBody);
    });
  }
  function getBinding(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);
    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id,
        init: init(data)
      });
    }
    return data;
  }
  var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
    ThisExpression(child, {
      thisPaths
    }) {
      thisPaths.push(child);
    },
    JSXIdentifier(child, {
      thisPaths
    }) {
      if (child.node.name !== "this")
        return;
      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression(child, {
      superCalls
    }) {
      if (child.get("callee").isSuper())
        superCalls.push(child);
    },
    MemberExpression(child, {
      superProps
    }) {
      if (child.get("object").isSuper())
        superProps.push(child);
    },
    Identifier(child, {
      argumentsPaths
    }) {
      if (!child.isReferencedIdentifier({
        name: "arguments"
      }))
        return;
      let curr = child.scope;
      do {
        if (curr.hasOwnBinding("arguments")) {
          curr.rename("arguments");
          return;
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break;
        }
      } while (curr = curr.parent);
      argumentsPaths.push(child);
    },
    MetaProperty(child, {
      newTargetPaths
    }) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      }))
        return;
      if (!child.get("property").isIdentifier({
        name: "target"
      }))
        return;
      newTargetPaths.push(child);
    }
  });
  function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse(getScopeInformationVisitor, {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    };
  }
  function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
      throw new Error("Only default and named export declarations can be split.");
    }
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const declaration = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
      const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
      const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      let id = declaration.node.id;
      let needBindingRegistration = false;
      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");
        if (standaloneDeclaration || exportExpr) {
          declaration.node.id = cloneNode(id);
        }
      } else if (exportExpr && scope.hasBinding(id.name)) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier(id.name);
      }
      const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
      const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
      this.insertAfter(updatedExportDeclaration);
      this.replaceWith(updatedDeclaration);
      if (needBindingRegistration) {
        scope.registerDeclaration(this);
      }
      return this;
    } else if (this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map((name) => {
      return exportSpecifier(identifier(name), identifier(name));
    });
    const aliasDeclar = exportNamedDeclaration(null, specifiers);
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
  }
  var refersOuterBindingVisitor = {
    "ReferencedIdentifier|BindingIdentifier"(path, state) {
      if (path.node.name !== state.name)
        return;
      state.needsRename = true;
      path.stop();
    },
    Scope(path, state) {
      if (path.scope.hasOwnBinding(state.name)) {
        path.skip();
      }
    }
  };
  function ensureFunctionName(supportUnicodeId) {
    if (this.node.id)
      return this;
    const res = getFunctionName(this.node, this.parent);
    if (res == null)
      return this;
    let {
      name
    } = res;
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
      return null;
    }
    if (name.startsWith("get ") || name.startsWith("set ")) {
      return null;
    }
    name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
    const id = identifier(name);
    inherits(id, res.originalNode);
    const state = {
      needsRename: false,
      name
    };
    const {
      scope
    } = this;
    const binding = scope.getOwnBinding(name);
    if (binding) {
      if (binding.kind === "param") {
        state.needsRename = true;
      } else {}
    } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
      this.traverse(refersOuterBindingVisitor, state);
    }
    if (!state.needsRename) {
      this.node.id = id;
      {
        scope.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      scope.rename(id.name);
      this.node.id = id;
      {
        scope.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (!isFunction(this.node))
      return null;
    const key = scope.generateUidIdentifier(id.name);
    const params = [];
    for (let i = 0, len = getFunctionArity(this.node);i < len; i++) {
      params.push(scope.generateUidIdentifier("x"));
    }
    const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `;
    return this.replaceWith(call)[0].get("arguments.0");
  }
  function getFunctionArity(node) {
    const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
    return count === -1 ? node.params.length : count;
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
  exports._resolve = _resolve;
  exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
  exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
  exports.getSource = getSource;
  exports.isCompletionRecord = isCompletionRecord;
  exports.isConstantExpression = isConstantExpression;
  exports.isInStrictMode = isInStrictMode;
  exports.isNodeType = isNodeType;
  exports.isStatementOrBlock = isStatementOrBlock;
  exports.isStatic = isStatic;
  exports.matchesPattern = matchesPattern;
  exports.referencesImport = referencesImport;
  exports.resolve = resolve;
  exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
  var _t = require_lib5();
  var {
    STATEMENT_OR_BLOCK_KEYS,
    VISITOR_KEYS,
    isBlockStatement,
    isExpression,
    isIdentifier,
    isLiteral,
    isStringLiteral,
    isType,
    matchesPattern: _matchesPattern
  } = _t;
  function matchesPattern(pattern, allowPartial) {
    return _matchesPattern(this.node, pattern, allowPartial);
  }
  {
    exports.has = function has(key) {
      var _this$node;
      const val = (_this$node = this.node) == null ? undefined : _this$node[key];
      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    };
  }
  function isStatic() {
    return this.scope.isStatic(this.node);
  }
  {
    exports.is = exports.has;
    exports.isnt = function isnt(key) {
      return !this.has(key);
    };
    exports.equals = function equals(key, value) {
      return this.node[key] === value;
    };
  }
  function isNodeType(type) {
    return isType(this.type, type);
  }
  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }
    if (this.isExpression()) {
      return isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return isExpression(replacement);
    }
    return false;
  }
  function isCompletionRecord(allowInsideFunction) {
    let path = this;
    let first = true;
    do {
      const {
        type,
        container
      } = path;
      if (!first && (path.isFunction() || type === "StaticBlock")) {
        return !!allowInsideFunction;
      }
      first = false;
      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
    return true;
  }
  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
      return false;
    } else {
      return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
  }
  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
        value: importName
      }) : this.node.property.name === importName)) {
        const object = this.get("object");
        return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
      }
      return false;
    }
    const binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module")
      return false;
    const path = binding.path;
    const parent = path.parentPath;
    if (!parent.isImportDeclaration())
      return false;
    if (parent.node.source.value === moduleSource) {
      if (!importName)
        return true;
    } else {
      return false;
    }
    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }
    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }
    if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
      name: importName
    })) {
      return true;
    }
    return false;
  }
  function getSource() {
    const node = this.node;
    if (node.end) {
      const code = this.hub.getCode();
      if (code)
        return code.slice(node.start, node.end);
    }
    return "";
  }
  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }
  function getOuterFunction(path) {
    return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
  }
  function isExecutionUncertain(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";
      case "ForStatement":
        return key === "body" || key === "update";
      case "SwitchStatement":
        return key === "cases";
      case "TryStatement":
        return key === "handler";
      case "AssignmentPattern":
        return key === "right";
      case "OptionalMemberExpression":
        return key === "property";
      case "OptionalCallExpression":
        return key === "arguments";
      default:
        return false;
    }
  }
  function isExecutionUncertainInList(paths, maxIndex) {
    for (let i = 0;i < maxIndex; i++) {
      const path = paths[i];
      if (isExecutionUncertain(path.parent.type, path.parentKey)) {
        return true;
      }
    }
    return false;
  }
  var SYMBOL_CHECKING = Symbol();
  function _guessExecutionStatusRelativeTo(target) {
    return _guessExecutionStatusRelativeToCached(this, target, new Map);
  }
  function _guessExecutionStatusRelativeToCached(base, target, cache) {
    const funcParent = {
      this: getOuterFunction(base),
      target: getOuterFunction(target)
    };
    if (funcParent.target.node !== funcParent.this.node) {
      return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
    }
    const paths = {
      target: target.getAncestry(),
      this: base.getAncestry()
    };
    if (paths.target.includes(base))
      return "after";
    if (paths.this.includes(target))
      return "before";
    let commonPath;
    const commonIndex = {
      target: 0,
      this: 0
    };
    while (!commonPath && commonIndex.this < paths.this.length) {
      const path = paths.this[commonIndex.this];
      commonIndex.target = paths.target.indexOf(path);
      if (commonIndex.target >= 0) {
        commonPath = path;
      } else {
        commonIndex.this++;
      }
    }
    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
    }
    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }
    const divergence = {
      this: paths.this[commonIndex.this - 1],
      target: paths.target[commonIndex.target - 1]
    };
    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
      return divergence.target.key > divergence.this.key ? "before" : "after";
    }
    const keys = VISITOR_KEYS[commonPath.type];
    const keyPosition = {
      this: keys.indexOf(divergence.this.parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition.this ? "before" : "after";
  }
  function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
    if (!target.isFunctionDeclaration()) {
      if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
        return "before";
      }
      return "unknown";
    } else if (target.parentPath.isExportDeclaration()) {
      return "unknown";
    }
    const binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references)
      return "before";
    const referencePaths = binding.referencePaths;
    let allStatus;
    for (const path of referencePaths) {
      const childOfFunction = !!path.find((path2) => path2.node === target.node);
      if (childOfFunction)
        continue;
      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }
      const status = _guessExecutionStatusRelativeToCached(base, path, cache);
      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }
    return allStatus;
  }
  function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
    let nodeMap = cache.get(base.node);
    let cached;
    if (!nodeMap) {
      cache.set(base.node, nodeMap = new Map);
    } else if (cached = nodeMap.get(target.node)) {
      if (cached === SYMBOL_CHECKING) {
        return "unknown";
      }
      return cached;
    }
    nodeMap.set(target.node, SYMBOL_CHECKING);
    const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
    nodeMap.set(target.node, result);
    return result;
  }
  function resolve(dangerous, resolved) {
    return _resolve.call(this, dangerous, resolved) || this;
  }
  function _resolve(dangerous, resolved) {
    var _resolved;
    if ((_resolved = resolved) != null && _resolved.includes(this))
      return;
    resolved = resolved || [];
    resolved.push(this);
    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      } else {}
    } else if (this.isReferencedIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding)
        return;
      if (!binding.constant)
        return;
      if (binding.kind === "module")
        return;
      if (binding.path !== this) {
        const ret = binding.path.resolve(dangerous, resolved);
        if (this.find((parent) => parent.node === ret.node))
          return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      const targetKey = this.toComputedKey();
      if (!isLiteral(targetKey))
        return;
      const targetName = targetKey.value;
      const target = this.get("object").resolve(dangerous, resolved);
      if (target.isObjectExpression()) {
        const props = target.get("properties");
        for (const prop of props) {
          if (!prop.isProperty())
            continue;
          const key = prop.get("key");
          let match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match)
            return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        const elems = target.get("elements");
        const elem = elems[targetName];
        if (elem)
          return elem.resolve(dangerous, resolved);
      }
    }
  }
  function isConstantExpression() {
    if (this.isIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding)
        return false;
      return binding.constant;
    }
    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }
      if (this.isTemplateLiteral()) {
        return this.get("expressions").every((expression) => expression.isConstantExpression());
      }
      return true;
    }
    if (this.isUnaryExpression()) {
      if (this.node.operator !== "void") {
        return false;
      }
      return this.get("argument").isConstantExpression();
    }
    if (this.isBinaryExpression()) {
      const {
        operator
      } = this.node;
      return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    if (this.isMemberExpression()) {
      return !this.node.computed && this.get("object").isIdentifier({
        name: "Symbol"
      }) && !this.scope.hasBinding("Symbol", {
        noGlobals: true
      });
    }
    if (this.isCallExpression()) {
      return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
        noGlobals: true
      }) && this.get("arguments")[0].isStringLiteral();
    }
    return false;
  }
  function isInStrictMode() {
    const start = this.isProgram() ? this : this.parentPath;
    const strictParent = start.find((path) => {
      if (path.isProgram({
        sourceType: "module"
      }))
        return true;
      if (path.isClass())
        return true;
      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
        return false;
      }
      let body;
      if (path.isFunction()) {
        body = path.node.body;
      } else if (path.isProgram()) {
        body = path.node;
      } else {
        return false;
      }
      for (const directive of body.directives) {
        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._getKey = _getKey;
  exports._getPattern = _getPattern;
  exports.get = get;
  exports.getAllNextSiblings = getAllNextSiblings;
  exports.getAllPrevSiblings = getAllPrevSiblings;
  exports.getAssignmentIdentifiers = getAssignmentIdentifiers;
  exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
  exports.getBindingIdentifiers = getBindingIdentifiers;
  exports.getCompletionRecords = getCompletionRecords;
  exports.getNextSibling = getNextSibling;
  exports.getOpposite = getOpposite;
  exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  exports.getPrevSibling = getPrevSibling;
  exports.getSibling = getSibling;
  var _index = require_path();
  var _t = require_lib5();
  var {
    getAssignmentIdentifiers: _getAssignmentIdentifiers,
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    numericLiteral,
    unaryExpression
  } = _t;
  var NORMAL_COMPLETION = 0;
  var BREAK_COMPLETION = 1;
  function NormalCompletion(path) {
    return {
      type: NORMAL_COMPLETION,
      path
    };
  }
  function BreakCompletion(path) {
    return {
      type: BREAK_COMPLETION,
      path
    };
  }
  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
    return null;
  }
  function addCompletionRecords(path, records, context) {
    if (path) {
      records.push(..._getCompletionRecords(path, context));
    }
    return records;
  }
  function completionRecordForSwitch(cases, records, context) {
    let lastNormalCompletions = [];
    for (let i = 0;i < cases.length; i++) {
      const casePath = cases[i];
      const caseCompletions = _getCompletionRecords(casePath, context);
      const normalCompletions = [];
      const breakCompletions = [];
      for (const c of caseCompletions) {
        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }
        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }
      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }
      records.push(...breakCompletions);
    }
    records.push(...lastNormalCompletions);
    return records;
  }
  function normalCompletionToBreak(completions) {
    completions.forEach((c) => {
      c.type = BREAK_COMPLETION;
    });
  }
  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c) => {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  }
  function getStatementListCompletion(paths, context) {
    const completions = [];
    if (context.canHaveBreak) {
      let lastNormalCompletions = [];
      for (let i = 0;i < paths.length; i++) {
        const path = paths[i];
        const newContext = Object.assign({}, context, {
          inCaseClause: false
        });
        if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }
        const statementCompletions = _getCompletionRecords(path, newContext);
        if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
            label: null
          }))) {
            normalCompletionToBreak(lastNormalCompletions);
            completions.push(...lastNormalCompletions);
            if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
              completions.push(...statementCompletions);
              if (!context.shouldPreserveBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            if (!context.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            }
          } else {
            completions.push(...statementCompletions);
            if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }
          break;
        }
        if (i === paths.length - 1) {
          completions.push(...statementCompletions);
        } else {
          lastNormalCompletions = [];
          for (let i2 = 0;i2 < statementCompletions.length; i2++) {
            const c = statementCompletions[i2];
            if (c.type === BREAK_COMPLETION) {
              completions.push(c);
            }
            if (c.type === NORMAL_COMPLETION) {
              lastNormalCompletions.push(c);
            }
          }
        }
      }
    } else if (paths.length) {
      for (let i = paths.length - 1;i >= 0; i--) {
        const pathCompletions = _getCompletionRecords(paths[i], context);
        if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
          completions.push(...pathCompletions);
          break;
        }
      }
    }
    return completions;
  }
  function _getCompletionRecords(path, context) {
    let records = [];
    if (path.isIfStatement()) {
      records = addCompletionRecords(path.get("consequent"), records, context);
      records = addCompletionRecords(path.get("alternate"), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
      return addCompletionRecords(path.get("body"), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
      return getStatementListCompletion(path.get("body"), context);
    } else if (path.isFunction()) {
      return _getCompletionRecords(path.get("body"), context);
    } else if (path.isTryStatement()) {
      records = addCompletionRecords(path.get("block"), records, context);
      records = addCompletionRecords(path.get("handler"), records, context);
    } else if (path.isCatchClause()) {
      return addCompletionRecords(path.get("body"), records, context);
    } else if (path.isSwitchStatement()) {
      return completionRecordForSwitch(path.get("cases"), records, context);
    } else if (path.isSwitchCase()) {
      return getStatementListCompletion(path.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true,
        shouldPreserveBreak: context.shouldPreserveBreak
      });
    } else if (path.isBreakStatement()) {
      records.push(BreakCompletion(path));
    } else {
      records.push(NormalCompletion(path));
    }
    return records;
  }
  function getCompletionRecords(shouldPreserveBreak = false) {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false,
      shouldPreserveBreak
    });
    return records.map((r) => r.path);
  }
  function getSibling(key) {
    return _index.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }
    return siblings;
  }
  function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }
    return siblings;
  }
  function get(key, context = true) {
    if (context === true)
      context = this.context;
    const parts = key.split(".");
    if (parts.length === 1) {
      return _getKey.call(this, key, context);
    } else {
      return _getPattern.call(this, parts, context);
    }
  }
  function _getKey(key, context) {
    const node = this.node;
    const container = node[key];
    if (Array.isArray(container)) {
      return container.map((_, i) => {
        return _index.default.get({
          listKey: key,
          parentPath: this,
          parent: node,
          container,
          key: i
        }).setContext(context);
      });
    } else {
      return _index.default.get({
        parentPath: this,
        parent: node,
        container: node,
        key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    let path = this;
    for (const part of parts) {
      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }
    return path;
  }
  function getAssignmentIdentifiers() {
    return _getAssignmentIdentifiers(this.node);
  }
  function getBindingIdentifiers(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path = this;
    const search = [path];
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id)
        continue;
      if (!id.node)
        continue;
      const keys = _getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");
        if (declaration.isDeclaration()) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);
          if (Array.isArray(child)) {
            search.push(...child);
          } else if (child.node) {
            search.push(child);
          }
        }
      }
    }
    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addComment = addComment;
  exports.addComments = addComments;
  exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
  var _t = require_lib5();
  var {
    addComment: _addComment,
    addComments: _addComments
  } = _t;
  function shareCommentsWithSiblings() {
    if (typeof this.key === "string")
      return;
    const node = this.node;
    if (!node)
      return;
    const trailing = node.trailingComments;
    const leading = node.leadingComments;
    if (!trailing && !leading)
      return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    if (hasPrev) {
      if (leading) {
        prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
      }
      if (trailing && !hasNext)
        prev.addComments("trailing", trailing);
    }
    if (hasNext) {
      if (trailing) {
        next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
      }
      if (leading && !hasPrev)
        next.addComments("leading", leading);
    }
  }
  function removeIfExisting(list, toRemove) {
    if (!(toRemove != null && toRemove.length))
      return list;
    const set = new Set(toRemove);
    return list.filter((el) => {
      return !set.has(el);
    });
  }
  function addComment(type, content, line) {
    _addComment(this.node, type, content, line);
  }
  function addComments(type, comments) {
    _addComments(this.node, type, comments);
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = undefined;
  var virtualTypes = require_virtual_types();
  var _debug = require_src();
  var _index = require_lib9();
  var _index2 = require_scope();
  var _t = require_lib5();
  var t = _t;
  var cache = require_cache();
  var _generator = require_lib6();
  var NodePath_ancestry = require_ancestry();
  var NodePath_inference = require_inference();
  var NodePath_replacement = require_replacement();
  var NodePath_evaluation = require_evaluation();
  var NodePath_conversion = require_conversion();
  var NodePath_introspection = require_introspection();
  var _context = require_context2();
  var NodePath_context = _context;
  var NodePath_removal = require_removal();
  var NodePath_modification = require_modification();
  var NodePath_family = require_family();
  var NodePath_comments = require_comments();
  var NodePath_virtual_types_validator = require_virtual_types_validator();
  var {
    validate
  } = _t;
  var debug = _debug("babel");
  var REMOVED = exports.REMOVED = 1 << 0;
  var SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;
  var SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;
  var NodePath_Final = exports.default = class NodePath {
    constructor(hub, parent) {
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this._store = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(v) {
      if (v)
        this._traverseFlags |= 1;
      else
        this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(v) {
      if (v)
        this._traverseFlags |= 2;
      else
        this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(v) {
      if (v)
        this._traverseFlags |= 4;
      else
        this._traverseFlags &= -5;
    }
    static get({
      hub,
      parentPath,
      parent,
      container,
      listKey,
      key
    }) {
      if (!hub && parentPath) {
        hub = parentPath.hub;
      }
      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }
      const targetNode = container[key];
      const paths = cache.getOrCreateCachedPaths(parent, parentPath);
      let path = paths.get(targetNode);
      if (!path) {
        path = new NodePath(hub, parent);
        if (targetNode)
          paths.set(targetNode, path);
      }
      _context.setup.call(path, parentPath, container, listKey, key);
      return path;
    }
    getScope(scope) {
      return this.isScope() ? new _index2.default(this) : scope;
    }
    setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }
      return this.data[key] = val;
    }
    getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }
      let val = this.data[key];
      if (val === undefined && def !== undefined)
        val = this.data[key] = def;
      return val;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(msg, Error2 = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error2);
    }
    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
    set(key, node) {
      validate(this.node, key, node);
      this.node[key] = node;
    }
    getPathLocation() {
      const parts = [];
      let path = this;
      do {
        let key = path.key;
        if (path.inList)
          key = `${path.listKey}[${key}]`;
        parts.unshift(key);
      } while (path = path.parentPath);
      return parts.join(".");
    }
    debug(message) {
      if (!debug.enabled)
        return;
      debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    toString() {
      return (0, _generator.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  };
  var methods = {
    findParent: NodePath_ancestry.findParent,
    find: NodePath_ancestry.find,
    getFunctionParent: NodePath_ancestry.getFunctionParent,
    getStatementParent: NodePath_ancestry.getStatementParent,
    getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
    getAncestry: NodePath_ancestry.getAncestry,
    isAncestor: NodePath_ancestry.isAncestor,
    isDescendant: NodePath_ancestry.isDescendant,
    inType: NodePath_ancestry.inType,
    getTypeAnnotation: NodePath_inference.getTypeAnnotation,
    isBaseType: NodePath_inference.isBaseType,
    couldBeBaseType: NodePath_inference.couldBeBaseType,
    baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
    isGenericType: NodePath_inference.isGenericType,
    replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
    replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
    replaceWith: NodePath_replacement.replaceWith,
    replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
    replaceInline: NodePath_replacement.replaceInline,
    evaluateTruthy: NodePath_evaluation.evaluateTruthy,
    evaluate: NodePath_evaluation.evaluate,
    toComputedKey: NodePath_conversion.toComputedKey,
    ensureBlock: NodePath_conversion.ensureBlock,
    unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
    arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
    splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
    ensureFunctionName: NodePath_conversion.ensureFunctionName,
    matchesPattern: NodePath_introspection.matchesPattern,
    isStatic: NodePath_introspection.isStatic,
    isNodeType: NodePath_introspection.isNodeType,
    canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: NodePath_introspection.isCompletionRecord,
    isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
    referencesImport: NodePath_introspection.referencesImport,
    getSource: NodePath_introspection.getSource,
    willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
    resolve: NodePath_introspection.resolve,
    isConstantExpression: NodePath_introspection.isConstantExpression,
    isInStrictMode: NodePath_introspection.isInStrictMode,
    isDenylisted: NodePath_context.isDenylisted,
    visit: NodePath_context.visit,
    skip: NodePath_context.skip,
    skipKey: NodePath_context.skipKey,
    stop: NodePath_context.stop,
    setContext: NodePath_context.setContext,
    requeue: NodePath_context.requeue,
    requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
    remove: NodePath_removal.remove,
    insertBefore: NodePath_modification.insertBefore,
    insertAfter: NodePath_modification.insertAfter,
    unshiftContainer: NodePath_modification.unshiftContainer,
    pushContainer: NodePath_modification.pushContainer,
    getOpposite: NodePath_family.getOpposite,
    getCompletionRecords: NodePath_family.getCompletionRecords,
    getSibling: NodePath_family.getSibling,
    getPrevSibling: NodePath_family.getPrevSibling,
    getNextSibling: NodePath_family.getNextSibling,
    getAllNextSiblings: NodePath_family.getAllNextSiblings,
    getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
    get: NodePath_family.get,
    getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
    getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
    getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
    addComment: NodePath_comments.addComment,
    addComments: NodePath_comments.addComments
  };
  Object.assign(NodePath_Final.prototype, methods);
  {
    NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
    Object.assign(NodePath_Final.prototype, {
      has: NodePath_introspection[String("has")],
      is: NodePath_introspection[String("is")],
      isnt: NodePath_introspection[String("isnt")],
      equals: NodePath_introspection[String("equals")],
      hoist: NodePath_modification[String("hoist")],
      updateSiblingKeys: NodePath_modification.updateSiblingKeys,
      call: NodePath_context.call,
      isBlacklisted: NodePath_context[String("isBlacklisted")],
      setScope: NodePath_context.setScope,
      resync: NodePath_context.resync,
      popContext: NodePath_context.popContext,
      pushContext: NodePath_context.pushContext,
      setup: NodePath_context.setup,
      setKey: NodePath_context.setKey
    });
  }
  {
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    Object.assign(NodePath_Final.prototype, {
      _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
      _replaceWith: NodePath_replacement._replaceWith,
      _resolve: NodePath_introspection._resolve,
      _call: NodePath_context._call,
      _resyncParent: NodePath_context._resyncParent,
      _resyncKey: NodePath_context._resyncKey,
      _resyncList: NodePath_context._resyncList,
      _resyncRemoved: NodePath_context._resyncRemoved,
      _getQueueContexts: NodePath_context._getQueueContexts,
      _removeFromScope: NodePath_removal._removeFromScope,
      _callRemovalHooks: NodePath_removal._callRemovalHooks,
      _remove: NodePath_removal._remove,
      _markRemoved: NodePath_removal._markRemoved,
      _assertUnremoved: NodePath_removal._assertUnremoved,
      _containerInsert: NodePath_modification._containerInsert,
      _containerInsertBefore: NodePath_modification._containerInsertBefore,
      _containerInsertAfter: NodePath_modification._containerInsertAfter,
      _verifyNodeList: NodePath_modification._verifyNodeList,
      _getKey: NodePath_family._getKey,
      _getPattern: NodePath_family._getPattern
    });
  }
  for (const type of t.TYPES) {
    const typeKey = `is${type}`;
    const fn = t[typeKey];
    NodePath_Final.prototype[typeKey] = function(opts) {
      return fn(this.node, opts);
    };
    NodePath_Final.prototype[`assert${type}`] = function(opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError(`Expected node path of type ${type}`);
      }
    };
  }
  Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
  for (const type of Object.keys(virtualTypes)) {
    if (type[0] === "_")
      continue;
    if (!t.TYPES.includes(type))
      t.TYPES.push(type);
  }
});

// ../../../../node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_path();
  var _t = require_lib5();
  var _context = require_context2();
  var {
    VISITOR_KEYS
  } = _t;

  class TraversalContext {
    constructor(scope, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }
    shouldVisit(node) {
      const opts = this.opts;
      if (opts.enter || opts.exit)
        return true;
      if (opts[node.type])
        return true;
      const keys = VISITOR_KEYS[node.type];
      if (!(keys != null && keys.length))
        return false;
      for (const key of keys) {
        if (node[key]) {
          return true;
        }
      }
      return false;
    }
    create(node, container, key, listKey) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: node,
        container,
        key,
        listKey
      });
    }
    maybeQueue(path, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    }
    visitMultiple(container, parent, listKey) {
      if (container.length === 0)
        return false;
      const queue = [];
      for (let key = 0;key < container.length; key++) {
        const node = container[key];
        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }
      return this.visitQueue(queue);
    }
    visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    }
    visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      const visited = new WeakSet;
      let stop = false;
      let visitIndex = 0;
      for (;visitIndex < queue.length; ) {
        const path = queue[visitIndex];
        visitIndex++;
        _context.resync.call(path);
        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
          _context.pushContext.call(path, this);
        }
        if (path.key === null)
          continue;
        const {
          node
        } = path;
        if (visited.has(node))
          continue;
        if (node)
          visited.add(node);
        if (path.visit()) {
          stop = true;
          break;
        }
        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop)
            break;
        }
      }
      for (let i = 0;i < visitIndex; i++) {
        _context.popContext.call(queue[i]);
      }
      this.queue = null;
      return stop;
    }
    visit(node, key) {
      const nodes = node[key];
      if (!nodes)
        return false;
      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    }
  }
  exports.default = TraversalContext;
});

// ../../../../node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.traverseNode = traverseNode;
  var _context = require_context();
  var _index = require_path();
  var _t = require_lib5();
  var _context2 = require_context2();
  var {
    VISITOR_KEYS
  } = _t;
  function traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {
    const keys = VISITOR_KEYS[node.type];
    if (!keys)
      return false;
    const context = new _context.default(scope, opts, state, path);
    if (visitSelf) {
      if (skipKeys != null && skipKeys[path.parentKey])
        return false;
      return context.visitQueue([path]);
    }
    for (const key of keys) {
      if (skipKeys != null && skipKeys[key])
        continue;
      if (context.visit(node, key)) {
        return true;
      }
    }
    return false;
  }
});

// ../../../../node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._call = _call;
  exports._getQueueContexts = _getQueueContexts;
  exports._resyncKey = _resyncKey;
  exports._resyncList = _resyncList;
  exports._resyncParent = _resyncParent;
  exports._resyncRemoved = _resyncRemoved;
  exports.call = call;
  exports.isDenylisted = isDenylisted;
  exports.popContext = popContext;
  exports.pushContext = pushContext;
  exports.requeue = requeue;
  exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
  exports.resync = resync;
  exports.setContext = setContext;
  exports.setKey = setKey;
  exports.setScope = setScope;
  exports.setup = setup;
  exports.skip = skip;
  exports.skipKey = skipKey;
  exports.stop = stop;
  exports.visit = visit;
  var _traverseNode = require_traverse_node();
  var _index = require_path();
  var _removal = require_removal();
  var t = require_lib5();
  function call(key) {
    const opts = this.opts;
    this.debug(key);
    if (this.node) {
      if (_call.call(this, opts[key]))
        return true;
    }
    if (this.node) {
      var _opts$this$node$type;
      return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? undefined : _opts$this$node$type[key]);
    }
    return false;
  }
  function _call(fns) {
    if (!fns)
      return false;
    for (const fn of fns) {
      if (!fn)
        continue;
      const node = this.node;
      if (!node)
        return true;
      const ret = fn.call(this.state, this, this.state);
      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
      }
      if (ret) {
        throw new Error(`Unexpected return value from visitor method ${fn}`);
      }
      if (this.node !== node)
        return true;
      if (this._traverseFlags > 0)
        return true;
    }
    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;
    const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist == null ? undefined : denylist.includes(this.node.type);
  }
  {
    exports.isBlacklisted = isDenylisted;
  }
  function restoreContext(path, context) {
    if (path.context !== context) {
      path.context = context;
      path.state = context.state;
      path.opts = context.opts;
    }
  }
  function visit() {
    var _this$opts$shouldSkip, _this$opts;
    if (!this.node) {
      return false;
    }
    if (this.isDenylisted()) {
      return false;
    }
    if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
      return false;
    }
    const currentContext = this.context;
    if (this.shouldSkip || call.call(this, "enter")) {
      this.debug("Skip...");
      return this.shouldStop;
    }
    restoreContext(this, currentContext);
    this.debug("Recursing into...");
    this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, "exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }
    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
  }
  function setScope() {
    var _this$opts2, _this$scope;
    if ((_this$opts2 = this.opts) != null && _this$opts2.noScope)
      return;
    let path = this.parentPath;
    if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
      path = path.parentPath;
    }
    let target;
    while (path && !target) {
      var _path$opts;
      if ((_path$opts = path.opts) != null && _path$opts.noScope)
        return;
      target = path.scope;
      path = path.parentPath;
    }
    this.scope = this.getScope(target);
    (_this$scope = this.scope) == null || _this$scope.init();
  }
  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }
    this._traverseFlags = 0;
    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }
    setScope.call(this);
    return this;
  }
  function resync() {
    if (this.removed)
      return;
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container)
      return;
    if (this.node === this.container[this.key]) {
      return;
    }
    if (Array.isArray(this.container)) {
      for (let i = 0;i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          setKey.call(this, i);
          return;
        }
      }
    } else {
      for (const key of Object.keys(this.container)) {
        if (this.container[key] === this.node) {
          setKey.call(this, key);
          return;
        }
      }
    }
    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList)
      return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer)
      return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      _removal._markRemoved.call(this);
    }
  }
  function popContext() {
    this.contexts.pop();
    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
  }
  function setKey(key) {
    var _this$node;
    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? undefined : _this$node.type;
  }
  function requeue(pathToQueue = this) {
    if (pathToQueue.removed)
      return;
    const contexts = this.contexts;
    for (const context of contexts) {
      context.maybeQueue(pathToQueue);
    }
  }
  function requeueComputedKeyAndDecorators() {
    const {
      context,
      node
    } = this;
    if (!t.isPrivate(node) && node.computed) {
      context.maybeQueue(this.get("key"));
    }
    if (node.decorators) {
      for (const decorator of this.get("decorators")) {
        context.maybeQueue(decorator);
      }
    }
  }
  function _getQueueContexts() {
    let path = this;
    let contexts = this.contexts;
    while (!contexts.length) {
      path = path.parentPath;
      if (!path)
        break;
      contexts = path.contexts;
    }
    return contexts;
  }
});

// ../../../../node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  class Hub {
    getCode() {}
    getScope() {}
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(node, msg, Error2 = TypeError) {
      return new Error2(msg);
    }
  }
  exports.default = Hub;
});

// ../../../../node_modules/@babel/traverse/lib/index.js
var require_lib9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "Hub", {
    enumerable: true,
    get: function() {
      return _hub.default;
    }
  });
  Object.defineProperty(exports, "NodePath", {
    enumerable: true,
    get: function() {
      return _index.default;
    }
  });
  Object.defineProperty(exports, "Scope", {
    enumerable: true,
    get: function() {
      return _index2.default;
    }
  });
  exports.visitors = exports.default = undefined;
  require_context2();
  var visitors = require_visitors();
  exports.visitors = visitors;
  var _t = require_lib5();
  var cache = require_cache();
  var _traverseNode = require_traverse_node();
  var _index = require_path();
  var _index2 = require_scope();
  var _hub = require_hub();
  var {
    VISITOR_KEYS,
    removeProperties,
    traverseFast
  } = _t;
  function traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {
    if (!parent)
      return;
    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
      }
    }
    if (!parentPath && visitSelf) {
      throw new Error("visitSelf can only be used when providing a NodePath.");
    }
    if (!VISITOR_KEYS[parent.type]) {
      return;
    }
    visitors.explode(opts);
    (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
  }
  var _default = exports.default = traverse;
  traverse.visitors = visitors;
  traverse.verify = visitors.verify;
  traverse.explode = visitors.explode;
  traverse.cheap = function(node, enter) {
    traverseFast(node, enter);
    return;
  };
  traverse.node = function(node, opts, scope, state, path, skipKeys) {
    (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
  };
  traverse.clearNode = function(node, opts) {
    removeProperties(node, opts);
  };
  traverse.removeProperties = function(tree, opts) {
    traverseFast(tree, traverse.clearNode, opts);
    return tree;
  };
  traverse.hasType = function(tree, type, denylistTypes) {
    if (denylistTypes != null && denylistTypes.includes(tree.type))
      return false;
    if (tree.type === type)
      return true;
    return traverseFast(tree, function(node) {
      if (denylistTypes != null && denylistTypes.includes(node.type)) {
        return traverseFast.skip;
      }
      if (node.type === type) {
        return traverseFast.stop;
      }
    });
  };
  traverse.cache = cache;
});

// ../../../../node_modules/sqlstring/lib/SqlString.js
var require_SqlString = __commonJS((exports) => {
  var SqlString = exports;
  var ID_GLOBAL_REGEXP = /`/g;
  var QUAL_GLOBAL_REGEXP = /\./g;
  var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
  var CHARS_ESCAPE_MAP = {
    "\x00": "\\0",
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\x1A": "\\Z",
    '"': "\\\"",
    "'": "\\'",
    "\\": "\\\\"
  };
  SqlString.escapeId = function escapeId(val, forbidQualified) {
    if (Array.isArray(val)) {
      var sql2 = "";
      for (var i = 0;i < val.length; i++) {
        sql2 += (i === 0 ? "" : ", ") + SqlString.escapeId(val[i], forbidQualified);
      }
      return sql2;
    } else if (forbidQualified) {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
    } else {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
    }
  };
  SqlString.escape = function escape(val, stringifyObjects, timeZone) {
    if (val === undefined || val === null) {
      return "NULL";
    }
    switch (typeof val) {
      case "boolean":
        return val ? "true" : "false";
      case "number":
        return val + "";
      case "object":
        if (Object.prototype.toString.call(val) === "[object Date]") {
          return SqlString.dateToString(val, timeZone || "local");
        } else if (Array.isArray(val)) {
          return SqlString.arrayToList(val, timeZone);
        } else if (Buffer.isBuffer(val)) {
          return SqlString.bufferToString(val);
        } else if (typeof val.toSqlString === "function") {
          return String(val.toSqlString());
        } else if (stringifyObjects) {
          return escapeString(val.toString());
        } else {
          return SqlString.objectToValues(val, timeZone);
        }
      default:
        return escapeString(val);
    }
  };
  SqlString.arrayToList = function arrayToList(array, timeZone) {
    var sql2 = "";
    for (var i = 0;i < array.length; i++) {
      var val = array[i];
      if (Array.isArray(val)) {
        sql2 += (i === 0 ? "" : ", ") + "(" + SqlString.arrayToList(val, timeZone) + ")";
      } else {
        sql2 += (i === 0 ? "" : ", ") + SqlString.escape(val, true, timeZone);
      }
    }
    return sql2;
  };
  SqlString.format = function format(sql2, values, stringifyObjects, timeZone) {
    if (values == null) {
      return sql2;
    }
    if (!Array.isArray(values)) {
      values = [values];
    }
    var chunkIndex = 0;
    var placeholdersRegex = /\?+/g;
    var result = "";
    var valuesIndex = 0;
    var match;
    while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql2))) {
      var len = match[0].length;
      if (len > 2) {
        continue;
      }
      var value = len === 2 ? SqlString.escapeId(values[valuesIndex]) : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);
      result += sql2.slice(chunkIndex, match.index) + value;
      chunkIndex = placeholdersRegex.lastIndex;
      valuesIndex++;
    }
    if (chunkIndex === 0) {
      return sql2;
    }
    if (chunkIndex < sql2.length) {
      return result + sql2.slice(chunkIndex);
    }
    return result;
  };
  SqlString.dateToString = function dateToString(date, timeZone) {
    var dt = new Date(date);
    if (isNaN(dt.getTime())) {
      return "NULL";
    }
    var year;
    var month;
    var day;
    var hour;
    var minute;
    var second;
    var millisecond;
    if (timeZone === "local") {
      year = dt.getFullYear();
      month = dt.getMonth() + 1;
      day = dt.getDate();
      hour = dt.getHours();
      minute = dt.getMinutes();
      second = dt.getSeconds();
      millisecond = dt.getMilliseconds();
    } else {
      var tz = convertTimezone(timeZone);
      if (tz !== false && tz !== 0) {
        dt.setTime(dt.getTime() + tz * 60000);
      }
      year = dt.getUTCFullYear();
      month = dt.getUTCMonth() + 1;
      day = dt.getUTCDate();
      hour = dt.getUTCHours();
      minute = dt.getUTCMinutes();
      second = dt.getUTCSeconds();
      millisecond = dt.getUTCMilliseconds();
    }
    var str = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    return escapeString(str);
  };
  SqlString.bufferToString = function bufferToString(buffer) {
    return "X" + escapeString(buffer.toString("hex"));
  };
  SqlString.objectToValues = function objectToValues(object, timeZone) {
    var sql2 = "";
    for (var key in object) {
      var val = object[key];
      if (typeof val === "function") {
        continue;
      }
      sql2 += (sql2.length === 0 ? "" : ", ") + SqlString.escapeId(key) + " = " + SqlString.escape(val, true, timeZone);
    }
    return sql2;
  };
  SqlString.raw = function raw(sql2) {
    if (typeof sql2 !== "string") {
      throw new TypeError("argument sql must be a string");
    }
    return {
      toSqlString: function toSqlString() {
        return sql2;
      }
    };
  };
  function escapeString(val) {
    var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    var escapedVal = "";
    var match;
    while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
      escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
      chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + val + "'";
    }
    if (chunkIndex < val.length) {
      return "'" + escapedVal + val.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
  function zeroPad(number, length) {
    number = number.toString();
    while (number.length < length) {
      number = "0" + number;
    }
    return number;
  }
  function convertTimezone(tz) {
    if (tz === "Z") {
      return 0;
    }
    var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m) {
      return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
    }
    return false;
  }
});

// ../../../../node_modules/mysql2/lib/constants/client.js
var require_client = __commonJS((exports) => {
  exports.LONG_PASSWORD = 1;
  exports.FOUND_ROWS = 2;
  exports.LONG_FLAG = 4;
  exports.CONNECT_WITH_DB = 8;
  exports.NO_SCHEMA = 16;
  exports.COMPRESS = 32;
  exports.ODBC = 64;
  exports.LOCAL_FILES = 128;
  exports.IGNORE_SPACE = 256;
  exports.PROTOCOL_41 = 512;
  exports.INTERACTIVE = 1024;
  exports.SSL = 2048;
  exports.IGNORE_SIGPIPE = 4096;
  exports.TRANSACTIONS = 8192;
  exports.RESERVED = 16384;
  exports.SECURE_CONNECTION = 32768;
  exports.MULTI_STATEMENTS = 65536;
  exports.MULTI_RESULTS = 131072;
  exports.PS_MULTI_RESULTS = 262144;
  exports.PLUGIN_AUTH = 524288;
  exports.CONNECT_ATTRS = 1048576;
  exports.PLUGIN_AUTH_LENENC_CLIENT_DATA = 2097152;
  exports.CAN_HANDLE_EXPIRED_PASSWORDS = 4194304;
  exports.SESSION_TRACK = 8388608;
  exports.DEPRECATE_EOF = 16777216;
  exports.SSL_VERIFY_SERVER_CERT = 1073741824;
  exports.REMEMBER_OPTIONS = 2147483648;
  exports.MULTI_FACTOR_AUTHENTICATION = 268435456;
});

// ../../../../node_modules/mysql2/lib/constants/charsets.js
var require_charsets = __commonJS((exports) => {
  exports.BIG5_CHINESE_CI = 1;
  exports.LATIN2_CZECH_CS = 2;
  exports.DEC8_SWEDISH_CI = 3;
  exports.CP850_GENERAL_CI = 4;
  exports.LATIN1_GERMAN1_CI = 5;
  exports.HP8_ENGLISH_CI = 6;
  exports.KOI8R_GENERAL_CI = 7;
  exports.LATIN1_SWEDISH_CI = 8;
  exports.LATIN2_GENERAL_CI = 9;
  exports.SWE7_SWEDISH_CI = 10;
  exports.ASCII_GENERAL_CI = 11;
  exports.UJIS_JAPANESE_CI = 12;
  exports.SJIS_JAPANESE_CI = 13;
  exports.CP1251_BULGARIAN_CI = 14;
  exports.LATIN1_DANISH_CI = 15;
  exports.HEBREW_GENERAL_CI = 16;
  exports.TIS620_THAI_CI = 18;
  exports.EUCKR_KOREAN_CI = 19;
  exports.LATIN7_ESTONIAN_CS = 20;
  exports.LATIN2_HUNGARIAN_CI = 21;
  exports.KOI8U_GENERAL_CI = 22;
  exports.CP1251_UKRAINIAN_CI = 23;
  exports.GB2312_CHINESE_CI = 24;
  exports.GREEK_GENERAL_CI = 25;
  exports.CP1250_GENERAL_CI = 26;
  exports.LATIN2_CROATIAN_CI = 27;
  exports.GBK_CHINESE_CI = 28;
  exports.CP1257_LITHUANIAN_CI = 29;
  exports.LATIN5_TURKISH_CI = 30;
  exports.LATIN1_GERMAN2_CI = 31;
  exports.ARMSCII8_GENERAL_CI = 32;
  exports.UTF8_GENERAL_CI = 33;
  exports.CP1250_CZECH_CS = 34;
  exports.UCS2_GENERAL_CI = 35;
  exports.CP866_GENERAL_CI = 36;
  exports.KEYBCS2_GENERAL_CI = 37;
  exports.MACCE_GENERAL_CI = 38;
  exports.MACROMAN_GENERAL_CI = 39;
  exports.CP852_GENERAL_CI = 40;
  exports.LATIN7_GENERAL_CI = 41;
  exports.LATIN7_GENERAL_CS = 42;
  exports.MACCE_BIN = 43;
  exports.CP1250_CROATIAN_CI = 44;
  exports.UTF8MB4_GENERAL_CI = 45;
  exports.UTF8MB4_BIN = 46;
  exports.LATIN1_BIN = 47;
  exports.LATIN1_GENERAL_CI = 48;
  exports.LATIN1_GENERAL_CS = 49;
  exports.CP1251_BIN = 50;
  exports.CP1251_GENERAL_CI = 51;
  exports.CP1251_GENERAL_CS = 52;
  exports.MACROMAN_BIN = 53;
  exports.UTF16_GENERAL_CI = 54;
  exports.UTF16_BIN = 55;
  exports.UTF16LE_GENERAL_CI = 56;
  exports.CP1256_GENERAL_CI = 57;
  exports.CP1257_BIN = 58;
  exports.CP1257_GENERAL_CI = 59;
  exports.UTF32_GENERAL_CI = 60;
  exports.UTF32_BIN = 61;
  exports.UTF16LE_BIN = 62;
  exports.BINARY = 63;
  exports.ARMSCII8_BIN = 64;
  exports.ASCII_BIN = 65;
  exports.CP1250_BIN = 66;
  exports.CP1256_BIN = 67;
  exports.CP866_BIN = 68;
  exports.DEC8_BIN = 69;
  exports.GREEK_BIN = 70;
  exports.HEBREW_BIN = 71;
  exports.HP8_BIN = 72;
  exports.KEYBCS2_BIN = 73;
  exports.KOI8R_BIN = 74;
  exports.KOI8U_BIN = 75;
  exports.UTF8_TOLOWER_CI = 76;
  exports.LATIN2_BIN = 77;
  exports.LATIN5_BIN = 78;
  exports.LATIN7_BIN = 79;
  exports.CP850_BIN = 80;
  exports.CP852_BIN = 81;
  exports.SWE7_BIN = 82;
  exports.UTF8_BIN = 83;
  exports.BIG5_BIN = 84;
  exports.EUCKR_BIN = 85;
  exports.GB2312_BIN = 86;
  exports.GBK_BIN = 87;
  exports.SJIS_BIN = 88;
  exports.TIS620_BIN = 89;
  exports.UCS2_BIN = 90;
  exports.UJIS_BIN = 91;
  exports.GEOSTD8_GENERAL_CI = 92;
  exports.GEOSTD8_BIN = 93;
  exports.LATIN1_SPANISH_CI = 94;
  exports.CP932_JAPANESE_CI = 95;
  exports.CP932_BIN = 96;
  exports.EUCJPMS_JAPANESE_CI = 97;
  exports.EUCJPMS_BIN = 98;
  exports.CP1250_POLISH_CI = 99;
  exports.UTF16_UNICODE_CI = 101;
  exports.UTF16_ICELANDIC_CI = 102;
  exports.UTF16_LATVIAN_CI = 103;
  exports.UTF16_ROMANIAN_CI = 104;
  exports.UTF16_SLOVENIAN_CI = 105;
  exports.UTF16_POLISH_CI = 106;
  exports.UTF16_ESTONIAN_CI = 107;
  exports.UTF16_SPANISH_CI = 108;
  exports.UTF16_SWEDISH_CI = 109;
  exports.UTF16_TURKISH_CI = 110;
  exports.UTF16_CZECH_CI = 111;
  exports.UTF16_DANISH_CI = 112;
  exports.UTF16_LITHUANIAN_CI = 113;
  exports.UTF16_SLOVAK_CI = 114;
  exports.UTF16_SPANISH2_CI = 115;
  exports.UTF16_ROMAN_CI = 116;
  exports.UTF16_PERSIAN_CI = 117;
  exports.UTF16_ESPERANTO_CI = 118;
  exports.UTF16_HUNGARIAN_CI = 119;
  exports.UTF16_SINHALA_CI = 120;
  exports.UTF16_GERMAN2_CI = 121;
  exports.UTF16_CROATIAN_CI = 122;
  exports.UTF16_UNICODE_520_CI = 123;
  exports.UTF16_VIETNAMESE_CI = 124;
  exports.UCS2_UNICODE_CI = 128;
  exports.UCS2_ICELANDIC_CI = 129;
  exports.UCS2_LATVIAN_CI = 130;
  exports.UCS2_ROMANIAN_CI = 131;
  exports.UCS2_SLOVENIAN_CI = 132;
  exports.UCS2_POLISH_CI = 133;
  exports.UCS2_ESTONIAN_CI = 134;
  exports.UCS2_SPANISH_CI = 135;
  exports.UCS2_SWEDISH_CI = 136;
  exports.UCS2_TURKISH_CI = 137;
  exports.UCS2_CZECH_CI = 138;
  exports.UCS2_DANISH_CI = 139;
  exports.UCS2_LITHUANIAN_CI = 140;
  exports.UCS2_SLOVAK_CI = 141;
  exports.UCS2_SPANISH2_CI = 142;
  exports.UCS2_ROMAN_CI = 143;
  exports.UCS2_PERSIAN_CI = 144;
  exports.UCS2_ESPERANTO_CI = 145;
  exports.UCS2_HUNGARIAN_CI = 146;
  exports.UCS2_SINHALA_CI = 147;
  exports.UCS2_GERMAN2_CI = 148;
  exports.UCS2_CROATIAN_CI = 149;
  exports.UCS2_UNICODE_520_CI = 150;
  exports.UCS2_VIETNAMESE_CI = 151;
  exports.UCS2_GENERAL_MYSQL500_CI = 159;
  exports.UTF32_UNICODE_CI = 160;
  exports.UTF32_ICELANDIC_CI = 161;
  exports.UTF32_LATVIAN_CI = 162;
  exports.UTF32_ROMANIAN_CI = 163;
  exports.UTF32_SLOVENIAN_CI = 164;
  exports.UTF32_POLISH_CI = 165;
  exports.UTF32_ESTONIAN_CI = 166;
  exports.UTF32_SPANISH_CI = 167;
  exports.UTF32_SWEDISH_CI = 168;
  exports.UTF32_TURKISH_CI = 169;
  exports.UTF32_CZECH_CI = 170;
  exports.UTF32_DANISH_CI = 171;
  exports.UTF32_LITHUANIAN_CI = 172;
  exports.UTF32_SLOVAK_CI = 173;
  exports.UTF32_SPANISH2_CI = 174;
  exports.UTF32_ROMAN_CI = 175;
  exports.UTF32_PERSIAN_CI = 176;
  exports.UTF32_ESPERANTO_CI = 177;
  exports.UTF32_HUNGARIAN_CI = 178;
  exports.UTF32_SINHALA_CI = 179;
  exports.UTF32_GERMAN2_CI = 180;
  exports.UTF32_CROATIAN_CI = 181;
  exports.UTF32_UNICODE_520_CI = 182;
  exports.UTF32_VIETNAMESE_CI = 183;
  exports.UTF8_UNICODE_CI = 192;
  exports.UTF8_ICELANDIC_CI = 193;
  exports.UTF8_LATVIAN_CI = 194;
  exports.UTF8_ROMANIAN_CI = 195;
  exports.UTF8_SLOVENIAN_CI = 196;
  exports.UTF8_POLISH_CI = 197;
  exports.UTF8_ESTONIAN_CI = 198;
  exports.UTF8_SPANISH_CI = 199;
  exports.UTF8_SWEDISH_CI = 200;
  exports.UTF8_TURKISH_CI = 201;
  exports.UTF8_CZECH_CI = 202;
  exports.UTF8_DANISH_CI = 203;
  exports.UTF8_LITHUANIAN_CI = 204;
  exports.UTF8_SLOVAK_CI = 205;
  exports.UTF8_SPANISH2_CI = 206;
  exports.UTF8_ROMAN_CI = 207;
  exports.UTF8_PERSIAN_CI = 208;
  exports.UTF8_ESPERANTO_CI = 209;
  exports.UTF8_HUNGARIAN_CI = 210;
  exports.UTF8_SINHALA_CI = 211;
  exports.UTF8_GERMAN2_CI = 212;
  exports.UTF8_CROATIAN_CI = 213;
  exports.UTF8_UNICODE_520_CI = 214;
  exports.UTF8_VIETNAMESE_CI = 215;
  exports.UTF8_GENERAL_MYSQL500_CI = 223;
  exports.UTF8MB4_UNICODE_CI = 224;
  exports.UTF8MB4_ICELANDIC_CI = 225;
  exports.UTF8MB4_LATVIAN_CI = 226;
  exports.UTF8MB4_ROMANIAN_CI = 227;
  exports.UTF8MB4_SLOVENIAN_CI = 228;
  exports.UTF8MB4_POLISH_CI = 229;
  exports.UTF8MB4_ESTONIAN_CI = 230;
  exports.UTF8MB4_SPANISH_CI = 231;
  exports.UTF8MB4_SWEDISH_CI = 232;
  exports.UTF8MB4_TURKISH_CI = 233;
  exports.UTF8MB4_CZECH_CI = 234;
  exports.UTF8MB4_DANISH_CI = 235;
  exports.UTF8MB4_LITHUANIAN_CI = 236;
  exports.UTF8MB4_SLOVAK_CI = 237;
  exports.UTF8MB4_SPANISH2_CI = 238;
  exports.UTF8MB4_ROMAN_CI = 239;
  exports.UTF8MB4_PERSIAN_CI = 240;
  exports.UTF8MB4_ESPERANTO_CI = 241;
  exports.UTF8MB4_HUNGARIAN_CI = 242;
  exports.UTF8MB4_SINHALA_CI = 243;
  exports.UTF8MB4_GERMAN2_CI = 244;
  exports.UTF8MB4_CROATIAN_CI = 245;
  exports.UTF8MB4_UNICODE_520_CI = 246;
  exports.UTF8MB4_VIETNAMESE_CI = 247;
  exports.GB18030_CHINESE_CI = 248;
  exports.GB18030_BIN = 249;
  exports.GB18030_UNICODE_520_CI = 250;
  exports.UTF8_GENERAL50_CI = 253;
  exports.UTF8MB4_0900_AI_CI = 255;
  exports.UTF8MB4_DE_PB_0900_AI_CI = 256;
  exports.UTF8MB4_IS_0900_AI_CI = 257;
  exports.UTF8MB4_LV_0900_AI_CI = 258;
  exports.UTF8MB4_RO_0900_AI_CI = 259;
  exports.UTF8MB4_SL_0900_AI_CI = 260;
  exports.UTF8MB4_PL_0900_AI_CI = 261;
  exports.UTF8MB4_ET_0900_AI_CI = 262;
  exports.UTF8MB4_ES_0900_AI_CI = 263;
  exports.UTF8MB4_SV_0900_AI_CI = 264;
  exports.UTF8MB4_TR_0900_AI_CI = 265;
  exports.UTF8MB4_CS_0900_AI_CI = 266;
  exports.UTF8MB4_DA_0900_AI_CI = 267;
  exports.UTF8MB4_LT_0900_AI_CI = 268;
  exports.UTF8MB4_SK_0900_AI_CI = 269;
  exports.UTF8MB4_ES_TRAD_0900_AI_CI = 270;
  exports.UTF8MB4_LA_0900_AI_CI = 271;
  exports.UTF8MB4_EO_0900_AI_CI = 273;
  exports.UTF8MB4_HU_0900_AI_CI = 274;
  exports.UTF8MB4_HR_0900_AI_CI = 275;
  exports.UTF8MB4_VI_0900_AI_CI = 277;
  exports.UTF8MB4_0900_AS_CS = 278;
  exports.UTF8MB4_DE_PB_0900_AS_CS = 279;
  exports.UTF8MB4_IS_0900_AS_CS = 280;
  exports.UTF8MB4_LV_0900_AS_CS = 281;
  exports.UTF8MB4_RO_0900_AS_CS = 282;
  exports.UTF8MB4_SL_0900_AS_CS = 283;
  exports.UTF8MB4_PL_0900_AS_CS = 284;
  exports.UTF8MB4_ET_0900_AS_CS = 285;
  exports.UTF8MB4_ES_0900_AS_CS = 286;
  exports.UTF8MB4_SV_0900_AS_CS = 287;
  exports.UTF8MB4_TR_0900_AS_CS = 288;
  exports.UTF8MB4_CS_0900_AS_CS = 289;
  exports.UTF8MB4_DA_0900_AS_CS = 290;
  exports.UTF8MB4_LT_0900_AS_CS = 291;
  exports.UTF8MB4_SK_0900_AS_CS = 292;
  exports.UTF8MB4_ES_TRAD_0900_AS_CS = 293;
  exports.UTF8MB4_LA_0900_AS_CS = 294;
  exports.UTF8MB4_EO_0900_AS_CS = 296;
  exports.UTF8MB4_HU_0900_AS_CS = 297;
  exports.UTF8MB4_HR_0900_AS_CS = 298;
  exports.UTF8MB4_VI_0900_AS_CS = 300;
  exports.UTF8MB4_JA_0900_AS_CS = 303;
  exports.UTF8MB4_JA_0900_AS_CS_KS = 304;
  exports.UTF8MB4_0900_AS_CI = 305;
  exports.UTF8MB4_RU_0900_AI_CI = 306;
  exports.UTF8MB4_RU_0900_AS_CS = 307;
  exports.UTF8MB4_ZH_0900_AS_CS = 308;
  exports.UTF8MB4_0900_BIN = 309;
  exports.BIG5 = exports.BIG5_CHINESE_CI;
  exports.DEC8 = exports.DEC8_SWEDISH_CI;
  exports.CP850 = exports.CP850_GENERAL_CI;
  exports.HP8 = exports.HP8_ENGLISH_CI;
  exports.KOI8R = exports.KOI8R_GENERAL_CI;
  exports.LATIN1 = exports.LATIN1_SWEDISH_CI;
  exports.LATIN2 = exports.LATIN2_GENERAL_CI;
  exports.SWE7 = exports.SWE7_SWEDISH_CI;
  exports.ASCII = exports.ASCII_GENERAL_CI;
  exports.UJIS = exports.UJIS_JAPANESE_CI;
  exports.SJIS = exports.SJIS_JAPANESE_CI;
  exports.HEBREW = exports.HEBREW_GENERAL_CI;
  exports.TIS620 = exports.TIS620_THAI_CI;
  exports.EUCKR = exports.EUCKR_KOREAN_CI;
  exports.KOI8U = exports.KOI8U_GENERAL_CI;
  exports.GB2312 = exports.GB2312_CHINESE_CI;
  exports.GREEK = exports.GREEK_GENERAL_CI;
  exports.CP1250 = exports.CP1250_GENERAL_CI;
  exports.GBK = exports.GBK_CHINESE_CI;
  exports.LATIN5 = exports.LATIN5_TURKISH_CI;
  exports.ARMSCII8 = exports.ARMSCII8_GENERAL_CI;
  exports.UTF8 = exports.UTF8_GENERAL_CI;
  exports.UCS2 = exports.UCS2_GENERAL_CI;
  exports.CP866 = exports.CP866_GENERAL_CI;
  exports.KEYBCS2 = exports.KEYBCS2_GENERAL_CI;
  exports.MACCE = exports.MACCE_GENERAL_CI;
  exports.MACROMAN = exports.MACROMAN_GENERAL_CI;
  exports.CP852 = exports.CP852_GENERAL_CI;
  exports.LATIN7 = exports.LATIN7_GENERAL_CI;
  exports.UTF8MB4 = exports.UTF8MB4_GENERAL_CI;
  exports.CP1251 = exports.CP1251_GENERAL_CI;
  exports.UTF16 = exports.UTF16_GENERAL_CI;
  exports.UTF16LE = exports.UTF16LE_GENERAL_CI;
  exports.CP1256 = exports.CP1256_GENERAL_CI;
  exports.CP1257 = exports.CP1257_GENERAL_CI;
  exports.UTF32 = exports.UTF32_GENERAL_CI;
  exports.CP932 = exports.CP932_JAPANESE_CI;
  exports.EUCJPMS = exports.EUCJPMS_JAPANESE_CI;
  exports.GB18030 = exports.GB18030_CHINESE_CI;
  exports.GEOSTD8 = exports.GEOSTD8_GENERAL_CI;
});

// ../../../../node_modules/mysql2/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "mysql2",
    version: "3.14.1",
    description: "fast mysql driver. Implements core protocol, prepared statements, ssl and compression in native JS",
    main: "index.js",
    typings: "typings/mysql/index",
    type: "commonjs",
    scripts: {
      lint: "eslint . && prettier --check .",
      "lint:fix": "eslint . --fix && prettier --write .",
      test: "poku -d -r=verbose --sequential test/esm test/unit test/integration",
      "test:bun": "bun poku -d --sequential test/esm test/unit test/integration",
      "test:deno": 'deno run --allow-read --allow-env --allow-run npm:poku -d --sequential --denoAllow="read,env,net,sys" test/esm test/unit test/integration',
      "test:tsc-build": 'cd "test/tsc-build" && npx tsc -p "tsconfig.json"',
      "coverage-test": "c8 npm run test",
      benchmark: "node ./benchmarks/benchmark.js",
      "wait-port": "wait-on"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/sidorares/node-mysql2.git"
    },
    homepage: "https://sidorares.github.io/node-mysql2/docs",
    keywords: [
      "mysql",
      "client",
      "server"
    ],
    files: [
      "lib",
      "typings/mysql",
      "index.js",
      "index.d.ts",
      "promise.js",
      "promise.d.ts"
    ],
    exports: {
      ".": "./index.js",
      "./package.json": "./package.json",
      "./promise": "./promise.js",
      "./promise.js": "./promise.js"
    },
    engines: {
      node: ">= 8.0"
    },
    author: "Andrey Sidorov <andrey.sidorov@gmail.com>",
    license: "MIT",
    dependencies: {
      "aws-ssl-profiles": "^1.1.1",
      denque: "^2.1.0",
      "generate-function": "^2.3.1",
      "iconv-lite": "^0.6.3",
      long: "^5.2.1",
      "lru.min": "^1.0.0",
      "named-placeholders": "^1.1.3",
      "seq-queue": "^0.0.5",
      sqlstring: "^2.3.2"
    },
    devDependencies: {
      "@eslint/eslintrc": "^3.3.0",
      "@eslint/js": "^9.21.0",
      "@eslint/markdown": "^6.2.2",
      "@types/node": "^22.0.0",
      "@typescript-eslint/eslint-plugin": "^8.26.0",
      "@typescript-eslint/parser": "^8.26.0",
      "assert-diff": "^3.0.2",
      benchmark: "^2.1.4",
      c8: "^10.1.1",
      "error-stack-parser": "^2.0.3",
      "eslint-config-prettier": "^10.0.2",
      "eslint-plugin-async-await": "^0.0.0",
      "eslint-plugin-markdown": "^5.1.0",
      "eslint-plugin-prettier": "^5.2.3",
      globals: "^16.0.0",
      poku: "^3.0.0",
      portfinder: "^1.0.28",
      prettier: "^3.0.0",
      typescript: "^5.0.2"
    }
  };
});

// ../../../../node_modules/aws-ssl-profiles/lib/profiles/ca/defaults.js
var require_defaults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaults = undefined;
  exports.defaults = [
    `-----BEGIN CERTIFICATE-----
` + `MIIEEjCCAvqgAwIBAgIJAM2ZN/+nPi27MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0Ew
` + `HhcNMTkxMDI4MTgwNTU4WhcNMjQxMDI2MTgwNTU4WjCBlTELMAkGA1UEBhMCVVMx
` + `EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM
` + `GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx
` + `JjAkBgNVBAMMHUFtYXpvbiBSRFMgYWYtc291dGgtMSBSb290IENBMIIBIjANBgkq
` + `hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR2351uPMZaJk2gMGT+1sk8HE9MQh2rc
` + `/sCnbxGn2p1c7Oi9aBbd/GiFijeJb2BXvHU+TOq3d3Jjqepq8tapXVt4ojbTJNyC
` + `J5E7r7KjTktKdLxtBE1MK25aY+IRJjtdU6vG3KiPKUT1naO3xs3yt0F76WVuFivd
` + `9OHv2a+KHvPkRUWIxpmAHuMY9SIIMmEZtVE7YZGx5ah0iO4JzItHcbVR0y0PBH55
` + `arpFBddpIVHCacp1FUPxSEWkOpI7q0AaU4xfX0fe1BV5HZYRKpBOIp1TtZWvJD+X
` + `jGUtL1BEsT5vN5g9MkqdtYrC+3SNpAk4VtpvJrdjraI/hhvfeXNnAwIDAQABo2Mw
` + `YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUEEi/
` + `WWMcBJsoGXg+EZwkQ0MscZQwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0Ms
` + `cZQwDQYJKoZIhvcNAQELBQADggEBAGDZ5js5Pc/gC58LJrwMPXFhJDBS8QuDm23C
` + `FFUdlqucskwOS3907ErK1ZkmVJCIqFLArHqskFXMAkRZ2PNR7RjWLqBs+0znG5yH
` + `hRKb4DXzhUFQ18UBRcvT6V6zN97HTRsEEaNhM/7k8YLe7P8vfNZ28VIoJIGGgv9D
` + `wQBBvkxQ71oOmAG0AwaGD0ORGUfbYry9Dz4a4IcUsZyRWRMADixgrFv6VuETp26s
` + `/+z+iqNaGWlELBKh3iQCT6Y/1UnkPLO42bxrCSyOvshdkYN58Q2gMTE1SVTqyo8G
` + `Lw8lLAz9bnvUSgHzB3jRrSx6ggF/WRMRYlR++y6LXP4SAsSAaC0=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEEjCCAvqgAwIBAgIJAJYM4LxvTZA6MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0Ew
` + `HhcNMTkxMDMwMjAyMDM2WhcNMjQxMDI4MjAyMDM2WjCBlTELMAkGA1UEBhMCVVMx
` + `EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM
` + `GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx
` + `JjAkBgNVBAMMHUFtYXpvbiBSRFMgZXUtc291dGgtMSBSb290IENBMIIBIjANBgkq
` + `hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqM921jXCXeqpRNCS9CBPOe5N7gMaEt+D
` + `s5uR3riZbqzRlHGiF1jZihkXfHAIQewDwy+Yz+Oec1aEZCQMhUHxZJPusuX0cJfj
` + `b+UluFqHIijL2TfXJ3D0PVLLoNTQJZ8+GAPECyojAaNuoHbdVqxhOcznMsXIXVFq
` + `yVLKDGvyKkJjai/iSPDrQMXufg3kWt0ISjNLvsG5IFXgP4gttsM8i0yvRd4QcHoo
` + `DjvH7V3cS+CQqW5SnDrGnHToB0RLskE1ET+oNOfeN9PWOxQprMOX/zmJhnJQlTqD
` + `QP7jcf7SddxrKFjuziFiouskJJyNDsMjt1Lf60+oHZhed2ogTeifGwIDAQABo2Mw
` + `YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUFBAF
` + `cgJe/BBuZiGeZ8STfpkgRYQwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkg
` + `RYQwDQYJKoZIhvcNAQELBQADggEBAKAYUtlvDuX2UpZW9i1QgsjFuy/ErbW0dLHU
` + `e/IcFtju2z6RLZ+uF+5A8Kme7IKG1hgt8s+w9TRVQS/7ukQzoK3TaN6XKXRosjtc
` + `o9Rm4gYWM8bmglzY1TPNaiI4HC7546hSwJhubjN0bXCuj/0sHD6w2DkiGuwKNAef
` + `yTu5vZhPkeNyXLykxkzz7bNp2/PtMBnzIp+WpS7uUDmWyScGPohKMq5PqvL59z+L
` + `ZI3CYeMZrJ5VpXUg3fNNIz/83N3G0sk7wr0ohs/kHTP7xPOYB0zD7Ku4HA0Q9Swf
` + `WX0qr6UQgTPMjfYDLffI7aEId0gxKw1eGYc6Cq5JAZ3ipi/cBFc=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew
` + `HhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx
` + `EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM
` + `GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx
` + `JjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq
` + `hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT
` + `aPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk
` + `UA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8
` + `gkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw
` + `ERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd
` + `rdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw
` + `YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf
` + `DjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda
` + `iqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA
` + `eC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7
` + `ny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB
` + `hitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso
` + `aTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv
` + `3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw
` + `ODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV
` + `BAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv
` + `biBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV
` + `BAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC
` + `AQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ
` + `oWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY
` + `0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I
` + `6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9
` + `O08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9
` + `McZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E
` + `BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa
` + `pmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN
` + `AQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV
` + `ynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc
` + `NUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu
` + `cbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY
` + `0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/
` + `zPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEEDCCAvigAwIBAgIJAKFMXyltvuRdMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTAe
` + `Fw0xOTA4MTkxNzM4MjZaFw0yNDA4MTkxNzM4MjZaMIGUMQswCQYDVQQGEwJVUzEQ
` + `MA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UECgwZ
` + `QW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEl
` + `MCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTCCASIwDQYJKoZI
` + `hvcNAQEBBQADggEPADCCAQoCggEBAMkZdnIH9ndatGAcFo+DppGJ1HUt4x+zeO+0
` + `ZZ29m0sfGetVulmTlv2d5b66e+QXZFWpcPQMouSxxYTW08TbrQiZngKr40JNXftA
` + `atvzBqIImD4II0ZX5UEVj2h98qe/ypW5xaDN7fEa5e8FkYB1TEemPaWIbNXqchcL
` + `tV7IJPr3Cd7Z5gZJlmujIVDPpMuSiNaal9/6nT9oqN+JSM1fx5SzrU5ssg1Vp1vv
` + `5Xab64uOg7wCJRB9R2GC9XD04odX6VcxUAGrZo6LR64ZSifupo3l+R5sVOc5i8NH
` + `skdboTzU9H7+oSdqoAyhIU717PcqeDum23DYlPE2nGBWckE+eT8CAwEAAaNjMGEw
` + `DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK2hDBWl
` + `sbHzt/EHd0QYOooqcFPhMB8GA1UdIwQYMBaAFK2hDBWlsbHzt/EHd0QYOooqcFPh
` + `MA0GCSqGSIb3DQEBCwUAA4IBAQAO/718k8EnOqJDx6wweUscGTGL/QdKXUzTVRAx
` + `JUsjNUv49mH2HQVEW7oxszfH6cPCaupNAddMhQc4C/af6GHX8HnqfPDk27/yBQI+
` + `yBBvIanGgxv9c9wBbmcIaCEWJcsLp3HzXSYHmjiqkViXwCpYfkoV3Ns2m8bp+KCO
` + `y9XmcCKRaXkt237qmoxoh2sGmBHk2UlQtOsMC0aUQ4d7teAJG0q6pbyZEiPyKZY1
` + `XR/UVxMJL0Q4iVpcRS1kaNCMfqS2smbLJeNdsan8pkw1dvPhcaVTb7CvjhJtjztF
` + `YfDzAI5794qMlWxwilKMmUvDlPPOTen8NNHkLwWvyFCH7Doh
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEFjCCAv6gAwIBAgIJAMzYZJ+R9NBVMA0GCSqGSIb3DQEBCwUAMIGXMQswCQYD
` + `VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi
` + `MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h
` + `em9uIFJEUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBD
` + `QTAeFw0xOTA4MjEyMjI5NDlaFw0yNDA4MjEyMjI5NDlaMIGXMQswCQYDVQQGEwJV
` + `UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE
` + `CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE
` + `UzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBDQTCCASIw
` + `DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM7kkS6vjgKKQTPynC2NjdN5aPPV
` + `O71G0JJS/2ARVBVJd93JLiGovVJilfWYfwZCs4gTRSSjrUD4D4HyqCd6A+eEEtJq
` + `M0DEC7i0dC+9WNTsPszuB206Jy2IUmxZMIKJAA1NHSbIMjB+b6/JhbSUi7nKdbR/
` + `brj83bF+RoSA+ogrgX7mQbxhmFcoZN9OGaJgYKsKWUt5Wqv627KkGodUK8mDepgD
` + `S3ZfoRQRx3iceETpcmHJvaIge6+vyDX3d9Z22jmvQ4AKv3py2CmU2UwuhOltFDwB
` + `0ddtb39vgwrJxaGfiMRHpEP1DfNLWHAnA69/pgZPwIggidS+iBPUhgucMp8CAwEA
` + `AaNjMGEwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE
` + `FGnTGpQuQ2H/DZlXMQijZEhjs7TdMB8GA1UdIwQYMBaAFGnTGpQuQ2H/DZlXMQij
` + `ZEhjs7TdMA0GCSqGSIb3DQEBCwUAA4IBAQC3xz1vQvcXAfpcZlngiRWeqU8zQAMQ
` + `LZPCFNv7PVk4pmqX+ZiIRo4f9Zy7TrOVcboCnqmP/b/mNq0gVF4O+88jwXJZD+f8
` + `/RnABMZcnGU+vK0YmxsAtYU6TIb1uhRFmbF8K80HHbj9vSjBGIQdPCbvmR2zY6VJ
` + `BYM+w9U9hp6H4DVMLKXPc1bFlKA5OBTgUtgkDibWJKFOEPW3UOYwp9uq6pFoN0AO
` + `xMTldqWFsOF3bJIlvOY0c/1EFZXu3Ns6/oCP//Ap9vumldYMUZWmbK+gK33FPOXV
` + `8BQ6jNC29icv7lLDpRPwjibJBXX+peDR5UK4FdYcswWEB1Tix5X8dYu6
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSYwJAYDVQQDDB1BbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw
` + `MjgxODA2NTNaFw0yNDEwMjgxODA2NTNaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE
` + `CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u
` + `IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE
` + `AwwYQW1hem9uIFJEUyBhZi1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC
` + `AQ8AMIIBCgKCAQEAvtV1OqmFa8zCVQSKOvPUJERLVFtd4rZmDpImc5rIoeBk7w/P
` + `9lcKUJjO8R/w1a2lJXx3oQ81tiY0Piw6TpT62YWVRMWrOw8+Vxq1dNaDSFp9I8d0
` + `UHillSSbOk6FOrPDp+R6AwbGFqUDebbN5LFFoDKbhNmH1BVS0a6YNKpGigLRqhka
` + `cClPslWtPqtjbaP3Jbxl26zWzLo7OtZl98dR225pq8aApNBwmtgA7Gh60HK/cX0t
` + `32W94n8D+GKSg6R4MKredVFqRTi9hCCNUu0sxYPoELuM+mHiqB5NPjtm92EzCWs+
` + `+vgWhMc6GxG+82QSWx1Vj8sgLqtE/vLrWddf5QIDAQABo2YwZDAOBgNVHQ8BAf8E
` + `BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUuLB4gYVJrSKJj/Gz
` + `pqc6yeA+RcAwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0MscZQwDQYJKoZI
` + `hvcNAQELBQADggEBABauYOZxUhe9/RhzGJ8MsWCz8eKcyDVd4FCnY6Qh+9wcmYNT
` + `LtnD88LACtJKb/b81qYzcB0Em6+zVJ3Z9jznfr6buItE6es9wAoja22Xgv44BTHL
` + `rimbgMwpTt3uEMXDffaS0Ww6YWb3pSE0XYI2ISMWz+xRERRf+QqktSaL39zuiaW5
` + `tfZMre+YhohRa/F0ZQl3RCd6yFcLx4UoSPqQsUl97WhYzwAxZZfwvLJXOc4ATt3u
` + `VlCUylNDkaZztDJc/yN5XQoK9W5nOt2cLu513MGYKbuarQr8f+gYU8S+qOyuSRSP
` + `NRITzwCRVnsJE+2JmcRInn/NcanB7uOGqTvJ9+c=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSYwJAYDVQQDDB1BbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw
` + `MzAyMDIxMzBaFw0yNDEwMzAyMDIxMzBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE
` + `CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u
` + `IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE
` + `AwwYQW1hem9uIFJEUyBldS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC
` + `AQ8AMIIBCgKCAQEAtEyjYcajx6xImJn8Vz1zjdmL4ANPgQXwF7+tF7xccmNAZETb
` + `bzb3I9i5fZlmrRaVznX+9biXVaGxYzIUIR3huQ3Q283KsDYnVuGa3mk690vhvJbB
` + `QIPgKa5mVwJppnuJm78KqaSpi0vxyCPe3h8h6LLFawVyWrYNZ4okli1/U582eef8
` + `RzJp/Ear3KgHOLIiCdPDF0rjOdCG1MOlDLixVnPn9IYOciqO+VivXBg+jtfc5J+L
` + `AaPm0/Yx4uELt1tkbWkm4BvTU/gBOODnYziITZM0l6Fgwvbwgq5duAtKW+h031lC
` + `37rEvrclqcp4wrsUYcLAWX79ZyKIlRxcAdvEhQIDAQABo2YwZDAOBgNVHQ8BAf8E
` + `BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU7zPyc0azQxnBCe7D
` + `b9KAadH1QSEwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkgRYQwDQYJKoZI
` + `hvcNAQELBQADggEBAFGaNiYxg7yC/xauXPlaqLCtwbm2dKyK9nIFbF/7be8mk7Q3
` + `MOA0of1vGHPLVQLr6bJJpD9MAbUcm4cPAwWaxwcNpxOjYOFDaq10PCK4eRAxZWwF
` + `NJRIRmGsl8NEsMNTMCy8X+Kyw5EzH4vWFl5Uf2bGKOeFg0zt43jWQVOX6C+aL3Cd
` + `pRS5MhmYpxMG8irrNOxf4NVFE2zpJOCm3bn0STLhkDcV/ww4zMzObTJhiIb5wSWn
` + `EXKKWhUXuRt7A2y1KJtXpTbSRHQxE++69Go1tWhXtRiULCJtf7wF2Ksm0RR/AdXT
` + `1uR1vKyH5KBJPX3ppYkQDukoHTFR0CpB+G84NLo=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSYwJAYDVQQDDB1BbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTA1
` + `MTAyMTU4NDNaFw0yNTA2MDExMjAwMDBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE
` + `CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u
` + `IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE
` + `AwwYQW1hem9uIFJEUyBtZS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC
` + `AQ8AMIIBCgKCAQEAudOYPZH+ihJAo6hNYMB5izPVBe3TYhnZm8+X3IoaaYiKtsp1
` + `JJhkTT0CEejYIQ58Fh4QrMUyWvU8qsdK3diNyQRoYLbctsBPgxBR1u07eUJDv38/
` + `C1JlqgHmMnMi4y68Iy7ymv50QgAMuaBqgEBRI1R6Lfbyrb2YvH5txjJyTVMwuCfd
` + `YPAtZVouRz0JxmnfsHyxjE+So56uOKTDuw++Ho4HhZ7Qveej7XB8b+PIPuroknd3
` + `FQB5RVbXRvt5ZcVD4F2fbEdBniF7FAF4dEiofVCQGQ2nynT7dZdEIPfPdH3n7ZmE
` + `lAOmwHQ6G83OsiHRBLnbp+QZRgOsjkHJxT20bQIDAQABo2YwZDAOBgNVHQ8BAf8E
` + `BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUOEVDM7VomRH4HVdA
` + `QvIMNq2tXOcwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXdaiqYwDQYJKoZI
` + `hvcNAQELBQADggEBAHhvMssj+Th8IpNePU6RH0BiL6o9c437R3Q4IEJeFdYL+nZz
` + `PW/rELDPvLRUNMfKM+KzduLZ+l29HahxefejYPXtvXBlq/E/9czFDD4fWXg+zVou
` + `uDXhyrV4kNmP4S0eqsAP/jQHPOZAMFA4yVwO9hlqmePhyDnszCh9c1PfJSBh49+b
` + `4w7i/L3VBOMt8j3EKYvqz0gVfpeqhJwL4Hey8UbVfJRFJMJzfNHpePqtDRAY7yjV
` + `PYquRaV2ab/E+/7VFkWMM4tazYz/qsYA2jSH+4xDHvYk8LnsbcrF9iuidQmEc5sb
` + `FgcWaSKG4DJjcI5k7AJLWcXyTDt21Ci43LE+I9Q=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz
` + `MDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h
` + `em9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB
` + `DwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim
` + `eWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC
` + `BaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM
` + `p/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e
` + `qCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt
` + `lPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE
` + `AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG
` + `i3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG
` + `9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+
` + `hu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K
` + `jYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD
` + `tZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe
` + `iOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox
` + `AVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2
` + `MjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H
` + `M6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld
` + `5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J
` + `bFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc
` + `Jt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7
` + `JbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq
` + `ccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I
` + `93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR
` + `4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn
` + `/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q
` + `Ls1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C
` + `jkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV
` + `UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE
` + `CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE
` + `UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0
` + `MDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh
` + `c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg
` + `U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt
` + `YXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB
` + `DwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6
` + `0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq
` + `/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH
` + `uM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK
` + `AkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v
` + `l5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE
` + `AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+
` + `T3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG
` + `9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA
` + `PAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6
` + `tZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17
` + `4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57
` + `Z6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd
` + `pFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2
` + `MjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h
` + `em9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF
` + `AAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5
` + `8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN
` + `DpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s
` + `3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc
` + `cQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ
` + `h32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B
` + `Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U
` + `lrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ
` + `KoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc
` + `9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6
` + `mkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV
` + `obcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx
` + `CRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4
` + `prf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy
` + `MjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h
` + `em9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD
` + `ggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB
` + `viuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp
` + `XnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O
` + `qvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi
` + `qmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh
` + `YDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/
` + `BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE
` + `CxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG
` + `SIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2
` + `lKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9
` + `r8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp
` + `xl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv
` + `RbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x
` + `JXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx
` + `NDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ
` + `LXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X
` + `O++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69
` + `7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5
` + `tvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS
` + `EMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt
` + `sLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP
` + `0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy
` + `lGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd
` + `vH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9
` + `nRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A
` + `J116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2
` + `MjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h
` + `em9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD
` + `ggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv
` + `n+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl
` + `I67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh
` + `m34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0
` + `5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6
` + `D/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/
` + `BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa
` + `TnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG
` + `SIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt
` + `DAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE
` + `cXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH
` + `mgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W
` + `CBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc
` + `qpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5
` + `NDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h
` + `em9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB
` + `DwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v
` + `Aoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO
` + `XsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs
` + `JXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e
` + `uhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE
` + `q+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE
` + `AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc
` + `hnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG
` + `9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI
` + `T5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl
` + `I1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe
` + `pxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc
` + `tKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN
` + `cjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy
` + `MzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u
` + `PFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn
` + `7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB
` + `6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX
` + `7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y
` + `fYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv
` + `2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM
` + `hnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q
` + `oHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10
` + `7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU
` + `mqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD
` + `bpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV
` + `UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE
` + `CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE
` + `UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw
` + `NjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh
` + `c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg
` + `U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt
` + `YXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB
` + `DwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht
` + `2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC
` + `au1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI
` + `8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c
` + `dbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4
` + `nS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE
` + `AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH
` + `6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG
` + `9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8
` + `quvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ
` + `HvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2
` + `V8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv
` + `OnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92
` + `tO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx
` + `NDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h
` + `em9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF
` + `AAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb
` + `qddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns
` + `eHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5
` + `6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH
` + `wzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw
` + `61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B
` + `Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5
` + `Ichd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ
` + `KoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP
` + `uYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj
` + `yjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h
` + `eIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi
` + `IRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI
` + `HfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx
` + `MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa
` + `uVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P
` + `PvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho
` + `OiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj
` + `pvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a
` + `2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu
` + `pHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P
` + `3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7
` + `GZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q
` + `UpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb
` + `jL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6
` + `uboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz
` + `NDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h
` + `em9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF
` + `AAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo
` + `GHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd
` + `gEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn
` + `TpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j
` + `7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH
` + `PbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B
` + `Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV
` + `M5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ
` + `KoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz
` + `sl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M
` + `NsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw
` + `1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL
` + `+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR
` + `FZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1
` + `MjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h
` + `em9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF
` + `AAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS
` + `kbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1
` + `xoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3
` + `Z+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV
` + `LhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn
` + `7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B
` + `Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+
` + `gv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ
` + `KoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w
` + `G0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad
` + `zQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN
` + `xngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W
` + `8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy
` + `DgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2
` + `MjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h
` + `em9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF
` + `AAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7
` + `+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx
` + `1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s
` + `BEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3
` + `UnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud
` + `QQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B
` + `Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+
` + `snUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ
` + `KoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j
` + `b4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM
` + `gwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX
` + `Fiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq
` + `nvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf
` + `2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz
` + `MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh
` + `1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg
` + `pVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2
` + `q+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr
` + `i+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV
` + `ARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3
` + `Y2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV
` + `SxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1
` + `AETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3
` + `O971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2
` + `zFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF
` + `wWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2
` + `NTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz
` + `aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT
` + `ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h
` + `em9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
` + `ADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL
` + `InXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt
` + `i8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs
` + `XcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso
` + `QIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK
` + `glMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD
` + `AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR
` + `RBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3
` + `DQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK
` + `PJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC
` + `E1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4
` + `0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i
` + `h2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF
` + `MRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEETCCAvmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSUwIwYDVQQDDBxBbWF6b24gUkRTIEJldGEgUm9vdCAyMDE5IENBMB4XDTE5MDgy
` + `MDE3MTAwN1oXDTI0MDgxOTE3MzgyNlowgZkxCzAJBgNVBAYTAlVTMRMwEQYDVQQI
` + `DApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g
` + `V2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSowKAYDVQQD
` + `DCFBbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3
` + `DQEBAQUAA4IBDwAwggEKAoIBAQDTNCOlotQcLP8TP82U2+nk0bExVuuMVOgFeVMx
` + `vbUHZQeIj9ikjk+jm6eTDnnkhoZcmJiJgRy+5Jt69QcRbb3y3SAU7VoHgtraVbxF
` + `QDh7JEHI9tqEEVOA5OvRrDRcyeEYBoTDgh76ROco2lR+/9uCvGtHVrMCtG7BP7ZB
` + `sSVNAr1IIRZZqKLv2skKT/7mzZR2ivcw9UeBBTUf8xsfiYVBvMGoEsXEycjYdf6w
` + `WV+7XS7teNOc9UgsFNN+9AhIBc1jvee5E//72/4F8pAttAg/+mmPUyIKtekNJ4gj
` + `OAR2VAzGx1ybzWPwIgOudZFHXFduxvq4f1hIRPH0KbQ/gkRrAgMBAAGjZjBkMA4G
` + `A1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTkvpCD
` + `6C43rar9TtJoXr7q8dkrrjAfBgNVHSMEGDAWgBStoQwVpbGx87fxB3dEGDqKKnBT
` + `4TANBgkqhkiG9w0BAQsFAAOCAQEAJd9fOSkwB3uVdsS+puj6gCER8jqmhd3g/J5V
` + `Zjk9cKS8H0e8pq/tMxeJ8kpurPAzUk5RkCspGt2l0BSwmf3ahr8aJRviMX6AuW3/
` + `g8aKplTvq/WMNGKLXONa3Sq8591J+ce8gtOX/1rDKmFI4wQ/gUzOSYiT991m7QKS
` + `Fr6HMgFuz7RNJbb3Fy5cnurh8eYWA7mMv7laiLwTNsaro5qsqErD5uXuot6o9beT
` + `a+GiKinEur35tNxAr47ax4IRubuIzyfCrezjfKc5raVV2NURJDyKP0m0CCaffAxE
` + `qn2dNfYc3v1D8ypg3XjHlOzRo32RB04o8ALHMD9LSwsYDLpMag==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEFzCCAv+gAwIBAgICFSUwDQYJKoZIhvcNAQELBQAwgZcxCzAJBgNVBAYTAlVT
` + `MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK
` + `DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT
` + `MSgwJgYDVQQDDB9BbWF6b24gUkRTIFByZXZpZXcgUm9vdCAyMDE5IENBMB4XDTE5
` + `MDgyMTIyMzk0N1oXDTI0MDgyMTIyMjk0OVowgZwxCzAJBgNVBAYTAlVTMRMwEQYD
` + `VQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6
` + `b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMS0wKwYD
` + `VQQDDCRBbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0G
` + `CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD0dB/U7qRnSf05wOi7m10Pa2uPMTJv
` + `r6U/3Y17a5prq5Zr4++CnSUYarG51YuIf355dKs+7Lpzs782PIwCmLpzAHKWzix6
` + `pOaTQ+WZ0+vUMTxyqgqWbsBgSCyP7pVBiyqnmLC/L4az9XnscrbAX4pNaoJxsuQe
` + `mzBo6yofjQaAzCX69DuqxFkVTRQnVy7LCFkVaZtjNAftnAHJjVgQw7lIhdGZp9q9
` + `IafRt2gteihYfpn+EAQ/t/E4MnhrYs4CPLfS7BaYXBycEKC5Muj1l4GijNNQ0Efo
` + `xG8LSZz7SNgUvfVwiNTaqfLP3AtEAWiqxyMyh3VO+1HpCjT7uNBFtmF3AgMBAAGj
` + `ZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW
` + `BBQtinkdrj+0B2+qdXngV2tgHnPIujAfBgNVHSMEGDAWgBRp0xqULkNh/w2ZVzEI
` + `o2RIY7O03TANBgkqhkiG9w0BAQsFAAOCAQEAtJdqbCxDeMc8VN1/RzCabw9BIL/z
` + `73Auh8eFTww/sup26yn8NWUkfbckeDYr1BrXa+rPyLfHpg06kwR8rBKyrs5mHwJx
` + `bvOzXD/5WTdgreB+2Fb7mXNvWhenYuji1MF+q1R2DXV3I05zWHteKX6Dajmx+Uuq
` + `Yq78oaCBSV48hMxWlp8fm40ANCL1+gzQ122xweMFN09FmNYFhwuW+Ao+Vv90ZfQG
` + `PYwTvN4n/gegw2TYcifGZC2PNX74q3DH03DXe5fvNgRW5plgz/7f+9mS+YHd5qa9
` + `tYTPUvoRbi169ou6jicsMKUKPORHWhiTpSCWR1FMMIbsAcsyrvtIsuaGCQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/jCCAuagAwIBAgIQdOCSuA9psBpQd8EI368/0DANBgkqhkiG9w0BAQsFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTE5MTgwNjI2WhgPMjA2MTA1MTkxOTA2MjZaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgc2EtZWFzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6ftL6w8v3dB2yW
` + `LjCxSP1D7ZsOTeLZOSCz1Zv0Gkd0XLhil5MdHOHBvwH/DrXqFU2oGzCRuAy+aZis
` + `DardJU6ChyIQIciXCO37f0K23edhtpXuruTLLwUwzeEPdcnLPCX+sWEn9Y5FPnVm
` + `pCd6J8edH2IfSGoa9LdErkpuESXdidLym/w0tWG/O2By4TabkNSmpdrCL00cqI+c
` + `prA8Bx1jX8/9sY0gpAovtuFaRN+Ivg3PAnWuhqiSYyQ5nC2qDparOWuDiOhpY56E
` + `EgmTvjwqMMjNtExfYx6Rv2Ndu50TriiNKEZBzEtkekwXInTupmYTvc7U83P/959V
` + `UiQ+WSMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4uYHdH0+
` + `bUeh81Eq2l5/RJbW+vswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB
` + `AQBhxcExJ+w74bvDknrPZDRgTeMLYgbVJjx2ExH7/Ac5FZZWcpUpFwWMIJJxtewI
` + `AnhryzM3tQYYd4CG9O+Iu0+h/VVfW7e4O3joWVkxNMb820kQSEwvZfA78aItGwOY
` + `WSaFNVRyloVicZRNJSyb1UL9EiJ9ldhxm4LTT0ax+4ontI7zTx6n6h8Sr6r/UOvX
` + `d9T5aUUENWeo6M9jGupHNn3BobtL7BZm2oS8wX8IVYj4tl0q5T89zDi2x0MxbsIV
` + `5ZjwqBQ5JWKv7ASGPb+z286RjPA9R2knF4lJVZrYuNV90rHvI/ECyt/JrDqeljGL
` + `BLl1W/UsvZo6ldLIpoMbbrb5
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBDCCAuygAwIBAgIQUfVbqapkLYpUqcLajpTJWzANBgkqhkiG9w0BAQsFADCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwIBcNMjIwNTA2MjMyMDA5WhgPMjA2MjA1MDcwMDIwMDlaMIGa
` + `MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j
` + `LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt
` + `YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJIeovu3
` + `ewI9FVitXMQzvkh34aQ6WyI4NO3YepfJaePiv3cnyFGYHN2S1cR3UQcLWgypP5va
` + `j6bfroqwGbCbZZcb+6cyOB4ceKO9Ws1UkcaGHnNDcy5gXR7aCW2OGTUfinUuhd2d
` + `5bOGgV7JsPbpw0bwJ156+MwfOK40OLCWVbzy8B1kITs4RUPNa/ZJnvIbiMu9rdj4
` + `8y7GSFJLnKCjlOFUkNI5LcaYvI1+ybuNgphT3nuu5ZirvTswGakGUT/Q0J3dxP0J
` + `pDfg5Sj/2G4gXiaM0LppVOoU5yEwVewhQ250l0eQAqSrwPqAkdTg9ng360zqCFPE
` + `JPPcgI1tdGUgneECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU
` + `/2AJVxWdZxc8eJgdpbwpW7b0f7IwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB
` + `CwUAA4IBAQBYm63jTu2qYKJ94gKnqc+oUgqmb1mTXmgmp/lXDbxonjszJDOXFbri
` + `3CCO7xB2sg9bd5YWY8sGKHaWmENj3FZpCmoefbUx++8D7Mny95Cz8R32rNcwsPTl
` + `ebpd9A/Oaw5ug6M0x/cNr0qzF8Wk9Dx+nFEimp8RYQdKvLDfNFZHjPa1itnTiD8M
` + `TorAqj+VwnUGHOYBsT/0NY12tnwXdD+ATWfpEHdOXV+kTMqFFwDyhfgRVNpTc+os
` + `ygr8SwhnSCpJPB/EYl2S7r+tgAbJOkuwUvGT4pTqrzDQEhwE7swgepnHC87zhf6l
` + `qN6mVpSnQKQLm6Ob5TeCEFgcyElsF5bH
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAOxu0I1QuMAhIeszB3fJIlkwCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyB1cy13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTI0MjIwNjU5WhgPMjEyMTA1MjQyMzA2NTlaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgdXMtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEz4bylRcGqqDWdP7gQIIoTHdBK6FNtKH1
` + `4SkEIXRXkYDmRvL9Bci1MuGrwuvrka5TDj4b7e+csY0llEzHpKfq6nJPFljoYYP9
` + `uqHFkv77nOpJJ633KOr8IxmeHW5RXgrZo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBQQikVz8wmjd9eDFRXzBIU8OseiGzAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIwf06Mcrpw1O0EBLBBrp84m37NYtOkE/0Z0O+C7D41wnXi
` + `EQdn6PXUVgdD23Gj82SrAjEAklhKs+liO1PtN15yeZR1Io98nFve+lLptaLakZcH
` + `+hfFuUtCqMbaI8CdvJlKnPqT
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCTCCA/GgAwIBAgIRALyWMTyCebLZOGcZZQmkmfcwDQYJKoZIhvcNAQEMBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyODAzWhgPMjEyMTA1MjQyMTI4MDNa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0E0MDk2IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
` + `wGFiyDyCrGqgdn4fXG12cxKAAfVvhMea1mw5h9CVRoavkPqhzQpAitSOuMB9DeiP
` + `wQyqcsiGl/cTEau4L+AUBG8b9v26RlY48exUYBXj8CieYntOT9iNw5WtdYJa3kF/
` + `JxgI+HDMzE9cmHDs5DOO3S0uwZVyra/xE1ymfSlpOeUIOTpHRJv97CBUEpaZMUW5
` + `Sr6GruuOwFVpO5FX3A/jQlcS+UN4GjSRgDUJuqg6RRQldEZGCVCCmodbByvI2fGm
` + `reGpsPJD54KkmAX08nOR8e5hkGoHxq0m2DLD4SrOFmt65vG47qnuwplWJjtk9B3Z
` + `9wDoopwZLBOtlkPIkUllWm1P8EuHC1IKOA+wSP6XdT7cy8S77wgyHzR0ynxv7q/l
` + `vlZtH30wnNqFI0y9FeogD0TGMCHcnGqfBSicJXPy9T4fU6f0r1HwqKwPp2GArwe7
` + `dnqLTj2D7M9MyVtFjEs6gfGWXmu1y5uDrf+CszurE8Cycoma+OfjjuVQgWOCy7Nd
` + `jJswPxAroTzVfpgoxXza4ShUY10woZu0/J+HmNmqK7lh4NS75q1tz75in8uTZDkV
` + `be7GK+SEusTrRgcf3tlgPjSTWG3veNzFDF2Vn1GLJXmuZfhdlVQDBNXW4MNREExS
` + `dG57kJjICpT+r8X+si+5j51gRzkSnMYs7VHulpxfcwECAwEAAaNCMEAwDwYDVR0T
` + `AQH/BAUwAwEB/zAdBgNVHQ4EFgQU4JWOpDBmUBuWKvGPZelw87ezhL8wDgYDVR0P
` + `AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBRNLMql7itvXSEFQRAnyOjivHz
` + `l5IlWVQjAbOUr6ogZcwvK6YpxNAFW5zQr8F+fdkiypLz1kk5irx9TIpff0BWC9hQ
` + `/odMPO8Gxn8+COlSvc+dLsF2Dax3Hvz0zLeKMo+cYisJOzpdR/eKd0/AmFdkvQoM
` + `AOK9n0yYvVJU2IrSgeJBiiCarpKSeAktEVQ4rvyacQGr+QAPkkjRwm+5LHZKK43W
` + `nNnggRli9N/27qYtc5bgr3AaQEhEXMI4RxPRXCLsod0ehMGWyRRK728a+6PMMJAJ
` + `WHOU0x7LCEMPP/bvpLj3BdvSGqNor4ZtyXEbwREry1uzsgODeRRns5acPwTM6ff+
` + `CmxO2NZ0OktIUSYRmf6H/ZFlZrIhV8uWaIwEJDz71qvj7buhQ+RFDZ9CNL64C0X6
` + `mf0zJGEpddjANHaaVky+F4gYMtEy2K2Lcm4JGTdyIzUoIe+atzCnRp0QeIcuWtF+
` + `s8AjDYCVFNypcMmqbRmNpITSnOoCHSRuVkY3gutVoYyMLbp8Jm9SJnCIlEWTA6Rm
` + `wADOMGZJVn5/XRTRuetVOB3KlQDjs9OO01XN5NzGSZO2KT9ngAUfh9Eqhf1iRWSP
` + `nZlRbQ2NRCuY/oJ5N59mLGxnNJSE7giEKEBRhTQ/XEPIUYAUPD5fca0arKRJwbol
` + `l9Se1Hsq0ZU5f+OZKQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAK7vlRrGVEePJpW1VHMXdlIwDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MTkxOTI4NDNaGA8yMTIxMDUxOTIwMjg0M1owgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMZiHOQC6x4o
` + `eC7vVOMCGiN5EuLqPYHdceFPm4h5k/ZejXTf7kryk6aoKZKsDIYihkaZwXVS7Y/y
` + `7Ig1F1ABi2jD+CYprj7WxXbhpysmN+CKG7YC3uE4jSvfvUnpzionkQbjJsRJcrPO
` + `cZJM4FVaVp3mlHHtvnM+K3T+ni4a38nAd8xrv1na4+B8ZzZwWZXarfg8lJoGskSn
` + `ou+3rbGQ0r+XlUP03zWujHoNlVK85qUIQvDfTB7n3O4s1XNGvkfv3GNBhYRWJYlB
` + `4p8T+PFN8wG+UOByp1gV7BD64RnpuZ8V3dRAlO6YVAmINyG5UGrPzkIbLtErUNHO
` + `4iSp4UqYvztDqJWWHR/rA84ef+I9RVwwZ8FQbjKq96OTnPrsr63A5mXTC9dXKtbw
` + `XNJPQY//FEdyM3K8sqM0IdCzxCA1MXZ8+QapWVjwyTjUwFvL69HYky9H8eAER59K
` + `5I7u/CWWeCy2R1SYUBINc3xxLr0CGGukcWPEZW2aPo5ibW5kepU1P/pzdMTaTfao
` + `F42jSFXbc7gplLcSqUgWwzBnn35HLTbiZOFBPKf6vRRu8aRX9atgHw/EjCebi2xP
` + `xIYr5Ub8u0QVHIqcnF1/hVzO/Xz0chj3E6VF/yTXnsakm+W1aM2QkZbFGpga+LMy
` + `mFCtdPrELjea2CfxgibaJX1Q4rdEpc8DAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFDSaycEyuspo/NOuzlzblui8KotFMA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEAbosemjeTRsL9o4v0KadBUNS3V7gdAH+X4vH2
` + `Ee1Jc91VOGLdd/s1L9UX6bhe37b9WjUD69ur657wDW0RzxMYgQdZ27SUl0tEgGGp
` + `cCmVs1ky3zEN+Hwnhkz+OTmIg1ufq0W2hJgJiluAx2r1ib1GB+YI3Mo3rXSaBYUk
` + `bgQuujYPctf0PA153RkeICE5GI3OaJ7u6j0caYEixBS3PDHt2MJWexITvXGwHWwc
` + `CcrC05RIrTUNOJaetQw8smVKYOfRImEzLLPZ5kf/H3Cbj8BNAFNsa10wgvlPuGOW
` + `XLXqzNXzrG4V3sjQU5YtisDMagwYaN3a6bBf1wFwFIHQoAPIgt8q5zaQ9WI+SBns
` + `Il6rd4zfvjq/BPmt0uI7rVg/cgbaEg/JDL2neuM9CJAzmKxYxLQuHSX2i3Fy4Y1B
` + `cnxnRQETCRZNPGd00ADyxPKVoYBC45/t+yVusArFt+2SVLEGiFBr23eG2CEZu+HS
` + `nDEgIfQ4V3YOTUNa86wvbAss1gbbnT/v1XCnNGClEWCWNCSRjwV2ZmQ/IVTmNHPo
` + `7axTTBBJbKJbKzFndCnuxnDXyytdYRgFU7Ly3sa27WS2KFyFEDebLFRHQEfoYqCu
` + `IupSqBSbXsR3U10OTjc9z6EPo1nuV6bdz+gEDthmxKa1NI+Qb1kvyliXQHL2lfhr
` + `5zT5+Bs=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/zCCA+egAwIBAgIRAOLV6zZcL4IV2xmEneN1GwswDQYJKoZIhvcNAQEMBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE5MDg1OFoYDzIxMjEwNTE5MjAwODU4WjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7koAKGXXlLixN
` + `fVjhuqvz0WxDeTQfhthPK60ekRpftkfE5QtnYGzeovaUAiS58MYVzqnnTACDwcJs
` + `IGTFE6Wd7sB6r8eI/3CwI1pyJfxepubiQNVAQG0zJETOVkoYKe/5KnteKtnEER3X
` + `tCBRdV/rfbxEDG9ZAsYfMl6zzhEWKF88G6xhs2+VZpDqwJNNALvQuzmTx8BNbl5W
` + `RUWGq9CQ9GK9GPF570YPCuURW7kl35skofudE9bhURNz51pNoNtk2Z3aEeRx3ouT
` + `ifFJlzh+xGJRHqBG7nt5NhX8xbg+vw4xHCeq1aAe6aVFJ3Uf9E2HzLB4SfIT9bRp
` + `P7c9c0ySGt+3n+KLSHFf/iQ3E4nft75JdPjeSt0dnyChi1sEKDi0tnWGiXaIg+J+
` + `r1ZtcHiyYpCB7l29QYMAdD0TjfDwwPayLmq//c20cPmnSzw271VwqjUT0jYdrNAm
` + `gV+JfW9t4ixtE3xF2jaUh/NzL3bAmN5v8+9k/aqPXlU1BgE3uPwMCjrfn7V0I7I1
` + `WLpHyd9jF3U/Ysci6H6i8YKgaPiOfySimQiDu1idmPld659qerutUSemQWmPD3bE
` + `dcjZolmzS9U0Ujq/jDF1YayN3G3xvry1qWkTci0qMRMu2dZu30Herugh9vsdTYkf
` + `00EqngPbqtIVLDrDjEQLqPcb8QvWFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBQBqg8Za/L0YMHURGExHfvPyfLbOTAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQEMBQADggIBACAGPMa1QL7P/FIO7jEtMelJ0hQlQepKnGtbKz4r
` + `Xq1bUX1jnLvnAieR9KZmeQVuKi3g3CDU6b0mDgygS+FL1KDDcGRCSPh238Ou8KcG
` + `HIxtt3CMwMHMa9gmdcMlR5fJF9vhR0C56KM2zvyelUY51B/HJqHwGvWuexryXUKa
` + `wq1/iK2/d9mNeOcjDvEIj0RCMI8dFQCJv3PRCTC36XS36Tzr6F47TcTw1c3mgKcs
` + `xpcwt7ezrXMUunzHS4qWAA5OGdzhYlcv+P5GW7iAA7TDNrBF+3W4a/6s9v2nQAnX
` + `UvXd9ul0ob71377UhZbJ6SOMY56+I9cJOOfF5QvaL83Sz29Ij1EKYw/s8TYdVqAq
` + `+dCyQZBkMSnDFLVe3J1KH2SUSfm3O98jdPORQrUlORQVYCHPls19l2F6lCmU7ICK
` + `hRt8EVSpXm4sAIA7zcnR2nU00UH8YmMQLnx5ok9YGhuh3Ehk6QlTQLJux6LYLskd
` + `9YHOLGW/t6knVtV78DgPqDeEx/Wu/5A8R0q7HunpWxr8LCPBK6hksZnOoUhhb8IP
` + `vl46Ve5Tv/FlkyYr1RTVjETmg7lb16a8J0At14iLtpZWmwmuv4agss/1iBVMXfFk
` + `+ZGtx5vytWU5XJmsfKA51KLsMQnhrLxb3X3zC+JRCyJoyc8++F3YEcRi2pkRYE3q
` + `Hing
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRANxgyBbnxgTEOpDul2ZnC0UwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNjEwMTgxOTA3WhgPMjA2MTA2MTAxOTE5MDda
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `xnwSDAChrMkfk5TA4Dk8hKzStDlSlONzmd3fTG0Wqr5+x3EmFT6Ksiu/WIwEl9J2
` + `K98UI7vYyuZfCxUKb1iMPeBdVGqk0zb92GpURd+Iz/+K1ps9ZLeGBkzR8mBmAi1S
` + `OfpwKiTBzIv6E8twhEn4IUpHsdcuX/2Y78uESpJyM8O5CpkG0JaV9FNEbDkJeBUQ
` + `Ao2qqNcH4R0Qcr5pyeqA9Zto1RswgL06BQMI9dTpfwSP5VvkvcNUaLl7Zv5WzLQE
` + `JzORWePvdPzzvWEkY/3FPjxBypuYwssKaERW0fkPDmPtykktP9W/oJolKUFI6pXp
` + `y+Y6p6/AVdnQD2zZjW5FhQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBT+jEKs96LC+/X4BZkUYUkzPfXdqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAIGQqgqcQ6XSGkmNebzR6DhadTbfDmbYeN5N0Vuzv+Tdmufb
` + `tMGjdjnYMg4B+IVnTKQb+Ox3pL9gbX6KglGK8HupobmIRtwKVth+gYYz3m0SL/Nk
` + `haWPYzOm0x3tJm8jSdufJcEob4/ATce9JwseLl76pSWdl5A4lLjnhPPKudUDfH+1
` + `BLNUi3lxpp6GkC8aWUPtupnhZuXddolTLOuA3GwTZySI44NfaFRm+o83N1jp+EwD
` + `6e94M4cTRzjUv6J3MZmSbdtQP/Tk1uz2K4bQZGP0PZC3bVpqiesdE/xr+wbu8uHr
` + `cM1JXH0AmXf1yIkTgyWzmvt0k1/vgcw5ixAqvvE=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEATCCAumgAwIBAgIRAMhw98EQU18mIji+unM2YH8wDQYJKoZIhvcNAQELBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQyMjJaGA8yMDYyMDYwNjIyNDIyMlowgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIeeRoLfTm+7
` + `vqm7ZlFSx+1/CGYHyYrOOryM4/Z3dqYVHFMgWTR7V3ziO8RZ6yUanrRcWVX3PZbF
` + `AfX0KFE8OgLsXEZIX8odSrq86+/Th5eZOchB2fDBsUB7GuN2rvFBbM8lTI9ivVOU
` + `lbuTnYyb55nOXN7TpmH2bK+z5c1y9RVC5iQsNAl6IJNvSN8VCqXh31eK5MlKB4DT
` + `+Y3OivCrSGsjM+UR59uZmwuFB1h+icE+U0p9Ct3Mjq3MzSX5tQb6ElTNGlfmyGpW
` + `Kh7GQ5XU1KaKNZXoJ37H53woNSlq56bpVrKI4uv7ATpdpFubOnSLtpsKlpLdR3sy
` + `Ws245200pC8CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUp0ki
` + `6+eWvsnBjQhMxwMW5pwn7DgwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUA
` + `A4IBAQB2V8lv0aqbYQpj/bmVv/83QfE4vOxKCJAHv7DQ35cJsTyBdF+8pBczzi3t
` + `3VNL5IUgW6WkyuUOWnE0eqAFOUVj0yTS1jSAtfl3vOOzGJZmWBbqm9BKEdu1D8O6
` + `sB8bnomwiab2tNDHPmUslpdDqdabbkWwNWzLJ97oGFZ7KNODMEPXWKWNxg33iHfS
` + `/nlmnrTVI3XgaNK9qLZiUrxu9Yz5gxi/1K+sG9/Dajd32ZxjRwDipOLiZbiXQrsd
` + `qzIMY4GcWf3g1gHL5mCTfk7dG22h/rhPyGV0svaDnsb+hOt6sv1McMN6Y3Ou0mtM
` + `/UaAXojREmJmTSCNvs2aBny3/2sy
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAMnRxsKLYscJV8Qv5pWbL7swCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTE5MTgxNjAxWhgPMjEyMTA1MTkxOTE2MDFaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgc2EtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjFOCZgTNVKxLKhUxffiDEvTLFhrmIqdO
` + `dKqVdgDoELEzIHWDdC+19aDPitbCYtBVHl65ITu/9pn6mMUl5hhUNtfZuc6A+Iw1
` + `sBe0v0qI3y9Q9HdQYrGgeHDh8M5P7E2ho0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBS5L7/8M0TzoBZk39Ps7BkfTB4yJTAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIwI43O0NtWKTgnVv9z0LO5UMZYgSve7GvGTwqktZYCMObE
` + `rUI4QerXM9D6JwLy09mqAjEAypfkdLyVWtaElVDUyHFkihAS1I1oUxaaDrynLNQK
` + `Ou/Ay+ns+J+GyvyDUjBpVVW1
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/jCCA+agAwIBAgIQR71Z8lTO5Sj+as2jB7IWXzANBgkqhkiG9w0BAQwFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTI0MjIwMzIwWhgPMjEyMTA1MjQyMzAzMjBaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM977bHIs1WJijrS
` + `XQMfUOhmlJjr2v0K0UjPl52sE1TJ76H8umo1yR4T7Whkd9IwBHNGKXCJtJmMr9zp
` + `fB38eLTu+5ydUAXdFuZpRMKBWwPVe37AdJRKqn5beS8HQjd3JXAgGKUNNuE92iqF
` + `qi2fIqFMpnJXWo0FIW6s2Dl2zkORd7tH0DygcRi7lgVxCsw1BJQhFJon3y+IV8/F
` + `bnbUXSNSDUnDW2EhvWSD8L+t4eiXYsozhDAzhBvojpxhPH9OB7vqFYw5qxFx+G0t
` + `lSLX5iWi1jzzc3XyGnB6WInZDVbvnvJ4BGZ+dTRpOCvsoMIn9bz4EQTvu243c7aU
` + `HbS/kvnCASNt+zk7C6lbmaq0AGNztwNj85Opn2enFciWZVnnJ/4OeefUWQxD0EPp
` + `SjEd9Cn2IHzkBZrHCg+lWZJQBKbUVS0lLIMSsLQQ6WvR38jY7D2nxM1A93xWxwpt
` + `ZtQnYRCVXH6zt2OwDAFePInWwxUjR5t/wu3XxPgpSfrmTi3WYtr1wFypAJ811e/P
` + `yBtswWUQ6BNJQvy+KnOEeGfOwmtdDFYR+GOCfvCihzrKJrxOtHIieehR5Iw3cbXG
` + `sm4pDzfMUVvDDz6C2M6PRlJhhClbatHCjik9hxFYEsAlqtVVK9pxaz9i8hOqSFQq
` + `kJSQsgWw+oM/B2CyjcSqkSQEu8RLAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w
` + `HQYDVR0OBBYEFPmrdxpRRgu3IcaB5BTqlprcKdTsMA4GA1UdDwEB/wQEAwIBhjAN
` + `BgkqhkiG9w0BAQwFAAOCAgEAVdlxWjPvVKky3kn8ZizeM4D+EsLw9dWLau2UD/ls
` + `zwDCFoT6euagVeCknrn+YEl7g20CRYT9iaonGoMUPuMR/cdtPL1W/Rf40PSrGf9q
` + `QuxavWiHLEXOQTCtCaVZMokkvjuuLNDXyZnstgECuiZECTwhexUF4oiuhyGk9o01
` + `QMaiz4HX4lgk0ozALUvEzaNd9gWEwD2qe+rq9cQMTVq3IArUkvTIftZUaVUMzr0O
` + `ed1+zAsNa9nJhURJ/6anJPJjbQgb5qA1asFcp9UaMT1ku36U3gnR1T/BdgG2jX3X
` + `Um0UcaGNVPrH1ukInWW743pxWQb7/2sumEEMVh+jWbB18SAyLI4WIh4lkurdifzS
` + `IuTFp8TEx+MouISFhz/vJDWZ84tqoLVjkEcP6oDypq9lFoEzHDJv3V1CYcIgOusT
` + `k1jm9P7BXdTG7TYzUaTb9USb6bkqkD9EwJAOSs7DI94aE6rsSws2yAHavjAMfuMZ
` + `sDAZvkqS2Qg2Z2+CI6wUZn7mzkJXbZoqRjDvChDXEB1mIhzVXhiNW/CR5WKVDvlj
` + `9v1sdGByh2pbxcLQtVaq/5coM4ANgphoNz3pOYUPWHS+JUrIivBZ+JobjXcxr3SN
` + `9iDzcu5/FVVNbq7+KN/nvPMngT+gduEN5m+EBjm8GukJymFG0m6BENRA0QSDqZ7k
` + `zDY=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRAK5EYG3iHserxMqgg+0EFjgwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyMzE2WhgPMjA2MTA1MjQyMTIzMTZa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `s1L6TtB84LGraLHVC+rGPhLBW2P0oN/91Rq3AnYwqDOuTom7agANwEjvLq7dSRG/
` + `sIfZsSV/ABTgArZ5sCmLjHFZAo8Kd45yA9byx20RcYtAG8IZl+q1Cri+s0XefzyO
` + `U6mlfXZkVe6lzjlfXBkrlE/+5ifVbJK4dqOS1t9cWIpgKqv5fbE6Qbq4LVT+5/WM
` + `Vd2BOljuBMGMzdZubqFKFq4mzTuIYfnBm7SmHlZfTdfBYPP1ScNuhpjuzw4n3NCR
` + `EdU6dQv04Q6th4r7eiOCwbWI9LkmVbvBe3ylhH63lApC7MiiPYLlB13xBubVHVhV
` + `q1NHoNTi+zA3MN9HWicRxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBSuxoqm0/wjNiZLvqv+JlQwsDvTPDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAFfTK/j5kv90uIbM8VaFdVbr/6weKTwehafT0pAk1bfLVX+7
` + `uf8oHgYiyKTTl0DFQicXejghXTeyzwoEkWSR8c6XkhD5vYG3oESqmt/RGvvoxz11
` + `rHHy7yHYu7RIUc3VQG60c4qxXv/1mWySGwVwJrnuyNT9KZXPevu3jVaWOVHEILaK
` + `HvzQ2YEcWBPmde/zEseO2QeeGF8FL45Q1d66wqIP4nNUd2pCjeTS5SpB0MMx7yi9
` + `ki1OH1pv8tOuIdimtZ7wkdB8+JSZoaJ81b8sRrydRwJyvB88rftuI3YB4WwGuONT
` + `ZezUPsmaoK69B0RChB0ofDpAaviF9V3xOWvVZfo=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGDzCCA/egAwIBAgIRAI0sMNG2XhaBMRN3zD7ZyoEwDQYJKoZIhvcNAQEMBQAw
` + `gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv
` + `QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzEx
` + `EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA1NzUwWhgPMjEyMTA1MTgyMTU3
` + `NTBaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl
` + `cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV
` + `BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2
` + `IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
` + `CgKCAgEAh/otSiCu4Uw3hu7OJm0PKgLsLRqBmUS6jihcrkxfN2SHmp2zuRflkweU
` + `BhMkebzL+xnNvC8okzbgPWtUxSmDnIRhE8J7bvSKFlqs/tmEdiI/LMqe/YIKcdsI
` + `20UYmvyLIjtDaJIh598SHHlF9P8DB5jD8snJfhxWY+9AZRN+YVTltgQAAgayxkWp
` + `M1BbvxpOnz4CC00rE0eqkguXIUSuobb1vKqdKIenlYBNxm2AmtgvQfpsBIQ0SB+8
` + `8Zip8Ef5rtjSw5J3s2Rq0aYvZPfCVIsKYepIboVwXtD7E9J31UkB5onLBQlaHaA6
` + `XlH4srsMmrew5d2XejQGy/lGZ1nVWNsKO0x/Az2QzY5Kjd6AlXZ8kq6H68hscA5i
` + `OMbNlXzeEQsZH0YkId3+UsEns35AAjZv4qfFoLOu8vDotWhgVNT5DfdbIWZW3ZL8
` + `qbmra3JnCHuaTwXMnc25QeKgVq7/rG00YB69tCIDwcf1P+tFJWxvaGtV0g2NthtB
` + `a+Xo09eC0L53gfZZ3hZw1pa3SIF5dIZ6RFRUQ+lFOux3Q/I3u+rYstYw7Zxc4Zeo
` + `Y8JiedpQXEAnbw2ECHix/L6mVWgiWCiDzBnNLLdbmXjJRnafNSndSfFtHCnY1SiP
` + `aCrNpzwZIJejoV1zDlWAMO+gyS28EqzuIq3WJK/TFE7acHkdKIcCAwEAAaNCMEAw
` + `DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrmV1YASnuudfmqAZP4sKGTvScaEw
` + `DgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBGpEKeQoPvE85tN/25
` + `qHFkys9oHDl93DZ62EnOqAUKLd6v0JpCyEiop4nlrJe+4KrBYVBPyKOJDcIqE2Sp
` + `3cvgJXLhY4i46VM3Qxe8yuYF1ElqBpg3jJVj/sCQnYz9dwoAMWIJFaDWOvmU2E7M
` + `MRaKx+sPXFkIjiDA6Bv0m+VHef7aedSYIY7IDltEQHuXoqNacGrYo3I50R+fZs88
` + `/mB3e/V7967e99D6565yf9Lcjw4oQf2Hy7kl/6P9AuMz0LODnGITwh2TKk/Zo3RU
` + `Vgq25RDrT4xJK6nFHyjUF6+4cOBxVpimmFw/VP1zaXT8DN5r4HyJ9p4YuSK8ha5N
` + `2pJc/exvU8Nv2+vS/efcDZWyuEdZ7eh1IJWQZlOZKIAONfRDRTpeQHJ3zzv3QVYy
` + `t78pYp/eWBHyVIfEE8p2lFKD4279WYe+Uvdb8c4Jm4TJwqkSJV8ifID7Ub80Lsir
` + `lPAU3OCVTBeVRFPXT2zpC4PB4W6KBSuj6OOcEu2y/HgWcoi7Cnjvp0vFTUhDFdus
` + `Wz3ucmJjfVsrkEO6avDKu4SwdbVHsk30TVAwPd6srIdi9U6MOeOQSOSE4EsrrS7l
` + `SVmu2QIDUVFpm8QAHYplkyWIyGkupyl3ashH9mokQhixIU/Pzir0byePxHLHrwLu
` + `1axqeKpI0F5SBUPsaVNYY2uNFg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECDCCAvCgAwIBAgIQCREfzzVyDTMcNME+gWnTCTANBgkqhkiG9w0BAQsFADCB
` + `nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB
` + `bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4G
` + `A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQyMzNaGA8yMDYxMDUyNDIxNDIzM1ow
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL
` + `1MT6br3L/4Pq87DPXtcjlXN3cnbNk2YqRAZHJayStTz8VtsFcGPJOpk14geRVeVk
` + `e9uKFHRbcyr/RM4owrJTj5X4qcEuATYZbo6ou/rW2kYzuWFZpFp7lqm0vasV4Z9F
` + `fChlhwkNks0UbM3G+psCSMNSoF19ERunj7w2c4E62LwujkeYLvKGNepjnaH10TJL
` + `2krpERd+ZQ4jIpObtRcMH++bTrvklc+ei8W9lqrVOJL+89v2piN3Ecdd389uphst
` + `qQdb1BBVXbhUrtuGHgVf7zKqN1SkCoktoWxVuOprVWhSvr7akaWeq0UmlvbEsujU
` + `vADqxGMcJFyCzxx3CkJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O
` + `BBYEFFk8UJmlhoxFT3PP12PvhvazHjT4MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG
` + `9w0BAQsFAAOCAQEAfFtr2lGoWVXmWAsIo2NYre7kzL8Xb9Tx7desKxCCz5HOOvIr
` + `8JMB1YK6A7IOvQsLJQ/f1UnKRh3X3mJZjKIywfrMSh0FiDf+rjcEzXxw2dGtUem4
` + `A+WMvIA3jwxnJ90OQj5rQ8bg3iPtE6eojzo9vWQGw/Vu48Dtw1DJo9210Lq/6hze
` + `hPhNkFh8fMXNT7Q1Wz/TJqJElyAQGNOXhyGpHKeb0jHMMhsy5UNoW5hLeMS5ffao
` + `TBFWEJ1gVfxIU9QRxSh+62m46JIg+dwDlWv8Aww14KgepspRbMqDuaM2cinoejv6
` + `t3dyOyHHrsOyv3ffZUKtQhQbQr+sUcL89lARsg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/zCCAuegAwIBAgIRAIJLTMpzGNxqHZ4t+c1MlCIwDQYJKoZIhvcNAQELBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBhcC1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNTIxMzAzM1oYDzIwNjEwNTI1MjIzMDMzWjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtdHut0ZhJ9Nn2
` + `MpVafFcwHdoEzx06okmmhjJsNy4l9QYVeh0UUoek0SufRNMRF4d5ibzpgZol0Y92
` + `/qKWNe0jNxhEj6sXyHsHPeYtNBPuDMzThfbvsLK8z7pBP7vVyGPGuppqW/6m4ZBB
` + `lcc9fsf7xpZ689iSgoyjiT6J5wlVgmCx8hFYc/uvcRtfd8jAHvheug7QJ3zZmIye
` + `V4htOW+fRVWnBjf40Q+7uTv790UAqs0Zboj4Yil+hER0ibG62y1g71XcCyvcVpto
` + `2/XW7Y9NCgMNqQ7fGN3wR1gjtSYPd7DO32LTzYhutyvfbpAZjsAHnoObmoljcgXI
` + `QjfBcCFpAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJI3aWLg
` + `CS5xqU5WYVaeT5s8lpO0MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC
` + `AQEAUwATpJOcGVOs3hZAgJwznWOoTzOVJKfrqBum7lvkVH1vBwxBl9CahaKj3ZOt
` + `YYp2qJzhDUWludL164DL4ZjS6eRedLRviyy5cRy0581l1MxPWTThs27z+lCC14RL
` + `PJZNVYYdl7Jy9Q5NsQ0RBINUKYlRY6OqGDySWyuMPgno2GPbE8aynMdKP+f6G/uE
` + `YHOf08gFDqTsbyfa70ztgVEJaRooVf5JJq4UQtpDvVswW2reT96qi6tXPKHN5qp3
` + `3wI0I1Mp4ePmiBKku2dwYzPfrJK/pQlvu0Gu5lKOQ65QdotwLAAoaFqrf9za1yYs
` + `INUkHLWIxDds+4OHNYcerGp5Dw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCTCCA/GgAwIBAgIRAIO6ldra1KZvNWJ0TA1ihXEwDQYJKoZIhvcNAQEMBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjE0NTA1WhgPMjEyMTA1MjEyMjQ1MDVa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
` + `sDN52Si9pFSyZ1ruh3xAN0nVqEs960o2IK5CPu/ZfshFmzAwnx/MM8EHt/jMeZtj
` + `SM58LADAsNDL01ELpFZATjgZQ6xNAyXRXE7RiTRUvNkK7O3o2qAGbLnJq/UqF7Sw
` + `LRnB8V6hYOv+2EjVnohtGCn9SUFGZtYDjWXsLd4ML4Zpxv0a5LK7oEC7AHzbUR7R
` + `jsjkrXqSv7GE7bvhSOhMkmgxgj1F3J0b0jdQdtyyj109aO0ATUmIvf+Bzadg5AI2
` + `A9UA+TUcGeebhpHu8AP1Hf56XIlzPpaQv3ZJ4vzoLaVNUC7XKzAl1dlvCl7Klg/C
` + `84qmbD/tjZ6GHtzpLKgg7kQEV7mRoXq8X4wDX2AFPPQl2fv+Kbe+JODqm5ZjGegm
` + `uskABBi8IFv1hYx9jEulZPxC6uD/09W2+niFm3pirnlWS83BwVDTUBzF+CooUIMT
` + `jhWkIIZGDDgMJTzouBHfoSJtS1KpUZi99m2WyVs21MNKHeWAbs+zmI6TO5iiMC+T
` + `uB8spaOiHFO1573Fmeer4sy3YA6qVoqVl6jjTQqOdy3frAMbCkwH22/crV8YA+08
` + `hLeHXrMK+6XUvU+EtHAM3VzcrLbuYJUI2XJbzTj5g0Eb8I8JWsHvWHR5K7Z7gceR
` + `78AzxQmoGEfV6KABNWKsgoCQnfb1BidDJIe3BsI0A6UCAwEAAaNCMEAwDwYDVR0T
` + `AQH/BAUwAwEB/zAdBgNVHQ4EFgQUABp0MlB14MSHgAcuNSOhs3MOlUcwDgYDVR0P
` + `AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCv4CIOBSQi/QR9NxdRgVAG/pAh
` + `tFJhV7OWb/wqwsNKFDtg6tTxwaahdCfWpGWId15OUe7G9LoPiKiwM9C92n0ZeHRz
` + `4ewbrQVo7Eu1JI1wf0rnZJISL72hVYKmlvaWaacHhWxvsbKLrB7vt6Cknxa+S993
` + `Kf8i2Psw8j5886gaxhiUtzMTBwoDWak8ZaK7m3Y6C6hXQk08+3pnIornVSFJ9dlS
` + `PAqt5UPwWmrEfF+0uIDORlT+cvrAwgSp7nUF1q8iasledycZ/BxFgQqzNwnkBDwQ
` + `Z/aM52ArGsTzfMhkZRz9HIEhz1/0mJw8gZtDVQroD8778h8zsx2SrIz7eWQ6uWsD
` + `QEeSWXpcheiUtEfzkDImjr2DLbwbA23c9LoexUD10nwohhoiQQg77LmvBVxeu7WU
` + `E63JqaYUlOLOzEmNJp85zekIgR8UTkO7Gc+5BD7P4noYscI7pPOL5rP7YLg15ZFi
` + `ega+G53NTckRXz4metsd8XFWloDjZJJq4FfD60VuxgXzoMNT9wpFTNSH42PR2s9L
` + `I1vcl3w8yNccs9se2utM2nLsItZ3J0m/+QSRiw9hbrTYTcM9sXki0DtH2kyIOwYf
` + `lOrGJDiYOIrXSQK36H0gQ+8omlrUTvUj4msvkXuQjlfgx6sgp2duOAfnGxE7uHnc
` + `UhnJzzoe6M+LfGHkVQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICuDCCAj2gAwIBAgIQSAG6j2WHtWUUuLGJTPb1nTAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMDE2MzgyNloYDzIxMjEwNTIwMTczODI2WjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE2eqwU4FOzW8RV1W381Bd
` + `olhDOrqoMqzWli21oDUt7y8OnXM/lmAuOS6sr8Nt61BLVbONdbr+jgCYw75KabrK
` + `ZGg3siqvMOgabIKkKuXO14wtrGyGDt7dnKXg5ERGYOZlo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBS1Acp2WYxOcblv5ikZ3ZIbRCCW+zAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAJL84J08PBprxmsAKPTotBuVI3MyW1r8
` + `xQ0i8lgCQUf8GcmYjQ0jI4oZyv+TuYJAcwIxAP9Xpzq0Docxb+4N1qVhpiOfWt1O
` + `FnemFiy9m1l+wv6p3riQMPV7mBVpklmijkIv3Q==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRALZLcqCVIJ25maDPE3sbPCIwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjEzOTM5WhgPMjA2MTA1MjEyMjM5Mzla
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `ypKc+6FfGx6Gl6fQ78WYS29QoKgQiur58oxR3zltWeg5fqh9Z85K5S3UbRSTqWWu
` + `Xcfnkz0/FS07qHX+nWAGU27JiQb4YYqhjZNOAq8q0+ptFHJ6V7lyOqXBq5xOzO8f
` + `+0DlbJSsy7GEtJp7d7QCM3M5KVY9dENVZUKeJwa8PC5StvwPx4jcLeZRJC2rAVDG
` + `SW7NAInbATvr9ssSh03JqjXb+HDyywiqoQ7EVLtmtXWimX+0b3/2vhqcH5jgcKC9
` + `IGFydrjPbv4kwMrKnm6XlPZ9L0/3FMzanXPGd64LQVy51SI4d5Xymn0Mw2kMX8s6
` + `Nf05OsWcDzJ1n6/Q1qHSxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBRmaIc8eNwGP7i6P7AJrNQuK6OpFzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAIBeHfGwz3S2zwIUIpqEEI5/sMySDeS+3nJR+woWAHeO0C8i
` + `BJdDh+kzzkP0JkWpr/4NWz84/IdYo1lqASd1Kopz9aT1+iROXaWr43CtbzjXb7/X
` + `Zv7eZZFC8/lS5SROq42pPWl4ekbR0w8XGQElmHYcWS41LBfKeHCUwv83ATF0XQ6I
` + `4t+9YSqZHzj4vvedrvcRInzmwWJaal9s7Z6GuwTGmnMsN3LkhZ+/GD6oW3pU/Pyh
` + `EtWqffjsLhfcdCs3gG8x9BbkcJPH5aPAVkPn4wc8wuXg6xxb9YGsQuY930GWTYRf
` + `schbgjsuqznW4HHakq4WNhs1UdTSTKkRdZz7FUQ=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEDzCCAvegAwIBAgIRAM2zAbhyckaqRim63b+Tib8wDQYJKoZIhvcNAQELBQAw
` + `gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv
` + `QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzEx
` + `EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA0OTQ1WhgPMjA2MTA1MTgyMTQ5
` + `NDVaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl
` + `cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV
` + `BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4
` + `IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
` + `CgKCAQEA1ybjQMH1MkbvfKsWJaCTXeCSN1SG5UYid+Twe+TjuSqaXWonyp4WRR5z
` + `tlkqq+L2MWUeQQAX3S17ivo/t84mpZ3Rla0cx39SJtP3BiA2BwfUKRjhPwOjmk7j
` + `3zrcJjV5k1vSeLNOfFFSlwyDiVyLAE61lO6onBx+cRjelu0egMGq6WyFVidTdCmT
` + `Q9Zw3W6LTrnPvPmEyjHy2yCHzH3E50KSd/5k4MliV4QTujnxYexI2eR8F8YQC4m3
` + `DYjXt/MicbqA366SOoJA50JbgpuVv62+LSBu56FpzY12wubmDZsdn4lsfYKiWxUy
` + `uc83a2fRXsJZ1d3whxrl20VFtLFHFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBRC0ytKmDYbfz0Bz0Psd4lRQV3aNTAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQELBQADggEBAGv8qZu4uaeoF6zsbumauz6ea6tdcWt+hGFuwGrb
` + `tRbI85ucAmVSX06x59DJClsb4MPhL1XmqO3RxVMIVVfRwRHWOsZQPnXm8OYQ2sny
` + `rYuFln1COOz1U/KflZjgJmxbn8x4lYiTPZRLarG0V/OsCmnLkQLPtEl/spMu8Un7
` + `r3K8SkbWN80gg17Q8EV5mnFwycUx9xsTAaFItuG0en9bGsMgMmy+ZsDmTRbL+lcX
` + `Fq8r4LT4QjrFz0shrzCwuuM4GmcYtBSxlacl+HxYEtAs5k10tmzRf6OYlY33tGf6
` + `1tkYvKryxDPF/EDgGp/LiBwx6ixYMBfISoYASt4V/ylAlHA=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtTCCAjqgAwIBAgIRAK9BSZU6nIe6jqfODmuVctYwCgYIKoZIzj0EAwMwgZkx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h
` + `em9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTIxMjIxMzA5WhgPMjEyMTA1MjEyMzEzMDlaMIGZMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv
` + `biBSRFMgY2EtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEUkEERcgxneT5H+P+fERcbGmf
` + `bVx+M7rNWtgWUr6w+OBENebQA9ozTkeSg4c4M+qdYSObFqjxITdYxT1z/nHz1gyx
` + `OKAhLjWu+nkbRefqy3RwXaWT680uUaAP6ccnkZOMo0IwQDAPBgNVHRMBAf8EBTAD
` + `AQH/MB0GA1UdDgQWBBSN6fxlg0s5Wny08uRBYZcQ3TUoyzAOBgNVHQ8BAf8EBAMC
` + `AYYwCgYIKoZIzj0EAwMDaQAwZgIxAORaz+MBVoFBTmZ93j2G2vYTwA6T5hWzBWrx
` + `CrI54pKn5g6At56DBrkjrwZF5T1enAIxAJe/LZ9xpDkAdxDgGJFN8gZYLRWc0NRy
` + `Rb4hihy5vj9L+w9uKc9VfEBIFuhT7Z3ljg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQB/57HSuaqUkLaasdjxUdPjANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE3NDAzNFoYDzIwNjEwNTE5MTg0MDM0WjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbkaoVsUS76o
` + `TgLFmcnaB8cswBk1M3Bf4IVRcwWT3a1HeJSnaJUqWHCJ+u3ip/zGVOYl0gN1MgBb
` + `MuQRIJiB95zGVcIa6HZtx00VezDTr3jgGWRHmRjNVCCHGmxOZWvJjsIE1xavT/1j
` + `QYV/ph4EZEIZ/qPq7e3rHohJaHDe23Z7QM9kbyqp2hANG2JtU/iUhCxqgqUHNozV
` + `Zd0l5K6KnltZQoBhhekKgyiHqdTrH8fWajYl5seD71bs0Axowb+Oh0rwmrws3Db2
` + `Dh+oc2PwREnjHeca9/1C6J2vhY+V0LGaJmnnIuOANrslx2+bgMlyhf9j0Bv8AwSi
` + `dSWsobOhNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQb7vJT
` + `VciLN72yJGhaRKLn6Krn2TAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAAxEj8N9GslReAQnNOBpGl8SLgCMTejQ6AW/bapQvzxrZrfVOZOYwp/5oV0f
` + `9S1jcGysDM+DrmfUJNzWxq2Y586R94WtpH4UpJDGqZp+FuOVJL313te4609kopzO
` + `lDdmd+8z61+0Au93wB1rMiEfnIMkOEyt7D2eTFJfJRKNmnPrd8RjimRDlFgcLWJA
` + `3E8wca67Lz/G0eAeLhRHIXv429y8RRXDtKNNz0wA2RwURWIxyPjn1fHjA9SPDkeW
` + `E1Bq7gZj+tBnrqz+ra3yjZ2blss6Ds3/uRY6NYqseFTZWmQWT7FolZEnT9vMUitW
` + `I0VynUbShVpGf6946e0vgaaKw20=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/jCCAuagAwIBAgIQGyUVTaVjYJvWhroVEiHPpDANBgkqhkiG9w0BAQsFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTE5MTkwNDA2WhgPMjA2MTA1MTkyMDA0MDZaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgdXMtd2VzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANhyXpJ0t4nigRDZ
` + `EwNtFOem1rM1k8k5XmziHKDvDk831p7QsX9ZOxl/BT59Pu/P+6W6SvasIyKls1sW
` + `FJIjFF+6xRQcpoE5L5evMgN/JXahpKGeQJPOX9UEXVW5B8yi+/dyUitFT7YK5LZA
` + `MqWBN/LtHVPa8UmE88RCDLiKkqiv229tmwZtWT7nlMTTCqiAHMFcryZHx0pf9VPh
` + `x/iPV8p2gBJnuPwcz7z1kRKNmJ8/cWaY+9w4q7AYlAMaq/rzEqDaN2XXevdpsYAK
` + `TMMj2kji4x1oZO50+VPNfBl5ZgJc92qz1ocF95SAwMfOUsP8AIRZkf0CILJYlgzk
` + `/6u6qZECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm5jfcS9o
` + `+LwL517HpB6hG+PmpBswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB
` + `AQAcQ6lsqxi63MtpGk9XK8mCxGRLCad51+MF6gcNz6i6PAqhPOoKCoFqdj4cEQTF
` + `F8dCfa3pvfJhxV6RIh+t5FCk/y6bWT8Ls/fYKVo6FhHj57bcemWsw/Z0XnROdVfK
` + `Yqbc7zvjCPmwPHEqYBhjU34NcY4UF9yPmlLOL8uO1JKXa3CAR0htIoW4Pbmo6sA4
` + `6P0co/clW+3zzsQ92yUCjYmRNeSbdXbPfz3K/RtFfZ8jMtriRGuO7KNxp8MqrUho
` + `HK8O0mlSUxGXBZMNicfo7qY8FD21GIPH9w5fp5oiAl7lqFzt3E3sCLD3IiVJmxbf
` + `fUwpGd1XZBBSdIxysRLM6j48
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrTCCAjOgAwIBAgIQU+PAILXGkpoTcpF200VD/jAKBggqhkjOPQQDAzCBljEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6
` + `b24gUkRTIGFwLWVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTAgFw0yMTA1MjUyMTQ1MTFaGA8yMTIxMDUyNTIyNDUxMVowgZYxCzAJBgNV
` + `BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD
` + `VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE
` + `UyBhcC1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw
` + `djAQBgcqhkjOPQIBBgUrgQQAIgNiAAT3tFKE8Kw1sGQAvNLlLhd8OcGhlc7MiW/s
` + `NXm3pOiCT4vZpawKvHBzD76Kcv+ZZzHRxQEmG1/muDzZGlKR32h8AAj+NNO2Wy3d
` + `CKTtYMiVF6Z2zjtuSkZQdjuQbe4eQ7qjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD
` + `VR0OBBYEFAiSQOp16Vv0Ohpvqcbd2j5RmhYNMA4GA1UdDwEB/wQEAwIBhjAKBggq
` + `hkjOPQQDAwNoADBlAjBVsi+5Ape0kOhMt/WFkANkslD4qXA5uqhrfAtH29Xzz2NV
` + `tR7akiA771OaIGB/6xsCMQCZt2egCtbX7J0WkuZ2KivTh66jecJr5DHvAP4X2xtS
` + `F/5pS+AUhcKTEGjI9jDH3ew=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICuDCCAj2gAwIBAgIQT5mGlavQzFHsB7hV6Mmy6TAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTAxNVoYDzIxMjEwNTI0MjE1MDE1WjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEcm4BBBjYK7clwm0HJRWS
` + `flt3iYwoJbIXiXn9c1y3E+Vb7bmuyKhS4eO8mwO4GefUcXObRfoHY2TZLhMJLVBQ
` + `7MN2xDc0RtZNj07BbGD3VAIFRTDX0mH9UNYd0JQM3t/Oo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBRrd5ITedfAwrGo4FA9UaDaGFK3rjAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAPBNqmVv1IIA3EZyQ6XuVf4gj79/DMO8
` + `bkicNS1EcBpUqbSuU4Zwt2BYc8c/t7KVOQIxAOHoWkoKZPiKyCxfMtJpCZySUG+n
` + `sXgB/LOyWE5BJcXUfm+T1ckeNoWeUUMOLmnJjg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRAJcDeinvdNrDQBeJ8+t38WQwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY0OTE2WhgPMjA2MjA1MjUxNzQ5MTZa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `k8DBNkr9tMoIM0NHoFiO7cQfSX0cOMhEuk/CHt0fFx95IBytx7GHCnNzpM27O5z6
` + `x6iRhfNnx+B6CrGyCzOjxvPizneY+h+9zfvNz9jj7L1I2uYMuiNyOKR6FkHR46CT
` + `1CiArfVLLPaTqgD/rQjS0GL2sLHS/0dmYipzynnZcs613XT0rAWdYDYgxDq7r/Yi
` + `Xge5AkWQFkMUq3nOYDLCyGGfQqWKkwv6lZUHLCDKf+Y0Uvsrj8YGCI1O8mF0qPCQ
` + `lmlfaDvbuBu1AV+aabmkvyFj3b8KRIlNLEtQ4N8KGYR2Jdb82S4YUGIOAt4wuuFt
` + `1B7AUDLk3V/u+HTWiwfoLQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBSNpcjz6ArWBtAA+Gz6kyyZxrrgdDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAGJEd7UgOzHYIcQRSF7nSYyjLROyalaIV9AX4WXW/Cqlul1c
` + `MblP5etDZm7A/thliZIWAuyqv2bNicmS3xKvNy6/QYi1YgxZyy/qwJ3NdFl067W0
` + `t8nGo29B+EVK94IPjzFHWShuoktIgp+dmpijB7wkTIk8SmIoe9yuY4+hzgqk+bo4
` + `ms2SOXSN1DoQ75Xv+YmztbnZM8MuWhL1T7hA4AMorzTQLJ9Pof8SpSdMHeDsHp0R
` + `01jogNFkwy25nw7cL62nufSuH2fPYGWXyNDg+y42wKsKWYXLRgUQuDVEJ2OmTFMB
` + `T0Vf7VuNijfIA9hkN2d3K53m/9z5WjGPSdOjGhg=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/jCCAuagAwIBAgIQRiwspKyrO0xoxDgSkqLZczANBgkqhkiG9w0BAQsFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTI0MjE1OTAwWhgPMjA2MTA1MjQyMjU5MDBaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL53Jk3GsKiu+4bx
` + `jDfsevWbwPCNJ3H08Zp7GWhvI3Tgi39opfHYv2ku2BKFjK8N2L6RvNPSR8yplv5j
` + `Y0tK0U+XVNl8o0ibhqRDhbTuh6KL8CFINWYzAajuxFS+CF0U6c1Q3tXLBdALxA7l
` + `FlXJ71QrP06W31kRe7kvgrvO7qWU3/OzUf9qYw4LSiR1/VkvvRCTqcVNw09clw/M
` + `Jbw6FSgweN65M9j7zPbjGAXSHkXyxH1Erin2fa+B9PE4ZDgX9cp2C1DHewYJQL/g
` + `SepwwcudVNRN1ibKH7kpMrgPnaNIVNx5sXVsTjk6q2ZqYw3SVHegltJpLy/cZReP
` + `mlivF2kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUmTcQd6o1
` + `CuS65MjBrMwQ9JJjmBwwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB
` + `AQAKSDSIzl956wVddPThf2VAzI8syw9ngSwsEHZvxVGHBvu5gg618rDyguVCYX9L
` + `4Kw/xJrk6S3qxOS2ZDyBcOpsrBskgahDFIunzoRP3a18ARQVq55LVgfwSDQiunch
` + `Bd05cnFGLoiLkR5rrkgYaP2ftn3gRBRaf0y0S3JXZ2XB3sMZxGxavYq9mfiEcwB0
` + `LMTMQ1NYzahIeG6Jm3LqRqR8HkzP/Ztq4dT2AtSLvFebbNMiWqeqT7OcYp94HTYT
` + `zqrtaVdUg9bwyAUCDgy0GV9RHDIdNAOInU/4LEETovrtuBU7Z1q4tcHXvN6Hd1H8
` + `gMb0mCG5I393qW5hFsA/diFb
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRAPQAvihfjBg/JDbj6U64K98wDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYyODQxWhgPMjA2MTA1MjAxNzI4NDFa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `vJ9lgyksCxkBlY40qOzI1TCj/Q0FVGuPL/Z1Mw2YN0l+41BDv0FHApjTUkIKOeIP
` + `nwDwpXTa3NjYbk3cOZ/fpH2rYJ++Fte6PNDGPgKppVCUh6x3jiVZ1L7wOgnTdK1Q
` + `Trw8440IDS5eLykRHvz8OmwvYDl0iIrt832V0QyOlHTGt6ZJ/aTQKl12Fy3QBLv7
` + `stClPzvHTrgWqVU6uidSYoDtzHbU7Vda7YH0wD9IUoMBf7Tu0rqcE4uH47s2XYkc
` + `SdLEoOg/Ngs7Y9B1y1GCyj3Ux7hnyvCoRTw014QyNB7dTatFMDvYlrRDGG14KeiU
` + `UL7Vo/+EejWI31eXNLw84wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBQkgTWFsNg6wA3HbbihDQ4vpt1E2zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAGz1Asiw7hn5WYUj8RpOCzpE0h/oBZcnxP8wulzZ5Xd0YxWO
` + `0jYUcUk3tTQy1QvoY+Q5aCjg6vFv+oFBAxkib/SmZzp4xLisZIGlzpJQuAgRkwWA
` + `6BVMgRS+AaOMQ6wKPgz1x4v6T0cIELZEPq3piGxvvqkcLZKdCaeC3wCS6sxuafzZ
` + `4qA3zMwWuLOzRftgX2hQto7d/2YkRXga7jSvQl3id/EI+xrYoH6zIWgjdU1AUaNq
` + `NGT7DIo47vVMfnd9HFZNhREsd4GJE83I+JhTqIxiKPNxrKgESzyADmNPt0gXDnHo
` + `tbV1pMZz5HpJtjnP/qVZhEK5oB0tqlKPv9yx074=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICuTCCAj6gAwIBAgIRAKp1Rn3aL/g/6oiHVIXtCq8wCgYIKoZIzj0EAwMwgZsx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h
` + `em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MjQyMDMyMTdaGA8yMTIxMDUyNDIxMzIxN1owgZsx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h
` + `em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABGTYWPILeBJXfcL3Dz4z
` + `EWMUq78xB1HpjBwHoTURYfcMd5r96BTVG6yaUBWnAVCMeeD6yTG9a1eVGNhG14Hk
` + `ZAEjgLiNB7RRbEG5JZ/XV7W/vODh09WCst2y9SLKsdgeAaNCMEAwDwYDVR0TAQH/
` + `BAUwAwEB/zAdBgNVHQ4EFgQUoE0qZHmDCDB+Bnm8GUa/evpfPwgwDgYDVR0PAQH/
` + `BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCnil5MMwhY3qoXv0xvcKZGxGPaBV15
` + `0CCssCKn0oVtdJQfJQ3Jrf3RSaEyijXIJsoCMQC35iJi4cWoNX3N/qfgnHohW52O
` + `B5dg0DYMqy5cNZ40+UcAanRMyqNQ6P7fy3umGco=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtzCCAj2gAwIBAgIQPXnDTPegvJrI98qz8WxrMjAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxODIxNDAxMloYDzIxMjEwNTE4MjI0MDEyWjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEI0sR7gwutK5AB46hM761
` + `gcLTGBIYlURSEoM1jcBwy56CL+3CJKZwLLyJ7qoOKfWbu5GsVLUTWS8MV6Nw33cx
` + `2KQD2svb694wi+Px2f4n9+XHkEFQw8BbiodDD7RZA70fo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBTQSioOvnVLEMXwNSDg+zgln/vAkjAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAMwu1hqm5Bc98uE/E0B5iMYbBQ4kpMxO
` + `tP8FTfz5UR37HUn26nXE0puj6S/Ffj4oJgIwXI7s2c26tFQeqzq6u3lrNJHp5jC9
` + `Uxlo/hEJOLoDj5jnpxo8dMAtCNoQPaHdfL0P
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjWgAwIBAgIQGKVv+5VuzEZEBzJ+bVfx2zAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTE5MTc1MDU5WhgPMjEyMTA1MTkxODUwNTlaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgYXAtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABMqdLJ0tZF/DGFZTKZDrGRJZID8ivC2I
` + `JRCYTWweZKCKSCAzoiuGGHzJhr5RlLHQf/QgmFcgXsdmO2n3CggzhA4tOD9Ip7Lk
` + `P05eHd2UPInyPCHRgmGjGb0Z+RdQ6zkitKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUC1yhRgVqU5bR8cGzOUCIxRpl4EYwDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2cAMGQCMG0c/zLGECRPzGKJvYCkpFTCUvdP4J74YP0v/dPvKojL
` + `t/BrR1Tg4xlfhaib7hPc7wIwFvgqHes20CubQnZmswbTKLUrgSUW4/lcKFpouFd2
` + `t2/ewfi/0VhkeUW+IiHhOMdU
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCTCCA/GgAwIBAgIRAOXxJuyXVkbfhZCkS/dOpfEwDQYJKoZIhvcNAQEMBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1OTEwWhgPMjEyMTA1MjUyMjU5MTBa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
` + `xiP4RDYm4tIS12hGgn1csfO8onQDmK5SZDswUpl0HIKXOUVVWkHNlINkVxbdqpqH
` + `FhbyZmNN6F/EWopotMDKe1B+NLrjNQf4zefv2vyKvPHJXhxoKmfyuTd5Wk8k1F7I
` + `lNwLQzznB+ElhrLIDJl9Ro8t31YBBNFRGAGEnxyACFGcdkjlsa52UwfYrwreEg2l
` + `gW5AzqHgjFfj9QRLydeU/n4bHm0F1adMsV7P3rVwilcUlqsENDwXnWyPEyv3sw6F
` + `wNemLEs1129mB77fwvySb+lLNGsnzr8w4wdioZ74co+T9z2ca+eUiP+EQccVw1Is
` + `D4Fh57IjPa6Wuc4mwiUYKkKY63+38aCfEWb0Qoi+zW+mE9nek6MOQ914cN12u5LX
` + `dBoYopphRO5YmubSN4xcBy405nIdSdbrAVWwxXnVVyjqjknmNeqQsPZaxAhdoKhV
` + `AqxNr8AUAdOAO6Sz3MslmcLlDXFihrEEOeUbpg/m1mSUUHGbu966ajTG1FuEHHwS
` + `7WB52yxoJo/tHvt9nAWnh3uH5BHmS8zn6s6CGweWKbX5yICnZ1QFR1e4pogxX39v
` + `XD6YcNOO+Vn+HY4nXmjgSYVC7l+eeP8eduMg1xJujzjrbmrXU+d+cBObgdTOAlpa
` + `JFHaGwYw1osAwPCo9cZ2f04yitBfj9aPFia8ASKldakCAwEAAaNCMEAwDwYDVR0T
` + `AQH/BAUwAwEB/zAdBgNVHQ4EFgQUqKS+ltlior0SyZKYAkJ/efv55towDgYDVR0P
` + `AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQAdElvp8bW4B+Cv+1WSN87dg6TN
` + `wGyIjJ14/QYURgyrZiYpUmZpj+/pJmprSWXu4KNyqHftmaidu7cdjL5nCAvAfnY5
` + `/6eDDbX4j8Gt9fb/6H9y0O0dn3mUPSEKG0crR+JRFAtPhn/2FNvst2P82yguWLv0
` + `pHjHVUVcq+HqDMtUIJsTPYjSh9Iy77Q6TOZKln9dyDOWJpCSkiUWQtMAKbCSlvzd
` + `zTs/ahqpT+zLfGR1SR+T3snZHgQnbnemmz/XtlKl52NxccARwfcEEKaCRQyGq/pR
` + `0PVZasyJS9JY4JfQs4YOdeOt4UMZ8BmW1+BQWGSkkb0QIRl8CszoKofucAlqdPcO
` + `IT/ZaMVhI580LFGWiQIizWFskX6lqbCyHqJB3LDl8gJISB5vNTHOHpvpMOMs5PYt
` + `cRl5Mrksx5MKMqG7y5R734nMlZxQIHjL5FOoOxTBp9KeWIL/Ib89T2QDaLw1SQ+w
` + `ihqWBJ4ZdrIMWYpP3WqM+MXWk7WAem+xsFJdR+MDgOOuobVQTy5dGBlPks/6gpjm
` + `rO9TjfQ36ppJ3b7LdKUPeRfnYmlR5RU4oyYJ//uLbClI443RZAgxaCXX/nyc12lr
` + `eVLUMNF2abLX4/VF63m2/Z9ACgMRfqGshPssn1NN33OonrotQoj4S3N9ZrjvzKt8
` + `iHcaqd60QKpfiH2A3A==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICuDCCAj2gAwIBAgIQPaVGRuu86nh/ylZVCLB0MzAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNTIyMDMxNloYDzIxMjEwNTI1MjMwMzE2WjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEexNURoB9KE93MEtEAlJG
` + `obz4LS/pD2hc8Gczix1WhVvpJ8bN5zCDXaKdnDMCebetyRQsmQ2LYlfmCwpZwSDu
` + `0zowB11Pt3I5Avu2EEcuKTlKIDMBeZ1WWuOd3Tf7MEAMo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBSaYbZPBvFLikSAjpa8mRJvyArMxzAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAOEJkuh3Zjb7Ih/zuNRd1RBqmIYcnyw0
` + `nwUZczKXry+9XebYj3VQxSRNadrarPWVqgIxAMg1dyGoDAYjY/L/9YElyMnvHltO
` + `PwpJShmqHvCLc/mXMgjjYb/akK7yGthvW6j/uQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCDCCA/CgAwIBAgIQChu3v5W1Doil3v6pgRIcVzANBgkqhkiG9w0BAQwFADCB
` + `nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB
` + `bWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G
` + `A1UEBwwHU2VhdHRsZTAgFw0yMTA1MTgyMTM0MTVaGA8yMTIxMDUxODIyMzQxNVow
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1
` + `FUGQ5tf3OwpDR6hGBxhUcrkwKZhaXP+1St1lSOQvjG8wXT3RkKzRGMvb7Ee0kzqI
` + `mzKKe4ASIhtV3UUWdlNmP0EA3XKnif6N79MismTeGkDj75Yzp5A6tSvqByCgxIjK
` + `JqpJrch3Dszoyn8+XhwDxMZtkUa5nQVdJgPzJ6ltsQ8E4SWLyLtTu0S63jJDkqYY
` + `S7cQblk7y7fel+Vn+LS5dGTdRRhMvSzEnb6mkVBaVzRyVX90FNUED06e8q+gU8Ob
` + `htvQlf9/kRzHwRAdls2YBhH40ZeyhpUC7vdtPwlmIyvW5CZ/QiG0yglixnL6xahL
` + `pbmTuTSA/Oqz4UGQZv2WzHe1lD2gRHhtFX2poQZeNQX8wO9IcUhrH5XurW/G9Xwl
` + `Sat9CMPERQn4KC3HSkat4ir2xaEUrjfg6c4XsGyh2Pk/LZ0gLKum0dyWYpWP4JmM
` + `RQNjrInXPbMhzQObozCyFT7jYegS/3cppdyy+K1K7434wzQGLU1gYXDKFnXwkX8R
` + `bRKgx2pHNbH5lUddjnNt75+e8m83ygSq/ZNBUz2Ur6W2s0pl6aBjwaDES4VfWYlI
` + `jokcmrGvJNDfQWygb1k00eF2bzNeNCHwgWsuo3HSxVgc/WGsbcGrTlDKfz+g3ich
` + `bXUeUidPhRiv5UQIVCLIHpHuin3bj9lQO/0t6p+tAQIDAQABo0IwQDAPBgNVHRMB
` + `Af8EBTADAQH/MB0GA1UdDgQWBBSFmMBgm5IsRv3hLrvDPIhcPweXYTAOBgNVHQ8B
` + `Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAAa2EuozymOsQDJlEi7TqnyA2OhT
` + `GXPfYqCyMJVkfrqNgcnsNpCAiNEiZbb+8sIPXnT8Ay8hrwJYEObJ5b7MHXpLuyft
` + `z0Pu1oFLKnQxKjNxrIsCvaB4CRRdYjm1q7EqGhMGv76se9stOxkOqO9it31w/LoU
` + `ENDk7GLsSqsV1OzYLhaH8t+MaNP6rZTSNuPrHwbV3CtBFl2TAZ7iKgKOhdFz1Hh9
` + `Pez0lG+oKi4mHZ7ajov6PD0W7njn5KqzCAkJR6OYmlNVPjir+c/vUtEs0j+owsMl
` + `g7KE5g4ZpTRShyh5BjCFRK2tv0tkqafzNtxrKC5XNpEkqqVTCnLcKG+OplIEadtr
` + `C7UWf4HyhCiR+xIyxFyR05p3uY/QQU/5uza7GlK0J+U1sBUytx7BZ+Fo8KQfPPqV
` + `CqDCaYUksoJcnJE/KeoksyqNQys7sDGJhkd0NeUGDrFLKHSLhIwAMbEWnqGxvhli
` + `E7sP2E5rI/I9Y9zTbLIiI8pfeZlFF8DBdoP/Hzg8pqsiE/yiXSFTKByDwKzGwNqz
` + `F0VoFdIZcIbLdDbzlQitgGpJtvEL7HseB0WH7B2PMMD8KPJlYvPveO3/6OLzCsav
` + `+CAkvk47NQViKMsUTKOA0JDCW+u981YRozxa3K081snhSiSe83zIPBz1ikldXxO9
` + `6YYLNPRrj3mi9T/f
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAMkvdFnVDb0mWWFiXqnKH68wCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTE5MTkxMzI0WhgPMjEyMTA1MTkyMDEzMjRaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgdXMtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEy86DB+9th/0A5VcWqMSWDxIUblWTt/R0
` + `ao6Z2l3vf2YDF2wt1A2NIOGpfQ5+WAOJO/IQmnV9LhYo+kacB8sOnXdQa6biZZkR
` + `IyouUfikVQAKWEJnh1Cuo5YMM4E2sUt5o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBQ8u3OnecANmG8OoT7KLWDuFzZwBTAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIwQ817qkb7mWJFnieRAN+m9W3E0FLVKaV3zC5aYJUk2fcZ
` + `TaUx3oLp3jPLGvY5+wgeAjEA6wAicAki4ZiDfxvAIuYiIe1OS/7H5RA++R8BH6qG
` + `iRzUBM/FItFpnkus7u/eTkvo
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrzCCAjWgAwIBAgIQS/+Ryfgb/IOVEa1pWoe8oTAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGFwLXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjIwNjA2MjE1NDQyWhgPMjEyMjA2MDYyMjU0NDJaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgYXAtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDsX6fhdUWBQpYTdseBD/P3s96Dtw2Iw
` + `OrXKNToCnmX5nMkUGdRn9qKNiz1pw3EPzaPxShbYwQ7LYP09ENK/JN4QQjxMihxC
` + `jLFxS85nhBQQQGRCWikDAe38mD8fSvREQKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUIh1xZiseQYFjPYKJmGbruAgRH+AwDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2gAMGUCMFudS4zLy+UUGrtgNLtRMcu/DZ9BUzV4NdHxo0bkG44O
` + `thnjl4+wTKI6VbyAbj2rkgIxAOHps8NMITU5DpyiMnKTxV8ubb/WGHrLl0BjB8Lw
` + `ETVJk5DNuZvsIIcm7ykk6iL4Tw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGBDCCA+ygAwIBAgIQDcEmNIAVrDpUw5cH5ynutDANBgkqhkiG9w0BAQwFADCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwIBcNMjIwNTA3MDA0MDIzWhgPMjEyMjA1MDcwMTQwMjNaMIGa
` + `MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j
` + `LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt
` + `YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvADk8t
` + `Fl9bFlU5sajLPPDSOUpPAkKs6iPlz+27o1GJC88THcOvf3x0nVAcu9WYe9Qaas+4
` + `j4a0vv51agqyODRD/SNi2HnqW7DbtLPAm6KBHe4twl28ItB/JD5g7u1oPAHFoXMS
` + `cH1CZEAs5RtlZGzJhcBXLFsHNv/7+SCLyZ7+2XFh9OrtgU4wMzkHoRNndhfwV5bu
` + `17bPTwuH+VxH37zXf1mQ/KjhuJos0C9dL0FpjYBAuyZTAWhZKs8dpSe4DI544z4w
` + `gkwUB4bC2nA1TBzsywEAHyNuZ/xRjNpWvx0ToWAA2iFJqC3VO3iKcnBplMvaUuMt
` + `jwzVSNBnKcoabXCZL2XDLt4YTZR8FSwz05IvsmwcPB7uNTBXq3T9sjejW8QQK3vT
` + `tzyfLq4jKmQE7PoS6cqYm+hEPm2hDaC/WP9bp3FdEJxZlPH26fq1b7BWYWhQ9pBA
` + `Nv9zTnzdR1xohTyOJBUFQ81ybEzabqXqVXUIANqIOaNcTB09/sLJ7+zuMhp3mwBu
` + `LtjfJv8PLuT1r63bU3seROhKA98b5KfzjvbvPSg3vws78JQyoYGbqNyDfyjVjg3U
` + `v//AdVuPie6PNtdrW3upZY4Qti5IjP9e3kimaJ+KAtTgMRG56W0WxD3SP7+YGGbG
` + `KhntDOkKsN39hLpn9UOafTIqFu7kIaueEy/NAgMBAAGjQjBAMA8GA1UdEwEB/wQF
` + `MAMBAf8wHQYDVR0OBBYEFHAems86dTwdZbLe8AaPy3kfIUVoMA4GA1UdDwEB/wQE
` + `AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOBHpp0ICx81kmeoBcZTrMdJs2gnhcd85
` + `FoSCjXx9H5XE5rmN/lQcxxOgj8hr3uPuLdLHu+i6THAyzjrl2NA1FWiqpfeECGmy
` + `0jm7iZsYORgGQYp/VKnDrwnKNSqlZvOuRr0kfUexwFlr34Y4VmupvEOK/RdGsd3S
` + `+3hiemcHse9ST/sJLHx962AWMkN86UHPscJEe4+eT3f2Wyzg6La8ARwdWZSNS+WH
` + `ZfybrncMmuiXuUdHv9XspPsqhKgtHhcYeXOGUtrwQPLe3+VJZ0LVxhlTWr9951GZ
` + `GfmWwTV/9VsyKVaCFIXeQ6L+gjcKyEzYF8wpMtQlSc7FFqwgC4bKxvMBSaRy88Nr
` + `lV2+tJD/fr8zGUeBK44Emon0HKDBWGX+/Hq1ZIv0Da0S+j6LbA4fusWxtGfuGha+
` + `luhHgVInCpALIOamiBEdGhILkoTtx7JrYppt3/Raqg9gUNCOOYlCvGhqX7DXeEfL
` + `DGabooiY2FNWot6h04JE9nqGj5QqT8D6t/TL1nzxhRPzbcSDIHUd/b5R+a0bAA+7
` + `YTU6JqzEVCWKEIEynYmqikgLMGB/OzWsgyEL6822QW6hJAQ78XpbNeCzrICF4+GC
` + `7KShLnwuWoWpAb26268lvOEvCTFM47VC6jNQl97md+2SA9Ma81C9wflid2M83Wle
` + `cuLMVcQZceE=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQAhAteLRCvizAElaWORFU2zANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMDE3MDkxNloYDzIwNjEwNTIwMTgwOTE2WjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+qg7JAcOVKjh
` + `N83SACnBFZPyB63EusfDr/0V9ZdL8lKcmZX9sv/CqoBo3N0EvBqHQqUUX6JvFb7F
` + `XrMUZ740kr28gSRALfXTFgNODjXeDsCtEkKRTkac/UM8xXHn+hR7UFRPHS3e0GzI
` + `iLiwQWDkr0Op74W8aM0CfaVKvh2bp4BI1jJbdDnQ9OKXpOxNHGUf0ZGb7TkNPkgI
` + `b2CBAc8J5o3H9lfw4uiyvl6Fz5JoP+A+zPELAioYBXDrbE7wJeqQDJrETWqR9VEK
` + `BXURCkVnHeaJy123MpAX2ozf4pqk0V0LOEOZRS29I+USF5DcWr7QIXR/w2I8ws1Q
` + `7ys+qbE+kQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQFJ16n
` + `1EcCMOIhoZs/F9sR+Jy++zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAOc5nXbT3XTDEZsxX2iD15YrQvmL5m13B3ImZWpx/pqmObsgx3/dg75rF2nQ
` + `qS+Vl+f/HLh516pj2BPP/yWCq12TRYigGav8UH0qdT3CAClYy2o+zAzUJHm84oiB
` + `ud+6pFVGkbqpsY+QMpJUbZWu52KViBpJMYsUEy+9cnPSFRVuRAHjYynSiLk2ZEjb
` + `Wkdc4x0nOZR5tP0FgrX0Ve2KcjFwVQJVZLgOUqmFYQ/G0TIIGTNh9tcmR7yp+xJR
` + `A2tbPV2Z6m9Yxx4E8lLEPNuoeouJ/GR4CkMEmF8cLwM310t174o3lKKUXJ4Vs2HO
` + `Wj2uN6R9oI+jGLMSswTzCNV1vgc=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICuDCCAj6gAwIBAgIRAOocLeZWjYkG/EbHmscuy8gwCgYIKoZIzj0EAwMwgZsx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h
` + `em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MjEyMTUwMDFaGA8yMTIxMDUyMTIyNTAwMVowgZsx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h
` + `em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABCEr3jq1KtRncnZfK5cq
` + `btY0nW6ZG3FMbh7XwBIR6Ca0f8llGZ4vJEC1pXgiM/4Dh045B9ZIzNrR54rYOIfa
` + `2NcYZ7mk06DjIQML64hbAxbQzOAuNzLPx268MrlL2uW2XaNCMEAwDwYDVR0TAQH/
` + `BAUwAwEB/zAdBgNVHQ4EFgQUln75pChychwN4RfHl+tOinMrfVowDgYDVR0PAQH/
` + `BAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMGiyPINRU1mwZ4Crw01vpuPvxZxb2IOr
` + `yX3RNlOIu4We1H+5dQk5tIvH8KGYFbWEpAIxAO9NZ6/j9osMhLgZ0yj0WVjb+uZx
` + `YlZR9fyFisY/jNfX7QhSk+nrc3SFLRUNtpXrng==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBTCCAu2gAwIBAgIRAKiaRZatN8eiz9p0s0lu0rQwDQYJKoZIhvcNAQELBQAw
` + `gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq
` + `QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD
` + `VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDIzNVoYDzIwNjEwNTIxMjMwMjM1WjCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCygVMf
` + `qB865IR9qYRBRFHn4eAqGJOCFx+UbraQZmjr/mnRqSkY+nhbM7Pn/DWOrRnxoh+w
` + `q5F9ZxdZ5D5T1v6kljVwxyfFgHItyyyIL0YS7e2h7cRRscCM+75kMedAP7icb4YN
` + `LfWBqfKHbHIOqvvQK8T6+Emu/QlG2B5LvuErrop9K0KinhITekpVIO4HCN61cuOe
` + `CADBKF/5uUJHwS9pWw3uUbpGUwsLBuhJzCY/OpJlDqC8Y9aToi2Ivl5u3/Q/sKjr
` + `6AZb9lx4q3J2z7tJDrm5MHYwV74elGSXoeoG8nODUqjgklIWAPrt6lQ3WJpO2kug
` + `8RhCdSbWkcXHfX95AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE
` + `FOIxhqTPkKVqKBZvMWtKewKWDvDBMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B
` + `AQsFAAOCAQEAqoItII89lOl4TKvg0I1EinxafZLXIheLcdGCxpjRxlZ9QMQUN3yb
` + `y/8uFKBL0otbQgJEoGhxm4h0tp54g28M6TN1U0332dwkjYxUNwvzrMaV5Na55I2Z
` + `1hq4GB3NMXW+PvdtsgVOZbEN+zOyOZ5MvJHEQVkT3YRnf6avsdntltcRzHJ16pJc
` + `Y8rR7yWwPXh1lPaPkxddrCtwayyGxNbNmRybjR48uHRhwu7v2WuAMdChL8H8bp89
` + `TQLMrMHgSbZfee9hKhO4Zebelf1/cslRSrhkG0ESq6G5MUINj6lMg2g6F0F7Xz2v
` + `ncD/vuRN5P+vT8th/oZ0Q2Gc68Pun0cn/g==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/zCCAuegAwIBAgIRAJYlnmkGRj4ju/2jBQsnXJYwDQYJKoZIhvcNAQELBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMTIzMDQ0NFoYDzIwNjEwNTIyMDAwNDQ0WjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC74V3eigv+pCj5
` + `nqDBqplY0Jp16pTeNB06IKbzb4MOTvNde6QjsZxrE1xUmprT8LxQqN9tI3aDYEYk
` + `b9v4F99WtQVgCv3Y34tYKX9NwWQgwS1vQwnIR8zOFBYqsAsHEkeJuSqAB12AYUSd
` + `Zv2RVFjiFmYJho2X30IrSLQfS/IE3KV7fCyMMm154+/K1Z2IJlcissydEAwgsUHw
` + `edrE6CxJVkkJ3EvIgG4ugK/suxd8eEMztaQYJwSdN8TdfT59LFuSPl7zmF3fIBdJ
` + `//WexcQmGabaJ7Xnx+6o2HTfkP8Zzzzaq8fvjAcvA7gyFH5EP26G2ZqMG+0y4pTx
` + `SPVTrQEXAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIWWuNEF
` + `sUMOC82XlfJeqazzrkPDMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC
` + `AQEAgClmxcJaQTGpEZmjElL8G2Zc8lGc+ylGjiNlSIw8X25/bcLRptbDA90nuP+q
` + `zXAMhEf0ccbdpwxG/P5a8JipmHgqQLHfpkvaXx+0CuP++3k+chAJ3Gk5XtY587jX
` + `+MJfrPgjFt7vmMaKmynndf+NaIJAYczjhJj6xjPWmGrjM3MlTa9XesmelMwP3jep
` + `bApIWAvCYVjGndbK9byyMq1nyj0TUzB8oJZQooaR3MMjHTmADuVBylWzkRMxbKPl
` + `4Nlsk4Ef1JvIWBCzsMt+X17nuKfEatRfp3c9tbpGlAE/DSP0W2/Lnayxr4RpE9ds
` + `ICF35uSis/7ZlsftODUe8wtpkQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/zCCA+egAwIBAgIRAPvvd+MCcp8E36lHziv0xhMwDQYJKoZIhvcNAQEMBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMTIzMTEwNloYDzIxMjEwNTIyMDAxMTA2WjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDbvwekKIKGcV/s
` + `lDU96a71ZdN2pTYkev1X2e2/ICb765fw/i1jP9MwCzs8/xHBEQBJSxdfO4hPeNx3
` + `ENi0zbM+TrMKliS1kFVe1trTTEaHYjF8BMK9yTY0VgSpWiGxGwg4tshezIA5lpu8
` + `sF6XMRxosCEVCxD/44CFqGZTzZaREIvvFPDTXKJ6yOYnuEkhH3OcoOajHN2GEMMQ
` + `ShuyRFDQvYkqOC/Q5icqFbKg7eGwfl4PmimdV7gOVsxSlw2s/0EeeIILXtHx22z3
` + `8QBhX25Lrq2rMuaGcD3IOMBeBo2d//YuEtd9J+LGXL9AeOXHAwpvInywJKAtXTMq
` + `Wsy3LjhuANFrzMlzjR2YdjkGVzeQVx3dKUzJ2//Qf7IXPSPaEGmcgbxuatxjnvfT
` + `H85oeKr3udKnXm0Kh7CLXeqJB5ITsvxI+Qq2iXtYCc+goHNR01QJwtGDSzuIMj3K
` + `f+YMrqBXZgYBwU2J/kCNTH31nfw96WTbOfNGwLwmVRDgguzFa+QzmQsJW4FTDMwc
` + `7cIjwdElQQVA+Gqa67uWmyDKAnoTkudmgAP+OTBkhnmc6NJuZDcy6f/iWUdl0X0u
` + `/tsfgXXR6ZovnHonM13ANiN7VmEVqFlEMa0VVmc09m+2FYjjlk8F9sC7Rc4wt214
` + `7u5YvCiCsFZwx44baP5viyRZgkJVpQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBQgCZCsc34nVTRbWsniXBPjnUTQ2DAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQEMBQADggIBAAQas3x1G6OpsIvQeMS9BbiHG3+kU9P/ba6Rrg+E
` + `lUz8TmL04Bcd+I+R0IyMBww4NznT+K60cFdk+1iSmT8Q55bpqRekyhcdWda1Qu0r
` + `JiTi7zz+3w2v66akofOnGevDpo/ilXGvCUJiLOBnHIF0izUqzvfczaMZGJT6xzKq
` + `PcEVRyAN1IHHf5KnGzUlVFv9SGy47xJ9I1vTk24JU0LWkSLzMMoxiUudVmHSqJtN
` + `u0h+n/x3Q6XguZi1/C1KOntH56ewRh8n5AF7c+9LJJSRM9wunb0Dzl7BEy21Xe9q
` + `03xRYjf5wn8eDELB8FZPa1PrNKXIOLYM9egdctbKEcpSsse060+tkyBrl507+SJT
` + `04lvJ4tcKjZFqxn+bUkDQvXYj0D3WK+iJ7a8kZJPRvz8BDHfIqancY8Tgw+69SUn
` + `WqIb+HNZqFuRs16WFSzlMksqzXv6wcDSyI7aZOmCGGEcYW9NHk8EuOnOQ+1UMT9C
` + `Qb1GJcipjRzry3M4KN/t5vN3hIetB+/PhmgTO4gKhBETTEyPC3HC1QbdVfRndB6e
` + `U/NF2U/t8U2GvD26TTFLK4pScW7gyw4FQyXWs8g8FS8f+R2yWajhtS9++VDJQKom
` + `fAUISoCH+PlPRJpu/nHd1Zrddeiiis53rBaLbXu2J1Q3VqjWOmtj0HjxJJxWnYmz
` + `Pqj2
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAI/U4z6+GF8/znpHM8Dq8G0wDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQ4MThaGA8yMTIyMDYwNjIyNDgxOFowgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK5WqMvyq888
` + `3uuOtEj1FcP6iZhqO5kJurdJF59Otp2WCg+zv6I+QwaAspEWHQsKD405XfFsTGKV
` + `SKTCwoMxwBniuChSmyhlagQGKSnRY9+znOWq0v7hgmJRwp6FqclTbubmr+K6lzPy
` + `hs86mEp68O5TcOTYWUlPZDqfKwfNTbtCl5YDRr8Gxb5buHmkp6gUSgDkRsXiZ5VV
` + `b3GBmXRqbnwo5ZRNAzQeM6ylXCn4jKs310lQGUrFbrJqlyxUdfxzqdlaIRn2X+HY
` + `xRSYbHox3LVNPpJxYSBRvpQVFSy9xbX8d1v6OM8+xluB31cbLBtm08KqPFuqx+cO
` + `I2H5F0CYqYzhyOSKJsiOEJT6/uH4ewryskZzncx9ae62SC+bB5n3aJLmOSTkKLFY
` + `YS5IsmDT2m3iMgzsJNUKVoCx2zihAzgBanFFBsG+Xmoq0aKseZUI6vd2qpd5tUST
` + `/wS1sNk0Ph7teWB2ACgbFE6etnJ6stwjHFZOj/iTYhlnR2zDRU8akunFdGb6CB4/
` + `hMxGJxaqXSJeGtHm7FpadlUTf+2ESbYcVW+ui/F8sdBJseQdKZf3VdZZMgM0bcaX
` + `NE47cauDTy72WdU9YJX/YXKYMLDE0iFHTnGpfVGsuWGPYhlwZ3dFIO07mWnCRM6X
` + `u5JXRB1oy5n5HRluMsmpSN/R92MeBxKFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFNtH0F0xfijSLHEyIkRGD9gW6NazMA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEACo+5jFeY3ygxoDDzL3xpfe5M0U1WxdKk+az4
` + `/OfjZvkoma7WfChi3IIMtwtKLYC2/seKWA4KjlB3rlTsCVNPnK6D+gAnybcfTKk/
` + `IRSPk92zagwQkSUWtAk80HpVfWJzpkSU16ejiajhedzOBRtg6BwsbSqLCDXb8hXr
` + `eXWC1S9ZceGc+LcKRHewGWPu31JDhHE9bNcl9BFSAS0lYVZqxIRWxivZ+45j5uQv
` + `wPrC8ggqsdU3K8quV6dblUQzzA8gKbXJpCzXZihkPrYpQHTH0szvXvgebh+CNUAG
` + `rUxm8+yTS0NFI3U+RLbcLFVzSvjMOnEwCX0SPj5XZRYYXs5ajtQCoZhTUkkwpDV8
` + `RxXk8qGKiXwUxDO8GRvmvM82IOiXz5w2jy/h7b7soyIgdYiUydMq4Ja4ogB/xPZa
` + `gf4y0o+bremO15HFf1MkaU2UxPK5FFVUds05pKvpSIaQWbF5lw4LHHj4ZtVup7zF
` + `CLjPWs4Hs/oUkxLMqQDw0FBwlqa4uot8ItT8uq5BFpz196ZZ+4WXw5PVzfSxZibI
` + `C/nwcj0AS6qharXOs8yPnPFLPSZ7BbmWzFDgo3tpglRqo3LbSPsiZR+sLeivqydr
` + `0w4RK1btRda5Ws88uZMmW7+2aufposMKcbAdrApDEAVzHijbB/nolS5nsnFPHZoA
` + `KDPtFEk=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtzCCAj2gAwIBAgIQVZ5Y/KqjR4XLou8MCD5pOjAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIyMDUyNTE2NTgzM1oYDzIxMjIwNTI1MTc1ODMzWjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbo473OmpD5vkckdJajXg
` + `brhmNFyoSa0WCY1njuZC2zMFp3zP6rX4I1r3imrYnJd9pFH/aSiV/r6L5ACE5RPx
` + `4qdg5SQ7JJUaZc3DWsTOiOed7BCZSzM+KTYK/2QzDMApo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBTmogc06+1knsej1ltKUOdWFvwgsjAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAIs7TlLMbGTWNXpGiKf9DxaM07d/iDHe
` + `F/Vv/wyWSTGdobxBL6iArQNVXz0Gr4dvPAIwd0rsoa6R0x5mtvhdRPtM37FYrbHJ
` + `pbV+OMusQqcSLseunLBoCHenvJW0QOCQ8EDY
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICvTCCAkOgAwIBAgIQCIY7E/bFvFN2lK9Kckb0dTAKBggqhkjOPQQDAzCBnjEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5BbWF6
` + `b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYD
` + `VQQHDAdTZWF0dGxlMCAXDTIxMDUxODIxMDUxMFoYDzIxMjEwNTE4MjIwNTEwWjCB
` + `njELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5B
` + `bWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEMI0hzf1JCEOI
` + `Eue4+DmcNnSs2i2UaJxHMrNGGfU7b42a7vwP53F7045ffHPBGP4jb9q02/bStZzd
` + `VHqfcgqkSRI7beBKjD2mfz82hF/wJSITTgCLs+NRpS6zKMFOFHUNo0IwQDAPBgNV
` + `HRMBAf8EBTADAQH/MB0GA1UdDgQWBBS8uF/6hk5mPLH4qaWv9NVZaMmyTjAOBgNV
` + `HQ8BAf8EBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAO7Pu9wzLyM0X7Q08uLIL+vL
` + `qaxe3UFuzFTWjM16MLJHbzLf1i9IDFKz+Q4hXCSiJwIwClMBsqT49BPUxVsJnjGr
` + `EbyEk6aOOVfY1p2yQL649zh3M4h8okLnwf+bYIb1YpeU
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQY+JhwFEQTe36qyRlUlF8ozANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE5MjQxNloYDzIwNjEwNTE5MjAyNDE2WjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnIye77j6ev40
` + `8wRPyN2OdKFSUfI9jB20Or2RLO+RDoL43+USXdrze0Wv4HMRLqaen9BcmCfaKMp0
` + `E4SFo47bXK/O17r6G8eyq1sqnHE+v288mWtYH9lAlSamNFRF6YwA7zncmE/iKL8J
` + `0vePHMHP/B6svw8LULZCk+nZk3tgxQn2+r0B4FOz+RmpkoVddfqqUPMbKUxhM2wf
` + `fO7F6bJaUXDNMBPhCn/3ayKCjYr49ErmnpYV2ZVs1i34S+LFq39J7kyv6zAgbHv9
` + `+/MtRMoRB1CjpqW0jIOZkHBdYcd1o9p1zFn591Do1wPkmMsWdjIYj+6e7UXcHvOB
` + `2+ScIRAcnwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQGtq2W
` + `YSyMMxpdQ3IZvcGE+nyZqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAEgoP3ixJsKSD5FN8dQ01RNHERl/IFbA7TRXfwC+L1yFocKnQh4Mp/msPRSV
` + `+OeHIvemPW/wtZDJzLTOFJ6eTolGekHK1GRTQ6ZqsWiU2fmiOP8ks4oSpI+tQ9Lw
` + `VrfZqTiEcS5wEIqyfUAZZfKDo7W1xp+dQWzfczSBuZJZwI5iaha7+ILM0r8Ckden
` + `TVTapc5pLSoO15v0ziRuQ2bT3V3nwu/U0MRK44z+VWOJdSiKxdnOYDs8hFNnKhfe
` + `klbTZF7kW7WbiNYB43OaAQBJ6BALZsIskEaqfeZT8FD71uN928TcEQyBDXdZpRN+
` + `iGQZDGhht0r0URGMDSs9waJtTfA=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/jCCA+agAwIBAgIQXY/dmS+72lZPranO2JM9jjANBgkqhkiG9w0BAQwFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTI1MjEzNDUxWhgPMjEyMTA1MjUyMjM0NTFaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgYXAtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMyW9kBJjD/hx8e8
` + `b5E1sF42bp8TXsz1htSYE3Tl3T1Aq379DfEhB+xa/ASDZxt7/vwa81BkNo4M6HYq
` + `okYIXeE7cu5SnSgjWXqcERhgPevtAwgmhdE3yREe8oz2DyOi2qKKZqah+1gpPaIQ
` + `fK0uAqoeQlyHosye3KZZKkDHBatjBsQ5kf8lhuf7wVulEZVRHY2bP2X7N98PfbpL
` + `QdH7mWXzDtJJ0LiwFwds47BrkgK1pkHx2p1mTo+HMkfX0P6Fq1atkVC2RHHtbB/X
` + `iYyH7paaHBzviFrhr679zNqwXIOKlbf74w3mS11P76rFn9rS1BAH2Qm6eY5S/Fxe
` + `HEKXm4kjPN63Zy0p3yE5EjPt54yPkvumOnT+RqDGJ2HCI9k8Ehcbve0ogfdRKNqQ
` + `VHWYTy8V33ndQRHZlx/CuU1yN61TH4WSoMly1+q1ihTX9sApmlQ14B2pJi/9DnKW
` + `cwECrPy1jAowC2UJ45RtC8UC05CbP9yrIy/7Noj8gQDiDOepm+6w1g6aNlWoiuQS
` + `kyI6nzz1983GcnOHya73ga7otXo0Qfg9jPghlYiMomrgshlSLDHZG0Ib/3hb8cnR
` + `1OcN9FpzNmVK2Ll1SmTMLrIhuCkyNYX9O/bOknbcf706XeESxGduSkHEjIw/k1+2
` + `Atteoq5dT6cwjnJ9hyhiueVlVkiDAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w
` + `HQYDVR0OBBYEFLUI+DD7RJs+0nRnjcwIVWzzYSsFMA4GA1UdDwEB/wQEAwIBhjAN
` + `BgkqhkiG9w0BAQwFAAOCAgEAb1mcCHv4qMQetLGTBH9IxsB2YUUhr5dda0D2BcHr
` + `UtDbfd0VQs4tux6h/6iKwHPx0Ew8fuuYj99WknG0ffgJfNc5/fMspxR/pc1jpdyU
` + `5zMQ+B9wi0lOZPO9uH7/pr+d2odcNEy8zAwqdv/ihsTwLmGP54is9fVbsgzNW1cm
` + `HKAVL2t/Ope+3QnRiRilKCN1lzhav4HHdLlN401TcWRWKbEuxF/FgxSO2Hmx86pj
` + `e726lweCTMmnq/cTsPOVY0WMjs0or3eHDVlyLgVeV5ldyN+ptg3Oit60T05SRa58
` + `AJPTaVKIcGQ/gKkKZConpu7GDofT67P/ox0YNY57LRbhsx9r5UY4ROgz7WMQ1yoS
` + `Y+19xizm+mBm2PyjMUbfwZUyCxsdKMwVdOq5/UmTmdms+TR8+m1uBHPOTQ2vKR0s
` + `Pd/THSzPuu+d3dbzRyDSLQbHFFneG760CUlD/ZmzFlQjJ89/HmAmz8IyENq+Sjhx
` + `Jgzy+FjVZb8aRUoYLlnffpUpej1n87Ynlr1GrvC4GsRpNpOHlwuf6WD4W0qUTsC/
` + `C9JO+fBzUj/aWlJzNcLEW6pte1SB+EdkR2sZvWH+F88TxemeDrV0jKJw5R89CDf8
` + `ZQNfkxJYjhns+YeV0moYjqQdc7tq4i04uggEQEtVzEhRLU5PE83nlh/K2NZZm8Kj
` + `dIA=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/zCCAuegAwIBAgIRAPVSMfFitmM5PhmbaOFoGfUwDQYJKoZIhvcNAQELBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNTIyMzQ1N1oYDzIwNjEwNTI1MjMzNDU3WjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDu9H7TBeGoDzMr
` + `dxN6H8COntJX4IR6dbyhnj5qMD4xl/IWvp50lt0VpmMd+z2PNZzx8RazeGC5IniV
` + `5nrLg0AKWRQ2A/lGGXbUrGXCSe09brMQCxWBSIYe1WZZ1iU1IJ/6Bp4D2YEHpXrW
` + `bPkOq5x3YPcsoitgm1Xh8ygz6vb7PsvJvPbvRMnkDg5IqEThapPjmKb8ZJWyEFEE
` + `QRrkCIRueB1EqQtJw0fvP4PKDlCJAKBEs/y049FoOqYpT3pRy0WKqPhWve+hScMd
` + `6obq8kxTFy1IHACjHc51nrGII5Bt76/MpTWhnJIJrCnq1/Uc3Qs8IVeb+sLaFC8K
` + `DI69Sw6bAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFE7PCopt
` + `lyOgtXX0Y1lObBUxuKaCMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC
` + `AQEAFj+bX8gLmMNefr5jRJfHjrL3iuZCjf7YEZgn89pS4z8408mjj9z6Q5D1H7yS
` + `jNETVV8QaJip1qyhh5gRzRaArgGAYvi2/r0zPsy+Tgf7v1KGL5Lh8NT8iCEGGXwF
` + `g3Ir+Nl3e+9XUp0eyyzBIjHtjLBm6yy8rGk9p6OtFDQnKF5OxwbAgip42CD75r/q
` + `p421maEDDvvRFR4D+99JZxgAYDBGqRRceUoe16qDzbMvlz0A9paCZFclxeftAxv6
` + `QlR5rItMz/XdzpBJUpYhdzM0gCzAzdQuVO5tjJxmXhkSMcDP+8Q+Uv6FA9k2VpUV
` + `E/O5jgpqUJJ2Hc/5rs9VkAPXeA==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrzCCAjWgAwIBAgIQW0yuFCle3uj4vWiGU0SaGzAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTE5MTkzNTE2WhgPMjEyMTA1MTkyMDM1MTZaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgYWYtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDPiKNZSaXs3Un/J/v+LTsFDANHpi7en
` + `oL2qh0u0DoqNzEBTbBjvO23bLN3k599zh6CY3HKW0r2k1yaIdbWqt4upMCRCcUFi
` + `I4iedAmubgzh56wJdoMZztjXZRwDthTkJKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUWbYkcrvVSnAWPR5PJhIzppcAnZIwDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2gAMGUCMCESGqpat93CjrSEjE7z+Hbvz0psZTHwqaxuiH64GKUm
` + `mYynIiwpKHyBrzjKBmeDoQIxANGrjIo6/b8Jl6sdIZQI18V0pAyLfLiZjlHVOnhM
` + `MOTVgr82ZuPoEHTX78MxeMnYlw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRAIbsx8XOl0sgTNiCN4O+18QwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1NDU4WhgPMjA2MTA1MjUyMjU0NTha
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `tROxwXWCgn5R9gI/2Ivjzaxc0g95ysBjoJsnhPdJEHQb7w3y2kWrVWU3Y9fOitgb
` + `CEsnEC3PrhRnzNVW0fPsK6kbvOeCmjvY30rdbxbc8h+bjXfGmIOgAkmoULEr6Hc7
` + `G1Q/+tvv4lEwIs7bEaf+abSZxRJbZ0MBxhbHn7UHHDiMZYvzK+SV1MGCxx7JVhrm
` + `xWu3GC1zZCsGDhB9YqY9eR6PmjbqA5wy8vqbC57dZZa1QVtWIQn3JaRXn+faIzHx
` + `nLMN5CEWihsdmHBXhnRboXprE/OS4MFv1UrQF/XM/h5RBeCywpHePpC+Oe1T3LNC
` + `iP8KzRFrjC1MX/WXJnmOVQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBS33XbXAUMs1znyZo4B0+B3D68WFTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBADuadd2EmlpueY2VlrIIPC30QkoA1EOSoCmZgN6124apkoY1
` + `HiV4r+QNPljN4WP8gmcARnNkS7ZeR4fvWi8xPh5AxQCpiaBMw4gcbTMCuKDV68Pw
` + `P2dZCTMspvR3CDfM35oXCufdtFnxyU6PAyINUqF/wyTHguO3owRFPz64+sk3r2pT
` + `WHmJjG9E7V+KOh0s6REgD17Gqn6C5ijLchSrPUHB0wOIkeLJZndHxN/76h7+zhMt
` + `fFeNxPWHY2MfpcaLjz4UREzZPSB2U9k+y3pW1omCIcl6MQU9itGx/LpQE+H3ZeX2
` + `M2bdYd5L+ow+bdbGtsVKOuN+R9Dm17YpswF+vyQ=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAKlQ+3JX9yHXyjP/Ja6kZhkwDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MTkxNzQ1MjBaGA8yMTIxMDUxOTE4NDUyMFowgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKtahBrpUjQ6
` + `H2mni05BAKU6Z5USPZeSKmBBJN3YgD17rJ93ikJxSgzJ+CupGy5rvYQ0xznJyiV0
` + `91QeQN4P+G2MjGQR0RGeUuZcfcZitJro7iAg3UBvw8WIGkcDUg+MGVpRv/B7ry88
` + `7E4OxKb8CPNoa+a9j6ABjOaaxaI22Bb7j3OJ+JyMICs6CU2bgkJaj3VUV9FCNUOc
` + `h9PxD4jzT9yyGYm/sK9BAT1WOTPG8XQUkpcFqy/IerZDfiQkf1koiSd4s5VhBkUn
` + `aQHOdri/stldT7a+HJFVyz2AXDGPDj+UBMOuLq0K6GAT6ThpkXCb2RIf4mdTy7ox
` + `N5BaJ+ih+Ro3ZwPkok60egnt/RN98jgbm+WstgjJWuLqSNInnMUgkuqjyBWwePqX
` + `Kib+wdpyx/LOzhKPEFpeMIvHQ3A0sjlulIjnh+j+itezD+dp0UNxMERlW4Bn/IlS
` + `sYQVNfYutWkRPRLErXOZXtlxxkI98JWQtLjvGzQr+jywxTiw644FSLWdhKa6DtfU
` + `2JWBHqQPJicMElfZpmfaHZjtXuCZNdZQXWg7onZYohe281ZrdFPOqC4rUq7gYamL
` + `T+ZB+2P+YCPOLJ60bj/XSvcB7mesAdg8P0DNddPhHUFWx2dFqOs1HxIVB4FZVA9U
` + `Ppbv4a484yxjTgG7zFZNqXHKTqze6rBBAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFCEAqjighncv/UnWzBjqu1Ka2Yb4MA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEAYyvumblckIXlohzi3QiShkZhqFzZultbFIu9
` + `GhA5CDar1IFMhJ9vJpO9nUK/camKs1VQRs8ZsBbXa0GFUM2p8y2cgUfLwFULAiC/
` + `sWETyW5lcX/xc4Pyf6dONhqFJt/ovVBxNZtcmMEWv/1D6Tf0nLeEb0P2i/pnSRR4
` + `Oq99LVFjossXtyvtaq06OSiUUZ1zLPvV6AQINg8dWeBOWRcQYhYcEcC2wQ06KShZ
` + `0ahuu7ar5Gym3vuLK6nH+eQrkUievVomN/LpASrYhK32joQ5ypIJej3sICIgJUEP
` + `UoeswJ+Z16f3ECoL1OSnq4A0riiLj1ZGmVHNhM6m/gotKaHNMxsK9zsbqmuU6IT/
` + `P6cR0S+vdigQG8ZNFf5vEyVNXhl8KcaJn6lMD/gMB2rY0qpaeTg4gPfU5wcg8S4Y
` + `C9V//tw3hv0f2n+8kGNmqZrylOQDQWSSo8j8M2SRSXiwOHDoTASd1fyBEIqBAwzn
` + `LvXVg8wQd1WlmM3b0Vrsbzltyh6y4SuKSkmgufYYvC07NknQO5vqvZcNoYbLNea3
` + `76NkFaMHUekSbwVejZgG5HGwbaYBgNdJEdpbWlA3X4yGRVxknQSUyt4dZRnw/HrX
` + `k8x6/wvtw7wht0/DOqz1li7baSsMazqxx+jDdSr1h9xML416Q4loFCLgqQhil8Jq
` + `Em4Hy3A=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGBTCCA+2gAwIBAgIRAJfKe4Zh4aWNt3bv6ZjQwogwDQYJKoZIhvcNAQEMBQAw
` + `gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq
` + `QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYD
` + `VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDg1M1oYDzIxMjEwNTIxMjMwODUzWjCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCpgUH6
` + `Crzd8cOw9prAh2rkQqAOx2vtuI7xX4tmBG4I/um28eBjyVmgwQ1fpq0Zg2nCKS54
` + `Nn0pCmT7f3h6Bvopxn0J45AzXEtajFqXf92NQ3iPth95GVfAJSD7gk2LWMhpmID9
` + `JGQyoGuDPg+hYyr292X6d0madzEktVVGO4mKTF989qEg+tY8+oN0U2fRTrqa2tZp
` + `iYsmg350ynNopvntsJAfpCO/srwpsqHHLNFZ9jvhTU8uW90wgaKO9i31j/mHggCE
` + `+CAOaJCM3g+L8DPl/2QKsb6UkBgaaIwKyRgKSj1IlgrK+OdCBCOgM9jjId4Tqo2j
` + `ZIrrPBGl6fbn1+etZX+2/tf6tegz+yV0HHQRAcKCpaH8AXF44bny9andslBoNjGx
` + `H6R/3ib4FhPrnBMElzZ5i4+eM/cuPC2huZMBXb/jKgRC/QN1Wm3/nah5FWq+yn+N
` + `tiAF10Ga0BYzVhHDEwZzN7gn38bcY5yi/CjDUNpY0OzEe2+dpaBKPlXTaFfn9Nba
` + `CBmXPRF0lLGGtPeTAgjcju+NEcVa82Ht1pqxyu2sDtbu3J5bxp4RKtj+ShwN8nut
` + `Tkf5Ea9rSmHEY13fzgibZlQhXaiFSKA2ASUwgJP19Putm0XKlBCNSGCoECemewxL
` + `+7Y8FszS4Uu4eaIwvXVqUEE2yf+4ex0hqQ1acQIDAQABo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBSeUnXIRxNbYsZLtKomIz4Y1nOZEzAOBgNVHQ8BAf8E
` + `BAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAIpRvxVS0dzoosBh/qw65ghPUGSbP2D4
` + `dm6oYCv5g/zJr4fR7NzEbHOXX5aOQnHbQL4M/7veuOCLNPOW1uXwywMg6gY+dbKe
` + `YtPVA1as8G9sUyadeXyGh2uXGsziMFXyaESwiAXZyiYyKChS3+g26/7jwECFo5vC
` + `XGhWpIO7Hp35Yglp8AnwnEAo/PnuXgyt2nvyTSrxlEYa0jus6GZEZd77pa82U1JH
` + `qFhIgmKPWWdvELA3+ra1nKnvpWM/xX0pnMznMej5B3RT3Y+k61+kWghJE81Ix78T
` + `+tG4jSotgbaL53BhtQWBD1yzbbilqsGE1/DXPXzHVf9yD73fwh2tGWSaVInKYinr
` + `a4tcrB3KDN/PFq0/w5/21lpZjVFyu/eiPj6DmWDuHW73XnRwZpHo/2OFkei5R7cT
` + `rn/YdDD6c1dYtSw5YNnS6hdCQ3sOiB/xbPRN9VWJa6se79uZ9NLz6RMOr73DNnb2
` + `bhIR9Gf7XAA5lYKqQk+A+stoKbIT0F65RnkxrXi/6vSiXfCh/bV6B41cf7MY/6YW
` + `ehserSdjhQamv35rTFdM+foJwUKz1QN9n9KZhPxeRmwqPitAV79PloksOnX25ElN
` + `SlyxdndIoA1wia1HRd26EFm2pqfZ2vtD2EjU3wD42CXX4H8fKVDna30nNFSYF0yn
` + `jGKc3k6UNxpg
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/jCCA+agAwIBAgIQaRHaEqqacXN20e8zZJtmDDANBgkqhkiG9w0BAQwFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTI1MjIzODM1WhgPMjEyMTA1MjUyMzM4MzVaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAInfBCaHuvj6Rb5c
` + `L5Wmn1jv2PHtEGMHm+7Z8dYosdwouG8VG2A+BCYCZfij9lIGszrTXkY4O7vnXgru
` + `JUNdxh0Q3M83p4X+bg+gODUs3jf+Z3Oeq7nTOk/2UYvQLcxP4FEXILxDInbQFcIx
` + `yen1ESHggGrjEodgn6nbKQNRfIhjhW+TKYaewfsVWH7EF2pfj+cjbJ6njjgZ0/M9
` + `VZifJFBgat6XUTOf3jwHwkCBh7T6rDpgy19A61laImJCQhdTnHKvzTpxcxiLRh69
` + `ZObypR7W04OAUmFS88V7IotlPmCL8xf7kwxG+gQfvx31+A9IDMsiTqJ1Cc4fYEKg
` + `bL+Vo+2Ii4W2esCTGVYmHm73drznfeKwL+kmIC/Bq+DrZ+veTqKFYwSkpHRyJCEe
` + `U4Zym6POqQ/4LBSKwDUhWLJIlq99bjKX+hNTJykB+Lbcx0ScOP4IAZQoxmDxGWxN
` + `S+lQj+Cx2pwU3S/7+OxlRndZAX/FKgk7xSMkg88HykUZaZ/ozIiqJqSnGpgXCtED
` + `oQ4OJw5ozAr+/wudOawaMwUWQl5asD8fuy/hl5S1nv9XxIc842QJOtJFxhyeMIXt
` + `LVECVw/dPekhMjS3Zo3wwRgYbnKG7YXXT5WMxJEnHu8+cYpMiRClzq2BEP6/MtI2
` + `AZQQUFu2yFjRGL2OZA6IYjxnXYiRAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w
` + `HQYDVR0OBBYEFADCcQCPX2HmkqQcmuHfiQ2jjqnrMA4GA1UdDwEB/wQEAwIBhjAN
` + `BgkqhkiG9w0BAQwFAAOCAgEASXkGQ2eUmudIKPeOIF7RBryCoPmMOsqP0+1qxF8l
` + `pGkwmrgNDGpmd9s0ArfIVBTc1jmpgB3oiRW9c6n2OmwBKL4UPuQ8O3KwSP0iD2sZ
` + `KMXoMEyphCEzW1I2GRvYDugL3Z9MWrnHkoaoH2l8YyTYvszTvdgxBPpM2x4pSkp+
` + `76d4/eRpJ5mVuQ93nC+YG0wXCxSq63hX4kyZgPxgCdAA+qgFfKIGyNqUIqWgeyTP
` + `n5OgKaboYk2141Rf2hGMD3/hsGm0rrJh7g3C0ZirPws3eeJfulvAOIy2IZzqHUSY
` + `jkFzraz6LEH3IlArT3jUPvWKqvh2lJWnnp56aqxBR7qHH5voD49UpJWY1K0BjGnS
` + `OHcurpp0Yt/BIs4VZeWdCZwI7JaSeDcPMaMDBvND3Ia5Fga0thgYQTG6dE+N5fgF
` + `z+hRaujXO2nb0LmddVyvE8prYlWRMuYFv+Co8hcMdJ0lEZlfVNu0jbm9/GmwAZ+l
` + `9umeYO9yz/uC7edC8XJBglMAKUmVK9wNtOckUWAcCfnPWYLbYa/PqtXBYcxrso5j
` + `iaS/A7iEW51uteHBGrViCy1afGG+hiUWwFlesli+Rq4dNstX3h6h2baWABaAxEVJ
` + `y1RnTQSz6mROT1VmZSgSVO37rgIyY0Hf0872ogcTS+FfvXgBxCxsNWEbiQ/XXva4
` + `0Ws=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtDCCAjqgAwIBAgIRAMyaTlVLN0ndGp4ffwKAfoMwCgYIKoZIzj0EAwMwgZkx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h
` + `em9uIFJEUyBtZS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjIwNTA3MDA0NDM3WhgPMjEyMjA1MDcwMTQ0MzdaMIGZMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv
` + `biBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE19nCV1nsI6CohSor13+B25cr
` + `zg+IHdi9Y3L7ziQnHWI6yjBazvnKD+oC71aRRlR8b5YXsYGUQxWzPLHN7EGPcSGv
` + `bzA9SLG1KQYCJaQ0m9Eg/iGrwKWOgylbhVw0bCxoo0IwQDAPBgNVHRMBAf8EBTAD
` + `AQH/MB0GA1UdDgQWBBS4KsknsJXM9+QPEkBdZxUPaLr11zAOBgNVHQ8BAf8EBAMC
` + `AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJaRgrYIEfXQMZQQDxMTYS0azpyWSseQooXo
` + `L3nYq4OHGBgYyQ9gVjvRYWU85PXbfgIwdi82DtANQFkCu+j+BU0JBY/uRKPEeYzo
` + `JG92igKIcXPqCoxIJ7lJbbzmuf73gQu5
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAJwCobx0Os8F7ihbJngxrR8wDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MjAxNzE1MzNaGA8yMTIxMDUyMDE4MTUzM1owgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANukKwlm+ZaI
` + `Y5MkWGbEVLApEyLmlrHLEg8PfiiEa9ts7jssQcin3bzEPdTqGr5jo91ONoZ3ccWq
` + `xJgg1W3bLu5CAO2CqIOXTXHRyCO/u0Ch1FGgWB8xETPSi3UHt/Vn1ltdO6DYdbDU
` + `mYgwzYrvLBdRCwxsb9o+BuYQHVFzUYonqk/y9ujz3gotzFq7r55UwDTA1ita3vb4
` + `eDKjIb4b1M4Wr81M23WHonpje+9qkkrAkdQcHrkgvSCV046xsq/6NctzwCUUNsgF
` + `7Q1a8ut5qJEYpz5ta8vI1rqFqAMBqCbFjRYlmAoTTpFPOmzAVxV+YoqTrW5A16su
` + `/2SXlMYfJ/n/ad/QfBNPPAAQMpyOr2RCL/YiL/PFZPs7NxYjnZHNWxMLSPgFyI+/
` + `t2klnn5jR76KJK2qimmaXedB90EtFsMRUU1e4NxH9gDuyrihKPJ3aVnZ35mSipvR
` + `/1KB8t8gtFXp/VQaz2sg8+uxPMKB81O37fL4zz6Mg5K8+aq3ejBiyHucpFGnsnVB
` + `3kQWeD36ONkybngmgWoyPceuSWm1hQ0Z7VRAQX+KlxxSaHmSaIk1XxZu9h9riQHx
` + `fMuev6KXjRn/CjCoUTn+7eFrt0dT5GryQEIZP+nA0oq0LKxogigHNZlwAT4flrqb
` + `JUfZJrqgoce5HjZSXl10APbtPjJi0fW9AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFEfV+LztI29OVDRm0tqClP3NrmEWMA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEAvSNe+0wuk53KhWlRlRf2x/97H2Q76X3anzF0
` + `5fOSVm022ldALzXMzqOfdnoKIhAu2oVKiHHKs7mMas+T6TL+Mkphx0CYEVxFE3PG
` + `061q3CqJU+wMm9W9xsB79oB2XG47r1fIEywZZ3GaRsatAbjcNOT8uBaATPQAfJFN
` + `zjFe4XyN+rA4cFrYNvfHTeu5ftrYmvks7JlRaJgEGWsz+qXux7uvaEEVPqEumd2H
` + `uYeaRNOZ2V23R009X5lbgBFx9tq5VDTnKhQiTQ2SeT0rc1W3Dz5ik6SbQQNP3nSR
` + `0Ywy7r/sZ3fcDyfFiqnrVY4Ympfvb4YW2PZ6OsQJbzH6xjdnTG2HtzEU30ngxdp1
` + `WUEF4zt6rjJCp7QBUqXgdlHvJqYu6949qtWjEPiFN9uSsRV2i1YDjJqN52dLjAPn
` + `AipJKo8x1PHTwUzuITqnB9BdP+5TlTl8biJfkEf/+08eWDTLlDHr2VrZLOLompTh
` + `bS5OrhDmqA2Q+O+EWrTIhMflwwlCpR9QYM/Xwvlbad9H0FUHbJsCVNaru3wGOgWo
` + `tt3dNSK9Lqnv/Ej9K9v6CRr36in4ylJKivhJ5B9E7ABHg7EpBJ1xi7O5eNDkNoJG
` + `+pFyphJq3AkBR2U4ni2tUaTAtSW2tks7IaiDV+UMtqZyGabT5ISQfWLLtLHSWn2F
` + `Tspdjbg=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIECTCCAvGgAwIBAgIRAJZFh4s9aZGzKaTMLrSb4acwDQYJKoZIhvcNAQELBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjEyODQxWhgPMjA2MTA1MTgyMjI4NDFa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgQmV0YSB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
` + `17i2yoU6diep+WrqxIn2CrDEO2NdJVwWTSckx4WMZlLpkQDoymSmkNHjq9ADIApD
` + `A31Cx+843apL7wub8QkFZD0Tk7/ThdHWJOzcAM3ov98QBPQfOC1W5zYIIRP2F+vQ
` + `TRETHQnLcW3rLv0NMk5oQvIKpJoC9ett6aeVrzu+4cU4DZVWYlJUoC/ljWzCluau
` + `8blfW0Vwin6OB7s0HCG5/wijQWJBU5SrP/KAIPeQi1GqG5efbqAXDr/ple0Ipwyo
` + `Xjjl73LenGUgqpANlC9EAT4i7FkJcllLPeK3NcOHjuUG0AccLv1lGsHAxZLgjk/x
` + `z9ZcnVV9UFWZiyJTKxeKPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
` + `DgQWBBRWyMuZUo4gxCR3Luf9/bd2AqZ7CjAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI
` + `hvcNAQELBQADggEBAIqN2DlIKlvDFPO0QUZQVFbsi/tLdYM98/vvzBpttlTGVMyD
` + `gJuQeHVz+MnhGIwoCGOlGU3OOUoIlLAut0+WG74qYczn43oA2gbMd7HoD7oL/IGg
` + `njorBwJVcuuLv2G//SqM3nxGcLRtkRnQ+lvqPxMz9+0fKFUn6QcIDuF0QSfthLs2
` + `WSiGEPKO9c9RSXdRQ4pXA7c3hXng8P4A2ZmdciPne5Nu4I4qLDGZYRrRLRkNTrOi
` + `TyS6r2HNGUfgF7eOSeKt3NWL+mNChcYj71/Vycf5edeczpUgfnWy9WbPrK1svKyl
` + `aAs2xg+X6O8qB+Mnj2dNBzm+lZIS3sIlm+nO9sg=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAPAlEk8VJPmEzVRRaWvTh2AwCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTI1MjI0MTU1WhgPMjEyMTA1MjUyMzQxNTVaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEx5xjrup8II4HOJw15NTnS3H5yMrQGlbj
` + `EDA5MMGnE9DmHp5dACIxmPXPMe/99nO7wNdl7G71OYPCgEvWm0FhdvVUeTb3LVnV
` + `BnaXt32Ek7/oxGk1T+Df03C+W0vmuJ+wo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBTGXmqBWN/1tkSea4pNw0oHrjk2UDAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIxAIqqZWCSrIkZ7zsv/FygtAusW6yvlL935YAWYPVXU30m
` + `jkMFLM+/RJ9GMvnO8jHfCgIwB+whlkcItzE9CRQ6CsMo/d5cEHDUu/QW6jSIh9BR
` + `OGh9pTYPVkUbBiKPA7lVVhre
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/zCCA+egAwIBAgIRAJGY9kZITwfSRaAS/bSBOw8wDQYJKoZIhvcNAQEMBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE4MTEyMFoYDzIxMjEwNTE5MTkxMTIwWjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDe2vlDp6Eo4WQi
` + `Wi32YJOgdXHhxTFrLjB9SRy22DYoMaWfginJIwJcSR8yse8ZDQuoNhERB9LRggAE
` + `eng23mhrfvtL1yQkMlZfBu4vG1nOb22XiPFzk7X2wqz/WigdYNBCqa1kK3jrLqPx
` + `YUy7jk2oZle4GLVRTNGuMfcid6S2hs3UCdXfkJuM2z2wc3WUlvHoVNk37v2/jzR/
` + `hSCHZv5YHAtzL/kLb/e64QkqxKll5QmKhyI6d7vt6Lr1C0zb+DmwxUoJhseAS0hI
` + `dRk5DklMb4Aqpj6KN0ss0HAYqYERGRIQM7KKA4+hxDMUkJmt8KqWKZkAlCZgflzl
` + `m8NZ31o2cvBzf6g+VFHx+6iVrSkohVQydkCxx7NJ743iPKsh8BytSM4qU7xx4OnD
` + `H2yNXcypu+D5bZnVZr4Pywq0w0WqbTM2bpYthG9IC4JeVUvZ2mDc01lqOlbMeyfT
` + `og5BRPLDXdZK8lapo7se2teh64cIfXtCmM2lDSwm1wnH2iSK+AWZVIM3iE45WSGc
` + `vZ+drHfVgjJJ5u1YrMCWNL5C2utFbyF9Obw9ZAwm61MSbPQL9JwznhNlCh7F2ANW
` + `ZHWQPNcOAJqzE4uVcJB1ZeVl28ORYY1668lx+s9yYeMXk3QQdj4xmdnvoBFggqRB
` + `ZR6Z0D7ZohADXe024RzEo1TukrQgKQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBT7Vs4Y5uG/9aXnYGNMEs6ycPUT3jAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQEMBQADggIBACN4Htp2PvGcQA0/sAS+qUVWWJoAXSsu8Pgc6Gar
` + `7tKVlNJ/4W/a6pUV2Xo/Tz3msg4yiE8sMESp2k+USosD5n9Alai5s5qpWDQjrqrh
` + `76AGyF2nzve4kIN19GArYhm4Mz/EKEG1QHYvBDGgXi3kNvL/a2Zbybp+3LevG+q7
` + `xtx4Sz9yIyMzuT/6Y7ijtiMZ9XbuxGf5wab8UtwT3Xq1UradJy0KCkzRJAz/Wy/X
` + `HbTkEvKSaYKExH6sLo0jqdIjV/d2Io31gt4e0Ly1ER2wPyFa+pc/swu7HCzrN+iz
` + `A2ZM4+KX9nBvFyfkHLix4rALg+WTYJa/dIsObXkdZ3z8qPf5A9PXlULiaa1mcP4+
` + `rokw74IyLEYooQ8iSOjxumXhnkTS69MAdGzXYE5gnHokABtGD+BB5qLhtLt4fqAp
` + `8AyHpQWMyV42M9SJLzQ+iOz7kAgJOBOaVtJI3FV/iAg/eqWVm3yLuUTWDxSHrKuL
` + `N19+pSjF6TNvUSFXwEa2LJkfDqIOCE32iOuy85QY//3NsgrSQF6UkSPa95eJrSGI
` + `3hTRYYh3Up2GhBGl1KUy7/o0k3KRZTk4s38fylY8bZ3TakUOH5iIGoHyFVVcp361
` + `Pyy25SzFSmNalWoQd9wZVc/Cps2ldxhcttM+WLkFNzprd0VJa8qTz8vYtHP0ouDN
` + `nWS0
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCTCCA/GgAwIBAgIRAOY7gfcBZgR2tqfBzMbFQCUwDQYJKoZIhvcNAQEMBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY1NDU5WhgPMjEyMjA1MjUxNzU0NTla
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0E0MDk2IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
` + `lfxER43FuLRdL08bddF0YhbCP+XXKj1A/TFMXmd2My8XDei8rPXFYyyjMig9+xZw
` + `uAsIxLwz8uiA26CKA8bCZKg5VG2kTeOJAfvBJaLv1CZefs3Z4Uf1Sjvm6MF2yqEj
` + `GoORfyfL9HiZFTDuF/hcjWoKYCfMuG6M/wO8IbdICrX3n+BiYQJu/pFO660Mg3h/
` + `8YBBWYDbHoCiH/vkqqJugQ5BM3OI5nsElW51P1icEEqti4AZ7JmtSv9t7fIFBVyR
` + `oaEyOgpp0sm193F/cDJQdssvjoOnaubsSYm1ep3awZAUyGN/X8MBrPY95d0hLhfH
` + `Ehc5Icyg+hsosBljlAyksmt4hFQ9iBnWIz/ZTfGMck+6p3HVL9RDgvluez+rWv59
` + `8q7omUGsiPApy5PDdwI/Wt/KtC34/2sjslIJfvgifdAtkRPkhff1WEwER00ADrN9
` + `eGGInaCpJfb1Rq8cV2n00jxg7DcEd65VR3dmIRb0bL+jWK62ni/WdEyomAOMfmGj
` + `aWf78S/4rasHllWJ+QwnaUYY3u6N8Cgio0/ep4i34FxMXqMV3V0/qXdfhyabi/LM
` + `wCxNo1Dwt+s6OtPJbwO92JL+829QAxydfmaMTeHBsgMPkG7RwAekeuatKGHNsc2Z
` + `x2Q4C2wVvOGAhcHwxfM8JfZs3nDSZJndtVVnFlUY0UECAwEAAaNCMEAwDwYDVR0T
` + `AQH/BAUwAwEB/zAdBgNVHQ4EFgQUpnG7mWazy6k97/tb5iduRB3RXgQwDgYDVR0P
` + `AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCDLqq1Wwa9Tkuv7vxBnIeVvvFF
` + `ecTn+P+wJxl9Qa2ortzqTHZsBDyJO62d04AgBwiDXkJ9a+bthgG0H1J7Xee8xqv1
` + `xyX2yKj24ygHjspLotKP4eDMdDi5TYq+gdkbPmm9Q69B1+W6e049JVGXvWG8/7kU
` + `igxeuCYwtCCdUPRLf6D8y+1XMGgVv3/DSOHWvTg3MJ1wJ3n3+eve3rjGdRYWZeJu
` + `k21HLSZYzVrCtUsh2YAeLnUbSxVuT2Xr4JehYe9zW5HEQ8Je/OUfnCy9vzoN/ITw
` + `osAH+EBJQey7RxEDqMwCaRefH0yeHFcnOll0OXg/urnQmwbEYzQ1uutJaBPsjU0J
` + `Qf06sMxI7GiB5nPE+CnI2sM6A9AW9kvwexGXpNJiLxF8dvPQthpOKGcYu6BFvRmt
` + `6ctfXd9b7JJoVqMWuf5cCY6ihpk1e9JTlAqu4Eb/7JNyGiGCR40iSLvV28un9wiE
` + `plrdYxwcNYq851BEu3r3AyYWw/UW1AKJ5tM+/Gtok+AphMC9ywT66o/Kfu44mOWm
` + `L3nSLSWEcgfUVgrikpnyGbUnGtgCmHiMlUtNVexcE7OtCIZoVAlCGKNu7tyuJf10
` + `Qlk8oIIzfSIlcbHpOYoN79FkLoDNc2er4Gd+7w1oPQmdAB0jBJnA6t0OUBPKdDdE
` + `Ufff2jrbfbzECn1ELg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCDCCA/CgAwIBAgIQIuO1A8LOnmc7zZ/vMm3TrDANBgkqhkiG9w0BAQwFADCB
` + `nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB
` + `bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G
` + `A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQ2MThaGA8yMTIxMDUyNDIxNDYxOFow
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDq
` + `qRHKbG8ZK6/GkGm2cenznEF06yHwI1gD5sdsHjTgekDZ2Dl9RwtDmUH2zFuIQwGj
` + `SeC7E2iKwrJRA5wYzL9/Vk8NOILEKQOP8OIKUHbc7q8rEtjs401KcU6pFBBEdO9G
` + `CTiRhogq+8mhC13AM/UriZJbKhwgM2UaDOzAneGMhQAGjH8z83NsNcPxpYVE7tqM
` + `sch5yLtIJLkJRusrmQQTeHUev16YNqyUa+LuFclFL0FzFCimkcxUhXlbfEKXbssS
` + `yPzjiv8wokGyo7+gA0SueceMO2UjfGfute3HlXZDcNvBbkSY+ver41jPydyRD6Qq
` + `oEkh0tyIbPoa3oU74kwipJtz6KBEA3u3iq61OUR0ENhR2NeP7CSKrC24SnQJZ/92
` + `qxusrbyV/0w+U4m62ug/o4hWNK1lUcc2AqiBOvCSJ7qpdteTFxcEIzDwYfERDx6a
` + `d9+3IPvzMb0ZCxBIIUFMxLTF7yAxI9s6KZBBXSZ6tDcCCYIgEysEPRWMRAcG+ye/
` + `fZVn9Vnzsj4/2wchC2eQrYpb1QvG4eMXA4M5tFHKi+/8cOPiUzJRgwS222J8YuDj
` + `yEBval874OzXk8H8Mj0JXJ/jH66WuxcBbh5K7Rp5oJn7yju9yqX6qubY8gVeMZ1i
` + `u4oXCopefDqa35JplQNUXbWwSebi0qJ4EK0V8F9Q+QIDAQABo0IwQDAPBgNVHRMB
` + `Af8EBTADAQH/MB0GA1UdDgQWBBT4ysqCxaPe7y+g1KUIAenqu8PAgzAOBgNVHQ8B
` + `Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBALU8WN35KAjPZEX65tobtCDQFkIO
` + `uJjv0alD7qLB0i9eY80C+kD87HKqdMDJv50a5fZdqOta8BrHutgFtDm+xo5F/1M3
` + `u5/Vva5lV4xy5DqPajcF4Mw52czYBmeiLRTnyPJsU93EQIC2Bp4Egvb6LI4cMOgm
` + `4pY2hL8DojOC5PXt4B1/7c1DNcJX3CMzHDm4SMwiv2MAxSuC/cbHXcWMk+qXdrVx
` + `+ayLUSh8acaAOy3KLs1MVExJ6j9iFIGsDVsO4vr4ZNsYQiyHjp+L8ops6YVBO5AT
` + `k/pI+axHIVsO5qiD4cFWvkGqmZ0gsVtgGUchZaacboyFsVmo6QPrl28l6LwxkIEv
` + `GGJYvIBW8sfqtGRspjfX5TlNy5IgW/VOwGBdHHsvg/xpRo31PR3HOFw7uPBi7cAr
` + `FiZRLJut7af98EB2UvovZnOh7uIEGPeecQWeOTQfJeWet2FqTzFYd0NUMgqPuJx1
` + `vLKferP+ajAZLJvVnW1J7Vccx/pm0rMiUJEf0LRb/6XFxx7T2RGjJTi0EzXODTYI
` + `gnLfBBjnolQqw+emf4pJ4pAtly0Gq1KoxTG2QN+wTd4lsCMjnelklFDjejwnl7Uy
` + `vtxzRBAu/hi/AqDkDFf94m6j+edIrjbi9/JDFtQ9EDlyeqPgw0qwi2fwtJyMD45V
` + `fejbXelUSJSzDIdY
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCTCCA/GgAwIBAgIRAN7Y9G9i4I+ZaslPobE7VL4wDQYJKoZIhvcNAQEMBQAw
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYzMzIzWhgPMjEyMTA1MjAxNzMzMjNa
` + `MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg
` + `SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM
` + `LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAw
` + `DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
` + `4BEPCiIfiK66Q/qa8k+eqf1Q3qsa6Xuu/fPkpuStXVBShhtXd3eqrM0iT4Xxs420
` + `Va0vSB3oZ7l86P9zYfa60n6PzRxdYFckYX330aI7L/oFIdaodB/C9szvROI0oLG+
` + `6RwmIF2zcprH0cTby8MiM7G3v9ykpq27g4WhDC1if2j8giOQL3oHpUaByekZNIHF
` + `dIllsI3RkXmR3xmmxoOxJM1B9MZi7e1CvuVtTGOnSGpNCQiqofehTGwxCN2wFSK8
` + `xysaWlw48G0VzZs7cbxoXMH9QbMpb4tpk0d+T8JfAPu6uWO9UwCLWWydf0CkmA/+
` + `D50/xd1t33X9P4FEaPSg5lYbHXzSLWn7oLbrN2UqMLaQrkoEBg/VGvzmfN0mbflw
` + `+T87bJ/VEOVNlG+gepyCTf89qIQVWOjuYMox4sK0PjzZGsYEuYiq1+OUT3vk/e5K
` + `ag1fCcq2Isy4/iwB2xcXrsQ6ljwdk1fc+EmOnjGKrhuOHJY3S+RFv4ToQBsVyYhC
` + `XGaC3EkqIX0xaCpDimxYhFjWhpDXAjG/zJ+hRLDAMCMhl/LPGRk/D1kzSbPmdjpl
` + `lEMK5695PeBvEBTQdBQdOiYgOU3vWU6tzwwHfiM2/wgvess/q0FDAHfJhppbgbb9
` + `3vgsIUcsvoC5o29JvMsUxsDRvsAfEmMSDGkJoA/X6GECAwEAAaNCMEAwDwYDVR0T
` + `AQH/BAUwAwEB/zAdBgNVHQ4EFgQUgEWm1mZCbGD6ytbwk2UU1aLaOUUwDgYDVR0P
` + `AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBb4+ABTGBGwxK1U/q4g8JDqTQM
` + `1Wh8Oz8yAk4XtPJMAmCctxbd81cRnSnePWw/hxViLVtkZ/GsemvXfqAQyOn1coN7
` + `QeYSw+ZOlu0j2jEJVynmgsR7nIRqE7QkCyZAU+d2FTJUfmee+IiBiGyFGgxz9n7A
` + `JhBZ/eahBbiuoOik/APW2JWLh0xp0W0GznfJ8lAlaQTyDa8iDXmVtbJg9P9qzkvl
` + `FgPXQttzEOyooF8Pb2LCZO4kUz+1sbU7tHdr2YE+SXxt6D3SBv+Yf0FlvyWLiqVk
` + `GDEOlPPTDSjAWgKnqST8UJ0RDcZK/v1ixs7ayqQJU0GUQm1I7LGTErWXHMnCuHKe
` + `UKYuiSZwmTcJ06NgdhcCnGZgPq13ryMDqxPeltQc3n5eO7f1cL9ERYLDLOzm6A9P
` + `oQ3MfcVOsbHgGHZWaPSeNrQRN9xefqBXH0ZPasgcH9WJdsLlEjVUXoultaHOKx3b
` + `UCCb+d3EfqF6pRT488ippOL6bk7zNubwhRa/+y4wjZtwe3kAX78ACJVcjPobH9jZ
` + `ErySads5zdQeaoee5wRKdp3TOfvuCe4bwLRdhOLCHWzEcXzY3g/6+ppLvNom8o+h
` + `Bh5X26G6KSfr9tqhQ3O9IcbARjnuPbvtJnoPY0gz3EHHGPhy0RNW8i2gl3nUp0ah
` + `PtjwbKW0hYAhIttT0Q==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtzCCAj2gAwIBAgIQQRBQTs6Y3H1DDbpHGta3lzAKBggqhkjOPQQDAzCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDYxMTAwMTI0M1oYDzIxMjEwNjExMDExMjQzWjCBmzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6
` + `b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEs0942Xj4m/gKA+WA6F5h
` + `AHYuek9eGpzTRoLJddM4rEV1T3eSueytMVKOSlS3Ub9IhyQrH2D8EHsLYk9ktnGR
` + `pATk0kCYTqFbB7onNo070lmMJmGT/Q7NgwC8cySChFxbo0IwQDAPBgNVHRMBAf8E
` + `BTADAQH/MB0GA1UdDgQWBBQ20iKBKiNkcbIZRu0y1uoF1yJTEzAOBgNVHQ8BAf8E
` + `BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIwYv0wTSrpQTaPaarfLN8Xcqrqu3hzl07n
` + `FrESIoRw6Cx77ZscFi2/MV6AFyjCV/TlAjEAhpwJ3tpzPXpThRML8DMJYZ3YgMh3
` + `CMuLqhPpla3cL0PhybrD27hJWl29C4el6aMO
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrDCCAjOgAwIBAgIQGcztRyV40pyMKbNeSN+vXTAKBggqhkjOPQQDAzCBljEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6
` + `b24gUkRTIHVzLWVhc3QtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTAgFw0yMTA1MjEyMzE1NTZaGA8yMTIxMDUyMjAwMTU1NlowgZYxCzAJBgNV
` + `BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD
` + `VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE
` + `UyB1cy1lYXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw
` + `djAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfDcv+GGRESD9wT+I5YIPRsD3L+/jsiIis
` + `Tr7t9RSbFl+gYpO7ZbDXvNbV5UGOC5lMJo/SnqFRTC6vL06NF7qOHfig3XO8QnQz
` + `6T5uhhrhnX2RSY3/10d2kTyHq3ZZg3+jQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD
` + `VR0OBBYEFLDyD3PRyNXpvKHPYYxjHXWOgfPnMA4GA1UdDwEB/wQEAwIBhjAKBggq
` + `hkjOPQQDAwNnADBkAjB20HQp6YL7CqYD82KaLGzgw305aUKw2aMrdkBR29J183jY
` + `6Ocj9+Wcif9xnRMS+7oCMAvrt03rbh4SU9BohpRUcQ2Pjkh7RoY0jDR4Xq4qzjNr
` + `5UFr3BXpFvACxXF51BksGQ==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjWgAwIBAgIQeKbS5zvtqDvRtwr5H48cAjAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTIwMTcxOTU1WhgPMjEyMTA1MjAxODE5NTVaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgbWUtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABEKjgUaAPmUlRMEQdBC7BScAGosJ1zRV
` + `LDd38qTBjzgmwBfQJ5ZfGIvyEK5unB09MB4e/3qqK5I/L6Qn5Px/n5g4dq0c7MQZ
` + `u7G9GBYm90U3WRJBf7lQrPStXaRnS4A/O6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUNKcAbGEIn03/vkwd8g6jNyiRdD4wDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2cAMGQCMHIeTrjenCSYuGC6txuBt/0ZwnM/ciO9kHGWVCoK8QLs
` + `jGghb5/YSFGZbmQ6qpGlSAIwVOQgdFfTpEfe5i+Vs9frLJ4QKAfc27cTNYzRIM0I
` + `E+AJgK4C4+DiyyMzOpiCfmvq
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGCDCCA/CgAwIBAgIQSFkEUzu9FYgC5dW+5lnTgjANBgkqhkiG9w0BAQwFADCB
` + `nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB
` + `bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G
` + `A1UEBwwHU2VhdHRsZTAgFw0yMTA2MTEwMDA4MzZaGA8yMTIxMDYxMTAxMDgzNlow
` + `gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws
` + `QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO
` + `BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDx
` + `my5Qmd8zdwaI/KOKV9Xar9oNbhJP5ED0JCiigkuvCkg5qM36klszE8JhsUj40xpp
` + `vQw9wkYW4y+C8twBpzKGBvakqMnoaVUV7lOCKx0RofrnNwkZCboTBB4X/GCZ3fIl
` + `YTybS7Ehi1UuiaZspIT5A2jidoA8HiBPk+mTg1UUkoWS9h+MEAPa8L4DY6fGf4pO
` + `J1Gk2cdePuNzzIrpm2yPto+I8MRROwZ3ha7ooyymOXKtz2c7jEHHJ314boCXAv9G
` + `cdo27WiebewZkHHH7Zx9iTIVuuk2abyVSzvLVeGv7Nuy4lmSqa5clWYqWsGXxvZ2
` + `0fZC5Gd+BDUMW1eSpW7QDTk3top6x/coNoWuLSfXiC5ZrJkIKimSp9iguULgpK7G
` + `abMMN4PR+O+vhcB8E879hcwmS2yd3IwcPTl3QXxufqeSV58/h2ibkqb/W4Bvggf6
` + `5JMHQPlPHOqMCVFIHP1IffIo+Of7clb30g9FD2j3F4qgV3OLwEDNg/zuO1DiAvH1
` + `L+OnmGHkfbtYz+AVApkAZrxMWwoYrwpauyBusvSzwRE24vLTd2i80ZDH422QBLXG
` + `rN7Zas8rwIiBKacJLYtBYETw8mfsNt8gb72aIQX6cZOsphqp6hUtKaiMTVgGazl7
` + `tBXqbB+sIv3S9X6bM4cZJKkMJOXbnyCCLZFYv8TurwIDAQABo0IwQDAPBgNVHRMB
` + `Af8EBTADAQH/MB0GA1UdDgQWBBTOVtaS1b/lz6yJDvNk65vEastbQTAOBgNVHQ8B
` + `Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBABEONg+TmMZM/PrYGNAfB4S41zp1
` + `3CVjslZswh/pC4kgXSf8cPJiUOzMwUevuFQj7tCqxQtJEygJM2IFg4ViInIah2kh
` + `xlRakEGGw2dEVlxZAmmLWxlL1s1lN1565t5kgVwM0GVfwYM2xEvUaby6KDVJIkD3
` + `aM6sFDBshvVA70qOggM6kU6mwTbivOROzfoIQDnVaT+LQjHqY/T+ok6IN0YXXCWl
` + `Favai8RDjzLDFwXSRvgIK+1c49vlFFY4W9Efp7Z9tPSZU1TvWUcKdAtV8P2fPHAS
` + `vAZ+g9JuNfeawhEibjXkwg6Z/yFUueQCQOs9TRXYogzp5CMMkfdNJF8byKYqHscs
` + `UosIcETnHwqwban99u35sWcoDZPr6aBIrz7LGKTJrL8Nis8qHqnqQBXu/fsQEN8u
` + `zJ2LBi8sievnzd0qI0kaWmg8GzZmYH1JCt1GXSqOFkI8FMy2bahP7TUQR1LBUKQ3
` + `hrOSqldkhN+cSAOnvbQcFzLr+iEYEk34+NhcMIFVE+51KJ1n6+zISOinr6mI3ckX
` + `6p2tmiCD4Shk2Xx/VTY/KGvQWKFcQApWezBSvDNlGe0yV71LtLf3dr1pr4ofo7cE
` + `rYucCJ40bfxEU/fmzYdBF32xP7AOD9U0FbOR3Mcthc6Z6w20WFC+zru8FGY08gPf
` + `WT1QcNdw7ntUJP/w
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrzCCAjWgAwIBAgIQARky6+5PNFRkFVOp3Ob1CTAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjIwNTIzMTg0MTI4WhgPMjEyMjA1MjMxOTQxMjdaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgZXUtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABNVGL5oF7cfIBxKyWd2PVK/S5yQfaJY3
` + `QFHWvEdt6951n9JhiiPrHzfVHsxZp1CBjILRMzjgRbYWmc8qRoLkgGE7htGdwudJ
` + `Fa/WuKzO574Prv4iZXUnVGTboC7JdvKbh6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUgDeIIEKynwUbNXApdIPnmRWieZwwDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2gAMGUCMEOOJfucrST+FxuqJkMZyCM3gWGZaB+/w6+XUAJC6hFM
` + `uSTY0F44/bERkA4XhH+YGAIxAIpJQBakCA1/mXjsTnQ+0El9ty+LODp8ibkn031c
` + `8DKDS7pR9UK7ZYdR6zFg3ZCjQw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjOgAwIBAgIQJvkWUcYLbnxtuwnyjMmntDAKBggqhkjOPQQDAzCBljEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6
` + `b24gUkRTIGV1LXdlc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTAgFw0yMTA1MjUyMjI2MTJaGA8yMTIxMDUyNTIzMjYxMlowgZYxCzAJBgNV
` + `BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD
` + `VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE
` + `UyBldS13ZXN0LTMgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw
` + `djAQBgcqhkjOPQIBBgUrgQQAIgNiAARENn8uHCyjn1dFax4OeXxvbV861qsXFD9G
` + `DshumTmFzWWHN/69WN/AOsxy9XN5S7Cgad4gQgeYYYgZ5taw+tFo/jQvCLY//uR5
` + `uihcLuLJ78opvRPvD9kbWZ6oXfBtFkWjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD
` + `VR0OBBYEFKiK3LpoF+gDnqPldGSwChBPCYciMA4GA1UdDwEB/wQEAwIBhjAKBggq
` + `hkjOPQQDAwNpADBmAjEA+7qfvRlnvF1Aosyp9HzxxCbN7VKu+QXXPhLEBWa5oeWW
` + `UOcifunf/IVLC4/FGCsLAjEAte1AYp+iJyOHDB8UYkhBE/1sxnFaTiEPbvQBU0wZ
` + `SuwWVLhu2wWDuSW+K7tTuL8p
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/zCCAuegAwIBAgIRAKeDpqX5WFCGNo94M4v69sUwDQYJKoZIhvcNAQELBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBldS13ZXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNTIyMTgzM1oYDzIwNjEwNTI1MjMxODMzWjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCcKOTEMTfzvs4H
` + `WtJR8gI7GXN6xesulWtZPv21oT+fLGwJ+9Bv8ADCGDDrDxfeH/HxJmzG9hgVAzVn
` + `4g97Bn7q07tGZM5pVi96/aNp11velZT7spOJKfJDZTlGns6DPdHmx48whpdO+dOb
` + `6+eR0VwCIv+Vl1fWXgoACXYCoKjhxJs+R+fwY//0JJ1YG8yjZ+ghLCJmvlkOJmE1
` + `TCPUyIENaEONd6T+FHGLVYRRxC2cPO65Jc4yQjsXvvQypoGgx7FwD5voNJnFMdyY
` + `754JGPOOe/SZdepN7Tz7UEq8kn7NQSbhmCsgA/Hkjkchz96qN/YJ+H/okiQUTNB0
` + `eG9ogiVFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFjayw9Y
` + `MjbxfF14XAhMM2VPl0PfMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC
` + `AQEAAtmx6d9+9CWlMoU0JCirtp4dSS41bBfb9Oor6GQ8WIr2LdfZLL6uES/ubJPE
` + `1Sh5Vu/Zon5/MbqLMVrfniv3UpQIof37jKXsjZJFE1JVD/qQfRzG8AlBkYgHNEiS
` + `VtD4lFxERmaCkY1tjKB4Dbd5hfhdrDy29618ZjbSP7NwAfnwb96jobCmMKgxVGiH
` + `UqsLSiEBZ33b2hI7PJ6iTJnYBWGuiDnsWzKRmheA4nxwbmcQSfjbrNwa93w3caL2
` + `v/4u54Kcasvcu3yFsUwJygt8z43jsGAemNZsS7GWESxVVlW93MJRn6M+MMakkl9L
` + `tWaXdHZ+KUV7LhfYLb0ajvb40w==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBDCCAuygAwIBAgIQJ5oxPEjefCsaESSwrxk68DANBgkqhkiG9w0BAQsFADCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjExNzA1WhgPMjA2MjA2MDYyMjE3MDVaMIGa
` + `MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j
` + `LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt
` + `YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALTQt5eX
` + `g+VP3BjO9VBkWJhE0GfLrU/QIk32I6WvrnejayTrlup9H1z4QWlXF7GNJrqScRMY
` + `KhJHlcP05aPsx1lYco6pdFOf42ybXyWHHJdShj4A5glU81GTT+VrXGzHSarLmtua
` + `eozkQgPpDsSlPt0RefyTyel7r3Cq+5K/4vyjCTcIqbfgaGwTU36ffjM1LaPCuE4O
` + `nINMeD6YuImt2hU/mFl20FZ+IZQUIFZZU7pxGLqTRz/PWcH8tDDxnkYg7tNuXOeN
` + `JbTpXrw7St50/E9ZQ0llGS+MxJD8jGRAa/oL4G/cwnV8P2OEPVVkgN9xDDQeieo0
` + `3xkzolkDkmeKOnUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU
` + `bwu8635iQGQMRanekesORM8Hkm4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB
` + `CwUAA4IBAQAgN6LE9mUgjsj6xGCX1afYE69fnmCjjb0rC6eEe1mb/QZNcyw4XBIW
` + `6+zTXo4mjZ4ffoxb//R0/+vdTE7IvaLgfAZgFsLKJCtYDDstXZj8ujQnGR9Pig3R
` + `W+LpNacvOOSJSawNQq0Xrlcu55AU4buyD5VjcICnfF1dqBMnGTnh27m/scd/ZMx/
` + `kapHZ/fMoK2mAgSX/NvUKF3UkhT85vSSM2BTtET33DzCPDQTZQYxFBa4rFRmFi4c
` + `BLlmIReiCGyh3eJhuUUuYAbK6wLaRyPsyEcIOLMQmZe1+gAFm1+1/q5Ke9ugBmjf
` + `PbTWjsi/lfZ5CdVAhc5lmZj/l5aKqwaS
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAKKPTYKln9L4NTx9dpZGUjowCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTIxMjI1NTIxWhgPMjEyMTA1MjEyMzU1MjFaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgZXUtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE/owTReDvaRqdmbtTzXbyRmEpKCETNj6O
` + `hZMKH0F8oU9Tmn8RU7kQQj6xUKEyjLPrFBN7c+26TvrVO1KmJAvbc8bVliiJZMbc
` + `C0yV5PtJTalvlMZA1NnciZuhxaxrzlK1o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBT4i5HaoHtrs7Mi8auLhMbKM1XevDAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIxAK9A+8/lFdX4XJKgfP+ZLy5ySXC2E0Spoy12Gv2GdUEZ
` + `p1G7c1KbWVlyb1d6subzkQIwKyH0Naf/3usWfftkmq8SzagicKz5cGcEUaULq4tO
` + `GzA/AMpr63IDBAqkZbMDTCmH
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrzCCAjWgAwIBAgIQTgIvwTDuNWQo0Oe1sOPQEzAKBggqhkjOPQQDAzCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTI0MjEwNjM4WhgPMjEyMTA1MjQyMjA2MzhaMIGXMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS
` + `RFMgZXUtbm9ydGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs
` + `ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJuzXLU8q6WwSKXBvx8BbdIi3mPhb7Xo
` + `rNJBfuMW1XRj5BcKH1ZoGaDGw+BIIwyBJg8qNmCK8kqIb4cH8/Hbo3Y+xBJyoXq/
` + `cuk8aPrxiNoRsKWwiDHCsVxaK9L7GhHHAqNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd
` + `BgNVHQ4EFgQUYgcsdU4fm5xtuqLNppkfTHM2QMYwDgYDVR0PAQH/BAQDAgGGMAoG
` + `CCqGSM49BAMDA2gAMGUCMQDz/Rm89+QJOWJecYAmYcBWCcETASyoK1kbr4vw7Hsg
` + `7Ew3LpLeq4IRmTyuiTMl0gMCMAa0QSjfAnxBKGhAnYxcNJSntUyyMpaXzur43ec0
` + `3D8npJghwC4DuICtKEkQiI5cSg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAORIGqQXLTcbbYT2upIsSnQwDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMjA1MjMxODM0MjJaGA8yMTIyMDUyMzE5MzQyMlowgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAPKukwsW2s/h
` + `1k+Hf65pOP0knVBnOnMQyT1mopp2XHGdXznj9xS49S30jYoUnWccyXgD983A1bzu
` + `w4fuJRHg4MFdz/NWTgXvy+zy0Roe83OPIJjUmXnnzwUHQcBa9vl6XUO65iQ3pbSi
` + `fQfNDFXD8cvuXbkezeADoy+iFAlzhXTzV9MD44GTuo9Z3qAXNGHQCrgRSCL7uRYt
` + `t1nfwboCbsVRnElopn2cTigyVXE62HzBUmAw1GTbAZeFAqCn5giBWYAfHwTUldRL
` + `6eEa6atfsS2oPNus4ZENa1iQxXq7ft+pMdNt0qKXTCZiiCZjmLkY0V9kWwHTRRF8
` + `r+75oSL//3di43QnuSCgjwMRIeWNtMud5jf3eQzSBci+9njb6DrrSUbx7blP0srg
` + `94/C/fYOp/0/EHH34w99Th14VVuGWgDgKahT9/COychLOubXUT6vD1As47S9KxTv
` + `yYleVKwJnF9cVjepODN72fNlEf74BwzgSIhUmhksmZSeJBabrjSUj3pdyo/iRZN/
` + `CiYz9YPQ29eXHPQjBZVIUqWbOVfdwsx0/Xu5T1e7yyXByQ3/oDulahtcoKPAFQ3J
` + `ee6NJK655MdS7pM9hJnU2Rzu3qZ/GkM6YK7xTlMXVouPUZov/VbiaCKbqYDs8Dg+
` + `UKdeNXAT6+BMleGQzly1X7vjhgeA8ugVAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFJdaPwpCf78UolFTEn6GO85/QwUIMA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEAWkxHIT3mers5YnZRSVjmpxCLivGj1jMB9VYC
` + `iKqTAeIvD0940L0YaZgivQll5pue8UUcQ6M2uCdVVAsNJdmQ5XHIYiGOknYPtxzO
` + `aO+bnZp7VIZw/vJ49hvH6RreA2bbxYMZO/ossYdcWsWbOKHFrRmAw0AhtK/my51g
` + `obV7eQg+WmlE5Iqc75ycUsoZdc3NimkjBi7LQoNP1HMvlLHlF71UZhQDdq+/WdV7
` + `0zmg+epkki1LjgMmuPyb+xWuYkFKT1/faX+Xs62hIm5BY+aI4if4RuQ+J//0pOSs
` + `UajrjTo+jLGB8A96jAe8HaFQenbwMjlaHRDAF0wvbkYrMr5a6EbneAB37V05QD0Y
` + `Rh4L4RrSs9DX2hbSmS6iLDuPEjanHKzglF5ePEvnItbRvGGkynqDVlwF+Bqfnw8l
` + `0i8Hr1f1/LP1c075UjkvsHlUnGgPbLqA0rDdcxF8Fdlv1BunUjX0pVlz10Ha5M6P
` + `AdyWUOneOfaA5G7jjv7i9qg3r99JNs1/Lmyg/tV++gnWTAsSPFSSEte81kmPhlK3
` + `2UtAO47nOdTtk+q4VIRAwY1MaOR7wTFZPfer1mWs4RhKNu/odp8urEY87iIzbMWT
` + `QYO/4I6BGj9rEWNGncvR5XTowwIthMCj2KWKM3Z/JxvjVFylSf+s+FFfO1bNIm6h
` + `u3UBpZI=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtDCCAjmgAwIBAgIQenQbcP/Zbj9JxvZ+jXbRnTAKBggqhkjOPQQDAzCBmTEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTIwMAYDVQQDDClBbWF6
` + `b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTAgFw0yMTA1MjEyMjMzMjRaGA8yMTIxMDUyMTIzMzMyNFowgZkxCzAJ
` + `BgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMw
` + `EQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1hem9u
` + `IFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATlBHiEM9LoEb1Hdnd5j2VpCDOU
` + `5nGuFoBD8ROUCkFLFh5mHrHfPXwBc63heW9WrP3qnDEm+UZEUvW7ROvtWCTPZdLz
` + `Z4XaqgAlSqeE2VfUyZOZzBSgUUJk7OlznXfkCMOjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFDT/ThjQZl42Nv/4Z/7JYaPNMly2MA4GA1UdDwEB/wQEAwIB
` + `hjAKBggqhkjOPQQDAwNpADBmAjEAnZWmSgpEbmq+oiCa13l5aGmxSlfp9h12Orvw
` + `Dq/W5cENJz891QD0ufOsic5oGq1JAjEAp5kSJj0MxJBTHQze1Aa9gG4sjHBxXn98
` + `4MP1VGsQuhfndNHQb4V0Au7OWnOeiobq
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/zCCAuegAwIBAgIRAMgnyikWz46xY6yRgiYwZ3swDQYJKoZIhvcNAQELBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMDE2NDkxMloYDzIwNjEwNTIwMTc0OTEyWjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCi8JYOc9cYSgZH
` + `gYPxLk6Xcc7HqzamvsnjYU98Dcb98y6iDqS46Ra2Ne02MITtU5MDL+qjxb8WGDZV
` + `RUA9ZS69tkTO3gldW8QdiSh3J6hVNJQW81F0M7ZWgV0gB3n76WCmfT4IWos0AXHM
` + `5v7M/M4tqVmCPViQnZb2kdVlM3/Xc9GInfSMCgNfwHPTXl+PXX+xCdNBePaP/A5C
` + `5S0oK3HiXaKGQAy3K7VnaQaYdiv32XUatlM4K2WS4AMKt+2cw3hTCjlmqKRHvYFQ
` + `veWCXAuc+U5PQDJ9SuxB1buFJZhT4VP3JagOuZbh5NWpIbOTxlAJOb5pGEDuJTKi
` + `1gQQQVEFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNXm+N87
` + `OFxK9Af/bjSxDCiulGUzMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC
` + `AQEAkqIbkgZ45spvrgRQ6n9VKzDLvNg+WciLtmVrqyohwwJbj4pYvWwnKQCkVc7c
` + `hUOSBmlSBa5REAPbH5o8bdt00FPRrD6BdXLXhaECKgjsHe1WW08nsequRKD8xVmc
` + `8bEX6sw/utBeBV3mB+3Zv7ejYAbDFM4vnRsWtO+XqgReOgrl+cwdA6SNQT9oW3e5
` + `rSQ+VaXgJtl9NhkiIysq9BeYigxqS/A13pHQp0COMwS8nz+kBPHhJTsajHCDc8F4
` + `HfLi6cgs9G0gaRhT8FCH66OdGSqn196sE7Y3bPFFFs/3U+vxvmQgoZC6jegQXAg5
` + `Prxd+VNXtNI/azitTysQPumH7A==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEBTCCAu2gAwIBAgIRAO8bekN7rUReuNPG8pSTKtEwDQYJKoZIhvcNAQELBQAw
` + `gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq
` + `QW1hem9uIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD
` + `VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMjM0N1oYDzIwNjEwNTIxMjMyMzQ3WjCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCTTYds
` + `Tray+Q9VA5j5jTh5TunHKFQzn68ZbOzdqaoi/Rq4ohfC0xdLrxCpfqn2TGDHN6Zi
` + `2qGK1tWJZEd1H0trhzd9d1CtGK+3cjabUmz/TjSW/qBar7e9MA67/iJ74Gc+Ww43
` + `A0xPNIWcL4aLrHaLm7sHgAO2UCKsrBUpxErOAACERScVYwPAfu79xeFcX7DmcX+e
` + `lIqY16pQAvK2RIzrekSYfLFxwFq2hnlgKHaVgZ3keKP+nmXcXmRSHQYUUr72oYNZ
` + `HcNYl2+gxCc9ccPEHM7xncVEKmb5cWEWvVoaysgQ+osi5f5aQdzgC2X2g2daKbyA
` + `XL/z5FM9GHpS5BJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE
` + `FBDAiJ7Py9/A9etNa/ebOnx5l5MGMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B
` + `AQsFAAOCAQEALMh/+81fFPdJV/RrJUeoUvFCGMp8iaANu97NpeJyKitNOv7RoeVP
` + `WjivS0KcCqZaDBs+p6IZ0sLI5ZH098LDzzytcfZg0PsGqUAb8a0MiU/LfgDCI9Ee
` + `jsOiwaFB8k0tfUJK32NPcIoQYApTMT2e26lPzYORSkfuntme2PTHUnuC7ikiQrZk
` + `P+SZjWgRuMcp09JfRXyAYWIuix4Gy0eZ4rpRuaTK6mjAb1/LYoNK/iZ/gTeIqrNt
` + `l70OWRsWW8jEmSyNTIubGK/gGGyfuZGSyqoRX6OKHESkP6SSulbIZHyJ5VZkgtXo
` + `2XvyRyJ7w5pFyoofrL3Wv0UF8yt/GDszmg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/zCCA+egAwIBAgIRAMDk/F+rrhdn42SfE+ghPC8wDQYJKoZIhvcNAQEMBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMTIyNTEyMloYDzIxMjEwNTIxMjM1MTIyWjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2twMALVg9vRVu
` + `VNqsr6N8thmp3Dy8jEGTsm3GCQ+C5P2YcGlD/T/5icfWW84uF7Sx3ezcGlvsqFMf
` + `Ukj9sQyqtz7qfFFugyy7pa/eH9f48kWFHLbQYm9GEgbYBIrWMp1cy3vyxuMCwQN4
` + `DCncqU+yNpy0CprQJEha3PzY+3yJOjDQtc3zr99lyECCFJTDUucxHzyQvX89eL74
` + `uh8la0lKH3v9wPpnEoftbrwmm5jHNFdzj7uXUHUJ41N7af7z7QUfghIRhlBDiKtx
` + `5lYZemPCXajTc3ryDKUZC/b+B6ViXZmAeMdmQoPE0jwyEp/uaUcdp+FlUQwCfsBk
` + `ayPFEApTWgPiku2isjdeTVmEgL8bJTDUZ6FYFR7ZHcYAsDzcwHgIu3GGEMVRS3Uf
` + `ILmioiyly9vcK4Sa01ondARmsi/I0s7pWpKflaekyv5boJKD/xqwz9lGejmJHelf
` + `8Od2TyqJScMpB7Q8c2ROxBwqwB72jMCEvYigB+Wnbb8RipliqNflIGx938FRCzKL
` + `UQUBmNAznR/yRRL0wHf9UAE/8v9a09uZABeiznzOFAl/frHpgdAbC00LkFlnwwgX
` + `g8YfEFlkp4fLx5B7LtoO6uVNFVimLxtwirpyKoj3G4M/kvSTux8bTw0heBCmWmKR
` + `57MS6k7ODzbv+Kpeht2hqVZCNFMxoQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBRuMnDhJjoj7DcKALj+HbxEqj3r6jAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQEMBQADggIBALSnXfx72C3ldhBP5kY4Mo2DDaGQ8FGpTOOiD95d
` + `0rf7I9LrsBGVqu/Nir+kqqP80PB70+Jy9fHFFigXwcPBX3MpKGxK8Cel7kVf8t1B
` + `4YD6A6bqlzP+OUL0uGWfZpdpDxwMDI2Flt4NEldHgXWPjvN1VblEKs0+kPnKowyg
` + `jhRMgBbD/y+8yg0fIcjXUDTAw/+INcp21gWaMukKQr/8HswqC1yoqW9in2ijQkpK
` + `2RB9vcQ0/gXR0oJUbZQx0jn0OH8Agt7yfMAnJAdnHO4M3gjvlJLzIC5/4aGrRXZl
` + `JoZKfJ2fZRnrFMi0nhAYDeInoS+Rwx+QzaBk6fX5VPyCj8foZ0nmqvuYoydzD8W5
` + `mMlycgxFqS+DUmO+liWllQC4/MnVBlHGB1Cu3wTj5kgOvNs/k+FW3GXGzD3+rpv0
` + `QTLuwSbMr+MbEThxrSZRSXTCQzKfehyC+WZejgLb+8ylLJUA10e62o7H9PvCrwj+
` + `ZDVmN7qj6amzvndCP98sZfX7CFZPLfcBd4wVIjHsFjSNEwWHOiFyLPPG7cdolGKA
` + `lOFvonvo4A1uRc13/zFeP0Xi5n5OZ2go8aOOeGYdI2vB2sgH9R2IASH/jHmr0gvY
` + `0dfBCcfXNgrS0toq0LX/y+5KkKOxh52vEYsJLdhqrveuZhQnsFEm/mFwjRXkyO7c
` + `2jpC
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGADCCA+igAwIBAgIQYe0HgSuFFP9ivYM2vONTrTANBgkqhkiG9w0BAQwFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE4MzMyMVoYDzIxMjEwNTE5MTkzMzIxWjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuO7QPKfPMTo2
` + `POQWvzDLwi5f++X98hGjORI1zkN9kotCYH5pAzSBwBPoMNaIfedgmsIxGHj2fq5G
` + `4oXagNhNuGP79Zl6uKW5H7S74W7aWM8C0s8zuxMOI4GZy5h2IfQk3m/3AzZEX5w8
` + `UtNPkzo2feDVOkerHT+j+vjXgAxZ4wHnuMDcRT+K4r9EXlAH6X9b/RO0JlfEwmNz
` + `xlqqGxocq9qRC66N6W0HF2fNEAKP84n8H80xcZBOBthQORRi8HSmKcPdmrvwCuPz
` + `M+L+j18q6RAVaA0ABbD0jMWcTf0UvjUfBStn5mvu/wGlLjmmRkZsppUTRukfwqXK
` + `yltUsTq0tOIgCIpne5zA4v+MebbR5JBnsvd4gdh5BI01QH470yB7BkUefZ9bobOm
` + `OseAAVXcYFJKe4DAA6uLDrqOfFSxV+CzVvEp3IhLRaik4G5MwI/h2c/jEYDqkg2J
` + `HMflxc2gcSMdk7E5ByLz5f6QrFfSDFk02ZJTs4ssbbUEYohht9znPMQEaWVqATWE
` + `3n0VspqZyoBNkH/agE5GiGZ/k/QyeqzMNj+c9kr43Upu8DpLrz8v2uAp5xNj3YVg
` + `ihaeD6GW8+PQoEjZ3mrCmH7uGLmHxh7Am59LfEyNrDn+8Rq95WvkmbyHSVxZnBmo
` + `h/6O3Jk+0/QhIXZ2hryMflPcYWeRGH0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB
` + `/zAdBgNVHQ4EFgQU2eFK7+R3x/me8roIBNxBrplkM6EwDgYDVR0PAQH/BAQDAgGG
` + `MA0GCSqGSIb3DQEBDAUAA4ICAQB5gWFe5s7ObQFj1fTO9L6gYgtFhnwdmxU0q8Ke
` + `HWCrdFmyXdC39qdAFOwM5/7fa9zKmiMrZvy9HNvCXEp4Z7z9mHhBmuqPZQx0qPgU
` + `uLdP8wGRuWryzp3g2oqkX9t31Z0JnkbIdp7kfRT6ME4I4VQsaY5Y3mh+hIHOUvcy
` + `p+98i3UuEIcwJnVAV9wTTzrWusZl9iaQ1nSYbmkX9bBssJ2GmtW+T+VS/1hJ/Q4f
` + `AlE3dOQkLFoPPb3YRWBHr2n1LPIqMVwDNAuWavRA2dSfaLl+kzbn/dua7HTQU5D4
` + `b2Fu2vLhGirwRJe+V7zdef+tI7sngXqjgObyOeG5O2BY3s+um6D4fS0Th3QchMO7
` + `0+GwcIgSgcjIjlrt6/xJwJLE8cRkUUieYKq1C4McpZWTF30WnzOPUzRzLHkcNzNA
` + `0A7sKMK6QoYWo5Rmo8zewUxUqzc9oQSrYADP7PEwGncLtFe+dlRFx+PA1a+lcIgo
` + `1ZGfXigYtQ3VKkcknyYlJ+hN4eCMBHtD81xDy9iP2MLE41JhLnoB2rVEtewO5diF
` + `7o95Mwl84VMkLhhHPeGKSKzEbBtYYBifHNct+Bst8dru8UumTltgfX6urH3DN+/8
` + `JF+5h3U8oR2LL5y76cyeb+GWDXXy9zoQe2QvTyTy88LwZq1JzujYi2k8QiLLhFIf
` + `FEv9Bg==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICsDCCAjagAwIBAgIRAMgApnfGYPpK/fD0dbN2U4YwCgYIKoZIzj0EAwMwgZcx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwnQW1h
` + `em9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMCAXDTIxMDUxOTE4MzgxMVoYDzIxMjEwNTE5MTkzODExWjCBlzELMAkG
` + `A1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzAR
` + `BgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6b24g
` + `UkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0
` + `bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfEWl6d4qSuIoECdZPp+39LaKsfsX7
` + `THs3/RrtT0+h/jl3bjZ7Qc68k16x+HGcHbaayHfqD0LPdzH/kKtNSfQKqemdxDQh
` + `Z4pwkixJu8T1VpXZ5zzCvBXCl75UqgEFS92jQjBAMA8GA1UdEwEB/wQFMAMBAf8w
` + `HQYDVR0OBBYEFFPrSNtWS5JU+Tvi6ABV231XbjbEMA4GA1UdDwEB/wQEAwIBhjAK
` + `BggqhkjOPQQDAwNoADBlAjEA+a7hF1IrNkBd2N/l7IQYAQw8chnRZDzh4wiGsZsC
` + `6A83maaKFWUKIb3qZYXFSi02AjAbp3wxH3myAmF8WekDHhKcC2zDvyOiKLkg9Y6v
` + `ZVmyMR043dscQbcsVoacOYv198c=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICtDCCAjqgAwIBAgIRAPhVkIsQ51JFhD2kjFK5uAkwCgYIKoZIzj0EAwMwgZkx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h
` + `em9uIFJEUyBldS1jZW50cmFsLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjIwNjA2MjEyOTE3WhgPMjEyMjA2MDYyMjI5MTdaMIGZMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv
` + `biBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEA5xnIEBtG5b2nmbj49UEwQza
` + `yX0844fXjccYzZ8xCDUe9dS2XOUi0aZlGblgSe/3lwjg8fMcKXLObGGQfgIx1+5h
` + `AIBjORis/dlyN5q/yH4U5sjS8tcR0GDGVHrsRUZCo0IwQDAPBgNVHRMBAf8EBTAD
` + `AQH/MB0GA1UdDgQWBBRK+lSGutXf4DkTjR3WNfv4+KeNFTAOBgNVHQ8BAf8EBAMC
` + `AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJ4NxQ1Gerqr70ZrnUqc62Vl8NNqTzInamCG
` + `Kce3FTsMWbS9qkgrjZkO9QqOcGIw/gIwSLrwUT+PKr9+H9eHyGvpq9/3AIYSnFkb
` + `Cf3dyWPiLKoAtLFwjzB/CkJlsAS1c8dS
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/jCCA+agAwIBAgIQGZH12Q7x41qIh9vDu9ikTjANBgkqhkiG9w0BAQwFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTI1MjIyMjMzWhgPMjEyMTA1MjUyMzIyMzNaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgZXUtd2VzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMqE47sHXWzdpuqj
` + `JHb+6jM9tDbQLDFnYjDWpq4VpLPZhb7xPNh9gnYYTPKG4avG421EblAHqzy9D2pN
` + `1z90yKbIfUb/Sy2MhQbmZomsObhONEra06fJ0Dydyjswf1iYRp2kwpx5AgkVoNo7
` + `3dlws73zFjD7ImKvUx2C7B75bhnw2pJWkFnGcswl8fZt9B5Yt95sFOKEz2MSJE91
` + `kZlHtya19OUxZ/cSGci4MlOySzqzbGwUqGxEIDlY8I39VMwXaYQ8uXUN4G780VcL
` + `u46FeyRGxZGz2n3hMc805WAA1V5uir87vuirTvoSVREET97HVRGVVNJJ/FM6GXr1
` + `VKtptybbo81nefYJg9KBysxAa2Ao2x2ry/2ZxwhS6VZ6v1+90bpZA1BIYFEDXXn/
` + `dW07HSCFnYSlgPtSc+Muh15mdr94LspYeDqNIierK9i4tB6ep7llJAnq0BU91fM2
` + `JPeqyoTtc3m06QhLf68ccSxO4l8Hmq9kLSHO7UXgtdjfRVaffngopTNk8qK7bIb7
` + `LrgkqhiQw/PRCZjUdyXL153/fUcsj9nFNe25gM4vcFYwH6c5trd2tUl31NTi1MfG
` + `Mgp3d2dqxQBIYANkEjtBDMy3SqQLIo9EymqmVP8xx2A/gCBgaxvMAsI6FSWRoC7+
` + `hqJ8XH4mFnXSHKtYMe6WPY+/XZgtAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w
` + `HQYDVR0OBBYEFIkXqTnllT/VJnI2NqipA4XV8rh1MA4GA1UdDwEB/wQEAwIBhjAN
` + `BgkqhkiG9w0BAQwFAAOCAgEAKjSle8eenGeHgT8pltWCw/HzWyQruVKhfYIBfKJd
` + `MhV4EnH5BK7LxBIvpXGsFUrb0ThzSw0fn0zoA9jBs3i/Sj6KyeZ9qUF6b8ycDXd+
` + `wHonmJiQ7nk7UuMefaYAfs06vosgl1rI7eBHC0itexIQmKh0aX+821l4GEgEoSMf
` + `loMFTLXv2w36fPHHCsZ67ODldgcZbKNnpCTX0YrCwEYO3Pz/L398btiRcWGrewrK
` + `jdxAAyietra8DRno1Zl87685tfqc6HsL9v8rVw58clAo9XAQvT+fmSOFw/PogRZ7
` + `OMHUat3gu/uQ1M5S64nkLLFsKu7jzudBuoNmcJysPlzIbqJ7vYc82OUGe9ucF3wi
` + `3tbKQ983hdJiTExVRBLX/fYjPsGbG3JtPTv89eg2tjWHlPhCDMMxyRKl6isu2RTq
` + `6VT489Z2zQrC33MYF8ZqO1NKjtyMAMIZwxVu4cGLkVsqFmEV2ScDHa5RadDyD3Ok
` + `m+mqybhvEVm5tPgY6p0ILPMN3yvJsMSPSvuBXhO/X5ppNnpw9gnxpwbjQKNhkFaG
` + `M5pkADZ14uRguOLM4VthSwUSEAr5VQYCFZhEwK+UOyJAGiB/nJz6IxL5XBNUXmRM
` + `Hl8Xvz4riq48LMQbjcVQj0XvH941yPh+P8xOi00SGaQRaWp55Vyr4YKGbV0mEDz1
` + `r1o=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIF/zCCA+egAwIBAgIRAKwYju1QWxUZpn6D1gOtwgQwDQYJKoZIhvcNAQEMBQAw
` + `gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn
` + `QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyMDE2NTM1NFoYDzIxMjEwNTIwMTc1MzU0WjCBlzEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6
` + `b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCKdBP1U4lqWWkc
` + `Cb25/BKRTsvNVnISiKocva8GAzJyKfcGRa85gmgu41U+Hz6+39K+XkRfM0YS4BvQ
` + `F1XxWT0bNyypuvwCvmYShSTjN1TY0ltncDddahTajE/4MdSOZb/c98u0yt03cH+G
` + `hVwRyT50h0v/UEol50VfwcVAEZEgcQQYhf1IFUFlIvKpmDOqLuFakOnc7c9akK+i
` + `ivST+JO1tgowbnNkn2iLlSSgUWgb1gjaOsNfysagv1RXdlyPw3EyfwkFifAQvF2P
` + `Q0ayYZfYS640cccv7efM1MSVyFHR9PrrDsF/zr2S2sGPbeHr7R/HwLl+S5J/l9N9
` + `y0rk6IHAWV4dEkOvgpnuJKURwA48iu1Hhi9e4moNS6eqoK2KmY3VFpuiyWcA73nH
` + `GSmyaH+YuMrF7Fnuu7GEHZL/o6+F5cL3mj2SJJhL7sz0ryf5Cs5R4yN9BIEj/f49
` + `wh84pM6nexoI0Q4wiSFCxWiBpjSmOK6h7z6+2utaB5p20XDZHhxAlmlx4vMuWtjh
` + `XckgRFxc+ZpVMU3cAHUpVEoO49e/+qKEpPzp8Xg4cToKw2+AfTk3cmyyXQfGwXMQ
` + `ZUHNZ3w9ILMWihGCM2aGUsLcGDRennvNmnmin/SENsOQ8Ku0/a3teEzwV9cmmdYz
` + `5iYs1YtgPvKFobY6+T2RXXh+A5kprwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
` + `MB0GA1UdDgQWBBSyUrsQVnKmA8z6/2Ech0rCvqpNmTAOBgNVHQ8BAf8EBAMCAYYw
` + `DQYJKoZIhvcNAQEMBQADggIBAFlj3IFmgiFz5lvTzFTRizhVofhTJsGr14Yfkuc7
` + `UrXPuXOwJomd4uot2d/VIeGJpfnuS84qGdmQyGewGTJ9inatHsGZgHl9NHNWRwKZ
` + `lTKTbBiq7aqgtUSFa06v202wpzU+1kadxJJePrbABxiXVfOmIW/a1a4hPNcT3syH
` + `FIEg1+CGsp71UNjBuwg3JTKWna0sLSKcxLOSOvX1fzxK5djzVpEsvQMB4PSAzXca
` + `vENgg2ErTwgTA+4s6rRtiBF9pAusN1QVuBahYP3ftrY6f3ycS4K65GnqscyfvKt5
` + `YgjtEKO3ZeeX8NpubMbzC+0Z6tVKfPFk/9TXuJtwvVeqow0YMrLLyRiYvK7EzJ97
` + `rrkxoKnHYQSZ+rH2tZ5SE392/rfk1PJL0cdHnkpDkUDO+8cKsFjjYKAQSNC52sKX
` + `74AVh6wMwxYwVZZJf2/2XxkjMWWhKNejsZhUkTISSmiLs+qPe3L67IM7GyKm9/m6
` + `R3r8x6NGjhTsKH64iYJg7AeKeax4b2e4hBb6GXFftyOs7unpEOIVkJJgM6gh3mwn
` + `R7v4gwFbLKADKt1vHuerSZMiTuNTGhSfCeDM53XI/mjZl2HeuCKP1mCDLlaO+gZR
` + `Q/G+E0sBKgEX4xTkAc3kgkuQGfExdGtnN2U2ehF80lBHB8+2y2E+xWWXih/ZyIcW
` + `wOx+
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGBDCCA+ygAwIBAgIQM4C8g5iFRucSWdC8EdqHeDANBgkqhkiG9w0BAQwFADCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwIBcNMjEwNTIxMjIyODI2WhgPMjEyMTA1MjEyMzI4MjZaMIGa
` + `MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j
` + `LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt
` + `YXpvbiBSRFMgZXUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANeTsD/u
` + `6saPiY4Sg0GlJlMXMBltnrcGAEkwq34OKQ0bCXqcoNJ2rcAMmuFC5x9Ho1Y3YzB7
` + `NO2GpIh6bZaO76GzSv4cnimcv9n/sQSYXsGbPD+bAtnN/RvNW1avt4C0q0/ghgF1
` + `VFS8JihIrgPYIArAmDtGNEdl5PUrdi9y6QGggbRfidMDdxlRdZBe1C18ZdgERSEv
` + `UgSTPRlVczONG5qcQkUGCH83MMqL5MKQiby/Br5ZyPq6rxQMwRnQ7tROuElzyYzL
` + `7d6kke+PNzG1mYy4cbYdjebwANCtZ2qYRSUHAQsOgybRcSoarv2xqcjO9cEsDiRU
` + `l97ToadGYa4VVERuTaNZxQwrld4mvzpyKuirqZltOqg0eoy8VUsaRPL3dc5aChR0
` + `dSrBgRYmSAClcR2/2ZCWpXemikwgt031Dsc0A/+TmVurrsqszwbr0e5xqMow9LzO
` + `MI/JtLd0VFtoOkL/7GG2tN8a+7gnLFxpv+AQ0DH5n4k/BY/IyS+H1erqSJhOTQ11
` + `vDOFTM5YplB9hWV9fp5PRs54ILlHTlZLpWGs3I2BrJwzRtg/rOlvsosqcge9ryai
` + `AKm2j+JBg5wJ19R8oxRy8cfrNTftZePpISaLTyV2B16w/GsSjqixjTQe9LRN2DHk
` + `cC+HPqYyzW2a3pUVyTGHhW6a7YsPBs9yzt6hAgMBAAGjQjBAMA8GA1UdEwEB/wQF
` + `MAMBAf8wHQYDVR0OBBYEFIqA8QkOs2cSirOpCuKuOh9VDfJfMA4GA1UdDwEB/wQE
` + `AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOUI90mEIsa+vNJku0iUwdBMnHiO4gm7E
` + `5JloP7JG0xUr7d0hypDorMM3zVDAL+aZRHsq8n934Cywj7qEp1304UF6538ByGdz
` + `tkfacJsUSYfdlNJE9KbA4T+U+7SNhj9jvePpVjdQbhgzxITE9f8CxY/eM40yluJJ
` + `PhbaWvOiRagzo74wttlcDerzLT6Y/JrVpWhnB7IY8HvzK+BwAdaCsBUPC3HF+kth
` + `CIqLq7J3YArTToejWZAp5OOI6DLPM1MEudyoejL02w0jq0CChmZ5i55ElEMnapRX
` + `7GQTARHmjgAOqa95FjbHEZzRPqZ72AtZAWKFcYFNk+grXSeWiDgPFOsq6mDg8DDB
` + `0kfbYwKLFFCC9YFmYzR2YrWw2NxAScccUc2chOWAoSNHiqBbHR8ofrlJSWrtmKqd
` + `YRCXzn8wqXnTS3NNHNccqJ6dN+iMr9NGnytw8zwwSchiev53Fpc1mGrJ7BKTWH0t
` + `ZrA6m32wzpMymtKozlOPYoE5mtZEzrzHEXfa44Rns7XIHxVQSXVWyBHLtIsZOrvW
` + `U5F41rQaFEpEeUQ7sQvqUoISfTUVRNDn6GK6YaccEhCji14APLFIvhRQUDyYMIiM
` + `4vll0F/xgVRHTgDVQ8b8sxdhSYlqB4Wc2Ym41YRz+X2yPqk3typEZBpc4P5Tt1/N
` + `89cEIGdbjsA=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQYjbPSg4+RNRD3zNxO1fuKDANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTkyMVoYDzIwNjEwNTI0MjE1OTIxWjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA179eQHxcV0YL
` + `XMkqEmhSBazHhnRVd8yICbMq82PitE3BZcnv1Z5Zs/oOgNmMkOKae4tCXO/41JCX
` + `wAgbs/eWWi+nnCfpQ/FqbLPg0h3dqzAgeszQyNl9IzTzX4Nd7JFRBVJXPIIKzlRf
` + `+GmFsAhi3rYgDgO27pz3ciahVSN+CuACIRYnA0K0s9lhYdddmrW/SYeWyoB7jPa2
` + `LmWpAs7bDOgS4LlP2H3eFepBPgNufRytSQUVA8f58lsE5w25vNiUSnrdlvDrIU5n
` + `Qwzc7NIZCx4qJpRbSKWrUtbyJriWfAkGU7i0IoainHLn0eHp9bWkwb9D+C/tMk1X
` + `ERZw2PDGkwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSFmR7s
` + `dAblusFN+xhf1ae0KUqhWTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAHsXOpjPMyH9lDhPM61zYdja1ebcMVgfUvsDvt+w0xKMKPhBzYDMs/cFOi1N
` + `Q8LV79VNNfI2NuvFmGygcvTIR+4h0pqqZ+wjWl3Kk5jVxCrbHg3RBX02QLumKd/i
` + `kwGcEtTUvTssn3SM8bgM0/1BDXgImZPC567ciLvWDo0s/Fe9dJJC3E0G7d/4s09n
` + `OMdextcxFuWBZrBm/KK3QF0ByA8MG3//VXaGO9OIeeOJCpWn1G1PjT1UklYhkg61
` + `EbsTiZVA2DLd1BGzfU4o4M5mo68l0msse/ndR1nEY6IywwpgIFue7+rEleDh6b9d
` + `PYkG1rHVw2I0XDG4o17aOn5E94I=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQC6W4HFghUkkgyQw14a6JljANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIyMDUyMzE4MTYzMloYDzIwNjIwNTIzMTkxNjMyWjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiM/t4FV2R9Nx
` + `UQG203UY83jInTa/6TMq0SPyg617FqYZxvz2kkx09x3dmxepUg9ttGMlPgjsRZM5
` + `LCFEi1FWk+hxHzt7vAdhHES5tdjwds3aIkgNEillmRDVrUsbrDwufLaa+MMDO2E1
` + `wQ/JYFXw16WBCCi2g1EtyQ2Xp+tZDX5IWOTnvhZpW8vVDptZ2AcJ5rMhfOYO3OsK
` + `5EF0GGA5ldzuezP+BkrBYGJ4wVKGxeaq9+5AT8iVZrypjwRkD7Y5CurywK3+aBwm
` + `s9Q5Nd8t45JCOUzYp92rFKsCriD86n/JnEvgDfdP6Hvtm0/DkwXK40Wz2q0Zrd0k
` + `mjP054NRPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRR7yqd
` + `SfKcX2Q8GzhcVucReIpewTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAEszBRDwXcZyNm07VcFwI1Im94oKwKccuKYeJEsizTBsVon8VpEiMwDs+yGu
` + `3p8kBhvkLwWybkD/vv6McH7T5b9jDX2DoOudqYnnaYeypsPH/00Vh3LvKagqzQza
` + `orWLx+0tLo8xW4BtU+Wrn3JId8LvAhxyYXTn9bm+EwPcStp8xGLwu53OPD1RXYuy
` + `uu+3ps/2piP7GVfou7H6PRaqbFHNfiGg6Y+WA0HGHiJzn8uLmrRJ5YRdIOOG9/xi
` + `qTmAZloUNM7VNuurcMM2hWF494tQpsQ6ysg2qPjbBqzlGoOt3GfBTOZmqmwmqtam
` + `K7juWM/mdMQAJ3SMlE5wI8nVdx4=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIICrjCCAjSgAwIBAgIRAL9SdzVPcpq7GOpvdGoM80IwCgYIKoZIzj0EAwMwgZYx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h
` + `em9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl
` + `YXR0bGUwIBcNMjEwNTIwMTY1ODA3WhgPMjEyMTA1MjAxNzU4MDdaMIGWMQswCQYD
` + `VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG
` + `A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS
` + `RFMgZXUtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl
` + `MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEJWDgXebvwjR+Ce+hxKOLbnsfN5W5dOlP
` + `Zn8kwWnD+SLkU81Eac/BDJsXGrMk6jFD1vg16PEkoSevsuYWlC8xR6FmT6F6pmeh
` + `fsMGOyJpfK4fyoEPhKeQoT23lFIc5Orjo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
` + `A1UdDgQWBBSVNAN1CHAz0eZ77qz2adeqjm31TzAOBgNVHQ8BAf8EBAMCAYYwCgYI
` + `KoZIzj0EAwMDaAAwZQIxAMlQeHbcjor49jqmcJ9gRLWdEWpXG8thIf6zfYQ/OEAg
` + `d7GDh4fR/OUk0VfjsBUN/gIwZB0bGdXvK38s6AAE/9IT051cz/wMe9GIrX1MnL1T
` + `1F5OqnXJdiwfZRRTHsRQ/L00
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGBDCCA+ygAwIBAgIQalr16vDfX4Rsr+gfQ4iVFDANBgkqhkiG9w0BAQwFADCB
` + `mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB
` + `bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV
` + `BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjEyNTIzWhgPMjEyMjA2MDYyMjI1MjNaMIGa
` + `MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j
` + `LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt
` + `YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANbHbFg7
` + `2VhZor1YNtez0VlNFaobS3PwOMcEn45BE3y7HONnElIIWXGQa0811M8V2FnyqnE8
` + `Z5aO1EuvijvWf/3D8DPZkdmAkIfh5hlZYY6Aatr65kEOckwIAm7ZZzrwFogYuaFC
` + `z/q0CW+8gxNK+98H/zeFx+IxiVoPPPX6UlrLvn+R6XYNERyHMLNgoZbbS5gGHk43
` + `KhENVv3AWCCcCc85O4rVd+DGb2vMVt6IzXdTQt6Kih28+RGph+WDwYmf+3txTYr8
` + `xMcCBt1+whyCPlMbC+Yn/ivtCO4LRf0MPZDRQrqTTrFf0h/V0BGEUmMGwuKgmzf5
` + `Kl9ILdWv6S956ioZin2WgAxhcn7+z//sN++zkqLreSf90Vgv+A7xPRqIpTdJ/nWG
` + `JaAOUofBfsDsk4X4SUFE7xJa1FZAiu2lqB/E+y7jnWOvFRalzxVJ2Y+D/ZfUfrnK
` + `4pfKtyD1C6ni1celrZrAwLrJ3PoXPSg4aJKh8+CHex477SRsGj8KP19FG8r0P5AG
` + `8lS1V+enFCNvT5KqEBpDZ/Y5SQAhAYFUX+zH4/n4ql0l/emS+x23kSRrF+yMkB9q
` + `lhC/fMk6Pi3tICBjrDQ8XAxv56hfud9w6+/ljYB2uQ1iUYtlE3JdIiuE+3ws26O8
` + `i7PLMD9zQmo+sVi12pLHfBHQ6RRHtdVRXbXRAgMBAAGjQjBAMA8GA1UdEwEB/wQF
` + `MAMBAf8wHQYDVR0OBBYEFBFot08ipEL9ZUXCG4lagmF53C0/MA4GA1UdDwEB/wQE
` + `AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAi2mcZi6cpaeqJ10xzMY0F3L2eOKYnlEQ
` + `h6QyhmNKCUF05q5u+cok5KtznzqMwy7TFOZtbVHl8uUX+xvgq/MQCxqFAnuStBXm
` + `gr2dg1h509ZwvTdk7TDxGdftvPCfnPNJBFbMSq4CZtNcOFBg9Rj8c3Yj+Qvwd56V
` + `zWs65BUkDNJrXmxdvhJZjUkMa9vi/oFN+M84xXeZTaC5YDYNZZeW9706QqDbAVES
` + `5ulvKLavB8waLI/lhRBK5/k0YykCMl0A8Togt8D1QsQ0eWWbIM8/HYJMPVFhJ8Wj
` + `vT1p/YVeDA3Bo1iKDOttgC5vILf5Rw1ZEeDxjf/r8A7VS13D3OLjBmc31zxRTs3n
` + `XvHKP9MieQHn9GE44tEYPjK3/yC6BDFzCBlvccYHmqGb+jvDEXEBXKzimdC9mcDl
` + `f4BBQWGJBH5jkbU9p6iti19L/zHhz7qU6UJWbxY40w92L9jS9Utljh4A0LCTjlnR
` + `NQUgjnGC6K+jkw8hj0LTC5Ip87oqoT9w7Av5EJ3VJ4hcnmNMXJJ1DkWYdnytcGpO
` + `DMVITQzzDZRwhbitCVPHagTN2wdi9TEuYE33J0VmFeTc6FSI50wP2aOAZ0Q1/8Aj
` + `bxeM5jS25eaHc2CQAuhrc/7GLnxOcPwdWQb2XWT8eHudhMnoRikVv/KSK3mf6om4
` + `1YfpdH2jp30=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID/jCCAuagAwIBAgIQTDc+UgTRtYO7ZGTQ8UWKDDANBgkqhkiG9w0BAQsFADCB
` + `lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB
` + `bWF6b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM
` + `B1NlYXR0bGUwIBcNMjEwNTIxMjI0NjI0WhgPMjA2MTA1MjEyMzQ2MjRaMIGXMQsw
` + `CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET
` + `MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv
` + `biBSRFMgZXUtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh
` + `dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM1oGtthQ1YiVIC2
` + `i4u4swMAGxAjc/BZp0yq0eP5ZQFaxnxs7zFAPabEWsrjeDzrRhdVO0h7zskrertP
` + `gblGhfD20JfjvCHdP1RUhy/nzG+T+hn6Takan/GIgs8grlBMRHMgBYHW7tklhjaH
` + `3F7LujhceAHhhgp6IOrpb6YTaTTaJbF3GTmkqxSJ3l1LtEoWz8Al/nL/Ftzxrtez
` + `Vs6ebpvd7sw37sxmXBWX2OlvUrPCTmladw9OrllGXtCFw4YyLe3zozBlZ3cHzQ0q
` + `lINhpRcajTMfZrsiGCkQtoJT+AqVJPS2sHjqsEH8yiySW9Jbq4zyMbM1yqQ2vnnx
` + `MJgoYMcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUaQG88UnV
` + `JPTI+Pcti1P+q3H7pGYwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB
` + `AQBAkgr75V0sEJimC6QRiTVWEuj2Khy7unjSfudbM6zumhXEU2/sUaVLiYy6cA/x
` + `3v0laDle6T07x9g64j5YastE/4jbzrGgIINFlY0JnaYmR3KZEjgi1s1fkRRf3llL
` + `PJm9u4Q1mbwAMQK/ZjLuuRcL3uRIHJek18nRqT5h43GB26qXyvJqeYYpYfIjL9+/
` + `YiZAbSRRZG+Li23cmPWrbA1CJY121SB+WybCbysbOXzhD3Sl2KSZRwSw4p2HrFtV
` + `1Prk0dOBtZxCG9luf87ultuDZpfS0w6oNBAMXocgswk24ylcADkkFxBWW+7BETn1
` + `EpK+t1Lm37mU4sxtuha00XAi
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIEADCCAuigAwIBAgIQcY44/8NUvBwr6LlHfRy7KjANBgkqhkiG9w0BAQsFADCB
` + `mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu
` + `Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB
` + `bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH
` + `DAdTZWF0dGxlMCAXDTIxMDUxOTE4MjcxOFoYDzIwNjEwNTE5MTkyNzE4WjCBmDEL
` + `MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x
` + `EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6
` + `b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT
` + `ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0UaBeC+Usalu
` + `EtXnV7+PnH+gi7/71tI/jkKVGKuhD2JDVvqLVoqbMHRh3+wGMvqKCjbHPcC2XMWv
` + `566fpAj4UZ9CLB5fVzss+QVNTl+FH2XhEzigopp+872ajsNzcZxrMkifxGb4i0U+
` + `t0Zi+UrbL5tsfP2JonKR1crOrbS6/DlzHBjIiJazGOQcMsJjNuTOItLbMohLpraA
` + `/nApa3kOvI7Ufool1/34MG0+wL3UUA4YkZ6oBJVxjZvvs6tI7Lzz/SnhK2widGdc
` + `snbLqBpHNIZQSorVoiwcFaRBGYX/uzYkiw44Yfa4cK2V/B5zgu1Fbr0gbI2am4eh
` + `yVYyg4jPawIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS9gM1m
` + `IIjyh9O5H/7Vj0R/akI7UzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
` + `ggEBAF0Sm9HC2AUyedBVnwgkVXMibnYChOzz7T+0Y+fOLXYAEXex2s8oqGeZdGYX
` + `JHkjBn7JXu7LM+TpTbPbFFDoc1sgMguD/ls+8XsqAl1CssW+amryIL+jfcfbgQ+P
` + `ICwEUD9hGdjBgJ5WcuS+qqxHsEIlFNci3HxcxfBa9VsWs5TjI7Vsl4meL5lf7ZyL
` + `wDV7dHRuU+cImqG1MIvPRIlvPnT7EghrCYi2VCPhP2pM/UvShuwVnkz4MJ29ebIk
` + `WR9kpblFxFdE92D5UUvMCjC2kmtgzNiErvTcwIvOO9YCbBHzRB1fFiWrXUHhJWq9
` + `IkaxR5icb/IpAV0A1lYZEWMVsfQ=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIGATCCA+mgAwIBAgIRAMa0TPL+QgbWfUPpYXQkf8wwDQYJKoZIhvcNAQEMBQAw
` + `gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ
` + `bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo
` + `QW1hem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE
` + `BwwHU2VhdHRsZTAgFw0yMTA1MjQyMTAzMjBaGA8yMTIxMDUyNDIyMDMyMFowgZgx
` + `CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu
` + `MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h
` + `em9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH
` + `U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANhS9LJVJyWp
` + `6Rudy9t47y6kzvgnFYDrvJVtgEK0vFn5ifdlHE7xqMz4LZqWBFTnS+3oidwVRqo7
` + `tqsuuElsouStO8m315/YUzKZEPmkw8h5ufWt/lg3NTCoUZNkB4p4skr7TspyMUwE
` + `VdlKQuWTCOLtofwmWT+BnFF3To6xTh3XPlT3ssancw27Gob8kJegD7E0TSMVsecP
` + `B8je65+3b8CGwcD3QB3kCTGLy87tXuS2+07pncHvjMRMBdDQQQqhXWsRSeUNg0IP
` + `xdHTWcuwMldYPWK5zus9M4dCNBDlmZjKdcZZVUOKeBBAm7Uo7CbJCk8r/Fvfr6mw
` + `nXXDtuWhqn/WhJiI/y0QU27M+Hy5CQMxBwFsfAjJkByBpdXmyYxUgTmMpLf43p7H
` + `oWfH1xN0cT0OQEVmAQjMakauow4AQLNkilV+X6uAAu3STQVFRSrpvMen9Xx3EPC3
` + `G9flHueTa71bU65Xe8ZmEmFhGeFYHY0GrNPAFhq9RThPRY0IPyCZe0Th8uGejkek
` + `jQjm0FHPOqs5jc8CD8eJs4jSEFt9lasFLVDcAhx0FkacLKQjGHvKAnnbRwhN/dF3
` + `xt4oL8Z4JGPCLau056gKnYaEyviN7PgO+IFIVOVIdKEBu2ASGE8/+QJB5bcHefNj
` + `04hEkDW0UYJbSfPpVbGAR0gFI/QpycKnAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wHQYDVR0OBBYEFFMXvvjoaGGUcul8GA3FT05DLbZcMA4GA1UdDwEB/wQEAwIB
` + `hjANBgkqhkiG9w0BAQwFAAOCAgEAQLwFhd2JKn4K/6salLyIA4mP58qbA/9BTB/r
` + `D9l0bEwDlVPSdY7R3gZCe6v7SWLfA9RjE5tdWDrQMi5IU6W2OVrVsZS/yGJfwnwe
` + `a/9iUAYprA5QYKDg37h12XhVsDKlYCekHdC+qa5WwB1SL3YUprDLPWeaIQdg+Uh2
` + `+LxvpZGoxoEbca0fc7flwq9ke/3sXt/3V4wJDyY6AL2YNdjFzC+FtYjHHx8rYxHs
` + `aesP7yunuN17KcfOZBBnSFRrx96k+Xm95VReTEEpwiBqAECqEpMbd+R0mFAayMb1
` + `cE77GaK5yeC2f67NLYGpkpIoPbO9p9rzoXLE5GpSizMjimnz6QCbXPFAFBDfSzim
` + `u6azp40kEUO6kWd7rBhqRwLc43D3TtNWQYxMve5mTRG4Od+eMKwYZmQz89BQCeqm
` + `aZiJP9y9uwJw4p/A5V3lYHTDQqzmbOyhGUk6OdpdE8HXs/1ep1xTT20QDYOx3Ekt
` + `r4mmNYfH/8v9nHNRlYJOqFhmoh1i85IUl5IHhg6OT5ZTTwsGTSxvgQQXrmmHVrgZ
` + `rZIqyBKllCgVeB9sMEsntn4bGLig7CS/N1y2mYdW/745yCLZv2gj0NXhPqgEIdVV
` + `f9DhFD4ohE1C63XP0kOQee+LYg/MY5vH8swpCSWxQgX5icv5jVDz8YTdCKgUc5u8
` + `rM2p0kk=
` + `-----END CERTIFICATE-----
`
  ];
});

// ../../../../node_modules/aws-ssl-profiles/lib/profiles/ca/proxies.js
var require_proxies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.proxies = undefined;
  exports.proxies = [
    `-----BEGIN CERTIFICATE-----
` + `MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
` + `ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
` + `b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
` + `MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
` + `b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
` + `ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
` + `9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
` + `IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
` + `VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
` + `93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
` + `jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
` + `AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
` + `A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
` + `U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
` + `N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
` + `o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
` + `5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
` + `rqXRfboQnoZsG4q5WTP468SQvvG5
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF
` + `ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
` + `b24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL
` + `MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
` + `b3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK
` + `gXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ
` + `W0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg
` + `1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K
` + `8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r
` + `2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me
` + `z/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR
` + `8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj
` + `mUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz
` + `7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6
` + `+XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI
` + `0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
` + `Af8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm
` + `UjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2
` + `LIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY
` + `+gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS
` + `k5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl
` + `7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm
` + `btmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl
` + `urR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+
` + `fUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63
` + `n749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE
` + `76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H
` + `9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT
` + `4PsJYGw=
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5
` + `MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
` + `Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
` + `A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
` + `Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl
` + `ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j
` + `QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr
` + `ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr
` + `BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM
` + `YyRIHN8wfdVoOw==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5
` + `MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
` + `Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
` + `A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
` + `Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi
` + `9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk
` + `M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB
` + `/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB
` + `MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw
` + `CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW
` + `1KyLa2tJElMzrdfkviT8tQp21KW8EA==
` + `-----END CERTIFICATE-----
`,
    `-----BEGIN CERTIFICATE-----
` + `MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx
` + `EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
` + `HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs
` + `ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5
` + `MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD
` + `VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy
` + `ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy
` + `dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI
` + `hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p
` + `OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2
` + `8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K
` + `Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe
` + `hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk
` + `6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw
` + `DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q
` + `AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI
` + `bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB
` + `ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z
` + `qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd
` + `iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn
` + `0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN
` + `sSi6
` + `-----END CERTIFICATE-----
`
  ];
});

// ../../../../node_modules/aws-ssl-profiles/lib/index.js
var require_lib10 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaults_js_1 = require_defaults();
  var proxies_js_1 = require_proxies();
  var proxyBundle = {
    ca: proxies_js_1.proxies
  };
  var profiles = {
    ca: [...defaults_js_1.defaults, ...proxies_js_1.proxies]
  };
  module.exports = profiles;
  module.exports.proxyBundle = proxyBundle;
  module.exports.default = profiles;
});

// ../../../../node_modules/mysql2/lib/constants/ssl_profiles.js
var require_ssl_profiles = __commonJS((exports) => {
  var awsCaBundle = require_lib10();
  exports["Amazon RDS"] = {
    ca: awsCaBundle.ca
  };
});

// ../../../../node_modules/mysql2/lib/connection_config.js
var require_connection_config = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  var ClientConstants = require_client();
  var Charsets = require_charsets();
  var { version } = require_package();
  var SSLProfiles = null;
  var validOptions = {
    authPlugins: 1,
    authSwitchHandler: 1,
    bigNumberStrings: 1,
    charset: 1,
    charsetNumber: 1,
    compress: 1,
    connectAttributes: 1,
    connectTimeout: 1,
    database: 1,
    dateStrings: 1,
    debug: 1,
    decimalNumbers: 1,
    enableKeepAlive: 1,
    flags: 1,
    host: 1,
    insecureAuth: 1,
    infileStreamFactory: 1,
    isServer: 1,
    keepAliveInitialDelay: 1,
    localAddress: 1,
    maxPreparedStatements: 1,
    multipleStatements: 1,
    namedPlaceholders: 1,
    nestTables: 1,
    password: 1,
    password1: 1,
    password2: 1,
    password3: 1,
    passwordSha1: 1,
    pool: 1,
    port: 1,
    queryFormat: 1,
    rowsAsArray: 1,
    socketPath: 1,
    ssl: 1,
    stream: 1,
    stringifyObjects: 1,
    supportBigNumbers: 1,
    timezone: 1,
    trace: 1,
    typeCast: 1,
    uri: 1,
    user: 1,
    disableEval: 1,
    connectionLimit: 1,
    maxIdle: 1,
    idleTimeout: 1,
    Promise: 1,
    queueLimit: 1,
    waitForConnections: 1,
    jsonStrings: 1
  };

  class ConnectionConfig {
    constructor(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      } else if (options && options.uri) {
        const uriOptions = ConnectionConfig.parseUrl(options.uri);
        for (const key in uriOptions) {
          if (!Object.prototype.hasOwnProperty.call(uriOptions, key))
            continue;
          if (options[key])
            continue;
          options[key] = uriOptions[key];
        }
      }
      for (const key in options) {
        if (!Object.prototype.hasOwnProperty.call(options, key))
          continue;
        if (validOptions[key] !== 1) {
          console.error(`Ignoring invalid configuration option passed to Connection: ${key}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`);
        }
      }
      this.isServer = options.isServer;
      this.stream = options.stream;
      this.host = options.host || "localhost";
      this.port = (typeof options.port === "string" ? parseInt(options.port, 10) : options.port) || 3306;
      this.localAddress = options.localAddress;
      this.socketPath = options.socketPath;
      this.user = options.user || undefined;
      this.password = options.password || options.password1 || undefined;
      this.password2 = options.password2 || undefined;
      this.password3 = options.password3 || undefined;
      this.passwordSha1 = options.passwordSha1 || undefined;
      this.database = options.database;
      this.connectTimeout = isNaN(options.connectTimeout) ? 10 * 1000 : options.connectTimeout;
      this.insecureAuth = options.insecureAuth || false;
      this.infileStreamFactory = options.infileStreamFactory || undefined;
      this.supportBigNumbers = options.supportBigNumbers || false;
      this.bigNumberStrings = options.bigNumberStrings || false;
      this.decimalNumbers = options.decimalNumbers || false;
      this.dateStrings = options.dateStrings || false;
      this.debug = options.debug;
      this.trace = options.trace !== false;
      this.stringifyObjects = options.stringifyObjects || false;
      this.enableKeepAlive = options.enableKeepAlive !== false;
      this.keepAliveInitialDelay = options.keepAliveInitialDelay;
      if (options.timezone && !/^(?:local|Z|[ +-]\d\d:\d\d)$/.test(options.timezone)) {
        console.error(`Ignoring invalid timezone passed to Connection: ${options.timezone}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`);
        this.timezone = "Z";
      } else {
        this.timezone = options.timezone || "local";
      }
      this.queryFormat = options.queryFormat;
      this.pool = options.pool || undefined;
      this.ssl = typeof options.ssl === "string" ? ConnectionConfig.getSSLProfile(options.ssl) : options.ssl || false;
      this.multipleStatements = options.multipleStatements || false;
      this.rowsAsArray = options.rowsAsArray || false;
      this.namedPlaceholders = options.namedPlaceholders || false;
      this.nestTables = options.nestTables === undefined ? undefined : options.nestTables;
      this.typeCast = options.typeCast === undefined ? true : options.typeCast;
      this.disableEval = Boolean(options.disableEval);
      if (this.timezone[0] === " ") {
        this.timezone = `+${this.timezone.slice(1)}`;
      }
      if (this.ssl) {
        if (typeof this.ssl !== "object") {
          throw new TypeError(`SSL profile must be an object, instead it's a ${typeof this.ssl}`);
        }
        this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
      }
      this.maxPacketSize = 0;
      this.charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;
      this.compress = options.compress || false;
      this.authPlugins = options.authPlugins;
      this.authSwitchHandler = options.authSwitchHandler;
      this.clientFlags = ConnectionConfig.mergeFlags(ConnectionConfig.getDefaultFlags(options), options.flags || "");
      const defaultConnectAttributes = {
        _client_name: "Node-MySQL-2",
        _client_version: version
      };
      this.connectAttributes = {
        ...defaultConnectAttributes,
        ...options.connectAttributes || {}
      };
      this.maxPreparedStatements = options.maxPreparedStatements || 16000;
      this.jsonStrings = options.jsonStrings || false;
    }
    static mergeFlags(default_flags, user_flags) {
      let flags = 0, i;
      if (!Array.isArray(user_flags)) {
        user_flags = String(user_flags || "").toUpperCase().split(/\s*,+\s*/);
      }
      for (i in default_flags) {
        if (user_flags.indexOf(`-${default_flags[i]}`) >= 0) {
          continue;
        }
        flags |= ClientConstants[default_flags[i]] || 0;
      }
      for (i in user_flags) {
        if (user_flags[i][0] === "-") {
          continue;
        }
        if (default_flags.indexOf(user_flags[i]) >= 0) {
          continue;
        }
        flags |= ClientConstants[user_flags[i]] || 0;
      }
      return flags;
    }
    static getDefaultFlags(options) {
      const defaultFlags = [
        "LONG_PASSWORD",
        "FOUND_ROWS",
        "LONG_FLAG",
        "CONNECT_WITH_DB",
        "ODBC",
        "LOCAL_FILES",
        "IGNORE_SPACE",
        "PROTOCOL_41",
        "IGNORE_SIGPIPE",
        "TRANSACTIONS",
        "RESERVED",
        "SECURE_CONNECTION",
        "MULTI_RESULTS",
        "TRANSACTIONS",
        "SESSION_TRACK",
        "CONNECT_ATTRS"
      ];
      if (options && options.multipleStatements) {
        defaultFlags.push("MULTI_STATEMENTS");
      }
      defaultFlags.push("PLUGIN_AUTH");
      defaultFlags.push("PLUGIN_AUTH_LENENC_CLIENT_DATA");
      return defaultFlags;
    }
    static getCharsetNumber(charset) {
      const num = Charsets[charset.toUpperCase()];
      if (num === undefined) {
        throw new TypeError(`Unknown charset '${charset}'`);
      }
      return num;
    }
    static getSSLProfile(name) {
      if (!SSLProfiles) {
        SSLProfiles = require_ssl_profiles();
      }
      const ssl = SSLProfiles[name];
      if (ssl === undefined) {
        throw new TypeError(`Unknown SSL profile '${name}'`);
      }
      return ssl;
    }
    static parseUrl(url) {
      const parsedUrl = new URL2(url);
      const options = {
        host: decodeURIComponent(parsedUrl.hostname),
        port: parseInt(parsedUrl.port, 10),
        database: decodeURIComponent(parsedUrl.pathname.slice(1)),
        user: decodeURIComponent(parsedUrl.username),
        password: decodeURIComponent(parsedUrl.password)
      };
      parsedUrl.searchParams.forEach((value, key) => {
        try {
          options[key] = JSON.parse(value);
        } catch (err2) {
          options[key] = value;
        }
      });
      return options;
    }
  }
  module.exports = ConnectionConfig;
});

// ../../../../node_modules/lru.min/lib/index.js
var require_lib11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLRU = undefined;
  var createLRU = (options) => {
    let { max } = options;
    if (!(Number.isInteger(max) && max > 0))
      throw new TypeError("`max` must be a positive integer");
    let size = 0;
    let head = 0;
    let tail = 0;
    let free = [];
    const { onEviction } = options;
    const keyMap = new Map;
    const keyList = new Array(max).fill(undefined);
    const valList = new Array(max).fill(undefined);
    const next = new Array(max).fill(0);
    const prev = new Array(max).fill(0);
    const setTail = (index, type) => {
      if (index === tail)
        return;
      const nextIndex = next[index];
      const prevIndex = prev[index];
      if (index === head)
        head = nextIndex;
      else if (type === "get" || prevIndex !== 0)
        next[prevIndex] = nextIndex;
      if (nextIndex !== 0)
        prev[nextIndex] = prevIndex;
      next[tail] = index;
      prev[index] = tail;
      next[index] = 0;
      tail = index;
    };
    const _evict = () => {
      const evictHead = head;
      const key = keyList[evictHead];
      onEviction === null || onEviction === undefined || onEviction(key, valList[evictHead]);
      keyMap.delete(key);
      keyList[evictHead] = undefined;
      valList[evictHead] = undefined;
      head = next[evictHead];
      if (head !== 0)
        prev[head] = 0;
      size--;
      if (size === 0)
        head = tail = 0;
      free.push(evictHead);
      return evictHead;
    };
    return {
      set(key, value) {
        if (key === undefined)
          return;
        let index = keyMap.get(key);
        if (index === undefined) {
          index = size === max ? _evict() : free.length > 0 ? free.pop() : size;
          keyMap.set(key, index);
          keyList[index] = key;
          size++;
        } else
          onEviction === null || onEviction === undefined || onEviction(key, valList[index]);
        valList[index] = value;
        if (size === 1)
          head = tail = index;
        else
          setTail(index, "set");
      },
      get(key) {
        const index = keyMap.get(key);
        if (index === undefined)
          return;
        if (index !== tail)
          setTail(index, "get");
        return valList[index];
      },
      peek: (key) => {
        const index = keyMap.get(key);
        return index !== undefined ? valList[index] : undefined;
      },
      has: (key) => keyMap.has(key),
      *keys() {
        let current = tail;
        for (let i = 0;i < size; i++) {
          yield keyList[current];
          current = prev[current];
        }
      },
      *values() {
        let current = tail;
        for (let i = 0;i < size; i++) {
          yield valList[current];
          current = prev[current];
        }
      },
      *entries() {
        let current = tail;
        for (let i = 0;i < size; i++) {
          yield [keyList[current], valList[current]];
          current = prev[current];
        }
      },
      forEach: (callback) => {
        let current = tail;
        for (let i = 0;i < size; i++) {
          const key = keyList[current];
          const value = valList[current];
          callback(value, key);
          current = prev[current];
        }
      },
      delete(key) {
        const index = keyMap.get(key);
        if (index === undefined)
          return false;
        onEviction === null || onEviction === undefined || onEviction(key, valList[index]);
        keyMap.delete(key);
        free.push(index);
        keyList[index] = undefined;
        valList[index] = undefined;
        const prevIndex = prev[index];
        const nextIndex = next[index];
        if (prevIndex !== 0)
          next[prevIndex] = nextIndex;
        if (nextIndex !== 0)
          prev[nextIndex] = prevIndex;
        if (index === head)
          head = nextIndex;
        if (index === tail)
          tail = prevIndex;
        size--;
        return true;
      },
      evict: (number) => {
        let toPrune = Math.min(number, size);
        while (toPrune > 0) {
          _evict();
          toPrune--;
        }
      },
      clear() {
        if (typeof onEviction === "function") {
          const iterator = keyMap.values();
          for (let result = iterator.next();!result.done; result = iterator.next())
            onEviction(keyList[result.value], valList[result.value]);
        }
        keyMap.clear();
        keyList.fill(undefined);
        valList.fill(undefined);
        free = [];
        size = 0;
        head = tail = 0;
      },
      resize: (newMax) => {
        if (!(Number.isInteger(newMax) && newMax > 0))
          throw new TypeError("`max` must be a positive integer");
        if (newMax === max)
          return;
        if (newMax < max) {
          let current = tail;
          const preserve = Math.min(size, newMax);
          const remove = size - preserve;
          const newKeyList = new Array(newMax);
          const newValList = new Array(newMax);
          const newNext = new Array(newMax);
          const newPrev = new Array(newMax);
          for (let i = 1;i <= remove; i++)
            onEviction === null || onEviction === undefined || onEviction(keyList[i], valList[i]);
          for (let i = preserve - 1;i >= 0; i--) {
            newKeyList[i] = keyList[current];
            newValList[i] = valList[current];
            newNext[i] = i + 1;
            newPrev[i] = i - 1;
            keyMap.set(newKeyList[i], i);
            current = prev[current];
          }
          head = 0;
          tail = preserve - 1;
          size = preserve;
          keyList.length = newMax;
          valList.length = newMax;
          next.length = newMax;
          prev.length = newMax;
          for (let i = 0;i < preserve; i++) {
            keyList[i] = newKeyList[i];
            valList[i] = newValList[i];
            next[i] = newNext[i];
            prev[i] = newPrev[i];
          }
          free = [];
          for (let i = preserve;i < newMax; i++)
            free.push(i);
        } else {
          const fill = newMax - max;
          keyList.push(...new Array(fill).fill(undefined));
          valList.push(...new Array(fill).fill(undefined));
          next.push(...new Array(fill).fill(0));
          prev.push(...new Array(fill).fill(0));
        }
        max = newMax;
      },
      get max() {
        return max;
      },
      get size() {
        return size;
      },
      get available() {
        return max - size;
      }
    };
  };
  exports.createLRU = createLRU;
});

// ../../../../node_modules/mysql2/lib/parsers/parser_cache.js
var require_parser_cache = __commonJS((exports, module) => {
  var { createLRU } = require_lib11();
  var parserCache = createLRU({
    max: 15000
  });
  function keyFromFields(type, fields, options, config) {
    const res = [
      type,
      typeof options.nestTables,
      options.nestTables,
      Boolean(options.rowsAsArray),
      Boolean(options.supportBigNumbers || config.supportBigNumbers),
      Boolean(options.bigNumberStrings || config.bigNumberStrings),
      typeof options.typeCast,
      options.timezone || config.timezone,
      Boolean(options.decimalNumbers),
      options.dateStrings
    ];
    for (let i = 0;i < fields.length; ++i) {
      const field = fields[i];
      res.push([
        field.name,
        field.columnType,
        field.length,
        field.schema,
        field.table,
        field.flags,
        field.characterSet
      ]);
    }
    return JSON.stringify(res, null, 0);
  }
  function getParser(type, fields, options, config, compiler) {
    const key = keyFromFields(type, fields, options, config);
    let parser = parserCache.get(key);
    if (parser) {
      return parser;
    }
    parser = compiler(fields, options, config);
    parserCache.set(key, parser);
    return parser;
  }
  function setMaxCache(max) {
    parserCache.resize(max);
  }
  function clearCache() {
    parserCache.clear();
  }
  module.exports = {
    getParser,
    setMaxCache,
    clearCache,
    _keyFromFields: keyFromFields
  };
});

// ../../../../node_modules/denque/index.js
var require_denque = __commonJS((exports, module) => {
  function Denque(array, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array)) {
      this._fromArray(array);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return;
    var item = this._list[head];
    this._list[head] = undefined;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = undefined;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index;k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index;k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0;k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index;k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index);k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0;k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i;k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0;k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0;k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    var length = array.length;
    var capacity = this._nextPowerOf2(length);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length;
    for (var i = 0;i < length; i++)
      this._list[i] = array[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
    var src2 = this._list;
    var capacity = src2.length;
    var length = this.length;
    size = size | length;
    if (size == length && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head;i < capacity; i++)
        dest[k++] = src2[i];
      for (i = 0;i < this._tail; i++)
        dest[k++] = src2[i];
    } else {
      for (i = this._head;i < this._tail; i++)
        dest[k++] = src2[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log22 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log22 + 1;
    return Math.max(nextPow2, 4);
  };
  module.exports = Denque;
});

// ../../../../node_modules/mysql2/lib/constants/errors.js
var require_errors = __commonJS((exports) => {
  exports.EE_CANTCREATEFILE = 1;
  exports.EE_READ = 2;
  exports.EE_WRITE = 3;
  exports.EE_BADCLOSE = 4;
  exports.EE_OUTOFMEMORY = 5;
  exports.EE_DELETE = 6;
  exports.EE_LINK = 7;
  exports.EE_EOFERR = 9;
  exports.EE_CANTLOCK = 10;
  exports.EE_CANTUNLOCK = 11;
  exports.EE_DIR = 12;
  exports.EE_STAT = 13;
  exports.EE_CANT_CHSIZE = 14;
  exports.EE_CANT_OPEN_STREAM = 15;
  exports.EE_GETWD = 16;
  exports.EE_SETWD = 17;
  exports.EE_LINK_WARNING = 18;
  exports.EE_OPEN_WARNING = 19;
  exports.EE_DISK_FULL = 20;
  exports.EE_CANT_MKDIR = 21;
  exports.EE_UNKNOWN_CHARSET = 22;
  exports.EE_OUT_OF_FILERESOURCES = 23;
  exports.EE_CANT_READLINK = 24;
  exports.EE_CANT_SYMLINK = 25;
  exports.EE_REALPATH = 26;
  exports.EE_SYNC = 27;
  exports.EE_UNKNOWN_COLLATION = 28;
  exports.EE_FILENOTFOUND = 29;
  exports.EE_FILE_NOT_CLOSED = 30;
  exports.EE_CHANGE_OWNERSHIP = 31;
  exports.EE_CHANGE_PERMISSIONS = 32;
  exports.EE_CANT_SEEK = 33;
  exports.EE_CAPACITY_EXCEEDED = 34;
  exports.EE_DISK_FULL_WITH_RETRY_MSG = 35;
  exports.EE_FAILED_TO_CREATE_TIMER = 36;
  exports.EE_FAILED_TO_DELETE_TIMER = 37;
  exports.EE_FAILED_TO_CREATE_TIMER_QUEUE = 38;
  exports.EE_FAILED_TO_START_TIMER_NOTIFY_THREAD = 39;
  exports.EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT = 40;
  exports.EE_EXITING_TIMER_NOTIFY_THREAD = 41;
  exports.EE_WIN_LIBRARY_LOAD_FAILED = 42;
  exports.EE_WIN_RUN_TIME_ERROR_CHECK = 43;
  exports.EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE = 44;
  exports.EE_FAILED_TO_KILL_ALL_THREADS = 45;
  exports.EE_FAILED_TO_CREATE_IO_COMPLETION_PORT = 46;
  exports.EE_FAILED_TO_OPEN_DEFAULTS_FILE = 47;
  exports.EE_FAILED_TO_HANDLE_DEFAULTS_FILE = 48;
  exports.EE_WRONG_DIRECTIVE_IN_CONFIG_FILE = 49;
  exports.EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION = 50;
  exports.EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE = 51;
  exports.EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE = 52;
  exports.EE_CONFIG_FILE_PERMISSION_ERROR = 53;
  exports.EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE = 54;
  exports.EE_USING_DISABLED_OPTION = 55;
  exports.EE_USING_DISABLED_SHORT_OPTION = 56;
  exports.EE_USING_PASSWORD_ON_CLI_IS_INSECURE = 57;
  exports.EE_UNKNOWN_SUFFIX_FOR_VARIABLE = 58;
  exports.EE_SSL_ERROR_FROM_FILE = 59;
  exports.EE_SSL_ERROR = 60;
  exports.EE_NET_SEND_ERROR_IN_BOOTSTRAP = 61;
  exports.EE_PACKETS_OUT_OF_ORDER = 62;
  exports.EE_UNKNOWN_PROTOCOL_OPTION = 63;
  exports.EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY = 64;
  exports.EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT = 65;
  exports.EE_DEBUG_INFO = 66;
  exports.EE_UNKNOWN_VARIABLE = 67;
  exports.EE_UNKNOWN_OPTION = 68;
  exports.EE_UNKNOWN_SHORT_OPTION = 69;
  exports.EE_OPTION_WITHOUT_ARGUMENT = 70;
  exports.EE_OPTION_REQUIRES_ARGUMENT = 71;
  exports.EE_SHORT_OPTION_REQUIRES_ARGUMENT = 72;
  exports.EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE = 73;
  exports.EE_OPTION_WITH_EMPTY_VALUE = 74;
  exports.EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION = 75;
  exports.EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION = 76;
  exports.EE_FAILED_TO_SET_OPTION_VALUE = 77;
  exports.EE_INCORRECT_INT_VALUE_FOR_OPTION = 78;
  exports.EE_INCORRECT_UINT_VALUE_FOR_OPTION = 79;
  exports.EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION = 80;
  exports.EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION = 81;
  exports.EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION = 82;
  exports.EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION = 83;
  exports.EE_INVALID_DECIMAL_VALUE_FOR_OPTION = 84;
  exports.EE_COLLATION_PARSER_ERROR = 85;
  exports.EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR = 86;
  exports.EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR = 87;
  exports.EE_SHIFT_CHAR_OUT_OF_RANGE = 88;
  exports.EE_RESET_CHAR_OUT_OF_RANGE = 89;
  exports.EE_UNKNOWN_LDML_TAG = 90;
  exports.EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR = 91;
  exports.EE_FAILED_PROCESSING_DIRECTIVE = 92;
  exports.EE_PTHREAD_KILL_FAILED = 93;
  exports.HA_ERR_KEY_NOT_FOUND = 120;
  exports.HA_ERR_FOUND_DUPP_KEY = 121;
  exports.HA_ERR_INTERNAL_ERROR = 122;
  exports.HA_ERR_RECORD_CHANGED = 123;
  exports.HA_ERR_WRONG_INDEX = 124;
  exports.HA_ERR_ROLLED_BACK = 125;
  exports.HA_ERR_CRASHED = 126;
  exports.HA_ERR_WRONG_IN_RECORD = 127;
  exports.HA_ERR_OUT_OF_MEM = 128;
  exports.HA_ERR_NOT_A_TABLE = 130;
  exports.HA_ERR_WRONG_COMMAND = 131;
  exports.HA_ERR_OLD_FILE = 132;
  exports.HA_ERR_NO_ACTIVE_RECORD = 133;
  exports.HA_ERR_RECORD_DELETED = 134;
  exports.HA_ERR_RECORD_FILE_FULL = 135;
  exports.HA_ERR_INDEX_FILE_FULL = 136;
  exports.HA_ERR_END_OF_FILE = 137;
  exports.HA_ERR_UNSUPPORTED = 138;
  exports.HA_ERR_TOO_BIG_ROW = 139;
  exports.HA_WRONG_CREATE_OPTION = 140;
  exports.HA_ERR_FOUND_DUPP_UNIQUE = 141;
  exports.HA_ERR_UNKNOWN_CHARSET = 142;
  exports.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
  exports.HA_ERR_CRASHED_ON_REPAIR = 144;
  exports.HA_ERR_CRASHED_ON_USAGE = 145;
  exports.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
  exports.HA_ERR_LOCK_TABLE_FULL = 147;
  exports.HA_ERR_READ_ONLY_TRANSACTION = 148;
  exports.HA_ERR_LOCK_DEADLOCK = 149;
  exports.HA_ERR_CANNOT_ADD_FOREIGN = 150;
  exports.HA_ERR_NO_REFERENCED_ROW = 151;
  exports.HA_ERR_ROW_IS_REFERENCED = 152;
  exports.HA_ERR_NO_SAVEPOINT = 153;
  exports.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
  exports.HA_ERR_NO_SUCH_TABLE = 155;
  exports.HA_ERR_TABLE_EXIST = 156;
  exports.HA_ERR_NO_CONNECTION = 157;
  exports.HA_ERR_NULL_IN_SPATIAL = 158;
  exports.HA_ERR_TABLE_DEF_CHANGED = 159;
  exports.HA_ERR_NO_PARTITION_FOUND = 160;
  exports.HA_ERR_RBR_LOGGING_FAILED = 161;
  exports.HA_ERR_DROP_INDEX_FK = 162;
  exports.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
  exports.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
  exports.HA_ERR_TABLE_READONLY = 165;
  exports.HA_ERR_AUTOINC_READ_FAILED = 166;
  exports.HA_ERR_AUTOINC_ERANGE = 167;
  exports.HA_ERR_GENERIC = 168;
  exports.HA_ERR_RECORD_IS_THE_SAME = 169;
  exports.HA_ERR_LOGGING_IMPOSSIBLE = 170;
  exports.HA_ERR_CORRUPT_EVENT = 171;
  exports.HA_ERR_NEW_FILE = 172;
  exports.HA_ERR_ROWS_EVENT_APPLY = 173;
  exports.HA_ERR_INITIALIZATION = 174;
  exports.HA_ERR_FILE_TOO_SHORT = 175;
  exports.HA_ERR_WRONG_CRC = 176;
  exports.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
  exports.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
  exports.HA_ERR_INDEX_COL_TOO_LONG = 179;
  exports.HA_ERR_INDEX_CORRUPT = 180;
  exports.HA_ERR_UNDO_REC_TOO_BIG = 181;
  exports.HA_FTS_INVALID_DOCID = 182;
  exports.HA_ERR_TABLE_IN_FK_CHECK = 183;
  exports.HA_ERR_TABLESPACE_EXISTS = 184;
  exports.HA_ERR_TOO_MANY_FIELDS = 185;
  exports.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
  exports.HA_ERR_INNODB_READ_ONLY = 187;
  exports.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
  exports.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
  exports.HA_ERR_INNODB_FORCED_RECOVERY = 190;
  exports.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
  exports.HA_ERR_FK_DEPTH_EXCEEDED = 192;
  exports.HA_MISSING_CREATE_OPTION = 193;
  exports.HA_ERR_SE_OUT_OF_MEMORY = 194;
  exports.HA_ERR_TABLE_CORRUPT = 195;
  exports.HA_ERR_QUERY_INTERRUPTED = 196;
  exports.HA_ERR_TABLESPACE_MISSING = 197;
  exports.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
  exports.HA_ERR_WRONG_FILE_NAME = 199;
  exports.HA_ERR_NOT_ALLOWED_COMMAND = 200;
  exports.HA_ERR_COMPUTE_FAILED = 201;
  exports.HA_ERR_ROW_FORMAT_CHANGED = 202;
  exports.HA_ERR_NO_WAIT_LOCK = 203;
  exports.HA_ERR_DISK_FULL_NOWAIT = 204;
  exports.HA_ERR_NO_SESSION_TEMP = 205;
  exports.HA_ERR_WRONG_TABLE_NAME = 206;
  exports.HA_ERR_TOO_LONG_PATH = 207;
  exports.HA_ERR_SAMPLING_INIT_FAILED = 208;
  exports.HA_ERR_FTS_TOO_MANY_NESTED_EXP = 209;
  exports.ER_HASHCHK = 1000;
  exports.ER_NISAMCHK = 1001;
  exports.ER_NO = 1002;
  exports.ER_YES = 1003;
  exports.ER_CANT_CREATE_FILE = 1004;
  exports.ER_CANT_CREATE_TABLE = 1005;
  exports.ER_CANT_CREATE_DB = 1006;
  exports.ER_DB_CREATE_EXISTS = 1007;
  exports.ER_DB_DROP_EXISTS = 1008;
  exports.ER_DB_DROP_DELETE = 1009;
  exports.ER_DB_DROP_RMDIR = 1010;
  exports.ER_CANT_DELETE_FILE = 1011;
  exports.ER_CANT_FIND_SYSTEM_REC = 1012;
  exports.ER_CANT_GET_STAT = 1013;
  exports.ER_CANT_GET_WD = 1014;
  exports.ER_CANT_LOCK = 1015;
  exports.ER_CANT_OPEN_FILE = 1016;
  exports.ER_FILE_NOT_FOUND = 1017;
  exports.ER_CANT_READ_DIR = 1018;
  exports.ER_CANT_SET_WD = 1019;
  exports.ER_CHECKREAD = 1020;
  exports.ER_DISK_FULL = 1021;
  exports.ER_DUP_KEY = 1022;
  exports.ER_ERROR_ON_CLOSE = 1023;
  exports.ER_ERROR_ON_READ = 1024;
  exports.ER_ERROR_ON_RENAME = 1025;
  exports.ER_ERROR_ON_WRITE = 1026;
  exports.ER_FILE_USED = 1027;
  exports.ER_FILSORT_ABORT = 1028;
  exports.ER_FORM_NOT_FOUND = 1029;
  exports.ER_GET_ERRNO = 1030;
  exports.ER_ILLEGAL_HA = 1031;
  exports.ER_KEY_NOT_FOUND = 1032;
  exports.ER_NOT_FORM_FILE = 1033;
  exports.ER_NOT_KEYFILE = 1034;
  exports.ER_OLD_KEYFILE = 1035;
  exports.ER_OPEN_AS_READONLY = 1036;
  exports.ER_OUTOFMEMORY = 1037;
  exports.ER_OUT_OF_SORTMEMORY = 1038;
  exports.ER_UNEXPECTED_EOF = 1039;
  exports.ER_CON_COUNT_ERROR = 1040;
  exports.ER_OUT_OF_RESOURCES = 1041;
  exports.ER_BAD_HOST_ERROR = 1042;
  exports.ER_HANDSHAKE_ERROR = 1043;
  exports.ER_DBACCESS_DENIED_ERROR = 1044;
  exports.ER_ACCESS_DENIED_ERROR = 1045;
  exports.ER_NO_DB_ERROR = 1046;
  exports.ER_UNKNOWN_COM_ERROR = 1047;
  exports.ER_BAD_NULL_ERROR = 1048;
  exports.ER_BAD_DB_ERROR = 1049;
  exports.ER_TABLE_EXISTS_ERROR = 1050;
  exports.ER_BAD_TABLE_ERROR = 1051;
  exports.ER_NON_UNIQ_ERROR = 1052;
  exports.ER_SERVER_SHUTDOWN = 1053;
  exports.ER_BAD_FIELD_ERROR = 1054;
  exports.ER_WRONG_FIELD_WITH_GROUP = 1055;
  exports.ER_WRONG_GROUP_FIELD = 1056;
  exports.ER_WRONG_SUM_SELECT = 1057;
  exports.ER_WRONG_VALUE_COUNT = 1058;
  exports.ER_TOO_LONG_IDENT = 1059;
  exports.ER_DUP_FIELDNAME = 1060;
  exports.ER_DUP_KEYNAME = 1061;
  exports.ER_DUP_ENTRY = 1062;
  exports.ER_WRONG_FIELD_SPEC = 1063;
  exports.ER_PARSE_ERROR = 1064;
  exports.ER_EMPTY_QUERY = 1065;
  exports.ER_NONUNIQ_TABLE = 1066;
  exports.ER_INVALID_DEFAULT = 1067;
  exports.ER_MULTIPLE_PRI_KEY = 1068;
  exports.ER_TOO_MANY_KEYS = 1069;
  exports.ER_TOO_MANY_KEY_PARTS = 1070;
  exports.ER_TOO_LONG_KEY = 1071;
  exports.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
  exports.ER_BLOB_USED_AS_KEY = 1073;
  exports.ER_TOO_BIG_FIELDLENGTH = 1074;
  exports.ER_WRONG_AUTO_KEY = 1075;
  exports.ER_READY = 1076;
  exports.ER_NORMAL_SHUTDOWN = 1077;
  exports.ER_GOT_SIGNAL = 1078;
  exports.ER_SHUTDOWN_COMPLETE = 1079;
  exports.ER_FORCING_CLOSE = 1080;
  exports.ER_IPSOCK_ERROR = 1081;
  exports.ER_NO_SUCH_INDEX = 1082;
  exports.ER_WRONG_FIELD_TERMINATORS = 1083;
  exports.ER_BLOBS_AND_NO_TERMINATED = 1084;
  exports.ER_TEXTFILE_NOT_READABLE = 1085;
  exports.ER_FILE_EXISTS_ERROR = 1086;
  exports.ER_LOAD_INFO = 1087;
  exports.ER_ALTER_INFO = 1088;
  exports.ER_WRONG_SUB_KEY = 1089;
  exports.ER_CANT_REMOVE_ALL_FIELDS = 1090;
  exports.ER_CANT_DROP_FIELD_OR_KEY = 1091;
  exports.ER_INSERT_INFO = 1092;
  exports.ER_UPDATE_TABLE_USED = 1093;
  exports.ER_NO_SUCH_THREAD = 1094;
  exports.ER_KILL_DENIED_ERROR = 1095;
  exports.ER_NO_TABLES_USED = 1096;
  exports.ER_TOO_BIG_SET = 1097;
  exports.ER_NO_UNIQUE_LOGFILE = 1098;
  exports.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
  exports.ER_TABLE_NOT_LOCKED = 1100;
  exports.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
  exports.ER_WRONG_DB_NAME = 1102;
  exports.ER_WRONG_TABLE_NAME = 1103;
  exports.ER_TOO_BIG_SELECT = 1104;
  exports.ER_UNKNOWN_ERROR = 1105;
  exports.ER_UNKNOWN_PROCEDURE = 1106;
  exports.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
  exports.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
  exports.ER_UNKNOWN_TABLE = 1109;
  exports.ER_FIELD_SPECIFIED_TWICE = 1110;
  exports.ER_INVALID_GROUP_FUNC_USE = 1111;
  exports.ER_UNSUPPORTED_EXTENSION = 1112;
  exports.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
  exports.ER_RECORD_FILE_FULL = 1114;
  exports.ER_UNKNOWN_CHARACTER_SET = 1115;
  exports.ER_TOO_MANY_TABLES = 1116;
  exports.ER_TOO_MANY_FIELDS = 1117;
  exports.ER_TOO_BIG_ROWSIZE = 1118;
  exports.ER_STACK_OVERRUN = 1119;
  exports.ER_WRONG_OUTER_JOIN = 1120;
  exports.ER_NULL_COLUMN_IN_INDEX = 1121;
  exports.ER_CANT_FIND_UDF = 1122;
  exports.ER_CANT_INITIALIZE_UDF = 1123;
  exports.ER_UDF_NO_PATHS = 1124;
  exports.ER_UDF_EXISTS = 1125;
  exports.ER_CANT_OPEN_LIBRARY = 1126;
  exports.ER_CANT_FIND_DL_ENTRY = 1127;
  exports.ER_FUNCTION_NOT_DEFINED = 1128;
  exports.ER_HOST_IS_BLOCKED = 1129;
  exports.ER_HOST_NOT_PRIVILEGED = 1130;
  exports.ER_PASSWORD_ANONYMOUS_USER = 1131;
  exports.ER_PASSWORD_NOT_ALLOWED = 1132;
  exports.ER_PASSWORD_NO_MATCH = 1133;
  exports.ER_UPDATE_INFO = 1134;
  exports.ER_CANT_CREATE_THREAD = 1135;
  exports.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
  exports.ER_CANT_REOPEN_TABLE = 1137;
  exports.ER_INVALID_USE_OF_NULL = 1138;
  exports.ER_REGEXP_ERROR = 1139;
  exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
  exports.ER_NONEXISTING_GRANT = 1141;
  exports.ER_TABLEACCESS_DENIED_ERROR = 1142;
  exports.ER_COLUMNACCESS_DENIED_ERROR = 1143;
  exports.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
  exports.ER_GRANT_WRONG_HOST_OR_USER = 1145;
  exports.ER_NO_SUCH_TABLE = 1146;
  exports.ER_NONEXISTING_TABLE_GRANT = 1147;
  exports.ER_NOT_ALLOWED_COMMAND = 1148;
  exports.ER_SYNTAX_ERROR = 1149;
  exports.ER_UNUSED1 = 1150;
  exports.ER_UNUSED2 = 1151;
  exports.ER_ABORTING_CONNECTION = 1152;
  exports.ER_NET_PACKET_TOO_LARGE = 1153;
  exports.ER_NET_READ_ERROR_FROM_PIPE = 1154;
  exports.ER_NET_FCNTL_ERROR = 1155;
  exports.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
  exports.ER_NET_UNCOMPRESS_ERROR = 1157;
  exports.ER_NET_READ_ERROR = 1158;
  exports.ER_NET_READ_INTERRUPTED = 1159;
  exports.ER_NET_ERROR_ON_WRITE = 1160;
  exports.ER_NET_WRITE_INTERRUPTED = 1161;
  exports.ER_TOO_LONG_STRING = 1162;
  exports.ER_TABLE_CANT_HANDLE_BLOB = 1163;
  exports.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
  exports.ER_UNUSED3 = 1165;
  exports.ER_WRONG_COLUMN_NAME = 1166;
  exports.ER_WRONG_KEY_COLUMN = 1167;
  exports.ER_WRONG_MRG_TABLE = 1168;
  exports.ER_DUP_UNIQUE = 1169;
  exports.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
  exports.ER_PRIMARY_CANT_HAVE_NULL = 1171;
  exports.ER_TOO_MANY_ROWS = 1172;
  exports.ER_REQUIRES_PRIMARY_KEY = 1173;
  exports.ER_NO_RAID_COMPILED = 1174;
  exports.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
  exports.ER_KEY_DOES_NOT_EXITS = 1176;
  exports.ER_CHECK_NO_SUCH_TABLE = 1177;
  exports.ER_CHECK_NOT_IMPLEMENTED = 1178;
  exports.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
  exports.ER_ERROR_DURING_COMMIT = 1180;
  exports.ER_ERROR_DURING_ROLLBACK = 1181;
  exports.ER_ERROR_DURING_FLUSH_LOGS = 1182;
  exports.ER_ERROR_DURING_CHECKPOINT = 1183;
  exports.ER_NEW_ABORTING_CONNECTION = 1184;
  exports.ER_DUMP_NOT_IMPLEMENTED = 1185;
  exports.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
  exports.ER_INDEX_REBUILD = 1187;
  exports.ER_SOURCE = 1188;
  exports.ER_SOURCE_NET_READ = 1189;
  exports.ER_SOURCE_NET_WRITE = 1190;
  exports.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
  exports.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
  exports.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
  exports.ER_CRASHED_ON_USAGE = 1194;
  exports.ER_CRASHED_ON_REPAIR = 1195;
  exports.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
  exports.ER_TRANS_CACHE_FULL = 1197;
  exports.ER_SLAVE_MUST_STOP = 1198;
  exports.ER_REPLICA_NOT_RUNNING = 1199;
  exports.ER_BAD_REPLICA = 1200;
  exports.ER_CONNECTION_METADATA = 1201;
  exports.ER_REPLICA_THREAD = 1202;
  exports.ER_TOO_MANY_USER_CONNECTIONS = 1203;
  exports.ER_SET_CONSTANTS_ONLY = 1204;
  exports.ER_LOCK_WAIT_TIMEOUT = 1205;
  exports.ER_LOCK_TABLE_FULL = 1206;
  exports.ER_READ_ONLY_TRANSACTION = 1207;
  exports.ER_DROP_DB_WITH_READ_LOCK = 1208;
  exports.ER_CREATE_DB_WITH_READ_LOCK = 1209;
  exports.ER_WRONG_ARGUMENTS = 1210;
  exports.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
  exports.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
  exports.ER_LOCK_DEADLOCK = 1213;
  exports.ER_TABLE_CANT_HANDLE_FT = 1214;
  exports.ER_CANNOT_ADD_FOREIGN = 1215;
  exports.ER_NO_REFERENCED_ROW = 1216;
  exports.ER_ROW_IS_REFERENCED = 1217;
  exports.ER_CONNECT_TO_SOURCE = 1218;
  exports.ER_QUERY_ON_MASTER = 1219;
  exports.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
  exports.ER_WRONG_USAGE = 1221;
  exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
  exports.ER_CANT_UPDATE_WITH_READLOCK = 1223;
  exports.ER_MIXING_NOT_ALLOWED = 1224;
  exports.ER_DUP_ARGUMENT = 1225;
  exports.ER_USER_LIMIT_REACHED = 1226;
  exports.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
  exports.ER_LOCAL_VARIABLE = 1228;
  exports.ER_GLOBAL_VARIABLE = 1229;
  exports.ER_NO_DEFAULT = 1230;
  exports.ER_WRONG_VALUE_FOR_VAR = 1231;
  exports.ER_WRONG_TYPE_FOR_VAR = 1232;
  exports.ER_VAR_CANT_BE_READ = 1233;
  exports.ER_CANT_USE_OPTION_HERE = 1234;
  exports.ER_NOT_SUPPORTED_YET = 1235;
  exports.ER_SOURCE_FATAL_ERROR_READING_BINLOG = 1236;
  exports.ER_REPLICA_IGNORED_TABLE = 1237;
  exports.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
  exports.ER_WRONG_FK_DEF = 1239;
  exports.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
  exports.ER_OPERAND_COLUMNS = 1241;
  exports.ER_SUBQUERY_NO_1_ROW = 1242;
  exports.ER_UNKNOWN_STMT_HANDLER = 1243;
  exports.ER_CORRUPT_HELP_DB = 1244;
  exports.ER_CYCLIC_REFERENCE = 1245;
  exports.ER_AUTO_CONVERT = 1246;
  exports.ER_ILLEGAL_REFERENCE = 1247;
  exports.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
  exports.ER_SELECT_REDUCED = 1249;
  exports.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
  exports.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
  exports.ER_SPATIAL_CANT_HAVE_NULL = 1252;
  exports.ER_COLLATION_CHARSET_MISMATCH = 1253;
  exports.ER_SLAVE_WAS_RUNNING = 1254;
  exports.ER_SLAVE_WAS_NOT_RUNNING = 1255;
  exports.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
  exports.ER_ZLIB_Z_MEM_ERROR = 1257;
  exports.ER_ZLIB_Z_BUF_ERROR = 1258;
  exports.ER_ZLIB_Z_DATA_ERROR = 1259;
  exports.ER_CUT_VALUE_GROUP_CONCAT = 1260;
  exports.ER_WARN_TOO_FEW_RECORDS = 1261;
  exports.ER_WARN_TOO_MANY_RECORDS = 1262;
  exports.ER_WARN_NULL_TO_NOTNULL = 1263;
  exports.ER_WARN_DATA_OUT_OF_RANGE = 1264;
  exports.WARN_DATA_TRUNCATED = 1265;
  exports.ER_WARN_USING_OTHER_HANDLER = 1266;
  exports.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
  exports.ER_DROP_USER = 1268;
  exports.ER_REVOKE_GRANTS = 1269;
  exports.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
  exports.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
  exports.ER_VARIABLE_IS_NOT_STRUCT = 1272;
  exports.ER_UNKNOWN_COLLATION = 1273;
  exports.ER_REPLICA_IGNORED_SSL_PARAMS = 1274;
  exports.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
  exports.ER_WARN_FIELD_RESOLVED = 1276;
  exports.ER_BAD_REPLICA_UNTIL_COND = 1277;
  exports.ER_MISSING_SKIP_REPLICA = 1278;
  exports.ER_UNTIL_COND_IGNORED = 1279;
  exports.ER_WRONG_NAME_FOR_INDEX = 1280;
  exports.ER_WRONG_NAME_FOR_CATALOG = 1281;
  exports.ER_WARN_QC_RESIZE = 1282;
  exports.ER_BAD_FT_COLUMN = 1283;
  exports.ER_UNKNOWN_KEY_CACHE = 1284;
  exports.ER_WARN_HOSTNAME_WONT_WORK = 1285;
  exports.ER_UNKNOWN_STORAGE_ENGINE = 1286;
  exports.ER_WARN_DEPRECATED_SYNTAX = 1287;
  exports.ER_NON_UPDATABLE_TABLE = 1288;
  exports.ER_FEATURE_DISABLED = 1289;
  exports.ER_OPTION_PREVENTS_STATEMENT = 1290;
  exports.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
  exports.ER_TRUNCATED_WRONG_VALUE = 1292;
  exports.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
  exports.ER_INVALID_ON_UPDATE = 1294;
  exports.ER_UNSUPPORTED_PS = 1295;
  exports.ER_GET_ERRMSG = 1296;
  exports.ER_GET_TEMPORARY_ERRMSG = 1297;
  exports.ER_UNKNOWN_TIME_ZONE = 1298;
  exports.ER_WARN_INVALID_TIMESTAMP = 1299;
  exports.ER_INVALID_CHARACTER_STRING = 1300;
  exports.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
  exports.ER_CONFLICTING_DECLARATIONS = 1302;
  exports.ER_SP_NO_RECURSIVE_CREATE = 1303;
  exports.ER_SP_ALREADY_EXISTS = 1304;
  exports.ER_SP_DOES_NOT_EXIST = 1305;
  exports.ER_SP_DROP_FAILED = 1306;
  exports.ER_SP_STORE_FAILED = 1307;
  exports.ER_SP_LILABEL_MISMATCH = 1308;
  exports.ER_SP_LABEL_REDEFINE = 1309;
  exports.ER_SP_LABEL_MISMATCH = 1310;
  exports.ER_SP_UNINIT_VAR = 1311;
  exports.ER_SP_BADSELECT = 1312;
  exports.ER_SP_BADRETURN = 1313;
  exports.ER_SP_BADSTATEMENT = 1314;
  exports.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
  exports.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
  exports.ER_QUERY_INTERRUPTED = 1317;
  exports.ER_SP_WRONG_NO_OF_ARGS = 1318;
  exports.ER_SP_COND_MISMATCH = 1319;
  exports.ER_SP_NORETURN = 1320;
  exports.ER_SP_NORETURNEND = 1321;
  exports.ER_SP_BAD_CURSOR_QUERY = 1322;
  exports.ER_SP_BAD_CURSOR_SELECT = 1323;
  exports.ER_SP_CURSOR_MISMATCH = 1324;
  exports.ER_SP_CURSOR_ALREADY_OPEN = 1325;
  exports.ER_SP_CURSOR_NOT_OPEN = 1326;
  exports.ER_SP_UNDECLARED_VAR = 1327;
  exports.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
  exports.ER_SP_FETCH_NO_DATA = 1329;
  exports.ER_SP_DUP_PARAM = 1330;
  exports.ER_SP_DUP_VAR = 1331;
  exports.ER_SP_DUP_COND = 1332;
  exports.ER_SP_DUP_CURS = 1333;
  exports.ER_SP_CANT_ALTER = 1334;
  exports.ER_SP_SUBSELECT_NYI = 1335;
  exports.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
  exports.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
  exports.ER_SP_CURSOR_AFTER_HANDLER = 1338;
  exports.ER_SP_CASE_NOT_FOUND = 1339;
  exports.ER_FPARSER_TOO_BIG_FILE = 1340;
  exports.ER_FPARSER_BAD_HEADER = 1341;
  exports.ER_FPARSER_EOF_IN_COMMENT = 1342;
  exports.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
  exports.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
  exports.ER_VIEW_NO_EXPLAIN = 1345;
  exports.ER_FRM_UNKNOWN_TYPE = 1346;
  exports.ER_WRONG_OBJECT = 1347;
  exports.ER_NONUPDATEABLE_COLUMN = 1348;
  exports.ER_VIEW_SELECT_DERIVED = 1349;
  exports.ER_VIEW_SELECT_CLAUSE = 1350;
  exports.ER_VIEW_SELECT_VARIABLE = 1351;
  exports.ER_VIEW_SELECT_TMPTABLE = 1352;
  exports.ER_VIEW_WRONG_LIST = 1353;
  exports.ER_WARN_VIEW_MERGE = 1354;
  exports.ER_WARN_VIEW_WITHOUT_KEY = 1355;
  exports.ER_VIEW_INVALID = 1356;
  exports.ER_SP_NO_DROP_SP = 1357;
  exports.ER_SP_GOTO_IN_HNDLR = 1358;
  exports.ER_TRG_ALREADY_EXISTS = 1359;
  exports.ER_TRG_DOES_NOT_EXIST = 1360;
  exports.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
  exports.ER_TRG_CANT_CHANGE_ROW = 1362;
  exports.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
  exports.ER_NO_DEFAULT_FOR_FIELD = 1364;
  exports.ER_DIVISION_BY_ZERO = 1365;
  exports.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
  exports.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
  exports.ER_VIEW_NONUPD_CHECK = 1368;
  exports.ER_VIEW_CHECK_FAILED = 1369;
  exports.ER_PROCACCESS_DENIED_ERROR = 1370;
  exports.ER_RELAY_LOG_FAIL = 1371;
  exports.ER_PASSWD_LENGTH = 1372;
  exports.ER_UNKNOWN_TARGET_BINLOG = 1373;
  exports.ER_IO_ERR_LOG_INDEX_READ = 1374;
  exports.ER_BINLOG_PURGE_PROHIBITED = 1375;
  exports.ER_FSEEK_FAIL = 1376;
  exports.ER_BINLOG_PURGE_FATAL_ERR = 1377;
  exports.ER_LOG_IN_USE = 1378;
  exports.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
  exports.ER_RELAY_LOG_INIT = 1380;
  exports.ER_NO_BINARY_LOGGING = 1381;
  exports.ER_RESERVED_SYNTAX = 1382;
  exports.ER_WSAS_FAILED = 1383;
  exports.ER_DIFF_GROUPS_PROC = 1384;
  exports.ER_NO_GROUP_FOR_PROC = 1385;
  exports.ER_ORDER_WITH_PROC = 1386;
  exports.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
  exports.ER_NO_FILE_MAPPING = 1388;
  exports.ER_WRONG_MAGIC = 1389;
  exports.ER_PS_MANY_PARAM = 1390;
  exports.ER_KEY_PART_0 = 1391;
  exports.ER_VIEW_CHECKSUM = 1392;
  exports.ER_VIEW_MULTIUPDATE = 1393;
  exports.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
  exports.ER_VIEW_DELETE_MERGE_VIEW = 1395;
  exports.ER_CANNOT_USER = 1396;
  exports.ER_XAER_NOTA = 1397;
  exports.ER_XAER_INVAL = 1398;
  exports.ER_XAER_RMFAIL = 1399;
  exports.ER_XAER_OUTSIDE = 1400;
  exports.ER_XAER_RMERR = 1401;
  exports.ER_XA_RBROLLBACK = 1402;
  exports.ER_NONEXISTING_PROC_GRANT = 1403;
  exports.ER_PROC_AUTO_GRANT_FAIL = 1404;
  exports.ER_PROC_AUTO_REVOKE_FAIL = 1405;
  exports.ER_DATA_TOO_LONG = 1406;
  exports.ER_SP_BAD_SQLSTATE = 1407;
  exports.ER_STARTUP = 1408;
  exports.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
  exports.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
  exports.ER_WRONG_VALUE_FOR_TYPE = 1411;
  exports.ER_TABLE_DEF_CHANGED = 1412;
  exports.ER_SP_DUP_HANDLER = 1413;
  exports.ER_SP_NOT_VAR_ARG = 1414;
  exports.ER_SP_NO_RETSET = 1415;
  exports.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
  exports.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
  exports.ER_BINLOG_UNSAFE_ROUTINE = 1418;
  exports.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
  exports.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
  exports.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
  exports.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
  exports.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
  exports.ER_SP_NO_RECURSION = 1424;
  exports.ER_TOO_BIG_SCALE = 1425;
  exports.ER_TOO_BIG_PRECISION = 1426;
  exports.ER_M_BIGGER_THAN_D = 1427;
  exports.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
  exports.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
  exports.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
  exports.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
  exports.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
  exports.ER_FOREIGN_DATA_STRING_INVALID = 1433;
  exports.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
  exports.ER_TRG_IN_WRONG_SCHEMA = 1435;
  exports.ER_STACK_OVERRUN_NEED_MORE = 1436;
  exports.ER_TOO_LONG_BODY = 1437;
  exports.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
  exports.ER_TOO_BIG_DISPLAYWIDTH = 1439;
  exports.ER_XAER_DUPID = 1440;
  exports.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
  exports.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
  exports.ER_VIEW_PREVENT_UPDATE = 1443;
  exports.ER_PS_NO_RECURSION = 1444;
  exports.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
  exports.ER_MALFORMED_DEFINER = 1446;
  exports.ER_VIEW_FRM_NO_USER = 1447;
  exports.ER_VIEW_OTHER_USER = 1448;
  exports.ER_NO_SUCH_USER = 1449;
  exports.ER_FORBID_SCHEMA_CHANGE = 1450;
  exports.ER_ROW_IS_REFERENCED_2 = 1451;
  exports.ER_NO_REFERENCED_ROW_2 = 1452;
  exports.ER_SP_BAD_VAR_SHADOW = 1453;
  exports.ER_TRG_NO_DEFINER = 1454;
  exports.ER_OLD_FILE_FORMAT = 1455;
  exports.ER_SP_RECURSION_LIMIT = 1456;
  exports.ER_SP_PROC_TABLE_CORRUPT = 1457;
  exports.ER_SP_WRONG_NAME = 1458;
  exports.ER_TABLE_NEEDS_UPGRADE = 1459;
  exports.ER_SP_NO_AGGREGATE = 1460;
  exports.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
  exports.ER_VIEW_RECURSIVE = 1462;
  exports.ER_NON_GROUPING_FIELD_USED = 1463;
  exports.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
  exports.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
  exports.ER_REMOVED_SPACES = 1466;
  exports.ER_AUTOINC_READ_FAILED = 1467;
  exports.ER_USERNAME = 1468;
  exports.ER_HOSTNAME = 1469;
  exports.ER_WRONG_STRING_LENGTH = 1470;
  exports.ER_NON_INSERTABLE_TABLE = 1471;
  exports.ER_ADMIN_WRONG_MRG_TABLE = 1472;
  exports.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
  exports.ER_NAME_BECOMES_EMPTY = 1474;
  exports.ER_AMBIGUOUS_FIELD_TERM = 1475;
  exports.ER_FOREIGN_SERVER_EXISTS = 1476;
  exports.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
  exports.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
  exports.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
  exports.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
  exports.ER_PARTITION_MAXVALUE_ERROR = 1481;
  exports.ER_PARTITION_SUBPARTITION_ERROR = 1482;
  exports.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
  exports.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
  exports.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
  exports.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
  exports.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
  exports.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
  exports.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
  exports.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
  exports.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
  exports.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
  exports.ER_RANGE_NOT_INCREASING_ERROR = 1493;
  exports.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
  exports.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
  exports.ER_PARTITION_ENTRY_ERROR = 1496;
  exports.ER_MIX_HANDLER_ERROR = 1497;
  exports.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
  exports.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
  exports.ER_SUBPARTITION_ERROR = 1500;
  exports.ER_CANT_CREATE_HANDLER_FILE = 1501;
  exports.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
  exports.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
  exports.ER_NO_PARTS_ERROR = 1504;
  exports.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
  exports.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
  exports.ER_DROP_PARTITION_NON_EXISTENT = 1507;
  exports.ER_DROP_LAST_PARTITION = 1508;
  exports.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
  exports.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
  exports.ER_REORG_NO_PARAM_ERROR = 1511;
  exports.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
  exports.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
  exports.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
  exports.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
  exports.ER_REORG_PARTITION_NOT_EXIST = 1516;
  exports.ER_SAME_NAME_PARTITION = 1517;
  exports.ER_NO_BINLOG_ERROR = 1518;
  exports.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
  exports.ER_REORG_OUTSIDE_RANGE = 1520;
  exports.ER_PARTITION_FUNCTION_FAILURE = 1521;
  exports.ER_PART_STATE_ERROR = 1522;
  exports.ER_LIMITED_PART_RANGE = 1523;
  exports.ER_PLUGIN_IS_NOT_LOADED = 1524;
  exports.ER_WRONG_VALUE = 1525;
  exports.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
  exports.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
  exports.ER_CREATE_FILEGROUP_FAILED = 1528;
  exports.ER_DROP_FILEGROUP_FAILED = 1529;
  exports.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
  exports.ER_WRONG_SIZE_NUMBER = 1531;
  exports.ER_SIZE_OVERFLOW_ERROR = 1532;
  exports.ER_ALTER_FILEGROUP_FAILED = 1533;
  exports.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
  exports.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
  exports.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
  exports.ER_EVENT_ALREADY_EXISTS = 1537;
  exports.ER_EVENT_STORE_FAILED = 1538;
  exports.ER_EVENT_DOES_NOT_EXIST = 1539;
  exports.ER_EVENT_CANT_ALTER = 1540;
  exports.ER_EVENT_DROP_FAILED = 1541;
  exports.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
  exports.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
  exports.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
  exports.ER_EVENT_OPEN_TABLE_FAILED = 1545;
  exports.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
  exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
  exports.ER_CANNOT_LOAD_FROM_TABLE = 1548;
  exports.ER_EVENT_CANNOT_DELETE = 1549;
  exports.ER_EVENT_COMPILE_ERROR = 1550;
  exports.ER_EVENT_SAME_NAME = 1551;
  exports.ER_EVENT_DATA_TOO_LONG = 1552;
  exports.ER_DROP_INDEX_FK = 1553;
  exports.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
  exports.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
  exports.ER_CANT_LOCK_LOG_TABLE = 1556;
  exports.ER_FOREIGN_DUPLICATE_KEY = 1557;
  exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
  exports.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
  exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
  exports.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
  exports.ER_PARTITION_NO_TEMPORARY = 1562;
  exports.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
  exports.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
  exports.ER_DDL_LOG_ERROR = 1565;
  exports.ER_NULL_IN_VALUES_LESS_THAN = 1566;
  exports.ER_WRONG_PARTITION_NAME = 1567;
  exports.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
  exports.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
  exports.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
  exports.ER_EVENT_SET_VAR_ERROR = 1571;
  exports.ER_PARTITION_MERGE_ERROR = 1572;
  exports.ER_CANT_ACTIVATE_LOG = 1573;
  exports.ER_RBR_NOT_AVAILABLE = 1574;
  exports.ER_BASE64_DECODE_ERROR = 1575;
  exports.ER_EVENT_RECURSION_FORBIDDEN = 1576;
  exports.ER_EVENTS_DB_ERROR = 1577;
  exports.ER_ONLY_INTEGERS_ALLOWED = 1578;
  exports.ER_UNSUPORTED_LOG_ENGINE = 1579;
  exports.ER_BAD_LOG_STATEMENT = 1580;
  exports.ER_CANT_RENAME_LOG_TABLE = 1581;
  exports.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
  exports.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
  exports.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
  exports.ER_NATIVE_FCT_NAME_COLLISION = 1585;
  exports.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
  exports.ER_BINLOG_PURGE_EMFILE = 1587;
  exports.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
  exports.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
  exports.ER_SLAVE_INCIDENT = 1590;
  exports.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
  exports.ER_BINLOG_UNSAFE_STATEMENT = 1592;
  exports.ER_BINLOG_FATAL_ERROR = 1593;
  exports.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
  exports.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
  exports.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
  exports.ER_SLAVE_MASTER_COM_FAILURE = 1597;
  exports.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
  exports.ER_VIEW_NO_CREATION_CTX = 1599;
  exports.ER_VIEW_INVALID_CREATION_CTX = 1600;
  exports.ER_SR_INVALID_CREATION_CTX = 1601;
  exports.ER_TRG_CORRUPTED_FILE = 1602;
  exports.ER_TRG_NO_CREATION_CTX = 1603;
  exports.ER_TRG_INVALID_CREATION_CTX = 1604;
  exports.ER_EVENT_INVALID_CREATION_CTX = 1605;
  exports.ER_TRG_CANT_OPEN_TABLE = 1606;
  exports.ER_CANT_CREATE_SROUTINE = 1607;
  exports.ER_NEVER_USED = 1608;
  exports.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
  exports.ER_REPLICA_CORRUPT_EVENT = 1610;
  exports.ER_LOAD_DATA_INVALID_COLUMN = 1611;
  exports.ER_LOG_PURGE_NO_FILE = 1612;
  exports.ER_XA_RBTIMEOUT = 1613;
  exports.ER_XA_RBDEADLOCK = 1614;
  exports.ER_NEED_REPREPARE = 1615;
  exports.ER_DELAYED_NOT_SUPPORTED = 1616;
  exports.WARN_NO_CONNECTION_METADATA = 1617;
  exports.WARN_OPTION_IGNORED = 1618;
  exports.ER_PLUGIN_DELETE_BUILTIN = 1619;
  exports.WARN_PLUGIN_BUSY = 1620;
  exports.ER_VARIABLE_IS_READONLY = 1621;
  exports.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
  exports.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
  exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
  exports.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
  exports.ER_CONFLICT_FN_PARSE_ERROR = 1626;
  exports.ER_EXCEPTIONS_WRITE_ERROR = 1627;
  exports.ER_TOO_LONG_TABLE_COMMENT = 1628;
  exports.ER_TOO_LONG_FIELD_COMMENT = 1629;
  exports.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
  exports.ER_DATABASE_NAME = 1631;
  exports.ER_TABLE_NAME = 1632;
  exports.ER_PARTITION_NAME = 1633;
  exports.ER_SUBPARTITION_NAME = 1634;
  exports.ER_TEMPORARY_NAME = 1635;
  exports.ER_RENAMED_NAME = 1636;
  exports.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
  exports.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
  exports.ER_DEBUG_SYNC_TIMEOUT = 1639;
  exports.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
  exports.ER_DUP_SIGNAL_SET = 1641;
  exports.ER_SIGNAL_WARN = 1642;
  exports.ER_SIGNAL_NOT_FOUND = 1643;
  exports.ER_SIGNAL_EXCEPTION = 1644;
  exports.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
  exports.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
  exports.WARN_COND_ITEM_TRUNCATED = 1647;
  exports.ER_COND_ITEM_TOO_LONG = 1648;
  exports.ER_UNKNOWN_LOCALE = 1649;
  exports.ER_REPLICA_IGNORE_SERVER_IDS = 1650;
  exports.ER_QUERY_CACHE_DISABLED = 1651;
  exports.ER_SAME_NAME_PARTITION_FIELD = 1652;
  exports.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
  exports.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
  exports.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
  exports.ER_MAXVALUE_IN_VALUES_IN = 1656;
  exports.ER_TOO_MANY_VALUES_ERROR = 1657;
  exports.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
  exports.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
  exports.ER_PARTITION_FIELDS_TOO_LONG = 1660;
  exports.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
  exports.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
  exports.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
  exports.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
  exports.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
  exports.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
  exports.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
  exports.ER_BINLOG_UNSAFE_LIMIT = 1668;
  exports.ER_UNUSED4 = 1669;
  exports.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
  exports.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
  exports.ER_BINLOG_UNSAFE_UDF = 1672;
  exports.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
  exports.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
  exports.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
  exports.ER_MESSAGE_AND_STATEMENT = 1676;
  exports.ER_SLAVE_CONVERSION_FAILED = 1677;
  exports.ER_REPLICA_CANT_CREATE_CONVERSION = 1678;
  exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
  exports.ER_PATH_LENGTH = 1680;
  exports.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
  exports.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
  exports.ER_WRONG_PERFSCHEMA_USAGE = 1683;
  exports.ER_WARN_I_S_SKIPPED_TABLE = 1684;
  exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
  exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
  exports.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
  exports.ER_TOO_LONG_INDEX_COMMENT = 1688;
  exports.ER_LOCK_ABORTED = 1689;
  exports.ER_DATA_OUT_OF_RANGE = 1690;
  exports.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
  exports.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
  exports.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
  exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
  exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
  exports.ER_FAILED_READ_FROM_PAR_FILE = 1696;
  exports.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
  exports.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
  exports.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
  exports.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
  exports.ER_TRUNCATE_ILLEGAL_FK = 1701;
  exports.ER_PLUGIN_IS_PERMANENT = 1702;
  exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
  exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
  exports.ER_STMT_CACHE_FULL = 1705;
  exports.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
  exports.ER_TABLE_NEEDS_REBUILD = 1707;
  exports.WARN_OPTION_BELOW_LIMIT = 1708;
  exports.ER_INDEX_COLUMN_TOO_LONG = 1709;
  exports.ER_ERROR_IN_TRIGGER_BODY = 1710;
  exports.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
  exports.ER_INDEX_CORRUPT = 1712;
  exports.ER_UNDO_RECORD_TOO_BIG = 1713;
  exports.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
  exports.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
  exports.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
  exports.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
  exports.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
  exports.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
  exports.ER_PLUGIN_NO_UNINSTALL = 1720;
  exports.ER_PLUGIN_NO_INSTALL = 1721;
  exports.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
  exports.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
  exports.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
  exports.ER_TABLE_IN_FK_CHECK = 1725;
  exports.ER_UNSUPPORTED_ENGINE = 1726;
  exports.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
  exports.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
  exports.ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE = 1729;
  exports.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
  exports.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
  exports.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
  exports.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
  exports.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
  exports.ER_UNKNOWN_PARTITION = 1735;
  exports.ER_TABLES_DIFFERENT_METADATA = 1736;
  exports.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
  exports.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
  exports.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
  exports.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
  exports.ER_NO_SUCH_KEY_VALUE = 1741;
  exports.ER_RPL_INFO_DATA_TOO_LONG = 1742;
  exports.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
  exports.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
  exports.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
  exports.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
  exports.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
  exports.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
  exports.ER_NO_SUCH_PARTITION = 1749;
  exports.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
  exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
  exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
  exports.ER_MTA_FEATURE_IS_NOT_SUPPORTED = 1753;
  exports.ER_MTA_UPDATED_DBS_GREATER_MAX = 1754;
  exports.ER_MTA_CANT_PARALLEL = 1755;
  exports.ER_MTA_INCONSISTENT_DATA = 1756;
  exports.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
  exports.ER_DA_INVALID_CONDITION_NUMBER = 1758;
  exports.ER_INSECURE_PLAIN_TEXT = 1759;
  exports.ER_INSECURE_CHANGE_SOURCE = 1760;
  exports.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
  exports.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
  exports.ER_SQLTHREAD_WITH_SECURE_REPLICA = 1763;
  exports.ER_TABLE_HAS_NO_FT = 1764;
  exports.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
  exports.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
  exports.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
  exports.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
  exports.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
  exports.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
  exports.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
  exports.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
  exports.ER_MALFORMED_GTID_SET_ENCODING = 1773;
  exports.ER_MALFORMED_GTID_SPECIFICATION = 1774;
  exports.ER_GNO_EXHAUSTED = 1775;
  exports.ER_BAD_REPLICA_AUTO_POSITION = 1776;
  exports.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
  exports.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
  exports.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
  exports.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
  exports.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
  exports.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
  exports.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
  exports.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
  exports.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
  exports.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
  exports.ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION = 1787;
  exports.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
  exports.ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS = 1789;
  exports.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
  exports.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
  exports.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
  exports.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
  exports.ER_REPLICA_CONFIGURATION = 1794;
  exports.ER_INNODB_FT_LIMIT = 1795;
  exports.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
  exports.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
  exports.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
  exports.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
  exports.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
  exports.ER_UNKNOWN_ALTER_LOCK = 1801;
  exports.ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS = 1802;
  exports.ER_MTA_RECOVERY_FAILURE = 1803;
  exports.ER_MTA_RESET_WORKERS = 1804;
  exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
  exports.ER_REPLICA_SILENT_RETRY_TRANSACTION = 1806;
  exports.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
  exports.ER_TABLE_SCHEMA_MISMATCH = 1808;
  exports.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
  exports.ER_IO_READ_ERROR = 1810;
  exports.ER_IO_WRITE_ERROR = 1811;
  exports.ER_TABLESPACE_MISSING = 1812;
  exports.ER_TABLESPACE_EXISTS = 1813;
  exports.ER_TABLESPACE_DISCARDED = 1814;
  exports.ER_INTERNAL_ERROR = 1815;
  exports.ER_INNODB_IMPORT_ERROR = 1816;
  exports.ER_INNODB_INDEX_CORRUPT = 1817;
  exports.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
  exports.ER_NOT_VALID_PASSWORD = 1819;
  exports.ER_MUST_CHANGE_PASSWORD = 1820;
  exports.ER_FK_NO_INDEX_CHILD = 1821;
  exports.ER_FK_NO_INDEX_PARENT = 1822;
  exports.ER_FK_FAIL_ADD_SYSTEM = 1823;
  exports.ER_FK_CANNOT_OPEN_PARENT = 1824;
  exports.ER_FK_INCORRECT_OPTION = 1825;
  exports.ER_FK_DUP_NAME = 1826;
  exports.ER_PASSWORD_FORMAT = 1827;
  exports.ER_FK_COLUMN_CANNOT_DROP = 1828;
  exports.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
  exports.ER_FK_COLUMN_NOT_NULL = 1830;
  exports.ER_DUP_INDEX = 1831;
  exports.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
  exports.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
  exports.ER_UNUSED5 = 1834;
  exports.ER_MALFORMED_PACKET = 1835;
  exports.ER_READ_ONLY_MODE = 1836;
  exports.ER_GTID_NEXT_TYPE_UNDEFINED_GTID = 1837;
  exports.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
  exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
  exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
  exports.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
  exports.ER_GTID_PURGED_WAS_CHANGED = 1842;
  exports.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
  exports.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
  exports.ER_UNUSED6 = 1852;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
  exports.ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
  exports.ER_DUP_UNKNOWN_IN_INDEX = 1859;
  exports.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
  exports.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
  exports.ER_ROW_IN_WRONG_PARTITION = 1863;
  exports.ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
  exports.ER_INNODB_NO_FT_USES_PARSER = 1865;
  exports.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
  exports.ER_WARN_PURGE_LOG_IN_USE = 1867;
  exports.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
  exports.ER_AUTO_INCREMENT_CONFLICT = 1869;
  exports.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
  exports.ER_REPLICA_CM_INIT_REPOSITORY = 1871;
  exports.ER_REPLICA_AM_INIT_REPOSITORY = 1872;
  exports.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
  exports.ER_INNODB_READ_ONLY = 1874;
  exports.ER_STOP_REPLICA_SQL_THREAD_TIMEOUT = 1875;
  exports.ER_STOP_REPLICA_IO_THREAD_TIMEOUT = 1876;
  exports.ER_TABLE_CORRUPT = 1877;
  exports.ER_TEMP_FILE_WRITE_FAILURE = 1878;
  exports.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
  exports.ER_OLD_TEMPORALS_UPGRADED = 1880;
  exports.ER_INNODB_FORCED_RECOVERY = 1881;
  exports.ER_AES_INVALID_IV = 1882;
  exports.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
  exports.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID = 1884;
  exports.ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE = 1885;
  exports.ER_MISSING_KEY = 1886;
  exports.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
  exports.ER_FILE_CORRUPT = 3000;
  exports.ER_ERROR_ON_SOURCE = 3001;
  exports.ER_INCONSISTENT_ERROR = 3002;
  exports.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
  exports.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
  exports.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
  exports.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
  exports.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
  exports.ER_FK_DEPTH_EXCEEDED = 3008;
  exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
  exports.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
  exports.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
  exports.ER_EXPLAIN_NOT_SUPPORTED = 3012;
  exports.ER_INVALID_FIELD_SIZE = 3013;
  exports.ER_MISSING_HA_CREATE_OPTION = 3014;
  exports.ER_ENGINE_OUT_OF_MEMORY = 3015;
  exports.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
  exports.ER_REPLICA_SQL_THREAD_MUST_STOP = 3017;
  exports.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
  exports.ER_INNODB_UNDO_LOG_FULL = 3019;
  exports.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
  exports.ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP = 3021;
  exports.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
  exports.ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS = 3023;
  exports.ER_QUERY_TIMEOUT = 3024;
  exports.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
  exports.ER_DUP_LIST_ENTRY = 3026;
  exports.ER_SQL_MODE_NO_EFFECT = 3027;
  exports.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
  exports.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
  exports.ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
  exports.ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER = 3031;
  exports.ER_SERVER_OFFLINE_MODE = 3032;
  exports.ER_GIS_DIFFERENT_SRIDS = 3033;
  exports.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
  exports.ER_GIS_UNKNOWN_ERROR = 3035;
  exports.ER_GIS_UNKNOWN_EXCEPTION = 3036;
  exports.ER_GIS_INVALID_DATA = 3037;
  exports.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
  exports.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
  exports.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
  exports.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
  exports.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
  exports.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
  exports.ER_STD_BAD_ALLOC_ERROR = 3044;
  exports.ER_STD_DOMAIN_ERROR = 3045;
  exports.ER_STD_LENGTH_ERROR = 3046;
  exports.ER_STD_INVALID_ARGUMENT = 3047;
  exports.ER_STD_OUT_OF_RANGE_ERROR = 3048;
  exports.ER_STD_OVERFLOW_ERROR = 3049;
  exports.ER_STD_RANGE_ERROR = 3050;
  exports.ER_STD_UNDERFLOW_ERROR = 3051;
  exports.ER_STD_LOGIC_ERROR = 3052;
  exports.ER_STD_RUNTIME_ERROR = 3053;
  exports.ER_STD_UNKNOWN_EXCEPTION = 3054;
  exports.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
  exports.ER_CHANGE_SOURCE_PASSWORD_LENGTH = 3056;
  exports.ER_USER_LOCK_WRONG_NAME = 3057;
  exports.ER_USER_LOCK_DEADLOCK = 3058;
  exports.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
  exports.ER_ILLEGAL_USER_VAR = 3061;
  exports.ER_GTID_MODE_OFF = 3062;
  exports.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
  exports.ER_INCORRECT_TYPE = 3064;
  exports.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
  exports.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
  exports.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
  exports.ER_NET_OK_PACKET_TOO_LARGE = 3068;
  exports.ER_INVALID_JSON_DATA = 3069;
  exports.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
  exports.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
  exports.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
  exports.ER_DIMENSION_UNSUPPORTED = 3073;
  exports.ER_REPLICA_CHANNEL_DOES_NOT_EXIST = 3074;
  exports.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
  exports.ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
  exports.ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
  exports.ER_SLAVE_CHANNEL_DELETE = 3078;
  exports.ER_REPLICA_MULTIPLE_CHANNELS_CMD = 3079;
  exports.ER_REPLICA_MAX_CHANNELS_EXCEEDED = 3080;
  exports.ER_REPLICA_CHANNEL_MUST_STOP = 3081;
  exports.ER_REPLICA_CHANNEL_NOT_RUNNING = 3082;
  exports.ER_REPLICA_CHANNEL_WAS_RUNNING = 3083;
  exports.ER_REPLICA_CHANNEL_WAS_NOT_RUNNING = 3084;
  exports.ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
  exports.ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER = 3086;
  exports.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
  exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
  exports.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
  exports.ER_WARN_DEPRECATED_SQLMODE = 3090;
  exports.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
  exports.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
  exports.ER_GROUP_REPLICATION_RUNNING = 3093;
  exports.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
  exports.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
  exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
  exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
  exports.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
  exports.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
  exports.ER_RUN_HOOK_ERROR = 3100;
  exports.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
  exports.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
  exports.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
  exports.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
  exports.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
  exports.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
  exports.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
  exports.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
  exports.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
  exports.ER_FEATURE_NOT_AVAILABLE = 3110;
  exports.ER_CANT_SET_GTID_MODE = 3111;
  exports.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
  exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
  exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
  exports.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
  exports.ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX = 3116;
  exports.ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX = 3117;
  exports.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
  exports.ER_WRONG_TABLESPACE_NAME = 3119;
  exports.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
  exports.ER_WRONG_FILE_NAME = 3121;
  exports.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
  exports.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
  exports.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
  exports.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
  exports.ER_WARN_CONFLICTING_HINT = 3126;
  exports.ER_WARN_UNKNOWN_QB_NAME = 3127;
  exports.ER_UNRESOLVED_HINT_NAME = 3128;
  exports.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
  exports.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
  exports.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
  exports.ER_LOCKING_SERVICE_DEADLOCK = 3132;
  exports.ER_LOCKING_SERVICE_TIMEOUT = 3133;
  exports.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
  exports.ER_SQL_MODE_MERGED = 3135;
  exports.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
  exports.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
  exports.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
  exports.ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
  exports.ER_INVALID_JSON_TEXT = 3140;
  exports.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
  exports.ER_INVALID_JSON_BINARY_DATA = 3142;
  exports.ER_INVALID_JSON_PATH = 3143;
  exports.ER_INVALID_JSON_CHARSET = 3144;
  exports.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
  exports.ER_INVALID_TYPE_FOR_JSON = 3146;
  exports.ER_INVALID_CAST_TO_JSON = 3147;
  exports.ER_INVALID_JSON_PATH_CHARSET = 3148;
  exports.ER_INVALID_JSON_PATH_WILDCARD = 3149;
  exports.ER_JSON_VALUE_TOO_BIG = 3150;
  exports.ER_JSON_KEY_TOO_BIG = 3151;
  exports.ER_JSON_USED_AS_KEY = 3152;
  exports.ER_JSON_VACUOUS_PATH = 3153;
  exports.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
  exports.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
  exports.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
  exports.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
  exports.ER_JSON_DOCUMENT_NULL_KEY = 3158;
  exports.ER_SECURE_TRANSPORT_REQUIRED = 3159;
  exports.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
  exports.ER_DISABLED_STORAGE_ENGINE = 3161;
  exports.ER_USER_DOES_NOT_EXIST = 3162;
  exports.ER_USER_ALREADY_EXISTS = 3163;
  exports.ER_AUDIT_API_ABORT = 3164;
  exports.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
  exports.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
  exports.ER_FEATURE_DISABLED_SEE_DOC = 3167;
  exports.ER_SERVER_ISNT_AVAILABLE = 3168;
  exports.ER_SESSION_WAS_KILLED = 3169;
  exports.ER_CAPACITY_EXCEEDED = 3170;
  exports.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
  exports.ER_TABLE_NEEDS_UPG_PART = 3172;
  exports.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
  exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
  exports.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
  exports.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
  exports.ER_LOCK_REFUSED_BY_ENGINE = 3177;
  exports.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
  exports.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
  exports.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
  exports.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
  exports.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
  exports.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
  exports.ER_INVALID_ENCRYPTION_OPTION = 3184;
  exports.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
  exports.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
  exports.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
  exports.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
  exports.ER_USER_COLUMN_OLD_LENGTH = 3189;
  exports.ER_CANT_RESET_SOURCE = 3190;
  exports.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
  exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
  exports.ER_TABLE_REFERENCED = 3193;
  exports.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
  exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
  exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
  exports.ER_XA_RETRY = 3197;
  exports.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
  exports.ER_BINLOG_UNSAFE_XA = 3199;
  exports.ER_UDF_ERROR = 3200;
  exports.ER_KEYRING_MIGRATION_FAILURE = 3201;
  exports.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
  exports.ER_KEYRING_MIGRATION_STATUS = 3203;
  exports.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
  exports.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
  exports.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
  exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
  exports.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
  exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
  exports.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
  exports.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
  exports.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
  exports.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
  exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
  exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
  exports.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
  exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
  exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
  exports.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
  exports.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
  exports.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
  exports.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
  exports.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
  exports.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
  exports.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
  exports.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
  exports.ER_XA_REPLICATION_FILTERS = 3227;
  exports.ER_CANT_OPEN_ERROR_LOG = 3228;
  exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
  exports.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
  exports.ER_WRITE_SET_EXCEEDS_LIMIT = 3231;
  exports.ER_DEPRECATED_TLS_VERSION_SESSION_57 = 3232;
  exports.ER_WARN_DEPRECATED_TLS_VERSION_57 = 3233;
  exports.ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE = 3234;
  exports.ER_AES_INVALID_KDF_NAME = 3235;
  exports.ER_AES_INVALID_KDF_ITERATIONS = 3236;
  exports.WARN_AES_KEY_SIZE = 3237;
  exports.ER_AES_INVALID_KDF_OPTION_SIZE = 3238;
  exports.ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE = 3500;
  exports.ER_ACL_OPERATION_FAILED = 3501;
  exports.ER_UNSUPPORTED_INDEX_ALGORITHM = 3502;
  exports.ER_NO_SUCH_DB = 3503;
  exports.ER_TOO_BIG_ENUM = 3504;
  exports.ER_TOO_LONG_SET_ENUM_VALUE = 3505;
  exports.ER_INVALID_DD_OBJECT = 3506;
  exports.ER_UPDATING_DD_TABLE = 3507;
  exports.ER_INVALID_DD_OBJECT_ID = 3508;
  exports.ER_INVALID_DD_OBJECT_NAME = 3509;
  exports.ER_TABLESPACE_MISSING_WITH_NAME = 3510;
  exports.ER_TOO_LONG_ROUTINE_COMMENT = 3511;
  exports.ER_SP_LOAD_FAILED = 3512;
  exports.ER_INVALID_BITWISE_OPERANDS_SIZE = 3513;
  exports.ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE = 3514;
  exports.ER_WARN_UNSUPPORTED_HINT = 3515;
  exports.ER_UNEXPECTED_GEOMETRY_TYPE = 3516;
  exports.ER_SRS_PARSE_ERROR = 3517;
  exports.ER_SRS_PROJ_PARAMETER_MISSING = 3518;
  exports.ER_WARN_SRS_NOT_FOUND = 3519;
  exports.ER_SRS_NOT_CARTESIAN = 3520;
  exports.ER_SRS_NOT_CARTESIAN_UNDEFINED = 3521;
  exports.ER_PK_INDEX_CANT_BE_INVISIBLE = 3522;
  exports.ER_UNKNOWN_AUTHID = 3523;
  exports.ER_FAILED_ROLE_GRANT = 3524;
  exports.ER_OPEN_ROLE_TABLES = 3525;
  exports.ER_FAILED_DEFAULT_ROLES = 3526;
  exports.ER_COMPONENTS_NO_SCHEME = 3527;
  exports.ER_COMPONENTS_NO_SCHEME_SERVICE = 3528;
  exports.ER_COMPONENTS_CANT_LOAD = 3529;
  exports.ER_ROLE_NOT_GRANTED = 3530;
  exports.ER_FAILED_REVOKE_ROLE = 3531;
  exports.ER_RENAME_ROLE = 3532;
  exports.ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION = 3533;
  exports.ER_COMPONENTS_CANT_SATISFY_DEPENDENCY = 3534;
  exports.ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION = 3535;
  exports.ER_COMPONENTS_LOAD_CANT_INITIALIZE = 3536;
  exports.ER_COMPONENTS_UNLOAD_NOT_LOADED = 3537;
  exports.ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE = 3538;
  exports.ER_COMPONENTS_CANT_RELEASE_SERVICE = 3539;
  exports.ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE = 3540;
  exports.ER_COMPONENTS_CANT_UNLOAD = 3541;
  exports.ER_WARN_UNLOAD_THE_NOT_PERSISTED = 3542;
  exports.ER_COMPONENT_TABLE_INCORRECT = 3543;
  exports.ER_COMPONENT_MANIPULATE_ROW_FAILED = 3544;
  exports.ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP = 3545;
  exports.ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS = 3546;
  exports.ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES = 3547;
  exports.ER_SRS_NOT_FOUND = 3548;
  exports.ER_VARIABLE_NOT_PERSISTED = 3549;
  exports.ER_IS_QUERY_INVALID_CLAUSE = 3550;
  exports.ER_UNABLE_TO_STORE_STATISTICS = 3551;
  exports.ER_NO_SYSTEM_SCHEMA_ACCESS = 3552;
  exports.ER_NO_SYSTEM_TABLESPACE_ACCESS = 3553;
  exports.ER_NO_SYSTEM_TABLE_ACCESS = 3554;
  exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE = 3555;
  exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE = 3556;
  exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE = 3557;
  exports.ER_INVALID_OPTION_KEY = 3558;
  exports.ER_INVALID_OPTION_VALUE = 3559;
  exports.ER_INVALID_OPTION_KEY_VALUE_PAIR = 3560;
  exports.ER_INVALID_OPTION_START_CHARACTER = 3561;
  exports.ER_INVALID_OPTION_END_CHARACTER = 3562;
  exports.ER_INVALID_OPTION_CHARACTERS = 3563;
  exports.ER_DUPLICATE_OPTION_KEY = 3564;
  exports.ER_WARN_SRS_NOT_FOUND_AXIS_ORDER = 3565;
  exports.ER_NO_ACCESS_TO_NATIVE_FCT = 3566;
  exports.ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE = 3567;
  exports.ER_UNRESOLVED_TABLE_LOCK = 3568;
  exports.ER_DUPLICATE_TABLE_LOCK = 3569;
  exports.ER_BINLOG_UNSAFE_SKIP_LOCKED = 3570;
  exports.ER_BINLOG_UNSAFE_NOWAIT = 3571;
  exports.ER_LOCK_NOWAIT = 3572;
  exports.ER_CTE_RECURSIVE_REQUIRES_UNION = 3573;
  exports.ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST = 3574;
  exports.ER_CTE_RECURSIVE_FORBIDS_AGGREGATION = 3575;
  exports.ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER = 3576;
  exports.ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE = 3577;
  exports.ER_SWITCH_TMP_ENGINE = 3578;
  exports.ER_WINDOW_NO_SUCH_WINDOW = 3579;
  exports.ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH = 3580;
  exports.ER_WINDOW_NO_CHILD_PARTITIONING = 3581;
  exports.ER_WINDOW_NO_INHERIT_FRAME = 3582;
  exports.ER_WINDOW_NO_REDEFINE_ORDER_BY = 3583;
  exports.ER_WINDOW_FRAME_START_ILLEGAL = 3584;
  exports.ER_WINDOW_FRAME_END_ILLEGAL = 3585;
  exports.ER_WINDOW_FRAME_ILLEGAL = 3586;
  exports.ER_WINDOW_RANGE_FRAME_ORDER_TYPE = 3587;
  exports.ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE = 3588;
  exports.ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE = 3589;
  exports.ER_WINDOW_RANGE_BOUND_NOT_CONSTANT = 3590;
  exports.ER_WINDOW_DUPLICATE_NAME = 3591;
  exports.ER_WINDOW_ILLEGAL_ORDER_BY = 3592;
  exports.ER_WINDOW_INVALID_WINDOW_FUNC_USE = 3593;
  exports.ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE = 3594;
  exports.ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC = 3595;
  exports.ER_WINDOW_ROWS_INTERVAL_USE = 3596;
  exports.ER_WINDOW_NO_GROUP_ORDER = 3597;
  exports.ER_WINDOW_EXPLAIN_JSON = 3598;
  exports.ER_WINDOW_FUNCTION_IGNORES_FRAME = 3599;
  exports.ER_WL9236_NOW = 3600;
  exports.ER_INVALID_NO_OF_ARGS = 3601;
  exports.ER_FIELD_IN_GROUPING_NOT_GROUP_BY = 3602;
  exports.ER_TOO_LONG_TABLESPACE_COMMENT = 3603;
  exports.ER_ENGINE_CANT_DROP_TABLE = 3604;
  exports.ER_ENGINE_CANT_DROP_MISSING_TABLE = 3605;
  exports.ER_TABLESPACE_DUP_FILENAME = 3606;
  exports.ER_DB_DROP_RMDIR2 = 3607;
  exports.ER_IMP_NO_FILES_MATCHED = 3608;
  exports.ER_IMP_SCHEMA_DOES_NOT_EXIST = 3609;
  exports.ER_IMP_TABLE_ALREADY_EXISTS = 3610;
  exports.ER_IMP_INCOMPATIBLE_MYSQLD_VERSION = 3611;
  exports.ER_IMP_INCOMPATIBLE_DD_VERSION = 3612;
  exports.ER_IMP_INCOMPATIBLE_SDI_VERSION = 3613;
  exports.ER_WARN_INVALID_HINT = 3614;
  exports.ER_VAR_DOES_NOT_EXIST = 3615;
  exports.ER_LONGITUDE_OUT_OF_RANGE = 3616;
  exports.ER_LATITUDE_OUT_OF_RANGE = 3617;
  exports.ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS = 3618;
  exports.ER_ILLEGAL_PRIVILEGE_LEVEL = 3619;
  exports.ER_NO_SYSTEM_VIEW_ACCESS = 3620;
  exports.ER_COMPONENT_FILTER_FLABBERGASTED = 3621;
  exports.ER_PART_EXPR_TOO_LONG = 3622;
  exports.ER_UDF_DROP_DYNAMICALLY_REGISTERED = 3623;
  exports.ER_UNABLE_TO_STORE_COLUMN_STATISTICS = 3624;
  exports.ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS = 3625;
  exports.ER_UNABLE_TO_DROP_COLUMN_STATISTICS = 3626;
  exports.ER_UNABLE_TO_BUILD_HISTOGRAM = 3627;
  exports.ER_MANDATORY_ROLE = 3628;
  exports.ER_MISSING_TABLESPACE_FILE = 3629;
  exports.ER_PERSIST_ONLY_ACCESS_DENIED_ERROR = 3630;
  exports.ER_CMD_NEED_SUPER = 3631;
  exports.ER_PATH_IN_DATADIR = 3632;
  exports.ER_CLONE_DDL_IN_PROGRESS = 3633;
  exports.ER_CLONE_TOO_MANY_CONCURRENT_CLONES = 3634;
  exports.ER_APPLIER_LOG_EVENT_VALIDATION_ERROR = 3635;
  exports.ER_CTE_MAX_RECURSION_DEPTH = 3636;
  exports.ER_NOT_HINT_UPDATABLE_VARIABLE = 3637;
  exports.ER_CREDENTIALS_CONTRADICT_TO_HISTORY = 3638;
  exports.ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID = 3639;
  exports.ER_CLIENT_DOES_NOT_SUPPORT = 3640;
  exports.ER_I_S_SKIPPED_TABLESPACE = 3641;
  exports.ER_TABLESPACE_ENGINE_MISMATCH = 3642;
  exports.ER_WRONG_SRID_FOR_COLUMN = 3643;
  exports.ER_CANNOT_ALTER_SRID_DUE_TO_INDEX = 3644;
  exports.ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED = 3645;
  exports.ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED = 3646;
  exports.ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES = 3647;
  exports.ER_COULD_NOT_APPLY_JSON_DIFF = 3648;
  exports.ER_CORRUPTED_JSON_DIFF = 3649;
  exports.ER_RESOURCE_GROUP_EXISTS = 3650;
  exports.ER_RESOURCE_GROUP_NOT_EXISTS = 3651;
  exports.ER_INVALID_VCPU_ID = 3652;
  exports.ER_INVALID_VCPU_RANGE = 3653;
  exports.ER_INVALID_THREAD_PRIORITY = 3654;
  exports.ER_DISALLOWED_OPERATION = 3655;
  exports.ER_RESOURCE_GROUP_BUSY = 3656;
  exports.ER_RESOURCE_GROUP_DISABLED = 3657;
  exports.ER_FEATURE_UNSUPPORTED = 3658;
  exports.ER_ATTRIBUTE_IGNORED = 3659;
  exports.ER_INVALID_THREAD_ID = 3660;
  exports.ER_RESOURCE_GROUP_BIND_FAILED = 3661;
  exports.ER_INVALID_USE_OF_FORCE_OPTION = 3662;
  exports.ER_GROUP_REPLICATION_COMMAND_FAILURE = 3663;
  exports.ER_SDI_OPERATION_FAILED = 3664;
  exports.ER_MISSING_JSON_TABLE_VALUE = 3665;
  exports.ER_WRONG_JSON_TABLE_VALUE = 3666;
  exports.ER_TF_MUST_HAVE_ALIAS = 3667;
  exports.ER_TF_FORBIDDEN_JOIN_TYPE = 3668;
  exports.ER_JT_VALUE_OUT_OF_RANGE = 3669;
  exports.ER_JT_MAX_NESTED_PATH = 3670;
  exports.ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD = 3671;
  exports.ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL = 3672;
  exports.ER_BAD_NULL_ERROR_NOT_IGNORED = 3673;
  exports.WARN_USELESS_SPATIAL_INDEX = 3674;
  exports.ER_DISK_FULL_NOWAIT = 3675;
  exports.ER_PARSE_ERROR_IN_DIGEST_FN = 3676;
  exports.ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN = 3677;
  exports.ER_SCHEMA_DIR_EXISTS = 3678;
  exports.ER_SCHEMA_DIR_MISSING = 3679;
  exports.ER_SCHEMA_DIR_CREATE_FAILED = 3680;
  exports.ER_SCHEMA_DIR_UNKNOWN = 3681;
  exports.ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326 = 3682;
  exports.ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER = 3683;
  exports.ER_REGEXP_BUFFER_OVERFLOW = 3684;
  exports.ER_REGEXP_ILLEGAL_ARGUMENT = 3685;
  exports.ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR = 3686;
  exports.ER_REGEXP_INTERNAL_ERROR = 3687;
  exports.ER_REGEXP_RULE_SYNTAX = 3688;
  exports.ER_REGEXP_BAD_ESCAPE_SEQUENCE = 3689;
  exports.ER_REGEXP_UNIMPLEMENTED = 3690;
  exports.ER_REGEXP_MISMATCHED_PAREN = 3691;
  exports.ER_REGEXP_BAD_INTERVAL = 3692;
  exports.ER_REGEXP_MAX_LT_MIN = 3693;
  exports.ER_REGEXP_INVALID_BACK_REF = 3694;
  exports.ER_REGEXP_LOOK_BEHIND_LIMIT = 3695;
  exports.ER_REGEXP_MISSING_CLOSE_BRACKET = 3696;
  exports.ER_REGEXP_INVALID_RANGE = 3697;
  exports.ER_REGEXP_STACK_OVERFLOW = 3698;
  exports.ER_REGEXP_TIME_OUT = 3699;
  exports.ER_REGEXP_PATTERN_TOO_BIG = 3700;
  exports.ER_CANT_SET_ERROR_LOG_SERVICE = 3701;
  exports.ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE = 3702;
  exports.ER_COMPONENT_FILTER_DIAGNOSTICS = 3703;
  exports.ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS = 3704;
  exports.ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS = 3705;
  exports.ER_NONPOSITIVE_RADIUS = 3706;
  exports.ER_RESTART_SERVER_FAILED = 3707;
  exports.ER_SRS_MISSING_MANDATORY_ATTRIBUTE = 3708;
  exports.ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS = 3709;
  exports.ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE = 3710;
  exports.ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE = 3711;
  exports.ER_SRS_ID_ALREADY_EXISTS = 3712;
  exports.ER_WARN_SRS_ID_ALREADY_EXISTS = 3713;
  exports.ER_CANT_MODIFY_SRID_0 = 3714;
  exports.ER_WARN_RESERVED_SRID_RANGE = 3715;
  exports.ER_CANT_MODIFY_SRS_USED_BY_COLUMN = 3716;
  exports.ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE = 3717;
  exports.ER_SRS_ATTRIBUTE_STRING_TOO_LONG = 3718;
  exports.ER_DEPRECATED_UTF8_ALIAS = 3719;
  exports.ER_DEPRECATED_NATIONAL = 3720;
  exports.ER_INVALID_DEFAULT_UTF8MB4_COLLATION = 3721;
  exports.ER_UNABLE_TO_COLLECT_LOG_STATUS = 3722;
  exports.ER_RESERVED_TABLESPACE_NAME = 3723;
  exports.ER_UNABLE_TO_SET_OPTION = 3724;
  exports.ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL = 3725;
  exports.ER_SRS_NOT_GEOGRAPHIC = 3726;
  exports.ER_POLYGON_TOO_LARGE = 3727;
  exports.ER_SPATIAL_UNIQUE_INDEX = 3728;
  exports.ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX = 3729;
  exports.ER_FK_CANNOT_DROP_PARENT = 3730;
  exports.ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE = 3731;
  exports.ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE = 3732;
  exports.ER_FK_CANNOT_USE_VIRTUAL_COLUMN = 3733;
  exports.ER_FK_NO_COLUMN_PARENT = 3734;
  exports.ER_CANT_SET_ERROR_SUPPRESSION_LIST = 3735;
  exports.ER_SRS_GEOGCS_INVALID_AXES = 3736;
  exports.ER_SRS_INVALID_SEMI_MAJOR_AXIS = 3737;
  exports.ER_SRS_INVALID_INVERSE_FLATTENING = 3738;
  exports.ER_SRS_INVALID_ANGULAR_UNIT = 3739;
  exports.ER_SRS_INVALID_PRIME_MERIDIAN = 3740;
  exports.ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED = 3741;
  exports.ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED = 3742;
  exports.ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84 = 3743;
  exports.ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84 = 3744;
  exports.ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT = 3745;
  exports.ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3746;
  exports.ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3747;
  exports.ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR = 3748;
  exports.ER_XA_CANT_CREATE_MDL_BACKUP = 3749;
  exports.ER_TABLE_WITHOUT_PK = 3750;
  exports.ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX = 3751;
  exports.ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX = 3752;
  exports.ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION = 3753;
  exports.ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT = 3754;
  exports.ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX = 3755;
  exports.ER_FUNCTIONAL_INDEX_PRIMARY_KEY = 3756;
  exports.ER_FUNCTIONAL_INDEX_ON_LOB = 3757;
  exports.ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED = 3758;
  exports.ER_FULLTEXT_FUNCTIONAL_INDEX = 3759;
  exports.ER_SPATIAL_FUNCTIONAL_INDEX = 3760;
  exports.ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX = 3761;
  exports.ER_FUNCTIONAL_INDEX_ON_FIELD = 3762;
  exports.ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED = 3763;
  exports.ER_GENERATED_COLUMN_ROW_VALUE = 3764;
  exports.ER_GENERATED_COLUMN_VARIABLES = 3765;
  exports.ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE = 3766;
  exports.ER_DEFAULT_VAL_GENERATED_NON_PRIOR = 3767;
  exports.ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC = 3768;
  exports.ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED = 3769;
  exports.ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED = 3770;
  exports.ER_DEFAULT_VAL_GENERATED_ROW_VALUE = 3771;
  exports.ER_DEFAULT_VAL_GENERATED_VARIABLES = 3772;
  exports.ER_DEFAULT_AS_VAL_GENERATED = 3773;
  exports.ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED = 3774;
  exports.ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION = 3775;
  exports.ER_FK_CANNOT_CHANGE_ENGINE = 3776;
  exports.ER_WARN_DEPRECATED_USER_SET_EXPR = 3777;
  exports.ER_WARN_DEPRECATED_UTF8MB3_COLLATION = 3778;
  exports.ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX = 3779;
  exports.ER_FK_INCOMPATIBLE_COLUMNS = 3780;
  exports.ER_GR_HOLD_WAIT_TIMEOUT = 3781;
  exports.ER_GR_HOLD_KILLED = 3782;
  exports.ER_GR_HOLD_MEMBER_STATUS_ERROR = 3783;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY = 3784;
  exports.ER_RPL_ENCRYPTION_KEY_NOT_FOUND = 3785;
  exports.ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY = 3786;
  exports.ER_RPL_ENCRYPTION_HEADER_ERROR = 3787;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS = 3788;
  exports.ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED = 3789;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY = 3790;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY = 3791;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY = 3792;
  exports.ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION = 3793;
  exports.ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED = 3794;
  exports.ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE = 3795;
  exports.ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED = 3796;
  exports.ER_GRP_TRX_CONSISTENCY_BEFORE = 3797;
  exports.ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN = 3798;
  exports.ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED = 3799;
  exports.ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED = 3800;
  exports.ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT = 3801;
  exports.ER_PAGE_TRACKING_NOT_STARTED = 3802;
  exports.ER_PAGE_TRACKING_RANGE_NOT_TRACKED = 3803;
  exports.ER_PAGE_TRACKING_CANNOT_PURGE = 3804;
  exports.ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY = 3805;
  exports.ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION = 3806;
  exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY = 3807;
  exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS = 3808;
  exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG = 3809;
  exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS = 3810;
  exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY = 3811;
  exports.ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT = 3812;
  exports.ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN = 3813;
  exports.ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED = 3814;
  exports.ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED = 3815;
  exports.ER_CHECK_CONSTRAINT_VARIABLES = 3816;
  exports.ER_CHECK_CONSTRAINT_ROW_VALUE = 3817;
  exports.ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN = 3818;
  exports.ER_CHECK_CONSTRAINT_VIOLATED = 3819;
  exports.ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN = 3820;
  exports.ER_CHECK_CONSTRAINT_NOT_FOUND = 3821;
  exports.ER_CHECK_CONSTRAINT_DUP_NAME = 3822;
  exports.ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN = 3823;
  exports.WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB = 3824;
  exports.ER_INVALID_ENCRYPTION_REQUEST = 3825;
  exports.ER_CANNOT_SET_TABLE_ENCRYPTION = 3826;
  exports.ER_CANNOT_SET_DATABASE_ENCRYPTION = 3827;
  exports.ER_CANNOT_SET_TABLESPACE_ENCRYPTION = 3828;
  exports.ER_TABLESPACE_CANNOT_BE_ENCRYPTED = 3829;
  exports.ER_TABLESPACE_CANNOT_BE_DECRYPTED = 3830;
  exports.ER_TABLESPACE_TYPE_UNKNOWN = 3831;
  exports.ER_TARGET_TABLESPACE_UNENCRYPTED = 3832;
  exports.ER_CANNOT_USE_ENCRYPTION_CLAUSE = 3833;
  exports.ER_INVALID_MULTIPLE_CLAUSES = 3834;
  exports.ER_UNSUPPORTED_USE_OF_GRANT_AS = 3835;
  exports.ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS = 3836;
  exports.ER_DEPENDENT_BY_FUNCTIONAL_INDEX = 3837;
  exports.ER_PLUGIN_NOT_EARLY = 3838;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH = 3839;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT = 3840;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID = 3841;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND = 3842;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY = 3843;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR = 3844;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH = 3845;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS = 3846;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE = 3847;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE = 3848;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE = 3849;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_FAILED = 3850;
  exports.ER_INNODB_REDO_LOG_ARCHIVE_SESSION = 3851;
  exports.ER_STD_REGEX_ERROR = 3852;
  exports.ER_INVALID_JSON_TYPE = 3853;
  exports.ER_CANNOT_CONVERT_STRING = 3854;
  exports.ER_DEPENDENT_BY_PARTITION_FUNC = 3855;
  exports.ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT = 3856;
  exports.ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP = 3857;
  exports.ER_WARN_DEPRECATED_FLOAT_DIGITS = 3858;
  exports.ER_WARN_DEPRECATED_FLOAT_UNSIGNED = 3859;
  exports.ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH = 3860;
  exports.ER_WARN_DEPRECATED_ZEROFILL = 3861;
  exports.ER_CLONE_DONOR = 3862;
  exports.ER_CLONE_PROTOCOL = 3863;
  exports.ER_CLONE_DONOR_VERSION = 3864;
  exports.ER_CLONE_OS = 3865;
  exports.ER_CLONE_PLATFORM = 3866;
  exports.ER_CLONE_CHARSET = 3867;
  exports.ER_CLONE_CONFIG = 3868;
  exports.ER_CLONE_SYS_CONFIG = 3869;
  exports.ER_CLONE_PLUGIN_MATCH = 3870;
  exports.ER_CLONE_LOOPBACK = 3871;
  exports.ER_CLONE_ENCRYPTION = 3872;
  exports.ER_CLONE_DISK_SPACE = 3873;
  exports.ER_CLONE_IN_PROGRESS = 3874;
  exports.ER_CLONE_DISALLOWED = 3875;
  exports.ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER = 3876;
  exports.ER_SECONDARY_ENGINE_PLUGIN = 3877;
  exports.ER_SECOND_PASSWORD_CANNOT_BE_EMPTY = 3878;
  exports.ER_DB_ACCESS_DENIED = 3879;
  exports.ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES = 3880;
  exports.ER_DA_RPL_GTID_TABLE_CANNOT_OPEN = 3881;
  exports.ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT = 3882;
  exports.ER_DA_PLUGIN_INSTALL_ERROR = 3883;
  exports.ER_NO_SESSION_TEMP = 3884;
  exports.ER_DA_UNKNOWN_ERROR_NUMBER = 3885;
  exports.ER_COLUMN_CHANGE_SIZE = 3886;
  exports.ER_REGEXP_INVALID_CAPTURE_GROUP_NAME = 3887;
  exports.ER_DA_SSL_LIBRARY_ERROR = 3888;
  exports.ER_SECONDARY_ENGINE = 3889;
  exports.ER_SECONDARY_ENGINE_DDL = 3890;
  exports.ER_INCORRECT_CURRENT_PASSWORD = 3891;
  exports.ER_MISSING_CURRENT_PASSWORD = 3892;
  exports.ER_CURRENT_PASSWORD_NOT_REQUIRED = 3893;
  exports.ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE = 3894;
  exports.ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED = 3895;
  exports.ER_PARTIAL_REVOKES_EXIST = 3896;
  exports.ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE = 3897;
  exports.ER_XA_REPLICATION_FILTERS = 3898;
  exports.ER_UNSUPPORTED_SQL_MODE = 3899;
  exports.ER_REGEXP_INVALID_FLAG = 3900;
  exports.ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS = 3901;
  exports.ER_UNIT_NOT_FOUND = 3902;
  exports.ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX = 3903;
  exports.ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX = 3904;
  exports.ER_EXCEEDED_MV_KEYS_NUM = 3905;
  exports.ER_EXCEEDED_MV_KEYS_SPACE = 3906;
  exports.ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG = 3907;
  exports.ER_WRONG_MVI_VALUE = 3908;
  exports.ER_WARN_FUNC_INDEX_NOT_APPLICABLE = 3909;
  exports.ER_GRP_RPL_UDF_ERROR = 3910;
  exports.ER_UPDATE_GTID_PURGED_WITH_GR = 3911;
  exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3912;
  exports.ER_TABLE_NAME_CAUSES_TOO_LONG_PATH = 3913;
  exports.ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE = 3914;
  exports.ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED = 3915;
  exports.ER_DA_GRP_RPL_STARTED_AUTO_REJOIN = 3916;
  exports.ER_SYSVAR_CHANGE_DURING_QUERY = 3917;
  exports.ER_GLOBSTAT_CHANGE_DURING_QUERY = 3918;
  exports.ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE = 3919;
  exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3920;
  exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT = 3921;
  exports.ER_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3922;
  exports.ER_WRONG_COMPRESSION_LEVEL_CLIENT = 3923;
  exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT = 3924;
  exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS = 3925;
  exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST = 3926;
  exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT = 3927;
  exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV = 3928;
  exports.ER_WARN_DA_PRIVILEGE_NOT_REGISTERED = 3929;
  exports.ER_CLIENT_KEYRING_UDF_KEY_INVALID = 3930;
  exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID = 3931;
  exports.ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG = 3932;
  exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG = 3933;
  exports.ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT = 3934;
  exports.ER_DA_UDF_INVALID_CHARSET_SPECIFIED = 3935;
  exports.ER_DA_UDF_INVALID_CHARSET = 3936;
  exports.ER_DA_UDF_INVALID_COLLATION = 3937;
  exports.ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE = 3938;
  exports.ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME = 3939;
  exports.ER_CONSTRAINT_NOT_FOUND = 3940;
  exports.ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED = 3941;
  exports.ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS = 3942;
  exports.ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT = 3943;
  exports.ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT = 3944;
  exports.ER_REQUIRE_ROW_FORMAT_INVALID_VALUE = 3945;
  exports.ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY = 3946;
  exports.ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST = 3947;
  exports.ER_CLIENT_LOCAL_FILES_DISABLED = 3948;
  exports.ER_IMP_INCOMPATIBLE_CFG_VERSION = 3949;
  exports.ER_DA_OOM = 3950;
  exports.ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET = 3951;
  exports.ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET = 3952;
  exports.ER_MULTIPLE_INTO_CLAUSES = 3953;
  exports.ER_MISPLACED_INTO = 3954;
  exports.ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK = 3955;
  exports.ER_WARN_DEPRECATED_YEAR_UNSIGNED = 3956;
  exports.ER_CLONE_NETWORK_PACKET = 3957;
  exports.ER_SDI_OPERATION_FAILED_MISSING_RECORD = 3958;
  exports.ER_DEPENDENT_BY_CHECK_CONSTRAINT = 3959;
  exports.ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP = 3960;
  exports.ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY = 3961;
  exports.ER_WARN_DEPRECATED_INNER_INTO = 3962;
  exports.ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL = 3963;
  exports.ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS = 3964;
  exports.ER_WARN_DEPRECATED_FOUND_ROWS = 3965;
  exports.ER_MISSING_JSON_VALUE = 3966;
  exports.ER_MULTIPLE_JSON_VALUES = 3967;
  exports.ER_HOSTNAME_TOO_LONG = 3968;
  exports.ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY = 3969;
  exports.ER_GROUP_REPLICATION_USER_EMPTY_MSG = 3970;
  exports.ER_GROUP_REPLICATION_USER_MANDATORY_MSG = 3971;
  exports.ER_GROUP_REPLICATION_PASSWORD_LENGTH = 3972;
  exports.ER_SUBQUERY_TRANSFORM_REJECTED = 3973;
  exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT = 3974;
  exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID = 3975;
  exports.ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART = 3976;
  exports.ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION = 3977;
  exports.ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT = 3978;
  exports.ER_NOT_ALLOWED_WITH_START_TRANSACTION = 3979;
  exports.ER_INVALID_JSON_ATTRIBUTE = 3980;
  exports.ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED = 3981;
  exports.ER_INVALID_USER_ATTRIBUTE_JSON = 3982;
  exports.ER_INNODB_REDO_DISABLED = 3983;
  exports.ER_INNODB_REDO_ARCHIVING_ENABLED = 3984;
  exports.ER_MDL_OUT_OF_RESOURCES = 3985;
  exports.ER_IMPLICIT_COMPARISON_FOR_JSON = 3986;
  exports.ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET = 3987;
  exports.ER_IMPOSSIBLE_STRING_CONVERSION = 3988;
  exports.ER_SCHEMA_READ_ONLY = 3989;
  exports.ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF = 3990;
  exports.ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF = 3991;
  exports.ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF = 3992;
  exports.ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF = 3993;
  exports.ER_INVALID_PARAMETER_USE = 3994;
  exports.ER_CHARACTER_SET_MISMATCH = 3995;
  exports.ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED = 3996;
  exports.ER_INVALID_TIME_ZONE_INTERVAL = 3997;
  exports.ER_INVALID_CAST = 3998;
  exports.ER_HYPERGRAPH_NOT_SUPPORTED_YET = 3999;
  exports.ER_WARN_HYPERGRAPH_EXPERIMENTAL = 4000;
  exports.ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED = 4001;
  exports.ER_DA_ERROR_LOG_TABLE_DISABLED = 4002;
  exports.ER_DA_ERROR_LOG_MULTIPLE_FILTERS = 4003;
  exports.ER_DA_CANT_OPEN_ERROR_LOG = 4004;
  exports.ER_USER_REFERENCED_AS_DEFINER = 4005;
  exports.ER_CANNOT_USER_REFERENCED_AS_DEFINER = 4006;
  exports.ER_REGEX_NUMBER_TOO_BIG = 4007;
  exports.ER_SPVAR_NONINTEGER_TYPE = 4008;
  exports.WARN_UNSUPPORTED_ACL_TABLES_READ = 4009;
  exports.ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL = 4010;
  exports.ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT = 4011;
  exports.ER_STARTING_REPLICA_MONITOR_IO_THREAD = 4012;
  exports.ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON = 4013;
  exports.ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION = 4014;
  exports.ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON = 4015;
  exports.ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON = 4016;
  exports.ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID = 4017;
  exports.ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS = 4018;
  exports.ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID = 4019;
  exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME = 4020;
  exports.ER_CANT_USE_SAME_UUID_AS_GROUP_NAME = 4021;
  exports.ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING = 4022;
  exports.ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE = 4023;
  exports.ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE = 4024;
  exports.ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE = 4025;
  exports.ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE = 4026;
  exports.ER_ROLE_GRANTED_TO_ITSELF = 4027;
  exports.ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN = 4028;
  exports.ER_INNODB_COMPRESSION_FAILURE = 4029;
  exports.ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE = 4030;
  exports.ER_CLIENT_INTERACTION_TIMEOUT = 4031;
  exports.ER_INVALID_CAST_TO_GEOMETRY = 4032;
  exports.ER_INVALID_CAST_POLYGON_RING_DIRECTION = 4033;
  exports.ER_GIS_DIFFERENT_SRIDS_AGGREGATION = 4034;
  exports.ER_RELOAD_KEYRING_FAILURE = 4035;
  exports.ER_SDI_GET_KEYS_INVALID_TABLESPACE = 4036;
  exports.ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE = 4037;
  exports.ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI = 4038;
  exports.ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID = 4039;
  exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID = 4040;
  exports.ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE = 4041;
  exports.ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS = 4042;
  exports.ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE = 4043;
  exports.ER_KERBEROS_CREATE_USER = 4044;
  exports.ER_INSTALL_PLUGIN_CONFLICT_CLIENT = 4045;
  exports.ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED = 4046;
  exports.ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED = 4047;
  exports.ER_INVALID_ASSIGNMENT_TARGET = 4048;
  exports.ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY = 4049;
  exports.ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION = 4050;
  exports.ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON = 4051;
  exports.ER_INVALID_MFA_PLUGIN_SPECIFIED = 4052;
  exports.ER_IDENTIFIED_BY_UNSUPPORTED = 4053;
  exports.ER_INVALID_PLUGIN_FOR_REGISTRATION = 4054;
  exports.ER_PLUGIN_REQUIRES_REGISTRATION = 4055;
  exports.ER_MFA_METHOD_EXISTS = 4056;
  exports.ER_MFA_METHOD_NOT_EXISTS = 4057;
  exports.ER_AUTHENTICATION_POLICY_MISMATCH = 4058;
  exports.ER_PLUGIN_REGISTRATION_DONE = 4059;
  exports.ER_INVALID_USER_FOR_REGISTRATION = 4060;
  exports.ER_USER_REGISTRATION_FAILED = 4061;
  exports.ER_MFA_METHODS_INVALID_ORDER = 4062;
  exports.ER_MFA_METHODS_IDENTICAL = 4063;
  exports.ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER = 4064;
  exports.ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY = 4065;
  exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY = 4066;
  exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY = 4067;
  exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS = 4068;
  exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS = 4069;
  exports.ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON = 4070;
  exports.ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON = 4071;
  exports.ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS = 4072;
  exports.ER_DA_SSL_FIPS_MODE_ERROR = 4073;
  exports.ER_VALUE_OUT_OF_RANGE = 4074;
  exports.ER_FULLTEXT_WITH_ROLLUP = 4075;
  exports.ER_REGEXP_MISSING_RESOURCE = 4076;
  exports.ER_WARN_REGEXP_USING_DEFAULT = 4077;
  exports.ER_REGEXP_MISSING_FILE = 4078;
  exports.ER_WARN_DEPRECATED_COLLATION = 4079;
  exports.ER_CONCURRENT_PROCEDURE_USAGE = 4080;
  exports.ER_DA_GLOBAL_CONN_LIMIT = 4081;
  exports.ER_DA_CONN_LIMIT = 4082;
  exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT = 4083;
  exports.ER_WARN_SF_UDF_NAME_COLLISION = 4084;
  exports.ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK = 4085;
  exports.ER_TOO_MANY_WINDOWS = 4086;
  exports.ER_MYSQLBACKUP_CLIENT_MSG = 4087;
  exports.ER_COMMENT_CONTAINS_INVALID_STRING = 4088;
  exports.ER_DEFINITION_CONTAINS_INVALID_STRING = 4089;
  exports.ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT = 4090;
  exports.ER_XA_TEMP_TABLE = 4091;
  exports.ER_INNODB_MAX_ROW_VERSION = 4092;
  exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE = 4093;
  exports.ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING = 4094;
  exports.ER_WARN_DEPRECATED_DATETIME_DELIMITER = 4095;
  exports.ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER = 4096;
  exports.ER_CANNOT_PERSIST_SENSITIVE_VARIABLES = 4097;
  exports.ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES = 4098;
  exports.ER_WARN_TRG_ALREADY_EXISTS = 4099;
  exports.ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE = 4100;
  exports.ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION = 4101;
  exports.ER_SET_PASSWORD_AUTH_PLUGIN_ERROR = 4102;
  exports.ER_REDUCED_DBLWR_FILE_CORRUPTED = 4103;
  exports.ER_REDUCED_DBLWR_PAGE_FOUND = 4104;
  exports.ER_SRS_INVALID_LATITUDE_OF_ORIGIN = 4105;
  exports.ER_SRS_INVALID_LONGITUDE_OF_ORIGIN = 4106;
  exports.ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT = 4107;
  exports.ER_GIPK_COLUMN_EXISTS = 4108;
  exports.ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS = 4109;
  exports.ER_GIPK_COLUMN_ALTER_NOT_ALLOWED = 4110;
  exports.ER_DROP_PK_COLUMN_TO_DROP_GIPK = 4111;
  exports.ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR = 4112;
  exports.ER_DA_EXPIRE_LOGS_DAYS_IGNORED = 4113;
  exports.ER_CTE_RECURSIVE_NOT_UNION = 4114;
  exports.ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX = 4115;
  exports.ER_COMMAND_SERVICE_BACKEND_FAILED = 4116;
  exports.ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS = 4117;
  exports.ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE = 4118;
  exports.ER_WARN_DEPRECATED_IDENT = 4119;
  exports.ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED = 4120;
  exports.ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT = 4121;
  exports.ER_BAD_TIMESTAMP_FORMAT = 4122;
  exports.ER_SHAPE_PRIDICTION_UDF = 4123;
  exports.ER_SRS_INVALID_HEIGHT = 4124;
  exports.ER_SRS_INVALID_SCALING = 4125;
  exports.ER_SRS_INVALID_ZONE_WIDTH = 4126;
  exports.ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A = 4127;
  exports.ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION = 4128;
  exports.ER_TABLE_NOT_EMPTY = 4129;
  exports.ER_TABLE_NO_PRIMARY_KEY = 4130;
  exports.ER_TABLE_IN_SHARED_TABLESPACE = 4131;
  exports.ER_INDEX_OTHER_THAN_PK = 4132;
  exports.ER_LOAD_BULK_DATA_UNSORTED = 4133;
  exports.ER_BULK_EXECUTOR_ERROR = 4134;
  exports.ER_BULK_READER_LIBCURL_INIT_FAILED = 4135;
  exports.ER_BULK_READER_LIBCURL_ERROR = 4136;
  exports.ER_BULK_READER_SERVER_ERROR = 4137;
  exports.ER_BULK_READER_COMMUNICATION_ERROR = 4138;
  exports.ER_BULK_LOAD_DATA_FAILED = 4139;
  exports.ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER = 4140;
  exports.ER_BULK_LOADER_COMPONENT_ERROR = 4141;
  exports.ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE = 4142;
  exports.ER_BULK_PARSER_MISSING_ENCLOSED_BY = 4143;
  exports.ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED = 4144;
  exports.ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED = 4145;
  exports.ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT = 4146;
  exports.ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR = 4147;
  exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY = 4148;
  exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE = 4149;
  exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR = 4150;
  exports.ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE = 4151;
  exports.ER_LOAD_BULK_DATA_FAILED = 4152;
  exports.ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD = 4153;
  exports.ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL = 4154;
  exports.ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR = 4155;
  exports.ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE = 4156;
  exports.ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE = 4157;
  exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS = 4158;
  exports.ER_CANT_SET_PERSISTED = 4159;
  exports.ER_INSTALL_COMPONENT_SET_NULL_VALUE = 4160;
  exports.ER_INSTALL_COMPONENT_SET_UNUSED_VALUE = 4161;
  exports.ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS = 4162;
  exports[1] = "EE_CANTCREATEFILE";
  exports[2] = "EE_READ";
  exports[3] = "EE_WRITE";
  exports[4] = "EE_BADCLOSE";
  exports[5] = "EE_OUTOFMEMORY";
  exports[6] = "EE_DELETE";
  exports[7] = "EE_LINK";
  exports[9] = "EE_EOFERR";
  exports[10] = "EE_CANTLOCK";
  exports[11] = "EE_CANTUNLOCK";
  exports[12] = "EE_DIR";
  exports[13] = "EE_STAT";
  exports[14] = "EE_CANT_CHSIZE";
  exports[15] = "EE_CANT_OPEN_STREAM";
  exports[16] = "EE_GETWD";
  exports[17] = "EE_SETWD";
  exports[18] = "EE_LINK_WARNING";
  exports[19] = "EE_OPEN_WARNING";
  exports[20] = "EE_DISK_FULL";
  exports[21] = "EE_CANT_MKDIR";
  exports[22] = "EE_UNKNOWN_CHARSET";
  exports[23] = "EE_OUT_OF_FILERESOURCES";
  exports[24] = "EE_CANT_READLINK";
  exports[25] = "EE_CANT_SYMLINK";
  exports[26] = "EE_REALPATH";
  exports[27] = "EE_SYNC";
  exports[28] = "EE_UNKNOWN_COLLATION";
  exports[29] = "EE_FILENOTFOUND";
  exports[30] = "EE_FILE_NOT_CLOSED";
  exports[31] = "EE_CHANGE_OWNERSHIP";
  exports[32] = "EE_CHANGE_PERMISSIONS";
  exports[33] = "EE_CANT_SEEK";
  exports[34] = "EE_CAPACITY_EXCEEDED";
  exports[35] = "EE_DISK_FULL_WITH_RETRY_MSG";
  exports[36] = "EE_FAILED_TO_CREATE_TIMER";
  exports[37] = "EE_FAILED_TO_DELETE_TIMER";
  exports[38] = "EE_FAILED_TO_CREATE_TIMER_QUEUE";
  exports[39] = "EE_FAILED_TO_START_TIMER_NOTIFY_THREAD";
  exports[40] = "EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT";
  exports[41] = "EE_EXITING_TIMER_NOTIFY_THREAD";
  exports[42] = "EE_WIN_LIBRARY_LOAD_FAILED";
  exports[43] = "EE_WIN_RUN_TIME_ERROR_CHECK";
  exports[44] = "EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE";
  exports[45] = "EE_FAILED_TO_KILL_ALL_THREADS";
  exports[46] = "EE_FAILED_TO_CREATE_IO_COMPLETION_PORT";
  exports[47] = "EE_FAILED_TO_OPEN_DEFAULTS_FILE";
  exports[48] = "EE_FAILED_TO_HANDLE_DEFAULTS_FILE";
  exports[49] = "EE_WRONG_DIRECTIVE_IN_CONFIG_FILE";
  exports[50] = "EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION";
  exports[51] = "EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE";
  exports[52] = "EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE";
  exports[53] = "EE_CONFIG_FILE_PERMISSION_ERROR";
  exports[54] = "EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE";
  exports[55] = "EE_USING_DISABLED_OPTION";
  exports[56] = "EE_USING_DISABLED_SHORT_OPTION";
  exports[57] = "EE_USING_PASSWORD_ON_CLI_IS_INSECURE";
  exports[58] = "EE_UNKNOWN_SUFFIX_FOR_VARIABLE";
  exports[59] = "EE_SSL_ERROR_FROM_FILE";
  exports[60] = "EE_SSL_ERROR";
  exports[61] = "EE_NET_SEND_ERROR_IN_BOOTSTRAP";
  exports[62] = "EE_PACKETS_OUT_OF_ORDER";
  exports[63] = "EE_UNKNOWN_PROTOCOL_OPTION";
  exports[64] = "EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY";
  exports[65] = "EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT";
  exports[66] = "EE_DEBUG_INFO";
  exports[67] = "EE_UNKNOWN_VARIABLE";
  exports[68] = "EE_UNKNOWN_OPTION";
  exports[69] = "EE_UNKNOWN_SHORT_OPTION";
  exports[70] = "EE_OPTION_WITHOUT_ARGUMENT";
  exports[71] = "EE_OPTION_REQUIRES_ARGUMENT";
  exports[72] = "EE_SHORT_OPTION_REQUIRES_ARGUMENT";
  exports[73] = "EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE";
  exports[74] = "EE_OPTION_WITH_EMPTY_VALUE";
  exports[75] = "EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION";
  exports[76] = "EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION";
  exports[77] = "EE_FAILED_TO_SET_OPTION_VALUE";
  exports[78] = "EE_INCORRECT_INT_VALUE_FOR_OPTION";
  exports[79] = "EE_INCORRECT_UINT_VALUE_FOR_OPTION";
  exports[80] = "EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION";
  exports[81] = "EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION";
  exports[82] = "EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION";
  exports[83] = "EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION";
  exports[84] = "EE_INVALID_DECIMAL_VALUE_FOR_OPTION";
  exports[85] = "EE_COLLATION_PARSER_ERROR";
  exports[86] = "EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR";
  exports[87] = "EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR";
  exports[88] = "EE_SHIFT_CHAR_OUT_OF_RANGE";
  exports[89] = "EE_RESET_CHAR_OUT_OF_RANGE";
  exports[90] = "EE_UNKNOWN_LDML_TAG";
  exports[91] = "EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR";
  exports[92] = "EE_FAILED_PROCESSING_DIRECTIVE";
  exports[93] = "EE_PTHREAD_KILL_FAILED";
  exports[120] = "HA_ERR_KEY_NOT_FOUND";
  exports[121] = "HA_ERR_FOUND_DUPP_KEY";
  exports[122] = "HA_ERR_INTERNAL_ERROR";
  exports[123] = "HA_ERR_RECORD_CHANGED";
  exports[124] = "HA_ERR_WRONG_INDEX";
  exports[125] = "HA_ERR_ROLLED_BACK";
  exports[126] = "HA_ERR_CRASHED";
  exports[127] = "HA_ERR_WRONG_IN_RECORD";
  exports[128] = "HA_ERR_OUT_OF_MEM";
  exports[130] = "HA_ERR_NOT_A_TABLE";
  exports[131] = "HA_ERR_WRONG_COMMAND";
  exports[132] = "HA_ERR_OLD_FILE";
  exports[133] = "HA_ERR_NO_ACTIVE_RECORD";
  exports[134] = "HA_ERR_RECORD_DELETED";
  exports[135] = "HA_ERR_RECORD_FILE_FULL";
  exports[136] = "HA_ERR_INDEX_FILE_FULL";
  exports[137] = "HA_ERR_END_OF_FILE";
  exports[138] = "HA_ERR_UNSUPPORTED";
  exports[139] = "HA_ERR_TOO_BIG_ROW";
  exports[140] = "HA_WRONG_CREATE_OPTION";
  exports[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
  exports[142] = "HA_ERR_UNKNOWN_CHARSET";
  exports[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
  exports[144] = "HA_ERR_CRASHED_ON_REPAIR";
  exports[145] = "HA_ERR_CRASHED_ON_USAGE";
  exports[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
  exports[147] = "HA_ERR_LOCK_TABLE_FULL";
  exports[148] = "HA_ERR_READ_ONLY_TRANSACTION";
  exports[149] = "HA_ERR_LOCK_DEADLOCK";
  exports[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
  exports[151] = "HA_ERR_NO_REFERENCED_ROW";
  exports[152] = "HA_ERR_ROW_IS_REFERENCED";
  exports[153] = "HA_ERR_NO_SAVEPOINT";
  exports[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
  exports[155] = "HA_ERR_NO_SUCH_TABLE";
  exports[156] = "HA_ERR_TABLE_EXIST";
  exports[157] = "HA_ERR_NO_CONNECTION";
  exports[158] = "HA_ERR_NULL_IN_SPATIAL";
  exports[159] = "HA_ERR_TABLE_DEF_CHANGED";
  exports[160] = "HA_ERR_NO_PARTITION_FOUND";
  exports[161] = "HA_ERR_RBR_LOGGING_FAILED";
  exports[162] = "HA_ERR_DROP_INDEX_FK";
  exports[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
  exports[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
  exports[165] = "HA_ERR_TABLE_READONLY";
  exports[166] = "HA_ERR_AUTOINC_READ_FAILED";
  exports[167] = "HA_ERR_AUTOINC_ERANGE";
  exports[168] = "HA_ERR_GENERIC";
  exports[169] = "HA_ERR_RECORD_IS_THE_SAME";
  exports[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
  exports[171] = "HA_ERR_CORRUPT_EVENT";
  exports[172] = "HA_ERR_NEW_FILE";
  exports[173] = "HA_ERR_ROWS_EVENT_APPLY";
  exports[174] = "HA_ERR_INITIALIZATION";
  exports[175] = "HA_ERR_FILE_TOO_SHORT";
  exports[176] = "HA_ERR_WRONG_CRC";
  exports[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
  exports[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
  exports[179] = "HA_ERR_INDEX_COL_TOO_LONG";
  exports[180] = "HA_ERR_INDEX_CORRUPT";
  exports[181] = "HA_ERR_UNDO_REC_TOO_BIG";
  exports[182] = "HA_FTS_INVALID_DOCID";
  exports[183] = "HA_ERR_TABLE_IN_FK_CHECK";
  exports[184] = "HA_ERR_TABLESPACE_EXISTS";
  exports[185] = "HA_ERR_TOO_MANY_FIELDS";
  exports[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
  exports[187] = "HA_ERR_INNODB_READ_ONLY";
  exports[188] = "HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT";
  exports[189] = "HA_ERR_TEMP_FILE_WRITE_FAILURE";
  exports[190] = "HA_ERR_INNODB_FORCED_RECOVERY";
  exports[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
  exports[192] = "HA_ERR_FK_DEPTH_EXCEEDED";
  exports[193] = "HA_MISSING_CREATE_OPTION";
  exports[194] = "HA_ERR_SE_OUT_OF_MEMORY";
  exports[195] = "HA_ERR_TABLE_CORRUPT";
  exports[196] = "HA_ERR_QUERY_INTERRUPTED";
  exports[197] = "HA_ERR_TABLESPACE_MISSING";
  exports[198] = "HA_ERR_TABLESPACE_IS_NOT_EMPTY";
  exports[199] = "HA_ERR_WRONG_FILE_NAME";
  exports[200] = "HA_ERR_NOT_ALLOWED_COMMAND";
  exports[201] = "HA_ERR_COMPUTE_FAILED";
  exports[202] = "HA_ERR_ROW_FORMAT_CHANGED";
  exports[203] = "HA_ERR_NO_WAIT_LOCK";
  exports[204] = "HA_ERR_DISK_FULL_NOWAIT";
  exports[205] = "HA_ERR_NO_SESSION_TEMP";
  exports[206] = "HA_ERR_WRONG_TABLE_NAME";
  exports[207] = "HA_ERR_TOO_LONG_PATH";
  exports[208] = "HA_ERR_SAMPLING_INIT_FAILED";
  exports[209] = "HA_ERR_FTS_TOO_MANY_NESTED_EXP";
  exports[1000] = "ER_HASHCHK";
  exports[1001] = "ER_NISAMCHK";
  exports[1002] = "ER_NO";
  exports[1003] = "ER_YES";
  exports[1004] = "ER_CANT_CREATE_FILE";
  exports[1005] = "ER_CANT_CREATE_TABLE";
  exports[1006] = "ER_CANT_CREATE_DB";
  exports[1007] = "ER_DB_CREATE_EXISTS";
  exports[1008] = "ER_DB_DROP_EXISTS";
  exports[1009] = "ER_DB_DROP_DELETE";
  exports[1010] = "ER_DB_DROP_RMDIR";
  exports[1011] = "ER_CANT_DELETE_FILE";
  exports[1012] = "ER_CANT_FIND_SYSTEM_REC";
  exports[1013] = "ER_CANT_GET_STAT";
  exports[1014] = "ER_CANT_GET_WD";
  exports[1015] = "ER_CANT_LOCK";
  exports[1016] = "ER_CANT_OPEN_FILE";
  exports[1017] = "ER_FILE_NOT_FOUND";
  exports[1018] = "ER_CANT_READ_DIR";
  exports[1019] = "ER_CANT_SET_WD";
  exports[1020] = "ER_CHECKREAD";
  exports[1021] = "ER_DISK_FULL";
  exports[1022] = "ER_DUP_KEY";
  exports[1023] = "ER_ERROR_ON_CLOSE";
  exports[1024] = "ER_ERROR_ON_READ";
  exports[1025] = "ER_ERROR_ON_RENAME";
  exports[1026] = "ER_ERROR_ON_WRITE";
  exports[1027] = "ER_FILE_USED";
  exports[1028] = "ER_FILSORT_ABORT";
  exports[1029] = "ER_FORM_NOT_FOUND";
  exports[1030] = "ER_GET_ERRNO";
  exports[1031] = "ER_ILLEGAL_HA";
  exports[1032] = "ER_KEY_NOT_FOUND";
  exports[1033] = "ER_NOT_FORM_FILE";
  exports[1034] = "ER_NOT_KEYFILE";
  exports[1035] = "ER_OLD_KEYFILE";
  exports[1036] = "ER_OPEN_AS_READONLY";
  exports[1037] = "ER_OUTOFMEMORY";
  exports[1038] = "ER_OUT_OF_SORTMEMORY";
  exports[1039] = "ER_UNEXPECTED_EOF";
  exports[1040] = "ER_CON_COUNT_ERROR";
  exports[1041] = "ER_OUT_OF_RESOURCES";
  exports[1042] = "ER_BAD_HOST_ERROR";
  exports[1043] = "ER_HANDSHAKE_ERROR";
  exports[1044] = "ER_DBACCESS_DENIED_ERROR";
  exports[1045] = "ER_ACCESS_DENIED_ERROR";
  exports[1046] = "ER_NO_DB_ERROR";
  exports[1047] = "ER_UNKNOWN_COM_ERROR";
  exports[1048] = "ER_BAD_NULL_ERROR";
  exports[1049] = "ER_BAD_DB_ERROR";
  exports[1050] = "ER_TABLE_EXISTS_ERROR";
  exports[1051] = "ER_BAD_TABLE_ERROR";
  exports[1052] = "ER_NON_UNIQ_ERROR";
  exports[1053] = "ER_SERVER_SHUTDOWN";
  exports[1054] = "ER_BAD_FIELD_ERROR";
  exports[1055] = "ER_WRONG_FIELD_WITH_GROUP";
  exports[1056] = "ER_WRONG_GROUP_FIELD";
  exports[1057] = "ER_WRONG_SUM_SELECT";
  exports[1058] = "ER_WRONG_VALUE_COUNT";
  exports[1059] = "ER_TOO_LONG_IDENT";
  exports[1060] = "ER_DUP_FIELDNAME";
  exports[1061] = "ER_DUP_KEYNAME";
  exports[1062] = "ER_DUP_ENTRY";
  exports[1063] = "ER_WRONG_FIELD_SPEC";
  exports[1064] = "ER_PARSE_ERROR";
  exports[1065] = "ER_EMPTY_QUERY";
  exports[1066] = "ER_NONUNIQ_TABLE";
  exports[1067] = "ER_INVALID_DEFAULT";
  exports[1068] = "ER_MULTIPLE_PRI_KEY";
  exports[1069] = "ER_TOO_MANY_KEYS";
  exports[1070] = "ER_TOO_MANY_KEY_PARTS";
  exports[1071] = "ER_TOO_LONG_KEY";
  exports[1072] = "ER_KEY_COLUMN_DOES_NOT_EXITS";
  exports[1073] = "ER_BLOB_USED_AS_KEY";
  exports[1074] = "ER_TOO_BIG_FIELDLENGTH";
  exports[1075] = "ER_WRONG_AUTO_KEY";
  exports[1076] = "ER_READY";
  exports[1077] = "ER_NORMAL_SHUTDOWN";
  exports[1078] = "ER_GOT_SIGNAL";
  exports[1079] = "ER_SHUTDOWN_COMPLETE";
  exports[1080] = "ER_FORCING_CLOSE";
  exports[1081] = "ER_IPSOCK_ERROR";
  exports[1082] = "ER_NO_SUCH_INDEX";
  exports[1083] = "ER_WRONG_FIELD_TERMINATORS";
  exports[1084] = "ER_BLOBS_AND_NO_TERMINATED";
  exports[1085] = "ER_TEXTFILE_NOT_READABLE";
  exports[1086] = "ER_FILE_EXISTS_ERROR";
  exports[1087] = "ER_LOAD_INFO";
  exports[1088] = "ER_ALTER_INFO";
  exports[1089] = "ER_WRONG_SUB_KEY";
  exports[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
  exports[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
  exports[1092] = "ER_INSERT_INFO";
  exports[1093] = "ER_UPDATE_TABLE_USED";
  exports[1094] = "ER_NO_SUCH_THREAD";
  exports[1095] = "ER_KILL_DENIED_ERROR";
  exports[1096] = "ER_NO_TABLES_USED";
  exports[1097] = "ER_TOO_BIG_SET";
  exports[1098] = "ER_NO_UNIQUE_LOGFILE";
  exports[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
  exports[1100] = "ER_TABLE_NOT_LOCKED";
  exports[1101] = "ER_BLOB_CANT_HAVE_DEFAULT";
  exports[1102] = "ER_WRONG_DB_NAME";
  exports[1103] = "ER_WRONG_TABLE_NAME";
  exports[1104] = "ER_TOO_BIG_SELECT";
  exports[1105] = "ER_UNKNOWN_ERROR";
  exports[1106] = "ER_UNKNOWN_PROCEDURE";
  exports[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
  exports[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
  exports[1109] = "ER_UNKNOWN_TABLE";
  exports[1110] = "ER_FIELD_SPECIFIED_TWICE";
  exports[1111] = "ER_INVALID_GROUP_FUNC_USE";
  exports[1112] = "ER_UNSUPPORTED_EXTENSION";
  exports[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
  exports[1114] = "ER_RECORD_FILE_FULL";
  exports[1115] = "ER_UNKNOWN_CHARACTER_SET";
  exports[1116] = "ER_TOO_MANY_TABLES";
  exports[1117] = "ER_TOO_MANY_FIELDS";
  exports[1118] = "ER_TOO_BIG_ROWSIZE";
  exports[1119] = "ER_STACK_OVERRUN";
  exports[1120] = "ER_WRONG_OUTER_JOIN";
  exports[1121] = "ER_NULL_COLUMN_IN_INDEX";
  exports[1122] = "ER_CANT_FIND_UDF";
  exports[1123] = "ER_CANT_INITIALIZE_UDF";
  exports[1124] = "ER_UDF_NO_PATHS";
  exports[1125] = "ER_UDF_EXISTS";
  exports[1126] = "ER_CANT_OPEN_LIBRARY";
  exports[1127] = "ER_CANT_FIND_DL_ENTRY";
  exports[1128] = "ER_FUNCTION_NOT_DEFINED";
  exports[1129] = "ER_HOST_IS_BLOCKED";
  exports[1130] = "ER_HOST_NOT_PRIVILEGED";
  exports[1131] = "ER_PASSWORD_ANONYMOUS_USER";
  exports[1132] = "ER_PASSWORD_NOT_ALLOWED";
  exports[1133] = "ER_PASSWORD_NO_MATCH";
  exports[1134] = "ER_UPDATE_INFO";
  exports[1135] = "ER_CANT_CREATE_THREAD";
  exports[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
  exports[1137] = "ER_CANT_REOPEN_TABLE";
  exports[1138] = "ER_INVALID_USE_OF_NULL";
  exports[1139] = "ER_REGEXP_ERROR";
  exports[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
  exports[1141] = "ER_NONEXISTING_GRANT";
  exports[1142] = "ER_TABLEACCESS_DENIED_ERROR";
  exports[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
  exports[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
  exports[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
  exports[1146] = "ER_NO_SUCH_TABLE";
  exports[1147] = "ER_NONEXISTING_TABLE_GRANT";
  exports[1148] = "ER_NOT_ALLOWED_COMMAND";
  exports[1149] = "ER_SYNTAX_ERROR";
  exports[1150] = "ER_UNUSED1";
  exports[1151] = "ER_UNUSED2";
  exports[1152] = "ER_ABORTING_CONNECTION";
  exports[1153] = "ER_NET_PACKET_TOO_LARGE";
  exports[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
  exports[1155] = "ER_NET_FCNTL_ERROR";
  exports[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
  exports[1157] = "ER_NET_UNCOMPRESS_ERROR";
  exports[1158] = "ER_NET_READ_ERROR";
  exports[1159] = "ER_NET_READ_INTERRUPTED";
  exports[1160] = "ER_NET_ERROR_ON_WRITE";
  exports[1161] = "ER_NET_WRITE_INTERRUPTED";
  exports[1162] = "ER_TOO_LONG_STRING";
  exports[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
  exports[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
  exports[1165] = "ER_UNUSED3";
  exports[1166] = "ER_WRONG_COLUMN_NAME";
  exports[1167] = "ER_WRONG_KEY_COLUMN";
  exports[1168] = "ER_WRONG_MRG_TABLE";
  exports[1169] = "ER_DUP_UNIQUE";
  exports[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
  exports[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
  exports[1172] = "ER_TOO_MANY_ROWS";
  exports[1173] = "ER_REQUIRES_PRIMARY_KEY";
  exports[1174] = "ER_NO_RAID_COMPILED";
  exports[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
  exports[1176] = "ER_KEY_DOES_NOT_EXITS";
  exports[1177] = "ER_CHECK_NO_SUCH_TABLE";
  exports[1178] = "ER_CHECK_NOT_IMPLEMENTED";
  exports[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
  exports[1180] = "ER_ERROR_DURING_COMMIT";
  exports[1181] = "ER_ERROR_DURING_ROLLBACK";
  exports[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
  exports[1183] = "ER_ERROR_DURING_CHECKPOINT";
  exports[1184] = "ER_NEW_ABORTING_CONNECTION";
  exports[1185] = "ER_DUMP_NOT_IMPLEMENTED";
  exports[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
  exports[1187] = "ER_INDEX_REBUILD";
  exports[1188] = "ER_SOURCE";
  exports[1189] = "ER_SOURCE_NET_READ";
  exports[1190] = "ER_SOURCE_NET_WRITE";
  exports[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
  exports[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
  exports[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
  exports[1194] = "ER_CRASHED_ON_USAGE";
  exports[1195] = "ER_CRASHED_ON_REPAIR";
  exports[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
  exports[1197] = "ER_TRANS_CACHE_FULL";
  exports[1198] = "ER_SLAVE_MUST_STOP";
  exports[1199] = "ER_REPLICA_NOT_RUNNING";
  exports[1200] = "ER_BAD_REPLICA";
  exports[1201] = "ER_CONNECTION_METADATA";
  exports[1202] = "ER_REPLICA_THREAD";
  exports[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
  exports[1204] = "ER_SET_CONSTANTS_ONLY";
  exports[1205] = "ER_LOCK_WAIT_TIMEOUT";
  exports[1206] = "ER_LOCK_TABLE_FULL";
  exports[1207] = "ER_READ_ONLY_TRANSACTION";
  exports[1208] = "ER_DROP_DB_WITH_READ_LOCK";
  exports[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
  exports[1210] = "ER_WRONG_ARGUMENTS";
  exports[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
  exports[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
  exports[1213] = "ER_LOCK_DEADLOCK";
  exports[1214] = "ER_TABLE_CANT_HANDLE_FT";
  exports[1215] = "ER_CANNOT_ADD_FOREIGN";
  exports[1216] = "ER_NO_REFERENCED_ROW";
  exports[1217] = "ER_ROW_IS_REFERENCED";
  exports[1218] = "ER_CONNECT_TO_SOURCE";
  exports[1219] = "ER_QUERY_ON_MASTER";
  exports[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
  exports[1221] = "ER_WRONG_USAGE";
  exports[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
  exports[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
  exports[1224] = "ER_MIXING_NOT_ALLOWED";
  exports[1225] = "ER_DUP_ARGUMENT";
  exports[1226] = "ER_USER_LIMIT_REACHED";
  exports[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
  exports[1228] = "ER_LOCAL_VARIABLE";
  exports[1229] = "ER_GLOBAL_VARIABLE";
  exports[1230] = "ER_NO_DEFAULT";
  exports[1231] = "ER_WRONG_VALUE_FOR_VAR";
  exports[1232] = "ER_WRONG_TYPE_FOR_VAR";
  exports[1233] = "ER_VAR_CANT_BE_READ";
  exports[1234] = "ER_CANT_USE_OPTION_HERE";
  exports[1235] = "ER_NOT_SUPPORTED_YET";
  exports[1236] = "ER_SOURCE_FATAL_ERROR_READING_BINLOG";
  exports[1237] = "ER_REPLICA_IGNORED_TABLE";
  exports[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
  exports[1239] = "ER_WRONG_FK_DEF";
  exports[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
  exports[1241] = "ER_OPERAND_COLUMNS";
  exports[1242] = "ER_SUBQUERY_NO_1_ROW";
  exports[1243] = "ER_UNKNOWN_STMT_HANDLER";
  exports[1244] = "ER_CORRUPT_HELP_DB";
  exports[1245] = "ER_CYCLIC_REFERENCE";
  exports[1246] = "ER_AUTO_CONVERT";
  exports[1247] = "ER_ILLEGAL_REFERENCE";
  exports[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
  exports[1249] = "ER_SELECT_REDUCED";
  exports[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
  exports[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
  exports[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
  exports[1253] = "ER_COLLATION_CHARSET_MISMATCH";
  exports[1254] = "ER_SLAVE_WAS_RUNNING";
  exports[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
  exports[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
  exports[1257] = "ER_ZLIB_Z_MEM_ERROR";
  exports[1258] = "ER_ZLIB_Z_BUF_ERROR";
  exports[1259] = "ER_ZLIB_Z_DATA_ERROR";
  exports[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
  exports[1261] = "ER_WARN_TOO_FEW_RECORDS";
  exports[1262] = "ER_WARN_TOO_MANY_RECORDS";
  exports[1263] = "ER_WARN_NULL_TO_NOTNULL";
  exports[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
  exports[1265] = "WARN_DATA_TRUNCATED";
  exports[1266] = "ER_WARN_USING_OTHER_HANDLER";
  exports[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
  exports[1268] = "ER_DROP_USER";
  exports[1269] = "ER_REVOKE_GRANTS";
  exports[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
  exports[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
  exports[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
  exports[1273] = "ER_UNKNOWN_COLLATION";
  exports[1274] = "ER_REPLICA_IGNORED_SSL_PARAMS";
  exports[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
  exports[1276] = "ER_WARN_FIELD_RESOLVED";
  exports[1277] = "ER_BAD_REPLICA_UNTIL_COND";
  exports[1278] = "ER_MISSING_SKIP_REPLICA";
  exports[1279] = "ER_UNTIL_COND_IGNORED";
  exports[1280] = "ER_WRONG_NAME_FOR_INDEX";
  exports[1281] = "ER_WRONG_NAME_FOR_CATALOG";
  exports[1282] = "ER_WARN_QC_RESIZE";
  exports[1283] = "ER_BAD_FT_COLUMN";
  exports[1284] = "ER_UNKNOWN_KEY_CACHE";
  exports[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
  exports[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
  exports[1287] = "ER_WARN_DEPRECATED_SYNTAX";
  exports[1288] = "ER_NON_UPDATABLE_TABLE";
  exports[1289] = "ER_FEATURE_DISABLED";
  exports[1290] = "ER_OPTION_PREVENTS_STATEMENT";
  exports[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
  exports[1292] = "ER_TRUNCATED_WRONG_VALUE";
  exports[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
  exports[1294] = "ER_INVALID_ON_UPDATE";
  exports[1295] = "ER_UNSUPPORTED_PS";
  exports[1296] = "ER_GET_ERRMSG";
  exports[1297] = "ER_GET_TEMPORARY_ERRMSG";
  exports[1298] = "ER_UNKNOWN_TIME_ZONE";
  exports[1299] = "ER_WARN_INVALID_TIMESTAMP";
  exports[1300] = "ER_INVALID_CHARACTER_STRING";
  exports[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
  exports[1302] = "ER_CONFLICTING_DECLARATIONS";
  exports[1303] = "ER_SP_NO_RECURSIVE_CREATE";
  exports[1304] = "ER_SP_ALREADY_EXISTS";
  exports[1305] = "ER_SP_DOES_NOT_EXIST";
  exports[1306] = "ER_SP_DROP_FAILED";
  exports[1307] = "ER_SP_STORE_FAILED";
  exports[1308] = "ER_SP_LILABEL_MISMATCH";
  exports[1309] = "ER_SP_LABEL_REDEFINE";
  exports[1310] = "ER_SP_LABEL_MISMATCH";
  exports[1311] = "ER_SP_UNINIT_VAR";
  exports[1312] = "ER_SP_BADSELECT";
  exports[1313] = "ER_SP_BADRETURN";
  exports[1314] = "ER_SP_BADSTATEMENT";
  exports[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
  exports[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
  exports[1317] = "ER_QUERY_INTERRUPTED";
  exports[1318] = "ER_SP_WRONG_NO_OF_ARGS";
  exports[1319] = "ER_SP_COND_MISMATCH";
  exports[1320] = "ER_SP_NORETURN";
  exports[1321] = "ER_SP_NORETURNEND";
  exports[1322] = "ER_SP_BAD_CURSOR_QUERY";
  exports[1323] = "ER_SP_BAD_CURSOR_SELECT";
  exports[1324] = "ER_SP_CURSOR_MISMATCH";
  exports[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
  exports[1326] = "ER_SP_CURSOR_NOT_OPEN";
  exports[1327] = "ER_SP_UNDECLARED_VAR";
  exports[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
  exports[1329] = "ER_SP_FETCH_NO_DATA";
  exports[1330] = "ER_SP_DUP_PARAM";
  exports[1331] = "ER_SP_DUP_VAR";
  exports[1332] = "ER_SP_DUP_COND";
  exports[1333] = "ER_SP_DUP_CURS";
  exports[1334] = "ER_SP_CANT_ALTER";
  exports[1335] = "ER_SP_SUBSELECT_NYI";
  exports[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
  exports[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
  exports[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
  exports[1339] = "ER_SP_CASE_NOT_FOUND";
  exports[1340] = "ER_FPARSER_TOO_BIG_FILE";
  exports[1341] = "ER_FPARSER_BAD_HEADER";
  exports[1342] = "ER_FPARSER_EOF_IN_COMMENT";
  exports[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
  exports[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
  exports[1345] = "ER_VIEW_NO_EXPLAIN";
  exports[1346] = "ER_FRM_UNKNOWN_TYPE";
  exports[1347] = "ER_WRONG_OBJECT";
  exports[1348] = "ER_NONUPDATEABLE_COLUMN";
  exports[1349] = "ER_VIEW_SELECT_DERIVED";
  exports[1350] = "ER_VIEW_SELECT_CLAUSE";
  exports[1351] = "ER_VIEW_SELECT_VARIABLE";
  exports[1352] = "ER_VIEW_SELECT_TMPTABLE";
  exports[1353] = "ER_VIEW_WRONG_LIST";
  exports[1354] = "ER_WARN_VIEW_MERGE";
  exports[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
  exports[1356] = "ER_VIEW_INVALID";
  exports[1357] = "ER_SP_NO_DROP_SP";
  exports[1358] = "ER_SP_GOTO_IN_HNDLR";
  exports[1359] = "ER_TRG_ALREADY_EXISTS";
  exports[1360] = "ER_TRG_DOES_NOT_EXIST";
  exports[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
  exports[1362] = "ER_TRG_CANT_CHANGE_ROW";
  exports[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
  exports[1364] = "ER_NO_DEFAULT_FOR_FIELD";
  exports[1365] = "ER_DIVISION_BY_ZERO";
  exports[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
  exports[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
  exports[1368] = "ER_VIEW_NONUPD_CHECK";
  exports[1369] = "ER_VIEW_CHECK_FAILED";
  exports[1370] = "ER_PROCACCESS_DENIED_ERROR";
  exports[1371] = "ER_RELAY_LOG_FAIL";
  exports[1372] = "ER_PASSWD_LENGTH";
  exports[1373] = "ER_UNKNOWN_TARGET_BINLOG";
  exports[1374] = "ER_IO_ERR_LOG_INDEX_READ";
  exports[1375] = "ER_BINLOG_PURGE_PROHIBITED";
  exports[1376] = "ER_FSEEK_FAIL";
  exports[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
  exports[1378] = "ER_LOG_IN_USE";
  exports[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
  exports[1380] = "ER_RELAY_LOG_INIT";
  exports[1381] = "ER_NO_BINARY_LOGGING";
  exports[1382] = "ER_RESERVED_SYNTAX";
  exports[1383] = "ER_WSAS_FAILED";
  exports[1384] = "ER_DIFF_GROUPS_PROC";
  exports[1385] = "ER_NO_GROUP_FOR_PROC";
  exports[1386] = "ER_ORDER_WITH_PROC";
  exports[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
  exports[1388] = "ER_NO_FILE_MAPPING";
  exports[1389] = "ER_WRONG_MAGIC";
  exports[1390] = "ER_PS_MANY_PARAM";
  exports[1391] = "ER_KEY_PART_0";
  exports[1392] = "ER_VIEW_CHECKSUM";
  exports[1393] = "ER_VIEW_MULTIUPDATE";
  exports[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
  exports[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
  exports[1396] = "ER_CANNOT_USER";
  exports[1397] = "ER_XAER_NOTA";
  exports[1398] = "ER_XAER_INVAL";
  exports[1399] = "ER_XAER_RMFAIL";
  exports[1400] = "ER_XAER_OUTSIDE";
  exports[1401] = "ER_XAER_RMERR";
  exports[1402] = "ER_XA_RBROLLBACK";
  exports[1403] = "ER_NONEXISTING_PROC_GRANT";
  exports[1404] = "ER_PROC_AUTO_GRANT_FAIL";
  exports[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
  exports[1406] = "ER_DATA_TOO_LONG";
  exports[1407] = "ER_SP_BAD_SQLSTATE";
  exports[1408] = "ER_STARTUP";
  exports[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
  exports[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
  exports[1411] = "ER_WRONG_VALUE_FOR_TYPE";
  exports[1412] = "ER_TABLE_DEF_CHANGED";
  exports[1413] = "ER_SP_DUP_HANDLER";
  exports[1414] = "ER_SP_NOT_VAR_ARG";
  exports[1415] = "ER_SP_NO_RETSET";
  exports[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
  exports[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
  exports[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
  exports[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
  exports[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
  exports[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
  exports[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
  exports[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
  exports[1424] = "ER_SP_NO_RECURSION";
  exports[1425] = "ER_TOO_BIG_SCALE";
  exports[1426] = "ER_TOO_BIG_PRECISION";
  exports[1427] = "ER_M_BIGGER_THAN_D";
  exports[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
  exports[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
  exports[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
  exports[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
  exports[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
  exports[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
  exports[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
  exports[1435] = "ER_TRG_IN_WRONG_SCHEMA";
  exports[1436] = "ER_STACK_OVERRUN_NEED_MORE";
  exports[1437] = "ER_TOO_LONG_BODY";
  exports[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
  exports[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
  exports[1440] = "ER_XAER_DUPID";
  exports[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
  exports[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
  exports[1443] = "ER_VIEW_PREVENT_UPDATE";
  exports[1444] = "ER_PS_NO_RECURSION";
  exports[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
  exports[1446] = "ER_MALFORMED_DEFINER";
  exports[1447] = "ER_VIEW_FRM_NO_USER";
  exports[1448] = "ER_VIEW_OTHER_USER";
  exports[1449] = "ER_NO_SUCH_USER";
  exports[1450] = "ER_FORBID_SCHEMA_CHANGE";
  exports[1451] = "ER_ROW_IS_REFERENCED_2";
  exports[1452] = "ER_NO_REFERENCED_ROW_2";
  exports[1453] = "ER_SP_BAD_VAR_SHADOW";
  exports[1454] = "ER_TRG_NO_DEFINER";
  exports[1455] = "ER_OLD_FILE_FORMAT";
  exports[1456] = "ER_SP_RECURSION_LIMIT";
  exports[1457] = "ER_SP_PROC_TABLE_CORRUPT";
  exports[1458] = "ER_SP_WRONG_NAME";
  exports[1459] = "ER_TABLE_NEEDS_UPGRADE";
  exports[1460] = "ER_SP_NO_AGGREGATE";
  exports[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
  exports[1462] = "ER_VIEW_RECURSIVE";
  exports[1463] = "ER_NON_GROUPING_FIELD_USED";
  exports[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
  exports[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
  exports[1466] = "ER_REMOVED_SPACES";
  exports[1467] = "ER_AUTOINC_READ_FAILED";
  exports[1468] = "ER_USERNAME";
  exports[1469] = "ER_HOSTNAME";
  exports[1470] = "ER_WRONG_STRING_LENGTH";
  exports[1471] = "ER_NON_INSERTABLE_TABLE";
  exports[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
  exports[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
  exports[1474] = "ER_NAME_BECOMES_EMPTY";
  exports[1475] = "ER_AMBIGUOUS_FIELD_TERM";
  exports[1476] = "ER_FOREIGN_SERVER_EXISTS";
  exports[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
  exports[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
  exports[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
  exports[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
  exports[1481] = "ER_PARTITION_MAXVALUE_ERROR";
  exports[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
  exports[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
  exports[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
  exports[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
  exports[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
  exports[1487] = "ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR";
  exports[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
  exports[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
  exports[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
  exports[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
  exports[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
  exports[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
  exports[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
  exports[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
  exports[1496] = "ER_PARTITION_ENTRY_ERROR";
  exports[1497] = "ER_MIX_HANDLER_ERROR";
  exports[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
  exports[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
  exports[1500] = "ER_SUBPARTITION_ERROR";
  exports[1501] = "ER_CANT_CREATE_HANDLER_FILE";
  exports[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
  exports[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
  exports[1504] = "ER_NO_PARTS_ERROR";
  exports[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
  exports[1506] = "ER_FOREIGN_KEY_ON_PARTITIONED";
  exports[1507] = "ER_DROP_PARTITION_NON_EXISTENT";
  exports[1508] = "ER_DROP_LAST_PARTITION";
  exports[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
  exports[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
  exports[1511] = "ER_REORG_NO_PARAM_ERROR";
  exports[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
  exports[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
  exports[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
  exports[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
  exports[1516] = "ER_REORG_PARTITION_NOT_EXIST";
  exports[1517] = "ER_SAME_NAME_PARTITION";
  exports[1518] = "ER_NO_BINLOG_ERROR";
  exports[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
  exports[1520] = "ER_REORG_OUTSIDE_RANGE";
  exports[1521] = "ER_PARTITION_FUNCTION_FAILURE";
  exports[1522] = "ER_PART_STATE_ERROR";
  exports[1523] = "ER_LIMITED_PART_RANGE";
  exports[1524] = "ER_PLUGIN_IS_NOT_LOADED";
  exports[1525] = "ER_WRONG_VALUE";
  exports[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
  exports[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
  exports[1528] = "ER_CREATE_FILEGROUP_FAILED";
  exports[1529] = "ER_DROP_FILEGROUP_FAILED";
  exports[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
  exports[1531] = "ER_WRONG_SIZE_NUMBER";
  exports[1532] = "ER_SIZE_OVERFLOW_ERROR";
  exports[1533] = "ER_ALTER_FILEGROUP_FAILED";
  exports[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
  exports[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
  exports[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
  exports[1537] = "ER_EVENT_ALREADY_EXISTS";
  exports[1538] = "ER_EVENT_STORE_FAILED";
  exports[1539] = "ER_EVENT_DOES_NOT_EXIST";
  exports[1540] = "ER_EVENT_CANT_ALTER";
  exports[1541] = "ER_EVENT_DROP_FAILED";
  exports[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
  exports[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
  exports[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
  exports[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
  exports[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
  exports[1547] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED";
  exports[1548] = "ER_CANNOT_LOAD_FROM_TABLE";
  exports[1549] = "ER_EVENT_CANNOT_DELETE";
  exports[1550] = "ER_EVENT_COMPILE_ERROR";
  exports[1551] = "ER_EVENT_SAME_NAME";
  exports[1552] = "ER_EVENT_DATA_TOO_LONG";
  exports[1553] = "ER_DROP_INDEX_FK";
  exports[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
  exports[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
  exports[1556] = "ER_CANT_LOCK_LOG_TABLE";
  exports[1557] = "ER_FOREIGN_DUPLICATE_KEY";
  exports[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
  exports[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
  exports[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
  exports[1561] = "ER_NDB_CANT_SWITCH_BINLOG_FORMAT";
  exports[1562] = "ER_PARTITION_NO_TEMPORARY";
  exports[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
  exports[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
  exports[1565] = "ER_DDL_LOG_ERROR";
  exports[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
  exports[1567] = "ER_WRONG_PARTITION_NAME";
  exports[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
  exports[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
  exports[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
  exports[1571] = "ER_EVENT_SET_VAR_ERROR";
  exports[1572] = "ER_PARTITION_MERGE_ERROR";
  exports[1573] = "ER_CANT_ACTIVATE_LOG";
  exports[1574] = "ER_RBR_NOT_AVAILABLE";
  exports[1575] = "ER_BASE64_DECODE_ERROR";
  exports[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
  exports[1577] = "ER_EVENTS_DB_ERROR";
  exports[1578] = "ER_ONLY_INTEGERS_ALLOWED";
  exports[1579] = "ER_UNSUPORTED_LOG_ENGINE";
  exports[1580] = "ER_BAD_LOG_STATEMENT";
  exports[1581] = "ER_CANT_RENAME_LOG_TABLE";
  exports[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
  exports[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
  exports[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
  exports[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
  exports[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
  exports[1587] = "ER_BINLOG_PURGE_EMFILE";
  exports[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
  exports[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
  exports[1590] = "ER_SLAVE_INCIDENT";
  exports[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
  exports[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
  exports[1593] = "ER_BINLOG_FATAL_ERROR";
  exports[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
  exports[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
  exports[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
  exports[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
  exports[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
  exports[1599] = "ER_VIEW_NO_CREATION_CTX";
  exports[1600] = "ER_VIEW_INVALID_CREATION_CTX";
  exports[1601] = "ER_SR_INVALID_CREATION_CTX";
  exports[1602] = "ER_TRG_CORRUPTED_FILE";
  exports[1603] = "ER_TRG_NO_CREATION_CTX";
  exports[1604] = "ER_TRG_INVALID_CREATION_CTX";
  exports[1605] = "ER_EVENT_INVALID_CREATION_CTX";
  exports[1606] = "ER_TRG_CANT_OPEN_TABLE";
  exports[1607] = "ER_CANT_CREATE_SROUTINE";
  exports[1608] = "ER_NEVER_USED";
  exports[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
  exports[1610] = "ER_REPLICA_CORRUPT_EVENT";
  exports[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
  exports[1612] = "ER_LOG_PURGE_NO_FILE";
  exports[1613] = "ER_XA_RBTIMEOUT";
  exports[1614] = "ER_XA_RBDEADLOCK";
  exports[1615] = "ER_NEED_REPREPARE";
  exports[1616] = "ER_DELAYED_NOT_SUPPORTED";
  exports[1617] = "WARN_NO_CONNECTION_METADATA";
  exports[1618] = "WARN_OPTION_IGNORED";
  exports[1619] = "ER_PLUGIN_DELETE_BUILTIN";
  exports[1620] = "WARN_PLUGIN_BUSY";
  exports[1621] = "ER_VARIABLE_IS_READONLY";
  exports[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
  exports[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
  exports[1624] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE";
  exports[1625] = "ER_NDB_REPLICATION_SCHEMA_ERROR";
  exports[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
  exports[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
  exports[1628] = "ER_TOO_LONG_TABLE_COMMENT";
  exports[1629] = "ER_TOO_LONG_FIELD_COMMENT";
  exports[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
  exports[1631] = "ER_DATABASE_NAME";
  exports[1632] = "ER_TABLE_NAME";
  exports[1633] = "ER_PARTITION_NAME";
  exports[1634] = "ER_SUBPARTITION_NAME";
  exports[1635] = "ER_TEMPORARY_NAME";
  exports[1636] = "ER_RENAMED_NAME";
  exports[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
  exports[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
  exports[1639] = "ER_DEBUG_SYNC_TIMEOUT";
  exports[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
  exports[1641] = "ER_DUP_SIGNAL_SET";
  exports[1642] = "ER_SIGNAL_WARN";
  exports[1643] = "ER_SIGNAL_NOT_FOUND";
  exports[1644] = "ER_SIGNAL_EXCEPTION";
  exports[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
  exports[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
  exports[1647] = "WARN_COND_ITEM_TRUNCATED";
  exports[1648] = "ER_COND_ITEM_TOO_LONG";
  exports[1649] = "ER_UNKNOWN_LOCALE";
  exports[1650] = "ER_REPLICA_IGNORE_SERVER_IDS";
  exports[1651] = "ER_QUERY_CACHE_DISABLED";
  exports[1652] = "ER_SAME_NAME_PARTITION_FIELD";
  exports[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
  exports[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
  exports[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
  exports[1656] = "ER_MAXVALUE_IN_VALUES_IN";
  exports[1657] = "ER_TOO_MANY_VALUES_ERROR";
  exports[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
  exports[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
  exports[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
  exports[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
  exports[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
  exports[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
  exports[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
  exports[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
  exports[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
  exports[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
  exports[1668] = "ER_BINLOG_UNSAFE_LIMIT";
  exports[1669] = "ER_UNUSED4";
  exports[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
  exports[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
  exports[1672] = "ER_BINLOG_UNSAFE_UDF";
  exports[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
  exports[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
  exports[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
  exports[1676] = "ER_MESSAGE_AND_STATEMENT";
  exports[1677] = "ER_SLAVE_CONVERSION_FAILED";
  exports[1678] = "ER_REPLICA_CANT_CREATE_CONVERSION";
  exports[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
  exports[1680] = "ER_PATH_LENGTH";
  exports[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
  exports[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
  exports[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
  exports[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
  exports[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
  exports[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
  exports[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
  exports[1688] = "ER_TOO_LONG_INDEX_COMMENT";
  exports[1689] = "ER_LOCK_ABORTED";
  exports[1690] = "ER_DATA_OUT_OF_RANGE";
  exports[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
  exports[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
  exports[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
  exports[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
  exports[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
  exports[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
  exports[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
  exports[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
  exports[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
  exports[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
  exports[1701] = "ER_TRUNCATE_ILLEGAL_FK";
  exports[1702] = "ER_PLUGIN_IS_PERMANENT";
  exports[1703] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
  exports[1704] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
  exports[1705] = "ER_STMT_CACHE_FULL";
  exports[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
  exports[1707] = "ER_TABLE_NEEDS_REBUILD";
  exports[1708] = "WARN_OPTION_BELOW_LIMIT";
  exports[1709] = "ER_INDEX_COLUMN_TOO_LONG";
  exports[1710] = "ER_ERROR_IN_TRIGGER_BODY";
  exports[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
  exports[1712] = "ER_INDEX_CORRUPT";
  exports[1713] = "ER_UNDO_RECORD_TOO_BIG";
  exports[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
  exports[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
  exports[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
  exports[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
  exports[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
  exports[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
  exports[1720] = "ER_PLUGIN_NO_UNINSTALL";
  exports[1721] = "ER_PLUGIN_NO_INSTALL";
  exports[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
  exports[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
  exports[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
  exports[1725] = "ER_TABLE_IN_FK_CHECK";
  exports[1726] = "ER_UNSUPPORTED_ENGINE";
  exports[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
  exports[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
  exports[1729] = "ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE";
  exports[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
  exports[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
  exports[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
  exports[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
  exports[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
  exports[1735] = "ER_UNKNOWN_PARTITION";
  exports[1736] = "ER_TABLES_DIFFERENT_METADATA";
  exports[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
  exports[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
  exports[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
  exports[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
  exports[1741] = "ER_NO_SUCH_KEY_VALUE";
  exports[1742] = "ER_RPL_INFO_DATA_TOO_LONG";
  exports[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
  exports[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
  exports[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
  exports[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
  exports[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
  exports[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
  exports[1749] = "ER_NO_SUCH_PARTITION";
  exports[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
  exports[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
  exports[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
  exports[1753] = "ER_MTA_FEATURE_IS_NOT_SUPPORTED";
  exports[1754] = "ER_MTA_UPDATED_DBS_GREATER_MAX";
  exports[1755] = "ER_MTA_CANT_PARALLEL";
  exports[1756] = "ER_MTA_INCONSISTENT_DATA";
  exports[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
  exports[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
  exports[1759] = "ER_INSECURE_PLAIN_TEXT";
  exports[1760] = "ER_INSECURE_CHANGE_SOURCE";
  exports[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
  exports[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
  exports[1763] = "ER_SQLTHREAD_WITH_SECURE_REPLICA";
  exports[1764] = "ER_TABLE_HAS_NO_FT";
  exports[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
  exports[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
  exports[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
  exports[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION";
  exports[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
  exports[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
  exports[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
  exports[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
  exports[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
  exports[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
  exports[1775] = "ER_GNO_EXHAUSTED";
  exports[1776] = "ER_BAD_REPLICA_AUTO_POSITION";
  exports[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF";
  exports[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
  exports[1779] = "ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
  exports[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
  exports[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
  exports[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
  exports[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
  exports[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
  exports[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
  exports[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
  exports[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION";
  exports[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
  exports[1789] = "ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS";
  exports[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
  exports[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
  exports[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
  exports[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
  exports[1794] = "ER_REPLICA_CONFIGURATION";
  exports[1795] = "ER_INNODB_FT_LIMIT";
  exports[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
  exports[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
  exports[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
  exports[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
  exports[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
  exports[1801] = "ER_UNKNOWN_ALTER_LOCK";
  exports[1802] = "ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS";
  exports[1803] = "ER_MTA_RECOVERY_FAILURE";
  exports[1804] = "ER_MTA_RESET_WORKERS";
  exports[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
  exports[1806] = "ER_REPLICA_SILENT_RETRY_TRANSACTION";
  exports[1807] = "ER_DISCARD_FK_CHECKS_RUNNING";
  exports[1808] = "ER_TABLE_SCHEMA_MISMATCH";
  exports[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
  exports[1810] = "ER_IO_READ_ERROR";
  exports[1811] = "ER_IO_WRITE_ERROR";
  exports[1812] = "ER_TABLESPACE_MISSING";
  exports[1813] = "ER_TABLESPACE_EXISTS";
  exports[1814] = "ER_TABLESPACE_DISCARDED";
  exports[1815] = "ER_INTERNAL_ERROR";
  exports[1816] = "ER_INNODB_IMPORT_ERROR";
  exports[1817] = "ER_INNODB_INDEX_CORRUPT";
  exports[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
  exports[1819] = "ER_NOT_VALID_PASSWORD";
  exports[1820] = "ER_MUST_CHANGE_PASSWORD";
  exports[1821] = "ER_FK_NO_INDEX_CHILD";
  exports[1822] = "ER_FK_NO_INDEX_PARENT";
  exports[1823] = "ER_FK_FAIL_ADD_SYSTEM";
  exports[1824] = "ER_FK_CANNOT_OPEN_PARENT";
  exports[1825] = "ER_FK_INCORRECT_OPTION";
  exports[1826] = "ER_FK_DUP_NAME";
  exports[1827] = "ER_PASSWORD_FORMAT";
  exports[1828] = "ER_FK_COLUMN_CANNOT_DROP";
  exports[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
  exports[1830] = "ER_FK_COLUMN_NOT_NULL";
  exports[1831] = "ER_DUP_INDEX";
  exports[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
  exports[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
  exports[1834] = "ER_UNUSED5";
  exports[1835] = "ER_MALFORMED_PACKET";
  exports[1836] = "ER_READ_ONLY_MODE";
  exports[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GTID";
  exports[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
  exports[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
  exports[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
  exports[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
  exports[1842] = "ER_GTID_PURGED_WAS_CHANGED";
  exports[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
  exports[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
  exports[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
  exports[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
  exports[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
  exports[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
  exports[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
  exports[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
  exports[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
  exports[1852] = "ER_UNUSED6";
  exports[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
  exports[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
  exports[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
  exports[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
  exports[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
  exports[1858] = "ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
  exports[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
  exports[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
  exports[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
  exports[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
  exports[1863] = "ER_ROW_IN_WRONG_PARTITION";
  exports[1864] = "ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
  exports[1865] = "ER_INNODB_NO_FT_USES_PARSER";
  exports[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
  exports[1867] = "ER_WARN_PURGE_LOG_IN_USE";
  exports[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
  exports[1869] = "ER_AUTO_INCREMENT_CONFLICT";
  exports[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
  exports[1871] = "ER_REPLICA_CM_INIT_REPOSITORY";
  exports[1872] = "ER_REPLICA_AM_INIT_REPOSITORY";
  exports[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
  exports[1874] = "ER_INNODB_READ_ONLY";
  exports[1875] = "ER_STOP_REPLICA_SQL_THREAD_TIMEOUT";
  exports[1876] = "ER_STOP_REPLICA_IO_THREAD_TIMEOUT";
  exports[1877] = "ER_TABLE_CORRUPT";
  exports[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
  exports[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
  exports[1880] = "ER_OLD_TEMPORALS_UPGRADED";
  exports[1881] = "ER_INNODB_FORCED_RECOVERY";
  exports[1882] = "ER_AES_INVALID_IV";
  exports[1883] = "ER_PLUGIN_CANNOT_BE_UNINSTALLED";
  exports[1884] = "ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID";
  exports[1885] = "ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE";
  exports[1886] = "ER_MISSING_KEY";
  exports[1887] = "WARN_NAMED_PIPE_ACCESS_EVERYONE";
  exports[3000] = "ER_FILE_CORRUPT";
  exports[3001] = "ER_ERROR_ON_SOURCE";
  exports[3002] = "ER_INCONSISTENT_ERROR";
  exports[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
  exports[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
  exports[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
  exports[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
  exports[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
  exports[3008] = "ER_FK_DEPTH_EXCEEDED";
  exports[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
  exports[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
  exports[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
  exports[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
  exports[3013] = "ER_INVALID_FIELD_SIZE";
  exports[3014] = "ER_MISSING_HA_CREATE_OPTION";
  exports[3015] = "ER_ENGINE_OUT_OF_MEMORY";
  exports[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
  exports[3017] = "ER_REPLICA_SQL_THREAD_MUST_STOP";
  exports[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
  exports[3019] = "ER_INNODB_UNDO_LOG_FULL";
  exports[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
  exports[3021] = "ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP";
  exports[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
  exports[3023] = "ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS";
  exports[3024] = "ER_QUERY_TIMEOUT";
  exports[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
  exports[3026] = "ER_DUP_LIST_ENTRY";
  exports[3027] = "ER_SQL_MODE_NO_EFFECT";
  exports[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
  exports[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
  exports[3030] = "ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR";
  exports[3031] = "ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER";
  exports[3032] = "ER_SERVER_OFFLINE_MODE";
  exports[3033] = "ER_GIS_DIFFERENT_SRIDS";
  exports[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
  exports[3035] = "ER_GIS_UNKNOWN_ERROR";
  exports[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
  exports[3037] = "ER_GIS_INVALID_DATA";
  exports[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
  exports[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
  exports[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
  exports[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
  exports[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
  exports[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
  exports[3044] = "ER_STD_BAD_ALLOC_ERROR";
  exports[3045] = "ER_STD_DOMAIN_ERROR";
  exports[3046] = "ER_STD_LENGTH_ERROR";
  exports[3047] = "ER_STD_INVALID_ARGUMENT";
  exports[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
  exports[3049] = "ER_STD_OVERFLOW_ERROR";
  exports[3050] = "ER_STD_RANGE_ERROR";
  exports[3051] = "ER_STD_UNDERFLOW_ERROR";
  exports[3052] = "ER_STD_LOGIC_ERROR";
  exports[3053] = "ER_STD_RUNTIME_ERROR";
  exports[3054] = "ER_STD_UNKNOWN_EXCEPTION";
  exports[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
  exports[3056] = "ER_CHANGE_SOURCE_PASSWORD_LENGTH";
  exports[3057] = "ER_USER_LOCK_WRONG_NAME";
  exports[3058] = "ER_USER_LOCK_DEADLOCK";
  exports[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
  exports[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
  exports[3061] = "ER_ILLEGAL_USER_VAR";
  exports[3062] = "ER_GTID_MODE_OFF";
  exports[3063] = "ER_UNSUPPORTED_BY_REPLICATION_THREAD";
  exports[3064] = "ER_INCORRECT_TYPE";
  exports[3065] = "ER_FIELD_IN_ORDER_NOT_SELECT";
  exports[3066] = "ER_AGGREGATE_IN_ORDER_NOT_SELECT";
  exports[3067] = "ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN";
  exports[3068] = "ER_NET_OK_PACKET_TOO_LARGE";
  exports[3069] = "ER_INVALID_JSON_DATA";
  exports[3070] = "ER_INVALID_GEOJSON_MISSING_MEMBER";
  exports[3071] = "ER_INVALID_GEOJSON_WRONG_TYPE";
  exports[3072] = "ER_INVALID_GEOJSON_UNSPECIFIED";
  exports[3073] = "ER_DIMENSION_UNSUPPORTED";
  exports[3074] = "ER_REPLICA_CHANNEL_DOES_NOT_EXIST";
  exports[3075] = "ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT";
  exports[3076] = "ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG";
  exports[3077] = "ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY";
  exports[3078] = "ER_SLAVE_CHANNEL_DELETE";
  exports[3079] = "ER_REPLICA_MULTIPLE_CHANNELS_CMD";
  exports[3080] = "ER_REPLICA_MAX_CHANNELS_EXCEEDED";
  exports[3081] = "ER_REPLICA_CHANNEL_MUST_STOP";
  exports[3082] = "ER_REPLICA_CHANNEL_NOT_RUNNING";
  exports[3083] = "ER_REPLICA_CHANNEL_WAS_RUNNING";
  exports[3084] = "ER_REPLICA_CHANNEL_WAS_NOT_RUNNING";
  exports[3085] = "ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP";
  exports[3086] = "ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER";
  exports[3087] = "ER_WRONG_FIELD_WITH_GROUP_V2";
  exports[3088] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2";
  exports[3089] = "ER_WARN_DEPRECATED_SYSVAR_UPDATE";
  exports[3090] = "ER_WARN_DEPRECATED_SQLMODE";
  exports[3091] = "ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID";
  exports[3092] = "ER_GROUP_REPLICATION_CONFIGURATION";
  exports[3093] = "ER_GROUP_REPLICATION_RUNNING";
  exports[3094] = "ER_GROUP_REPLICATION_APPLIER_INIT_ERROR";
  exports[3095] = "ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT";
  exports[3096] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR";
  exports[3097] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR";
  exports[3098] = "ER_BEFORE_DML_VALIDATION_ERROR";
  exports[3099] = "ER_PREVENTS_VARIABLE_WITHOUT_RBR";
  exports[3100] = "ER_RUN_HOOK_ERROR";
  exports[3101] = "ER_TRANSACTION_ROLLBACK_DURING_COMMIT";
  exports[3102] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
  exports[3103] = "ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN";
  exports[3104] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
  exports[3105] = "ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
  exports[3106] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
  exports[3107] = "ER_GENERATED_COLUMN_NON_PRIOR";
  exports[3108] = "ER_DEPENDENT_BY_GENERATED_COLUMN";
  exports[3109] = "ER_GENERATED_COLUMN_REF_AUTO_INC";
  exports[3110] = "ER_FEATURE_NOT_AVAILABLE";
  exports[3111] = "ER_CANT_SET_GTID_MODE";
  exports[3112] = "ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF";
  exports[3113] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION";
  exports[3114] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON";
  exports[3115] = "ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF";
  exports[3116] = "ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX";
  exports[3117] = "ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX";
  exports[3118] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
  exports[3119] = "ER_WRONG_TABLESPACE_NAME";
  exports[3120] = "ER_TABLESPACE_IS_NOT_EMPTY";
  exports[3121] = "ER_WRONG_FILE_NAME";
  exports[3122] = "ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION";
  exports[3123] = "ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR";
  exports[3124] = "ER_WARN_BAD_MAX_EXECUTION_TIME";
  exports[3125] = "ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME";
  exports[3126] = "ER_WARN_CONFLICTING_HINT";
  exports[3127] = "ER_WARN_UNKNOWN_QB_NAME";
  exports[3128] = "ER_UNRESOLVED_HINT_NAME";
  exports[3129] = "ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE";
  exports[3130] = "ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED";
  exports[3131] = "ER_LOCKING_SERVICE_WRONG_NAME";
  exports[3132] = "ER_LOCKING_SERVICE_DEADLOCK";
  exports[3133] = "ER_LOCKING_SERVICE_TIMEOUT";
  exports[3134] = "ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED";
  exports[3135] = "ER_SQL_MODE_MERGED";
  exports[3136] = "ER_VTOKEN_PLUGIN_TOKEN_MISMATCH";
  exports[3137] = "ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND";
  exports[3138] = "ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID";
  exports[3139] = "ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED";
  exports[3140] = "ER_INVALID_JSON_TEXT";
  exports[3141] = "ER_INVALID_JSON_TEXT_IN_PARAM";
  exports[3142] = "ER_INVALID_JSON_BINARY_DATA";
  exports[3143] = "ER_INVALID_JSON_PATH";
  exports[3144] = "ER_INVALID_JSON_CHARSET";
  exports[3145] = "ER_INVALID_JSON_CHARSET_IN_FUNCTION";
  exports[3146] = "ER_INVALID_TYPE_FOR_JSON";
  exports[3147] = "ER_INVALID_CAST_TO_JSON";
  exports[3148] = "ER_INVALID_JSON_PATH_CHARSET";
  exports[3149] = "ER_INVALID_JSON_PATH_WILDCARD";
  exports[3150] = "ER_JSON_VALUE_TOO_BIG";
  exports[3151] = "ER_JSON_KEY_TOO_BIG";
  exports[3152] = "ER_JSON_USED_AS_KEY";
  exports[3153] = "ER_JSON_VACUOUS_PATH";
  exports[3154] = "ER_JSON_BAD_ONE_OR_ALL_ARG";
  exports[3155] = "ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE";
  exports[3156] = "ER_INVALID_JSON_VALUE_FOR_CAST";
  exports[3157] = "ER_JSON_DOCUMENT_TOO_DEEP";
  exports[3158] = "ER_JSON_DOCUMENT_NULL_KEY";
  exports[3159] = "ER_SECURE_TRANSPORT_REQUIRED";
  exports[3160] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
  exports[3161] = "ER_DISABLED_STORAGE_ENGINE";
  exports[3162] = "ER_USER_DOES_NOT_EXIST";
  exports[3163] = "ER_USER_ALREADY_EXISTS";
  exports[3164] = "ER_AUDIT_API_ABORT";
  exports[3165] = "ER_INVALID_JSON_PATH_ARRAY_CELL";
  exports[3166] = "ER_BUFPOOL_RESIZE_INPROGRESS";
  exports[3167] = "ER_FEATURE_DISABLED_SEE_DOC";
  exports[3168] = "ER_SERVER_ISNT_AVAILABLE";
  exports[3169] = "ER_SESSION_WAS_KILLED";
  exports[3170] = "ER_CAPACITY_EXCEEDED";
  exports[3171] = "ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER";
  exports[3172] = "ER_TABLE_NEEDS_UPG_PART";
  exports[3173] = "ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID";
  exports[3174] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL";
  exports[3175] = "ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT";
  exports[3176] = "ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE";
  exports[3177] = "ER_LOCK_REFUSED_BY_ENGINE";
  exports[3178] = "ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN";
  exports[3179] = "ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE";
  exports[3180] = "ER_MASTER_KEY_ROTATION_ERROR_BY_SE";
  exports[3181] = "ER_MASTER_KEY_ROTATION_BINLOG_FAILED";
  exports[3182] = "ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE";
  exports[3183] = "ER_TABLESPACE_CANNOT_ENCRYPT";
  exports[3184] = "ER_INVALID_ENCRYPTION_OPTION";
  exports[3185] = "ER_CANNOT_FIND_KEY_IN_KEYRING";
  exports[3186] = "ER_CAPACITY_EXCEEDED_IN_PARSER";
  exports[3187] = "ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE";
  exports[3188] = "ER_KEYRING_UDF_KEYRING_SERVICE_ERROR";
  exports[3189] = "ER_USER_COLUMN_OLD_LENGTH";
  exports[3190] = "ER_CANT_RESET_SOURCE";
  exports[3191] = "ER_GROUP_REPLICATION_MAX_GROUP_SIZE";
  exports[3192] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED";
  exports[3193] = "ER_TABLE_REFERENCED";
  exports[3194] = "ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE";
  exports[3195] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO";
  exports[3196] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID";
  exports[3197] = "ER_XA_RETRY";
  exports[3198] = "ER_KEYRING_AWS_UDF_AWS_KMS_ERROR";
  exports[3199] = "ER_BINLOG_UNSAFE_XA";
  exports[3200] = "ER_UDF_ERROR";
  exports[3201] = "ER_KEYRING_MIGRATION_FAILURE";
  exports[3202] = "ER_KEYRING_ACCESS_DENIED_ERROR";
  exports[3203] = "ER_KEYRING_MIGRATION_STATUS";
  exports[3204] = "ER_PLUGIN_FAILED_TO_OPEN_TABLES";
  exports[3205] = "ER_PLUGIN_FAILED_TO_OPEN_TABLE";
  exports[3206] = "ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED";
  exports[3207] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET";
  exports[3208] = "ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY";
  exports[3209] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED";
  exports[3210] = "ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED";
  exports[3211] = "ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE";
  exports[3212] = "ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED";
  exports[3213] = "ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS";
  exports[3214] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE";
  exports[3215] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT";
  exports[3216] = "ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED";
  exports[3217] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE";
  exports[3218] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE";
  exports[3219] = "ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR";
  exports[3220] = "ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY";
  exports[3221] = "ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY";
  exports[3222] = "ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS";
  exports[3223] = "ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC";
  exports[3224] = "ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER";
  exports[3225] = "ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER";
  exports[3226] = "WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP";
  exports[3227] = "ER_XA_REPLICATION_FILTERS";
  exports[3228] = "ER_CANT_OPEN_ERROR_LOG";
  exports[3229] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
  exports[3230] = "ER_CANT_START_SERVER_NAMED_PIPE";
  exports[3231] = "ER_WRITE_SET_EXCEEDS_LIMIT";
  exports[3232] = "ER_DEPRECATED_TLS_VERSION_SESSION_57";
  exports[3233] = "ER_WARN_DEPRECATED_TLS_VERSION_57";
  exports[3234] = "ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE";
  exports[3235] = "ER_AES_INVALID_KDF_NAME";
  exports[3236] = "ER_AES_INVALID_KDF_ITERATIONS";
  exports[3237] = "WARN_AES_KEY_SIZE";
  exports[3238] = "ER_AES_INVALID_KDF_OPTION_SIZE";
  exports[3500] = "ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE";
  exports[3501] = "ER_ACL_OPERATION_FAILED";
  exports[3502] = "ER_UNSUPPORTED_INDEX_ALGORITHM";
  exports[3503] = "ER_NO_SUCH_DB";
  exports[3504] = "ER_TOO_BIG_ENUM";
  exports[3505] = "ER_TOO_LONG_SET_ENUM_VALUE";
  exports[3506] = "ER_INVALID_DD_OBJECT";
  exports[3507] = "ER_UPDATING_DD_TABLE";
  exports[3508] = "ER_INVALID_DD_OBJECT_ID";
  exports[3509] = "ER_INVALID_DD_OBJECT_NAME";
  exports[3510] = "ER_TABLESPACE_MISSING_WITH_NAME";
  exports[3511] = "ER_TOO_LONG_ROUTINE_COMMENT";
  exports[3512] = "ER_SP_LOAD_FAILED";
  exports[3513] = "ER_INVALID_BITWISE_OPERANDS_SIZE";
  exports[3514] = "ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE";
  exports[3515] = "ER_WARN_UNSUPPORTED_HINT";
  exports[3516] = "ER_UNEXPECTED_GEOMETRY_TYPE";
  exports[3517] = "ER_SRS_PARSE_ERROR";
  exports[3518] = "ER_SRS_PROJ_PARAMETER_MISSING";
  exports[3519] = "ER_WARN_SRS_NOT_FOUND";
  exports[3520] = "ER_SRS_NOT_CARTESIAN";
  exports[3521] = "ER_SRS_NOT_CARTESIAN_UNDEFINED";
  exports[3522] = "ER_PK_INDEX_CANT_BE_INVISIBLE";
  exports[3523] = "ER_UNKNOWN_AUTHID";
  exports[3524] = "ER_FAILED_ROLE_GRANT";
  exports[3525] = "ER_OPEN_ROLE_TABLES";
  exports[3526] = "ER_FAILED_DEFAULT_ROLES";
  exports[3527] = "ER_COMPONENTS_NO_SCHEME";
  exports[3528] = "ER_COMPONENTS_NO_SCHEME_SERVICE";
  exports[3529] = "ER_COMPONENTS_CANT_LOAD";
  exports[3530] = "ER_ROLE_NOT_GRANTED";
  exports[3531] = "ER_FAILED_REVOKE_ROLE";
  exports[3532] = "ER_RENAME_ROLE";
  exports[3533] = "ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION";
  exports[3534] = "ER_COMPONENTS_CANT_SATISFY_DEPENDENCY";
  exports[3535] = "ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION";
  exports[3536] = "ER_COMPONENTS_LOAD_CANT_INITIALIZE";
  exports[3537] = "ER_COMPONENTS_UNLOAD_NOT_LOADED";
  exports[3538] = "ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE";
  exports[3539] = "ER_COMPONENTS_CANT_RELEASE_SERVICE";
  exports[3540] = "ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE";
  exports[3541] = "ER_COMPONENTS_CANT_UNLOAD";
  exports[3542] = "ER_WARN_UNLOAD_THE_NOT_PERSISTED";
  exports[3543] = "ER_COMPONENT_TABLE_INCORRECT";
  exports[3544] = "ER_COMPONENT_MANIPULATE_ROW_FAILED";
  exports[3545] = "ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP";
  exports[3546] = "ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS";
  exports[3547] = "ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES";
  exports[3548] = "ER_SRS_NOT_FOUND";
  exports[3549] = "ER_VARIABLE_NOT_PERSISTED";
  exports[3550] = "ER_IS_QUERY_INVALID_CLAUSE";
  exports[3551] = "ER_UNABLE_TO_STORE_STATISTICS";
  exports[3552] = "ER_NO_SYSTEM_SCHEMA_ACCESS";
  exports[3553] = "ER_NO_SYSTEM_TABLESPACE_ACCESS";
  exports[3554] = "ER_NO_SYSTEM_TABLE_ACCESS";
  exports[3555] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE";
  exports[3556] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE";
  exports[3557] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE";
  exports[3558] = "ER_INVALID_OPTION_KEY";
  exports[3559] = "ER_INVALID_OPTION_VALUE";
  exports[3560] = "ER_INVALID_OPTION_KEY_VALUE_PAIR";
  exports[3561] = "ER_INVALID_OPTION_START_CHARACTER";
  exports[3562] = "ER_INVALID_OPTION_END_CHARACTER";
  exports[3563] = "ER_INVALID_OPTION_CHARACTERS";
  exports[3564] = "ER_DUPLICATE_OPTION_KEY";
  exports[3565] = "ER_WARN_SRS_NOT_FOUND_AXIS_ORDER";
  exports[3566] = "ER_NO_ACCESS_TO_NATIVE_FCT";
  exports[3567] = "ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE";
  exports[3568] = "ER_UNRESOLVED_TABLE_LOCK";
  exports[3569] = "ER_DUPLICATE_TABLE_LOCK";
  exports[3570] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
  exports[3571] = "ER_BINLOG_UNSAFE_NOWAIT";
  exports[3572] = "ER_LOCK_NOWAIT";
  exports[3573] = "ER_CTE_RECURSIVE_REQUIRES_UNION";
  exports[3574] = "ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST";
  exports[3575] = "ER_CTE_RECURSIVE_FORBIDS_AGGREGATION";
  exports[3576] = "ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER";
  exports[3577] = "ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE";
  exports[3578] = "ER_SWITCH_TMP_ENGINE";
  exports[3579] = "ER_WINDOW_NO_SUCH_WINDOW";
  exports[3580] = "ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH";
  exports[3581] = "ER_WINDOW_NO_CHILD_PARTITIONING";
  exports[3582] = "ER_WINDOW_NO_INHERIT_FRAME";
  exports[3583] = "ER_WINDOW_NO_REDEFINE_ORDER_BY";
  exports[3584] = "ER_WINDOW_FRAME_START_ILLEGAL";
  exports[3585] = "ER_WINDOW_FRAME_END_ILLEGAL";
  exports[3586] = "ER_WINDOW_FRAME_ILLEGAL";
  exports[3587] = "ER_WINDOW_RANGE_FRAME_ORDER_TYPE";
  exports[3588] = "ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE";
  exports[3589] = "ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE";
  exports[3590] = "ER_WINDOW_RANGE_BOUND_NOT_CONSTANT";
  exports[3591] = "ER_WINDOW_DUPLICATE_NAME";
  exports[3592] = "ER_WINDOW_ILLEGAL_ORDER_BY";
  exports[3593] = "ER_WINDOW_INVALID_WINDOW_FUNC_USE";
  exports[3594] = "ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE";
  exports[3595] = "ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC";
  exports[3596] = "ER_WINDOW_ROWS_INTERVAL_USE";
  exports[3597] = "ER_WINDOW_NO_GROUP_ORDER";
  exports[3598] = "ER_WINDOW_EXPLAIN_JSON";
  exports[3599] = "ER_WINDOW_FUNCTION_IGNORES_FRAME";
  exports[3600] = "ER_WL9236_NOW";
  exports[3601] = "ER_INVALID_NO_OF_ARGS";
  exports[3602] = "ER_FIELD_IN_GROUPING_NOT_GROUP_BY";
  exports[3603] = "ER_TOO_LONG_TABLESPACE_COMMENT";
  exports[3604] = "ER_ENGINE_CANT_DROP_TABLE";
  exports[3605] = "ER_ENGINE_CANT_DROP_MISSING_TABLE";
  exports[3606] = "ER_TABLESPACE_DUP_FILENAME";
  exports[3607] = "ER_DB_DROP_RMDIR2";
  exports[3608] = "ER_IMP_NO_FILES_MATCHED";
  exports[3609] = "ER_IMP_SCHEMA_DOES_NOT_EXIST";
  exports[3610] = "ER_IMP_TABLE_ALREADY_EXISTS";
  exports[3611] = "ER_IMP_INCOMPATIBLE_MYSQLD_VERSION";
  exports[3612] = "ER_IMP_INCOMPATIBLE_DD_VERSION";
  exports[3613] = "ER_IMP_INCOMPATIBLE_SDI_VERSION";
  exports[3614] = "ER_WARN_INVALID_HINT";
  exports[3615] = "ER_VAR_DOES_NOT_EXIST";
  exports[3616] = "ER_LONGITUDE_OUT_OF_RANGE";
  exports[3617] = "ER_LATITUDE_OUT_OF_RANGE";
  exports[3618] = "ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS";
  exports[3619] = "ER_ILLEGAL_PRIVILEGE_LEVEL";
  exports[3620] = "ER_NO_SYSTEM_VIEW_ACCESS";
  exports[3621] = "ER_COMPONENT_FILTER_FLABBERGASTED";
  exports[3622] = "ER_PART_EXPR_TOO_LONG";
  exports[3623] = "ER_UDF_DROP_DYNAMICALLY_REGISTERED";
  exports[3624] = "ER_UNABLE_TO_STORE_COLUMN_STATISTICS";
  exports[3625] = "ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS";
  exports[3626] = "ER_UNABLE_TO_DROP_COLUMN_STATISTICS";
  exports[3627] = "ER_UNABLE_TO_BUILD_HISTOGRAM";
  exports[3628] = "ER_MANDATORY_ROLE";
  exports[3629] = "ER_MISSING_TABLESPACE_FILE";
  exports[3630] = "ER_PERSIST_ONLY_ACCESS_DENIED_ERROR";
  exports[3631] = "ER_CMD_NEED_SUPER";
  exports[3632] = "ER_PATH_IN_DATADIR";
  exports[3633] = "ER_CLONE_DDL_IN_PROGRESS";
  exports[3634] = "ER_CLONE_TOO_MANY_CONCURRENT_CLONES";
  exports[3635] = "ER_APPLIER_LOG_EVENT_VALIDATION_ERROR";
  exports[3636] = "ER_CTE_MAX_RECURSION_DEPTH";
  exports[3637] = "ER_NOT_HINT_UPDATABLE_VARIABLE";
  exports[3638] = "ER_CREDENTIALS_CONTRADICT_TO_HISTORY";
  exports[3639] = "ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID";
  exports[3640] = "ER_CLIENT_DOES_NOT_SUPPORT";
  exports[3641] = "ER_I_S_SKIPPED_TABLESPACE";
  exports[3642] = "ER_TABLESPACE_ENGINE_MISMATCH";
  exports[3643] = "ER_WRONG_SRID_FOR_COLUMN";
  exports[3644] = "ER_CANNOT_ALTER_SRID_DUE_TO_INDEX";
  exports[3645] = "ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED";
  exports[3646] = "ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED";
  exports[3647] = "ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES";
  exports[3648] = "ER_COULD_NOT_APPLY_JSON_DIFF";
  exports[3649] = "ER_CORRUPTED_JSON_DIFF";
  exports[3650] = "ER_RESOURCE_GROUP_EXISTS";
  exports[3651] = "ER_RESOURCE_GROUP_NOT_EXISTS";
  exports[3652] = "ER_INVALID_VCPU_ID";
  exports[3653] = "ER_INVALID_VCPU_RANGE";
  exports[3654] = "ER_INVALID_THREAD_PRIORITY";
  exports[3655] = "ER_DISALLOWED_OPERATION";
  exports[3656] = "ER_RESOURCE_GROUP_BUSY";
  exports[3657] = "ER_RESOURCE_GROUP_DISABLED";
  exports[3658] = "ER_FEATURE_UNSUPPORTED";
  exports[3659] = "ER_ATTRIBUTE_IGNORED";
  exports[3660] = "ER_INVALID_THREAD_ID";
  exports[3661] = "ER_RESOURCE_GROUP_BIND_FAILED";
  exports[3662] = "ER_INVALID_USE_OF_FORCE_OPTION";
  exports[3663] = "ER_GROUP_REPLICATION_COMMAND_FAILURE";
  exports[3664] = "ER_SDI_OPERATION_FAILED";
  exports[3665] = "ER_MISSING_JSON_TABLE_VALUE";
  exports[3666] = "ER_WRONG_JSON_TABLE_VALUE";
  exports[3667] = "ER_TF_MUST_HAVE_ALIAS";
  exports[3668] = "ER_TF_FORBIDDEN_JOIN_TYPE";
  exports[3669] = "ER_JT_VALUE_OUT_OF_RANGE";
  exports[3670] = "ER_JT_MAX_NESTED_PATH";
  exports[3671] = "ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD";
  exports[3672] = "ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL";
  exports[3673] = "ER_BAD_NULL_ERROR_NOT_IGNORED";
  exports[3674] = "WARN_USELESS_SPATIAL_INDEX";
  exports[3675] = "ER_DISK_FULL_NOWAIT";
  exports[3676] = "ER_PARSE_ERROR_IN_DIGEST_FN";
  exports[3677] = "ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN";
  exports[3678] = "ER_SCHEMA_DIR_EXISTS";
  exports[3679] = "ER_SCHEMA_DIR_MISSING";
  exports[3680] = "ER_SCHEMA_DIR_CREATE_FAILED";
  exports[3681] = "ER_SCHEMA_DIR_UNKNOWN";
  exports[3682] = "ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326";
  exports[3683] = "ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER";
  exports[3684] = "ER_REGEXP_BUFFER_OVERFLOW";
  exports[3685] = "ER_REGEXP_ILLEGAL_ARGUMENT";
  exports[3686] = "ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR";
  exports[3687] = "ER_REGEXP_INTERNAL_ERROR";
  exports[3688] = "ER_REGEXP_RULE_SYNTAX";
  exports[3689] = "ER_REGEXP_BAD_ESCAPE_SEQUENCE";
  exports[3690] = "ER_REGEXP_UNIMPLEMENTED";
  exports[3691] = "ER_REGEXP_MISMATCHED_PAREN";
  exports[3692] = "ER_REGEXP_BAD_INTERVAL";
  exports[3693] = "ER_REGEXP_MAX_LT_MIN";
  exports[3694] = "ER_REGEXP_INVALID_BACK_REF";
  exports[3695] = "ER_REGEXP_LOOK_BEHIND_LIMIT";
  exports[3696] = "ER_REGEXP_MISSING_CLOSE_BRACKET";
  exports[3697] = "ER_REGEXP_INVALID_RANGE";
  exports[3698] = "ER_REGEXP_STACK_OVERFLOW";
  exports[3699] = "ER_REGEXP_TIME_OUT";
  exports[3700] = "ER_REGEXP_PATTERN_TOO_BIG";
  exports[3701] = "ER_CANT_SET_ERROR_LOG_SERVICE";
  exports[3702] = "ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE";
  exports[3703] = "ER_COMPONENT_FILTER_DIAGNOSTICS";
  exports[3704] = "ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS";
  exports[3705] = "ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS";
  exports[3706] = "ER_NONPOSITIVE_RADIUS";
  exports[3707] = "ER_RESTART_SERVER_FAILED";
  exports[3708] = "ER_SRS_MISSING_MANDATORY_ATTRIBUTE";
  exports[3709] = "ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS";
  exports[3710] = "ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE";
  exports[3711] = "ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE";
  exports[3712] = "ER_SRS_ID_ALREADY_EXISTS";
  exports[3713] = "ER_WARN_SRS_ID_ALREADY_EXISTS";
  exports[3714] = "ER_CANT_MODIFY_SRID_0";
  exports[3715] = "ER_WARN_RESERVED_SRID_RANGE";
  exports[3716] = "ER_CANT_MODIFY_SRS_USED_BY_COLUMN";
  exports[3717] = "ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE";
  exports[3718] = "ER_SRS_ATTRIBUTE_STRING_TOO_LONG";
  exports[3719] = "ER_DEPRECATED_UTF8_ALIAS";
  exports[3720] = "ER_DEPRECATED_NATIONAL";
  exports[3721] = "ER_INVALID_DEFAULT_UTF8MB4_COLLATION";
  exports[3722] = "ER_UNABLE_TO_COLLECT_LOG_STATUS";
  exports[3723] = "ER_RESERVED_TABLESPACE_NAME";
  exports[3724] = "ER_UNABLE_TO_SET_OPTION";
  exports[3725] = "ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL";
  exports[3726] = "ER_SRS_NOT_GEOGRAPHIC";
  exports[3727] = "ER_POLYGON_TOO_LARGE";
  exports[3728] = "ER_SPATIAL_UNIQUE_INDEX";
  exports[3729] = "ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX";
  exports[3730] = "ER_FK_CANNOT_DROP_PARENT";
  exports[3731] = "ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE";
  exports[3732] = "ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE";
  exports[3733] = "ER_FK_CANNOT_USE_VIRTUAL_COLUMN";
  exports[3734] = "ER_FK_NO_COLUMN_PARENT";
  exports[3735] = "ER_CANT_SET_ERROR_SUPPRESSION_LIST";
  exports[3736] = "ER_SRS_GEOGCS_INVALID_AXES";
  exports[3737] = "ER_SRS_INVALID_SEMI_MAJOR_AXIS";
  exports[3738] = "ER_SRS_INVALID_INVERSE_FLATTENING";
  exports[3739] = "ER_SRS_INVALID_ANGULAR_UNIT";
  exports[3740] = "ER_SRS_INVALID_PRIME_MERIDIAN";
  exports[3741] = "ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED";
  exports[3742] = "ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED";
  exports[3743] = "ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84";
  exports[3744] = "ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84";
  exports[3745] = "ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT";
  exports[3746] = "ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
  exports[3747] = "ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
  exports[3748] = "ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR";
  exports[3749] = "ER_XA_CANT_CREATE_MDL_BACKUP";
  exports[3750] = "ER_TABLE_WITHOUT_PK";
  exports[3751] = "ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX";
  exports[3752] = "ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX";
  exports[3753] = "ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION";
  exports[3754] = "ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT";
  exports[3755] = "ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX";
  exports[3756] = "ER_FUNCTIONAL_INDEX_PRIMARY_KEY";
  exports[3757] = "ER_FUNCTIONAL_INDEX_ON_LOB";
  exports[3758] = "ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED";
  exports[3759] = "ER_FULLTEXT_FUNCTIONAL_INDEX";
  exports[3760] = "ER_SPATIAL_FUNCTIONAL_INDEX";
  exports[3761] = "ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX";
  exports[3762] = "ER_FUNCTIONAL_INDEX_ON_FIELD";
  exports[3763] = "ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED";
  exports[3764] = "ER_GENERATED_COLUMN_ROW_VALUE";
  exports[3765] = "ER_GENERATED_COLUMN_VARIABLES";
  exports[3766] = "ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE";
  exports[3767] = "ER_DEFAULT_VAL_GENERATED_NON_PRIOR";
  exports[3768] = "ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC";
  exports[3769] = "ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED";
  exports[3770] = "ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED";
  exports[3771] = "ER_DEFAULT_VAL_GENERATED_ROW_VALUE";
  exports[3772] = "ER_DEFAULT_VAL_GENERATED_VARIABLES";
  exports[3773] = "ER_DEFAULT_AS_VAL_GENERATED";
  exports[3774] = "ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED";
  exports[3775] = "ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION";
  exports[3776] = "ER_FK_CANNOT_CHANGE_ENGINE";
  exports[3777] = "ER_WARN_DEPRECATED_USER_SET_EXPR";
  exports[3778] = "ER_WARN_DEPRECATED_UTF8MB3_COLLATION";
  exports[3779] = "ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX";
  exports[3780] = "ER_FK_INCOMPATIBLE_COLUMNS";
  exports[3781] = "ER_GR_HOLD_WAIT_TIMEOUT";
  exports[3782] = "ER_GR_HOLD_KILLED";
  exports[3783] = "ER_GR_HOLD_MEMBER_STATUS_ERROR";
  exports[3784] = "ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY";
  exports[3785] = "ER_RPL_ENCRYPTION_KEY_NOT_FOUND";
  exports[3786] = "ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY";
  exports[3787] = "ER_RPL_ENCRYPTION_HEADER_ERROR";
  exports[3788] = "ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS";
  exports[3789] = "ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED";
  exports[3790] = "ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY";
  exports[3791] = "ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY";
  exports[3792] = "ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY";
  exports[3793] = "ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION";
  exports[3794] = "ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED";
  exports[3795] = "ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE";
  exports[3796] = "ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED";
  exports[3797] = "ER_GRP_TRX_CONSISTENCY_BEFORE";
  exports[3798] = "ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN";
  exports[3799] = "ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED";
  exports[3800] = "ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED";
  exports[3801] = "ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT";
  exports[3802] = "ER_PAGE_TRACKING_NOT_STARTED";
  exports[3803] = "ER_PAGE_TRACKING_RANGE_NOT_TRACKED";
  exports[3804] = "ER_PAGE_TRACKING_CANNOT_PURGE";
  exports[3805] = "ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY";
  exports[3806] = "ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION";
  exports[3807] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY";
  exports[3808] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS";
  exports[3809] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG";
  exports[3810] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS";
  exports[3811] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY";
  exports[3812] = "ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT";
  exports[3813] = "ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN";
  exports[3814] = "ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED";
  exports[3815] = "ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED";
  exports[3816] = "ER_CHECK_CONSTRAINT_VARIABLES";
  exports[3817] = "ER_CHECK_CONSTRAINT_ROW_VALUE";
  exports[3818] = "ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN";
  exports[3819] = "ER_CHECK_CONSTRAINT_VIOLATED";
  exports[3820] = "ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN";
  exports[3821] = "ER_CHECK_CONSTRAINT_NOT_FOUND";
  exports[3822] = "ER_CHECK_CONSTRAINT_DUP_NAME";
  exports[3823] = "ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN";
  exports[3824] = "WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB";
  exports[3825] = "ER_INVALID_ENCRYPTION_REQUEST";
  exports[3826] = "ER_CANNOT_SET_TABLE_ENCRYPTION";
  exports[3827] = "ER_CANNOT_SET_DATABASE_ENCRYPTION";
  exports[3828] = "ER_CANNOT_SET_TABLESPACE_ENCRYPTION";
  exports[3829] = "ER_TABLESPACE_CANNOT_BE_ENCRYPTED";
  exports[3830] = "ER_TABLESPACE_CANNOT_BE_DECRYPTED";
  exports[3831] = "ER_TABLESPACE_TYPE_UNKNOWN";
  exports[3832] = "ER_TARGET_TABLESPACE_UNENCRYPTED";
  exports[3833] = "ER_CANNOT_USE_ENCRYPTION_CLAUSE";
  exports[3834] = "ER_INVALID_MULTIPLE_CLAUSES";
  exports[3835] = "ER_UNSUPPORTED_USE_OF_GRANT_AS";
  exports[3836] = "ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS";
  exports[3837] = "ER_DEPENDENT_BY_FUNCTIONAL_INDEX";
  exports[3838] = "ER_PLUGIN_NOT_EARLY";
  exports[3839] = "ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH";
  exports[3840] = "ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT";
  exports[3841] = "ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID";
  exports[3842] = "ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND";
  exports[3843] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY";
  exports[3844] = "ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR";
  exports[3845] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH";
  exports[3846] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS";
  exports[3847] = "ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE";
  exports[3848] = "ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE";
  exports[3849] = "ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE";
  exports[3850] = "ER_INNODB_REDO_LOG_ARCHIVE_FAILED";
  exports[3851] = "ER_INNODB_REDO_LOG_ARCHIVE_SESSION";
  exports[3852] = "ER_STD_REGEX_ERROR";
  exports[3853] = "ER_INVALID_JSON_TYPE";
  exports[3854] = "ER_CANNOT_CONVERT_STRING";
  exports[3855] = "ER_DEPENDENT_BY_PARTITION_FUNC";
  exports[3856] = "ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT";
  exports[3857] = "ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP";
  exports[3858] = "ER_WARN_DEPRECATED_FLOAT_DIGITS";
  exports[3859] = "ER_WARN_DEPRECATED_FLOAT_UNSIGNED";
  exports[3860] = "ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH";
  exports[3861] = "ER_WARN_DEPRECATED_ZEROFILL";
  exports[3862] = "ER_CLONE_DONOR";
  exports[3863] = "ER_CLONE_PROTOCOL";
  exports[3864] = "ER_CLONE_DONOR_VERSION";
  exports[3865] = "ER_CLONE_OS";
  exports[3866] = "ER_CLONE_PLATFORM";
  exports[3867] = "ER_CLONE_CHARSET";
  exports[3868] = "ER_CLONE_CONFIG";
  exports[3869] = "ER_CLONE_SYS_CONFIG";
  exports[3870] = "ER_CLONE_PLUGIN_MATCH";
  exports[3871] = "ER_CLONE_LOOPBACK";
  exports[3872] = "ER_CLONE_ENCRYPTION";
  exports[3873] = "ER_CLONE_DISK_SPACE";
  exports[3874] = "ER_CLONE_IN_PROGRESS";
  exports[3875] = "ER_CLONE_DISALLOWED";
  exports[3876] = "ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER";
  exports[3877] = "ER_SECONDARY_ENGINE_PLUGIN";
  exports[3878] = "ER_SECOND_PASSWORD_CANNOT_BE_EMPTY";
  exports[3879] = "ER_DB_ACCESS_DENIED";
  exports[3880] = "ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES";
  exports[3881] = "ER_DA_RPL_GTID_TABLE_CANNOT_OPEN";
  exports[3882] = "ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT";
  exports[3883] = "ER_DA_PLUGIN_INSTALL_ERROR";
  exports[3884] = "ER_NO_SESSION_TEMP";
  exports[3885] = "ER_DA_UNKNOWN_ERROR_NUMBER";
  exports[3886] = "ER_COLUMN_CHANGE_SIZE";
  exports[3887] = "ER_REGEXP_INVALID_CAPTURE_GROUP_NAME";
  exports[3888] = "ER_DA_SSL_LIBRARY_ERROR";
  exports[3889] = "ER_SECONDARY_ENGINE";
  exports[3890] = "ER_SECONDARY_ENGINE_DDL";
  exports[3891] = "ER_INCORRECT_CURRENT_PASSWORD";
  exports[3892] = "ER_MISSING_CURRENT_PASSWORD";
  exports[3893] = "ER_CURRENT_PASSWORD_NOT_REQUIRED";
  exports[3894] = "ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE";
  exports[3895] = "ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED";
  exports[3896] = "ER_PARTIAL_REVOKES_EXIST";
  exports[3897] = "ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE";
  exports[3898] = "ER_XA_REPLICATION_FILTERS";
  exports[3899] = "ER_UNSUPPORTED_SQL_MODE";
  exports[3900] = "ER_REGEXP_INVALID_FLAG";
  exports[3901] = "ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS";
  exports[3902] = "ER_UNIT_NOT_FOUND";
  exports[3903] = "ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX";
  exports[3904] = "ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX";
  exports[3905] = "ER_EXCEEDED_MV_KEYS_NUM";
  exports[3906] = "ER_EXCEEDED_MV_KEYS_SPACE";
  exports[3907] = "ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG";
  exports[3908] = "ER_WRONG_MVI_VALUE";
  exports[3909] = "ER_WARN_FUNC_INDEX_NOT_APPLICABLE";
  exports[3910] = "ER_GRP_RPL_UDF_ERROR";
  exports[3911] = "ER_UPDATE_GTID_PURGED_WITH_GR";
  exports[3912] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
  exports[3913] = "ER_TABLE_NAME_CAUSES_TOO_LONG_PATH";
  exports[3914] = "ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE";
  exports[3915] = "ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED";
  exports[3916] = "ER_DA_GRP_RPL_STARTED_AUTO_REJOIN";
  exports[3917] = "ER_SYSVAR_CHANGE_DURING_QUERY";
  exports[3918] = "ER_GLOBSTAT_CHANGE_DURING_QUERY";
  exports[3919] = "ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE";
  exports[3920] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT";
  exports[3921] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT";
  exports[3922] = "ER_WRONG_COMPRESSION_ALGORITHM_CLIENT";
  exports[3923] = "ER_WRONG_COMPRESSION_LEVEL_CLIENT";
  exports[3924] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT";
  exports[3925] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS";
  exports[3926] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST";
  exports[3927] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT";
  exports[3928] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV";
  exports[3929] = "ER_WARN_DA_PRIVILEGE_NOT_REGISTERED";
  exports[3930] = "ER_CLIENT_KEYRING_UDF_KEY_INVALID";
  exports[3931] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID";
  exports[3932] = "ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG";
  exports[3933] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG";
  exports[3934] = "ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT";
  exports[3935] = "ER_DA_UDF_INVALID_CHARSET_SPECIFIED";
  exports[3936] = "ER_DA_UDF_INVALID_CHARSET";
  exports[3937] = "ER_DA_UDF_INVALID_COLLATION";
  exports[3938] = "ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE";
  exports[3939] = "ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME";
  exports[3940] = "ER_CONSTRAINT_NOT_FOUND";
  exports[3941] = "ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED";
  exports[3942] = "ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS";
  exports[3943] = "ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT";
  exports[3944] = "ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT";
  exports[3945] = "ER_REQUIRE_ROW_FORMAT_INVALID_VALUE";
  exports[3946] = "ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY";
  exports[3947] = "ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST";
  exports[3948] = "ER_CLIENT_LOCAL_FILES_DISABLED";
  exports[3949] = "ER_IMP_INCOMPATIBLE_CFG_VERSION";
  exports[3950] = "ER_DA_OOM";
  exports[3951] = "ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET";
  exports[3952] = "ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET";
  exports[3953] = "ER_MULTIPLE_INTO_CLAUSES";
  exports[3954] = "ER_MISPLACED_INTO";
  exports[3955] = "ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK";
  exports[3956] = "ER_WARN_DEPRECATED_YEAR_UNSIGNED";
  exports[3957] = "ER_CLONE_NETWORK_PACKET";
  exports[3958] = "ER_SDI_OPERATION_FAILED_MISSING_RECORD";
  exports[3959] = "ER_DEPENDENT_BY_CHECK_CONSTRAINT";
  exports[3960] = "ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP";
  exports[3961] = "ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY";
  exports[3962] = "ER_WARN_DEPRECATED_INNER_INTO";
  exports[3963] = "ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL";
  exports[3964] = "ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS";
  exports[3965] = "ER_WARN_DEPRECATED_FOUND_ROWS";
  exports[3966] = "ER_MISSING_JSON_VALUE";
  exports[3967] = "ER_MULTIPLE_JSON_VALUES";
  exports[3968] = "ER_HOSTNAME_TOO_LONG";
  exports[3969] = "ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY";
  exports[3970] = "ER_GROUP_REPLICATION_USER_EMPTY_MSG";
  exports[3971] = "ER_GROUP_REPLICATION_USER_MANDATORY_MSG";
  exports[3972] = "ER_GROUP_REPLICATION_PASSWORD_LENGTH";
  exports[3973] = "ER_SUBQUERY_TRANSFORM_REJECTED";
  exports[3974] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT";
  exports[3975] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID";
  exports[3976] = "ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART";
  exports[3977] = "ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION";
  exports[3978] = "ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT";
  exports[3979] = "ER_NOT_ALLOWED_WITH_START_TRANSACTION";
  exports[3980] = "ER_INVALID_JSON_ATTRIBUTE";
  exports[3981] = "ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED";
  exports[3982] = "ER_INVALID_USER_ATTRIBUTE_JSON";
  exports[3983] = "ER_INNODB_REDO_DISABLED";
  exports[3984] = "ER_INNODB_REDO_ARCHIVING_ENABLED";
  exports[3985] = "ER_MDL_OUT_OF_RESOURCES";
  exports[3986] = "ER_IMPLICIT_COMPARISON_FOR_JSON";
  exports[3987] = "ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET";
  exports[3988] = "ER_IMPOSSIBLE_STRING_CONVERSION";
  exports[3989] = "ER_SCHEMA_READ_ONLY";
  exports[3990] = "ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF";
  exports[3991] = "ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF";
  exports[3992] = "ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF";
  exports[3993] = "ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF";
  exports[3994] = "ER_INVALID_PARAMETER_USE";
  exports[3995] = "ER_CHARACTER_SET_MISMATCH";
  exports[3996] = "ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED";
  exports[3997] = "ER_INVALID_TIME_ZONE_INTERVAL";
  exports[3998] = "ER_INVALID_CAST";
  exports[3999] = "ER_HYPERGRAPH_NOT_SUPPORTED_YET";
  exports[4000] = "ER_WARN_HYPERGRAPH_EXPERIMENTAL";
  exports[4001] = "ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED";
  exports[4002] = "ER_DA_ERROR_LOG_TABLE_DISABLED";
  exports[4003] = "ER_DA_ERROR_LOG_MULTIPLE_FILTERS";
  exports[4004] = "ER_DA_CANT_OPEN_ERROR_LOG";
  exports[4005] = "ER_USER_REFERENCED_AS_DEFINER";
  exports[4006] = "ER_CANNOT_USER_REFERENCED_AS_DEFINER";
  exports[4007] = "ER_REGEX_NUMBER_TOO_BIG";
  exports[4008] = "ER_SPVAR_NONINTEGER_TYPE";
  exports[4009] = "WARN_UNSUPPORTED_ACL_TABLES_READ";
  exports[4010] = "ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL";
  exports[4011] = "ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT";
  exports[4012] = "ER_STARTING_REPLICA_MONITOR_IO_THREAD";
  exports[4013] = "ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON";
  exports[4014] = "ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION";
  exports[4015] = "ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON";
  exports[4016] = "ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON";
  exports[4017] = "ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID";
  exports[4018] = "ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS";
  exports[4019] = "ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID";
  exports[4020] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME";
  exports[4021] = "ER_CANT_USE_SAME_UUID_AS_GROUP_NAME";
  exports[4022] = "ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING";
  exports[4023] = "ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE";
  exports[4024] = "ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE";
  exports[4025] = "ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE";
  exports[4026] = "ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE";
  exports[4027] = "ER_ROLE_GRANTED_TO_ITSELF";
  exports[4028] = "ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN";
  exports[4029] = "ER_INNODB_COMPRESSION_FAILURE";
  exports[4030] = "ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE";
  exports[4031] = "ER_CLIENT_INTERACTION_TIMEOUT";
  exports[4032] = "ER_INVALID_CAST_TO_GEOMETRY";
  exports[4033] = "ER_INVALID_CAST_POLYGON_RING_DIRECTION";
  exports[4034] = "ER_GIS_DIFFERENT_SRIDS_AGGREGATION";
  exports[4035] = "ER_RELOAD_KEYRING_FAILURE";
  exports[4036] = "ER_SDI_GET_KEYS_INVALID_TABLESPACE";
  exports[4037] = "ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE";
  exports[4038] = "ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI";
  exports[4039] = "ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID";
  exports[4040] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID";
  exports[4041] = "ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE";
  exports[4042] = "ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS";
  exports[4043] = "ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE";
  exports[4044] = "ER_KERBEROS_CREATE_USER";
  exports[4045] = "ER_INSTALL_PLUGIN_CONFLICT_CLIENT";
  exports[4046] = "ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED";
  exports[4047] = "ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED";
  exports[4048] = "ER_INVALID_ASSIGNMENT_TARGET";
  exports[4049] = "ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY";
  exports[4050] = "ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION";
  exports[4051] = "ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON";
  exports[4052] = "ER_INVALID_MFA_PLUGIN_SPECIFIED";
  exports[4053] = "ER_IDENTIFIED_BY_UNSUPPORTED";
  exports[4054] = "ER_INVALID_PLUGIN_FOR_REGISTRATION";
  exports[4055] = "ER_PLUGIN_REQUIRES_REGISTRATION";
  exports[4056] = "ER_MFA_METHOD_EXISTS";
  exports[4057] = "ER_MFA_METHOD_NOT_EXISTS";
  exports[4058] = "ER_AUTHENTICATION_POLICY_MISMATCH";
  exports[4059] = "ER_PLUGIN_REGISTRATION_DONE";
  exports[4060] = "ER_INVALID_USER_FOR_REGISTRATION";
  exports[4061] = "ER_USER_REGISTRATION_FAILED";
  exports[4062] = "ER_MFA_METHODS_INVALID_ORDER";
  exports[4063] = "ER_MFA_METHODS_IDENTICAL";
  exports[4064] = "ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER";
  exports[4065] = "ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY";
  exports[4066] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY";
  exports[4067] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY";
  exports[4068] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS";
  exports[4069] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS";
  exports[4070] = "ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON";
  exports[4071] = "ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON";
  exports[4072] = "ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS";
  exports[4073] = "ER_DA_SSL_FIPS_MODE_ERROR";
  exports[4074] = "ER_VALUE_OUT_OF_RANGE";
  exports[4075] = "ER_FULLTEXT_WITH_ROLLUP";
  exports[4076] = "ER_REGEXP_MISSING_RESOURCE";
  exports[4077] = "ER_WARN_REGEXP_USING_DEFAULT";
  exports[4078] = "ER_REGEXP_MISSING_FILE";
  exports[4079] = "ER_WARN_DEPRECATED_COLLATION";
  exports[4080] = "ER_CONCURRENT_PROCEDURE_USAGE";
  exports[4081] = "ER_DA_GLOBAL_CONN_LIMIT";
  exports[4082] = "ER_DA_CONN_LIMIT";
  exports[4083] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT";
  exports[4084] = "ER_WARN_SF_UDF_NAME_COLLISION";
  exports[4085] = "ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK";
  exports[4086] = "ER_TOO_MANY_WINDOWS";
  exports[4087] = "ER_MYSQLBACKUP_CLIENT_MSG";
  exports[4088] = "ER_COMMENT_CONTAINS_INVALID_STRING";
  exports[4089] = "ER_DEFINITION_CONTAINS_INVALID_STRING";
  exports[4090] = "ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT";
  exports[4091] = "ER_XA_TEMP_TABLE";
  exports[4092] = "ER_INNODB_MAX_ROW_VERSION";
  exports[4093] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE";
  exports[4094] = "ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING";
  exports[4095] = "ER_WARN_DEPRECATED_DATETIME_DELIMITER";
  exports[4096] = "ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER";
  exports[4097] = "ER_CANNOT_PERSIST_SENSITIVE_VARIABLES";
  exports[4098] = "ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES";
  exports[4099] = "ER_WARN_TRG_ALREADY_EXISTS";
  exports[4100] = "ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE";
  exports[4101] = "ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION";
  exports[4102] = "ER_SET_PASSWORD_AUTH_PLUGIN_ERROR";
  exports[4103] = "ER_REDUCED_DBLWR_FILE_CORRUPTED";
  exports[4104] = "ER_REDUCED_DBLWR_PAGE_FOUND";
  exports[4105] = "ER_SRS_INVALID_LATITUDE_OF_ORIGIN";
  exports[4106] = "ER_SRS_INVALID_LONGITUDE_OF_ORIGIN";
  exports[4107] = "ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT";
  exports[4108] = "ER_GIPK_COLUMN_EXISTS";
  exports[4109] = "ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS";
  exports[4110] = "ER_GIPK_COLUMN_ALTER_NOT_ALLOWED";
  exports[4111] = "ER_DROP_PK_COLUMN_TO_DROP_GIPK";
  exports[4112] = "ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR";
  exports[4113] = "ER_DA_EXPIRE_LOGS_DAYS_IGNORED";
  exports[4114] = "ER_CTE_RECURSIVE_NOT_UNION";
  exports[4115] = "ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX";
  exports[4116] = "ER_COMMAND_SERVICE_BACKEND_FAILED";
  exports[4117] = "ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS";
  exports[4118] = "ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE";
  exports[4119] = "ER_WARN_DEPRECATED_IDENT";
  exports[4120] = "ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED";
  exports[4121] = "ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT";
  exports[4122] = "ER_BAD_TIMESTAMP_FORMAT";
  exports[4123] = "ER_SHAPE_PRIDICTION_UDF";
  exports[4124] = "ER_SRS_INVALID_HEIGHT";
  exports[4125] = "ER_SRS_INVALID_SCALING";
  exports[4126] = "ER_SRS_INVALID_ZONE_WIDTH";
  exports[4127] = "ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A";
  exports[4128] = "ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION";
  exports[4129] = "ER_TABLE_NOT_EMPTY";
  exports[4130] = "ER_TABLE_NO_PRIMARY_KEY";
  exports[4131] = "ER_TABLE_IN_SHARED_TABLESPACE";
  exports[4132] = "ER_INDEX_OTHER_THAN_PK";
  exports[4133] = "ER_LOAD_BULK_DATA_UNSORTED";
  exports[4134] = "ER_BULK_EXECUTOR_ERROR";
  exports[4135] = "ER_BULK_READER_LIBCURL_INIT_FAILED";
  exports[4136] = "ER_BULK_READER_LIBCURL_ERROR";
  exports[4137] = "ER_BULK_READER_SERVER_ERROR";
  exports[4138] = "ER_BULK_READER_COMMUNICATION_ERROR";
  exports[4139] = "ER_BULK_LOAD_DATA_FAILED";
  exports[4140] = "ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER";
  exports[4141] = "ER_BULK_LOADER_COMPONENT_ERROR";
  exports[4142] = "ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE";
  exports[4143] = "ER_BULK_PARSER_MISSING_ENCLOSED_BY";
  exports[4144] = "ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED";
  exports[4145] = "ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED";
  exports[4146] = "ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT";
  exports[4147] = "ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR";
  exports[4148] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY";
  exports[4149] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE";
  exports[4150] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR";
  exports[4151] = "ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE";
  exports[4152] = "ER_LOAD_BULK_DATA_FAILED";
  exports[4153] = "ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD";
  exports[4154] = "ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL";
  exports[4155] = "ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR";
  exports[4156] = "ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE";
  exports[4157] = "ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE";
  exports[4158] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS";
  exports[4159] = "ER_CANT_SET_PERSISTED";
  exports[4160] = "ER_INSTALL_COMPONENT_SET_NULL_VALUE";
  exports[4161] = "ER_INSTALL_COMPONENT_SET_UNUSED_VALUE";
  exports[4162] = "ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS";
});

// ../../../../node_modules/long/umd/index.js
var require_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    function preferDefault(exports2) {
      return exports2.default || exports2;
    }
    if (typeof define === "function" && define.amd) {
      define([], function() {
        var exports2 = {};
        factory(exports2);
        return preferDefault(exports2);
      });
    } else if (typeof exports === "object") {
      factory(exports);
      if (typeof module === "object")
        module.exports = preferDefault(exports);
    } else {
      (function() {
        var exports2 = {};
        factory(exports2);
        global2.Long = preferDefault(exports2);
      })();
    }
  })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(_exports) {
    Object.defineProperty(_exports, "__esModule", {
      value: true
    });
    _exports.default = undefined;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch {}
    function Long(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", {
      value: true
    });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }
    Long.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (typeof unsigned === "number") {
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return unsigned ? UZERO : ZERO;
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p2 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0;i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, true);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isSafeInteger = function isSafeInteger() {
      var top11Bits = this.high >> 21;
      if (!top11Bits)
        return true;
      if (this.unsigned)
        return false;
      return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    if (typeof BigInt === "function") {
      Long.fromBigInt = function fromBigInt(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
      };
      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint")
          return Long.fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
      };
      LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return highBigInt << BigInt(32) | lowBigInt;
      };
    }
    var _default = _exports.default = Long;
  });
});

// ../../../../node_modules/mysql2/lib/parsers/string.js
var require_string2 = __commonJS((exports) => {
  var Iconv = require_lib2();
  var { createLRU } = require_lib11();
  var decoderCache = createLRU({
    max: 500
  });
  exports.decode = function(buffer, encoding, start, end, options) {
    if (Buffer.isEncoding(encoding)) {
      return buffer.toString(encoding, start, end);
    }
    let decoder;
    if (!options) {
      decoder = decoderCache.get(encoding);
      if (!decoder) {
        decoder = Iconv.getDecoder(encoding);
        decoderCache.set(encoding, decoder);
      }
    } else {
      const decoderArgs = { encoding, options };
      const decoderKey = JSON.stringify(decoderArgs);
      decoder = decoderCache.get(decoderKey);
      if (!decoder) {
        decoder = Iconv.getDecoder(decoderArgs.encoding, decoderArgs.options);
        decoderCache.set(decoderKey, decoder);
      }
    }
    const res = decoder.write(buffer.slice(start, end));
    const trail = decoder.end();
    return trail ? res + trail : res;
  };
  exports.encode = function(string, encoding, options) {
    if (Buffer.isEncoding(encoding)) {
      return Buffer.from(string, encoding);
    }
    const encoder = Iconv.getEncoder(encoding, options || {});
    const res = encoder.write(string);
    const trail = encoder.end();
    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
  };
});

// ../../../../node_modules/mysql2/lib/constants/types.js
var require_types2 = __commonJS((exports, module) => {
  module.exports = {
    0: "DECIMAL",
    1: "TINY",
    2: "SHORT",
    3: "LONG",
    4: "FLOAT",
    5: "DOUBLE",
    6: "NULL",
    7: "TIMESTAMP",
    8: "LONGLONG",
    9: "INT24",
    10: "DATE",
    11: "TIME",
    12: "DATETIME",
    13: "YEAR",
    14: "NEWDATE",
    15: "VARCHAR",
    16: "BIT",
    245: "JSON",
    246: "NEWDECIMAL",
    247: "ENUM",
    248: "SET",
    249: "TINY_BLOB",
    250: "MEDIUM_BLOB",
    251: "LONG_BLOB",
    252: "BLOB",
    253: "VAR_STRING",
    254: "STRING",
    255: "GEOMETRY"
  };
  module.exports.DECIMAL = 0;
  module.exports.TINY = 1;
  module.exports.SHORT = 2;
  module.exports.LONG = 3;
  module.exports.FLOAT = 4;
  module.exports.DOUBLE = 5;
  module.exports.NULL = 6;
  module.exports.TIMESTAMP = 7;
  module.exports.LONGLONG = 8;
  module.exports.INT24 = 9;
  module.exports.DATE = 10;
  module.exports.TIME = 11;
  module.exports.DATETIME = 12;
  module.exports.YEAR = 13;
  module.exports.NEWDATE = 14;
  module.exports.VARCHAR = 15;
  module.exports.BIT = 16;
  module.exports.VECTOR = 242;
  module.exports.JSON = 245;
  module.exports.NEWDECIMAL = 246;
  module.exports.ENUM = 247;
  module.exports.SET = 248;
  module.exports.TINY_BLOB = 249;
  module.exports.MEDIUM_BLOB = 250;
  module.exports.LONG_BLOB = 251;
  module.exports.BLOB = 252;
  module.exports.VAR_STRING = 253;
  module.exports.STRING = 254;
  module.exports.GEOMETRY = 255;
});

// ../../../../node_modules/mysql2/lib/packets/packet.js
var require_packet = __commonJS((exports, module) => {
  var ErrorCodeToName = require_errors();
  var NativeBuffer = __require("buffer").Buffer;
  var Long = require_umd();
  var StringParser = require_string2();
  var Types = require_types2();
  var INVALID_DATE = new Date(NaN);
  var pad = "000000000000";
  function leftPad(num, value) {
    const s = value.toString();
    if (s.length >= num) {
      return s;
    }
    return (pad + s).slice(-num);
  }
  var minus = 45;
  var plus = 43;
  var dot = 46;
  var exponent = 101;
  var exponentCapital = 69;

  class Packet {
    constructor(id, buffer, start, end) {
      this.sequenceId = id;
      this.numPackets = 1;
      this.buffer = buffer;
      this.start = start;
      this.offset = start + 4;
      this.end = end;
    }
    reset() {
      this.offset = this.start + 4;
    }
    length() {
      return this.end - this.start;
    }
    slice() {
      return this.buffer.slice(this.start, this.end);
    }
    dump() {
      console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);
    }
    haveMoreData() {
      return this.end > this.offset;
    }
    skip(num) {
      this.offset += num;
    }
    readInt8() {
      return this.buffer[this.offset++];
    }
    readInt16() {
      this.offset += 2;
      return this.buffer.readUInt16LE(this.offset - 2);
    }
    readInt24() {
      return this.readInt16() + (this.readInt8() << 16);
    }
    readInt32() {
      this.offset += 4;
      return this.buffer.readUInt32LE(this.offset - 4);
    }
    readSInt8() {
      return this.buffer.readInt8(this.offset++);
    }
    readSInt16() {
      this.offset += 2;
      return this.buffer.readInt16LE(this.offset - 2);
    }
    readSInt32() {
      this.offset += 4;
      return this.buffer.readInt32LE(this.offset - 4);
    }
    readInt64JSNumber() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const l = new Long(word0, word1, true);
      return l.toNumber();
    }
    readSInt64JSNumber() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      if (!(word1 & 2147483648)) {
        return word0 + 4294967296 * word1;
      }
      const l = new Long(word0, word1, false);
      return l.toNumber();
    }
    readInt64String() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const res = new Long(word0, word1, true);
      return res.toString();
    }
    readSInt64String() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      const res = new Long(word0, word1, false);
      return res.toString();
    }
    readInt64() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      let res = new Long(word0, word1, true);
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
    readSInt64() {
      const word0 = this.readInt32();
      const word1 = this.readInt32();
      let res = new Long(word0, word1, false);
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
    isEOF() {
      return this.buffer[this.offset] === 254 && this.length() < 13;
    }
    eofStatusFlags() {
      return this.buffer.readInt16LE(this.offset + 3);
    }
    eofWarningCount() {
      return this.buffer.readInt16LE(this.offset + 1);
    }
    readLengthCodedNumber(bigNumberStrings, signed) {
      const byte1 = this.buffer[this.offset++];
      if (byte1 < 251) {
        return byte1;
      }
      return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
    }
    readLengthCodedNumberSigned(bigNumberStrings) {
      return this.readLengthCodedNumber(bigNumberStrings, true);
    }
    readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
      let word0, word1;
      let res;
      if (tag === 251) {
        return null;
      }
      if (tag === 252) {
        return this.readInt8() + (this.readInt8() << 8);
      }
      if (tag === 253) {
        return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
      }
      if (tag === 254) {
        word0 = this.readInt32();
        word1 = this.readInt32();
        if (word1 === 0) {
          return word0;
        }
        if (word1 < 2097152) {
          return word1 * 4294967296 + word0;
        }
        res = new Long(word0, word1, !signed);
        const resNumber = res.toNumber();
        const resString = res.toString();
        res = resNumber.toString() === resString ? resNumber : resString;
        return bigNumberStrings ? resString : res;
      }
      console.trace();
      throw new Error(`Should not reach here: ${tag}`);
    }
    readFloat() {
      const res = this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return res;
    }
    readDouble() {
      const res = this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return res;
    }
    readBuffer(len) {
      if (typeof len === "undefined") {
        len = this.end - this.offset;
      }
      this.offset += len;
      return this.buffer.slice(this.offset - len, this.offset);
    }
    readDateTime(timezone) {
      if (!timezone || timezone === "Z" || timezone === "local") {
        const length = this.readInt8();
        if (length === 251) {
          return null;
        }
        let y = 0;
        let m = 0;
        let d = 0;
        let H = 0;
        let M = 0;
        let S = 0;
        let ms = 0;
        if (length > 3) {
          y = this.readInt16();
          m = this.readInt8();
          d = this.readInt8();
        }
        if (length > 6) {
          H = this.readInt8();
          M = this.readInt8();
          S = this.readInt8();
        }
        if (length > 10) {
          ms = this.readInt32() / 1000;
        }
        if (y + m + d + H + M + S + ms === 0) {
          return INVALID_DATE;
        }
        if (timezone === "Z") {
          return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));
        }
        return new Date(y, m - 1, d, H, M, S, ms);
      }
      let str = this.readDateTimeString(6, "T", null);
      if (str.length === 10) {
        str += "T00:00:00";
      }
      return new Date(str + timezone);
    }
    readDateTimeString(decimals, timeSep, columnType) {
      const length = this.readInt8();
      let y = 0;
      let m = 0;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms = 0;
      let str;
      if (length > 3) {
        y = this.readInt16();
        m = this.readInt8();
        d = this.readInt8();
        str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join("-");
      }
      if (length > 6) {
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
        str += `${timeSep || " "}${[
          leftPad(2, H),
          leftPad(2, M),
          leftPad(2, S)
        ].join(":")}`;
      } else if (columnType === Types.DATETIME) {
        str += " 00:00:00";
      }
      if (length > 10) {
        ms = this.readInt32();
        str += ".";
        if (decimals) {
          ms = leftPad(6, ms);
          if (ms.length > decimals) {
            ms = ms.substring(0, decimals);
          }
        }
        str += ms;
      }
      return str;
    }
    readTimeString(convertTtoMs) {
      const length = this.readInt8();
      if (length === 0) {
        return "00:00:00";
      }
      const sign = this.readInt8() ? -1 : 1;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms = 0;
      if (length > 6) {
        d = this.readInt32();
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
      }
      if (length > 10) {
        ms = this.readInt32();
      }
      if (convertTtoMs) {
        H += d * 24;
        M += H * 60;
        S += M * 60;
        ms += S * 1000;
        ms *= sign;
        return ms;
      }
      return (sign === -1 ? "-" : "") + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(":") + (ms ? `.${ms}`.replace(/0+$/, "") : "");
    }
    readLengthCodedString(encoding) {
      const len = this.readLengthCodedNumber();
      if (len === null) {
        return null;
      }
      this.offset += len;
      return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);
    }
    readLengthCodedBuffer() {
      const len = this.readLengthCodedNumber();
      if (len === null) {
        return null;
      }
      return this.readBuffer(len);
    }
    readNullTerminatedString(encoding) {
      const start = this.offset;
      let end = this.offset;
      while (this.buffer[end]) {
        end = end + 1;
      }
      this.offset = end + 1;
      return StringParser.decode(this.buffer, encoding, start, end);
    }
    readString(len, encoding) {
      if (typeof len === "string" && typeof encoding === "undefined") {
        encoding = len;
        len = undefined;
      }
      if (typeof len === "undefined") {
        len = this.end - this.offset;
      }
      this.offset += len;
      return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);
    }
    parseInt(len, supportBigNumbers) {
      if (len === null) {
        return null;
      }
      if (len >= 14 && !supportBigNumbers) {
        const s = this.buffer.toString("ascii", this.offset, this.offset + len);
        this.offset += len;
        return Number(s);
      }
      let result = 0;
      const start = this.offset;
      const end = this.offset + len;
      let sign = 1;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      }
      let str;
      const numDigits = end - this.offset;
      if (supportBigNumbers) {
        if (numDigits >= 15) {
          str = this.readString(end - this.offset, "binary");
          result = parseInt(str, 10);
          if (result.toString() === str) {
            return sign * result;
          }
          return sign === -1 ? `-${str}` : str;
        }
        if (numDigits > 16) {
          str = this.readString(end - this.offset);
          return sign === -1 ? `-${str}` : str;
        }
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }
      const num = result * sign;
      if (!supportBigNumbers) {
        return num;
      }
      str = this.buffer.toString("ascii", start, end);
      if (num.toString() === str) {
        return num;
      }
      return str;
    }
    parseIntNoBigCheck(len) {
      if (len === null) {
        return null;
      }
      let result = 0;
      const end = this.offset + len;
      let sign = 1;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }
      return result * sign;
    }
    parseGeometryValue() {
      const buffer = this.readLengthCodedBuffer();
      let offset = 4;
      if (buffer === null || !buffer.length) {
        return null;
      }
      function parseGeometry() {
        let x, y, i, j, numPoints, line;
        let result = null;
        const byteOrder = buffer.readUInt8(offset);
        offset += 1;
        const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
        offset += 4;
        switch (wkbType) {
          case 1:
            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            result = { x, y };
            break;
          case 2:
            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = numPoints;i > 0; i--) {
              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              result.push({ x, y });
            }
            break;
          case 3:
            const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = numRings;i > 0; i--) {
              numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
              offset += 4;
              line = [];
              for (j = numPoints;j > 0; j--) {
                x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                line.push({ x, y });
              }
              result.push(line);
            }
            break;
          case 4:
          case 5:
          case 6:
          case 7:
            const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (i = num;i > 0; i--) {
              result.push(parseGeometry());
            }
            break;
        }
        return result;
      }
      return parseGeometry();
    }
    parseVector() {
      const bufLen = this.readLengthCodedNumber();
      const vectorEnd = this.offset + bufLen;
      const result = [];
      while (this.offset < vectorEnd && this.offset < this.end) {
        result.push(this.readFloat());
      }
      return result;
    }
    parseDate(timezone) {
      const strLen = this.readLengthCodedNumber();
      if (strLen === null) {
        return null;
      }
      if (strLen !== 10) {
        return new Date(NaN);
      }
      const y = this.parseInt(4);
      this.offset++;
      const m = this.parseInt(2);
      this.offset++;
      const d = this.parseInt(2);
      if (!timezone || timezone === "local") {
        return new Date(y, m - 1, d);
      }
      if (timezone === "Z") {
        return new Date(Date.UTC(y, m - 1, d));
      }
      return new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);
    }
    parseDateTime(timezone) {
      const str = this.readLengthCodedString("binary");
      if (str === null) {
        return null;
      }
      if (!timezone || timezone === "local") {
        return new Date(str);
      }
      return new Date(`${str}${timezone}`);
    }
    parseFloat(len) {
      if (len === null) {
        return null;
      }
      let result = 0;
      const end = this.offset + len;
      let factor = 1;
      let pastDot = false;
      let charCode = 0;
      if (len === 0) {
        return 0;
      }
      if (this.buffer[this.offset] === minus) {
        this.offset++;
        factor = -1;
      }
      if (this.buffer[this.offset] === plus) {
        this.offset++;
      }
      while (this.offset < end) {
        charCode = this.buffer[this.offset];
        if (charCode === dot) {
          pastDot = true;
          this.offset++;
        } else if (charCode === exponent || charCode === exponentCapital) {
          this.offset++;
          const exponentValue = this.parseInt(end - this.offset);
          return result / factor * Math.pow(10, exponentValue);
        } else {
          result *= 10;
          result += this.buffer[this.offset] - 48;
          this.offset++;
          if (pastDot) {
            factor = factor * 10;
          }
        }
      }
      return result / factor;
    }
    parseLengthCodedIntNoBigCheck() {
      return this.parseIntNoBigCheck(this.readLengthCodedNumber());
    }
    parseLengthCodedInt(supportBigNumbers) {
      return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
    }
    parseLengthCodedIntString() {
      return this.readLengthCodedString("binary");
    }
    parseLengthCodedFloat() {
      return this.parseFloat(this.readLengthCodedNumber());
    }
    peekByte() {
      return this.buffer[this.offset];
    }
    isAlt() {
      return this.peekByte() === 254;
    }
    isError() {
      return this.peekByte() === 255;
    }
    asError(encoding) {
      this.reset();
      this.readInt8();
      const errorCode = this.readInt16();
      let sqlState = "";
      if (this.buffer[this.offset] === 35) {
        this.skip(1);
        sqlState = this.readBuffer(5).toString();
      }
      const message = this.readString(undefined, encoding);
      const err2 = new Error(message);
      err2.code = ErrorCodeToName[errorCode];
      err2.errno = errorCode;
      err2.sqlState = sqlState;
      err2.sqlMessage = message;
      return err2;
    }
    writeInt32(n) {
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
    }
    writeInt24(n) {
      this.writeInt8(n & 255);
      this.writeInt16(n >> 8);
    }
    writeInt16(n) {
      this.buffer.writeUInt16LE(n, this.offset);
      this.offset += 2;
    }
    writeInt8(n) {
      this.buffer.writeUInt8(n, this.offset);
      this.offset++;
    }
    writeDouble(n) {
      this.buffer.writeDoubleLE(n, this.offset);
      this.offset += 8;
    }
    writeBuffer(b) {
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
    writeNull() {
      this.buffer[this.offset] = 251;
      this.offset++;
    }
    writeNullTerminatedString(s, encoding) {
      const buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
      this.writeInt8(0);
    }
    writeString(s, encoding) {
      if (s === null) {
        this.writeInt8(251);
        return;
      }
      if (s.length === 0) {
        return;
      }
      const buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
    writeLengthCodedString(s, encoding) {
      const buf = StringParser.encode(s, encoding);
      this.writeLengthCodedNumber(buf.length);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
    writeLengthCodedBuffer(b) {
      this.writeLengthCodedNumber(b.length);
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
    writeLengthCodedNumber(n) {
      if (n < 251) {
        return this.writeInt8(n);
      }
      if (n < 65535) {
        this.writeInt8(252);
        return this.writeInt16(n);
      }
      if (n < 16777215) {
        this.writeInt8(253);
        return this.writeInt24(n);
      }
      if (n === null) {
        return this.writeInt8(251);
      }
      this.writeInt8(254);
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
      this.buffer.writeUInt32LE(n >> 32, this.offset);
      this.offset += 4;
      return this.offset;
    }
    writeDate(d, timezone) {
      this.buffer.writeUInt8(11, this.offset);
      if (!timezone || timezone === "local") {
        this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);
      } else {
        if (timezone !== "Z") {
          const offset = (timezone[0] === "-" ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));
          if (offset !== 0) {
            d = new Date(d.getTime() + 60000 * offset);
          }
        }
        this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);
      }
      this.offset += 12;
    }
    writeHeader(sequenceId) {
      const offset = this.offset;
      this.offset = 0;
      this.writeInt24(this.buffer.length - 4);
      this.writeInt8(sequenceId);
      this.offset = offset;
    }
    clone() {
      return new Packet(this.sequenceId, this.buffer, this.start, this.end);
    }
    type() {
      if (this.isEOF()) {
        return "EOF";
      }
      if (this.isError()) {
        return "Error";
      }
      if (this.buffer[this.offset] === 0) {
        return "maybeOK";
      }
      return "";
    }
    static lengthCodedNumberLength(n) {
      if (n < 251) {
        return 1;
      }
      if (n < 65535) {
        return 3;
      }
      if (n < 16777215) {
        return 5;
      }
      return 9;
    }
    static lengthCodedStringLength(str, encoding) {
      const buf = StringParser.encode(str, encoding);
      const slen = buf.length;
      return Packet.lengthCodedNumberLength(slen) + slen;
    }
    static MockBuffer() {
      const noop2 = function() {};
      const res = Buffer.alloc(0);
      for (const op in NativeBuffer.prototype) {
        if (typeof res[op] === "function") {
          res[op] = noop2;
        }
      }
      return res;
    }
  }
  module.exports = Packet;
});

// ../../../../node_modules/mysql2/lib/packet_parser.js
var require_packet_parser = __commonJS((exports, module) => {
  var Packet = require_packet();
  var MAX_PACKET_LENGTH = 16777215;
  function readPacketLength(b, off2) {
    const b0 = b[off2];
    const b1 = b[off2 + 1];
    const b2 = b[off2 + 2];
    if (b1 + b2 === 0) {
      return b0;
    }
    return b0 + (b1 << 8) + (b2 << 16);
  }

  class PacketParser {
    constructor(onPacket, packetHeaderLength) {
      if (typeof packetHeaderLength === "undefined") {
        packetHeaderLength = 4;
      }
      this.buffer = [];
      this.bufferLength = 0;
      this.packetHeaderLength = packetHeaderLength;
      this.headerLen = 0;
      this.length = 0;
      this.largePacketParts = [];
      this.firstPacketSequenceId = 0;
      this.onPacket = onPacket;
      this.execute = PacketParser.prototype.executeStart;
      this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;
    }
    _flushLargePacket4() {
      const numPackets = this.largePacketParts.length;
      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0]));
      const body = Buffer.concat(this.largePacketParts);
      const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);
      this.largePacketParts.length = 0;
      packet.numPackets = numPackets;
      this.onPacket(packet);
    }
    _flushLargePacket7() {
      const numPackets = this.largePacketParts.length;
      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0]));
      const body = Buffer.concat(this.largePacketParts);
      this.largePacketParts.length = 0;
      const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);
      packet.numPackets = numPackets;
      this.onPacket(packet);
    }
    executeStart(chunk) {
      let start = 0;
      const end = chunk.length;
      while (end - start >= 3) {
        this.length = readPacketLength(chunk, start);
        if (end - start >= this.length + this.packetHeaderLength) {
          const sequenceId = chunk[start + 3];
          if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {
            this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));
          } else {
            if (this.largePacketParts.length === 0) {
              this.firstPacketSequenceId = sequenceId;
            }
            this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));
            if (this.length < MAX_PACKET_LENGTH) {
              this._flushLargePacket();
            }
          }
          start += this.packetHeaderLength + this.length;
        } else {
          this.buffer = [chunk.slice(start + 3, end)];
          this.bufferLength = end - start - 3;
          this.execute = PacketParser.prototype.executePayload;
          return;
        }
      }
      if (end - start > 0) {
        this.headerLen = end - start;
        this.length = chunk[start];
        if (this.headerLen === 2) {
          this.length = chunk[start] + (chunk[start + 1] << 8);
          this.execute = PacketParser.prototype.executeHeader3;
        } else {
          this.execute = PacketParser.prototype.executeHeader2;
        }
      }
    }
    executePayload(chunk) {
      let start = 0;
      const end = chunk.length;
      const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;
      if (end - start >= remainingPayload) {
        const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);
        let offset = 3;
        for (let i = 0;i < this.buffer.length; ++i) {
          this.buffer[i].copy(payload, offset);
          offset += this.buffer[i].length;
        }
        chunk.copy(payload, offset, start, start + remainingPayload);
        const sequenceId = payload[3];
        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {
          this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));
        } else {
          if (this.largePacketParts.length === 0) {
            this.firstPacketSequenceId = sequenceId;
          }
          this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));
          if (this.length < MAX_PACKET_LENGTH) {
            this._flushLargePacket();
          }
        }
        this.buffer = [];
        this.bufferLength = 0;
        this.execute = PacketParser.prototype.executeStart;
        start += remainingPayload;
        if (end - start > 0) {
          return this.execute(chunk.slice(start, end));
        }
      } else {
        this.buffer.push(chunk);
        this.bufferLength += chunk.length;
      }
      return null;
    }
    executeHeader2(chunk) {
      this.length += chunk[0] << 8;
      if (chunk.length > 1) {
        this.length += chunk[1] << 16;
        this.execute = PacketParser.prototype.executePayload;
        return this.executePayload(chunk.slice(2));
      }
      this.execute = PacketParser.prototype.executeHeader3;
      return null;
    }
    executeHeader3(chunk) {
      this.length += chunk[0] << 16;
      this.execute = PacketParser.prototype.executePayload;
      return this.executePayload(chunk.slice(1));
    }
  }
  module.exports = PacketParser;
});

// ../../../../node_modules/mysql2/lib/packets/auth_next_factor.js
var require_auth_next_factor = __commonJS((exports, module) => {
  var Packet = require_packet();

  class AuthNextFactor {
    constructor(opts) {
      this.pluginName = opts.pluginName;
      this.pluginData = opts.pluginData;
    }
    toPacket(encoding) {
      const length = 6 + this.pluginName.length + this.pluginData.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(2);
      packet.writeNullTerminatedString(this.pluginName, encoding);
      packet.writeBuffer(this.pluginData);
      return packet;
    }
    static fromPacket(packet, encoding) {
      packet.readInt8();
      const name = packet.readNullTerminatedString(encoding);
      const data = packet.readBuffer();
      return new AuthNextFactor({
        pluginName: name,
        pluginData: data
      });
    }
  }
  module.exports = AuthNextFactor;
});

// ../../../../node_modules/mysql2/lib/packets/auth_switch_request.js
var require_auth_switch_request = __commonJS((exports, module) => {
  var Packet = require_packet();

  class AuthSwitchRequest {
    constructor(opts) {
      this.pluginName = opts.pluginName;
      this.pluginData = opts.pluginData;
    }
    toPacket() {
      const length = 6 + this.pluginName.length + this.pluginData.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(254);
      packet.writeNullTerminatedString(this.pluginName, "cesu8");
      packet.writeBuffer(this.pluginData);
      return packet;
    }
    static fromPacket(packet) {
      packet.readInt8();
      const name = packet.readNullTerminatedString("cesu8");
      const data = packet.readBuffer();
      return new AuthSwitchRequest({
        pluginName: name,
        pluginData: data
      });
    }
  }
  module.exports = AuthSwitchRequest;
});

// ../../../../node_modules/mysql2/lib/packets/auth_switch_request_more_data.js
var require_auth_switch_request_more_data = __commonJS((exports, module) => {
  var Packet = require_packet();

  class AuthSwitchRequestMoreData {
    constructor(data) {
      this.data = data;
    }
    toPacket() {
      const length = 5 + this.data.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(1);
      packet.writeBuffer(this.data);
      return packet;
    }
    static fromPacket(packet) {
      packet.readInt8();
      const data = packet.readBuffer();
      return new AuthSwitchRequestMoreData(data);
    }
    static verifyMarker(packet) {
      return packet.peekByte() === 1;
    }
  }
  module.exports = AuthSwitchRequestMoreData;
});

// ../../../../node_modules/mysql2/lib/packets/auth_switch_response.js
var require_auth_switch_response = __commonJS((exports, module) => {
  var Packet = require_packet();

  class AuthSwitchResponse {
    constructor(data) {
      if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
      }
      this.data = data;
    }
    toPacket() {
      const length = 4 + this.data.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeBuffer(this.data);
      return packet;
    }
    static fromPacket(packet) {
      const data = packet.readBuffer();
      return new AuthSwitchResponse(data);
    }
  }
  module.exports = AuthSwitchResponse;
});

// ../../../../node_modules/mysql2/lib/packets/binary_row.js
var require_binary_row = __commonJS((exports, module) => {
  var Types = require_types2();
  var Packet = require_packet();
  var binaryReader = new Array(256);

  class BinaryRow {
    constructor(columns) {
      this.columns = columns || [];
    }
    static toPacket(columns, encoding) {
      const sequenceId = 0;
      let length = 0;
      columns.forEach((val) => {
        if (val === null || typeof val === "undefined") {
          ++length;
          return;
        }
        length += Packet.lengthCodedStringLength(val.toString(10), encoding);
      });
      length = length + 2;
      const buffer = Buffer.allocUnsafe(length + 4);
      const packet = new Packet(sequenceId, buffer, 0, length + 4);
      packet.offset = 4;
      packet.writeInt8(0);
      let bitmap = 0;
      let bitValue = 1;
      columns.forEach((parameter) => {
        if (parameter.type === Types.NULL) {
          bitmap += bitValue;
        }
        bitValue *= 2;
        if (bitValue === 256) {
          packet.writeInt8(bitmap);
          bitmap = 0;
          bitValue = 1;
        }
      });
      if (bitValue !== 1) {
        packet.writeInt8(bitmap);
      }
      columns.forEach((val) => {
        if (val === null) {
          packet.writeNull();
          return;
        }
        if (typeof val === "undefined") {
          packet.writeInt8(0);
          return;
        }
        packet.writeLengthCodedString(val.toString(10), encoding);
      });
      return packet;
    }
    static fromPacket(fields, packet) {
      const columns = new Array(fields.length);
      packet.readInt8();
      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
      packet.skip(nullBitmapLength);
      for (let i = 0;i < columns.length; ++i) {
        columns[i] = binaryReader[fields[i].columnType].apply(packet);
      }
      return new BinaryRow(columns);
    }
  }
  binaryReader[Types.DECIMAL] = Packet.prototype.readLengthCodedString;
  binaryReader[1] = Packet.prototype.readInt8;
  binaryReader[2] = Packet.prototype.readInt16;
  binaryReader[3] = Packet.prototype.readInt32;
  binaryReader[4] = Packet.prototype.readFloat;
  binaryReader[5] = Packet.prototype.readDouble;
  binaryReader[6] = Packet.prototype.assertInvalid;
  binaryReader[7] = Packet.prototype.readTimestamp;
  binaryReader[8] = Packet.prototype.readInt64;
  binaryReader[9] = Packet.prototype.readInt32;
  binaryReader[10] = Packet.prototype.readTimestamp;
  binaryReader[11] = Packet.prototype.readTime;
  binaryReader[12] = Packet.prototype.readDateTime;
  binaryReader[13] = Packet.prototype.readInt16;
  binaryReader[Types.VAR_STRING] = Packet.prototype.readLengthCodedString;
  module.exports = BinaryRow;
});

// ../../../../node_modules/mysql2/lib/constants/commands.js
var require_commands = __commonJS((exports, module) => {
  module.exports = {
    SLEEP: 0,
    QUIT: 1,
    INIT_DB: 2,
    QUERY: 3,
    FIELD_LIST: 4,
    CREATE_DB: 5,
    DROP_DB: 6,
    REFRESH: 7,
    SHUTDOWN: 8,
    STATISTICS: 9,
    PROCESS_INFO: 10,
    CONNECT: 11,
    PROCESS_KILL: 12,
    DEBUG: 13,
    PING: 14,
    TIME: 15,
    DELAYED_INSERT: 16,
    CHANGE_USER: 17,
    BINLOG_DUMP: 18,
    TABLE_DUMP: 19,
    CONNECT_OUT: 20,
    REGISTER_SLAVE: 21,
    STMT_PREPARE: 22,
    STMT_EXECUTE: 23,
    STMT_SEND_LONG_DATA: 24,
    STMT_CLOSE: 25,
    STMT_RESET: 26,
    SET_OPTION: 27,
    STMT_FETCH: 28,
    DAEMON: 29,
    BINLOG_DUMP_GTID: 30,
    UNKNOWN: 255
  };
});

// ../../../../node_modules/mysql2/lib/packets/binlog_dump.js
var require_binlog_dump = __commonJS((exports, module) => {
  var Packet = require_packet();
  var CommandCodes = require_commands();

  class BinlogDump {
    constructor(opts) {
      this.binlogPos = opts.binlogPos || 0;
      this.serverId = opts.serverId || 0;
      this.flags = opts.flags || 0;
      this.filename = opts.filename || "";
    }
    toPacket() {
      const length = 15 + Buffer.byteLength(this.filename, "utf8");
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.BINLOG_DUMP);
      packet.writeInt32(this.binlogPos);
      packet.writeInt16(this.flags);
      packet.writeInt32(this.serverId);
      packet.writeString(this.filename);
      return packet;
    }
  }
  module.exports = BinlogDump;
});

// ../../../../node_modules/mysql2/lib/auth_41.js
var require_auth_41 = __commonJS((exports) => {
  var crypto = __require("crypto");
  function sha1(msg, msg1, msg2) {
    const hash = crypto.createHash("sha1");
    hash.update(msg);
    if (msg1) {
      hash.update(msg1);
    }
    if (msg2) {
      hash.update(msg2);
    }
    return hash.digest();
  }
  function xor(a, b) {
    const result = Buffer.allocUnsafe(a.length);
    for (let i = 0;i < a.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return result;
  }
  exports.xor = xor;
  function token(password, scramble1, scramble2) {
    if (!password) {
      return Buffer.alloc(0);
    }
    const stage1 = sha1(password);
    return exports.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);
  }
  exports.calculateTokenFromPasswordSha = function(passwordSha, scramble1, scramble2) {
    const authPluginData1 = scramble1.slice(0, 8);
    const authPluginData2 = scramble2.slice(0, 12);
    const stage2 = sha1(passwordSha);
    const stage3 = sha1(authPluginData1, authPluginData2, stage2);
    return xor(stage3, passwordSha);
  };
  exports.calculateToken = token;
  exports.verifyToken = function(publicSeed1, publicSeed2, token2, doubleSha) {
    const hashStage1 = xor(token2, sha1(publicSeed1, publicSeed2, doubleSha));
    const candidateHash2 = sha1(hashStage1);
    return candidateHash2.compare(doubleSha) === 0;
  };
  exports.doubleSha1 = function(password) {
    return sha1(sha1(password));
  };
  function xorRotating(a, seed) {
    const result = Buffer.allocUnsafe(a.length);
    const seedLen = seed.length;
    for (let i = 0;i < a.length; i++) {
      result[i] = a[i] ^ seed[i % seedLen];
    }
    return result;
  }
  exports.xorRotating = xorRotating;
});

// ../../../../node_modules/mysql2/lib/constants/charset_encodings.js
var require_charset_encodings = __commonJS((exports, module) => {
  module.exports = [
    "utf8",
    "big5",
    "latin2",
    "dec8",
    "cp850",
    "latin1",
    "hp8",
    "koi8r",
    "latin1",
    "latin2",
    "swe7",
    "ascii",
    "eucjp",
    "sjis",
    "cp1251",
    "latin1",
    "hebrew",
    "utf8",
    "tis620",
    "euckr",
    "latin7",
    "latin2",
    "koi8u",
    "cp1251",
    "gb2312",
    "greek",
    "cp1250",
    "latin2",
    "gbk",
    "cp1257",
    "latin5",
    "latin1",
    "armscii8",
    "cesu8",
    "cp1250",
    "ucs2",
    "cp866",
    "keybcs2",
    "macintosh",
    "macroman",
    "cp852",
    "latin7",
    "latin7",
    "macintosh",
    "cp1250",
    "utf8",
    "utf8",
    "latin1",
    "latin1",
    "latin1",
    "cp1251",
    "cp1251",
    "cp1251",
    "macroman",
    "utf16",
    "utf16",
    "utf16-le",
    "cp1256",
    "cp1257",
    "cp1257",
    "utf32",
    "utf32",
    "utf16-le",
    "binary",
    "armscii8",
    "ascii",
    "cp1250",
    "cp1256",
    "cp866",
    "dec8",
    "greek",
    "hebrew",
    "hp8",
    "keybcs2",
    "koi8r",
    "koi8u",
    "cesu8",
    "latin2",
    "latin5",
    "latin7",
    "cp850",
    "cp852",
    "swe7",
    "cesu8",
    "big5",
    "euckr",
    "gb2312",
    "gbk",
    "sjis",
    "tis620",
    "ucs2",
    "eucjp",
    "geostd8",
    "geostd8",
    "latin1",
    "cp932",
    "cp932",
    "eucjpms",
    "eucjpms",
    "cp1250",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf16",
    "utf8",
    "utf8",
    "utf8",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "ucs2",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "ucs2",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf32",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "cesu8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "cesu8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "gb18030",
    "gb18030",
    "gb18030",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8",
    "utf8"
  ];
});

// ../../../../node_modules/mysql2/lib/packets/change_user.js
var require_change_user = __commonJS((exports, module) => {
  var CommandCode = require_commands();
  var ClientConstants = require_client();
  var Packet = require_packet();
  var auth41 = require_auth_41();
  var CharsetToEncoding = require_charset_encodings();

  class ChangeUser {
    constructor(opts) {
      this.flags = opts.flags;
      this.user = opts.user || "";
      this.database = opts.database || "";
      this.password = opts.password || "";
      this.passwordSha1 = opts.passwordSha1;
      this.authPluginData1 = opts.authPluginData1;
      this.authPluginData2 = opts.authPluginData2;
      this.connectAttributes = opts.connectAttrinutes || {};
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, this.authPluginData1, this.authPluginData2);
      } else {
        authToken = auth41.calculateToken(this.password, this.authPluginData1, this.authPluginData2);
      }
      this.authToken = authToken;
      this.charsetNumber = opts.charsetNumber;
    }
    serializeToBuffer(buffer) {
      const isSet = (flag) => this.flags & ClientConstants[flag];
      const packet = new Packet(0, buffer, 0, buffer.length);
      packet.offset = 4;
      const encoding = CharsetToEncoding[this.charsetNumber];
      packet.writeInt8(CommandCode.CHANGE_USER);
      packet.writeNullTerminatedString(this.user, encoding);
      if (isSet("SECURE_CONNECTION")) {
        packet.writeInt8(this.authToken.length);
        packet.writeBuffer(this.authToken);
      } else {
        packet.writeBuffer(this.authToken);
        packet.writeInt8(0);
      }
      packet.writeNullTerminatedString(this.database, encoding);
      packet.writeInt16(this.charsetNumber);
      if (isSet("PLUGIN_AUTH")) {
        packet.writeNullTerminatedString("mysql_native_password", "latin1");
      }
      if (isSet("CONNECT_ATTRS")) {
        const connectAttributes = this.connectAttributes;
        const attrNames = Object.keys(connectAttributes);
        let keysLength = 0;
        for (let k = 0;k < attrNames.length; ++k) {
          keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
          keysLength += Packet.lengthCodedStringLength(connectAttributes[attrNames[k]], encoding);
        }
        packet.writeLengthCodedNumber(keysLength);
        for (let k = 0;k < attrNames.length; ++k) {
          packet.writeLengthCodedString(attrNames[k], encoding);
          packet.writeLengthCodedString(connectAttributes[attrNames[k]], encoding);
        }
      }
      return packet;
    }
    toPacket() {
      if (typeof this.user !== "string") {
        throw new Error('"user" connection config property must be a string');
      }
      if (typeof this.database !== "string") {
        throw new Error('"database" connection config property must be a string');
      }
      const p2 = this.serializeToBuffer(Packet.MockBuffer());
      return this.serializeToBuffer(Buffer.allocUnsafe(p2.offset));
    }
  }
  module.exports = ChangeUser;
});

// ../../../../node_modules/mysql2/lib/packets/close_statement.js
var require_close_statement = __commonJS((exports, module) => {
  var Packet = require_packet();
  var CommandCodes = require_commands();

  class CloseStatement {
    constructor(id) {
      this.id = id;
    }
    toPacket() {
      const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.STMT_CLOSE);
      packet.writeInt32(this.id);
      return packet;
    }
  }
  module.exports = CloseStatement;
});

// ../../../../node_modules/mysql2/lib/constants/field_flags.js
var require_field_flags = __commonJS((exports) => {
  exports.NOT_NULL = 1;
  exports.PRI_KEY = 2;
  exports.UNIQUE_KEY = 4;
  exports.MULTIPLE_KEY = 8;
  exports.BLOB = 16;
  exports.UNSIGNED = 32;
  exports.ZEROFILL = 64;
  exports.BINARY = 128;
  exports.ENUM = 256;
  exports.AUTO_INCREMENT = 512;
  exports.TIMESTAMP = 1024;
  exports.SET = 2048;
  exports.NO_DEFAULT_VALUE = 4096;
  exports.ON_UPDATE_NOW = 8192;
  exports.NUM = 32768;
});

// ../../../../node_modules/mysql2/lib/packets/column_definition.js
var require_column_definition = __commonJS((exports, module) => {
  var Packet = require_packet();
  var StringParser = require_string2();
  var CharsetToEncoding = require_charset_encodings();
  var fields = ["catalog", "schema", "table", "orgTable", "name", "orgName"];

  class ColumnDefinition {
    constructor(packet, clientEncoding) {
      this._buf = packet.buffer;
      this._clientEncoding = clientEncoding;
      this._catalogLength = packet.readLengthCodedNumber();
      this._catalogStart = packet.offset;
      packet.offset += this._catalogLength;
      this._schemaLength = packet.readLengthCodedNumber();
      this._schemaStart = packet.offset;
      packet.offset += this._schemaLength;
      this._tableLength = packet.readLengthCodedNumber();
      this._tableStart = packet.offset;
      packet.offset += this._tableLength;
      this._orgTableLength = packet.readLengthCodedNumber();
      this._orgTableStart = packet.offset;
      packet.offset += this._orgTableLength;
      const _nameLength = packet.readLengthCodedNumber();
      const _nameStart = packet.offset;
      packet.offset += _nameLength;
      this._orgNameLength = packet.readLengthCodedNumber();
      this._orgNameStart = packet.offset;
      packet.offset += this._orgNameLength;
      packet.skip(1);
      this.characterSet = packet.readInt16();
      this.encoding = CharsetToEncoding[this.characterSet];
      this.name = StringParser.decode(this._buf, this.encoding === "binary" ? this._clientEncoding : this.encoding, _nameStart, _nameStart + _nameLength);
      this.columnLength = packet.readInt32();
      this.columnType = packet.readInt8();
      this.type = this.columnType;
      this.flags = packet.readInt16();
      this.decimals = packet.readInt8();
    }
    inspect() {
      return {
        catalog: this.catalog,
        schema: this.schema,
        name: this.name,
        orgName: this.orgName,
        table: this.table,
        orgTable: this.orgTable,
        characterSet: this.characterSet,
        encoding: this.encoding,
        columnLength: this.columnLength,
        type: this.columnType,
        flags: this.flags,
        decimals: this.decimals
      };
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, inspectOptions, inspect) {
      const Types = require_types2();
      const typeNames = [];
      for (const t in Types) {
        typeNames[Types[t]] = t;
      }
      const fiedFlags = require_field_flags();
      const flagNames = [];
      const inspectFlags = this.flags;
      for (const f in fiedFlags) {
        if (inspectFlags & fiedFlags[f]) {
          if (f === "PRI_KEY") {
            flagNames.push("PRIMARY KEY");
          } else if (f === "NOT_NULL") {
            flagNames.push("NOT NULL");
          } else if (f === "BINARY") {} else if (f === "MULTIPLE_KEY") {} else if (f === "NO_DEFAULT_VALUE") {} else if (f === "BLOB") {} else if (f === "UNSIGNED") {} else if (f === "TIMESTAMP") {} else if (f === "ON_UPDATE_NOW") {
            flagNames.push("ON UPDATE CURRENT_TIMESTAMP");
          } else {
            flagNames.push(f);
          }
        }
      }
      if (depth > 1) {
        return inspect({
          ...this.inspect(),
          typeName: typeNames[this.columnType],
          flags: flagNames
        });
      }
      const isUnsigned = this.flags & fiedFlags.UNSIGNED;
      let typeName = typeNames[this.columnType];
      if (typeName === "BLOB") {
        if (this.columnLength === 4294967295) {
          typeName = "LONGTEXT";
        } else if (this.columnLength === 67108860) {
          typeName = "MEDIUMTEXT";
        } else if (this.columnLength === 262140) {
          typeName = "TEXT";
        } else if (this.columnLength === 1020) {
          typeName = "TINYTEXT";
        } else {
          typeName = `BLOB(${this.columnLength})`;
        }
      } else if (typeName === "VAR_STRING") {
        typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;
      } else if (typeName === "TINY") {
        if (this.columnLength === 3 && isUnsigned || this.columnLength === 4 && !isUnsigned) {
          typeName = "TINYINT";
        } else {
          typeName = `TINYINT(${this.columnLength})`;
        }
      } else if (typeName === "LONGLONG") {
        if (this.columnLength === 20) {
          typeName = "BIGINT";
        } else {
          typeName = `BIGINT(${this.columnLength})`;
        }
      } else if (typeName === "SHORT") {
        if (isUnsigned && this.columnLength === 5) {
          typeName = "SMALLINT";
        } else if (!isUnsigned && this.columnLength === 6) {
          typeName = "SMALLINT";
        } else {
          typeName = `SMALLINT(${this.columnLength})`;
        }
      } else if (typeName === "LONG") {
        if (isUnsigned && this.columnLength === 10) {
          typeName = "INT";
        } else if (!isUnsigned && this.columnLength === 11) {
          typeName = "INT";
        } else {
          typeName = `INT(${this.columnLength})`;
        }
      } else if (typeName === "INT24") {
        if (isUnsigned && this.columnLength === 8) {
          typeName = "MEDIUMINT";
        } else if (!isUnsigned && this.columnLength === 9) {
          typeName = "MEDIUMINT";
        } else {
          typeName = `MEDIUMINT(${this.columnLength})`;
        }
      } else if (typeName === "DOUBLE") {
        if (this.columnLength === 22 && this.decimals === 31) {
          typeName = "DOUBLE";
        } else {
          typeName = `DOUBLE(${this.columnLength},${this.decimals})`;
        }
      } else if (typeName === "FLOAT") {
        if (this.columnLength === 12 && this.decimals === 31) {
          typeName = "FLOAT";
        } else {
          typeName = `FLOAT(${this.columnLength},${this.decimals})`;
        }
      } else if (typeName === "NEWDECIMAL") {
        if (this.columnLength === 11 && this.decimals === 0) {
          typeName = "DECIMAL";
        } else if (this.decimals === 0) {
          if (isUnsigned) {
            typeName = `DECIMAL(${this.columnLength})`;
          } else {
            typeName = `DECIMAL(${this.columnLength - 1})`;
          }
        } else {
          typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;
        }
      } else {
        typeName = `${typeNames[this.columnType]}(${this.columnLength})`;
      }
      if (isUnsigned) {
        typeName += " UNSIGNED";
      }
      return `\`${this.name}\` ${[typeName, ...flagNames].join(" ")}`;
    }
    static toPacket(column, sequenceId) {
      let length = 17;
      fields.forEach((field) => {
        length += Packet.lengthCodedStringLength(column[field], CharsetToEncoding[column.characterSet]);
      });
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(sequenceId, buffer, 0, length);
      function writeField(name) {
        packet.writeLengthCodedString(column[name], CharsetToEncoding[column.characterSet]);
      }
      packet.offset = 4;
      fields.forEach(writeField);
      packet.writeInt8(12);
      packet.writeInt16(column.characterSet);
      packet.writeInt32(column.columnLength);
      packet.writeInt8(column.columnType);
      packet.writeInt16(column.flags);
      packet.writeInt8(column.decimals);
      packet.writeInt16(0);
      return packet;
    }
    get db() {
      return this.schema;
    }
  }
  var addString = function(name) {
    Object.defineProperty(ColumnDefinition.prototype, name, {
      get: function() {
        const start = this[`_${name}Start`];
        const end = start + this[`_${name}Length`];
        const val = StringParser.decode(this._buf, this.encoding === "binary" ? this._clientEncoding : this.encoding, start, end);
        Object.defineProperty(this, name, {
          value: val,
          writable: false,
          configurable: false,
          enumerable: false
        });
        return val;
      }
    });
  };
  addString("catalog");
  addString("schema");
  addString("table");
  addString("orgTable");
  addString("orgName");
  module.exports = ColumnDefinition;
});

// ../../../../node_modules/mysql2/lib/constants/cursor.js
var require_cursor = __commonJS((exports, module) => {
  module.exports = {
    NO_CURSOR: 0,
    READ_ONLY: 1,
    FOR_UPDATE: 2,
    SCROLLABLE: 3
  };
});

// ../../../../node_modules/mysql2/lib/packets/execute.js
var require_execute = __commonJS((exports, module) => {
  var CursorType = require_cursor();
  var CommandCodes = require_commands();
  var Types = require_types2();
  var Packet = require_packet();
  var CharsetToEncoding = require_charset_encodings();
  function isJSON(value) {
    return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === "function" && !Buffer.isBuffer(value);
  }
  function toParameter(value, encoding, timezone) {
    let type = Types.VAR_STRING;
    let length;
    let writer = function(value2) {
      return Packet.prototype.writeLengthCodedString.call(this, value2, encoding);
    };
    if (value !== null) {
      switch (typeof value) {
        case "undefined":
          throw new TypeError("Bind parameters must not contain undefined");
        case "number":
          type = Types.DOUBLE;
          length = 8;
          writer = Packet.prototype.writeDouble;
          break;
        case "boolean":
          value = value | 0;
          type = Types.TINY;
          length = 1;
          writer = Packet.prototype.writeInt8;
          break;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            type = Types.DATETIME;
            length = 12;
            writer = function(value2) {
              return Packet.prototype.writeDate.call(this, value2, timezone);
            };
          } else if (isJSON(value)) {
            value = JSON.stringify(value);
            type = Types.JSON;
          } else if (Buffer.isBuffer(value)) {
            length = Packet.lengthCodedNumberLength(value.length) + value.length;
            writer = Packet.prototype.writeLengthCodedBuffer;
          }
          break;
        default:
          value = value.toString();
      }
    } else {
      value = "";
      type = Types.NULL;
    }
    if (!length) {
      length = Packet.lengthCodedStringLength(value, encoding);
    }
    return { value, type, length, writer };
  }

  class Execute {
    constructor(id, parameters, charsetNumber, timezone) {
      this.id = id;
      this.parameters = parameters;
      this.encoding = CharsetToEncoding[charsetNumber];
      this.timezone = timezone;
    }
    static fromPacket(packet, encoding) {
      const stmtId = packet.readInt32();
      const flags = packet.readInt8();
      const iterationCount = packet.readInt32();
      let i = packet.offset;
      while (i < packet.end - 1) {
        if ((packet.buffer[i + 1] === Types.VAR_STRING || packet.buffer[i + 1] === Types.NULL || packet.buffer[i + 1] === Types.DOUBLE || packet.buffer[i + 1] === Types.TINY || packet.buffer[i + 1] === Types.DATETIME || packet.buffer[i + 1] === Types.JSON) && packet.buffer[i] === 1 && packet.buffer[i + 2] === 0) {
          break;
        } else {
          packet.readInt8();
        }
        i++;
      }
      const types2 = [];
      for (let i2 = packet.offset + 1;i2 < packet.end - 1; i2++) {
        if ((packet.buffer[i2] === Types.VAR_STRING || packet.buffer[i2] === Types.NULL || packet.buffer[i2] === Types.DOUBLE || packet.buffer[i2] === Types.TINY || packet.buffer[i2] === Types.DATETIME || packet.buffer[i2] === Types.JSON) && packet.buffer[i2 + 1] === 0) {
          types2.push(packet.buffer[i2]);
          packet.skip(2);
        }
      }
      packet.skip(1);
      const values = [];
      for (let i2 = 0;i2 < types2.length; i2++) {
        if (types2[i2] === Types.VAR_STRING) {
          values.push(packet.readLengthCodedString(encoding));
        } else if (types2[i2] === Types.DOUBLE) {
          values.push(packet.readDouble());
        } else if (types2[i2] === Types.TINY) {
          values.push(packet.readInt8());
        } else if (types2[i2] === Types.DATETIME) {
          values.push(packet.readDateTime());
        } else if (types2[i2] === Types.JSON) {
          values.push(JSON.parse(packet.readLengthCodedString(encoding)));
        }
        if (types2[i2] === Types.NULL) {
          values.push(null);
        }
      }
      return { stmtId, flags, iterationCount, values };
    }
    toPacket() {
      let length = 14;
      let parameters;
      if (this.parameters && this.parameters.length > 0) {
        length += Math.floor((this.parameters.length + 7) / 8);
        length += 1;
        length += 2 * this.parameters.length;
        parameters = this.parameters.map((value) => toParameter(value, this.encoding, this.timezone));
        length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);
      }
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.STMT_EXECUTE);
      packet.writeInt32(this.id);
      packet.writeInt8(CursorType.NO_CURSOR);
      packet.writeInt32(1);
      if (parameters) {
        let bitmap = 0;
        let bitValue = 1;
        parameters.forEach((parameter) => {
          if (parameter.type === Types.NULL) {
            bitmap += bitValue;
          }
          bitValue *= 2;
          if (bitValue === 256) {
            packet.writeInt8(bitmap);
            bitmap = 0;
            bitValue = 1;
          }
        });
        if (bitValue !== 1) {
          packet.writeInt8(bitmap);
        }
        packet.writeInt8(1);
        parameters.forEach((parameter) => {
          packet.writeInt8(parameter.type);
          packet.writeInt8(0);
        });
        parameters.forEach((parameter) => {
          if (parameter.type !== Types.NULL) {
            parameter.writer.call(packet, parameter.value);
          }
        });
      }
      return packet;
    }
  }
  module.exports = Execute;
});

// ../../../../node_modules/mysql2/lib/packets/handshake.js
var require_handshake = __commonJS((exports, module) => {
  var Packet = require_packet();
  var ClientConstants = require_client();

  class Handshake {
    constructor(args) {
      this.protocolVersion = args.protocolVersion;
      this.serverVersion = args.serverVersion;
      this.capabilityFlags = args.capabilityFlags;
      this.connectionId = args.connectionId;
      this.authPluginData1 = args.authPluginData1;
      this.authPluginData2 = args.authPluginData2;
      this.characterSet = args.characterSet;
      this.statusFlags = args.statusFlags;
      this.authPluginName = args.authPluginName;
    }
    setScrambleData(cb) {
      __require("crypto").randomBytes(20, (err2, data) => {
        if (err2) {
          cb(err2);
          return;
        }
        this.authPluginData1 = data.slice(0, 8);
        this.authPluginData2 = data.slice(8, 20);
        cb();
      });
    }
    toPacket(sequenceId) {
      const length = 68 + Buffer.byteLength(this.serverVersion, "utf8");
      const buffer = Buffer.alloc(length + 4, 0);
      const packet = new Packet(sequenceId, buffer, 0, length + 4);
      packet.offset = 4;
      packet.writeInt8(this.protocolVersion);
      packet.writeString(this.serverVersion, "cesu8");
      packet.writeInt8(0);
      packet.writeInt32(this.connectionId);
      packet.writeBuffer(this.authPluginData1);
      packet.writeInt8(0);
      const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
      capabilityFlagsBuffer.writeUInt32LE(this.capabilityFlags, 0);
      packet.writeBuffer(capabilityFlagsBuffer.slice(0, 2));
      packet.writeInt8(this.characterSet);
      packet.writeInt16(this.statusFlags);
      packet.writeBuffer(capabilityFlagsBuffer.slice(2, 4));
      packet.writeInt8(21);
      packet.skip(10);
      packet.writeBuffer(this.authPluginData2);
      packet.writeInt8(0);
      packet.writeString("mysql_native_password", "latin1");
      packet.writeInt8(0);
      return packet;
    }
    static fromPacket(packet) {
      const args = {};
      args.protocolVersion = packet.readInt8();
      args.serverVersion = packet.readNullTerminatedString("cesu8");
      args.connectionId = packet.readInt32();
      args.authPluginData1 = packet.readBuffer(8);
      packet.skip(1);
      const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
      capabilityFlagsBuffer[0] = packet.readInt8();
      capabilityFlagsBuffer[1] = packet.readInt8();
      if (packet.haveMoreData()) {
        args.characterSet = packet.readInt8();
        args.statusFlags = packet.readInt16();
        capabilityFlagsBuffer[2] = packet.readInt8();
        capabilityFlagsBuffer[3] = packet.readInt8();
        args.capabilityFlags = capabilityFlagsBuffer.readUInt32LE(0);
        if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
          args.authPluginDataLength = packet.readInt8();
        } else {
          args.authPluginDataLength = 0;
          packet.skip(1);
        }
        packet.skip(10);
      } else {
        args.capabilityFlags = capabilityFlagsBuffer.readUInt16LE(0);
      }
      const isSecureConnection = args.capabilityFlags & ClientConstants.SECURE_CONNECTION;
      if (isSecureConnection) {
        const authPluginDataLength = args.authPluginDataLength;
        if (authPluginDataLength === 0) {
          args.authPluginDataLength = 20;
          args.authPluginData2 = packet.readBuffer(12);
          packet.skip(1);
        } else {
          const len = Math.max(13, authPluginDataLength - 8);
          args.authPluginData2 = packet.readBuffer(len);
        }
      }
      if (args.capabilityFlags & ClientConstants.PLUGIN_AUTH) {
        args.authPluginName = packet.readNullTerminatedString("ascii");
      }
      return new Handshake(args);
    }
  }
  module.exports = Handshake;
});

// ../../../../node_modules/mysql2/lib/packets/handshake_response.js
var require_handshake_response = __commonJS((exports, module) => {
  var ClientConstants = require_client();
  var CharsetToEncoding = require_charset_encodings();
  var Packet = require_packet();
  var auth41 = require_auth_41();

  class HandshakeResponse {
    constructor(handshake) {
      this.user = handshake.user || "";
      this.database = handshake.database || "";
      this.password = handshake.password || "";
      this.passwordSha1 = handshake.passwordSha1;
      this.authPluginData1 = handshake.authPluginData1;
      this.authPluginData2 = handshake.authPluginData2;
      this.compress = handshake.compress;
      this.clientFlags = handshake.flags;
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, this.authPluginData1, this.authPluginData2);
      } else {
        authToken = auth41.calculateToken(this.password, this.authPluginData1, this.authPluginData2);
      }
      this.authToken = authToken;
      this.charsetNumber = handshake.charsetNumber;
      this.encoding = CharsetToEncoding[handshake.charsetNumber];
      this.connectAttributes = handshake.connectAttributes;
    }
    serializeResponse(buffer) {
      const isSet = (flag) => this.clientFlags & ClientConstants[flag];
      const packet = new Packet(0, buffer, 0, buffer.length);
      packet.offset = 4;
      packet.writeInt32(this.clientFlags);
      packet.writeInt32(0);
      packet.writeInt8(this.charsetNumber);
      packet.skip(23);
      const encoding = this.encoding;
      packet.writeNullTerminatedString(this.user, encoding);
      let k;
      if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
        packet.writeLengthCodedNumber(this.authToken.length);
        packet.writeBuffer(this.authToken);
      } else if (isSet("SECURE_CONNECTION")) {
        packet.writeInt8(this.authToken.length);
        packet.writeBuffer(this.authToken);
      } else {
        packet.writeBuffer(this.authToken);
        packet.writeInt8(0);
      }
      if (isSet("CONNECT_WITH_DB")) {
        packet.writeNullTerminatedString(this.database, encoding);
      }
      if (isSet("PLUGIN_AUTH")) {
        packet.writeNullTerminatedString("mysql_native_password", "latin1");
      }
      if (isSet("CONNECT_ATTRS")) {
        const connectAttributes = this.connectAttributes || {};
        const attrNames = Object.keys(connectAttributes);
        let keysLength = 0;
        for (k = 0;k < attrNames.length; ++k) {
          keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);
          keysLength += Packet.lengthCodedStringLength(connectAttributes[attrNames[k]], encoding);
        }
        packet.writeLengthCodedNumber(keysLength);
        for (k = 0;k < attrNames.length; ++k) {
          packet.writeLengthCodedString(attrNames[k], encoding);
          packet.writeLengthCodedString(connectAttributes[attrNames[k]], encoding);
        }
      }
      return packet;
    }
    toPacket() {
      if (typeof this.user !== "string") {
        throw new Error('"user" connection config property must be a string');
      }
      if (typeof this.database !== "string") {
        throw new Error('"database" connection config property must be a string');
      }
      const p2 = this.serializeResponse(Packet.MockBuffer());
      return this.serializeResponse(Buffer.alloc(p2.offset));
    }
    static fromPacket(packet) {
      const args = {};
      args.clientFlags = packet.readInt32();
      function isSet(flag) {
        return args.clientFlags & ClientConstants[flag];
      }
      args.maxPacketSize = packet.readInt32();
      args.charsetNumber = packet.readInt8();
      const encoding = CharsetToEncoding[args.charsetNumber];
      args.encoding = encoding;
      packet.skip(23);
      args.user = packet.readNullTerminatedString(encoding);
      let authTokenLength;
      if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
        authTokenLength = packet.readLengthCodedNumber(encoding);
        args.authToken = packet.readBuffer(authTokenLength);
      } else if (isSet("SECURE_CONNECTION")) {
        authTokenLength = packet.readInt8();
        args.authToken = packet.readBuffer(authTokenLength);
      } else {
        args.authToken = packet.readNullTerminatedString(encoding);
      }
      if (isSet("CONNECT_WITH_DB")) {
        args.database = packet.readNullTerminatedString(encoding);
      }
      if (isSet("PLUGIN_AUTH")) {
        args.authPluginName = packet.readNullTerminatedString(encoding);
      }
      if (isSet("CONNECT_ATTRS")) {
        const keysLength = packet.readLengthCodedNumber(encoding);
        const keysEnd = packet.offset + keysLength;
        const attrs = {};
        while (packet.offset < keysEnd) {
          attrs[packet.readLengthCodedString(encoding)] = packet.readLengthCodedString(encoding);
        }
        args.connectAttributes = attrs;
      }
      return args;
    }
  }
  module.exports = HandshakeResponse;
});

// ../../../../node_modules/mysql2/lib/packets/prepare_statement.js
var require_prepare_statement = __commonJS((exports, module) => {
  var Packet = require_packet();
  var CommandCodes = require_commands();
  var StringParser = require_string2();
  var CharsetToEncoding = require_charset_encodings();

  class PrepareStatement {
    constructor(sql2, charsetNumber) {
      this.query = sql2;
      this.charsetNumber = charsetNumber;
      this.encoding = CharsetToEncoding[charsetNumber];
    }
    toPacket() {
      const buf = StringParser.encode(this.query, this.encoding);
      const length = 5 + buf.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.STMT_PREPARE);
      packet.writeBuffer(buf);
      return packet;
    }
  }
  module.exports = PrepareStatement;
});

// ../../../../node_modules/mysql2/lib/packets/prepared_statement_header.js
var require_prepared_statement_header = __commonJS((exports, module) => {
  class PreparedStatementHeader {
    constructor(packet) {
      packet.skip(1);
      this.id = packet.readInt32();
      this.fieldCount = packet.readInt16();
      this.parameterCount = packet.readInt16();
      packet.skip(1);
      this.warningCount = packet.readInt16();
    }
  }
  module.exports = PreparedStatementHeader;
});

// ../../../../node_modules/mysql2/lib/packets/query.js
var require_query = __commonJS((exports, module) => {
  var Packet = require_packet();
  var CommandCode = require_commands();
  var StringParser = require_string2();
  var CharsetToEncoding = require_charset_encodings();

  class Query {
    constructor(sql2, charsetNumber) {
      this.query = sql2;
      this.charsetNumber = charsetNumber;
      this.encoding = CharsetToEncoding[charsetNumber];
    }
    toPacket() {
      const buf = StringParser.encode(this.query, this.encoding);
      const length = 5 + buf.length;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCode.QUERY);
      packet.writeBuffer(buf);
      return packet;
    }
  }
  module.exports = Query;
});

// ../../../../node_modules/mysql2/lib/packets/register_slave.js
var require_register_slave = __commonJS((exports, module) => {
  var Packet = require_packet();
  var CommandCodes = require_commands();

  class RegisterSlave {
    constructor(opts) {
      this.serverId = opts.serverId || 0;
      this.slaveHostname = opts.slaveHostname || "";
      this.slaveUser = opts.slaveUser || "";
      this.slavePassword = opts.slavePassword || "";
      this.slavePort = opts.slavePort || 0;
      this.replicationRank = opts.replicationRank || 0;
      this.masterId = opts.masterId || 0;
    }
    toPacket() {
      const length = 15 + Buffer.byteLength(this.slaveHostname, "utf8") + Buffer.byteLength(this.slaveUser, "utf8") + Buffer.byteLength(this.slavePassword, "utf8") + 3 + 4;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.REGISTER_SLAVE);
      packet.writeInt32(this.serverId);
      packet.writeInt8(Buffer.byteLength(this.slaveHostname, "utf8"));
      packet.writeString(this.slaveHostname);
      packet.writeInt8(Buffer.byteLength(this.slaveUser, "utf8"));
      packet.writeString(this.slaveUser);
      packet.writeInt8(Buffer.byteLength(this.slavePassword, "utf8"));
      packet.writeString(this.slavePassword);
      packet.writeInt16(this.slavePort);
      packet.writeInt32(this.replicationRank);
      packet.writeInt32(this.masterId);
      return packet;
    }
  }
  module.exports = RegisterSlave;
});

// ../../../../node_modules/mysql2/lib/constants/server_status.js
var require_server_status = __commonJS((exports) => {
  exports.SERVER_STATUS_IN_TRANS = 1;
  exports.SERVER_STATUS_AUTOCOMMIT = 2;
  exports.SERVER_MORE_RESULTS_EXISTS = 8;
  exports.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
  exports.SERVER_QUERY_NO_INDEX_USED = 32;
  exports.SERVER_STATUS_CURSOR_EXISTS = 64;
  exports.SERVER_STATUS_LAST_ROW_SENT = 128;
  exports.SERVER_STATUS_DB_DROPPED = 256;
  exports.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
  exports.SERVER_STATUS_METADATA_CHANGED = 1024;
  exports.SERVER_QUERY_WAS_SLOW = 2048;
  exports.SERVER_PS_OUT_PARAMS = 4096;
  exports.SERVER_STATUS_IN_TRANS_READONLY = 8192;
  exports.SERVER_SESSION_STATE_CHANGED = 16384;
});

// ../../../../node_modules/mysql2/lib/constants/encoding_charset.js
var require_encoding_charset = __commonJS((exports, module) => {
  module.exports = {
    big5: 1,
    latin2: 2,
    dec8: 3,
    cp850: 4,
    latin1: 5,
    hp8: 6,
    koi8r: 7,
    swe7: 10,
    ascii: 11,
    eucjp: 12,
    sjis: 13,
    cp1251: 14,
    hebrew: 16,
    tis620: 18,
    euckr: 19,
    latin7: 20,
    koi8u: 22,
    gb2312: 24,
    greek: 25,
    cp1250: 26,
    gbk: 28,
    cp1257: 29,
    latin5: 30,
    armscii8: 32,
    cesu8: 33,
    ucs2: 35,
    cp866: 36,
    keybcs2: 37,
    macintosh: 38,
    macroman: 39,
    cp852: 40,
    utf8: 45,
    utf8mb4: 45,
    utf16: 54,
    utf16le: 56,
    cp1256: 57,
    utf32: 60,
    binary: 63,
    geostd8: 92,
    cp932: 95,
    eucjpms: 97,
    gb18030: 248,
    utf8mb3: 192
  };
});

// ../../../../node_modules/mysql2/lib/constants/session_track.js
var require_session_track = __commonJS((exports) => {
  exports.SYSTEM_VARIABLES = 0;
  exports.SCHEMA = 1;
  exports.STATE_CHANGE = 2;
  exports.STATE_GTIDS = 3;
  exports.TRANSACTION_CHARACTERISTICS = 4;
  exports.TRANSACTION_STATE = 5;
  exports.FIRST_KEY = exports.SYSTEM_VARIABLES;
  exports.LAST_KEY = exports.TRANSACTION_STATE;
});

// ../../../../node_modules/mysql2/lib/packets/resultset_header.js
var require_resultset_header = __commonJS((exports, module) => {
  var Packet = require_packet();
  var ClientConstants = require_client();
  var ServerSatusFlags = require_server_status();
  var EncodingToCharset = require_encoding_charset();
  var sessionInfoTypes = require_session_track();

  class ResultSetHeader {
    constructor(packet, connection) {
      const bigNumberStrings = connection.config.bigNumberStrings;
      const encoding = connection.serverEncoding;
      const flags = connection._handshakePacket.capabilityFlags;
      const isSet = function(flag) {
        return flags & ClientConstants[flag];
      };
      if (packet.buffer[packet.offset] !== 0) {
        this.fieldCount = packet.readLengthCodedNumber();
        if (this.fieldCount === null) {
          this.infileName = packet.readString(undefined, encoding);
        }
        return;
      }
      this.fieldCount = packet.readInt8();
      this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);
      this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);
      this.info = "";
      if (isSet("PROTOCOL_41")) {
        this.serverStatus = packet.readInt16();
        this.warningStatus = packet.readInt16();
      } else if (isSet("TRANSACTIONS")) {
        this.serverStatus = packet.readInt16();
      }
      let stateChanges = null;
      if (isSet("SESSION_TRACK") && packet.offset < packet.end) {
        this.info = packet.readLengthCodedString(encoding);
        if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
          let len = packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;
          const end = packet.offset + len;
          let type, key, stateEnd;
          if (len > 0) {
            stateChanges = {
              systemVariables: {},
              schema: null,
              gtids: [],
              trackStateChange: null
            };
          }
          while (packet.offset < end) {
            type = packet.readInt8();
            len = packet.readLengthCodedNumber();
            stateEnd = packet.offset + len;
            if (type === sessionInfoTypes.SYSTEM_VARIABLES) {
              key = packet.readLengthCodedString(encoding);
              const val = packet.readLengthCodedString(encoding);
              stateChanges.systemVariables[key] = val;
              if (key === "character_set_client") {
                const charsetNumber = EncodingToCharset[val];
                if (typeof charsetNumber !== "undefined") {
                  connection.config.charsetNumber = charsetNumber;
                }
              }
            } else if (type === sessionInfoTypes.SCHEMA) {
              key = packet.readLengthCodedString(encoding);
              stateChanges.schema = key;
            } else if (type === sessionInfoTypes.STATE_CHANGE) {
              stateChanges.trackStateChange = packet.readLengthCodedString(encoding);
            } else if (type === sessionInfoTypes.STATE_GTIDS) {
              const _unknownString = packet.readLengthCodedString(encoding);
              const gtid = packet.readLengthCodedString(encoding);
              stateChanges.gtids = gtid.split(",");
            } else {}
            packet.offset = stateEnd;
          }
        }
      } else {
        this.info = packet.readString(undefined, encoding);
      }
      if (stateChanges) {
        this.stateChanges = stateChanges;
      }
      const m = this.info.match(/\schanged:\s*(\d+)/i);
      if (m !== null) {
        this.changedRows = parseInt(m[1], 10);
      } else {
        this.changedRows = 0;
      }
    }
    static toPacket(fieldCount, insertId) {
      let length = 4 + Packet.lengthCodedNumberLength(fieldCount);
      if (typeof insertId !== "undefined") {
        length += Packet.lengthCodedNumberLength(insertId);
      }
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeLengthCodedNumber(fieldCount);
      if (typeof insertId !== "undefined") {
        packet.writeLengthCodedNumber(insertId);
      }
      return packet;
    }
  }
  module.exports = ResultSetHeader;
});

// ../../../../node_modules/mysql2/lib/packets/ssl_request.js
var require_ssl_request = __commonJS((exports, module) => {
  var ClientConstants = require_client();
  var Packet = require_packet();

  class SSLRequest {
    constructor(flags, charset) {
      this.clientFlags = flags | ClientConstants.SSL;
      this.charset = charset;
    }
    toPacket() {
      const length = 36;
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      buffer.fill(0);
      packet.offset = 4;
      packet.writeInt32(this.clientFlags);
      packet.writeInt32(0);
      packet.writeInt8(this.charset);
      return packet;
    }
  }
  module.exports = SSLRequest;
});

// ../../../../node_modules/mysql2/lib/packets/text_row.js
var require_text_row = __commonJS((exports, module) => {
  var Packet = require_packet();

  class TextRow {
    constructor(columns) {
      this.columns = columns || [];
    }
    static fromPacket(packet) {
      const columns = [];
      while (packet.haveMoreData()) {
        columns.push(packet.readLengthCodedString());
      }
      return new TextRow(columns);
    }
    static toPacket(columns, encoding) {
      const sequenceId = 0;
      let length = 0;
      columns.forEach((val) => {
        if (val === null || typeof val === "undefined") {
          ++length;
          return;
        }
        length += Packet.lengthCodedStringLength(val.toString(10), encoding);
      });
      const buffer = Buffer.allocUnsafe(length + 4);
      const packet = new Packet(sequenceId, buffer, 0, length + 4);
      packet.offset = 4;
      columns.forEach((val) => {
        if (val === null) {
          packet.writeNull();
          return;
        }
        if (typeof val === "undefined") {
          packet.writeInt8(0);
          return;
        }
        packet.writeLengthCodedString(val.toString(10), encoding);
      });
      return packet;
    }
  }
  module.exports = TextRow;
});

// ../../../../node_modules/mysql2/lib/packets/index.js
var require_packets = __commonJS((exports, module) => {
  var process2 = __require("process");
  var AuthNextFactor = require_auth_next_factor();
  var AuthSwitchRequest = require_auth_switch_request();
  var AuthSwitchRequestMoreData = require_auth_switch_request_more_data();
  var AuthSwitchResponse = require_auth_switch_response();
  var BinaryRow = require_binary_row();
  var BinlogDump = require_binlog_dump();
  var ChangeUser = require_change_user();
  var CloseStatement = require_close_statement();
  var ColumnDefinition = require_column_definition();
  var Execute = require_execute();
  var Handshake = require_handshake();
  var HandshakeResponse = require_handshake_response();
  var PrepareStatement = require_prepare_statement();
  var PreparedStatementHeader = require_prepared_statement_header();
  var Query = require_query();
  var RegisterSlave = require_register_slave();
  var ResultSetHeader = require_resultset_header();
  var SSLRequest = require_ssl_request();
  var TextRow = require_text_row();
  var ctorMap = {
    AuthNextFactor,
    AuthSwitchRequest,
    AuthSwitchRequestMoreData,
    AuthSwitchResponse,
    BinaryRow,
    BinlogDump,
    ChangeUser,
    CloseStatement,
    ColumnDefinition,
    Execute,
    Handshake,
    HandshakeResponse,
    PrepareStatement,
    PreparedStatementHeader,
    Query,
    RegisterSlave,
    ResultSetHeader,
    SSLRequest,
    TextRow
  };
  Object.entries(ctorMap).forEach(([name, ctor]) => {
    exports[name] = ctor;
    if (process2.env.NODE_DEBUG) {
      if (ctor.prototype.toPacket) {
        const old = ctor.prototype.toPacket;
        ctor.prototype.toPacket = function() {
          const p2 = old.call(this);
          p2._name = name;
          return p2;
        };
      }
    }
  });
  var Packet = require_packet();
  exports.Packet = Packet;

  class OK {
    static toPacket(args, encoding) {
      args = args || {};
      const affectedRows = args.affectedRows || 0;
      const insertId = args.insertId || 0;
      const serverStatus = args.serverStatus || 0;
      const warningCount = args.warningCount || 0;
      const message = args.message || "";
      let length = 9 + Packet.lengthCodedNumberLength(affectedRows);
      length += Packet.lengthCodedNumberLength(insertId);
      const buffer = Buffer.allocUnsafe(length);
      const packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(0);
      packet.writeLengthCodedNumber(affectedRows);
      packet.writeLengthCodedNumber(insertId);
      packet.writeInt16(serverStatus);
      packet.writeInt16(warningCount);
      packet.writeString(message, encoding);
      packet._name = "OK";
      return packet;
    }
  }
  exports.OK = OK;

  class EOF {
    static toPacket(warnings, statusFlags) {
      if (typeof warnings === "undefined") {
        warnings = 0;
      }
      if (typeof statusFlags === "undefined") {
        statusFlags = 0;
      }
      const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
      packet.offset = 4;
      packet.writeInt8(254);
      packet.writeInt16(warnings);
      packet.writeInt16(statusFlags);
      packet._name = "EOF";
      return packet;
    }
  }
  exports.EOF = EOF;

  class Error2 {
    static toPacket(args, encoding) {
      const length = 13 + Buffer.byteLength(args.message, "utf8");
      const packet = new Packet(0, Buffer.allocUnsafe(length), 0, length);
      packet.offset = 4;
      packet.writeInt8(255);
      packet.writeInt16(args.code);
      packet.writeString("#_____", encoding);
      packet.writeString(args.message, encoding);
      packet._name = "Error";
      return packet;
    }
    static fromPacket(packet) {
      packet.readInt8();
      const code = packet.readInt16();
      packet.readString(1, "ascii");
      packet.readString(5, "ascii");
      const message = packet.readNullTerminatedString("utf8");
      const error = new Error2;
      error.message = message;
      error.code = code;
      return error;
    }
  }
  exports.Error = Error2;
});

// ../../../../node_modules/mysql2/lib/commands/command.js
var require_command = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var Timers = __require("timers");

  class Command2 extends EventEmitter2 {
    constructor() {
      super();
      this.next = null;
    }
    stateName() {
      const state = this.next;
      for (const i in this) {
        if (this[i] === state && i !== "next") {
          return i;
        }
      }
      return "unknown name";
    }
    execute(packet, connection) {
      if (!this.next) {
        this.next = this.start;
        connection._resetSequenceId();
      }
      if (packet && packet.isError()) {
        const err2 = packet.asError(connection.clientEncoding);
        err2.sql = this.sql || this.query;
        if (this.queryTimeout) {
          Timers.clearTimeout(this.queryTimeout);
          this.queryTimeout = null;
        }
        if (this.onResult) {
          this.onResult(err2);
          this.emit("end");
        } else {
          this.emit("error", err2);
          this.emit("end");
        }
        return true;
      }
      this.next = this.next(packet, connection);
      if (this.next) {
        return false;
      }
      this.emit("end");
      return true;
    }
  }
  module.exports = Command2;
});

// ../../../../node_modules/mysql2/lib/auth_plugins/sha256_password.js
var require_sha256_password = __commonJS((exports, module) => {
  var PLUGIN_NAME = "sha256_password";
  var crypto = __require("crypto");
  var { xorRotating } = require_auth_41();
  var REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);
  var STATE_INITIAL = 0;
  var STATE_WAIT_SERVER_KEY = 1;
  var STATE_FINAL = -1;
  function encrypt(password, scramble, key) {
    const stage1 = xorRotating(Buffer.from(`${password}\x00`, "utf8"), scramble);
    return crypto.publicEncrypt(key, stage1);
  }
  module.exports = (pluginOptions = {}) => ({ connection }) => {
    let state = 0;
    let scramble = null;
    const password = connection.config.password;
    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };
    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          if (pluginOptions.serverPublicKey) {
            return authWithKey(pluginOptions.serverPublicKey);
          }
          state = STATE_WAIT_SERVER_KEY;
          return REQUEST_SERVER_KEY_PACKET;
        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);
      }
      throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);
    };
  };
});

// ../../../../node_modules/mysql2/lib/auth_plugins/caching_sha2_password.js
var require_caching_sha2_password = __commonJS((exports, module) => {
  var PLUGIN_NAME = "caching_sha2_password";
  var crypto = __require("crypto");
  var { xor, xorRotating } = require_auth_41();
  var REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
  var FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
  var PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);
  var STATE_INITIAL = 0;
  var STATE_TOKEN_SENT = 1;
  var STATE_WAIT_SERVER_KEY = 2;
  var STATE_FINAL = -1;
  function sha256(msg) {
    const hash = crypto.createHash("sha256");
    hash.update(msg);
    return hash.digest();
  }
  function calculateToken(password, scramble) {
    if (!password) {
      return Buffer.alloc(0);
    }
    const stage1 = sha256(Buffer.from(password));
    const stage2 = sha256(stage1);
    const stage3 = sha256(Buffer.concat([stage2, scramble]));
    return xor(stage1, stage3);
  }
  function encrypt(password, scramble, key) {
    const stage1 = xorRotating(Buffer.from(`${password}\x00`, "utf8"), scramble);
    return crypto.publicEncrypt({
      key,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    }, stage1);
  }
  module.exports = (pluginOptions = {}) => ({ connection }) => {
    let state = 0;
    let scramble = null;
    const password = connection.config.password;
    const authWithKey = (serverKey) => {
      const _password = encrypt(password, scramble, serverKey);
      state = STATE_FINAL;
      return _password;
    };
    return (data) => {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          state = STATE_TOKEN_SENT;
          return calculateToken(password, scramble);
        case STATE_TOKEN_SENT:
          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
            state = STATE_FINAL;
            return null;
          }
          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
            const isSecureConnection = typeof pluginOptions.overrideIsSecure === "undefined" ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure;
            if (isSecureConnection) {
              state = STATE_FINAL;
              return Buffer.from(`${password}\x00`, "utf8");
            }
            if (pluginOptions.serverPublicKey) {
              return authWithKey(pluginOptions.serverPublicKey);
            }
            state = STATE_WAIT_SERVER_KEY;
            return REQUEST_SERVER_KEY_PACKET;
          }
          throw new Error(`Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`);
        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }
          return authWithKey(data);
        case STATE_FINAL:
          throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);
      }
      throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);
    };
  };
});

// ../../../../node_modules/mysql2/lib/auth_plugins/mysql_native_password.js
var require_mysql_native_password = __commonJS((exports, module) => {
  var auth41 = require_auth_41();
  module.exports = (pluginOptions) => ({ connection, command }) => {
    const password = command.password || pluginOptions.password || connection.config.password;
    const passwordSha1 = command.passwordSha1 || pluginOptions.passwordSha1 || connection.config.passwordSha1;
    return (data) => {
      const authPluginData1 = data.slice(0, 8);
      const authPluginData2 = data.slice(8, 20);
      let authToken;
      if (passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(passwordSha1, authPluginData1, authPluginData2);
      } else {
        authToken = auth41.calculateToken(password, authPluginData1, authPluginData2);
      }
      return authToken;
    };
  };
});

// ../../../../node_modules/mysql2/lib/auth_plugins/mysql_clear_password.js
var require_mysql_clear_password = __commonJS((exports, module) => {
  function bufferFromStr(str) {
    return Buffer.from(`${str}\x00`);
  }
  var create_mysql_clear_password_plugin = (pluginOptions) => function mysql_clear_password_plugin({ connection, command }) {
    const password = command.password || pluginOptions.password || connection.config.password;
    return function() {
      return bufferFromStr(password);
    };
  };
  module.exports = create_mysql_clear_password_plugin;
});

// ../../../../node_modules/mysql2/lib/commands/auth_switch.js
var require_auth_switch = __commonJS((exports, module) => {
  var Packets = require_packets();
  var sha256_password = require_sha256_password();
  var caching_sha2_password = require_caching_sha2_password();
  var mysql_native_password = require_mysql_native_password();
  var mysql_clear_password = require_mysql_clear_password();
  var standardAuthPlugins = {
    sha256_password: sha256_password({}),
    caching_sha2_password: caching_sha2_password({}),
    mysql_native_password: mysql_native_password({}),
    mysql_clear_password: mysql_clear_password({})
  };
  function warnLegacyAuthSwitch() {
    console.warn("WARNING! authSwitchHandler api is deprecated, please use new authPlugins api");
  }
  function authSwitchPluginError(error, command) {
    error.code = "AUTH_SWITCH_PLUGIN_ERROR";
    error.fatal = true;
    command.emit("error", error);
  }
  function authSwitchRequest(packet, connection, command) {
    const { pluginName, pluginData } = Packets.AuthSwitchRequest.fromPacket(packet);
    let authPlugin = connection.config.authPlugins && connection.config.authPlugins[pluginName];
    if (connection.config.authSwitchHandler && pluginName !== "mysql_native_password") {
      const legacySwitchHandler = connection.config.authSwitchHandler;
      warnLegacyAuthSwitch();
      legacySwitchHandler({ pluginName, pluginData }, (err2, data) => {
        if (err2) {
          return authSwitchPluginError(err2, command);
        }
        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      });
      return;
    }
    if (!authPlugin) {
      authPlugin = standardAuthPlugins[pluginName];
    }
    if (!authPlugin) {
      throw new Error(`Server requests authentication using unknown plugin ${pluginName}. See ${"TODO: add plugins doco here"} on how to configure or author authentication plugins.`);
    }
    connection._authPlugin = authPlugin({ connection, command });
    Promise.resolve(connection._authPlugin(pluginData)).then((data) => {
      if (data) {
        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
      }
    }).catch((err2) => {
      authSwitchPluginError(err2, command);
    });
  }
  function authSwitchRequestMoreData(packet, connection, command) {
    const { data } = Packets.AuthSwitchRequestMoreData.fromPacket(packet);
    if (connection.config.authSwitchHandler) {
      const legacySwitchHandler = connection.config.authSwitchHandler;
      warnLegacyAuthSwitch();
      legacySwitchHandler({ pluginData: data }, (err2, data2) => {
        if (err2) {
          return authSwitchPluginError(err2, command);
        }
        connection.writePacket(new Packets.AuthSwitchResponse(data2).toPacket());
      });
      return;
    }
    if (!connection._authPlugin) {
      throw new Error("AuthPluginMoreData received but no auth plugin instance found");
    }
    Promise.resolve(connection._authPlugin(data)).then((data2) => {
      if (data2) {
        connection.writePacket(new Packets.AuthSwitchResponse(data2).toPacket());
      }
    }).catch((err2) => {
      authSwitchPluginError(err2, command);
    });
  }
  module.exports = {
    authSwitchRequest,
    authSwitchRequestMoreData
  };
});

// ../../../../node_modules/seq-queue/lib/seq-queue.js
var require_seq_queue = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var util = __require("util");
  var DEFAULT_TIMEOUT = 3000;
  var INIT_ID = 0;
  var EVENT_CLOSED = "closed";
  var EVENT_DRAINED = "drained";
  var SeqQueue = function(timeout) {
    EventEmitter2.call(this);
    if (timeout && timeout > 0) {
      this.timeout = timeout;
    } else {
      this.timeout = DEFAULT_TIMEOUT;
    }
    this.status = SeqQueueManager.STATUS_IDLE;
    this.curId = INIT_ID;
    this.queue = [];
  };
  util.inherits(SeqQueue, EventEmitter2);
  SeqQueue.prototype.push = function(fn, ontimeout, timeout) {
    if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
      return false;
    }
    if (typeof fn !== "function") {
      throw new Error("fn should be a function.");
    }
    this.queue.push({ fn, ontimeout, timeout });
    if (this.status === SeqQueueManager.STATUS_IDLE) {
      this.status = SeqQueueManager.STATUS_BUSY;
      var self2 = this;
      process.nextTick(function() {
        self2._next(self2.curId);
      });
    }
    return true;
  };
  SeqQueue.prototype.close = function(force) {
    if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
      return;
    }
    if (force) {
      this.status = SeqQueueManager.STATUS_DRAINED;
      if (this.timerId) {
        clearTimeout(this.timerId);
        this.timerId = undefined;
      }
      this.emit(EVENT_DRAINED);
    } else {
      this.status = SeqQueueManager.STATUS_CLOSED;
      this.emit(EVENT_CLOSED);
    }
  };
  SeqQueue.prototype._next = function(tid) {
    if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {
      return;
    }
    if (this.timerId) {
      clearTimeout(this.timerId);
      this.timerId = undefined;
    }
    var task = this.queue.shift();
    if (!task) {
      if (this.status === SeqQueueManager.STATUS_BUSY) {
        this.status = SeqQueueManager.STATUS_IDLE;
        this.curId++;
      } else {
        this.status = SeqQueueManager.STATUS_DRAINED;
        this.emit(EVENT_DRAINED);
      }
      return;
    }
    var self2 = this;
    task.id = ++this.curId;
    var timeout = task.timeout > 0 ? task.timeout : this.timeout;
    timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;
    this.timerId = setTimeout(function() {
      process.nextTick(function() {
        self2._next(task.id);
      });
      self2.emit("timeout", task);
      if (task.ontimeout) {
        task.ontimeout();
      }
    }, timeout);
    try {
      task.fn({
        done: function() {
          var res = task.id === self2.curId;
          process.nextTick(function() {
            self2._next(task.id);
          });
          return res;
        }
      });
    } catch (err2) {
      self2.emit("error", err2, task);
      process.nextTick(function() {
        self2._next(task.id);
      });
    }
  };
  var SeqQueueManager = exports;
  SeqQueueManager.STATUS_IDLE = 0;
  SeqQueueManager.STATUS_BUSY = 1;
  SeqQueueManager.STATUS_CLOSED = 2;
  SeqQueueManager.STATUS_DRAINED = 3;
  SeqQueueManager.createQueue = function(timeout) {
    return new SeqQueue(timeout);
  };
});

// ../../../../node_modules/mysql2/lib/compressed_protocol.js
var require_compressed_protocol = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var PacketParser = require_packet_parser();
  function handleCompressedPacket(packet) {
    const connection = this;
    const deflatedLength = packet.readInt24();
    const body = packet.readBuffer();
    if (deflatedLength !== 0) {
      connection.inflateQueue.push((task) => {
        zlib.inflate(body, (err2, data) => {
          if (err2) {
            connection._handleNetworkError(err2);
            return;
          }
          connection._bumpCompressedSequenceId(packet.numPackets);
          connection._inflatedPacketsParser.execute(data);
          task.done();
        });
      });
    } else {
      connection.inflateQueue.push((task) => {
        connection._bumpCompressedSequenceId(packet.numPackets);
        connection._inflatedPacketsParser.execute(body);
        task.done();
      });
    }
  }
  function writeCompressed(buffer) {
    const MAX_COMPRESSED_LENGTH = 16777210;
    let start;
    if (buffer.length > MAX_COMPRESSED_LENGTH) {
      for (start = 0;start < buffer.length; start += MAX_COMPRESSED_LENGTH) {
        writeCompressed.call(this, buffer.slice(start, start + MAX_COMPRESSED_LENGTH));
      }
      return;
    }
    const connection = this;
    let packetLen = buffer.length;
    const compressHeader = Buffer.allocUnsafe(7);
    (function(seqId) {
      connection.deflateQueue.push((task) => {
        zlib.deflate(buffer, (err2, compressed) => {
          if (err2) {
            connection._handleFatalError(err2);
            return;
          }
          let compressedLength = compressed.length;
          if (compressedLength < packetLen) {
            compressHeader.writeUInt8(compressedLength & 255, 0);
            compressHeader.writeUInt16LE(compressedLength >> 8, 1);
            compressHeader.writeUInt8(seqId, 3);
            compressHeader.writeUInt8(packetLen & 255, 4);
            compressHeader.writeUInt16LE(packetLen >> 8, 5);
            connection.writeUncompressed(compressHeader);
            connection.writeUncompressed(compressed);
          } else {
            compressedLength = packetLen;
            packetLen = 0;
            compressHeader.writeUInt8(compressedLength & 255, 0);
            compressHeader.writeUInt16LE(compressedLength >> 8, 1);
            compressHeader.writeUInt8(seqId, 3);
            compressHeader.writeUInt8(packetLen & 255, 4);
            compressHeader.writeUInt16LE(packetLen >> 8, 5);
            connection.writeUncompressed(compressHeader);
            connection.writeUncompressed(buffer);
          }
          task.done();
        });
      });
    })(connection.compressedSequenceId);
    connection._bumpCompressedSequenceId(1);
  }
  function enableCompression(connection) {
    connection._lastWrittenPacketId = 0;
    connection._lastReceivedPacketId = 0;
    connection._handleCompressedPacket = handleCompressedPacket;
    connection._inflatedPacketsParser = new PacketParser((p2) => {
      connection.handlePacket(p2);
    }, 4);
    connection._inflatedPacketsParser._lastPacket = 0;
    connection.packetParser = new PacketParser((packet) => {
      connection._handleCompressedPacket(packet);
    }, 7);
    connection.writeUncompressed = connection.write;
    connection.write = writeCompressed;
    const seqqueue = require_seq_queue();
    connection.inflateQueue = seqqueue.createQueue();
    connection.deflateQueue = seqqueue.createQueue();
  }
  module.exports = {
    enableCompression
  };
});

// ../../../../node_modules/mysql2/lib/commands/client_handshake.js
var require_client_handshake = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Packets = require_packets();
  var ClientConstants = require_client();
  var CharsetToEncoding = require_charset_encodings();
  var auth41 = require_auth_41();
  function flagNames(flags) {
    const res = [];
    for (const c in ClientConstants) {
      if (flags & ClientConstants[c]) {
        res.push(c.replace(/_/g, " ").toLowerCase());
      }
    }
    return res;
  }

  class ClientHandshake extends Command2 {
    constructor(clientFlags) {
      super();
      this.handshake = null;
      this.clientFlags = clientFlags;
      this.authenticationFactor = 0;
    }
    start() {
      return ClientHandshake.prototype.handshakeInit;
    }
    sendSSLRequest(connection) {
      const sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);
      connection.writePacket(sslRequest.toPacket());
    }
    sendCredentials(connection) {
      if (connection.config.debug) {
        console.log("Sending handshake packet: flags:%d=(%s)", this.clientFlags, flagNames(this.clientFlags).join(", "));
      }
      this.user = connection.config.user;
      this.password = connection.config.password;
      this.password1 = connection.config.password;
      this.password2 = connection.config.password2;
      this.password3 = connection.config.password3;
      this.passwordSha1 = connection.config.passwordSha1;
      this.database = connection.config.database;
      this.authPluginName = this.handshake.authPluginName;
      const handshakeResponse = new Packets.HandshakeResponse({
        flags: this.clientFlags,
        user: this.user,
        database: this.database,
        password: this.password,
        passwordSha1: this.passwordSha1,
        charsetNumber: connection.config.charsetNumber,
        authPluginData1: this.handshake.authPluginData1,
        authPluginData2: this.handshake.authPluginData2,
        compress: connection.config.compress,
        connectAttributes: connection.config.connectAttributes
      });
      connection.writePacket(handshakeResponse.toPacket());
    }
    calculateNativePasswordAuthToken(authPluginData) {
      const authPluginData1 = authPluginData.slice(0, 8);
      const authPluginData2 = authPluginData.slice(8, 20);
      let authToken;
      if (this.passwordSha1) {
        authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);
      } else {
        authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);
      }
      return authToken;
    }
    handshakeInit(helloPacket, connection) {
      this.on("error", (e) => {
        connection._fatalError = e;
        connection._protocolError = e;
      });
      this.handshake = Packets.Handshake.fromPacket(helloPacket);
      if (connection.config.debug) {
        console.log("Server hello packet: capability flags:%d=(%s)", this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(", "));
      }
      connection.serverCapabilityFlags = this.handshake.capabilityFlags;
      connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];
      connection.connectionId = this.handshake.connectionId;
      const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL;
      const multiFactorAuthentication = this.handshake.capabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;
      this.clientFlags = this.clientFlags | multiFactorAuthentication;
      connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;
      this.clientFlags = this.clientFlags | connection.config.compress;
      if (connection.config.ssl) {
        if (!serverSSLSupport) {
          const err2 = new Error("Server does not support secure connection");
          err2.code = "HANDSHAKE_NO_SSL_SUPPORT";
          err2.fatal = true;
          this.emit("error", err2);
          return false;
        }
        this.clientFlags |= ClientConstants.SSL;
        this.sendSSLRequest(connection);
        connection.startTLS((err2) => {
          if (err2) {
            err2.code = "HANDSHAKE_SSL_ERROR";
            err2.fatal = true;
            this.emit("error", err2);
            return;
          }
          this.sendCredentials(connection);
        });
      } else {
        this.sendCredentials(connection);
      }
      if (multiFactorAuthentication) {
        this.authenticationFactor = 1;
      }
      return ClientHandshake.prototype.handshakeResult;
    }
    handshakeResult(packet, connection) {
      const marker = packet.peekByte();
      if (marker === 254 || marker === 1 || marker === 2) {
        const authSwitch = require_auth_switch();
        try {
          if (marker === 1) {
            authSwitch.authSwitchRequestMoreData(packet, connection, this);
          } else {
            if (this.authenticationFactor !== 0) {
              connection.config.password = this[`password${this.authenticationFactor}`];
              this.authenticationFactor += 1;
            }
            authSwitch.authSwitchRequest(packet, connection, this);
          }
          return ClientHandshake.prototype.handshakeResult;
        } catch (err2) {
          err2.code = "AUTH_SWITCH_PLUGIN_ERROR";
          err2.fatal = true;
          if (this.onResult) {
            this.onResult(err2);
          } else {
            this.emit("error", err2);
          }
          return null;
        }
      }
      if (marker !== 0) {
        const err2 = new Error("Unexpected packet during handshake phase");
        err2.code = "HANDSHAKE_UNKNOWN_ERROR";
        err2.fatal = true;
        if (this.onResult) {
          this.onResult(err2);
        } else {
          this.emit("error", err2);
        }
        return null;
      }
      if (!connection.authorized) {
        connection.authorized = true;
        if (connection.config.compress) {
          const enableCompression = require_compressed_protocol().enableCompression;
          enableCompression(connection);
        }
      }
      if (this.onResult) {
        this.onResult(null);
      }
      return null;
    }
  }
  module.exports = ClientHandshake;
});

// ../../../../node_modules/mysql2/lib/commands/server_handshake.js
var require_server_handshake = __commonJS((exports, module) => {
  var CommandCode = require_commands();
  var Errors = require_errors();
  var Command2 = require_command();
  var Packets = require_packets();

  class ServerHandshake extends Command2 {
    constructor(args) {
      super();
      this.args = args;
    }
    start(packet, connection) {
      const serverHelloPacket = new Packets.Handshake(this.args);
      this.serverHello = serverHelloPacket;
      serverHelloPacket.setScrambleData((err2) => {
        if (err2) {
          connection.emit("error", new Error("Error generating random bytes"));
          return;
        }
        connection.writePacket(serverHelloPacket.toPacket(0));
      });
      return ServerHandshake.prototype.readClientReply;
    }
    readClientReply(packet, connection) {
      const clientHelloReply = Packets.HandshakeResponse.fromPacket(packet);
      connection.clientHelloReply = clientHelloReply;
      if (this.args.authCallback) {
        this.args.authCallback({
          user: clientHelloReply.user,
          database: clientHelloReply.database,
          address: connection.stream.remoteAddress,
          authPluginData1: this.serverHello.authPluginData1,
          authPluginData2: this.serverHello.authPluginData2,
          authToken: clientHelloReply.authToken
        }, (err2, mysqlError) => {
          if (!mysqlError) {
            connection.writeOk();
          } else {
            connection.writeError({
              message: mysqlError.message || "",
              code: mysqlError.code || 1045
            });
            connection.close();
          }
        });
      } else {
        connection.writeOk();
      }
      return ServerHandshake.prototype.dispatchCommands;
    }
    _isStatement(query2, name) {
      const firstWord = query2.split(" ")[0].toUpperCase();
      return firstWord === name;
    }
    dispatchCommands(packet, connection) {
      let knownCommand = true;
      const encoding = connection.clientHelloReply.encoding;
      const commandCode = packet.readInt8();
      switch (commandCode) {
        case CommandCode.STMT_PREPARE:
          if (connection.listeners("stmt_prepare").length) {
            const query2 = packet.readString(undefined, encoding);
            connection.emit("stmt_prepare", query2);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler for prepared statements."
            });
          }
          break;
        case CommandCode.STMT_EXECUTE:
          if (connection.listeners("stmt_execute").length) {
            const { stmtId, flags, iterationCount, values } = Packets.Execute.fromPacket(packet, encoding);
            connection.emit("stmt_execute", stmtId, flags, iterationCount, values);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler for execute statements."
            });
          }
          break;
        case CommandCode.QUIT:
          if (connection.listeners("quit").length) {
            connection.emit("quit");
          } else {
            connection.stream.end();
          }
          break;
        case CommandCode.INIT_DB:
          if (connection.listeners("init_db").length) {
            const schemaName = packet.readString(undefined, encoding);
            connection.emit("init_db", schemaName);
          } else {
            connection.writeOk();
          }
          break;
        case CommandCode.QUERY:
          if (connection.listeners("query").length) {
            const query2 = packet.readString(undefined, encoding);
            if (this._isStatement(query2, "PREPARE") || this._isStatement(query2, "SET")) {
              connection.emit("stmt_prepare", query2);
            } else if (this._isStatement(query2, "EXECUTE")) {
              connection.emit("stmt_execute", null, null, null, null, query2);
            } else
              connection.emit("query", query2);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: "No query handler"
            });
          }
          break;
        case CommandCode.FIELD_LIST:
          if (connection.listeners("field_list").length) {
            const table = packet.readNullTerminatedString(encoding);
            const fields = packet.readString(undefined, encoding);
            connection.emit("field_list", table, fields);
          } else {
            connection.writeError({
              code: Errors.ER_WARN_DEPRECATED_SYNTAX,
              message: "As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL."
            });
          }
          break;
        case CommandCode.PING:
          if (connection.listeners("ping").length) {
            connection.emit("ping");
          } else {
            connection.writeOk();
          }
          break;
        default:
          knownCommand = false;
      }
      if (connection.listeners("packet").length) {
        connection.emit("packet", packet.clone(), knownCommand, commandCode);
      } else if (!knownCommand) {
        console.log("Unknown command:", commandCode);
      }
      return ServerHandshake.prototype.dispatchCommands;
    }
  }
  module.exports = ServerHandshake;
});

// ../../../../node_modules/mysql2/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  function srcEscape(str) {
    return JSON.stringify({
      [str]: 1
    }).slice(1, -3);
  }
  exports.srcEscape = srcEscape;
  var highlightFn;
  var cardinalRecommended = false;
  try {
    const REQUIRE_TERMINATOR = "";
    highlightFn = __require(`cardinal${REQUIRE_TERMINATOR}`).highlight;
  } catch (err2) {
    highlightFn = (text) => {
      if (!cardinalRecommended) {
        console.log("For nicer debug output consider install cardinal@^2.0.0");
        cardinalRecommended = true;
      }
      return text;
    };
  }
  function printDebugWithCode(msg, code) {
    console.log(`

${msg}:
`);
    console.log(`${highlightFn(code)}
`);
  }
  exports.printDebugWithCode = printDebugWithCode;
  function typeMatch(type, list, Types) {
    if (Array.isArray(list)) {
      return list.some((t) => type === Types[t]);
    }
    return !!list;
  }
  exports.typeMatch = typeMatch;
  var privateObjectProps = new Set([
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__proto__"
  ]);
  exports.privateObjectProps = privateObjectProps;
  var fieldEscape = (field, isEval = true) => {
    if (privateObjectProps.has(field)) {
      throw new Error(`The field name (${field}) can't be the same as an object's private property.`);
    }
    return isEval ? srcEscape(field) : field;
  };
  exports.fieldEscape = fieldEscape;
});

// ../../../../node_modules/is-property/is-property.js
var require_is_property = __commonJS((exports, module) => {
  function isProperty(str) {
    return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str);
  }
  module.exports = isProperty;
});

// ../../../../node_modules/generate-function/index.js
var require_generate_function = __commonJS((exports, module) => {
  var util = __require("util");
  var isProperty = require_is_property();
  var INDENT_START = /[\{\[]/;
  var INDENT_END = /[\}\]]/;
  var RESERVED = [
    "do",
    "if",
    "in",
    "for",
    "let",
    "new",
    "try",
    "var",
    "case",
    "else",
    "enum",
    "eval",
    "null",
    "this",
    "true",
    "void",
    "with",
    "await",
    "break",
    "catch",
    "class",
    "const",
    "false",
    "super",
    "throw",
    "while",
    "yield",
    "delete",
    "export",
    "import",
    "public",
    "return",
    "static",
    "switch",
    "typeof",
    "default",
    "extends",
    "finally",
    "package",
    "private",
    "continue",
    "debugger",
    "function",
    "arguments",
    "interface",
    "protected",
    "implements",
    "instanceof",
    "NaN",
    "undefined"
  ];
  var RESERVED_MAP = {};
  for (i = 0;i < RESERVED.length; i++) {
    RESERVED_MAP[RESERVED[i]] = true;
  }
  var i;
  var isVariable = function(name) {
    return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
  };
  var formats = {
    s: function(s) {
      return "" + s;
    },
    d: function(d) {
      return "" + Number(d);
    },
    o: function(o) {
      return JSON.stringify(o);
    }
  };
  var genfun = function() {
    var lines = [];
    var indent = 0;
    var vars = {};
    var push = function(str) {
      var spaces = "";
      while (spaces.length < indent * 2)
        spaces += "  ";
      lines.push(spaces + str);
    };
    var pushLine = function(line2) {
      if (INDENT_END.test(line2.trim()[0]) && INDENT_START.test(line2[line2.length - 1])) {
        indent--;
        push(line2);
        indent++;
        return;
      }
      if (INDENT_START.test(line2[line2.length - 1])) {
        push(line2);
        indent++;
        return;
      }
      if (INDENT_END.test(line2.trim()[0])) {
        indent--;
        push(line2);
        return;
      }
      push(line2);
    };
    var line = function(fmt) {
      if (!fmt)
        return line;
      if (arguments.length === 1 && fmt.indexOf(`
`) > -1) {
        var lines2 = fmt.trim().split(`
`);
        for (var i2 = 0;i2 < lines2.length; i2++) {
          pushLine(lines2[i2].trim());
        }
      } else {
        pushLine(util.format.apply(util, arguments));
      }
      return line;
    };
    line.scope = {};
    line.formats = formats;
    line.sym = function(name) {
      if (!name || !isVariable(name))
        name = "tmp";
      if (!vars[name])
        vars[name] = 0;
      return name + (vars[name]++ || "");
    };
    line.property = function(obj, name) {
      if (arguments.length === 1) {
        name = obj;
        obj = "";
      }
      name = name + "";
      if (isProperty(name))
        return obj ? obj + "." + name : name;
      return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
    };
    line.toString = function() {
      return lines.join(`
`);
    };
    line.toFunction = function(scope) {
      if (!scope)
        scope = {};
      var src2 = "return (" + line.toString() + ")";
      Object.keys(line.scope).forEach(function(key) {
        if (!scope[key])
          scope[key] = line.scope[key];
      });
      var keys = Object.keys(scope).map(function(key) {
        return key;
      });
      var vals = keys.map(function(key) {
        return scope[key];
      });
      return Function.apply(null, keys.concat(src2)).apply(null, vals);
    };
    if (arguments.length)
      line.apply(null, arguments);
    return line;
  };
  genfun.formats = formats;
  module.exports = genfun;
});

// ../../../../node_modules/mysql2/lib/parsers/text_parser.js
var require_text_parser = __commonJS((exports, module) => {
  var Types = require_types2();
  var Charsets = require_charsets();
  var helpers = require_helpers();
  var genFunc = require_generate_function();
  var parserCache = require_parser_cache();
  var typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readCodeFor(type, charset, encodingExpr, config, options) {
    const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
    const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    switch (type) {
      case Types.TINY:
      case Types.SHORT:
      case Types.LONG:
      case Types.INT24:
      case Types.YEAR:
        return "packet.parseLengthCodedIntNoBigCheck()";
      case Types.LONGLONG:
        if (supportBigNumbers && bigNumberStrings) {
          return "packet.parseLengthCodedIntString()";
        }
        return `packet.parseLengthCodedInt(${supportBigNumbers})`;
      case Types.FLOAT:
      case Types.DOUBLE:
        return "packet.parseLengthCodedFloat()";
      case Types.NULL:
        return "packet.readLengthCodedNumber()";
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return "packet.parseLengthCodedFloat()";
        }
        return 'packet.readLengthCodedString("ascii")';
      case Types.DATE:
        if (helpers.typeMatch(type, dateStrings, Types)) {
          return 'packet.readLengthCodedString("ascii")';
        }
        return `packet.parseDate(${helpers.srcEscape(timezone)})`;
      case Types.DATETIME:
      case Types.TIMESTAMP:
        if (helpers.typeMatch(type, dateStrings, Types)) {
          return 'packet.readLengthCodedString("ascii")';
        }
        return `packet.parseDateTime(${helpers.srcEscape(timezone)})`;
      case Types.TIME:
        return 'packet.readLengthCodedString("ascii")';
      case Types.GEOMETRY:
        return "packet.parseGeometryValue()";
      case Types.VECTOR:
        return "packet.parseVector()";
      case Types.JSON:
        return config.jsonStrings ? 'packet.readLengthCodedString("utf8")' : 'JSON.parse(packet.readLengthCodedString("utf8"))';
      default:
        if (charset === Charsets.BINARY) {
          return "packet.readLengthCodedBuffer()";
        }
        return `packet.readLengthCodedString(${encodingExpr})`;
    }
  }
  function compile(fields, options, config) {
    if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") {
      options.typeCast = config.typeCast;
    }
    function wrap(field, _this) {
      return {
        type: typeNames[field.columnType],
        length: field.columnLength,
        db: field.schema,
        table: field.table,
        name: field.name,
        string: function(encoding = field.encoding) {
          if (field.columnType === Types.JSON && encoding === field.encoding) {
            console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
          }
          return _this.packet.readLengthCodedString(encoding);
        },
        buffer: function() {
          return _this.packet.readLengthCodedBuffer();
        },
        geometry: function() {
          return _this.packet.parseGeometryValue();
        }
      };
    }
    const parserFn = genFunc();
    parserFn("(function () {")("return class TextRow {");
    parserFn("constructor(fields) {");
    if (typeof options.typeCast === "function") {
      parserFn("const _this = this;");
      parserFn("for(let i=0; i<fields.length; ++i) {");
      parserFn("this[`wrap${i}`] = wrap(fields[i], _this);");
      parserFn("}");
    }
    parserFn("}");
    parserFn("next(packet, fields, options) {");
    parserFn("this.packet = packet;");
    if (options.rowsAsArray) {
      parserFn(`const result = new Array(${fields.length});`);
    } else {
      parserFn("const result = {};");
    }
    const resultTables = {};
    let resultTablesArray = [];
    if (options.nestTables === true) {
      for (let i = 0;i < fields.length; i++) {
        resultTables[fields[i].table] = 1;
      }
      resultTablesArray = Object.keys(resultTables);
      for (let i = 0;i < resultTablesArray.length; i++) {
        parserFn(`result[${helpers.fieldEscape(resultTablesArray[i])}] = {};`);
      }
    }
    let lvalue = "";
    let fieldName = "";
    let tableName = "";
    for (let i = 0;i < fields.length; i++) {
      fieldName = helpers.fieldEscape(fields[i].name);
      if (typeof options.nestTables === "string") {
        lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
      } else if (options.nestTables === true) {
        tableName = helpers.fieldEscape(fields[i].table);
        parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
        lvalue = `result[${tableName}][${fieldName}]`;
      } else if (options.rowsAsArray) {
        lvalue = `result[${i.toString(10)}]`;
      } else {
        lvalue = `result[${fieldName}]`;
      }
      if (options.typeCast === false) {
        parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
      } else {
        const encodingExpr = `fields[${i}].encoding`;
        const readCode = readCodeFor(fields[i].columnType, fields[i].characterSet, encodingExpr, config, options);
        if (typeof options.typeCast === "function") {
          parserFn(`${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`);
        } else {
          parserFn(`${lvalue} = ${readCode};`);
        }
      }
    }
    parserFn("return result;");
    parserFn("}");
    parserFn("};")("})()");
    if (config.debug) {
      helpers.printDebugWithCode("Compiled text protocol row parser", parserFn.toString());
    }
    if (typeof options.typeCast === "function") {
      return parserFn.toFunction({ wrap });
    }
    return parserFn.toFunction();
  }
  function getTextParser(fields, options, config) {
    return parserCache.getParser("text", fields, options, config, compile);
  }
  module.exports = getTextParser;
});

// ../../../../node_modules/mysql2/lib/parsers/static_text_parser.js
var require_static_text_parser = __commonJS((exports, module) => {
  var Types = require_types2();
  var Charsets = require_charsets();
  var helpers = require_helpers();
  var typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readField({ packet, type, charset, encoding, config, options }) {
    const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
    const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    switch (type) {
      case Types.TINY:
      case Types.SHORT:
      case Types.LONG:
      case Types.INT24:
      case Types.YEAR:
        return packet.parseLengthCodedIntNoBigCheck();
      case Types.LONGLONG:
        if (supportBigNumbers && bigNumberStrings) {
          return packet.parseLengthCodedIntString();
        }
        return packet.parseLengthCodedInt(supportBigNumbers);
      case Types.FLOAT:
      case Types.DOUBLE:
        return packet.parseLengthCodedFloat();
      case Types.NULL:
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return packet.parseLengthCodedFloat();
        }
        return packet.readLengthCodedString("ascii");
      case Types.DATE:
        if (helpers.typeMatch(type, dateStrings, Types)) {
          return packet.readLengthCodedString("ascii");
        }
        return packet.parseDate(timezone);
      case Types.DATETIME:
      case Types.TIMESTAMP:
        if (helpers.typeMatch(type, dateStrings, Types)) {
          return packet.readLengthCodedString("ascii");
        }
        return packet.parseDateTime(timezone);
      case Types.TIME:
        return packet.readLengthCodedString("ascii");
      case Types.GEOMETRY:
        return packet.parseGeometryValue();
      case Types.VECTOR:
        return packet.parseVector();
      case Types.JSON:
        return config.jsonStrings ? packet.readLengthCodedString("utf8") : JSON.parse(packet.readLengthCodedString("utf8"));
      default:
        if (charset === Charsets.BINARY) {
          return packet.readLengthCodedBuffer();
        }
        return packet.readLengthCodedString(encoding);
    }
  }
  function createTypecastField(field, packet) {
    return {
      type: typeNames[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function(encoding = field.encoding) {
        if (field.columnType === Types.JSON && encoding === field.encoding) {
          console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
        }
        return packet.readLengthCodedString(encoding);
      },
      buffer: function() {
        return packet.readLengthCodedBuffer();
      },
      geometry: function() {
        return packet.parseGeometryValue();
      }
    };
  }
  function getTextParser(_fields, _options, config) {
    return {
      next(packet, fields, options) {
        const result = options.rowsAsArray ? [] : {};
        for (let i = 0;i < fields.length; i++) {
          const field = fields[i];
          const typeCast = options.typeCast ? options.typeCast : config.typeCast;
          const next = () => readField({
            packet,
            type: field.columnType,
            encoding: field.encoding,
            charset: field.characterSet,
            config,
            options
          });
          let value;
          if (options.typeCast === false) {
            value = packet.readLengthCodedBuffer();
          } else if (typeof typeCast === "function") {
            value = typeCast(createTypecastField(field, packet), next);
          } else {
            value = next();
          }
          if (options.rowsAsArray) {
            result.push(value);
          } else if (typeof options.nestTables === "string") {
            result[`${helpers.fieldEscape(field.table, false)}${options.nestTables}${helpers.fieldEscape(field.name, false)}`] = value;
          } else if (options.nestTables) {
            const tableName = helpers.fieldEscape(field.table, false);
            if (!result[tableName]) {
              result[tableName] = {};
            }
            result[tableName][helpers.fieldEscape(field.name, false)] = value;
          } else {
            result[helpers.fieldEscape(field.name, false)] = value;
          }
        }
        return result;
      }
    };
  }
  module.exports = getTextParser;
});

// ../../../../node_modules/mysql2/lib/commands/query.js
var require_query2 = __commonJS((exports, module) => {
  var process2 = __require("process");
  var Timers = __require("timers");
  var Readable = __require("stream").Readable;
  var Command2 = require_command();
  var Packets = require_packets();
  var getTextParser = require_text_parser();
  var staticParser = require_static_text_parser();
  var ServerStatus = require_server_status();
  var EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4);

  class Query extends Command2 {
    constructor(options, callback) {
      super();
      this.sql = options.sql;
      this.values = options.values;
      this._queryOptions = options;
      this.namedPlaceholders = options.namedPlaceholders || false;
      this.onResult = callback;
      this.timeout = options.timeout;
      this.queryTimeout = null;
      this._fieldCount = 0;
      this._rowParser = null;
      this._fields = [];
      this._rows = [];
      this._receivedFieldsCount = 0;
      this._resultIndex = 0;
      this._localStream = null;
      this._unpipeStream = function() {};
      this._streamFactory = options.infileStreamFactory;
      this._connection = null;
    }
    then() {
      const err2 = "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper";
      console.log(err2);
      throw new Error(err2);
    }
    start(_packet, connection) {
      if (connection.config.debug) {
        console.log("        Sending query command: %s", this.sql);
      }
      this._connection = connection;
      this.options = Object.assign({}, connection.config, this._queryOptions);
      this._setTimeout();
      const cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);
      connection.writePacket(cmdPacket.toPacket(1));
      return Query.prototype.resultsetHeader;
    }
    done() {
      this._unpipeStream();
      if (this.timeout && !this.queryTimeout) {
        return null;
      }
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      if (this.onResult) {
        let rows, fields;
        if (this._resultIndex === 0) {
          rows = this._rows[0];
          fields = this._fields[0];
        } else {
          rows = this._rows;
          fields = this._fields;
        }
        if (fields) {
          process2.nextTick(() => {
            this.onResult(null, rows, fields);
          });
        } else {
          process2.nextTick(() => {
            this.onResult(null, rows);
          });
        }
      }
      return null;
    }
    doneInsert(rs) {
      if (this._localStreamError) {
        if (this.onResult) {
          this.onResult(this._localStreamError, rs);
        } else {
          this.emit("error", this._localStreamError);
        }
        return null;
      }
      this._rows.push(rs);
      this._fields.push(undefined);
      this.emit("fields", undefined);
      this.emit("result", rs);
      if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
        this._resultIndex++;
        return this.resultsetHeader;
      }
      return this.done();
    }
    resultsetHeader(packet, connection) {
      const rs = new Packets.ResultSetHeader(packet, connection);
      this._fieldCount = rs.fieldCount;
      if (connection.config.debug) {
        console.log(`        Resultset header received, expecting ${rs.fieldCount} column definition packets`);
      }
      if (this._fieldCount === 0) {
        return this.doneInsert(rs);
      }
      if (this._fieldCount === null) {
        return this._streamLocalInfile(connection, rs.infileName);
      }
      this._receivedFieldsCount = 0;
      this._rows.push([]);
      this._fields.push([]);
      return this.readField;
    }
    _streamLocalInfile(connection, path10) {
      if (this._streamFactory) {
        this._localStream = this._streamFactory(path10);
      } else {
        this._localStreamError = new Error(`As a result of LOCAL INFILE command server wants to read ${path10} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`);
        connection.writePacket(EmptyPacket);
        return this.infileOk;
      }
      const onConnectionError = () => {
        this._unpipeStream();
      };
      const onDrain = () => {
        this._localStream.resume();
      };
      const onPause = () => {
        this._localStream.pause();
      };
      const onData = function(data) {
        const dataWithHeader = Buffer.allocUnsafe(data.length + 4);
        data.copy(dataWithHeader, 4);
        connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));
      };
      const onEnd = () => {
        connection.removeListener("error", onConnectionError);
        connection.writePacket(EmptyPacket);
      };
      const onError = (err2) => {
        this._localStreamError = err2;
        connection.removeListener("error", onConnectionError);
        connection.writePacket(EmptyPacket);
      };
      this._unpipeStream = () => {
        connection.stream.removeListener("pause", onPause);
        connection.stream.removeListener("drain", onDrain);
        this._localStream.removeListener("data", onData);
        this._localStream.removeListener("end", onEnd);
        this._localStream.removeListener("error", onError);
      };
      connection.stream.on("pause", onPause);
      connection.stream.on("drain", onDrain);
      this._localStream.on("data", onData);
      this._localStream.on("end", onEnd);
      this._localStream.on("error", onError);
      connection.once("error", onConnectionError);
      return this.infileOk;
    }
    readField(packet, connection) {
      this._receivedFieldsCount++;
      if (this._fields[this._resultIndex].length !== this._fieldCount) {
        const field = new Packets.ColumnDefinition(packet, connection.clientEncoding);
        this._fields[this._resultIndex].push(field);
        if (connection.config.debug) {
          console.log("        Column definition:");
          console.log(`          name: ${field.name}`);
          console.log(`          type: ${field.columnType}`);
          console.log(`         flags: ${field.flags}`);
        }
      }
      if (this._receivedFieldsCount === this._fieldCount) {
        const fields = this._fields[this._resultIndex];
        this.emit("fields", fields);
        if (this.options.disableEval) {
          this._rowParser = staticParser(fields, this.options, connection.config);
        } else {
          this._rowParser = new (getTextParser(fields, this.options, connection.config))(fields);
        }
        return Query.prototype.fieldsEOF;
      }
      return Query.prototype.readField;
    }
    fieldsEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError("Expected EOF packet");
      }
      return this.row;
    }
    row(packet, _connection) {
      if (packet.isEOF()) {
        const status = packet.eofStatusFlags();
        const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;
        if (moreResults) {
          this._resultIndex++;
          return Query.prototype.resultsetHeader;
        }
        return this.done();
      }
      let row;
      try {
        row = this._rowParser.next(packet, this._fields[this._resultIndex], this.options);
      } catch (err2) {
        this._localStreamError = err2;
        return this.doneInsert(null);
      }
      if (this.onResult) {
        this._rows[this._resultIndex].push(row);
      } else {
        this.emit("result", row, this._resultIndex);
      }
      return Query.prototype.row;
    }
    infileOk(packet, connection) {
      const rs = new Packets.ResultSetHeader(packet, connection);
      return this.doneInsert(rs);
    }
    stream(options) {
      options = options || {};
      options.objectMode = true;
      const stream = new Readable(options);
      stream._read = () => {
        this._connection && this._connection.resume();
      };
      this.on("result", (row, resultSetIndex) => {
        if (!stream.push(row)) {
          this._connection.pause();
        }
        stream.emit("result", row, resultSetIndex);
      });
      this.on("error", (err2) => {
        stream.emit("error", err2);
      });
      this.on("end", () => {
        stream.push(null);
      });
      this.on("fields", (fields) => {
        stream.emit("fields", fields);
      });
      stream.on("end", () => {
        stream.emit("close");
      });
      return stream;
    }
    _setTimeout() {
      if (this.timeout) {
        const timeoutHandler = this._handleTimeoutError.bind(this);
        this.queryTimeout = Timers.setTimeout(timeoutHandler, this.timeout);
      }
    }
    _handleTimeoutError() {
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      const err2 = new Error("Query inactivity timeout");
      err2.errorno = "PROTOCOL_SEQUENCE_TIMEOUT";
      err2.code = "PROTOCOL_SEQUENCE_TIMEOUT";
      err2.syscall = "query";
      if (this.onResult) {
        this.onResult(err2);
      } else {
        this.emit("error", err2);
      }
    }
  }
  Query.prototype.catch = Query.prototype.then;
  module.exports = Query;
});

// ../../../../node_modules/mysql2/lib/commands/close_statement.js
var require_close_statement2 = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Packets = require_packets();

  class CloseStatement extends Command2 {
    constructor(id) {
      super();
      this.id = id;
    }
    start(packet, connection) {
      connection.writePacket(new Packets.CloseStatement(this.id).toPacket(1));
      return null;
    }
  }
  module.exports = CloseStatement;
});

// ../../../../node_modules/mysql2/lib/parsers/binary_parser.js
var require_binary_parser = __commonJS((exports, module) => {
  var FieldFlags = require_field_flags();
  var Charsets = require_charsets();
  var Types = require_types2();
  var helpers = require_helpers();
  var genFunc = require_generate_function();
  var parserCache = require_parser_cache();
  var typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function readCodeFor(field, config, options, fieldNum) {
    const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
    const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    const unsigned = field.flags & FieldFlags.UNSIGNED;
    switch (field.columnType) {
      case Types.TINY:
        return unsigned ? "packet.readInt8();" : "packet.readSInt8();";
      case Types.SHORT:
        return unsigned ? "packet.readInt16();" : "packet.readSInt16();";
      case Types.LONG:
      case Types.INT24:
        return unsigned ? "packet.readInt32();" : "packet.readSInt32();";
      case Types.YEAR:
        return "packet.readInt16()";
      case Types.FLOAT:
        return "packet.readFloat();";
      case Types.DOUBLE:
        return "packet.readDouble();";
      case Types.NULL:
        return "null;";
      case Types.DATE:
      case Types.DATETIME:
      case Types.TIMESTAMP:
      case Types.NEWDATE:
        if (helpers.typeMatch(field.columnType, dateStrings, Types)) {
          return `packet.readDateTimeString(${parseInt(field.decimals, 10)}, ${null}, ${field.columnType});`;
        }
        return `packet.readDateTime(${helpers.srcEscape(timezone)});`;
      case Types.TIME:
        return "packet.readTimeString()";
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        if (config.decimalNumbers) {
          return "packet.parseLengthCodedFloat();";
        }
        return 'packet.readLengthCodedString("ascii");';
      case Types.GEOMETRY:
        return "packet.parseGeometryValue();";
      case Types.VECTOR:
        return "packet.parseVector()";
      case Types.JSON:
        return config.jsonStrings ? 'packet.readLengthCodedString("utf8")' : 'JSON.parse(packet.readLengthCodedString("utf8"));';
      case Types.LONGLONG:
        if (!supportBigNumbers) {
          return unsigned ? "packet.readInt64JSNumber();" : "packet.readSInt64JSNumber();";
        }
        if (bigNumberStrings) {
          return unsigned ? "packet.readInt64String();" : "packet.readSInt64String();";
        }
        return unsigned ? "packet.readInt64();" : "packet.readSInt64();";
      default:
        if (field.characterSet === Charsets.BINARY) {
          return "packet.readLengthCodedBuffer();";
        }
        return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;
    }
  }
  function compile(fields, options, config) {
    const parserFn = genFunc();
    const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
    function wrap(field, packet) {
      return {
        type: typeNames[field.columnType],
        length: field.columnLength,
        db: field.schema,
        table: field.table,
        name: field.name,
        string: function(encoding = field.encoding) {
          if (field.columnType === Types.JSON && encoding === field.encoding) {
            console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
          }
          if ([Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(field.columnType)) {
            return packet.readDateTimeString(parseInt(field.decimals, 10));
          }
          if (field.columnType === Types.TINY) {
            const unsigned = field.flags & FieldFlags.UNSIGNED;
            return String(unsigned ? packet.readInt8() : packet.readSInt8());
          }
          if (field.columnType === Types.TIME) {
            return packet.readTimeString();
          }
          return packet.readLengthCodedString(encoding);
        },
        buffer: function() {
          return packet.readLengthCodedBuffer();
        },
        geometry: function() {
          return packet.parseGeometryValue();
        }
      };
    }
    parserFn("(function(){");
    parserFn("return class BinaryRow {");
    parserFn("constructor() {");
    parserFn("}");
    parserFn("next(packet, fields, options) {");
    if (options.rowsAsArray) {
      parserFn(`const result = new Array(${fields.length});`);
    } else {
      parserFn("const result = {};");
    }
    if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") {
      options.typeCast = config.typeCast;
    }
    parserFn("packet.readInt8();");
    for (let i = 0;i < nullBitmapLength; ++i) {
      parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);
    }
    let lvalue = "";
    let currentFieldNullBit = 4;
    let nullByteIndex = 0;
    let fieldName = "";
    let tableName = "";
    for (let i = 0;i < fields.length; i++) {
      fieldName = helpers.fieldEscape(fields[i].name);
      if (typeof options.nestTables === "string") {
        lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
      } else if (options.nestTables === true) {
        tableName = helpers.fieldEscape(fields[i].table);
        parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
        lvalue = `result[${tableName}][${fieldName}]`;
      } else if (options.rowsAsArray) {
        lvalue = `result[${i.toString(10)}]`;
      } else {
        lvalue = `result[${fieldName}]`;
      }
      parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);
      parserFn(`${lvalue} = null;`);
      parserFn("else {");
      if (options.typeCast === false) {
        parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
      } else {
        const fieldWrapperVar = `fieldWrapper${i}`;
        parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);
        const readCode = readCodeFor(fields[i], config, options, i);
        if (typeof options.typeCast === "function") {
          parserFn(`${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`);
        } else {
          parserFn(`${lvalue} = ${readCode};`);
        }
      }
      parserFn("}");
      currentFieldNullBit *= 2;
      if (currentFieldNullBit === 256) {
        currentFieldNullBit = 1;
        nullByteIndex++;
      }
    }
    parserFn("return result;");
    parserFn("}");
    parserFn("};")("})()");
    if (config.debug) {
      helpers.printDebugWithCode("Compiled binary protocol row parser", parserFn.toString());
    }
    return parserFn.toFunction({ wrap });
  }
  function getBinaryParser(fields, options, config) {
    return parserCache.getParser("binary", fields, options, config, compile);
  }
  module.exports = getBinaryParser;
});

// ../../../../node_modules/mysql2/lib/parsers/static_binary_parser.js
var require_static_binary_parser = __commonJS((exports, module) => {
  var FieldFlags = require_field_flags();
  var Charsets = require_charsets();
  var Types = require_types2();
  var helpers = require_helpers();
  var typeNames = [];
  for (const t in Types) {
    typeNames[Types[t]] = t;
  }
  function getBinaryParser(fields, _options, config) {
    function readCode(field, config2, options, fieldNum, packet) {
      const supportBigNumbers = Boolean(options.supportBigNumbers || config2.supportBigNumbers);
      const bigNumberStrings = Boolean(options.bigNumberStrings || config2.bigNumberStrings);
      const timezone = options.timezone || config2.timezone;
      const dateStrings = options.dateStrings || config2.dateStrings;
      const unsigned = field.flags & FieldFlags.UNSIGNED;
      switch (field.columnType) {
        case Types.TINY:
          return unsigned ? packet.readInt8() : packet.readSInt8();
        case Types.SHORT:
          return unsigned ? packet.readInt16() : packet.readSInt16();
        case Types.LONG:
        case Types.INT24:
          return unsigned ? packet.readInt32() : packet.readSInt32();
        case Types.YEAR:
          return packet.readInt16();
        case Types.FLOAT:
          return packet.readFloat();
        case Types.DOUBLE:
          return packet.readDouble();
        case Types.NULL:
          return null;
        case Types.DATE:
        case Types.DATETIME:
        case Types.TIMESTAMP:
        case Types.NEWDATE:
          return helpers.typeMatch(field.columnType, dateStrings, Types) ? packet.readDateTimeString(parseInt(field.decimals, 10), null, field.columnType) : packet.readDateTime(timezone);
        case Types.TIME:
          return packet.readTimeString();
        case Types.DECIMAL:
        case Types.NEWDECIMAL:
          return config2.decimalNumbers ? packet.parseLengthCodedFloat() : packet.readLengthCodedString("ascii");
        case Types.GEOMETRY:
          return packet.parseGeometryValue();
        case Types.VECTOR:
          return packet.parseVector();
        case Types.JSON:
          return config2.jsonStrings ? packet.readLengthCodedString("utf8") : JSON.parse(packet.readLengthCodedString("utf8"));
        case Types.LONGLONG:
          if (!supportBigNumbers)
            return unsigned ? packet.readInt64JSNumber() : packet.readSInt64JSNumber();
          return bigNumberStrings ? unsigned ? packet.readInt64String() : packet.readSInt64String() : unsigned ? packet.readInt64() : packet.readSInt64();
        default:
          return field.characterSet === Charsets.BINARY ? packet.readLengthCodedBuffer() : packet.readLengthCodedString(fields[fieldNum].encoding);
      }
    }
    return class BinaryRow {
      constructor() {}
      next(packet, fields2, options) {
        packet.readInt8();
        const nullBitmapLength = Math.floor((fields2.length + 7 + 2) / 8);
        const nullBitmaskBytes = new Array(nullBitmapLength);
        for (let i = 0;i < nullBitmapLength; i++) {
          nullBitmaskBytes[i] = packet.readInt8();
        }
        const result = options.rowsAsArray ? new Array(fields2.length) : {};
        let currentFieldNullBit = 4;
        let nullByteIndex = 0;
        for (let i = 0;i < fields2.length; i++) {
          const field = fields2[i];
          const typeCast = options.typeCast !== undefined ? options.typeCast : config.typeCast;
          let value;
          if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {
            value = null;
          } else if (options.typeCast === false) {
            value = packet.readLengthCodedBuffer();
          } else {
            const next = () => readCode(field, config, options, i, packet);
            value = typeof typeCast === "function" ? typeCast({
              type: typeNames[field.columnType],
              length: field.columnLength,
              db: field.schema,
              table: field.table,
              name: field.name,
              string: function(encoding = field.encoding) {
                if (field.columnType === Types.JSON && encoding === field.encoding) {
                  console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
                }
                if ([
                  Types.DATETIME,
                  Types.NEWDATE,
                  Types.TIMESTAMP,
                  Types.DATE
                ].includes(field.columnType)) {
                  return packet.readDateTimeString(parseInt(field.decimals, 10));
                }
                if (field.columnType === Types.TINY) {
                  const unsigned = field.flags & FieldFlags.UNSIGNED;
                  return String(unsigned ? packet.readInt8() : packet.readSInt8());
                }
                if (field.columnType === Types.TIME) {
                  return packet.readTimeString();
                }
                return packet.readLengthCodedString(encoding);
              },
              buffer: function() {
                return packet.readLengthCodedBuffer();
              },
              geometry: function() {
                return packet.parseGeometryValue();
              }
            }, next) : next();
          }
          if (options.rowsAsArray) {
            result[i] = value;
          } else if (typeof options.nestTables === "string") {
            const key = helpers.fieldEscape(field.table + options.nestTables + field.name, false);
            result[key] = value;
          } else if (options.nestTables === true) {
            const tableName = helpers.fieldEscape(field.table, false);
            if (!result[tableName]) {
              result[tableName] = {};
            }
            const fieldName = helpers.fieldEscape(field.name, false);
            result[tableName][fieldName] = value;
          } else {
            const key = helpers.fieldEscape(field.name, false);
            result[key] = value;
          }
          currentFieldNullBit *= 2;
          if (currentFieldNullBit === 256) {
            currentFieldNullBit = 1;
            nullByteIndex++;
          }
        }
        return result;
      }
    };
  }
  module.exports = getBinaryParser;
});

// ../../../../node_modules/mysql2/lib/commands/execute.js
var require_execute2 = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Query = require_query2();
  var Packets = require_packets();
  var getBinaryParser = require_binary_parser();
  var getStaticBinaryParser = require_static_binary_parser();

  class Execute extends Command2 {
    constructor(options, callback) {
      super();
      this.statement = options.statement;
      this.sql = options.sql;
      this.values = options.values;
      this.onResult = callback;
      this.parameters = options.values;
      this.insertId = 0;
      this.timeout = options.timeout;
      this.queryTimeout = null;
      this._rows = [];
      this._fields = [];
      this._result = [];
      this._fieldCount = 0;
      this._rowParser = null;
      this._executeOptions = options;
      this._resultIndex = 0;
      this._localStream = null;
      this._unpipeStream = function() {};
      this._streamFactory = options.infileStreamFactory;
      this._connection = null;
    }
    buildParserFromFields(fields, connection) {
      if (this.options.disableEval) {
        return getStaticBinaryParser(fields, this.options, connection.config);
      }
      return getBinaryParser(fields, this.options, connection.config);
    }
    start(packet, connection) {
      this._connection = connection;
      this.options = Object.assign({}, connection.config, this._executeOptions);
      this._setTimeout();
      const executePacket = new Packets.Execute(this.statement.id, this.parameters, connection.config.charsetNumber, connection.config.timezone);
      try {
        connection.writePacket(executePacket.toPacket(1));
      } catch (error) {
        this.onResult(error);
      }
      return Execute.prototype.resultsetHeader;
    }
    readField(packet, connection) {
      let fields;
      const field = new Packets.ColumnDefinition(packet, connection.clientEncoding);
      this._receivedFieldsCount++;
      this._fields[this._resultIndex].push(field);
      if (this._receivedFieldsCount === this._fieldCount) {
        fields = this._fields[this._resultIndex];
        this.emit("fields", fields, this._resultIndex);
        return Execute.prototype.fieldsEOF;
      }
      return Execute.prototype.readField;
    }
    fieldsEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError("Expected EOF packet");
      }
      this._rowParser = new (this.buildParserFromFields(this._fields[this._resultIndex], connection));
      return Execute.prototype.row;
    }
  }
  Execute.prototype.done = Query.prototype.done;
  Execute.prototype.doneInsert = Query.prototype.doneInsert;
  Execute.prototype.resultsetHeader = Query.prototype.resultsetHeader;
  Execute.prototype._findOrCreateReadStream = Query.prototype._findOrCreateReadStream;
  Execute.prototype._streamLocalInfile = Query.prototype._streamLocalInfile;
  Execute.prototype._setTimeout = Query.prototype._setTimeout;
  Execute.prototype._handleTimeoutError = Query.prototype._handleTimeoutError;
  Execute.prototype.row = Query.prototype.row;
  Execute.prototype.stream = Query.prototype.stream;
  module.exports = Execute;
});

// ../../../../node_modules/mysql2/lib/commands/prepare.js
var require_prepare = __commonJS((exports, module) => {
  var Packets = require_packets();
  var Command2 = require_command();
  var CloseStatement = require_close_statement2();
  var Execute = require_execute2();

  class PreparedStatementInfo {
    constructor(query2, id, columns, parameters, connection) {
      this.query = query2;
      this.id = id;
      this.columns = columns;
      this.parameters = parameters;
      this.rowParser = null;
      this._connection = connection;
    }
    close() {
      return this._connection.addCommand(new CloseStatement(this.id));
    }
    execute(parameters, callback) {
      if (typeof parameters === "function") {
        callback = parameters;
        parameters = [];
      }
      return this._connection.addCommand(new Execute({ statement: this, values: parameters }, callback));
    }
  }

  class Prepare extends Command2 {
    constructor(options, callback) {
      super();
      this.query = options.sql;
      this.onResult = callback;
      this.id = 0;
      this.fieldCount = 0;
      this.parameterCount = 0;
      this.fields = [];
      this.parameterDefinitions = [];
      this.options = options;
    }
    start(packet, connection) {
      const Connection = connection.constructor;
      this.key = Connection.statementKey(this.options);
      const statement = connection._statements.get(this.key);
      if (statement) {
        if (this.onResult) {
          this.onResult(null, statement);
        }
        return null;
      }
      const cmdPacket = new Packets.PrepareStatement(this.query, connection.config.charsetNumber, this.options.values);
      connection.writePacket(cmdPacket.toPacket(1));
      return Prepare.prototype.prepareHeader;
    }
    prepareHeader(packet, connection) {
      const header = new Packets.PreparedStatementHeader(packet);
      this.id = header.id;
      this.fieldCount = header.fieldCount;
      this.parameterCount = header.parameterCount;
      if (this.parameterCount > 0) {
        return Prepare.prototype.readParameter;
      }
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection);
    }
    readParameter(packet, connection) {
      if (packet.isEOF()) {
        if (this.fieldCount > 0) {
          return Prepare.prototype.readField;
        }
        return this.prepareDone(connection);
      }
      const def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
      this.parameterDefinitions.push(def);
      if (this.parameterDefinitions.length === this.parameterCount) {
        return Prepare.prototype.parametersEOF;
      }
      return this.readParameter;
    }
    readField(packet, connection) {
      if (packet.isEOF()) {
        return this.prepareDone(connection);
      }
      const def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
      this.fields.push(def);
      if (this.fields.length === this.fieldCount) {
        return Prepare.prototype.fieldsEOF;
      }
      return Prepare.prototype.readField;
    }
    parametersEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError("Expected EOF packet after parameters");
      }
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection);
    }
    fieldsEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError("Expected EOF packet after fields");
      }
      return this.prepareDone(connection);
    }
    prepareDone(connection) {
      const statement = new PreparedStatementInfo(this.query, this.id, this.fields, this.parameterDefinitions, connection);
      connection._statements.set(this.key, statement);
      if (this.onResult) {
        this.onResult(null, statement);
      }
      return null;
    }
  }
  module.exports = Prepare;
});

// ../../../../node_modules/mysql2/lib/commands/ping.js
var require_ping = __commonJS((exports, module) => {
  var Command2 = require_command();
  var CommandCode = require_commands();
  var Packet = require_packet();

  class Ping extends Command2 {
    constructor(callback) {
      super();
      this.onResult = callback;
    }
    start(packet, connection) {
      const ping = new Packet(0, Buffer.from([1, 0, 0, 0, CommandCode.PING]), 0, 5);
      connection.writePacket(ping);
      return Ping.prototype.pingResponse;
    }
    pingResponse() {
      if (this.onResult) {
        process.nextTick(this.onResult.bind(this));
      }
      return null;
    }
  }
  module.exports = Ping;
});

// ../../../../node_modules/mysql2/lib/commands/register_slave.js
var require_register_slave2 = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Packets = require_packets();

  class RegisterSlave extends Command2 {
    constructor(opts, callback) {
      super();
      this.onResult = callback;
      this.opts = opts;
    }
    start(packet, connection) {
      const newPacket = new Packets.RegisterSlave(this.opts);
      connection.writePacket(newPacket.toPacket(1));
      return RegisterSlave.prototype.registerResponse;
    }
    registerResponse() {
      if (this.onResult) {
        process.nextTick(this.onResult.bind(this));
      }
      return null;
    }
  }
  module.exports = RegisterSlave;
});

// ../../../../node_modules/mysql2/lib/packets/binlog_query_statusvars.js
var require_binlog_query_statusvars = __commonJS((exports, module) => {
  var keys = {
    FLAGS2: 0,
    SQL_MODE: 1,
    CATALOG: 2,
    AUTO_INCREMENT: 3,
    CHARSET: 4,
    TIME_ZONE: 5,
    CATALOG_NZ: 6,
    LC_TIME_NAMES: 7,
    CHARSET_DATABASE: 8,
    TABLE_MAP_FOR_UPDATE: 9,
    MASTER_DATA_WRITTEN: 10,
    INVOKERS: 11,
    UPDATED_DB_NAMES: 12,
    MICROSECONDS: 3
  };
  module.exports = function parseStatusVars(buffer) {
    const result = {};
    let offset = 0;
    let key, length, prevOffset;
    while (offset < buffer.length) {
      key = buffer[offset++];
      switch (key) {
        case keys.FLAGS2:
          result.flags = buffer.readUInt32LE(offset);
          offset += 4;
          break;
        case keys.SQL_MODE:
          result.sqlMode = buffer.readUInt32LE(offset);
          offset += 8;
          break;
        case keys.CATALOG:
          length = buffer[offset++];
          result.catalog = buffer.toString("utf8", offset, offset + length);
          offset += length + 1;
          break;
        case keys.CHARSET:
          result.clientCharset = buffer.readUInt16LE(offset);
          result.connectionCollation = buffer.readUInt16LE(offset + 2);
          result.serverCharset = buffer.readUInt16LE(offset + 4);
          offset += 6;
          break;
        case keys.TIME_ZONE:
          length = buffer[offset++];
          result.timeZone = buffer.toString("utf8", offset, offset + length);
          offset += length;
          break;
        case keys.CATALOG_NZ:
          length = buffer[offset++];
          result.catalogNz = buffer.toString("utf8", offset, offset + length);
          offset += length;
          break;
        case keys.LC_TIME_NAMES:
          result.lcTimeNames = buffer.readUInt16LE(offset);
          offset += 2;
          break;
        case keys.CHARSET_DATABASE:
          result.schemaCharset = buffer.readUInt16LE(offset);
          offset += 2;
          break;
        case keys.TABLE_MAP_FOR_UPDATE:
          result.mapForUpdate1 = buffer.readUInt32LE(offset);
          result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);
          offset += 8;
          break;
        case keys.MASTER_DATA_WRITTEN:
          result.masterDataWritten = buffer.readUInt32LE(offset);
          offset += 4;
          break;
        case keys.INVOKERS:
          length = buffer[offset++];
          result.invokerUsername = buffer.toString("utf8", offset, offset + length);
          offset += length;
          length = buffer[offset++];
          result.invokerHostname = buffer.toString("utf8", offset, offset + length);
          offset += length;
          break;
        case keys.UPDATED_DB_NAMES:
          length = buffer[offset++];
          result.updatedDBs = [];
          for (;length; --length) {
            prevOffset = offset;
            while (buffer[offset++] && offset < buffer.length) {}
            result.updatedDBs.push(buffer.toString("utf8", prevOffset, offset - 1));
          }
          break;
        case keys.MICROSECONDS:
          result.microseconds = buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);
          offset += 3;
      }
    }
    return result;
  };
});

// ../../../../node_modules/mysql2/lib/commands/binlog_dump.js
var require_binlog_dump2 = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Packets = require_packets();
  var eventParsers = [];

  class BinlogEventHeader {
    constructor(packet) {
      this.timestamp = packet.readInt32();
      this.eventType = packet.readInt8();
      this.serverId = packet.readInt32();
      this.eventSize = packet.readInt32();
      this.logPos = packet.readInt32();
      this.flags = packet.readInt16();
    }
  }

  class BinlogDump extends Command2 {
    constructor(opts) {
      super();
      this.opts = opts;
    }
    start(packet, connection) {
      const newPacket = new Packets.BinlogDump(this.opts);
      connection.writePacket(newPacket.toPacket(1));
      return BinlogDump.prototype.binlogData;
    }
    binlogData(packet) {
      if (packet.isEOF()) {
        this.emit("eof");
        return null;
      }
      packet.readInt8();
      const header = new BinlogEventHeader(packet);
      const EventParser = eventParsers[header.eventType];
      let event;
      if (EventParser) {
        event = new EventParser(packet);
      } else {
        event = {
          name: "UNKNOWN"
        };
      }
      event.header = header;
      this.emit("event", event);
      return BinlogDump.prototype.binlogData;
    }
  }

  class RotateEvent {
    constructor(packet) {
      this.pposition = packet.readInt32();
      packet.readInt32();
      this.nextBinlog = packet.readString();
      this.name = "RotateEvent";
    }
  }

  class FormatDescriptionEvent {
    constructor(packet) {
      this.binlogVersion = packet.readInt16();
      this.serverVersion = packet.readString(50).replace(/\u0000.*/, "");
      this.createTimestamp = packet.readInt32();
      this.eventHeaderLength = packet.readInt8();
      this.eventsLength = packet.readBuffer();
      this.name = "FormatDescriptionEvent";
    }
  }

  class QueryEvent {
    constructor(packet) {
      const parseStatusVars = require_binlog_query_statusvars();
      this.slaveProxyId = packet.readInt32();
      this.executionTime = packet.readInt32();
      const schemaLength = packet.readInt8();
      this.errorCode = packet.readInt16();
      const statusVarsLength = packet.readInt16();
      const statusVars = packet.readBuffer(statusVarsLength);
      this.schema = packet.readString(schemaLength);
      packet.readInt8();
      this.statusVars = parseStatusVars(statusVars);
      this.query = packet.readString();
      this.name = "QueryEvent";
    }
  }

  class XidEvent {
    constructor(packet) {
      this.binlogVersion = packet.readInt16();
      this.xid = packet.readInt64();
      this.name = "XidEvent";
    }
  }
  eventParsers[2] = QueryEvent;
  eventParsers[4] = RotateEvent;
  eventParsers[15] = FormatDescriptionEvent;
  eventParsers[16] = XidEvent;
  module.exports = BinlogDump;
});

// ../../../../node_modules/mysql2/lib/commands/change_user.js
var require_change_user2 = __commonJS((exports, module) => {
  var Command2 = require_command();
  var Packets = require_packets();
  var ClientConstants = require_client();
  var ClientHandshake = require_client_handshake();
  var CharsetToEncoding = require_charset_encodings();

  class ChangeUser extends Command2 {
    constructor(options, callback) {
      super();
      this.onResult = callback;
      this.user = options.user;
      this.password = options.password;
      this.password1 = options.password;
      this.password2 = options.password2;
      this.password3 = options.password3;
      this.database = options.database;
      this.passwordSha1 = options.passwordSha1;
      this.charsetNumber = options.charsetNumber;
      this.currentConfig = options.currentConfig;
      this.authenticationFactor = 0;
    }
    start(packet, connection) {
      const newPacket = new Packets.ChangeUser({
        flags: connection.config.clientFlags,
        user: this.user,
        database: this.database,
        charsetNumber: this.charsetNumber,
        password: this.password,
        passwordSha1: this.passwordSha1,
        authPluginData1: connection._handshakePacket.authPluginData1,
        authPluginData2: connection._handshakePacket.authPluginData2
      });
      this.currentConfig.user = this.user;
      this.currentConfig.password = this.password;
      this.currentConfig.database = this.database;
      this.currentConfig.charsetNumber = this.charsetNumber;
      connection.clientEncoding = CharsetToEncoding[this.charsetNumber];
      connection._statements.clear();
      connection.writePacket(newPacket.toPacket());
      const multiFactorAuthentication = connection.serverCapabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;
      if (multiFactorAuthentication) {
        this.authenticationFactor = 1;
      }
      return ChangeUser.prototype.handshakeResult;
    }
  }
  ChangeUser.prototype.handshakeResult = ClientHandshake.prototype.handshakeResult;
  ChangeUser.prototype.calculateNativePasswordAuthToken = ClientHandshake.prototype.calculateNativePasswordAuthToken;
  module.exports = ChangeUser;
});

// ../../../../node_modules/mysql2/lib/commands/quit.js
var require_quit = __commonJS((exports, module) => {
  var Command2 = require_command();
  var CommandCode = require_commands();
  var Packet = require_packet();

  class Quit extends Command2 {
    constructor(callback) {
      super();
      this.onResult = callback;
    }
    start(packet, connection) {
      connection._closing = true;
      const quit = new Packet(0, Buffer.from([1, 0, 0, 0, CommandCode.QUIT]), 0, 5);
      if (this.onResult) {
        this.onResult();
      }
      connection.writePacket(quit);
      return null;
    }
  }
  module.exports = Quit;
});

// ../../../../node_modules/mysql2/lib/commands/index.js
var require_commands2 = __commonJS((exports, module) => {
  var ClientHandshake = require_client_handshake();
  var ServerHandshake = require_server_handshake();
  var Query = require_query2();
  var Prepare = require_prepare();
  var CloseStatement = require_close_statement2();
  var Execute = require_execute2();
  var Ping = require_ping();
  var RegisterSlave = require_register_slave2();
  var BinlogDump = require_binlog_dump2();
  var ChangeUser = require_change_user2();
  var Quit = require_quit();
  module.exports = {
    ClientHandshake,
    ServerHandshake,
    Query,
    Prepare,
    CloseStatement,
    Execute,
    Ping,
    RegisterSlave,
    BinlogDump,
    ChangeUser,
    Quit
  };
});

// ../../../../node_modules/named-placeholders/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var hasAbortController = typeof AbortController === "function";
  var AC = hasAbortController ? AbortController : class AbortController2 {
    constructor() {
      this.signal = new AS;
    }
    abort(reason = new Error("This operation was aborted")) {
      this.signal.reason = this.signal.reason || reason;
      this.signal.aborted = true;
      this.signal.dispatchEvent({
        type: "abort",
        target: this.signal
      });
    }
  };
  var hasAbortSignal = typeof AbortSignal === "function";
  var hasACAbortSignal = typeof AC.AbortSignal === "function";
  var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
    constructor() {
      this.reason = undefined;
      this.aborted = false;
      this._listeners = [];
    }
    dispatchEvent(e) {
      if (e.type === "abort") {
        this.aborted = true;
        this.onabort(e);
        this._listeners.forEach((f) => f(e), this);
      }
    }
    onabort() {}
    addEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners.push(fn);
      }
    }
    removeEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners = this._listeners.filter((f) => f !== fn);
      }
    }
  };
  var warned = new Set;
  var deprecatedOption = (opt, instead) => {
    const code = `LRU_CACHE_OPTION_${opt}`;
    if (shouldWarn(code)) {
      warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }
  };
  var deprecatedMethod = (method, instead) => {
    const code = `LRU_CACHE_METHOD_${method}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, method);
      warn(code, `${method} method`, `cache.${instead}()`, get);
    }
  };
  var deprecatedProperty = (field, instead) => {
    const code = `LRU_CACHE_PROPERTY_${field}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, field);
      warn(code, `${field} property`, `cache.${instead}`, get);
    }
  };
  var emitWarning = (...a) => {
    typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
  };
  var shouldWarn = (code) => !warned.has(code);
  var warn = (code, what, instead, fn) => {
    warned.add(code);
    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
    emitWarning(msg, "DeprecationWarning", code, fn);
  };
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    constructor(max) {
      if (max === 0) {
        return [];
      }
      const UintArray = getUintArray(max);
      this.heap = new UintArray(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    constructor(options = {}) {
      const {
        max = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        maxEntrySize = 0,
        sizeCalculation,
        fetchMethod,
        fetchContext,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort
      } = options;
      const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.max = max;
      this.maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.maxSize;
      this.sizeCalculation = sizeCalculation || length;
      if (this.sizeCalculation) {
        if (!this.maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      this.fetchMethod = fetchMethod || null;
      if (this.fetchMethod && typeof this.fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.fetchContext = fetchContext;
      if (!this.fetchMethod && fetchContext !== undefined) {
        throw new TypeError("cannot set fetchContext without fetchMethod");
      }
      this.keyMap = new Map;
      this.keyList = new Array(max).fill(null);
      this.valList = new Array(max).fill(null);
      this.next = new UintArray(max);
      this.prev = new UintArray(max);
      this.head = 0;
      this.tail = 0;
      this.free = new Stack(max);
      this.initialFill = 1;
      this.size = 0;
      if (typeof dispose === "function") {
        this.dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.disposeAfter = disposeAfter;
        this.disposed = [];
      } else {
        this.disposeAfter = null;
        this.disposed = null;
      }
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.initializeSizeTracking();
      }
      this.allowStale = !!allowStale || !!stale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || maxAge || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.initializeTTLTracking();
      }
      if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.max && !this.maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
      if (stale) {
        deprecatedOption("stale", "allowStale");
      }
      if (maxAge) {
        deprecatedOption("maxAge", "ttl");
      }
      if (length) {
        deprecatedOption("length", "sizeCalculation");
      }
    }
    getRemainingTTL(key) {
      return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
    }
    initializeTTLTracking() {
      this.ttls = new ZeroArray(this.max);
      this.starts = new ZeroArray(this.max);
      this.setItemTTL = (index, ttl, start = perf.now()) => {
        this.starts[index] = ttl !== 0 ? start : 0;
        this.ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.isStale(index)) {
              this.delete(this.keyList[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.updateItemAge = (index) => {
        this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
      };
      this.statusTTL = (status, index) => {
        if (status) {
          status.ttl = this.ttls[index];
          status.start = this.starts[index];
          status.now = cachedNow || getNow();
          status.remainingTTL = status.now + status.ttl - status.start;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
      };
      this.isStale = (index) => {
        return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
      };
    }
    updateItemAge(_index) {}
    statusTTL(_status, _index) {}
    setItemTTL(_index, _ttl, _start) {}
    isStale(_index) {
      return false;
    }
    initializeSizeTracking() {
      this.calculatedSize = 0;
      this.sizes = new ZeroArray(this.max);
      this.removeItemSize = (index) => {
        this.calculatedSize -= this.sizes[index];
        this.sizes[index] = 0;
      };
      this.requireSize = (k, v, size, sizeCalculation) => {
        if (this.isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation or size " + "must be set.");
          }
        }
        return size;
      };
      this.addItemSize = (index, size, status) => {
        this.sizes[index] = size;
        if (this.maxSize) {
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
        }
        this.calculatedSize += this.sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.calculatedSize;
        }
      };
    }
    removeItemSize(_index) {}
    addItemSize(_index, _size) {}
    requireSize(_k, _v, size, sizeCalculation) {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
    }
    *indexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.tail;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.head) {
            break;
          } else {
            i = this.prev[i];
          }
        }
      }
    }
    *rindexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.head;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.tail) {
            break;
          } else {
            i = this.next[i];
          }
        }
      }
    }
    isValidIndex(index) {
      return index !== undefined && this.keyMap.get(this.keyList[index]) === index;
    }
    *entries() {
      for (const i of this.indexes()) {
        if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
    }
    *rentries() {
      for (const i of this.rindexes()) {
        if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
    }
    *keys() {
      for (const i of this.indexes()) {
        if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield this.keyList[i];
        }
      }
    }
    *rkeys() {
      for (const i of this.rindexes()) {
        if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield this.keyList[i];
        }
      }
    }
    *values() {
      for (const i of this.indexes()) {
        if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield this.valList[i];
        }
      }
    }
    *rvalues() {
      for (const i of this.rindexes()) {
        if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
          yield this.valList[i];
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(fn, getOptions) {
      for (const i of this.indexes()) {
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        if (fn(value, this.keyList[i], this)) {
          return this.get(this.keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.indexes()) {
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.rindexes()) {
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.keyList[i], this);
      }
    }
    get prune() {
      deprecatedMethod("prune", "purgeStale");
      return this.purgeStale;
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.rindexes({ allowStale: true })) {
        if (this.isStale(i)) {
          this.delete(this.keyList[i]);
          deleted = true;
        }
      }
      return deleted;
    }
    dump() {
      const arr = [];
      for (const i of this.indexes({ allowStale: true })) {
        const key = this.keyList[i];
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        const entry = { value };
        if (this.ttls) {
          entry.ttl = this.ttls[i];
          const age = perf.now() - this.starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.sizes) {
          entry.size = this.sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    dispose(_v, _k, _reason) {}
    set(k, v, {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      status
    } = {}) {
      size = this.requireSize(k, v, size, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.delete(k);
        return this;
      }
      let index = this.size === 0 ? undefined : this.keyMap.get(k);
      if (index === undefined) {
        index = this.newIndex();
        this.keyList[index] = k;
        this.valList[index] = v;
        this.keyMap.set(k, index);
        this.next[this.tail] = index;
        this.prev[index] = this.tail;
        this.tail = index;
        this.size++;
        this.addItemSize(index, size, status);
        if (status) {
          status.set = "add";
        }
        noUpdateTTL = false;
      } else {
        this.moveToTail(index);
        const oldVal = this.valList[index];
        if (v !== oldVal) {
          if (this.isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
          } else {
            if (!noDisposeOnSet) {
              this.dispose(oldVal, k, "set");
              if (this.disposeAfter) {
                this.disposed.push([oldVal, k, "set"]);
              }
            }
          }
          this.removeItemSize(index);
          this.valList[index] = v;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
        this.initializeTTLTracking();
      }
      if (!noUpdateTTL) {
        this.setItemTTL(index, ttl, start);
      }
      this.statusTTL(status, index);
      if (this.disposeAfter) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return this;
    }
    newIndex() {
      if (this.size === 0) {
        return this.tail;
      }
      if (this.size === this.max && this.max !== 0) {
        return this.evict(false);
      }
      if (this.free.length !== 0) {
        return this.free.pop();
      }
      return this.initialFill++;
    }
    pop() {
      if (this.size) {
        const val = this.valList[this.head];
        this.evict(true);
        return val;
      }
    }
    evict(free) {
      const head = this.head;
      const k = this.keyList[head];
      const v = this.valList[head];
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else {
        this.dispose(v, k, "evict");
        if (this.disposeAfter) {
          this.disposed.push([v, k, "evict"]);
        }
      }
      this.removeItemSize(head);
      if (free) {
        this.keyList[head] = null;
        this.valList[head] = null;
        this.free.push(head);
      }
      this.head = this.next[head];
      this.keyMap.delete(k);
      this.size--;
      return head;
    }
    has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        if (!this.isStale(index)) {
          if (updateAgeOnHas) {
            this.updateItemAge(index);
          }
          if (status)
            status.has = "hit";
          this.statusTTL(status, index);
          return true;
        } else if (status) {
          status.has = "stale";
          this.statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    peek(k, { allowStale = this.allowStale } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined && (allowStale || !this.isStale(index))) {
        const v = this.valList[index];
        return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.valList[index];
      if (this.isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      if (options.signal) {
        options.signal.addEventListener("abort", () => ac.abort(options.signal.reason));
      }
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        if (this.valList[index] === p2) {
          if (v2 === undefined) {
            if (p2.__staleWhileFetching) {
              this.valList[index] = p2.__staleWhileFetching;
            } else {
              this.delete(k);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        if (this.valList[index] === p2) {
          const del = !noDelete || p2.__staleWhileFetching === undefined;
          if (del) {
            this.delete(k);
          } else if (!allowStaleAborted) {
            this.valList[index] = p2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && p2.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true;
          }
          return p2.__staleWhileFetching;
        } else if (p2.__returned === p2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        this.fetchMethod(k, v, fetchOpts).then((v2) => res(v2), rej);
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res();
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p2 = new Promise(pcall).then(cb, eb);
      p2.__abortController = ac;
      p2.__staleWhileFetching = v;
      p2.__returned = null;
      if (index === undefined) {
        this.set(k, p2, { ...fetchOpts.options, status: undefined });
        index = this.keyMap.get(k);
      } else {
        this.valList[index] = p2;
      }
      return p2;
    }
    isBackgroundFetch(p2) {
      return p2 && typeof p2 === "object" && typeof p2.then === "function" && Object.prototype.hasOwnProperty.call(p2, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p2, "__returned") && (p2.__returned === p2 || p2.__returned === null);
    }
    async fetch(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      fetchContext = this.fetchContext,
      forceRefresh = false,
      status,
      signal
    } = {}) {
      if (!this.fetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.keyMap.get(k);
      if (index === undefined) {
        if (status)
          status.fetch = "miss";
        const p2 = this.backgroundFetch(k, index, options, fetchContext);
        return p2.__returned = p2;
      } else {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          this.statusTTL(status, index);
          return v;
        }
        const p2 = this.backgroundFetch(k, index, options, fetchContext);
        const hasStale = p2.__staleWhileFetching !== undefined;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = hasStale && isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
      }
    }
    get(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      status
    } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        const value = this.valList[index];
        const fetching = this.isBackgroundFetch(value);
        this.statusTTL(status, index);
        if (this.isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            if (status)
              status.returnedStale = allowStale;
            return allowStale ? value : undefined;
          } else {
            if (status) {
              status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;
            }
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    connect(p2, n) {
      this.prev[n] = p2;
      this.next[p2] = n;
    }
    moveToTail(index) {
      if (index !== this.tail) {
        if (index === this.head) {
          this.head = this.next[index];
        } else {
          this.connect(this.prev[index], this.next[index]);
        }
        this.connect(this.tail, index);
        this.tail = index;
      }
    }
    get del() {
      deprecatedMethod("del", "delete");
      return this.delete;
    }
    delete(k) {
      let deleted = false;
      if (this.size !== 0) {
        const index = this.keyMap.get(k);
        if (index !== undefined) {
          deleted = true;
          if (this.size === 1) {
            this.clear();
          } else {
            this.removeItemSize(index);
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else {
              this.dispose(v, k, "delete");
              if (this.disposeAfter) {
                this.disposed.push([v, k, "delete"]);
              }
            }
            this.keyMap.delete(k);
            this.keyList[index] = null;
            this.valList[index] = null;
            if (index === this.tail) {
              this.tail = this.prev[index];
            } else if (index === this.head) {
              this.head = this.next[index];
            } else {
              this.next[this.prev[index]] = this.next[index];
              this.prev[this.next[index]] = this.prev[index];
            }
            this.size--;
            this.free.push(index);
          }
        }
      }
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return deleted;
    }
    clear() {
      for (const index of this.rindexes({ allowStale: true })) {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.keyList[index];
          this.dispose(v, k, "delete");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "delete"]);
          }
        }
      }
      this.keyMap.clear();
      this.valList.fill(null);
      this.keyList.fill(null);
      if (this.ttls) {
        this.ttls.fill(0);
        this.starts.fill(0);
      }
      if (this.sizes) {
        this.sizes.fill(0);
      }
      this.head = 0;
      this.tail = 0;
      this.initialFill = 1;
      this.free.length = 0;
      this.calculatedSize = 0;
      this.size = 0;
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
    }
    get reset() {
      deprecatedMethod("reset", "clear");
      return this.clear;
    }
    get length() {
      deprecatedProperty("length", "size");
      return this.size;
    }
    static get AbortController() {
      return AC;
    }
    static get AbortSignal() {
      return AS;
    }
  }
  module.exports = LRUCache;
});

// ../../../../node_modules/named-placeholders/index.js
var require_named_placeholders = __commonJS((exports, module) => {
  var RE_PARAM = /(?:\?)|(?::(\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g;
  var DQUOTE = 34;
  var SQUOTE = 39;
  var BSLASH = 92;
  function parse(query2) {
    let ppos = RE_PARAM.exec(query2);
    let curpos = 0;
    let start = 0;
    let end;
    const parts = [];
    let inQuote = false;
    let escape = false;
    let qchr;
    const tokens = [];
    let qcnt = 0;
    let lastTokenEndPos = 0;
    let i;
    if (ppos) {
      do {
        for (i = curpos, end = ppos.index;i < end; ++i) {
          let chr = query2.charCodeAt(i);
          if (chr === BSLASH)
            escape = !escape;
          else {
            if (escape) {
              escape = false;
              continue;
            }
            if (inQuote && chr === qchr) {
              if (query2.charCodeAt(i + 1) === qchr) {
                ++i;
                continue;
              }
              inQuote = false;
            } else if (chr === DQUOTE || chr === SQUOTE) {
              inQuote = true;
              qchr = chr;
            }
          }
        }
        if (!inQuote) {
          parts.push(query2.substring(start, end));
          tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);
          start = end + ppos[0].length;
          lastTokenEndPos = start;
        }
        curpos = end + ppos[0].length;
      } while (ppos = RE_PARAM.exec(query2));
      if (tokens.length) {
        if (curpos < query2.length) {
          parts.push(query2.substring(lastTokenEndPos));
        }
        return [parts, tokens];
      }
    }
    return [query2];
  }
  function createCompiler(config) {
    if (!config)
      config = {};
    if (!config.placeholder) {
      config.placeholder = "?";
    }
    let ncache = 100;
    let cache;
    if (typeof config.cache === "number") {
      ncache = config.cache;
    }
    if (typeof config.cache === "object") {
      cache = config.cache;
    }
    if (config.cache !== false && !cache) {
      cache = new (require_lru_cache())({ max: ncache });
    }
    function toArrayParams(tree, params) {
      const arr = [];
      if (tree.length == 1) {
        return [tree[0], []];
      }
      if (typeof params == "undefined")
        throw new Error("Named query contains placeholders, but parameters object is undefined");
      const tokens = tree[1];
      for (let i = 0;i < tokens.length; ++i) {
        arr.push(params[tokens[i]]);
      }
      return [tree[0], arr];
    }
    function noTailingSemicolon(s) {
      if (s.slice(-1) == ":") {
        return s.slice(0, -1);
      }
      return s;
    }
    function join(tree) {
      if (tree.length == 1) {
        return tree;
      }
      let unnamed = noTailingSemicolon(tree[0][0]);
      for (let i = 1;i < tree[0].length; ++i) {
        if (tree[0][i - 1].slice(-1) == ":") {
          unnamed += config.placeholder;
        }
        unnamed += config.placeholder;
        unnamed += noTailingSemicolon(tree[0][i]);
      }
      const last = tree[0][tree[0].length - 1];
      if (tree[0].length == tree[1].length) {
        if (last.slice(-1) == ":") {
          unnamed += config.placeholder;
        }
        unnamed += config.placeholder;
      }
      return [unnamed, tree[1]];
    }
    function compile(query2, paramsObj) {
      let tree;
      if (cache && (tree = cache.get(query2))) {
        return toArrayParams(tree, paramsObj);
      }
      tree = join(parse(query2));
      if (cache) {
        cache.set(query2, tree);
      }
      return toArrayParams(tree, paramsObj);
    }
    compile.parse = parse;
    return compile;
  }
  function toNumbered(q, params) {
    const tree = parse(q);
    const paramsArr = [];
    if (tree.length == 1) {
      return [tree[0], paramsArr];
    }
    const pIndexes = {};
    let pLastIndex = 0;
    let qs = "";
    let varIndex;
    const varNames = [];
    for (let i = 0;i < tree[0].length; ++i) {
      varIndex = pIndexes[tree[1][i]];
      if (!varIndex) {
        varIndex = ++pLastIndex;
        pIndexes[tree[1][i]] = varIndex;
      }
      if (tree[1][i]) {
        varNames[varIndex - 1] = tree[1][i];
        qs += tree[0][i] + "$" + varIndex;
      } else {
        qs += tree[0][i];
      }
    }
    return [qs, varNames.map((n) => params[n])];
  }
  module.exports = createCompiler;
  module.exports.toNumbered = toNumbered;
});

// ../../../../node_modules/mysql2/lib/base/connection.js
var require_connection = __commonJS((exports, module) => {
  var Net = __require("net");
  var Tls = __require("tls");
  var Timers = __require("timers");
  var EventEmitter2 = __require("events").EventEmitter;
  var Readable = __require("stream").Readable;
  var Queue = require_denque();
  var SqlString = require_SqlString();
  var { createLRU } = require_lib11();
  var PacketParser = require_packet_parser();
  var Packets = require_packets();
  var Commands = require_commands2();
  var ConnectionConfig = require_connection_config();
  var CharsetToEncoding = require_charset_encodings();
  var _connectionId = 0;
  var convertNamedPlaceholders = null;

  class BaseConnection extends EventEmitter2 {
    constructor(opts) {
      super();
      this.config = opts.config;
      if (!opts.config.stream) {
        if (opts.config.socketPath) {
          this.stream = Net.connect(opts.config.socketPath);
        } else {
          this.stream = Net.connect(opts.config.port, opts.config.host);
          if (this.config.enableKeepAlive) {
            this.stream.on("connect", () => {
              this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
            });
          }
          this.stream.setNoDelay(true);
        }
      } else if (typeof opts.config.stream === "function") {
        this.stream = opts.config.stream(opts);
      } else {
        this.stream = opts.config.stream;
      }
      this._internalId = _connectionId++;
      this._commands = new Queue;
      this._command = null;
      this._paused = false;
      this._paused_packets = new Queue;
      this._statements = createLRU({
        max: this.config.maxPreparedStatements,
        onEviction: function(_, statement) {
          statement.close();
        }
      });
      this.serverCapabilityFlags = 0;
      this.authorized = false;
      this.sequenceId = 0;
      this.compressedSequenceId = 0;
      this.threadId = null;
      this._handshakePacket = null;
      this._fatalError = null;
      this._protocolError = null;
      this._outOfOrderPackets = [];
      this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];
      this.stream.on("error", this._handleNetworkError.bind(this));
      this.packetParser = new PacketParser((p2) => {
        this.handlePacket(p2);
      });
      this.stream.on("data", (data) => {
        if (this.connectTimeout) {
          Timers.clearTimeout(this.connectTimeout);
          this.connectTimeout = null;
        }
        this.packetParser.execute(data);
      });
      this.stream.on("end", () => {
        this.emit("end");
      });
      this.stream.on("close", () => {
        if (this._closing) {
          return;
        }
        if (!this._protocolError) {
          this._protocolError = new Error("Connection lost: The server closed the connection.");
          this._protocolError.fatal = true;
          this._protocolError.code = "PROTOCOL_CONNECTION_LOST";
        }
        this._notifyError(this._protocolError);
      });
      let handshakeCommand;
      if (!this.config.isServer) {
        handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);
        handshakeCommand.on("end", () => {
          if (!handshakeCommand.handshake || this._fatalError || this._protocolError) {
            return;
          }
          this._handshakePacket = handshakeCommand.handshake;
          this.threadId = handshakeCommand.handshake.connectionId;
          this.emit("connect", handshakeCommand.handshake);
        });
        handshakeCommand.on("error", (err2) => {
          this._closing = true;
          this._notifyError(err2);
        });
        this.addCommand(handshakeCommand);
      }
      this.serverEncoding = "utf8";
      if (this.config.connectTimeout) {
        const timeoutHandler = this._handleTimeoutError.bind(this);
        this.connectTimeout = Timers.setTimeout(timeoutHandler, this.config.connectTimeout);
      }
    }
    _addCommandClosedState(cmd) {
      const err2 = new Error("Can't add new command when connection is in closed state");
      err2.fatal = true;
      if (cmd.onResult) {
        cmd.onResult(err2);
      } else {
        this.emit("error", err2);
      }
    }
    _handleFatalError(err2) {
      err2.fatal = true;
      this.stream.removeAllListeners("data");
      this.addCommand = this._addCommandClosedState;
      this.write = () => {
        this.emit("error", new Error("Can't write in closed state"));
      };
      this._notifyError(err2);
      this._fatalError = err2;
    }
    _handleNetworkError(err2) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      if (err2.code === "ECONNRESET" && this._closing) {
        return;
      }
      this._handleFatalError(err2);
    }
    _handleTimeoutError() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.stream.destroy && this.stream.destroy();
      const err2 = new Error("connect ETIMEDOUT");
      err2.errorno = "ETIMEDOUT";
      err2.code = "ETIMEDOUT";
      err2.syscall = "connect";
      this._handleNetworkError(err2);
    }
    _notifyError(err2) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      if (this._fatalError) {
        return;
      }
      let command;
      let bubbleErrorToConnection = !this._command;
      if (this._command && this._command.onResult) {
        this._command.onResult(err2);
        this._command = null;
      } else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) {
        bubbleErrorToConnection = true;
      }
      while (command = this._commands.shift()) {
        if (command.onResult) {
          command.onResult(err2);
        } else {
          bubbleErrorToConnection = true;
        }
      }
      if (bubbleErrorToConnection || this._pool) {
        this.emit("error", err2);
      }
      if (err2.fatal) {
        this.close();
      }
    }
    write(buffer) {
      const result = this.stream.write(buffer, (err2) => {
        if (err2) {
          this._handleNetworkError(err2);
        }
      });
      if (!result) {
        this.stream.emit("pause");
      }
    }
    _resetSequenceId() {
      this.sequenceId = 0;
      this.compressedSequenceId = 0;
    }
    _bumpCompressedSequenceId(numPackets) {
      this.compressedSequenceId += numPackets;
      this.compressedSequenceId %= 256;
    }
    _bumpSequenceId(numPackets) {
      this.sequenceId += numPackets;
      this.sequenceId %= 256;
    }
    writePacket(packet) {
      const MAX_PACKET_LENGTH = 16777215;
      const length = packet.length();
      let chunk, offset, header;
      if (length < MAX_PACKET_LENGTH) {
        packet.writeHeader(this.sequenceId);
        if (this.config.debug) {
          console.log(`${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(",")})`);
          console.log(`${this._internalId} ${this.connectionId} <== ${packet.buffer.toString("hex")}`);
        }
        this._bumpSequenceId(1);
        this.write(packet.buffer);
      } else {
        if (this.config.debug) {
          console.log(`${this._internalId} ${this.connectionId} <== Writing large packet, raw content not written:`);
          console.log(`${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(",")})`);
        }
        for (offset = 4;offset < 4 + length; offset += MAX_PACKET_LENGTH) {
          chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);
          if (chunk.length === MAX_PACKET_LENGTH) {
            header = Buffer.from([255, 255, 255, this.sequenceId]);
          } else {
            header = Buffer.from([
              chunk.length & 255,
              chunk.length >> 8 & 255,
              chunk.length >> 16 & 255,
              this.sequenceId
            ]);
          }
          this._bumpSequenceId(1);
          this.write(header);
          this.write(chunk);
        }
      }
    }
    startTLS(onSecure) {
      if (this.config.debug) {
        console.log("Upgrading connection to TLS");
      }
      const secureContext = Tls.createSecureContext({
        ca: this.config.ssl.ca,
        cert: this.config.ssl.cert,
        ciphers: this.config.ssl.ciphers,
        key: this.config.ssl.key,
        passphrase: this.config.ssl.passphrase,
        minVersion: this.config.ssl.minVersion,
        maxVersion: this.config.ssl.maxVersion
      });
      const rejectUnauthorized = this.config.ssl.rejectUnauthorized;
      const verifyIdentity = this.config.ssl.verifyIdentity;
      const servername = this.config.host;
      let secureEstablished = false;
      this.stream.removeAllListeners("data");
      const secureSocket = Tls.connect({
        rejectUnauthorized,
        requestCert: rejectUnauthorized,
        checkServerIdentity: verifyIdentity ? Tls.checkServerIdentity : function() {
          return;
        },
        secureContext,
        isServer: false,
        socket: this.stream,
        servername
      }, () => {
        secureEstablished = true;
        if (rejectUnauthorized) {
          if (typeof servername === "string" && verifyIdentity) {
            const cert = secureSocket.getPeerCertificate(true);
            const serverIdentityCheckError = Tls.checkServerIdentity(servername, cert);
            if (serverIdentityCheckError) {
              onSecure(serverIdentityCheckError);
              return;
            }
          }
        }
        onSecure();
      });
      secureSocket.on("error", (err2) => {
        if (secureEstablished) {
          this._handleNetworkError(err2);
        } else {
          onSecure(err2);
        }
      });
      secureSocket.on("data", (data) => {
        this.packetParser.execute(data);
      });
      this.write = (buffer) => secureSocket.write(buffer);
    }
    protocolError(message, code) {
      if (this._closing) {
        return;
      }
      const err2 = new Error(message);
      err2.fatal = true;
      err2.code = code || "PROTOCOL_ERROR";
      this.emit("error", err2);
    }
    get fatalError() {
      return this._fatalError;
    }
    handlePacket(packet) {
      if (this._paused) {
        this._paused_packets.push(packet);
        return;
      }
      if (this.config.debug) {
        if (packet) {
          console.log(` raw: ${packet.buffer.slice(packet.offset, packet.offset + packet.length()).toString("hex")}`);
          console.trace();
          const commandName = this._command ? this._command._commandName : "(no command)";
          const stateName = this._command ? this._command.stateName() : "(no command)";
          console.log(`${this._internalId} ${this.connectionId} ==> ${commandName}#${stateName}(${[packet.sequenceId, packet.type(), packet.length()].join(",")})`);
        }
      }
      if (!this._command) {
        const marker = packet.peekByte();
        if (marker === 255) {
          const error = Packets.Error.fromPacket(packet);
          this.protocolError(error.message, error.code);
        } else {
          this.protocolError("Unexpected packet while no commands in the queue", "PROTOCOL_UNEXPECTED_PACKET");
        }
        this.close();
        return;
      }
      if (packet) {
        if (this.sequenceId !== packet.sequenceId) {
          const err2 = new Error(`Warning: got packets out of order. Expected ${this.sequenceId} but received ${packet.sequenceId}`);
          err2.expected = this.sequenceId;
          err2.received = packet.sequenceId;
          this.emit("warn", err2);
          console.error(err2.message);
        }
        this._bumpSequenceId(packet.numPackets);
      }
      try {
        if (this._fatalError) {
          return;
        }
        const done = this._command.execute(packet, this);
        if (done) {
          this._command = this._commands.shift();
          if (this._command) {
            this.sequenceId = 0;
            this.compressedSequenceId = 0;
            this.handlePacket();
          }
        }
      } catch (err2) {
        this._handleFatalError(err2);
        this.stream.destroy();
      }
    }
    addCommand(cmd) {
      if (this.config.debug) {
        const commandName = cmd.constructor.name;
        console.log(`Add command: ${commandName}`);
        cmd._commandName = commandName;
      }
      if (!this._command) {
        this._command = cmd;
        this.handlePacket();
      } else {
        this._commands.push(cmd);
      }
      return cmd;
    }
    format(sql2, values) {
      if (typeof this.config.queryFormat === "function") {
        return this.config.queryFormat.call(this, sql2, values, this.config.timezone);
      }
      const opts = {
        sql: sql2,
        values
      };
      this._resolveNamedPlaceholders(opts);
      return SqlString.format(opts.sql, opts.values, this.config.stringifyObjects, this.config.timezone);
    }
    escape(value) {
      return SqlString.escape(value, false, this.config.timezone);
    }
    escapeId(value) {
      return SqlString.escapeId(value, false);
    }
    raw(sql2) {
      return SqlString.raw(sql2);
    }
    _resolveNamedPlaceholders(options) {
      let unnamed;
      if (this.config.namedPlaceholders || options.namedPlaceholders) {
        if (Array.isArray(options.values)) {
          return;
        }
        if (convertNamedPlaceholders === null) {
          convertNamedPlaceholders = require_named_placeholders()();
        }
        unnamed = convertNamedPlaceholders(options.sql, options.values);
        options.sql = unnamed[0];
        options.values = unnamed[1];
      }
    }
    query(sql2, values, cb) {
      let cmdQuery;
      if (sql2.constructor === Commands.Query) {
        cmdQuery = sql2;
      } else {
        cmdQuery = BaseConnection.createQuery(sql2, values, cb, this.config);
      }
      this._resolveNamedPlaceholders(cmdQuery);
      const rawSql = this.format(cmdQuery.sql, cmdQuery.values !== undefined ? cmdQuery.values : []);
      cmdQuery.sql = rawSql;
      return this.addCommand(cmdQuery);
    }
    pause() {
      this._paused = true;
      this.stream.pause();
    }
    resume() {
      let packet;
      this._paused = false;
      while (packet = this._paused_packets.shift()) {
        this.handlePacket(packet);
        if (this._paused) {
          return;
        }
      }
      this.stream.resume();
    }
    prepare(options, cb) {
      if (typeof options === "string") {
        options = { sql: options };
      }
      return this.addCommand(new Commands.Prepare(options, cb));
    }
    unprepare(sql2) {
      let options = {};
      if (typeof sql2 === "object") {
        options = sql2;
      } else {
        options.sql = sql2;
      }
      const key = BaseConnection.statementKey(options);
      const stmt = this._statements.get(key);
      if (stmt) {
        this._statements.delete(key);
        stmt.close();
      }
      return stmt;
    }
    execute(sql2, values, cb) {
      let options = {
        infileStreamFactory: this.config.infileStreamFactory
      };
      if (typeof sql2 === "object") {
        options = {
          ...options,
          ...sql2,
          sql: sql2.sql,
          values: sql2.values
        };
        if (typeof values === "function") {
          cb = values;
        } else {
          options.values = options.values || values;
        }
      } else if (typeof values === "function") {
        cb = values;
        options.sql = sql2;
        options.values = undefined;
      } else {
        options.sql = sql2;
        options.values = values;
      }
      this._resolveNamedPlaceholders(options);
      if (options.values) {
        if (!Array.isArray(options.values)) {
          throw new TypeError("Bind parameters must be array if namedPlaceholders parameter is not enabled");
        }
        options.values.forEach((val) => {
          if (!Array.isArray(options.values)) {
            throw new TypeError("Bind parameters must be array if namedPlaceholders parameter is not enabled");
          }
          if (val === undefined) {
            throw new TypeError("Bind parameters must not contain undefined. To pass SQL NULL specify JS null");
          }
          if (typeof val === "function") {
            throw new TypeError("Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first");
          }
        });
      }
      const executeCommand = new Commands.Execute(options, cb);
      const prepareCommand = new Commands.Prepare(options, (err2, stmt) => {
        if (err2) {
          executeCommand.start = function() {
            return null;
          };
          if (cb) {
            cb(err2);
          } else {
            executeCommand.emit("error", err2);
          }
          executeCommand.emit("end");
          return;
        }
        executeCommand.statement = stmt;
      });
      this.addCommand(prepareCommand);
      this.addCommand(executeCommand);
      return executeCommand;
    }
    changeUser(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      const charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;
      return this.addCommand(new Commands.ChangeUser({
        user: options.user || this.config.user,
        password: options.password || options.password1 || this.config.password || this.config.password1,
        password2: options.password2 || this.config.password2,
        password3: options.password3 || this.config.password3,
        passwordSha1: options.passwordSha1 || this.config.passwordSha1,
        database: options.database || this.config.database,
        timeout: options.timeout,
        charsetNumber,
        currentConfig: this.config
      }, (err2) => {
        if (err2) {
          err2.fatal = true;
        }
        if (callback) {
          callback(err2);
        }
      }));
    }
    beginTransaction(cb) {
      return this.query("START TRANSACTION", cb);
    }
    commit(cb) {
      return this.query("COMMIT", cb);
    }
    rollback(cb) {
      return this.query("ROLLBACK", cb);
    }
    ping(cb) {
      return this.addCommand(new Commands.Ping(cb));
    }
    _registerSlave(opts, cb) {
      return this.addCommand(new Commands.RegisterSlave(opts, cb));
    }
    _binlogDump(opts, cb) {
      return this.addCommand(new Commands.BinlogDump(opts, cb));
    }
    destroy() {
      this.close();
    }
    close() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this._closing = true;
      this.stream.end();
      this.addCommand = this._addCommandClosedState;
    }
    createBinlogStream(opts) {
      let test = 1;
      const stream = new Readable({ objectMode: true });
      stream._read = function() {
        return {
          data: test++
        };
      };
      this._registerSlave(opts, () => {
        const dumpCmd = this._binlogDump(opts);
        dumpCmd.on("event", (ev) => {
          stream.push(ev);
        });
        dumpCmd.on("eof", () => {
          stream.push(null);
          if (opts.flags && opts.flags & 1) {
            this.close();
          }
        });
      });
      return stream;
    }
    connect(cb) {
      if (!cb) {
        return;
      }
      if (this._fatalError || this._protocolError) {
        return cb(this._fatalError || this._protocolError);
      }
      if (this._handshakePacket) {
        return cb(null, this);
      }
      let connectCalled = 0;
      function callbackOnce(isErrorHandler) {
        return function(param) {
          if (!connectCalled) {
            if (isErrorHandler) {
              cb(param);
            } else {
              cb(null, param);
            }
          }
          connectCalled = 1;
        };
      }
      this.once("error", callbackOnce(true));
      this.once("connect", callbackOnce(false));
    }
    writeColumns(columns) {
      this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
      columns.forEach((column) => {
        this.writePacket(Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding));
      });
      this.writeEof();
    }
    writeTextRow(column) {
      this.writePacket(Packets.TextRow.toPacket(column, this.serverConfig.encoding));
    }
    writeBinaryRow(column) {
      this.writePacket(Packets.BinaryRow.toPacket(column, this.serverConfig.encoding));
    }
    writeTextResult(rows, columns, binary = false) {
      this.writeColumns(columns);
      rows.forEach((row) => {
        const arrayRow = new Array(columns.length);
        columns.forEach((column) => {
          arrayRow.push(row[column.name]);
        });
        if (binary) {
          this.writeBinaryRow(arrayRow);
        } else
          this.writeTextRow(arrayRow);
      });
      this.writeEof();
    }
    writeEof(warnings, statusFlags) {
      this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
    }
    writeOk(args) {
      if (!args) {
        args = { affectedRows: 0 };
      }
      this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
    }
    writeError(args) {
      const encoding = this.serverConfig ? this.serverConfig.encoding : "cesu8";
      this.writePacket(Packets.Error.toPacket(args, encoding));
    }
    serverHandshake(args) {
      this.serverConfig = args;
      this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];
      return this.addCommand(new Commands.ServerHandshake(args));
    }
    end(callback) {
      if (this.config.isServer) {
        this._closing = true;
        const quitCmd2 = new EventEmitter2;
        setImmediate(() => {
          this.stream.end();
          quitCmd2.emit("end");
        });
        return quitCmd2;
      }
      const quitCmd = this.addCommand(new Commands.Quit(callback));
      this.addCommand = this._addCommandClosedState;
      return quitCmd;
    }
    static createQuery(sql2, values, cb, config) {
      let options = {
        rowsAsArray: config.rowsAsArray,
        infileStreamFactory: config.infileStreamFactory
      };
      if (typeof sql2 === "object") {
        options = {
          ...options,
          ...sql2,
          sql: sql2.sql,
          values: sql2.values
        };
        if (typeof values === "function") {
          cb = values;
        } else if (values !== undefined) {
          options.values = values;
        }
      } else if (typeof values === "function") {
        cb = values;
        options.sql = sql2;
        options.values = undefined;
      } else {
        options.sql = sql2;
        options.values = values;
      }
      return new Commands.Query(options, cb);
    }
    static statementKey(options) {
      return `${typeof options.nestTables}/${options.nestTables}/${options.rowsAsArray}${options.sql}`;
    }
  }
  module.exports = BaseConnection;
});

// ../../../../node_modules/mysql2/lib/promise/make_done_cb.js
var require_make_done_cb = __commonJS((exports, module) => {
  function makeDoneCb(resolve, reject, localErr) {
    return function(err2, rows, fields) {
      if (err2) {
        localErr.message = err2.message;
        localErr.code = err2.code;
        localErr.errno = err2.errno;
        localErr.sql = err2.sql;
        localErr.sqlState = err2.sqlState;
        localErr.sqlMessage = err2.sqlMessage;
        reject(localErr);
      } else {
        resolve([rows, fields]);
      }
    };
  }
  module.exports = makeDoneCb;
});

// ../../../../node_modules/mysql2/lib/promise/prepared_statement_info.js
var require_prepared_statement_info = __commonJS((exports, module) => {
  var makeDoneCb = require_make_done_cb();

  class PromisePreparedStatementInfo {
    constructor(statement, promiseImpl) {
      this.statement = statement;
      this.Promise = promiseImpl;
    }
    execute(parameters) {
      const s = this.statement;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (parameters) {
          s.execute(parameters, done);
        } else {
          s.execute(done);
        }
      });
    }
    close() {
      return new this.Promise((resolve) => {
        this.statement.close();
        resolve();
      });
    }
  }
  module.exports = PromisePreparedStatementInfo;
});

// ../../../../node_modules/mysql2/lib/promise/inherit_events.js
var require_inherit_events = __commonJS((exports, module) => {
  function inheritEvents(source, target, events2) {
    const listeners = {};
    target.on("newListener", (eventName) => {
      if (events2.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.on(eventName, listeners[eventName] = function() {
          const args = [].slice.call(arguments);
          args.unshift(eventName);
          target.emit.apply(target, args);
        });
      }
    }).on("removeListener", (eventName) => {
      if (events2.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.removeListener(eventName, listeners[eventName]);
        delete listeners[eventName];
      }
    });
  }
  module.exports = inheritEvents;
});

// ../../../../node_modules/mysql2/lib/promise/connection.js
var require_connection2 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var PromisePreparedStatementInfo = require_prepared_statement_info();
  var makeDoneCb = require_make_done_cb();
  var inheritEvents = require_inherit_events();
  var BaseConnection = require_connection();

  class PromiseConnection extends EventEmitter2 {
    constructor(connection, promiseImpl) {
      super();
      this.connection = connection;
      this.Promise = promiseImpl || Promise;
      inheritEvents(connection, this, [
        "error",
        "drain",
        "connect",
        "end",
        "enqueue"
      ]);
    }
    release() {
      this.connection.release();
    }
    query(query2, params) {
      const c = this.connection;
      const localErr = new Error;
      if (typeof params === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (params !== undefined) {
          c.query(query2, params, done);
        } else {
          c.query(query2, done);
        }
      });
    }
    execute(query2, params) {
      const c = this.connection;
      const localErr = new Error;
      if (typeof params === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (params !== undefined) {
          c.execute(query2, params, done);
        } else {
          c.execute(query2, done);
        }
      });
    }
    end() {
      return new this.Promise((resolve) => {
        this.connection.end(resolve);
      });
    }
    beginTransaction() {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.beginTransaction(done);
      });
    }
    commit() {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.commit(done);
      });
    }
    rollback() {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        c.rollback(done);
      });
    }
    ping() {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        c.ping((err2) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            resolve(true);
          }
        });
      });
    }
    connect() {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        c.connect((err2, param) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            resolve(param);
          }
        });
      });
    }
    prepare(options) {
      const c = this.connection;
      const promiseImpl = this.Promise;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        c.prepare(options, (err2, statement) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            const wrappedStatement = new PromisePreparedStatementInfo(statement, promiseImpl);
            resolve(wrappedStatement);
          }
        });
      });
    }
    changeUser(options) {
      const c = this.connection;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        c.changeUser(options, (err2) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
    get config() {
      return this.connection.config;
    }
    get threadId() {
      return this.connection.threadId;
    }
  }
  (function(functionsToWrap) {
    for (let i = 0;functionsToWrap && i < functionsToWrap.length; i++) {
      const func = functionsToWrap[i];
      if (typeof BaseConnection.prototype[func] === "function" && PromiseConnection.prototype[func] === undefined) {
        PromiseConnection.prototype[func] = function factory(funcName) {
          return function() {
            return BaseConnection.prototype[funcName].apply(this.connection, arguments);
          };
        }(func);
      }
    }
  })([
    "close",
    "createBinlogStream",
    "destroy",
    "escape",
    "escapeId",
    "format",
    "pause",
    "pipe",
    "resume",
    "unprepare"
  ]);
  module.exports = PromiseConnection;
});

// ../../../../node_modules/mysql2/lib/connection.js
var require_connection3 = __commonJS((exports, module) => {
  var BaseConnection = require_connection();

  class Connection extends BaseConnection {
    promise(promiseImpl) {
      const PromiseConnection = require_connection2();
      return new PromiseConnection(this, promiseImpl);
    }
  }
  module.exports = Connection;
});

// ../../../../node_modules/mysql2/lib/create_connection.js
var require_create_connection = __commonJS((exports, module) => {
  var Connection = require_connection3();
  var ConnectionConfig = require_connection_config();
  function createConnection(opts) {
    return new Connection({ config: new ConnectionConfig(opts) });
  }
  module.exports = createConnection;
});

// ../../../../node_modules/mysql2/lib/base/pool_connection.js
var require_pool_connection = __commonJS((exports, module) => {
  var BaseConnection = require_connection();

  class BasePoolConnection extends BaseConnection {
    constructor(pool, options) {
      super(options);
      this._pool = pool;
      this.lastActiveTime = Date.now();
      this.once("end", () => {
        this._removeFromPool();
      });
      this.once("error", () => {
        this._removeFromPool();
      });
    }
    release() {
      if (!this._pool || this._pool._closed) {
        return;
      }
      this.lastActiveTime = Date.now();
      this._pool.releaseConnection(this);
    }
    end() {
      const err2 = new Error("Calling conn.end() to release a pooled connection is " + "deprecated. In next version calling conn.end() will be " + "restored to default conn.end() behavior. Use " + "conn.release() instead.");
      this.emit("warn", err2);
      console.warn(err2.message);
      this.release();
    }
    destroy() {
      this._removeFromPool();
      super.destroy();
    }
    _removeFromPool() {
      if (!this._pool || this._pool._closed) {
        return;
      }
      const pool = this._pool;
      this._pool = null;
      pool._removeConnection(this);
    }
  }
  BasePoolConnection.statementKey = BaseConnection.statementKey;
  module.exports = BasePoolConnection;
  BasePoolConnection.prototype._realEnd = BaseConnection.prototype.end;
});

// ../../../../node_modules/mysql2/lib/promise/pool_connection.js
var require_pool_connection2 = __commonJS((exports, module) => {
  var PromiseConnection = require_connection2();
  var BasePoolConnection = require_pool_connection();

  class PromisePoolConnection extends PromiseConnection {
    constructor(connection, promiseImpl) {
      super(connection, promiseImpl);
    }
    destroy() {
      return BasePoolConnection.prototype.destroy.apply(this.connection, arguments);
    }
  }
  module.exports = PromisePoolConnection;
});

// ../../../../node_modules/mysql2/lib/pool_connection.js
var require_pool_connection3 = __commonJS((exports, module) => {
  var BasePoolConnection = require_pool_connection();

  class PoolConnection extends BasePoolConnection {
    promise(promiseImpl) {
      const PromisePoolConnection = require_pool_connection2();
      return new PromisePoolConnection(this, promiseImpl);
    }
  }
  module.exports = PoolConnection;
});

// ../../../../node_modules/mysql2/lib/base/pool.js
var require_pool = __commonJS((exports, module) => {
  var process2 = __require("process");
  var SqlString = require_SqlString();
  var EventEmitter2 = __require("events").EventEmitter;
  var PoolConnection = require_pool_connection3();
  var Queue = require_denque();
  var BaseConnection = require_connection();
  function spliceConnection(queue, connection) {
    const len = queue.length;
    for (let i = 0;i < len; i++) {
      if (queue.get(i) === connection) {
        queue.removeOne(i);
        break;
      }
    }
  }

  class BasePool extends EventEmitter2 {
    constructor(options) {
      super();
      this.config = options.config;
      this.config.connectionConfig.pool = this;
      this._allConnections = new Queue;
      this._freeConnections = new Queue;
      this._connectionQueue = new Queue;
      this._closed = false;
      if (this.config.maxIdle < this.config.connectionLimit) {
        this._removeIdleTimeoutConnections();
      }
    }
    getConnection(cb) {
      if (this._closed) {
        return process2.nextTick(() => cb(new Error("Pool is closed.")));
      }
      let connection;
      if (this._freeConnections.length > 0) {
        connection = this._freeConnections.pop();
        this.emit("acquire", connection);
        return process2.nextTick(() => cb(null, connection));
      }
      if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
        connection = new PoolConnection(this, {
          config: this.config.connectionConfig
        });
        this._allConnections.push(connection);
        return connection.connect((err2) => {
          if (this._closed) {
            return cb(new Error("Pool is closed."));
          }
          if (err2) {
            return cb(err2);
          }
          this.emit("connection", connection);
          this.emit("acquire", connection);
          return cb(null, connection);
        });
      }
      if (!this.config.waitForConnections) {
        return process2.nextTick(() => cb(new Error("No connections available.")));
      }
      if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {
        return cb(new Error("Queue limit reached."));
      }
      this.emit("enqueue");
      return this._connectionQueue.push(cb);
    }
    releaseConnection(connection) {
      let cb;
      if (!connection._pool) {
        if (this._connectionQueue.length) {
          cb = this._connectionQueue.shift();
          process2.nextTick(this.getConnection.bind(this, cb));
        }
      } else if (this._connectionQueue.length) {
        cb = this._connectionQueue.shift();
        process2.nextTick(cb.bind(null, null, connection));
      } else {
        this._freeConnections.push(connection);
        this.emit("release", connection);
      }
    }
    end(cb) {
      this._closed = true;
      clearTimeout(this._removeIdleTimeoutConnectionsTimer);
      if (typeof cb !== "function") {
        cb = function(err2) {
          if (err2) {
            throw err2;
          }
        };
      }
      let calledBack = false;
      let closedConnections = 0;
      let connection;
      const endCB = function(err2) {
        if (calledBack) {
          return;
        }
        if (err2 || ++closedConnections >= this._allConnections.length) {
          calledBack = true;
          cb(err2);
          return;
        }
      }.bind(this);
      if (this._allConnections.length === 0) {
        endCB();
        return;
      }
      for (let i = 0;i < this._allConnections.length; i++) {
        connection = this._allConnections.get(i);
        connection._realEnd(endCB);
      }
    }
    query(sql2, values, cb) {
      const cmdQuery = BaseConnection.createQuery(sql2, values, cb, this.config.connectionConfig);
      if (typeof cmdQuery.namedPlaceholders === "undefined") {
        cmdQuery.namedPlaceholders = this.config.connectionConfig.namedPlaceholders;
      }
      this.getConnection((err2, conn) => {
        if (err2) {
          if (typeof cmdQuery.onResult === "function") {
            cmdQuery.onResult(err2);
          } else {
            cmdQuery.emit("error", err2);
          }
          return;
        }
        try {
          conn.query(cmdQuery).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
      return cmdQuery;
    }
    execute(sql2, values, cb) {
      if (typeof values === "function") {
        cb = values;
        values = [];
      }
      this.getConnection((err2, conn) => {
        if (err2) {
          return cb(err2);
        }
        try {
          conn.execute(sql2, values, cb).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          return cb(e);
        }
      });
    }
    _removeConnection(connection) {
      spliceConnection(this._allConnections, connection);
      spliceConnection(this._freeConnections, connection);
      this.releaseConnection(connection);
    }
    _removeIdleTimeoutConnections() {
      if (this._removeIdleTimeoutConnectionsTimer) {
        clearTimeout(this._removeIdleTimeoutConnectionsTimer);
      }
      this._removeIdleTimeoutConnectionsTimer = setTimeout(() => {
        try {
          while (this._freeConnections.length > this.config.maxIdle || this._freeConnections.length > 0 && Date.now() - this._freeConnections.get(0).lastActiveTime > this.config.idleTimeout) {
            this._freeConnections.get(0).destroy();
          }
        } finally {
          this._removeIdleTimeoutConnections();
        }
      }, 1000);
    }
    format(sql2, values) {
      return SqlString.format(sql2, values, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
    }
    escape(value) {
      return SqlString.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
    }
    escapeId(value) {
      return SqlString.escapeId(value, false);
    }
  }
  module.exports = BasePool;
});

// ../../../../node_modules/mysql2/lib/promise/pool.js
var require_pool2 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var makeDoneCb = require_make_done_cb();
  var PromisePoolConnection = require_pool_connection2();
  var inheritEvents = require_inherit_events();
  var BasePool = require_pool();

  class PromisePool extends EventEmitter2 {
    constructor(pool, thePromise) {
      super();
      this.pool = pool;
      this.Promise = thePromise || Promise;
      inheritEvents(pool, this, ["acquire", "connection", "enqueue", "release"]);
    }
    getConnection() {
      const corePool = this.pool;
      return new this.Promise((resolve, reject) => {
        corePool.getConnection((err2, coreConnection) => {
          if (err2) {
            reject(err2);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        });
      });
    }
    releaseConnection(connection) {
      if (connection instanceof PromisePoolConnection)
        connection.release();
    }
    query(sql2, args) {
      const corePool = this.pool;
      const localErr = new Error;
      if (typeof args === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (args !== undefined) {
          corePool.query(sql2, args, done);
        } else {
          corePool.query(sql2, done);
        }
      });
    }
    execute(sql2, args) {
      const corePool = this.pool;
      const localErr = new Error;
      if (typeof args === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        if (args) {
          corePool.execute(sql2, args, done);
        } else {
          corePool.execute(sql2, done);
        }
      });
    }
    end() {
      const corePool = this.pool;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        corePool.end((err2) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }
  (function(functionsToWrap) {
    for (let i = 0;functionsToWrap && i < functionsToWrap.length; i++) {
      const func = functionsToWrap[i];
      if (typeof BasePool.prototype[func] === "function" && PromisePool.prototype[func] === undefined) {
        PromisePool.prototype[func] = function factory(funcName) {
          return function() {
            return BasePool.prototype[funcName].apply(this.pool, arguments);
          };
        }(func);
      }
    }
  })([
    "escape",
    "escapeId",
    "format"
  ]);
  module.exports = PromisePool;
});

// ../../../../node_modules/mysql2/lib/pool.js
var require_pool3 = __commonJS((exports, module) => {
  var BasePool = require_pool();

  class Pool extends BasePool {
    promise(promiseImpl) {
      const PromisePool = require_pool2();
      return new PromisePool(this, promiseImpl);
    }
  }
  module.exports = Pool;
});

// ../../../../node_modules/mysql2/lib/pool_config.js
var require_pool_config = __commonJS((exports, module) => {
  var ConnectionConfig = require_connection_config();

  class PoolConfig {
    constructor(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      }
      this.connectionConfig = new ConnectionConfig(options);
      this.waitForConnections = options.waitForConnections === undefined ? true : Boolean(options.waitForConnections);
      this.connectionLimit = isNaN(options.connectionLimit) ? 10 : Number(options.connectionLimit);
      this.maxIdle = isNaN(options.maxIdle) ? this.connectionLimit : Number(options.maxIdle);
      this.idleTimeout = isNaN(options.idleTimeout) ? 60000 : Number(options.idleTimeout);
      this.queueLimit = isNaN(options.queueLimit) ? 0 : Number(options.queueLimit);
    }
  }
  module.exports = PoolConfig;
});

// ../../../../node_modules/mysql2/lib/pool_cluster.js
var require_pool_cluster = __commonJS((exports, module) => {
  var process2 = __require("process");
  var Pool = require_pool3();
  var PoolConfig = require_pool_config();
  var Connection = require_connection3();
  var EventEmitter2 = __require("events").EventEmitter;
  var makeSelector = {
    RR() {
      let index = 0;
      return (clusterIds) => clusterIds[index++ % clusterIds.length];
    },
    RANDOM() {
      return (clusterIds) => clusterIds[Math.floor(Math.random() * clusterIds.length)];
    },
    ORDER() {
      return (clusterIds) => clusterIds[0];
    }
  };
  var getMonotonicMilliseconds = function() {
    let ms;
    if (typeof process2.hrtime === "function") {
      ms = process2.hrtime();
      ms = ms[0] * 1000 + ms[1] * 0.000001;
    } else {
      ms = process2.uptime() * 1000;
    }
    return Math.floor(ms);
  };
  var patternRegExp = function(pattern) {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    const source = pattern.replace(/([.+?^=!:${}()|[\]/\\])/g, "\\$1").replace(/\*/g, ".*");
    return new RegExp(`^${source}$`);
  };

  class PoolNamespace {
    constructor(cluster, pattern, selector) {
      this._cluster = cluster;
      this._pattern = pattern;
      this._selector = makeSelector[selector]();
    }
    getConnection(cb) {
      const clusterNode = this._getClusterNode();
      if (clusterNode === null) {
        let err2 = new Error("Pool does Not exist.");
        err2.code = "POOL_NOEXIST";
        if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
          err2 = new Error("Pool does Not have online node.");
          err2.code = "POOL_NONEONLINE";
        }
        return cb(err2);
      }
      return this._cluster._getConnection(clusterNode, (err2, connection) => {
        if (err2) {
          if (this._cluster._canRetry && this._cluster._findNodeIds(this._pattern).length !== 0) {
            this._cluster.emit("warn", err2);
            return this.getConnection(cb);
          }
          return cb(err2);
        }
        return cb(null, connection);
      });
    }
    query(sql2, values, cb) {
      const query2 = Connection.createQuery(sql2, values, cb, {});
      this.getConnection((err2, conn) => {
        if (err2) {
          if (typeof query2.onResult === "function") {
            query2.onResult(err2);
          } else {
            query2.emit("error", err2);
          }
          return;
        }
        try {
          conn.query(query2).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
      return query2;
    }
    execute(sql2, values, cb) {
      if (typeof values === "function") {
        cb = values;
        values = [];
      }
      this.getConnection((err2, conn) => {
        if (err2) {
          return cb(err2);
        }
        try {
          conn.execute(sql2, values, cb).once("end", () => {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
    }
    _getClusterNode() {
      const foundNodeIds = this._cluster._findNodeIds(this._pattern);
      if (foundNodeIds.length === 0) {
        return null;
      }
      const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);
      return this._cluster._getNode(nodeId);
    }
  }

  class PoolCluster extends EventEmitter2 {
    constructor(config) {
      super();
      config = config || {};
      this._canRetry = typeof config.canRetry === "undefined" ? true : config.canRetry;
      this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
      this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
      this._defaultSelector = config.defaultSelector || "RR";
      this._closed = false;
      this._lastId = 0;
      this._nodes = {};
      this._serviceableNodeIds = [];
      this._namespaces = {};
      this._findCaches = {};
    }
    of(pattern, selector) {
      pattern = pattern || "*";
      selector = selector || this._defaultSelector;
      selector = selector.toUpperCase();
      if (!makeSelector[selector] === "undefined") {
        selector = this._defaultSelector;
      }
      const key = pattern + selector;
      if (typeof this._namespaces[key] === "undefined") {
        this._namespaces[key] = new PoolNamespace(this, pattern, selector);
      }
      return this._namespaces[key];
    }
    add(id, config) {
      if (typeof id === "object") {
        config = id;
        id = `CLUSTER::${++this._lastId}`;
      }
      if (typeof this._nodes[id] === "undefined") {
        this._nodes[id] = {
          id,
          errorCount: 0,
          pool: new Pool({ config: new PoolConfig(config) }),
          _offlineUntil: 0
        };
        this._serviceableNodeIds.push(id);
        this._clearFindCaches();
      }
    }
    remove(pattern) {
      const foundNodeIds = this._findNodeIds(pattern, true);
      for (let i = 0;i < foundNodeIds.length; i++) {
        const node = this._getNode(foundNodeIds[i]);
        if (node) {
          this._removeNode(node);
        }
      }
    }
    getConnection(pattern, selector, cb) {
      let namespace;
      if (typeof pattern === "function") {
        cb = pattern;
        namespace = this.of();
      } else {
        if (typeof selector === "function") {
          cb = selector;
          selector = this._defaultSelector;
        }
        namespace = this.of(pattern, selector);
      }
      namespace.getConnection(cb);
    }
    end(callback) {
      const cb = callback !== undefined ? callback : (err2) => {
        if (err2) {
          throw err2;
        }
      };
      if (this._closed) {
        process2.nextTick(cb);
        return;
      }
      this._closed = true;
      let calledBack = false;
      let waitingClose = 0;
      const onEnd = (err2) => {
        if (!calledBack && (err2 || --waitingClose <= 0)) {
          calledBack = true;
          return cb(err2);
        }
      };
      for (const id in this._nodes) {
        waitingClose++;
        this._nodes[id].pool.end(onEnd);
      }
      if (waitingClose === 0) {
        process2.nextTick(onEnd);
      }
    }
    _findNodeIds(pattern, includeOffline) {
      let currentTime = 0;
      let foundNodeIds = this._findCaches[pattern];
      if (foundNodeIds === undefined) {
        const expression = patternRegExp(pattern);
        foundNodeIds = this._serviceableNodeIds.filter((id) => id.match(expression));
      }
      this._findCaches[pattern] = foundNodeIds;
      if (includeOffline) {
        return foundNodeIds;
      }
      return foundNodeIds.filter((nodeId) => {
        const node = this._getNode(nodeId);
        if (!node._offlineUntil) {
          return true;
        }
        if (!currentTime) {
          currentTime = getMonotonicMilliseconds();
        }
        return node._offlineUntil <= currentTime;
      });
    }
    _getNode(id) {
      return this._nodes[id] || null;
    }
    _increaseErrorCount(node) {
      const errorCount = ++node.errorCount;
      if (this._removeNodeErrorCount > errorCount) {
        return;
      }
      if (this._restoreNodeTimeout > 0) {
        node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
        this.emit("offline", node.id);
        return;
      }
      this._removeNode(node);
      this.emit("remove", node.id);
    }
    _decreaseErrorCount(node) {
      let errorCount = node.errorCount;
      if (errorCount > this._removeNodeErrorCount) {
        errorCount = this._removeNodeErrorCount;
      }
      if (errorCount < 1) {
        errorCount = 1;
      }
      node.errorCount = errorCount - 1;
      if (node._offlineUntil) {
        node._offlineUntil = 0;
        this.emit("online", node.id);
      }
    }
    _getConnection(node, cb) {
      node.pool.getConnection((err2, connection) => {
        if (err2) {
          this._increaseErrorCount(node);
          return cb(err2);
        }
        this._decreaseErrorCount(node);
        connection._clusterId = node.id;
        return cb(null, connection);
      });
    }
    _removeNode(node) {
      const index = this._serviceableNodeIds.indexOf(node.id);
      if (index !== -1) {
        this._serviceableNodeIds.splice(index, 1);
        delete this._nodes[node.id];
        this._clearFindCaches();
        node.pool.end();
      }
    }
    _clearFindCaches() {
      this._findCaches = {};
    }
  }
  module.exports = PoolCluster;
});

// ../../../../node_modules/mysql2/lib/create_pool.js
var require_create_pool = __commonJS((exports, module) => {
  var Pool = require_pool3();
  var PoolConfig = require_pool_config();
  function createPool(config) {
    return new Pool({ config: new PoolConfig(config) });
  }
  module.exports = createPool;
});

// ../../../../node_modules/mysql2/lib/create_pool_cluster.js
var require_create_pool_cluster = __commonJS((exports, module) => {
  var PoolCluster = require_pool_cluster();
  function createPoolCluster(config) {
    return new PoolCluster(config);
  }
  module.exports = createPoolCluster;
});

// ../../../../node_modules/mysql2/lib/server.js
var require_server = __commonJS((exports, module) => {
  var net = __require("net");
  var EventEmitter2 = __require("events").EventEmitter;
  var Connection = require_connection3();
  var ConnectionConfig = require_connection_config();

  class Server extends EventEmitter2 {
    constructor() {
      super();
      this.connections = [];
      this._server = net.createServer(this._handleConnection.bind(this));
    }
    _handleConnection(socket) {
      const connectionConfig = new ConnectionConfig({
        stream: socket,
        isServer: true
      });
      const connection = new Connection({ config: connectionConfig });
      this.emit("connection", connection);
    }
    listen(port) {
      this._port = port;
      this._server.listen.apply(this._server, arguments);
      return this;
    }
    close(cb) {
      this._server.close(cb);
    }
  }
  module.exports = Server;
});

// ../../../../node_modules/mysql2/lib/auth_plugins/index.js
var require_auth_plugins = __commonJS((exports, module) => {
  module.exports = {
    caching_sha2_password: require_caching_sha2_password(),
    mysql_clear_password: require_mysql_clear_password(),
    mysql_native_password: require_mysql_native_password(),
    sha256_password: require_sha256_password()
  };
});

// ../../../../node_modules/mysql2/lib/promise/pool_cluster.js
var require_pool_cluster2 = __commonJS((exports, module) => {
  var PromisePoolConnection = require_pool_connection2();
  var makeDoneCb = require_make_done_cb();

  class PromisePoolNamespace {
    constructor(poolNamespace, thePromise) {
      this.poolNamespace = poolNamespace;
      this.Promise = thePromise || Promise;
    }
    getConnection() {
      const corePoolNamespace = this.poolNamespace;
      return new this.Promise((resolve, reject) => {
        corePoolNamespace.getConnection((err2, coreConnection) => {
          if (err2) {
            reject(err2);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        });
      });
    }
    query(sql2, values) {
      const corePoolNamespace = this.poolNamespace;
      const localErr = new Error;
      if (typeof values === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolNamespace.query(sql2, values, done);
      });
    }
    execute(sql2, values) {
      const corePoolNamespace = this.poolNamespace;
      const localErr = new Error;
      if (typeof values === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolNamespace.execute(sql2, values, done);
      });
    }
  }
  module.exports = PromisePoolNamespace;
});

// ../../../../node_modules/mysql2/promise.js
var require_promise = __commonJS((exports) => {
  var SqlString = require_SqlString();
  var EventEmitter2 = __require("events").EventEmitter;
  var parserCache = require_parser_cache();
  var PoolCluster = require_pool_cluster();
  var createConnection = require_create_connection();
  var createPool = require_create_pool();
  var createPoolCluster = require_create_pool_cluster();
  var PromiseConnection = require_connection2();
  var PromisePool = require_pool2();
  var makeDoneCb = require_make_done_cb();
  var PromisePoolConnection = require_pool_connection2();
  var inheritEvents = require_inherit_events();
  var PromisePoolNamespace = require_pool_cluster2();
  function createConnectionPromise(opts) {
    const coreConnection = createConnection(opts);
    const createConnectionErr = new Error;
    const thePromise = opts.Promise || Promise;
    if (!thePromise) {
      throw new Error("no Promise implementation available." + "Use promise-enabled node version or pass userland Promise" + " implementation as parameter, for example: { Promise: require('bluebird') }");
    }
    return new thePromise((resolve, reject) => {
      coreConnection.once("connect", () => {
        resolve(new PromiseConnection(coreConnection, thePromise));
      });
      coreConnection.once("error", (err2) => {
        createConnectionErr.message = err2.message;
        createConnectionErr.code = err2.code;
        createConnectionErr.errno = err2.errno;
        createConnectionErr.sqlState = err2.sqlState;
        reject(createConnectionErr);
      });
    });
  }
  function createPromisePool(opts) {
    const corePool = createPool(opts);
    const thePromise = opts.Promise || Promise;
    if (!thePromise) {
      throw new Error("no Promise implementation available." + "Use promise-enabled node version or pass userland Promise" + " implementation as parameter, for example: { Promise: require('bluebird') }");
    }
    return new PromisePool(corePool, thePromise);
  }

  class PromisePoolCluster extends EventEmitter2 {
    constructor(poolCluster, thePromise) {
      super();
      this.poolCluster = poolCluster;
      this.Promise = thePromise || Promise;
      inheritEvents(poolCluster, this, ["warn", "remove", "online", "offline"]);
    }
    getConnection(pattern, selector) {
      const corePoolCluster = this.poolCluster;
      return new this.Promise((resolve, reject) => {
        corePoolCluster.getConnection(pattern, selector, (err2, coreConnection) => {
          if (err2) {
            reject(err2);
          } else {
            resolve(new PromisePoolConnection(coreConnection, this.Promise));
          }
        });
      });
    }
    query(sql2, args) {
      const corePoolCluster = this.poolCluster;
      const localErr = new Error;
      if (typeof args === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolCluster.query(sql2, args, done);
      });
    }
    execute(sql2, args) {
      const corePoolCluster = this.poolCluster;
      const localErr = new Error;
      if (typeof args === "function") {
        throw new Error("Callback function is not available with promise clients.");
      }
      return new this.Promise((resolve, reject) => {
        const done = makeDoneCb(resolve, reject, localErr);
        corePoolCluster.execute(sql2, args, done);
      });
    }
    of(pattern, selector) {
      return new PromisePoolNamespace(this.poolCluster.of(pattern, selector), this.Promise);
    }
    end() {
      const corePoolCluster = this.poolCluster;
      const localErr = new Error;
      return new this.Promise((resolve, reject) => {
        corePoolCluster.end((err2) => {
          if (err2) {
            localErr.message = err2.message;
            localErr.code = err2.code;
            localErr.errno = err2.errno;
            localErr.sqlState = err2.sqlState;
            localErr.sqlMessage = err2.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }
  (function(functionsToWrap) {
    for (let i = 0;functionsToWrap && i < functionsToWrap.length; i++) {
      const func = functionsToWrap[i];
      if (typeof PoolCluster.prototype[func] === "function" && PromisePoolCluster.prototype[func] === undefined) {
        PromisePoolCluster.prototype[func] = function factory(funcName) {
          return function() {
            return PoolCluster.prototype[funcName].apply(this.poolCluster, arguments);
          };
        }(func);
      }
    }
  })(["add", "remove"]);
  function createPromisePoolCluster(opts) {
    const corePoolCluster = createPoolCluster(opts);
    const thePromise = opts && opts.Promise || Promise;
    if (!thePromise) {
      throw new Error("no Promise implementation available." + "Use promise-enabled node version or pass userland Promise" + " implementation as parameter, for example: { Promise: require('bluebird') }");
    }
    return new PromisePoolCluster(corePoolCluster, thePromise);
  }
  exports.createConnection = createConnectionPromise;
  exports.createPool = createPromisePool;
  exports.createPoolCluster = createPromisePoolCluster;
  exports.escape = SqlString.escape;
  exports.escapeId = SqlString.escapeId;
  exports.format = SqlString.format;
  exports.raw = SqlString.raw;
  exports.PromisePool = PromisePool;
  exports.PromiseConnection = PromiseConnection;
  exports.PromisePoolConnection = PromisePoolConnection;
  exports.__defineGetter__("Types", () => require_types2());
  exports.__defineGetter__("Charsets", () => require_charsets());
  exports.__defineGetter__("CharsetToEncoding", () => require_charset_encodings());
  exports.setMaxParserCache = function(max) {
    parserCache.setMaxCache(max);
  };
  exports.clearParserCache = function() {
    parserCache.clearCache();
  };
});

// ../../../../node_modules/mysql2/index.js
var require_mysql2 = __commonJS((exports) => {
  var SqlString = require_SqlString();
  var ConnectionConfig = require_connection_config();
  var parserCache = require_parser_cache();
  var Connection = require_connection3();
  exports.createConnection = require_create_connection();
  exports.connect = exports.createConnection;
  exports.Connection = Connection;
  exports.ConnectionConfig = ConnectionConfig;
  var Pool = require_pool3();
  var PoolCluster = require_pool_cluster();
  var createPool = require_create_pool();
  var createPoolCluster = require_create_pool_cluster();
  exports.createPool = createPool;
  exports.createPoolCluster = createPoolCluster;
  exports.createQuery = Connection.createQuery;
  exports.Pool = Pool;
  exports.PoolCluster = PoolCluster;
  exports.createServer = function(handler) {
    const Server = require_server();
    const s = new Server;
    if (handler) {
      s.on("connection", handler);
    }
    return s;
  };
  exports.PoolConnection = require_pool_connection3();
  exports.authPlugins = require_auth_plugins();
  exports.escape = SqlString.escape;
  exports.escapeId = SqlString.escapeId;
  exports.format = SqlString.format;
  exports.raw = SqlString.raw;
  exports.__defineGetter__("createConnectionPromise", () => require_promise().createConnection);
  exports.__defineGetter__("createPoolPromise", () => require_promise().createPool);
  exports.__defineGetter__("createPoolClusterPromise", () => require_promise().createPoolCluster);
  exports.__defineGetter__("Types", () => require_types2());
  exports.__defineGetter__("Charsets", () => require_charsets());
  exports.__defineGetter__("CharsetToEncoding", () => require_charset_encodings());
  exports.setMaxParserCache = function(max) {
    parserCache.setMaxCache(max);
  };
  exports.clearParserCache = function() {
    parserCache.clearCache();
  };
});

// ../../../../node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform) {
    return new ArrayParser(source, transform).parse();
  };

  class ArrayParser {
    constructor(source, transform) {
      this.source = source;
      this.transform = transform || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// ../../../../node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source, transform) {
      return {
        parse: function() {
          return array.parse(source, transform);
        }
      };
    }
  };
});

// ../../../../node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date.setTime(date.getTime() - offset);
      }
    } else {
      date = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
    }
    return date;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date = new Date(year, month, day);
    if (is0To99(year)) {
      date.setFullYear(year);
    }
    return date;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// ../../../../node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty2.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// ../../../../node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend(this, parse(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// ../../../../node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// ../../../../node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p2 = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p2 = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p2 = arrayParser.create(value);
    return p2.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p2 = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p2 = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// ../../../../node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// ../../../../node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim2 = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim2; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// ../../../../node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// ../../../../node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// ../../../../node_modules/pg/lib/defaults.js
var require_defaults2 = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// ../../../../node_modules/pg/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var defaults = require_defaults2();
  var util = __require("util");
  var { isDate: isDate2 } = util.types || util;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate2(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date) {
    let offset = -date.getTimezoneOffset();
    let year = date.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + String(date.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date) {
    let year = date.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0") + "T" + String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0") + ":" + String(date.getUTCSeconds()).padStart(2, "0") + "." + String(date.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values) {
      if (typeof values === "function") {
        config.callback = values;
      } else {
        config.values = values;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// ../../../../node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  }
  function hashByName(hashName, text) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
});

// ../../../../node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hashByName(hashName, text) {
    return await subtleCrypto.digest(hashName, text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// ../../../../node_modules/pg/lib/crypto/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// ../../../../node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// ../../../../node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto = require_utils3();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto.sha256(clientKey);
    const clientSignature = await crypto.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  }
  function parseAttributePairs(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// ../../../../node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types2 = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types2;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// ../../../../node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err2) {
      err2.input && (err2.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs6 = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs6.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs6.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs6.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config.sslrootcert) {
            config.ssl.checkServerIdentity = function() {};
          } else {
            config.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse(str));
  }
  module.exports = parse;
  parse.parse = parse;
  parse.toClientConfig = toClientConfig;
  parse.parseIntoClientConfig = parseIntoClientConfig;
});

// ../../../../node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults2();
  var parse = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    const value = config[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err2, address) {
        if (err2)
          return cb(err2, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// ../../../../node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types2 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types3) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types3;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types2.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// ../../../../node_modules/pg/lib/query.js
var require_query3 = __commonJS((exports, module) => {
  var { EventEmitter: EventEmitter2 } = __require("events");
  var Result = require_result();
  var utils3 = require_utils2();

  class Query extends EventEmitter2 {
    constructor(config, values, callback) {
      super();
      config = utils3.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err2) {
        this._canceledDueToError = err2;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err2, connection) {
      if (this._canceledDueToError) {
        err2 = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err2);
      }
      this.emit("error", err2);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err2) {
          process.nextTick(() => {
            throw err2;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils3.prepareValue
        });
      } catch (err2) {
        this.handleError(err2, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// ../../../../node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// ../../../../node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// ../../../../node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query2 = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse = (query3) => {
    const name = query3.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types2 = query3.types || emptyArray;
    const len = types2.length;
    const buffer = writer.addCString(name).addCString(query3.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types2[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query: query2,
    parse,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// ../../../../node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// ../../../../node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// ../../../../node_modules/pg-protocol/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  }
  exports.parse = parse;
});

// ../../../../node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// ../../../../node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// ../../../../node_modules/pg/lib/connection.js
var require_connection4 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var { parse, serialize } = require_dist();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter2 {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error) {
        if (self2._ending && (error.code === "ECONNRESET" || error.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err2) {
          return self2.emit("error", err2);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query2) {
      this._send(serialize.parse(query2));
    }
    bind(config) {
      this._send(serialize.bind(config));
    }
    execute(config) {
      this._send(serialize.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// ../../../../node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error) {
        return cb(error);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error) {
        return cb(error);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop2(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop2;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop2;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err2, cb) {
      this._writableState.errorEmitted = false;
      cb(err2);
    };
    return stream;
  }
  module.exports = split;
});

// ../../../../node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path10 = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util.format.apply(util, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env = rawEnv || process.env;
    var file = env.PGPASSFILE || (isWin ? path10.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path10.join(env.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err2) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err2);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// ../../../../node_modules/pgpass/lib/index.js
var require_lib12 = __commonJS((exports, module) => {
  var path10 = __require("path");
  var fs6 = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs6.stat(file, function(err2, stat) {
      if (err2 || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs6.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// ../../../../node_modules/pg/lib/client.js
var require_client2 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var utils3 = require_utils2();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query3();
  var defaults = require_defaults2();
  var Connection = require_connection4();
  var crypto = require_utils3();

  class Client extends EventEmitter2 {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err2) {
      const enqueueError = (query2) => {
        process.nextTick(() => {
          query2.handleError(err2, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err2 = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err2);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error);
            } else {
              this._handleErrorEvent(error);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error) => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err2) => {
          con.emit("error", err2);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib12();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err2) {
          this.connection.emit("error", err2);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err2) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err2);
      }
      this.emit("error", err2);
    }
    _handleErrorEvent(err2) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err2);
      }
      this._queryable = false;
      this._errorAllQueries(err2);
      this.emit("error", err2);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query2) {
      if (client.activeQuery === query2) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query2) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query2), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils3.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils3.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values, callback) {
      let query2;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query2 = config;
        if (typeof values === "function") {
          query2.callback = query2.callback || values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query2 = new Query(config, values, callback);
        if (!query2.callback) {
          result = new this._Promise((resolve, reject) => {
            query2.callback = (err2, res) => err2 ? reject(err2) : resolve(res);
          }).catch((err2) => {
            Error.captureStackTrace(err2);
            throw err2;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query2.callback;
        readTimeoutTimer = setTimeout(() => {
          const error = new Error("Query read timeout");
          process.nextTick(() => {
            query2.handleError(error, this.connection);
          });
          queryCallback(error);
          query2.callback = () => {};
          const index = this.queryQueue.indexOf(query2);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query2.callback = (err2, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err2, res);
        };
      }
      if (this.binary && !query2.binary) {
        query2.binary = true;
      }
      if (query2._result && !query2._result._types) {
        query2._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query2.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query2.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query2);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// ../../../../node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err2, client) {
      err2 ? rej(err2) : res(client);
    };
    const result = new Promise2(function(resolve, reject) {
      res = resolve;
      rej = reject;
    }).catch((err2) => {
      Error.captureStackTrace(err2);
      throw err2;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err2) {
      err2.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err2);
      });
      pool._remove(client);
      pool.emit("error", err2, client);
    };
  }

  class Pool extends EventEmitter2 {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib13().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err2 = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err2, res, done) => {
          clearTimeout(tid);
          response.callback(err2, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err2) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err2) {
          this.log("client failed to connect", err2);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err2 = new Error("Connection terminated due to connection timeout", { cause: err2 });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err2, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err3, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err2) => {
            if (err2) {
              client.release(err2);
              return pendingItem.callback(err2, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err2) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err2);
      };
    }
    _release(client, idleListener, err2) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err2, client);
      if (err2 || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err2, client) => {
        if (err2) {
          return cb(err2);
        }
        let clientReleased = false;
        const onError = (err3) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err3);
          cb(err3);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text, values, (err3, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err3);
            if (err3) {
              return cb(err3);
            }
            return cb(undefined, res);
          });
        } catch (err3) {
          client.release(err3);
          return cb(err3);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err2 = new Error("Called end on pool more than once");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// ../../../../node_modules/pg/lib/native/query.js
var require_query4 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var util = __require("util");
  var utils3 = require_utils2();
  var NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter2.call(this);
    config = utils3.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util.inherits(NativeQuery, EventEmitter2);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err2) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err2[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err2);
    } else {
      this.emit("error", err2);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject) {
      this._once("end", resolve);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err2, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err2) {
        return self2.handleError(err2);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils3.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err2);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err2) {
        if (err2)
          return after(err2);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err2 = new Error("Query values must be an array");
        return after(err2);
      }
      const vals = this.values.map(utils3.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// ../../../../node_modules/pg/lib/native/client.js
var require_client3 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter2 = __require("events").EventEmitter;
  var util = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query4();
  var Client = module.exports = function(config) {
    EventEmitter2.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util.inherits(Client, EventEmitter2);
  Client.prototype._errorAllQueries = function(err2) {
    const enqueueError = (query2) => {
      process.nextTick(() => {
        query2.native = this.native;
        query2.handleError(err2);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err2, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err2)
        return cb(err2);
      self2.native.connect(conString, function(err3) {
        if (err3) {
          self2.native.end();
          return cb(err3);
        }
        self2._connected = true;
        self2.native.on("error", function(err4) {
          self2._queryable = false;
          self2._errorAllQueries(err4);
          self2.emit("error", err4);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject) => {
      this._connect((error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values, callback) {
    let query2;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query2 = config;
      if (typeof values === "function") {
        config.callback = values;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query2 = new NativeQuery(config, values, callback);
      if (!query2.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject) => {
          resolveOut = resolve;
          rejectOut = reject;
        }).catch((err2) => {
          Error.captureStackTrace(err2);
          throw err2;
        });
        query2.callback = (err2, res) => err2 ? rejectOut(err2) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query2.callback;
      readTimeoutTimer = setTimeout(() => {
        const error = new Error("Query read timeout");
        process.nextTick(() => {
          query2.handleError(error, this.connection);
        });
        queryCallback(error);
        query2.callback = () => {};
        const index = this._queryQueue.indexOf(query2);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query2.callback = (err2, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err2, res);
      };
    }
    if (!this._queryable) {
      query2.native = this.native;
      process.nextTick(() => {
        query2.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query2.native = this.native;
      process.nextTick(() => {
        query2.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query2);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject) {
        cb = (err2) => err2 ? reject(err2) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query2 = this._queryQueue.shift();
    if (!query2) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query2;
    query2.submit(this);
    const self2 = this;
    query2.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query2) {
    if (this._activeQuery === query2) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query2) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query2), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// ../../../../node_modules/pg/lib/index.js
var require_lib13 = __commonJS((exports, module) => {
  var Client = require_client2();
  var defaults = require_defaults2();
  var Connection = require_connection4();
  var Result = require_result();
  var utils3 = require_utils2();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist();
  var { escapeIdentifier, escapeLiteral } = require_utils2();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils3;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client3());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client3());
        } catch (err2) {
          if (err2.code !== "MODULE_NOT_FOUND") {
            throw err2;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// ../../../../node_modules/fdir/dist/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizePath = exports.isRootDirectory = exports.convertSlashes = exports.cleanPath = undefined;
  var path_1 = __require("path");
  function cleanPath(path11) {
    let normalized = (0, path_1.normalize)(path11);
    if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)
      normalized = normalized.substring(0, normalized.length - 1);
    return normalized;
  }
  exports.cleanPath = cleanPath;
  var SLASHES_REGEX = /[\\/]/g;
  function convertSlashes(path11, separator) {
    return path11.replace(SLASHES_REGEX, separator);
  }
  exports.convertSlashes = convertSlashes;
  var WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
  function isRootDirectory(path11) {
    return path11 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path11);
  }
  exports.isRootDirectory = isRootDirectory;
  function normalizePath(path11, options) {
    const { resolvePaths, normalizePath: normalizePath2, pathSeparator } = options;
    const pathNeedsCleaning = process.platform === "win32" && path11.includes("/") || path11.startsWith(".");
    if (resolvePaths)
      path11 = (0, path_1.resolve)(path11);
    if (normalizePath2 || pathNeedsCleaning)
      path11 = cleanPath(path11);
    if (path11 === ".")
      return "";
    const needsSeperator = path11[path11.length - 1] !== pathSeparator;
    return convertSlashes(needsSeperator ? path11 + pathSeparator : path11, pathSeparator);
  }
  exports.normalizePath = normalizePath;
});

// ../../../../node_modules/fdir/dist/api/functions/join-path.js
var require_join_path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = exports.joinDirectoryPath = exports.joinPathWithBasePath = undefined;
  var path_1 = __require("path");
  var utils_1 = require_utils4();
  function joinPathWithBasePath(filename, directoryPath) {
    return directoryPath + filename;
  }
  exports.joinPathWithBasePath = joinPathWithBasePath;
  function joinPathWithRelativePath(root, options) {
    return function(filename, directoryPath) {
      const sameRoot = directoryPath.startsWith(root);
      if (sameRoot)
        return directoryPath.replace(root, "") + filename;
      else
        return (0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
    };
  }
  function joinPath(filename) {
    return filename;
  }
  function joinDirectoryPath(filename, directoryPath, separator) {
    return directoryPath + filename + separator;
  }
  exports.joinDirectoryPath = joinDirectoryPath;
  function build(root, options) {
    const { relativePaths, includeBasePath } = options;
    return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/push-directory.js
var require_push_directory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  function pushDirectoryWithRelativePath(root) {
    return function(directoryPath, paths) {
      paths.push(directoryPath.substring(root.length) || ".");
    };
  }
  function pushDirectoryFilterWithRelativePath(root) {
    return function(directoryPath, paths, filters) {
      const relativePath = directoryPath.substring(root.length) || ".";
      if (filters.every((filter) => filter(relativePath, true))) {
        paths.push(relativePath);
      }
    };
  }
  var pushDirectory = (directoryPath, paths) => {
    paths.push(directoryPath || ".");
  };
  var pushDirectoryFilter = (directoryPath, paths, filters) => {
    const path11 = directoryPath || ".";
    if (filters.every((filter) => filter(path11, true))) {
      paths.push(path11);
    }
  };
  var empty = () => {};
  function build(root, options) {
    const { includeDirs, filters, relativePaths } = options;
    if (!includeDirs)
      return empty;
    if (relativePaths)
      return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
    return filters && filters.length ? pushDirectoryFilter : pushDirectory;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/push-file.js
var require_push_file = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var pushFileFilterAndCount = (filename, _paths, counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
      counts.files++;
  };
  var pushFileFilter = (filename, paths, _counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
      paths.push(filename);
  };
  var pushFileCount = (_filename, _paths, counts, _filters) => {
    counts.files++;
  };
  var pushFile = (filename, paths) => {
    paths.push(filename);
  };
  var empty = () => {};
  function build(options) {
    const { excludeFiles, filters, onlyCounts } = options;
    if (excludeFiles)
      return empty;
    if (filters && filters.length) {
      return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
    } else if (onlyCounts) {
      return pushFileCount;
    } else {
      return pushFile;
    }
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/get-array.js
var require_get_array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var getArray = (paths) => {
    return paths;
  };
  var getArrayGroup = () => {
    return [""].slice(0, 0);
  };
  function build(options) {
    return options.group ? getArrayGroup : getArray;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/group-files.js
var require_group_files = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var groupFiles = (groups, directory, files) => {
    groups.push({ directory, files, dir: directory });
  };
  var empty = () => {};
  function build(options) {
    return options.group ? groupFiles : empty;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/resolve-symlink.js
var require_resolve_symlink = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var fs_1 = __importDefault(__require("fs"));
  var path_1 = __require("path");
  var resolveSymlinksAsync = function(path11, state, callback) {
    const { queue, options: { suppressErrors } } = state;
    queue.enqueue();
    fs_1.default.realpath(path11, (error, resolvedPath) => {
      if (error)
        return queue.dequeue(suppressErrors ? null : error, state);
      fs_1.default.stat(resolvedPath, (error2, stat) => {
        if (error2)
          return queue.dequeue(suppressErrors ? null : error2, state);
        if (stat.isDirectory() && isRecursive(path11, resolvedPath, state))
          return queue.dequeue(null, state);
        callback(stat, resolvedPath);
        queue.dequeue(null, state);
      });
    });
  };
  var resolveSymlinks = function(path11, state, callback) {
    const { queue, options: { suppressErrors } } = state;
    queue.enqueue();
    try {
      const resolvedPath = fs_1.default.realpathSync(path11);
      const stat = fs_1.default.statSync(resolvedPath);
      if (stat.isDirectory() && isRecursive(path11, resolvedPath, state))
        return;
      callback(stat, resolvedPath);
    } catch (e2) {
      if (!suppressErrors)
        throw e2;
    }
  };
  function build(options, isSynchronous) {
    if (!options.resolveSymlinks || options.excludeSymlinks)
      return null;
    return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
  }
  exports.build = build;
  function isRecursive(path11, resolved, state) {
    if (state.options.useRealPaths)
      return isRecursiveUsingRealPaths(resolved, state);
    let parent = (0, path_1.dirname)(path11);
    let depth = 1;
    while (parent !== state.root && depth < 2) {
      const resolvedPath = state.symlinks.get(parent);
      const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
      if (isSameRoot)
        depth++;
      else
        parent = (0, path_1.dirname)(parent);
    }
    state.symlinks.set(path11, resolved);
    return depth > 1;
  }
  function isRecursiveUsingRealPaths(resolved, state) {
    return state.visited.includes(resolved + state.options.pathSeparator);
  }
});

// ../../../../node_modules/fdir/dist/api/functions/invoke-callback.js
var require_invoke_callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var onlyCountsSync = (state) => {
    return state.counts;
  };
  var groupsSync = (state) => {
    return state.groups;
  };
  var defaultSync = (state) => {
    return state.paths;
  };
  var limitFilesSync = (state) => {
    return state.paths.slice(0, state.options.maxFiles);
  };
  var onlyCountsAsync = (state, error, callback) => {
    report(error, callback, state.counts, state.options.suppressErrors);
    return null;
  };
  var defaultAsync = (state, error, callback) => {
    report(error, callback, state.paths, state.options.suppressErrors);
    return null;
  };
  var limitFilesAsync = (state, error, callback) => {
    report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
    return null;
  };
  var groupsAsync = (state, error, callback) => {
    report(error, callback, state.groups, state.options.suppressErrors);
    return null;
  };
  function report(error, callback, output, suppressErrors) {
    if (error && !suppressErrors)
      callback(error, output);
    else
      callback(null, output);
  }
  function build(options, isSynchronous) {
    const { onlyCounts, group, maxFiles } = options;
    if (onlyCounts)
      return isSynchronous ? onlyCountsSync : onlyCountsAsync;
    else if (group)
      return isSynchronous ? groupsSync : groupsAsync;
    else if (maxFiles)
      return isSynchronous ? limitFilesSync : limitFilesAsync;
    else
      return isSynchronous ? defaultSync : defaultAsync;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/functions/walk-directory.js
var require_walk_directory = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var fs_1 = __importDefault(__require("fs"));
  var readdirOpts = { withFileTypes: true };
  var walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {
    state.queue.enqueue();
    if (currentDepth < 0)
      return state.queue.dequeue(null, state);
    state.visited.push(crawlPath);
    state.counts.directories++;
    fs_1.default.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
      callback(entries, directoryPath, currentDepth);
      state.queue.dequeue(state.options.suppressErrors ? null : error, state);
    });
  };
  var walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {
    if (currentDepth < 0)
      return;
    state.visited.push(crawlPath);
    state.counts.directories++;
    let entries = [];
    try {
      entries = fs_1.default.readdirSync(crawlPath || ".", readdirOpts);
    } catch (e2) {
      if (!state.options.suppressErrors)
        throw e2;
    }
    callback(entries, directoryPath, currentDepth);
  };
  function build(isSynchronous) {
    return isSynchronous ? walkSync : walkAsync;
  }
  exports.build = build;
});

// ../../../../node_modules/fdir/dist/api/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Queue = undefined;

  class Queue {
    onQueueEmpty;
    count = 0;
    constructor(onQueueEmpty) {
      this.onQueueEmpty = onQueueEmpty;
    }
    enqueue() {
      this.count++;
      return this.count;
    }
    dequeue(error, output) {
      if (this.onQueueEmpty && (--this.count <= 0 || error)) {
        this.onQueueEmpty(error, output);
        if (error) {
          output.controller.abort();
          this.onQueueEmpty = undefined;
        }
      }
    }
  }
  exports.Queue = Queue;
});

// ../../../../node_modules/fdir/dist/api/counter.js
var require_counter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Counter = undefined;

  class Counter {
    _files = 0;
    _directories = 0;
    set files(num) {
      this._files = num;
    }
    get files() {
      return this._files;
    }
    set directories(num) {
      this._directories = num;
    }
    get directories() {
      return this._directories;
    }
    get dirs() {
      return this._directories;
    }
  }
  exports.Counter = Counter;
});

// ../../../../node_modules/fdir/dist/api/walker.js
var require_walker = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m3, k2);
    if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m3[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m3, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m3[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v3) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
  } : function(o2, v3) {
    o2["default"] = v3;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Walker = undefined;
  var path_1 = __require("path");
  var utils_1 = require_utils4();
  var joinPath = __importStar(require_join_path());
  var pushDirectory = __importStar(require_push_directory());
  var pushFile = __importStar(require_push_file());
  var getArray = __importStar(require_get_array());
  var groupFiles = __importStar(require_group_files());
  var resolveSymlink = __importStar(require_resolve_symlink());
  var invokeCallback = __importStar(require_invoke_callback());
  var walkDirectory = __importStar(require_walk_directory());
  var queue_1 = require_queue();
  var counter_1 = require_counter();

  class Walker {
    root;
    isSynchronous;
    state;
    joinPath;
    pushDirectory;
    pushFile;
    getArray;
    groupFiles;
    resolveSymlink;
    walkDirectory;
    callbackInvoker;
    constructor(root, options, callback) {
      this.isSynchronous = !callback;
      this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
      this.root = (0, utils_1.normalizePath)(root, options);
      this.state = {
        root: (0, utils_1.isRootDirectory)(this.root) ? this.root : this.root.slice(0, -1),
        paths: [""].slice(0, 0),
        groups: [],
        counts: new counter_1.Counter,
        options,
        queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),
        symlinks: new Map,
        visited: [""].slice(0, 0),
        controller: new AbortController
      };
      this.joinPath = joinPath.build(this.root, options);
      this.pushDirectory = pushDirectory.build(this.root, options);
      this.pushFile = pushFile.build(options);
      this.getArray = getArray.build(options);
      this.groupFiles = groupFiles.build(options);
      this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
      this.walkDirectory = walkDirectory.build(this.isSynchronous);
    }
    start() {
      this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
      this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
      return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
    }
    walk = (entries, directoryPath, depth) => {
      const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
      if (controller.signal.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles)
        return;
      const files = this.getArray(this.state.paths);
      for (let i2 = 0;i2 < entries.length; ++i2) {
        const entry = entries[i2];
        if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks) {
          const filename = this.joinPath(entry.name, directoryPath);
          this.pushFile(filename, files, this.state.counts, filters);
        } else if (entry.isDirectory()) {
          let path11 = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
          if (exclude && exclude(entry.name, path11))
            continue;
          this.pushDirectory(path11, paths, filters);
          this.walkDirectory(this.state, path11, path11, depth - 1, this.walk);
        } else if (this.resolveSymlink && entry.isSymbolicLink()) {
          let path11 = joinPath.joinPathWithBasePath(entry.name, directoryPath);
          this.resolveSymlink(path11, this.state, (stat, resolvedPath) => {
            if (stat.isDirectory()) {
              resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
              if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path11 + pathSeparator))
                return;
              this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path11 + pathSeparator, depth - 1, this.walk);
            } else {
              resolvedPath = useRealPaths ? resolvedPath : path11;
              const filename = (0, path_1.basename)(resolvedPath);
              const directoryPath2 = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);
              resolvedPath = this.joinPath(filename, directoryPath2);
              this.pushFile(resolvedPath, files, this.state.counts, filters);
            }
          });
        }
      }
      this.groupFiles(this.state.groups, directoryPath, files);
    };
  }
  exports.Walker = Walker;
});

// ../../../../node_modules/fdir/dist/api/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callback = exports.promise = undefined;
  var walker_1 = require_walker();
  function promise(root, options) {
    return new Promise((resolve, reject) => {
      callback(root, options, (err3, output) => {
        if (err3)
          return reject(err3);
        resolve(output);
      });
    });
  }
  exports.promise = promise;
  function callback(root, options, callback2) {
    let walker = new walker_1.Walker(root, options, callback2);
    walker.start();
  }
  exports.callback = callback;
});

// ../../../../node_modules/fdir/dist/api/sync.js
var require_sync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sync = undefined;
  var walker_1 = require_walker();
  function sync(root, options) {
    const walker = new walker_1.Walker(root, options);
    return walker.start();
  }
  exports.sync = sync;
});

// ../../../../node_modules/fdir/dist/builder/api-builder.js
var require_api_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIBuilder = undefined;
  var async_1 = require_async();
  var sync_1 = require_sync();

  class APIBuilder {
    root;
    options;
    constructor(root, options) {
      this.root = root;
      this.options = options;
    }
    withPromise() {
      return (0, async_1.promise)(this.root, this.options);
    }
    withCallback(cb) {
      (0, async_1.callback)(this.root, this.options, cb);
    }
    sync() {
      return (0, sync_1.sync)(this.root, this.options);
    }
  }
  exports.APIBuilder = APIBuilder;
});

// ../../../../node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var SEP = "/";
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR,
    SEP
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
    SEP: "\\"
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// ../../../../node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants2();
  exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports.isWindows = () => {
    if (typeof navigator !== "undefined" && navigator.platform) {
      const platform = navigator.platform.toLowerCase();
      return platform === "win32" || platform === "windows";
    }
    if (typeof process !== "undefined" && process.platform) {
      return process.platform === "win32";
    }
    return false;
  };
  exports.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
  exports.basename = (path11, { windows } = {}) => {
    const segs = path11.split(windows ? /[\\/]/ : "/");
    const last = segs[segs.length - 1];
    if (last === "") {
      return segs[segs.length - 2];
    }
    return last;
  };
});

// ../../../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports, module) => {
  var utils3 = require_utils5();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants2();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob2 = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob2 = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob2 = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob2)
        glob2 = utils3.removeBackslashes(glob2);
      if (base && backslashes === true) {
        base = utils3.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob: glob2,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0;idx < slashes.length; idx++) {
        const n2 = prevIndex ? prevIndex + 1 : start;
        const i2 = slashes[idx];
        const value = input.slice(n2, i2);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i2;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module.exports = scan;
});

// ../../../../node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var constants = require_constants2();
  var utils3 = require_utils5();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v3) => utils3.escapeRegex(v3)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options };
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const PLATFORM_CHARS = constants.globChars(opts.windows);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils3.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n2 = 1) => input[state.index + n2];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.output = (prev.output || prev.value) + tok.value;
        prev.value += tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
      push({ type: "paren", extglob: true, value: advance(), output });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse(rest, { ...options, fastpaths: false }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({ type: "paren", extglob: true, value, output });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m3;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m3 : `\\${m3}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m3) => {
            return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils3.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\x00") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({ type: "text", value });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils3.escapeRegex(value);
        prev.value += value;
        append({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: "text", value });
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({ value });
        if (opts.literalBrackets === false || utils3.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils3.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i2 = arr.length - 1;i2 >= 0; i2--) {
            tokens.pop();
            if (arr[i2].type === "brace") {
              break;
            }
            if (arr[i2].type !== "dots") {
              range.unshift(arr[i2].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t2 of toks) {
            state.output += t2.output || t2.value;
          }
        }
        push({ type: "brace", value, output });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({ type: "plus", value });
          continue;
        }
        push({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({ type: "at", extglob: true, value, output: "" });
          continue;
        }
        push({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({ type: "star", value, output: "" });
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== undefined ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = { type: "star", value, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils3.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils3.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils3.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse.fastpaths = (input, options) => {
    const opts = { ...options };
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(opts.windows);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils3.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module.exports = parse;
});

// ../../../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports, module) => {
  var scan = require_scan();
  var parse = require_parse2();
  var utils3 = require_utils5();
  var constants = require_constants2();
  var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob2, options, returnState = false) => {
    if (Array.isArray(glob2)) {
      const fns = glob2.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject2(glob2) && glob2.tokens && glob2.input;
    if (glob2 === "" || typeof glob2 !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = opts.windows;
    const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch, match, output } = picomatch.test(input, regex, options, { glob: glob2, posix });
      const result = { glob: glob2, state, regex, posix, input, output, match, isMatch };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, { glob: glob2, posix } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils3.toPosixSlashes : null);
    let match = input === glob2;
    let output = match && format ? format(input) : input;
    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob2;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return { isMatch: Boolean(match), match, output };
  };
  picomatch.matchBase = (input, glob2, options) => {
    const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
    return regex.test(utils3.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p4) => picomatch.parse(p4, options));
    return parse(pattern, { ...options, fastpaths: false });
  };
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err3) {
      if (options && options.debug === true)
        throw err3;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module.exports = picomatch;
});

// ../../../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS((exports, module) => {
  var pico = require_picomatch();
  var utils3 = require_utils5();
  function picomatch(glob2, options, returnState = false) {
    if (options && (options.windows === null || options.windows === undefined)) {
      options = { ...options, windows: utils3.isWindows() };
    }
    return pico(glob2, options, returnState);
  }
  Object.assign(picomatch, pico);
  module.exports = picomatch;
});

// ../../../../node_modules/fdir/dist/builder/index.js
var require_builder2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Builder = undefined;
  var path_1 = __require("path");
  var api_builder_1 = require_api_builder();
  var pm = null;
  try {
    __require.resolve("picomatch");
    pm = require_picomatch2();
  } catch (_e3) {}

  class Builder {
    globCache = {};
    options = {
      maxDepth: Infinity,
      suppressErrors: true,
      pathSeparator: path_1.sep,
      filters: []
    };
    globFunction;
    constructor(options) {
      this.options = { ...this.options, ...options };
      this.globFunction = this.options.globFunction;
    }
    group() {
      this.options.group = true;
      return this;
    }
    withPathSeparator(separator) {
      this.options.pathSeparator = separator;
      return this;
    }
    withBasePath() {
      this.options.includeBasePath = true;
      return this;
    }
    withRelativePaths() {
      this.options.relativePaths = true;
      return this;
    }
    withDirs() {
      this.options.includeDirs = true;
      return this;
    }
    withMaxDepth(depth) {
      this.options.maxDepth = depth;
      return this;
    }
    withMaxFiles(limit) {
      this.options.maxFiles = limit;
      return this;
    }
    withFullPaths() {
      this.options.resolvePaths = true;
      this.options.includeBasePath = true;
      return this;
    }
    withErrors() {
      this.options.suppressErrors = false;
      return this;
    }
    withSymlinks({ resolvePaths = true } = {}) {
      this.options.resolveSymlinks = true;
      this.options.useRealPaths = resolvePaths;
      return this.withFullPaths();
    }
    withAbortSignal(signal) {
      this.options.signal = signal;
      return this;
    }
    normalize() {
      this.options.normalizePath = true;
      return this;
    }
    filter(predicate) {
      this.options.filters.push(predicate);
      return this;
    }
    onlyDirs() {
      this.options.excludeFiles = true;
      this.options.includeDirs = true;
      return this;
    }
    exclude(predicate) {
      this.options.exclude = predicate;
      return this;
    }
    onlyCounts() {
      this.options.onlyCounts = true;
      return this;
    }
    crawl(root) {
      return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    withGlobFunction(fn) {
      this.globFunction = fn;
      return this;
    }
    crawlWithOptions(root, options) {
      this.options = { ...this.options, ...options };
      return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    glob(...patterns) {
      if (this.globFunction) {
        return this.globWithOptions(patterns);
      }
      return this.globWithOptions(patterns, ...[{ dot: true }]);
    }
    globWithOptions(patterns, ...options) {
      const globFn = this.globFunction || pm;
      if (!globFn) {
        throw new Error("Please specify a glob function to use glob matching.");
      }
      var isMatch = this.globCache[patterns.join("\x00")];
      if (!isMatch) {
        isMatch = globFn(patterns, ...options);
        this.globCache[patterns.join("\x00")] = isMatch;
      }
      this.options.filters.push((path11) => isMatch(path11));
      return this;
    }
  }
  exports.Builder = Builder;
});

// ../../../../node_modules/fdir/dist/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../../../node_modules/fdir/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m3, k2);
    if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m3[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m3, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m3[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
    for (var p4 in m3)
      if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
        __createBinding(exports2, m3, p4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fdir = undefined;
  var builder_1 = require_builder2();
  Object.defineProperty(exports, "fdir", { enumerable: true, get: function() {
    return builder_1.Builder;
  } });
  __exportStar(require_types3(), exports);
});

// ../../../../node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString2;
  function assertString2(input) {
    if (input === undefined || input === null)
      throw new TypeError("Expected a string but received a ".concat(input));
    if (input.constructor.name !== "String")
      throw new TypeError("Expected a string but received a ".concat(input.constructor.name));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isIP.js
var require_isIP = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP2;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  var IPv4SegmentFormat2 = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat2 = "(".concat(IPv4SegmentFormat2, "[.]){3}").concat(IPv4SegmentFormat2);
  var IPv4AddressRegExp2 = new RegExp("^".concat(IPv4AddressFormat2, "$"));
  var IPv6SegmentFormat2 = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp2 = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat2, ":){7}(?:").concat(IPv6SegmentFormat2, "|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){6}(?:").concat(IPv4AddressFormat2, "|:").concat(IPv6SegmentFormat2, "|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){5}(?::").concat(IPv4AddressFormat2, "|(:").concat(IPv6SegmentFormat2, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){4}(?:(:").concat(IPv6SegmentFormat2, "){0,1}:").concat(IPv4AddressFormat2, "|(:").concat(IPv6SegmentFormat2, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){3}(?:(:").concat(IPv6SegmentFormat2, "){0,2}:").concat(IPv4AddressFormat2, "|(:").concat(IPv6SegmentFormat2, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){2}(?:(:").concat(IPv6SegmentFormat2, "){0,3}:").concat(IPv4AddressFormat2, "|(:").concat(IPv6SegmentFormat2, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat2, ":){1}(?:(:").concat(IPv6SegmentFormat2, "){0,4}:").concat(IPv4AddressFormat2, "|(:").concat(IPv6SegmentFormat2, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat2, "){0,5}:").concat(IPv4AddressFormat2, "|(?::").concat(IPv6SegmentFormat2, "){1,7}|:))") + ")(%[0-9a-zA-Z.]{1,})?$");
  function isIP2(ipAddress) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(ipAddress);
    var version = (_typeof(options) === "object" ? options.version : arguments[1]) || "";
    if (!version) {
      return isIP2(ipAddress, {
        version: 4
      }) || isIP2(ipAddress, {
        version: 6
      });
    }
    if (version.toString() === "4") {
      return IPv4AddressRegExp2.test(ipAddress);
    }
    if (version.toString() === "6") {
      return IPv6AddressRegExp2.test(ipAddress);
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/util/merge.js
var require_merge = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge2;
  function merge2() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults3 = arguments.length > 1 ? arguments[1] : undefined;
    for (var key in defaults3) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults3[key];
      }
    }
    return obj;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isBase64.js
var require_isBase64 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase64;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var base64WithPadding = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/;
  var base64WithoutPadding = /^[A-Za-z0-9+/]+$/;
  var base64UrlWithPadding = /^(?:[A-Za-z0-9_-]{4})*(?:[A-Za-z0-9_-]{2}==|[A-Za-z0-9_-]{3}=|[A-Za-z0-9_-]{4})$/;
  var base64UrlWithoutPadding = /^[A-Za-z0-9_-]+$/;
  function isBase64(str, options) {
    var _options;
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, {
      urlSafe: false,
      padding: !((_options = options) !== null && _options !== undefined && _options.urlSafe)
    });
    if (str === "")
      return true;
    var regex;
    if (options.urlSafe) {
      regex = options.padding ? base64UrlWithPadding : base64UrlWithoutPadding;
    } else {
      regex = options.padding ? base64WithPadding : base64WithoutPadding;
    }
    return (!options.padding || str.length % 4 === 0) && regex.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isJWT.js
var require_isJWT = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJWT;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isBase = _interopRequireDefault(require_isBase64());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function isJWT(str) {
    (0, _assertString.default)(str);
    var dotSplit = str.split(".");
    var len = dotSplit.length;
    if (len !== 3) {
      return false;
    }
    return dotSplit.reduce(function(acc, currElem) {
      return acc && (0, _isBase.default)(currElem, {
        urlSafe: true
      });
    }, true);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/util/checkHost.js
var require_checkHost = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = checkHost2;
  function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  function checkHost2(host, matches) {
    for (var i2 = 0;i2 < matches.length; i2++) {
      var match = matches[i2];
      if (host === match || isRegExp2(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/util/includesString.js
var require_includesString = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var includes = function includes(str, val) {
    return str.indexOf(val) !== -1;
  };
  var _default = exports.default = includes;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN2;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var default_fqdn_options2 = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false,
    ignore_max_length: false
  };
  function isFQDN2(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_fqdn_options2);
    if (options.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
      str = str.substring(2);
    }
    var parts = str.split(".");
    var tld = parts[parts.length - 1];
    if (options.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63 && !options.ignore_max_length) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isURL.js
var require_isURL = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL2;
  var _assertString = _interopRequireDefault(require_assertString());
  var _checkHost = _interopRequireDefault(require_checkHost());
  var _includesString = _interopRequireDefault(require_includesString());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _slicedToArray(r2, e2) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if (typeof r2 == "string")
        return _arrayLikeToArray(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : undefined;
    }
  }
  function _arrayLikeToArray(r2, a2) {
    (a2 == null || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2);e2 < a2; e2++)
      n2[e2] = r2[e2];
    return n2;
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = r2 == null ? null : typeof Symbol != "undefined" && r2[Symbol.iterator] || r2["@@iterator"];
    if (t2 != null) {
      var e2, n2, i2, u2, a2 = [], f3 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, l2 === 0) {
          if (Object(t2) !== t2)
            return;
          f3 = false;
        } else
          for (;!(f3 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f3 = true)
            ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f3 && t2.return != null && (u2 = t2.return(), Object(u2) !== u2))
            return;
        } finally {
          if (o2)
            throw n2;
        }
      }
      return a2;
    }
  }
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2))
      return r2;
  }
  var default_url_options2 = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true,
    max_allowed_length: 2084
  };
  var wrapped_ipv62 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function isURL2(url, options) {
    (0, _assertString.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options = (0, _merge.default)(options, default_url_options2);
    if (options.validate_length && url.length > options.max_allowed_length) {
      return false;
    }
    if (!options.allow_fragments && (0, _includesString.default)(url, "#")) {
      return false;
    }
    if (!options.allow_query_components && ((0, _includesString.default)(url, "?") || (0, _includesString.default)(url, "&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url.split("#");
    url = split.shift();
    split = url.split("?");
    url = split.shift();
    split = url.split("://");
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === "//") {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url.slice(2);
    }
    url = split.join("://");
    if (url === "") {
      return false;
    }
    split = url.split("/");
    url = split.shift();
    if (url === "" && !options.require_host) {
      return true;
    }
    split = url.split("@");
    if (split.length > 1) {
      if (options.disallow_auth) {
        return false;
      }
      if (split[0] === "") {
        return false;
      }
      auth = split.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv62);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(":");
      host = split.shift();
      if (split.length) {
        port_str = split.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }
    if (options.host_whitelist) {
      return (0, _checkHost.default)(host, options.host_whitelist);
    }
    if (host === "" && !options.require_host) {
      return true;
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options.host_blacklist && (0, _checkHost.default)(host, options.host_blacklist)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isSlug.js
var require_isSlug = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSlug;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
  function isSlug(str) {
    (0, _assertString.default)(str);
    return charsetRegex.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/util/includesArray.js
var require_includesArray = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var includes = function includes(arr, val) {
    return arr.some(function(arrVal) {
      return val === arrVal;
    });
  };
  var _default = exports.default = includes;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isIBAN.js
var require_isIBAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIBAN;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _includesArray = _interopRequireDefault(require_includesArray());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var ibanRegexThroughCountryCode2 = {
    AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
    AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
    AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    AT: /^(AT[0-9]{2})\d{16}$/,
    AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    BA: /^(BA[0-9]{2})\d{16}$/,
    BE: /^(BE[0-9]{2})\d{12}$/,
    BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
    BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
    BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
    BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    CR: /^(CR[0-9]{2})\d{18}$/,
    CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    CZ: /^(CZ[0-9]{2})\d{20}$/,
    DE: /^(DE[0-9]{2})\d{18}$/,
    DK: /^(DK[0-9]{2})\d{14}$/,
    DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
    DZ: /^(DZ\d{24})$/,
    EE: /^(EE[0-9]{2})\d{16}$/,
    EG: /^(EG[0-9]{2})\d{25}$/,
    ES: /^(ES[0-9]{2})\d{20}$/,
    FI: /^(FI[0-9]{2})\d{14}$/,
    FO: /^(FO[0-9]{2})\d{14}$/,
    FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
    GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
    GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
    GL: /^(GL[0-9]{2})\d{14}$/,
    GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
    GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
    HR: /^(HR[0-9]{2})\d{17}$/,
    HU: /^(HU[0-9]{2})\d{24}$/,
    IE: /^(IE[0-9]{2})[A-Z]{4}\d{14}$/,
    IL: /^(IL[0-9]{2})\d{19}$/,
    IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
    IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
    IS: /^(IS[0-9]{2})\d{22}$/,
    IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
    KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
    KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
    LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
    LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    LT: /^(LT[0-9]{2})\d{16}$/,
    LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
    MA: /^(MA[0-9]{26})$/,
    MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
    ME: /^(ME[0-9]{2})\d{18}$/,
    MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
    MR: /^(MR[0-9]{2})\d{23}$/,
    MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
    MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
    MZ: /^(MZ[0-9]{2})\d{21}$/,
    NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
    NO: /^(NO[0-9]{2})\d{11}$/,
    PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
    PL: /^(PL[0-9]{2})\d{24}$/,
    PS: /^(PS[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
    PT: /^(PT[0-9]{2})\d{21}$/,
    QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
    RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
    RS: /^(RS[0-9]{2})\d{18}$/,
    SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
    SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
    SE: /^(SE[0-9]{2})\d{20}$/,
    SI: /^(SI[0-9]{2})\d{15}$/,
    SK: /^(SK[0-9]{2})\d{20}$/,
    SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    TL: /^(TL[0-9]{2})\d{19}$/,
    TN: /^(TN[0-9]{2})\d{20}$/,
    TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
    UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
    VA: /^(VA[0-9]{2})\d{18}$/,
    VG: /^(VG[0-9]{2})[A-Z]{4}\d{16}$/,
    XK: /^(XK[0-9]{2})\d{16}$/
  };
  function hasOnlyValidCountryCodes(countryCodeArray) {
    var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
      return !(countryCode in ibanRegexThroughCountryCode2);
    });
    if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
      return false;
    }
    return true;
  }
  function hasValidIbanFormat(str, options) {
    var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
    var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
    var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode2;
    if (options.whitelist) {
      if (!hasOnlyValidCountryCodes(options.whitelist)) {
        return false;
      }
      var isoCountryCodeInWhiteList = (0, _includesArray.default)(options.whitelist, isoCountryCode);
      if (!isoCountryCodeInWhiteList) {
        return false;
      }
    }
    if (options.blacklist) {
      var isoCountryCodeInBlackList = (0, _includesArray.default)(options.blacklist, isoCountryCode);
      if (isoCountryCodeInBlackList) {
        return false;
      }
    }
    return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode2[isoCountryCode].test(strippedStr);
  }
  function hasValidIbanChecksum(str) {
    var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
    var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
    var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
      return char.charCodeAt(0) - 55;
    });
    var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
      return Number(acc + value) % 97;
    }, "");
    return remainder === 1;
  }
  function isIBAN(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(str);
    return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
  }
  var locales8 = exports.locales = Object.keys(ibanRegexThroughCountryCode2);
});

// ../../../../node_modules/validator/lib/isUUID.js
var require_isUUID = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUUID;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var uuid = {
    1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    6: /^[0-9A-F]{8}-[0-9A-F]{4}-6[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    8: /^[0-9A-F]{8}-[0-9A-F]{4}-8[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    nil: /^00000000-0000-0000-0000-000000000000$/i,
    max: /^ffffffff-ffff-ffff-ffff-ffffffffffff$/i,
    loose: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    all: /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i
  };
  function isUUID(str, version) {
    (0, _assertString.default)(str);
    if (version === undefined || version === null) {
      version = "all";
    }
    return version in uuid ? uuid[version].test(str) : false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isAscii.js
var require_isAscii = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAscii;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var ascii = /^[\x00-\x7F]+$/;
  function isAscii(str) {
    (0, _assertString.default)(str);
    return ascii.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength2;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function isByteLength2(str, options) {
    (0, _assertString.default)(str);
    var min;
    var max;
    if (_typeof(options) === "object") {
      min = options.min || 0;
      max = options.max;
    } else {
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === "undefined" || len <= max);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail2;
  var _assertString = _interopRequireDefault(require_assertString());
  var _checkHost = _interopRequireDefault(require_checkHost());
  var _isByteLength = _interopRequireDefault(require_isByteLength());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var default_email_options2 = {
    allow_display_name: false,
    allow_underscores: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: "",
    ignore_max_length: false,
    host_blacklist: [],
    host_whitelist: []
  };
  var splitNameAddress2 = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart2 = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart2 = /^[a-z\d]+$/;
  var quotedEmailUser2 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part2 = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf82 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength2 = 254;
  function validateDisplayName2(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
    if (!display_name_without_quotes.trim()) {
      return false;
    }
    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
      if (display_name_without_quotes === display_name) {
        return false;
      }
      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split("\\\"").length;
      if (!all_start_with_back_slash) {
        return false;
      }
    }
    return true;
  }
  function isEmail2(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_email_options2);
    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(splitNameAddress2);
      if (display_email) {
        var display_name = display_email[1];
        str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
        if (display_name.endsWith(" ")) {
          display_name = display_name.slice(0, -1);
        }
        if (!validateDisplayName2(display_name)) {
          return false;
        }
      } else if (options.require_display_name) {
        return false;
      }
    }
    if (!options.ignore_max_length && str.length > defaultMaxEmailLength2) {
      return false;
    }
    var parts = str.split("@");
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();
    if (options.host_blacklist.length > 0 && (0, _checkHost.default)(lower_domain, options.host_blacklist)) {
      return false;
    }
    if (options.host_whitelist.length > 0 && !(0, _checkHost.default)(lower_domain, options.host_whitelist)) {
      return false;
    }
    var user = parts.join("@");
    if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i2 = 0;i2 < _user_parts.length; i2++) {
        if (!gmailUserPart2.test(_user_parts[i2])) {
          return false;
        }
      }
    }
    if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    }))) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options.require_tld,
      ignore_max_length: options.ignore_max_length,
      allow_underscores: options.allow_underscores
    })) {
      if (!options.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.slice(1, -1);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (options.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
        return false;
    }
    if (user[0] === '"' && user[user.length - 1] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf82.test(user) : quotedEmailUser2.test(user);
    }
    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part2 : emailUserPart2;
    var user_parts = user.split(".");
    for (var _i = 0;_i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/alpha.js
var require_alpha = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.farsiLocales = exports.englishLocales = exports.dotDecimal = exports.decimal = exports.commaDecimal = exports.bengaliLocales = exports.arabicLocales = exports.alphanumeric = exports.alpha = undefined;
  var alpha2 = exports.alpha = {
    "en-US": /^[A-Z]+$/i,
    "az-AZ": /^[A-VXYZ\u00C7\u018F\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
    "bg-BG": /^[\u0410-\u042F]+$/i,
    "cs-CZ": /^[A-Z\u00C1\u010C\u010E\u00C9\u011A\u00CD\u0147\u00D3\u0158\u0160\u0164\u00DA\u016E\u00DD\u017D]+$/i,
    "da-DK": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
    "de-DE": /^[A-Z\u00C4\u00D6\u00DC\u00DF]+$/i,
    "el-GR": /^[\u0391-\u03CE]+$/i,
    "es-ES": /^[A-Z\u00C1\u00C9\u00CD\u00D1\u00D3\u00DA\u00DC]+$/i,
    "fa-IR": /^[\u0627\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u06CC]+$/i,
    "fi-FI": /^[A-Z\u00C5\u00C4\u00D6]+$/i,
    "fr-FR": /^[A-Z\u00C0\u00C2\u00C6\u00C7\u00C9\u00C8\u00CA\u00CB\u00CF\u00CE\u00D4\u0152\u00D9\u00DB\u00DC\u0178]+$/i,
    "it-IT": /^[A-Z\u00C0\u00C9\u00C8\u00CC\u00CE\u00D3\u00D2\u00D9]+$/i,
    "ja-JP": /^[\u3041-\u3093\u30A1-\u30F6\uFF66-\uFF9F\u4E00-\u9FA0\u30FC\u30FB\u3002\u3001]+$/i,
    "nb-NO": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
    "nl-NL": /^[A-Z\u00C1\u00C9\u00CB\u00CF\u00D3\u00D6\u00DC\u00DA]+$/i,
    "nn-NO": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
    "hu-HU": /^[A-Z\u00C1\u00C9\u00CD\u00D3\u00D6\u0150\u00DA\u00DC\u0170]+$/i,
    "pl-PL": /^[A-Z\u0104\u0106\u0118\u015A\u0141\u0143\u00D3\u017B\u0179]+$/i,
    "pt-PT": /^[A-Z\u00C3\u00C1\u00C0\u00C2\u00C4\u00C7\u00C9\u00CA\u00CB\u00CD\u00CF\u00D5\u00D3\u00D4\u00D6\u00DA\u00DC]+$/i,
    "ru-RU": /^[\u0410-\u042F\u0401]+$/i,
    "kk-KZ": /^[\u0410-\u042F\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    "sl-SI": /^[A-Z\u010C\u0106\u0110\u0160\u017D]+$/i,
    "sk-SK": /^[A-Z\u00C1\u010C\u010E\u00C9\u00CD\u0147\u00D3\u0160\u0164\u00DA\u00DD\u017D\u0139\u0154\u013D\u00C4\u00D4]+$/i,
    "sr-RS@latin": /^[A-Z\u010C\u0106\u017D\u0160\u0110]+$/i,
    "sr-RS": /^[\u0410-\u042F\u0402\u0408\u0409\u040A\u040B\u040F]+$/i,
    "sv-SE": /^[A-Z\u00C5\u00C4\u00D6]+$/i,
    "th-TH": /^[\u0E01-\u0E50\s]+$/i,
    "tr-TR": /^[A-Z\u00C7\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
    "uk-UA": /^[\u0410-\u0429\u042C\u042E\u042F\u0404I\u0407\u0490\u0456]+$/i,
    "vi-VN": /^[A-Z\u00C0\u00C1\u1EA0\u1EA2\u00C3\u00C2\u1EA6\u1EA4\u1EAC\u1EA8\u1EAA\u0102\u1EB0\u1EAE\u1EB6\u1EB2\u1EB4\u0110\u00C8\u00C9\u1EB8\u1EBA\u1EBC\u00CA\u1EC0\u1EBE\u1EC6\u1EC2\u1EC4\u00CC\u00CD\u1ECA\u1EC8\u0128\u00D2\u00D3\u1ECC\u1ECE\u00D5\u00D4\u1ED2\u1ED0\u1ED8\u1ED4\u1ED6\u01A0\u1EDC\u1EDA\u1EE2\u1EDE\u1EE0\u00D9\u00DA\u1EE4\u1EE6\u0168\u01AF\u1EEA\u1EE8\u1EF0\u1EEC\u1EEE\u1EF2\u00DD\u1EF4\u1EF6\u1EF8]+$/i,
    "ko-KR": /^[\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]*$/,
    "ku-IQ": /^[\u0626\u0627\u0628\u067E\u062A\u062C\u0686\u062D\u062E\u062F\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063A\u0641\u06A4\u0642\u06A9\u06AF\u0644\u06B5\u0645\u0646\u0648\u06C6\u06BE\u06D5\u06CC\u06CE\u064A\u0637\u0624\u062B\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/i,
    ar: /^[\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0670]+$/,
    he: /^[\u05D0-\u05EA]+$/,
    fa: /^['\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u0629\u06CC']+$/i,
    bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098A\u098B\u098C\u098F\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099A\u099B\u099C\u099D\u099E\u099F\u09A0\u09A1\u09A2\u09A3\u09A4\u09A5\u09A6\u09A7\u09A8\u09AA\u09AB\u09AC\u09AD\u09AE\u09AF\u09B0\u09B2\u09B6\u09B7\u09B8\u09B9\u09BC\u09BD\u09BE\u09BF\u09C0\u09C1\u09C2\u09C3\u09C4\u09C7\u09C8\u09CB\u09CC\u09CD\u09CE\u09D7\u09DC\u09DD\u09DF\u09E0\u09E1\u09E2\u09E3\u09F0\u09F1\u09F2\u09F3\u09F4\u09F5\u09F6\u09F7\u09F8\u09F9\u09FA\u09FB']+$/,
    eo: /^[ABC\u0108D-G\u011CH\u0124IJ\u0134K-PRS\u015CTU\u016CVZ]+$/i,
    "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
    "si-LK": /^[\u0D80-\u0DFF]+$/
  };
  var alphanumeric3 = exports.alphanumeric = {
    "en-US": /^[0-9A-Z]+$/i,
    "az-AZ": /^[0-9A-VXYZ\u00C7\u018F\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
    "bg-BG": /^[0-9\u0410-\u042F]+$/i,
    "cs-CZ": /^[0-9A-Z\u00C1\u010C\u010E\u00C9\u011A\u00CD\u0147\u00D3\u0158\u0160\u0164\u00DA\u016E\u00DD\u017D]+$/i,
    "da-DK": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
    "de-DE": /^[0-9A-Z\u00C4\u00D6\u00DC\u00DF]+$/i,
    "el-GR": /^[0-9\u0391-\u03C9]+$/i,
    "es-ES": /^[0-9A-Z\u00C1\u00C9\u00CD\u00D1\u00D3\u00DA\u00DC]+$/i,
    "fi-FI": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
    "fr-FR": /^[0-9A-Z\u00C0\u00C2\u00C6\u00C7\u00C9\u00C8\u00CA\u00CB\u00CF\u00CE\u00D4\u0152\u00D9\u00DB\u00DC\u0178]+$/i,
    "it-IT": /^[0-9A-Z\u00C0\u00C9\u00C8\u00CC\u00CE\u00D3\u00D2\u00D9]+$/i,
    "ja-JP": /^[0-9\uFF10-\uFF19\u3041-\u3093\u30A1-\u30F6\uFF66-\uFF9F\u4E00-\u9FA0\u30FC\u30FB\u3002\u3001]+$/i,
    "hu-HU": /^[0-9A-Z\u00C1\u00C9\u00CD\u00D3\u00D6\u0150\u00DA\u00DC\u0170]+$/i,
    "nb-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
    "nl-NL": /^[0-9A-Z\u00C1\u00C9\u00CB\u00CF\u00D3\u00D6\u00DC\u00DA]+$/i,
    "nn-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
    "pl-PL": /^[0-9A-Z\u0104\u0106\u0118\u015A\u0141\u0143\u00D3\u017B\u0179]+$/i,
    "pt-PT": /^[0-9A-Z\u00C3\u00C1\u00C0\u00C2\u00C4\u00C7\u00C9\u00CA\u00CB\u00CD\u00CF\u00D5\u00D3\u00D4\u00D6\u00DA\u00DC]+$/i,
    "ru-RU": /^[0-9\u0410-\u042F\u0401]+$/i,
    "kk-KZ": /^[0-9\u0410-\u042F\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    "sl-SI": /^[0-9A-Z\u010C\u0106\u0110\u0160\u017D]+$/i,
    "sk-SK": /^[0-9A-Z\u00C1\u010C\u010E\u00C9\u00CD\u0147\u00D3\u0160\u0164\u00DA\u00DD\u017D\u0139\u0154\u013D\u00C4\u00D4]+$/i,
    "sr-RS@latin": /^[0-9A-Z\u010C\u0106\u017D\u0160\u0110]+$/i,
    "sr-RS": /^[0-9\u0410-\u042F\u0402\u0408\u0409\u040A\u040B\u040F]+$/i,
    "sv-SE": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
    "th-TH": /^[\u0E01-\u0E59\s]+$/i,
    "tr-TR": /^[0-9A-Z\u00C7\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
    "uk-UA": /^[0-9\u0410-\u0429\u042C\u042E\u042F\u0404I\u0407\u0490\u0456]+$/i,
    "ko-KR": /^[0-9\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]*$/,
    "ku-IQ": /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0626\u0627\u0628\u067E\u062A\u062C\u0686\u062D\u062E\u062F\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063A\u0641\u06A4\u0642\u06A9\u06AF\u0644\u06B5\u0645\u0646\u0648\u06C6\u06BE\u06D5\u06CC\u06CE\u064A\u0637\u0624\u062B\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/i,
    "vi-VN": /^[0-9A-Z\u00C0\u00C1\u1EA0\u1EA2\u00C3\u00C2\u1EA6\u1EA4\u1EAC\u1EA8\u1EAA\u0102\u1EB0\u1EAE\u1EB6\u1EB2\u1EB4\u0110\u00C8\u00C9\u1EB8\u1EBA\u1EBC\u00CA\u1EC0\u1EBE\u1EC6\u1EC2\u1EC4\u00CC\u00CD\u1ECA\u1EC8\u0128\u00D2\u00D3\u1ECC\u1ECE\u00D5\u00D4\u1ED2\u1ED0\u1ED8\u1ED4\u1ED6\u01A0\u1EDC\u1EDA\u1EE2\u1EDE\u1EE0\u00D9\u00DA\u1EE4\u1EE6\u0168\u01AF\u1EEA\u1EE8\u1EF0\u1EEC\u1EEE\u1EF2\u00DD\u1EF4\u1EF6\u1EF8]+$/i,
    ar: /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0670]+$/,
    he: /^[0-9\u05D0-\u05EA]+$/,
    fa: /^['0-9\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u0629\u06CC\u06F1\u06F2\u06F3\u06F4\u06F5\u06F6\u06F7\u06F8\u06F9\u06F0']+$/i,
    bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098A\u098B\u098C\u098F\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099A\u099B\u099C\u099D\u099E\u099F\u09A0\u09A1\u09A2\u09A3\u09A4\u09A5\u09A6\u09A7\u09A8\u09AA\u09AB\u09AC\u09AD\u09AE\u09AF\u09B0\u09B2\u09B6\u09B7\u09B8\u09B9\u09BC\u09BD\u09BE\u09BF\u09C0\u09C1\u09C2\u09C3\u09C4\u09C7\u09C8\u09CB\u09CC\u09CD\u09CE\u09D7\u09DC\u09DD\u09DF\u09E0\u09E1\u09E2\u09E3\u09E6\u09E7\u09E8\u09E9\u09EA\u09EB\u09EC\u09ED\u09EE\u09EF\u09F0\u09F1\u09F2\u09F3\u09F4\u09F5\u09F6\u09F7\u09F8\u09F9\u09FA\u09FB']+$/,
    eo: /^[0-9ABC\u0108D-G\u011CH\u0124IJ\u0134K-PRS\u015CTU\u016CVZ]+$/i,
    "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
    "si-LK": /^[0-9\u0D80-\u0DFF]+$/
  };
  var decimal3 = exports.decimal = {
    "en-US": ".",
    ar: "\u066B"
  };
  var englishLocales3 = exports.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
  for (i2 = 0;i2 < englishLocales3.length; i2++) {
    locale = "en-".concat(englishLocales3[i2]);
    alpha2[locale] = alpha2["en-US"];
    alphanumeric3[locale] = alphanumeric3["en-US"];
    decimal3[locale] = decimal3["en-US"];
  }
  var locale;
  var i2;
  var arabicLocales3 = exports.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
  for (_i = 0;_i < arabicLocales3.length; _i++) {
    _locale = "ar-".concat(arabicLocales3[_i]);
    alpha2[_locale] = alpha2.ar;
    alphanumeric3[_locale] = alphanumeric3.ar;
    decimal3[_locale] = decimal3.ar;
  }
  var _locale;
  var _i;
  var farsiLocales2 = exports.farsiLocales = ["IR", "AF"];
  for (_i2 = 0;_i2 < farsiLocales2.length; _i2++) {
    _locale2 = "fa-".concat(farsiLocales2[_i2]);
    alphanumeric3[_locale2] = alphanumeric3.fa;
    decimal3[_locale2] = decimal3.ar;
  }
  var _locale2;
  var _i2;
  var bengaliLocales2 = exports.bengaliLocales = ["BD", "IN"];
  for (_i3 = 0;_i3 < bengaliLocales2.length; _i3++) {
    _locale3 = "bn-".concat(bengaliLocales2[_i3]);
    alpha2[_locale3] = alpha2.bn;
    alphanumeric3[_locale3] = alphanumeric3.bn;
    decimal3[_locale3] = decimal3["en-US"];
  }
  var _locale3;
  var _i3;
  var dotDecimal3 = exports.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
  var commaDecimal3 = exports.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
  for (_i4 = 0;_i4 < dotDecimal3.length; _i4++) {
    decimal3[dotDecimal3[_i4]] = decimal3["en-US"];
  }
  var _i4;
  for (_i5 = 0;_i5 < commaDecimal3.length; _i5++) {
    decimal3[commaDecimal3[_i5]] = ",";
  }
  var _i5;
  alpha2["fr-CA"] = alpha2["fr-FR"];
  alphanumeric3["fr-CA"] = alphanumeric3["fr-FR"];
  alpha2["pt-BR"] = alpha2["pt-PT"];
  alphanumeric3["pt-BR"] = alphanumeric3["pt-PT"];
  decimal3["pt-BR"] = decimal3["pt-PT"];
  alpha2["pl-Pl"] = alpha2["pl-PL"];
  alphanumeric3["pl-Pl"] = alphanumeric3["pl-PL"];
  decimal3["pl-Pl"] = decimal3["pl-PL"];
  alpha2["fa-AF"] = alpha2.fa;
});

// ../../../../node_modules/validator/lib/isAlpha.js
var require_isAlpha = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAlpha2;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function isAlpha2(_str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _assertString.default)(_str);
    var str = _str;
    var ignore = options.ignore;
    if (ignore) {
      if (ignore instanceof RegExp) {
        str = str.replace(ignore, "");
      } else if (typeof ignore === "string") {
        str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
      } else {
        throw new Error("ignore should be instance of a String or RegExp");
      }
    }
    if (locale in _alpha.alpha) {
      return _alpha.alpha[locale].test(str);
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  var locales8 = exports.locales = Object.keys(_alpha.alpha);
});

// ../../../../node_modules/validator/lib/isLatLong.js
var require_isLatLong = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLatLong;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var _includesString = _interopRequireDefault(require_includesString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
  var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
  var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
  var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
  var defaultLatLongOptions = {
    checkDMS: false
  };
  function isLatLong(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaultLatLongOptions);
    if (!(0, _includesString.default)(str, ","))
      return false;
    var pair = str.split(",");
    if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
      return false;
    if (options.checkDMS) {
      return latDMS.test(pair[0]) && longDMS.test(pair[1]);
    }
    return lat.test(pair[0]) && long.test(pair[1]);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isDecimal.js
var require_isDecimal = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDecimal;
  var _merge = _interopRequireDefault(require_merge());
  var _assertString = _interopRequireDefault(require_assertString());
  var _includesArray = _interopRequireDefault(require_includesArray());
  var _alpha = require_alpha();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function decimalRegExp(options) {
    var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
    return regExp;
  }
  var default_decimal_options = {
    force_decimal: false,
    decimal_digits: "1,",
    locale: "en-US"
  };
  var blacklist = ["", "-", "+"];
  function isDecimal(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_decimal_options);
    if (options.locale in _alpha.decimal) {
      return !(0, _includesArray.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
    }
    throw new Error("Invalid locale '".concat(options.locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isHexColor.js
var require_isHexColor = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexColor;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
  function isHexColor(str) {
    (0, _assertString.default)(str);
    return hexcolor.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isLuhnNumber.js
var require_isLuhnNumber = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLuhnNumber;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function isLuhnNumber(str) {
    (0, _assertString.default)(str);
    var sanitized = str.replace(/[- ]+/g, "");
    var sum = 0;
    var digit;
    var tmpNum;
    var shouldDouble;
    for (var i2 = sanitized.length - 1;i2 >= 0; i2--) {
      digit = sanitized.substring(i2, i2 + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isCreditCard.js
var require_isCreditCard = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var cards2 = {
    amex: /^3[47][0-9]{13}$/,
    dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
    discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
    jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
    mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
    unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
    visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
  };
  var allCards2 = function() {
    var tmpCardsArray = [];
    for (var cardProvider in cards2) {
      if (cards2.hasOwnProperty(cardProvider)) {
        tmpCardsArray.push(cards2[cardProvider]);
      }
    }
    return tmpCardsArray;
  }();
  function isCreditCard(card) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(card);
    var provider = options.provider;
    var sanitized = card.replace(/[- ]+/g, "");
    if (provider && provider.toLowerCase() in cards2) {
      if (!cards2[provider.toLowerCase()].test(sanitized)) {
        return false;
      }
    } else if (provider && !(provider.toLowerCase() in cards2)) {
      throw new Error("".concat(provider, " is not a valid credit card provider."));
    } else if (!allCards2.some(function(cardProvider) {
      return cardProvider.test(sanitized);
    })) {
      return false;
    }
    return (0, _isLuhnNumber.default)(card);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/isAlphanumeric.js
var require_isAlphanumeric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAlphanumeric2;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function isAlphanumeric2(_str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _assertString.default)(_str);
    var str = _str;
    var ignore = options.ignore;
    if (ignore) {
      if (ignore instanceof RegExp) {
        str = str.replace(ignore, "");
      } else if (typeof ignore === "string") {
        str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
      } else {
        throw new Error("ignore should be instance of a String or RegExp");
      }
    }
    if (locale in _alpha.alphanumeric) {
      return _alpha.alphanumeric[locale].test(str);
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  var locales8 = exports.locales = Object.keys(_alpha.alphanumeric);
});

// ../../../../node_modules/validator/lib/isPassportNumber.js
var require_isPassportNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPassportNumber;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var passportRegexByCountryCode2 = {
    AM: /^[A-Z]{2}\d{7}$/,
    AR: /^[A-Z]{3}\d{6}$/,
    AT: /^[A-Z]\d{7}$/,
    AU: /^[A-Z]\d{7}$/,
    AZ: /^[A-Z]{1}\d{8}$/,
    BE: /^[A-Z]{2}\d{6}$/,
    BG: /^\d{9}$/,
    BR: /^[A-Z]{2}\d{6}$/,
    BY: /^[A-Z]{2}\d{7}$/,
    CA: /^[A-Z]{2}\d{6}$|^[A-Z]\d{6}[A-Z]{2}$/,
    CH: /^[A-Z]\d{7}$/,
    CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
    CY: /^[A-Z](\d{6}|\d{8})$/,
    CZ: /^\d{8}$/,
    DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
    DK: /^\d{9}$/,
    DZ: /^\d{9}$/,
    EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
    ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
    FI: /^[A-Z]{2}\d{7}$/,
    FR: /^\d{2}[A-Z]{2}\d{5}$/,
    GB: /^\d{9}$/,
    GR: /^[A-Z]{2}\d{7}$/,
    HR: /^\d{9}$/,
    HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
    IE: /^[A-Z0-9]{2}\d{7}$/,
    IN: /^[A-Z]{1}-?\d{7}$/,
    ID: /^[A-C]\d{7}$/,
    IR: /^[A-Z]\d{8}$/,
    IS: /^(A)\d{7}$/,
    IT: /^[A-Z0-9]{2}\d{7}$/,
    JM: /^[Aa]\d{7}$/,
    JP: /^[A-Z]{2}\d{7}$/,
    KR: /^[MS]\d{8}$/,
    KZ: /^[a-zA-Z]\d{7}$/,
    LI: /^[a-zA-Z]\d{5}$/,
    LT: /^[A-Z0-9]{8}$/,
    LU: /^[A-Z0-9]{8}$/,
    LV: /^[A-Z0-9]{2}\d{7}$/,
    LY: /^[A-Z0-9]{8}$/,
    MT: /^\d{7}$/,
    MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
    MY: /^[AHK]\d{8}$/,
    MX: /^\d{10,11}$/,
    NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
    NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
    PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
    PK: /^[A-Z]{2}\d{7}$/,
    PL: /^[A-Z]{2}\d{7}$/,
    PT: /^[A-Z]\d{6}$/,
    RO: /^\d{8,9}$/,
    RU: /^\d{9}$/,
    SE: /^\d{8}$/,
    SL: /^(P)[A-Z]\d{7}$/,
    SK: /^[0-9A-Z]\d{7}$/,
    TH: /^[A-Z]{1,2}\d{6,7}$/,
    TR: /^[A-Z]\d{8}$/,
    UA: /^[A-Z]{2}\d{6}$/,
    US: /^\d{9}$|^[A-Z]\d{8}$/,
    ZA: /^[TAMD]\d{8}$/
  };
  var locales8 = exports.locales = Object.keys(passportRegexByCountryCode2);
  function isPassportNumber(str, countryCode) {
    (0, _assertString.default)(str);
    var normalizedStr = str.replace(/\s/g, "").toUpperCase();
    return countryCode.toUpperCase() in passportRegexByCountryCode2 && passportRegexByCountryCode2[countryCode].test(normalizedStr);
  }
});

// ../../../../node_modules/validator/lib/isPostalCode.js
var require_isPostalCode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPostalCode;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var threeDigit2 = /^\d{3}$/;
  var fourDigit2 = /^\d{4}$/;
  var fiveDigit2 = /^\d{5}$/;
  var sixDigit2 = /^\d{6}$/;
  var patterns2 = {
    AD: /^AD\d{3}$/,
    AT: fourDigit2,
    AU: fourDigit2,
    AZ: /^AZ\d{4}$/,
    BA: /^([7-8]\d{4}$)/,
    BD: /^([1-8][0-9]{3}|9[0-4][0-9]{2})$/,
    BE: fourDigit2,
    BG: fourDigit2,
    BR: /^\d{5}-?\d{3}$/,
    BY: /^2[1-4]\d{4}$/,
    CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
    CH: fourDigit2,
    CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
    CO: /^(05|08|11|13|15|17|18|19|20|23|25|27|41|44|47|50|52|54|63|66|68|70|73|76|81|85|86|88|91|94|95|97|99)(\d{4})$/,
    CZ: /^\d{3}\s?\d{2}$/,
    DE: fiveDigit2,
    DK: fourDigit2,
    DO: fiveDigit2,
    DZ: fiveDigit2,
    EE: fiveDigit2,
    ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
    FI: fiveDigit2,
    FR: /^(?:(?:0[1-9]|[1-8]\d|9[0-5])\d{3}|97[1-46]\d{2})$/,
    GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
    GR: /^\d{3}\s?\d{2}$/,
    HR: /^([1-5]\d{4}$)/,
    HT: /^HT\d{4}$/,
    HU: fourDigit2,
    ID: fiveDigit2,
    IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
    IL: /^(\d{5}|\d{7})$/,
    IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
    IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
    IS: threeDigit2,
    IT: fiveDigit2,
    JP: /^\d{3}\-\d{4}$/,
    KE: fiveDigit2,
    KR: /^(\d{5}|\d{6})$/,
    LI: /^(948[5-9]|949[0-7])$/,
    LT: /^LT\-\d{5}$/,
    LU: fourDigit2,
    LV: /^LV\-\d{4}$/,
    LK: fiveDigit2,
    MG: threeDigit2,
    MX: fiveDigit2,
    MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
    MY: fiveDigit2,
    NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
    NO: fourDigit2,
    NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
    NZ: fourDigit2,
    PK: fiveDigit2,
    PL: /^\d{2}\-\d{3}$/,
    PR: /^00[679]\d{2}([ -]\d{4})?$/,
    PT: /^\d{4}\-\d{3}?$/,
    RO: sixDigit2,
    RU: sixDigit2,
    SA: fiveDigit2,
    SE: /^[1-9]\d{2}\s?\d{2}$/,
    SG: sixDigit2,
    SI: fourDigit2,
    SK: /^\d{3}\s?\d{2}$/,
    TH: fiveDigit2,
    TN: fourDigit2,
    TW: /^\d{3}(\d{2,3})?$/,
    UA: fiveDigit2,
    US: /^\d{5}(-\d{4})?$/,
    ZA: fourDigit2,
    ZM: fiveDigit2
  };
  var locales8 = exports.locales = Object.keys(patterns2);
  function isPostalCode(str, locale) {
    (0, _assertString.default)(str);
    if (locale in patterns2) {
      return patterns2[locale].test(str);
    } else if (locale === "any") {
      for (var key in patterns2) {
        if (patterns2.hasOwnProperty(key)) {
          var pattern = patterns2[key];
          if (pattern.test(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
});

// ../../../../node_modules/validator/lib/isMobilePhone.js
var require_isMobilePhone = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMobilePhone;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var phones2 = {
    "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
    "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
    "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
    "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
    "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
    "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
    "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
    "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
    "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
    "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
    "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
    "ar-OM": /^((\+|00)968)?([79][1-9])\d{6}$/,
    "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
    "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
    "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
    "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
    "ar-TN": /^(\+?216)?[2459]\d{7}$/,
    "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
    "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
    "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
    "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
    "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
    "ca-AD": /^(\+376)?[346]\d{5}$/,
    "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
    "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
    "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
    "de-LU": /^(\+352)?((6\d1)\d{6})$/,
    "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
    "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
    "el-CY": /^(\+?357?)?(9(9|7|6|5|4)\d{6})$/,
    "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
    "en-AU": /^(\+?61|0)4\d{8}$/,
    "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
    "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
    "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
    "en-GB": /^(\+?44|0)7[1-9]\d{8}$/,
    "en-GG": /^(\+?44|0)1481\d{6}$/,
    "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|53|28|55|59)\d{7}$/,
    "en-GY": /^(\+592|0)6\d{6}$/,
    "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
    "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
    "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
    "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
    "en-JM": /^(\+?876)?\d{7}$/,
    "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
    "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
    "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
    "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
    "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
    "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
    "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
    "en-MU": /^(\+?230|0)?\d{8}$/,
    "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
    "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
    "en-NG": /^(\+?234|0)?[789]\d{9}$/,
    "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
    "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
    "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
    "en-PH": /^(09|\+639)\d{9}$/,
    "en-RW": /^(\+?250|0)?[7]\d{8}$/,
    "en-SG": /^(\+65)?[3689]\d{7}$/,
    "en-SL": /^(\+?232|0)\d{8}$/,
    "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
    "en-UG": /^(\+?256|0)?[7]\d{8}$/,
    "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
    "en-ZA": /^(\+?27|0)\d{9}$/,
    "en-ZM": /^(\+?26)?0[79][567]\d{7}$/,
    "en-ZW": /^(\+263)[0-9]{9}$/,
    "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
    "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
    "es-BO": /^(\+?591)?(6|7)\d{7}$/,
    "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
    "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
    "es-CR": /^(\+506)?[2-8]\d{7}$/,
    "es-CU": /^(\+53|0053)?5\d{7}$/,
    "es-DO": /^(\+?1)?8[024]9\d{7}$/,
    "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
    "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
    "es-ES": /^(\+?34)?[6|7]\d{8}$/,
    "es-GT": /^(\+?502)?[2|6|7]\d{7}$/,
    "es-PE": /^(\+?51)?9\d{8}$/,
    "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
    "es-NI": /^(\+?505)\d{7,8}$/,
    "es-PA": /^(\+?507)\d{7,8}$/,
    "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
    "es-SV": /^(\+?503)?[67]\d{7}$/,
    "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
    "es-VE": /^(\+?58)?(2|4)\d{9}$/,
    "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
    "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
    "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
    "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
    "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "fr-BF": /^(\+226|0)[67]\d{7}$/,
    "fr-BJ": /^(\+229)\d{8}$/,
    "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
    "fr-CM": /^(\+?237)6[0-9]{8}$/,
    "fr-FR": /^(\+?33|0)[67]\d{8}$/,
    "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
    "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
    "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
    "fr-PF": /^(\+?689)?8[789]\d{6}$/,
    "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
    "fr-WF": /^(\+681)?\d{6}$/,
    "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
    "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
    "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
    "ir-IR": /^(\+98|0)?9\d{9}$/,
    "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
    "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
    "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
    "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
    "kk-KZ": /^(\+?7|8)?7\d{9}$/,
    "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
    "ky-KG": /^(\+996\s?)?(22[0-9]|50[0-9]|55[0-9]|70[0-9]|75[0-9]|77[0-9]|880|990|995|996|997|998)\s?\d{3}\s?\d{3}$/,
    "lt-LT": /^(\+370|8)\d{8}$/,
    "lv-LV": /^(\+?371)2\d{7}$/,
    "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
    "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
    "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
    "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
    "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
    "nb-NO": /^(\+?47)?[49]\d{7}$/,
    "ne-NP": /^(\+?977)?9[78]\d{8}$/,
    "nl-BE": /^(\+?32|0)4\d{8}$/,
    "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
    "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
    "nn-NO": /^(\+?47)?[49]\d{7}$/,
    "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
    "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
    "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
    "pt-AO": /^(\+?244)?9\d{8}$/,
    "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
    "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
    "ru-RU": /^(\+?7|8)?9\d{9}$/,
    "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
    "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
    "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
    "sq-AL": /^(\+355|0)6[2-9]\d{7}$/,
    "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
    "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
    "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
    "th-TH": /^(\+66|66|0)\d{9}$/,
    "tr-TR": /^(\+?90|0)?5\d{9}$/,
    "tk-TM": /^(\+993|993|8)\d{8}$/,
    "uk-UA": /^(\+?38)?0(50|6[36-8]|7[357]|9[1-9])\d{7}$/,
    "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
    "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
    "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
    "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
    "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
    "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
    "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
    "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/,
    "mk-MK": /^(\+?389|0)?((?:2[2-9]\d{6}|(?:3[1-4]|4[2-8])\d{6}|500\d{5}|5[2-9]\d{6}|7[0-9][2-9]\d{5}|8[1-9]\d{6}|800\d{5}|8009\d{4}))$/
  };
  phones2["en-CA"] = phones2["en-US"];
  phones2["fr-CA"] = phones2["en-CA"];
  phones2["fr-BE"] = phones2["nl-BE"];
  phones2["zh-HK"] = phones2["en-HK"];
  phones2["zh-MO"] = phones2["en-MO"];
  phones2["ga-IE"] = phones2["en-IE"];
  phones2["fr-CH"] = phones2["de-CH"];
  phones2["it-CH"] = phones2["fr-CH"];
  function isMobilePhone(str, locale, options) {
    (0, _assertString.default)(str);
    if (options && options.strictMode && !str.startsWith("+")) {
      return false;
    }
    if (Array.isArray(locale)) {
      return locale.some(function(key2) {
        if (phones2.hasOwnProperty(key2)) {
          var phone2 = phones2[key2];
          if (phone2.test(str)) {
            return true;
          }
        }
        return false;
      });
    } else if (locale in phones2) {
      return phones2[locale].test(str);
    } else if (!locale || locale === "any") {
      for (var key in phones2) {
        if (phones2.hasOwnProperty(key)) {
          var phone = phones2[key];
          if (phone.test(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  var locales8 = exports.locales = Object.keys(phones2);
});

// ../../../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t2, e2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e2() : typeof define == "function" && define.amd ? define(e2) : (t2 = typeof globalThis != "undefined" ? globalThis : t2 || self).dayjs = e2();
  })(exports, function() {
    var t2 = 1000, e2 = 60000, n2 = 3600000, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f3 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m3 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v4 = { s: m3, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m3(r3, 2, "0") + ":" + m3(i3, 2, "0");
    }, m: function t(e3, n3) {
      if (e3.date() < n3.date())
        return -t(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f3 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return t3 === undefined;
    } }, g2 = "en", D3 = {};
    D3[g2] = M3;
    var p4 = "$isDayjsObject", S3 = function(t3) {
      return t3 instanceof _3 || !(!t3 || !t3[p4]);
    }, w3 = function t(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if (typeof e3 == "string") {
        var s3 = e3.toLowerCase();
        D3[s3] && (i3 = s3), n3 && (D3[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t(u3[0]);
      } else {
        var a3 = e3.name;
        D3[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O3 = function(t3, e3) {
      if (S3(t3))
        return t3.clone();
      var n3 = typeof e3 == "object" ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _3(n3);
    }, b2 = v4;
    b2.l = w3, b2.i = S3, b2.w = function(t3, e3) {
      return O3(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _3 = function() {
      function M4(t3) {
        this.$L = w3(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p4] = true;
      }
      var m4 = M4.prototype;
      return m4.parse = function(t3) {
        this.$d = function(t4) {
          var { date: e3, utc: n3 } = t4;
          if (e3 === null)
            return new Date(NaN);
          if (b2.u(e3))
            return new Date;
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r3 = e3.match($3);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m4.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m4.$utils = function() {
        return b2;
      }, m4.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m4.isSame = function(t3, e3) {
        var n3 = O3(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m4.isAfter = function(t3, e3) {
        return O3(t3) < this.startOf(e3);
      }, m4.isBefore = function(t3, e3) {
        return this.endOf(e3) < O3(t3);
      }, m4.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m4.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m4.valueOf = function() {
        return this.$d.getTime();
      }, m4.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f4 = b2.p(t3), l3 = function(t4, e4) {
          var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $4 = function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M5 = this.$M, m5 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
        switch (f4) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M5) : l3(0, M5 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D4 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m5 - D4 : m5 + (6 - D4), M5);
          case a2:
          case d2:
            return $4(v5 + "Hours", 0);
          case u2:
            return $4(v5 + "Minutes", 1);
          case s2:
            return $4(v5 + "Seconds", 2);
          case i2:
            return $4(v5 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m4.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m4.$set = function(t3, e3) {
        var n3, o3 = b2.p(t3), f4 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f4 + "Date", n3[d2] = f4 + "Date", n3[c2] = f4 + "Month", n3[h2] = f4 + "FullYear", n3[u2] = f4 + "Hours", n3[s2] = f4 + "Minutes", n3[i2] = f4 + "Seconds", n3[r2] = f4 + "Milliseconds", n3)[o3], $4 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($4), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($4);
        return this.init(), this;
      }, m4.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m4.get = function(t3) {
        return this[b2.p(t3)]();
      }, m4.add = function(r3, f4) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $4 = b2.p(f4), y3 = function(t3) {
          var e3 = O3(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($4 === c2)
          return this.set(c2, this.$M + r3);
        if ($4 === h2)
          return this.set(h2, this.$y + r3);
        if ($4 === a2)
          return y3(1);
        if ($4 === o2)
          return y3(7);
        var M5 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$4] || 1, m5 = this.$d.getTime() + r3 * M5;
        return b2.w(m5, this);
      }, m4.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m4.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f4 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, d3 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $4 = f4 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $4(s3, u3, true);
              case "A":
                return $4(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m4.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m4.diff = function(r3, d3, l3) {
        var $4, y3 = this, M5 = b2.p(d3), m5 = O3(r3), v5 = (m5.utcOffset() - this.utcOffset()) * e2, g3 = this - m5, D4 = function() {
          return b2.m(y3, m5);
        };
        switch (M5) {
          case h2:
            $4 = D4() / 12;
            break;
          case c2:
            $4 = D4();
            break;
          case f3:
            $4 = D4() / 3;
            break;
          case o2:
            $4 = (g3 - v5) / 604800000;
            break;
          case a2:
            $4 = (g3 - v5) / 86400000;
            break;
          case u2:
            $4 = g3 / n2;
            break;
          case s2:
            $4 = g3 / e2;
            break;
          case i2:
            $4 = g3 / t2;
            break;
          default:
            $4 = g3;
        }
        return l3 ? $4 : b2.a($4);
      }, m4.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m4.$locale = function() {
        return D3[this.$L];
      }, m4.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = w3(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m4.clone = function() {
        return b2.w(this.$d, this);
      }, m4.toDate = function() {
        return new Date(this.valueOf());
      }, m4.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m4.toISOString = function() {
        return this.$d.toISOString();
      }, m4.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), k2 = _3.prototype;
    return O3.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O3.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _3, O3), t3.$i = true), O3;
    }, O3.locale = w3, O3.isDayjs = S3, O3.unix = function(t3) {
      return O3(1000 * t3);
    }, O3.en = D3[g2], O3.Ls = D3, O3.p = {}, O3;
  });
});

// ../../../../node_modules/dayjs/plugin/isSameOrAfter.js
var require_isSameOrAfter = __commonJS((exports, module) => {
  (function(e2, t2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t2() : typeof define == "function" && define.amd ? define(t2) : (e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).dayjs_plugin_isSameOrAfter = t2();
  })(exports, function() {
    return function(e2, t2) {
      t2.prototype.isSameOrAfter = function(e3, t3) {
        return this.isSame(e3, t3) || this.isAfter(e3, t3);
      };
    };
  });
});

// ../../../../node_modules/dayjs/plugin/isSameOrBefore.js
var require_isSameOrBefore = __commonJS((exports, module) => {
  (function(e2, i2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i2() : typeof define == "function" && define.amd ? define(i2) : (e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).dayjs_plugin_isSameOrBefore = i2();
  })(exports, function() {
    return function(e2, i2) {
      i2.prototype.isSameOrBefore = function(e3, i3) {
        return this.isSame(e3, i3) || this.isBefore(e3, i3);
      };
    };
  });
});

// ../../../../node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  (function(e2, t2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t2() : typeof define == "function" && define.amd ? define(t2) : (e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).dayjs_plugin_customParseFormat = t2();
  })(exports, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i2 = /\d\d?/, o2 = /\d*[^-_:/,()\s\d]+/, s2 = {}, a2 = function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2000);
    };
    var f3 = function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, h2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if (e4 === "Z")
          return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return n3 === 0 ? 0 : t3[0] === "+" ? -n3 : n3;
      }(e3);
    }], u2 = function(e3) {
      var t3 = s2[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, d2 = function(e3, t3) {
      var n3, r3 = s2.meridiem;
      if (r3) {
        for (var i3 = 1;i3 <= 24; i3 += 1)
          if (e3.indexOf(r3(i3, 0, t3)) > -1) {
            n3 = i3 > 12;
            break;
          }
      } else
        n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, c2 = { A: [o2, function(e3) {
      this.afternoon = d2(e3, false);
    }], a: [o2, function(e3) {
      this.afternoon = d2(e3, true);
    }], Q: [n2, function(e3) {
      this.month = 3 * (e3 - 1) + 1;
    }], S: [n2, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [r2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [i2, f3("seconds")], ss: [i2, f3("seconds")], m: [i2, f3("minutes")], mm: [i2, f3("minutes")], H: [i2, f3("hours")], h: [i2, f3("hours")], HH: [i2, f3("hours")], hh: [i2, f3("hours")], D: [i2, f3("day")], DD: [r2, f3("day")], Do: [o2, function(e3) {
      var t3 = s2.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t3)
        for (var r3 = 1;r3 <= 31; r3 += 1)
          t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
    }], w: [i2, f3("week")], ww: [r2, f3("week")], M: [i2, f3("month")], MM: [r2, f3("month")], MMM: [o2, function(e3) {
      var t3 = u2("months"), n3 = (u2("monthsShort") || t3.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1)
        throw new Error;
      this.month = n3 % 12 || n3;
    }], MMMM: [o2, function(e3) {
      var t3 = u2("months").indexOf(e3) + 1;
      if (t3 < 1)
        throw new Error;
      this.month = t3 % 12 || t3;
    }], Y: [/[+-]?\d+/, f3("year")], YY: [r2, function(e3) {
      this.year = a2(e3);
    }], YYYY: [/\d{4}/, f3("year")], Z: h2, ZZ: h2 };
    function l2(n3) {
      var r3, i3;
      r3 = n3, i3 = s2 && s2.formats;
      for (var o3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
        var o4 = r4 && r4.toUpperCase();
        return n4 || i3[r4] || e2[r4] || i3[o4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a3 = o3.length, f4 = 0;f4 < a3; f4 += 1) {
        var h3 = o3[f4], u3 = c2[h3], d3 = u3 && u3[0], l3 = u3 && u3[1];
        o3[f4] = l3 ? { regex: d3, parser: l3 } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r4 = 0;n4 < a3; n4 += 1) {
          var i4 = o3[n4];
          if (typeof i4 == "string")
            r4 += i4.length;
          else {
            var { regex: s3, parser: f5 } = i4, h4 = e3.slice(r4), u4 = s3.exec(h4)[0];
            f5.call(t3, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (t4 !== undefined) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : n5 === 12 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    return function(e3, t3, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (a2 = e3.parseTwoDigitYear);
      var r3 = t3.prototype, i3 = r3.parse;
      r3.parse = function(e4) {
        var { date: t4, utc: r4, args: o3 } = e4;
        this.$u = r4;
        var a3 = o3[1];
        if (typeof a3 == "string") {
          var f4 = o3[2] === true, h3 = o3[3] === true, u3 = f4 || h3, d3 = o3[2];
          h3 && (d3 = o3[2]), s2 = this.$locale(), !f4 && d3 && (s2 = n3.Ls[d3]), this.$d = function(e5, t5, n4, r5) {
            try {
              if (["x", "X"].indexOf(t5) > -1)
                return new Date((t5 === "X" ? 1000 : 1) * e5);
              var i4 = l2(t5)(e5), o4 = i4.year, s3 = i4.month, a4 = i4.day, f5 = i4.hours, h4 = i4.minutes, u4 = i4.seconds, d4 = i4.milliseconds, c4 = i4.zone, m4 = i4.week, M4 = new Date, Y3 = a4 || (o4 || s3 ? 1 : M4.getDate()), p4 = o4 || M4.getFullYear(), v4 = 0;
              o4 && !s3 || (v4 = s3 > 0 ? s3 - 1 : M4.getMonth());
              var D3, w3 = f5 || 0, g2 = h4 || 0, y2 = u4 || 0, L3 = d4 || 0;
              return c4 ? new Date(Date.UTC(p4, v4, Y3, w3, g2, y2, L3 + 60 * c4.offset * 1000)) : n4 ? new Date(Date.UTC(p4, v4, Y3, w3, g2, y2, L3)) : (D3 = new Date(p4, v4, Y3, w3, g2, y2, L3), m4 && (D3 = r5(D3).week(m4).toDate()), D3);
            } catch (e6) {
              return new Date("");
            }
          }(t4, a3, r4, n3), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = new Date("")), s2 = {};
        } else if (a3 instanceof Array)
          for (var c3 = a3.length, m3 = 1;m3 <= c3; m3 += 1) {
            o3[1] = a3[m3 - 1];
            var M3 = n3.apply(this, o3);
            if (M3.isValid()) {
              this.$d = M3.$d, this.$L = M3.$L, this.init();
              break;
            }
            m3 === c3 && (this.$d = new Date(""));
          }
        else
          i3.call(this, e4);
      };
    };
  });
});

// ../../../../node_modules/validator/lib/escape.js
var require_escape = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = escape;
  var _assertString = _interopRequireDefault(require_assertString());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function escape(str) {
    (0, _assertString.default)(str);
    return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../../../../node_modules/validator/lib/normalizeEmail.js
var require_normalizeEmail = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeEmail;
  var _merge = _interopRequireDefault(require_merge());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var default_normalize_email_options = {
    all_lowercase: true,
    gmail_lowercase: true,
    gmail_remove_dots: true,
    gmail_remove_subaddress: true,
    gmail_convert_googlemaildotcom: true,
    outlookdotcom_lowercase: true,
    outlookdotcom_remove_subaddress: true,
    yahoo_lowercase: true,
    yahoo_remove_subaddress: true,
    yandex_lowercase: true,
    yandex_convert_yandexru: true,
    icloud_lowercase: true,
    icloud_remove_subaddress: true
  };
  var icloud_domains = ["icloud.com", "me.com"];
  var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
  var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
  var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
  function dotsReplacer(match) {
    if (match.length > 1) {
      return match;
    }
    return "";
  }
  function normalizeEmail(email, options) {
    options = (0, _merge.default)(options, default_normalize_email_options);
    var raw_parts = email.split("@");
    var domain = raw_parts.pop();
    var user = raw_parts.join("@");
    var parts = [user, domain];
    parts[1] = parts[1].toLowerCase();
    if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
      if (options.gmail_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (options.gmail_remove_dots) {
        parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.gmail_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
    } else if (icloud_domains.indexOf(parts[1]) >= 0) {
      if (options.icloud_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.icloud_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
      if (options.outlookdotcom_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.outlookdotcom_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
      if (options.yahoo_remove_subaddress) {
        var components = parts[0].split("-");
        parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.yahoo_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yandex_domains.indexOf(parts[1]) >= 0) {
      if (options.all_lowercase || options.yandex_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = options.yandex_convert_yandexru ? "yandex.ru" : parts[1];
    } else if (options.all_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    return parts.join("@");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// ../build/src/index.ts
import { bold, dim, green, italic, log } from "@stacksjs/cli";
import { path as p } from "@stacksjs/path";
import { fs, glob } from "@stacksjs/storage";

// ../build/src/utils.ts
var import_generator = __toESM(require_lib6(), 1);
var import_parser = __toESM(require_lib(), 1);
var import_traverse = __toESM(require_lib9(), 1);
// ../orm/src/utils.ts
import { italic as italic9, log as log16 } from "@stacksjs/cli";

// ../database/src/custom/errors.ts
import { log as log7 } from "@stacksjs/cli";
import { database } from "@stacksjs/config";
import { path as path7 } from "@stacksjs/path";

// ../database/src/drivers/index.ts
import { log as log6 } from "@stacksjs/cli";

// ../../orm/src/utils/base.ts
import { HttpError } from "@stacksjs/error-handling";
class BaseOrm {
  tableName;
  selectFromQuery;
  updateFromQuery;
  deleteFromQuery;
  withRelations;
  hasSelect = false;
  constructor(tableName) {
    this.tableName = tableName;
    this.selectFromQuery = DB.instance.selectFrom(this.tableName);
    this.updateFromQuery = DB.instance.updateTable(this.tableName);
    this.deleteFromQuery = DB.instance.deleteFrom(this.tableName);
    this.withRelations = [];
  }
  applySelect(params) {
    this.selectFromQuery = this.selectFromQuery.select(params);
    this.hasSelect = true;
    return this;
  }
  select(params) {
    return this.applySelect(params);
  }
  async first() {
    const model = await this.applyFirst();
    if (!model)
      return;
    return model;
  }
  async firstOrFail() {
    const model = await this.applyFirstOrFail();
    if (!model)
      throw new HttpError(404, `No ${this.tableName} results found for query`);
    return model;
  }
  async applyFirstOrFail() {
    let model;
    if (this.hasSelect) {
      model = await this.selectFromQuery.executeTakeFirst();
    } else {
      model = await this.selectFromQuery.selectAll().executeTakeFirst();
    }
    if (!model)
      throw new HttpError(404, `No ${this.tableName} results found for query`);
    if (model) {
      this.mapCustomGetters(model);
      await this.loadRelations(model);
    }
    return model;
  }
  async applyFind(id) {
    const model = await DB.instance.selectFrom(this.tableName).where("id", "=", id).selectAll().executeTakeFirst();
    if (!model)
      return;
    this.mapCustomGetters(model);
    await this.loadRelations(model);
    return model;
  }
  async applyFindMany(ids) {
    let query2 = DB.instance.selectFrom("users").where("id", "in", ids);
    query2 = query2.selectAll();
    const models = await query2.execute();
    this.mapCustomGetters(models);
    await this.loadRelations(models);
    return models;
  }
  async findMany(ids) {
    return await this.applyFindMany(ids);
  }
  async all() {
    const models = await DB.instance.selectFrom(this.tableName).selectAll().execute();
    this.mapCustomGetters(models);
    await this.loadRelations(models);
    return models;
  }
  async applyFirst() {
    let model;
    if (this.hasSelect) {
      model = await this.selectFromQuery.executeTakeFirst();
    } else {
      model = await this.selectFromQuery.selectAll().executeTakeFirst();
    }
    if (model) {
      this.mapCustomGetters(model);
      await this.loadRelations(model);
    }
    return model;
  }
  applyWhere(column, ...args) {
    if (args.length === 1) {
      const [value] = args;
      this.selectFromQuery = this.selectFromQuery.where(column, "=", value);
      this.updateFromQuery = this.updateFromQuery.where(column, "=", value);
      this.deleteFromQuery = this.deleteFromQuery.where(column, "=", value);
    } else {
      const [operator, value] = args;
      this.selectFromQuery = this.selectFromQuery.where(column, operator, value);
      this.updateFromQuery = this.updateFromQuery.where(column, operator, value);
      this.deleteFromQuery = this.deleteFromQuery.where(column, operator, value);
    }
    return this;
  }
  where(column, ...args) {
    return this.applyWhere(column, ...args);
  }
  async find(id) {
    return await this.applyFind(id);
  }
  async findOrFail(id) {
    const model = await this.applyFindOrFail(id);
    if (!model)
      throw new HttpError(404, `No ${this.tableName} results found for id ${id}`);
    return model;
  }
  async applyFindOrFail(id) {
    const model = await DB.instance.selectFrom(this.tableName).where("id", "=", id).selectAll().executeTakeFirst();
    if (!model)
      throw new HttpError(404, `No ${this.tableName} results found for id ${id}`);
    this.mapCustomGetters(model);
    await this.loadRelations(model);
    return model;
  }
  applyWhereColumn(first, operator, second) {
    this.selectFromQuery = this.selectFromQuery.whereRef(first, operator, second);
    return this;
  }
  whereColumn(first, operator, second) {
    return this.applyWhereColumn(first, operator, second);
  }
  applyWhereRef(column, ...args) {
    const [operatorOrValue, value] = args;
    const operator = value === undefined ? "=" : operatorOrValue;
    const actualValue = value === undefined ? operatorOrValue : value;
    this.selectFromQuery = this.selectFromQuery.whereRef(column, operator, actualValue);
    return this;
  }
  whereRef(column, ...args) {
    return this.applyWhereRef(column, ...args);
  }
  applyWhereRaw(sqlStatement) {
    this.selectFromQuery = this.selectFromQuery.where(sql`${sqlStatement}`);
    return this;
  }
  whereRaw(sqlStatement) {
    return this.applyWhereRaw(sqlStatement);
  }
  applyOrWhere(...conditions) {
    this.selectFromQuery = this.selectFromQuery.where((eb) => {
      return eb.or(conditions.map(([column, value]) => eb(column, "=", value)));
    });
    this.updateFromQuery = this.updateFromQuery.where((eb) => {
      return eb.or(conditions.map(([column, value]) => eb(column, "=", value)));
    });
    this.deleteFromQuery = this.deleteFromQuery.where((eb) => {
      return eb.or(conditions.map(([column, value]) => eb(column, "=", value)));
    });
    return this;
  }
  orWhere(...conditions) {
    return this.applyOrWhere(...conditions);
  }
  applyWhen(condition, callback) {
    if (condition)
      callback(this);
    return this;
  }
  when(condition, callback) {
    return this.applyWhen(condition, callback);
  }
  applyWhereNotNull(column) {
    this.selectFromQuery = this.selectFromQuery.where((eb) => eb(column, "=", "").or(column, "is not", null));
    this.updateFromQuery = this.updateFromQuery.where((eb) => eb(column, "=", "").or(column, "is not", null));
    this.deleteFromQuery = this.deleteFromQuery.where((eb) => eb(column, "=", "").or(column, "is not", null));
    return this;
  }
  whereNotNull(column) {
    return this.applyWhereNotNull(column);
  }
  applyWhereNull(column) {
    this.selectFromQuery = this.selectFromQuery.where((eb) => eb(column, "=", "").or(column, "is", null));
    this.updateFromQuery = this.updateFromQuery.where((eb) => eb(column, "=", "").or(column, "is", null));
    this.deleteFromQuery = this.deleteFromQuery.where((eb) => eb(column, "=", "").or(column, "is", null));
    return this;
  }
  whereNull(column) {
    return this.applyWhereNull(column);
  }
  applyWhereIn(column, values) {
    this.selectFromQuery = this.selectFromQuery.where(column, "in", values);
    this.updateFromQuery = this.updateFromQuery.where(column, "in", values);
    this.deleteFromQuery = this.deleteFromQuery.where(column, "in", values);
    return this;
  }
  whereIn(column, values) {
    return this.applyWhereIn(column, values);
  }
  applyWhereBetween(column, range) {
    if (range.length !== 2) {
      throw new HttpError(500, "Range must have exactly two values: [min, max]");
    }
    const query2 = sql` ${sql.raw(column)} between ${range[0]} and ${range[1]} `;
    this.selectFromQuery = this.selectFromQuery.where(query2);
    this.updateFromQuery = this.updateFromQuery.where(query2);
    this.deleteFromQuery = this.deleteFromQuery.where(query2);
    return this;
  }
  whereBetween(column, range) {
    return this.applyWhereBetween(column, range);
  }
  applyWhereLike(column, value) {
    this.selectFromQuery = this.selectFromQuery.where(sql` ${sql.raw(column)} LIKE ${value}`);
    this.updateFromQuery = this.updateFromQuery.where(sql` ${sql.raw(column)} LIKE ${value}`);
    this.deleteFromQuery = this.deleteFromQuery.where(sql` ${sql.raw(column)} LIKE ${value}`);
    return this;
  }
  whereLike(column, value) {
    return this.applyWhereLike(column, value);
  }
  applyWhereNotIn(column, values) {
    this.selectFromQuery = this.selectFromQuery.where(column, "not in", values);
    this.updateFromQuery = this.updateFromQuery.where(column, "not in", values);
    this.deleteFromQuery = this.deleteFromQuery.where(column, "not in", values);
    return this;
  }
  whereNotIn(column, values) {
    return this.applyWhereNotIn(column, values);
  }
  async exists() {
    let model;
    if (this.hasSelect) {
      model = await this.selectFromQuery.executeTakeFirst();
    } else {
      model = await this.selectFromQuery.selectAll().executeTakeFirst();
    }
    return model !== null && model !== undefined;
  }
  applyWith(relations) {
    this.withRelations = relations;
    return this;
  }
  with(relations) {
    return this.applyWith(relations);
  }
  async applyLast() {
    let model;
    if (this.hasSelect) {
      model = await this.selectFromQuery.executeTakeFirst();
    } else {
      model = await this.selectFromQuery.selectAll().orderBy("id", "desc").executeTakeFirst();
    }
    if (model) {
      this.mapCustomGetters(model);
      await this.loadRelations(model);
    }
    return model;
  }
  async last() {
    const model = await this.applyLast();
    if (!model)
      return;
    return model;
  }
  async applyGet() {
    let models;
    if (this.hasSelect) {
      models = await this.selectFromQuery.execute();
    } else {
      models = await this.selectFromQuery.selectAll().execute();
    }
    this.mapCustomGetters(models);
    await this.loadRelations(models);
    return models;
  }
  async get() {
    return await this.applyGet();
  }
  applySkip(count) {
    this.selectFromQuery = this.selectFromQuery.offset(count);
    return this;
  }
  skip(count) {
    return this.applySkip(count);
  }
  applyTake(count) {
    this.selectFromQuery = this.selectFromQuery.limit(count);
    return this;
  }
  take(count) {
    return this.applyTake(count);
  }
  async applyCount() {
    const result = await this.selectFromQuery.select(sql`COUNT(*) as count`).executeTakeFirst();
    return result.count || 0;
  }
  async count() {
    return await this.applyCount();
  }
  applyOrderBy(column, order) {
    this.selectFromQuery = this.selectFromQuery.orderBy(column, order);
    return this;
  }
  orderBy(column, order) {
    return this.applyOrderBy(column, order);
  }
  applyGroupBy(column) {
    this.selectFromQuery = this.selectFromQuery.groupBy(column);
    return this;
  }
  groupBy(column) {
    return this.applyGroupBy(column);
  }
  applyHaving(column, operator, value) {
    this.selectFromQuery = this.selectFromQuery.having(column, operator, value);
    return this;
  }
  having(column, operator, value) {
    return this.applyHaving(column, operator, value);
  }
  applyOrderByDesc(column) {
    this.selectFromQuery = this.selectFromQuery.orderBy(column, "desc");
    return this;
  }
  orderByDesc(column) {
    return this.applyOrderByDesc(column);
  }
  applyOrderByAsc(column) {
    this.selectFromQuery = this.selectFromQuery.orderBy(column, "asc");
    return this;
  }
  orderByAsc(column) {
    return this.applyOrderByAsc(column);
  }
  applyDistinct(column) {
    this.selectFromQuery = this.selectFromQuery.select(column).distinct();
    this.hasSelect = true;
    return this;
  }
  distinct(column) {
    return this.applyDistinct(column);
  }
  applyJoin(table, firstCol, secondCol) {
    this.selectFromQuery = this.selectFromQuery.innerJoin(table, firstCol, secondCol);
    return this;
  }
  join(table, firstCol, secondCol) {
    return this.applyJoin(table, firstCol, secondCol);
  }
  async applyPluck(field) {
    let models;
    if (this.hasSelect) {
      models = await this.selectFromQuery.execute();
    } else {
      models = await this.selectFromQuery.selectAll().execute();
    }
    return models.map((model) => model[field]);
  }
  async pluck(field) {
    return await this.applyPluck(field);
  }
  applyInRandomOrder() {
    this.selectFromQuery = this.selectFromQuery.orderBy(sql` ${sql.raw("RANDOM()")} `);
    return this;
  }
  inRandomOrder() {
    return this.applyInRandomOrder();
  }
  applyWhereExists(callback) {
    this.selectFromQuery = this.selectFromQuery.where(({ exists, selectFrom }) => exists(callback({ exists, selectFrom })));
    return this;
  }
  whereExists(callback) {
    return this.applyWhereExists(callback);
  }
  applyHas(relation) {
    this.selectFromQuery = this.selectFromQuery.where(({ exists, selectFrom }) => exists(selectFrom(relation).select("1").whereRef(`${relation}.${this.tableName.slice(0, -1)}_id`, "=", `${this.tableName}.id`)));
    return this;
  }
  has(relation) {
    return this.applyHas(relation);
  }
  applyDoesntHave(relation) {
    this.selectFromQuery = this.selectFromQuery.where(({ not, exists, selectFrom }) => not(exists(selectFrom(relation).select("1").whereRef(`${relation}.${this.tableName.slice(0, -1)}_id`, "=", `${this.tableName}.id`))));
    return this;
  }
  doesntHave(relation) {
    return this.applyDoesntHave(relation);
  }
  applyWhereHas(relation, callback) {
    this.selectFromQuery = this.selectFromQuery.where(({ exists, selectFrom }) => {
      const subquery = selectFrom(relation).select("1").whereRef(`${relation}.${this.tableName.slice(0, -1)}_id`, "=", `${this.tableName}.id`);
      callback(subquery);
      return exists(subquery);
    });
    return this;
  }
  whereHas(relation, callback) {
    return this.applyWhereHas(relation, callback);
  }
  applyWhereDoesntHave(relation, callback) {
    this.selectFromQuery = this.selectFromQuery.where(({ exists, selectFrom, not }) => {
      const subquery = selectFrom(relation).select("1").whereRef(`${relation}.${this.tableName.slice(0, -1)}_id`, "=", `${this.tableName}.id`);
      callback(subquery);
      return not(exists(subquery));
    });
    return this;
  }
  whereDoesntHave(relation, callback) {
    return this.applyWhereDoesntHave(relation, callback);
  }
  async applyPaginate(options = { limit: 10, offset: 0, page: 1 }) {
    const totalRecordsResult = await DB.instance.selectFrom(this.tableName).select(DB.instance.fn.count("id").as("total")).executeTakeFirst();
    const totalRecords = Number(totalRecordsResult?.total) || 0;
    const totalPages = Math.ceil(totalRecords / (options.limit ?? 10));
    const modelsWithExtra = await DB.instance.selectFrom(this.tableName).selectAll().orderBy("id", "asc").limit((options.limit ?? 10) + 1).offset(((options.page ?? 1) - 1) * (options.limit ?? 10)).execute();
    let nextCursor = null;
    if (modelsWithExtra.length > (options.limit ?? 10))
      nextCursor = modelsWithExtra.pop()?.id ?? null;
    this.mapCustomGetters(modelsWithExtra);
    await this.loadRelations(modelsWithExtra);
    return {
      data: modelsWithExtra,
      paging: {
        total_records: totalRecords,
        page: options.page || 1,
        total_pages: totalPages
      },
      next_cursor: nextCursor
    };
  }
  async paginate(options = { limit: 10, offset: 0, page: 1 }) {
    return await this.applyPaginate(options);
  }
  async applyMax(field) {
    const result = await this.selectFromQuery.select(sql`MAX(${sql.raw(field)}) as max`).executeTakeFirst();
    return result.max || 0;
  }
  async max(field) {
    return await this.applyMax(field);
  }
  async applyMin(field) {
    const result = await this.selectFromQuery.select(sql`MIN(${sql.raw(field)}) as min`).executeTakeFirst();
    return result.min || 0;
  }
  async min(field) {
    return await this.applyMin(field);
  }
  async applyAvg(field) {
    const result = await this.selectFromQuery.select(sql`AVG(${sql.raw(field)}) as avg`).executeTakeFirst();
    return result.avg || 0;
  }
  async avg(field) {
    return await this.applyAvg(field);
  }
  async applySum(field) {
    const result = await this.selectFromQuery.select(sql`SUM(${sql.raw(field)}) as sum`).executeTakeFirst();
    return Number(result?.sum) || 0;
  }
  async sum(field) {
    return await this.applySum(field);
  }
  async applyChunk(size, callback) {
    let page = 1;
    let hasMore = true;
    while (hasMore) {
      const models = await this.selectFromQuery.selectAll().limit(size).offset((page - 1) * size).execute();
      if (models.length < size) {
        hasMore = false;
      }
      if (models.length > 0) {
        await callback(models);
      }
      page++;
    }
  }
  async chunk(size, callback) {
    await this.applyChunk(size, callback);
  }
  isDirty(column) {
    if (!("attributes" in this) || !("originalAttributes" in this)) {
      throw new Error("Child class must define attributes and originalAttributes properties");
    }
    if (column) {
      return this.attributes[column] !== this.originalAttributes[column];
    }
    return Object.entries(this.originalAttributes).some(([key, originalValue]) => {
      const currentValue = this.attributes[key];
      return currentValue !== originalValue;
    });
  }
  isClean(column) {
    return !this.isDirty(column);
  }
  wasChanged(column) {
    if (!("hasSaved" in this)) {
      throw new Error("Child class must define hasSaved property");
    }
    return this.hasSaved && this.isDirty(column);
  }
  getOriginal(column) {
    if (!("originalAttributes" in this)) {
      throw new Error("Child class must define originalAttributes property");
    }
    if (column) {
      return this.originalAttributes[column];
    }
    return this.originalAttributes;
  }
  getChanges() {
    if (!("attributes" in this) || !("originalAttributes" in this) || !("fillable" in this)) {
      throw new Error("Child class must define attributes, originalAttributes, and fillable properties");
    }
    return this.fillable.reduce((changes, key) => {
      const currentValue = this.attributes[key];
      const originalValue = this.originalAttributes[key];
      if (currentValue !== originalValue) {
        changes[key] = currentValue;
      }
      return changes;
    }, {});
  }
  applyFill(data) {
    if (!("attributes" in this) || !("fillable" in this) || !("guarded" in this)) {
      throw new Error("Child class must define attributes, fillable, and guarded properties");
    }
    for (const [key, value] of Object.entries(data)) {
      if (!this.guarded.includes(key) && this.fillable.includes(key)) {
        this.attributes[key] = value;
      }
    }
    return this;
  }
  fill(data) {
    return this.applyFill(data);
  }
  applyForceFill(data) {
    if (!("attributes" in this)) {
      throw new Error("Child class must define attributes property");
    }
    for (const [key, value] of Object.entries(data)) {
      this.attributes[key] = value;
    }
    return this;
  }
  forceFill(data) {
    return this.applyForceFill(data);
  }
  mapCustomGetters(_model) {}
  async loadRelations(_model) {}
  async getCategoryIds(id) {
    const categoryLinks = await DB.instance.selectFrom("categorizable_models").where("categorizable_id", "=", id).where("categorizable_type", "=", this.tableName).selectAll().execute();
    return categoryLinks.map((link) => link.category_id);
  }
  async baseCategories(id) {
    const categoryIds = await this.getCategoryIds(id);
    if (categoryIds.length === 0)
      return [];
    return await DB.instance.selectFrom("categorizable").where("id", "in", categoryIds).selectAll().execute();
  }
  async baseCategoryCount(id) {
    const categoryIds = await this.getCategoryIds(id);
    return categoryIds.length;
  }
  async baseAddCategory(id, category) {
    let categoryRecord = await DB.instance.selectFrom("categorizable").where("name", "=", category.name).selectAll().executeTakeFirst();
    if (!categoryRecord) {
      categoryRecord = await DB.instance.insertInto("categorizable").values({
        name: category.name,
        description: category.description,
        slug: category.name.toLowerCase().replace(/[^a-z0-9]+/g, "-"),
        is_active: true,
        created_at: new Date,
        updated_at: new Date
      }).returningAll().executeTakeFirst();
    }
    return await DB.instance.insertInto("categorizable_models").values({
      categorizable_id: id,
      categorizable_type: this.tableName,
      category_id: categoryRecord.id,
      created_at: new Date,
      updated_at: new Date
    }).returningAll().executeTakeFirst();
  }
  async baseActiveCategories(id) {
    const categoryIds = await this.getCategoryIds(id);
    if (categoryIds.length === 0)
      return [];
    return await DB.instance.selectFrom("categorizable").where("id", "in", categoryIds).where("is_active", "=", true).selectAll().execute();
  }
  async baseInactiveCategories(id) {
    const categoryIds = await this.getCategoryIds(id);
    if (categoryIds.length === 0)
      return [];
    return await DB.instance.selectFrom("categorizable").where("id", "in", categoryIds).where("is_active", "=", false).selectAll().execute();
  }
  async baseRemoveCategory(categoryId) {
    await DB.instance.deleteFrom("categorizable").where("categorizable_type", "=", this.tableName).where("id", "=", categoryId).execute();
  }
  async baseTags(id) {
    return await DB.instance.selectFrom("taggable").where("taggable_id", "=", id).where("taggable_type", "=", this.tableName).selectAll().execute();
  }
  async baseTagCount(id) {
    const result = await DB.instance.selectFrom("taggable").select(sql`count(*) as count`).where("taggable_id", "=", id).where("taggable_type", "=", this.tableName).executeTakeFirst();
    return Number(result?.count) || 0;
  }
  async baseAddTag(id, tag) {
    return await DB.instance.insertInto("taggable").values({
      ...tag,
      taggable_id: id,
      taggable_type: this.tableName,
      slug: tag.name.toLowerCase().replace(/[^a-z0-9]+/g, "-"),
      order: 0,
      is_active: true,
      created_at: new Date,
      updated_at: new Date
    }).returningAll().executeTakeFirst();
  }
  async baseActiveTags(id) {
    return await DB.instance.selectFrom("taggable").where("taggable_id", "=", id).where("taggable_type", "=", this.tableName).where("is_active", "=", true).selectAll().execute();
  }
  async baseInactiveTags(id) {
    return await DB.instance.selectFrom("taggable").where("taggable_id", "=", id).where("taggable_type", "=", this.tableName).where("is_active", "=", false).selectAll().execute();
  }
  async baseRemoveTag(id, tagId) {
    await DB.instance.deleteFrom("taggable").where("taggable_id", "=", id).where("taggable_type", "=", this.tableName).where("id", "=", tagId).execute();
  }
  async baseComments(id) {
    return await DB.instance.selectFrom("comments").where("commentables_id", "=", id).where("commentables_type", "=", this.tableName).selectAll().execute();
  }
  async baseCommentCount(id) {
    const result = await DB.instance.selectFrom("comments").select(sql`count(*) as count`).where("commentables_id", "=", id).where("commentables_type", "=", this.tableName).executeTakeFirst();
    return Number(result?.count) || 0;
  }
  async baseAddComment(id, comment) {
    return await DB.instance.insertInto("comments").values({
      ...comment,
      commentables_id: id,
      commentables_type: this.tableName,
      status: "pending",
      created_at: new Date,
      updated_at: new Date
    }).returningAll().executeTakeFirst();
  }
  async baseApprovedComments(id) {
    return await DB.instance.selectFrom("comments").where("commentables_id", "=", id).where("commentables_type", "=", this.tableName).where("status", "=", "approved").selectAll().execute();
  }
  async basePendingComments(id) {
    return await DB.instance.selectFrom("comments").where("commentables_id", "=", id).where("commentables_type", "=", this.tableName).where("status", "=", "pending").selectAll().execute();
  }
  async baseRejectedComments(id) {
    return await DB.instance.selectFrom("comments").where("commentables_id", "=", id).where("commentables_type", "=", this.tableName).where("status", "=", "rejected").selectAll().execute();
  }
}

// ../../orm/src/models/Project.ts
import { HttpError as HttpError2 } from "@stacksjs/error-handling";
// ../../orm/src/models/SubscriberEmail.ts
import { HttpError as HttpError3 } from "@stacksjs/error-handling";
// ../../orm/src/models/OauthAccessToken.ts
import { HttpError as HttpError4 } from "@stacksjs/error-handling";
// ../../orm/src/models/OauthClient.ts
import { HttpError as HttpError5 } from "@stacksjs/error-handling";
// ../../orm/src/models/Team.ts
import { HttpError as HttpError6 } from "@stacksjs/error-handling";
// ../../orm/src/models/Subscriber.ts
import { HttpError as HttpError7 } from "@stacksjs/error-handling";
// ../../orm/src/models/Deployment.ts
import { HttpError as HttpError8 } from "@stacksjs/error-handling";
// ../../orm/src/models/Release.ts
import { HttpError as HttpError9 } from "@stacksjs/error-handling";
// ../../orm/src/models/User.ts
import { HttpError as HttpError10 } from "@stacksjs/error-handling";
var {randomUUIDv7 } = globalThis.Bun;
class UserModel extends BaseOrm {
  hidden = ["password"];
  fillable = ["name", "email", "password", "uuid", "two_factor_secret", "public_key", "team_id"];
  guarded = [];
  attributes = {};
  originalAttributes = {};
  selectFromQuery;
  updateFromQuery;
  deleteFromQuery;
  hasSelect;
  customColumns = {};
  constructor(user) {
    super("users");
    if (user) {
      this.attributes = { ...user };
      this.originalAttributes = { ...user };
      Object.keys(user).forEach((key) => {
        if (!(key in this)) {
          this.customColumns[key] = user[key];
        }
      });
    }
    this.withRelations = [];
    this.selectFromQuery = DB.instance.selectFrom("users");
    this.updateFromQuery = DB.instance.updateTable("users");
    this.deleteFromQuery = DB.instance.deleteFrom("users");
    this.hasSelect = false;
  }
  async loadRelations(models) {
    const modelArray = Array.isArray(models) ? models : [models];
    if (!modelArray.length)
      return;
    const modelIds = modelArray.map((model) => model.id);
    for (const relation of this.withRelations) {
      const relatedRecords = await DB.instance.selectFrom(relation).where("user_id", "in", modelIds).selectAll().execute();
      if (Array.isArray(models)) {
        models.map((model) => {
          const records = relatedRecords.filter((record) => {
            return record.user_id === model.id;
          });
          model[relation] = records.length === 1 ? records[0] : records;
          return model;
        });
      } else {
        const records = relatedRecords.filter((record) => {
          return record.user_id === models.id;
        });
        models[relation] = records.length === 1 ? records[0] : records;
      }
    }
  }
  static with(relations) {
    const instance = new UserModel(undefined);
    return instance.applyWith(relations);
  }
  mapCustomGetters(models) {
    const data = models;
    if (Array.isArray(data)) {
      data.map((model) => {
        const customGetter = {
          default: () => {},
          salutationName: () => {
            return `Mr. ${model.name}`;
          }
        };
        for (const [key, fn] of Object.entries(customGetter)) {
          model[key] = fn();
        }
        return model;
      });
    } else {
      const model = data;
      const customGetter = {
        default: () => {},
        salutationName: () => {
          return `Mr. ${model.name}`;
        }
      };
      for (const [key, fn] of Object.entries(customGetter)) {
        model[key] = fn();
      }
    }
  }
  async mapCustomSetters(model) {
    const customSetter = {
      default: () => {},
      password: async () => {
        return await make(model.password, { algorithm: "bcrypt" });
      }
    };
    for (const [key, fn] of Object.entries(customSetter)) {
      model[key] = await fn();
    }
  }
  get subscriber() {
    return this.attributes.subscriber;
  }
  get driver() {
    return this.attributes.driver;
  }
  get author() {
    return this.attributes.author;
  }
  get personal_access_tokens() {
    return this.attributes.personal_access_tokens;
  }
  get oauth_access_tokens() {
    return this.attributes.oauth_access_tokens;
  }
  get customers() {
    return this.attributes.customers;
  }
  get id() {
    return this.attributes.id;
  }
  get uuid() {
    return this.attributes.uuid;
  }
  get public_passkey() {
    return this.attributes.public_passkey;
  }
  get name() {
    return this.attributes.name;
  }
  get email() {
    return this.attributes.email;
  }
  get password() {
    return this.attributes.password;
  }
  get github_id() {
    return this.attributes.github_id;
  }
  get created_at() {
    return this.attributes.created_at;
  }
  get updated_at() {
    return this.attributes.updated_at;
  }
  set uuid(value) {
    this.attributes.uuid = value;
  }
  set public_passkey(value) {
    this.attributes.public_passkey = value;
  }
  set name(value) {
    this.attributes.name = value;
  }
  set email(value) {
    this.attributes.email = value;
  }
  set password(value) {
    this.attributes.password = value;
  }
  set github_id(value) {
    this.attributes.github_id = value;
  }
  set updated_at(value) {
    this.attributes.updated_at = value;
  }
  static select(params) {
    const instance = new UserModel(undefined);
    return instance.applySelect(params);
  }
  static async find(id) {
    let query2 = DB.instance.selectFrom("users").where("id", "=", id).selectAll();
    const model = await query2.executeTakeFirst();
    if (!model)
      return;
    const instance = new UserModel(undefined);
    return instance.createInstance(model);
  }
  static async first() {
    const instance = new UserModel(undefined);
    const model = await instance.applyFirst();
    const data = new UserModel(model);
    return data;
  }
  static async last() {
    const instance = new UserModel(undefined);
    const model = await instance.applyLast();
    if (!model)
      return;
    return new UserModel(model);
  }
  static async firstOrFail() {
    const instance = new UserModel(undefined);
    return await instance.applyFirstOrFail();
  }
  static async all() {
    const instance = new UserModel(undefined);
    const models = await DB.instance.selectFrom("users").selectAll().execute();
    instance.mapCustomGetters(models);
    const data = await Promise.all(models.map(async (model) => {
      return new UserModel(model);
    }));
    return data;
  }
  static async findOrFail(id) {
    const instance = new UserModel(undefined);
    return await instance.applyFindOrFail(id);
  }
  static async findMany(ids) {
    const instance = new UserModel(undefined);
    const models = await instance.applyFindMany(ids);
    return models.map((modelItem) => instance.parseResult(new UserModel(modelItem)));
  }
  static async latest(column = "created_at") {
    const instance = new UserModel(undefined);
    const model = await instance.selectFromQuery.selectAll().orderBy(column, "desc").limit(1).executeTakeFirst();
    if (!model)
      return;
    return new UserModel(model);
  }
  static async oldest(column = "created_at") {
    const instance = new UserModel(undefined);
    const model = await instance.selectFromQuery.selectAll().orderBy(column, "asc").limit(1).executeTakeFirst();
    if (!model)
      return;
    return new UserModel(model);
  }
  static skip(count) {
    const instance = new UserModel(undefined);
    return instance.applySkip(count);
  }
  static take(count) {
    const instance = new UserModel(undefined);
    return instance.applyTake(count);
  }
  static where(column, ...args) {
    const instance = new UserModel(undefined);
    return instance.applyWhere(column, ...args);
  }
  static orWhere(...conditions) {
    const instance = new UserModel(undefined);
    return instance.applyOrWhere(...conditions);
  }
  static whereNotIn(column, values) {
    const instance = new UserModel(undefined);
    return instance.applyWhereNotIn(column, values);
  }
  static whereBetween(column, range) {
    const instance = new UserModel(undefined);
    return instance.applyWhereBetween(column, range);
  }
  static whereRef(column, ...args) {
    const instance = new UserModel(undefined);
    return instance.applyWhereRef(column, ...args);
  }
  static when(condition, callback) {
    const instance = new UserModel(undefined);
    return instance.applyWhen(condition, callback);
  }
  static whereNull(column) {
    const instance = new UserModel(undefined);
    return instance.applyWhereNull(column);
  }
  static whereNotNull(column) {
    const instance = new UserModel(undefined);
    return instance.applyWhereNotNull(column);
  }
  static whereLike(column, value) {
    const instance = new UserModel(undefined);
    return instance.applyWhereLike(column, value);
  }
  static orderBy(column, order) {
    const instance = new UserModel(undefined);
    return instance.applyOrderBy(column, order);
  }
  static orderByAsc(column) {
    const instance = new UserModel(undefined);
    return instance.applyOrderByAsc(column);
  }
  static orderByDesc(column) {
    const instance = new UserModel(undefined);
    return instance.applyOrderByDesc(column);
  }
  static groupBy(column) {
    const instance = new UserModel(undefined);
    return instance.applyGroupBy(column);
  }
  static having(column, operator, value) {
    const instance = new UserModel(undefined);
    return instance.applyHaving(column, operator, value);
  }
  static inRandomOrder() {
    const instance = new UserModel(undefined);
    return instance.applyInRandomOrder();
  }
  static whereColumn(first, operator, second) {
    const instance = new UserModel(undefined);
    return instance.applyWhereColumn(first, operator, second);
  }
  static async max(field) {
    const instance = new UserModel(undefined);
    return await instance.applyMax(field);
  }
  static async min(field) {
    const instance = new UserModel(undefined);
    return await instance.applyMin(field);
  }
  static async avg(field) {
    const instance = new UserModel(undefined);
    return await instance.applyAvg(field);
  }
  static async sum(field) {
    const instance = new UserModel(undefined);
    return await instance.applySum(field);
  }
  static async count() {
    const instance = new UserModel(undefined);
    return instance.applyCount();
  }
  static async get() {
    const instance = new UserModel(undefined);
    const results = await instance.applyGet();
    return results.map((item) => instance.createInstance(item));
  }
  static async pluck(field) {
    const instance = new UserModel(undefined);
    return await instance.applyPluck(field);
  }
  static async chunk(size, callback) {
    const instance = new UserModel(undefined);
    await instance.applyChunk(size, async (models) => {
      const modelInstances = models.map((item) => instance.createInstance(item));
      await callback(modelInstances);
    });
  }
  static async paginate(options = { limit: 10, offset: 0, page: 1 }) {
    const instance = new UserModel(undefined);
    const result = await instance.applyPaginate(options);
    return {
      data: result.data.map((item) => instance.createInstance(item)),
      paging: result.paging,
      next_cursor: result.next_cursor
    };
  }
  createInstance(data) {
    return new UserModel(data);
  }
  async applyCreate(newUser) {
    const filteredValues = Object.fromEntries(Object.entries(newUser).filter(([key]) => !this.guarded.includes(key) && this.fillable.includes(key)));
    await this.mapCustomSetters(filteredValues);
    filteredValues["uuid"] = randomUUIDv7();
    const result = await DB.instance.insertInto("users").values(filteredValues).executeTakeFirst();
    const model = await DB.instance.selectFrom("users").where("id", "=", Number(result.insertId || result.numInsertedOrUpdatedRows)).selectAll().executeTakeFirst();
    if (!model) {
      throw new HttpError10(500, "Failed to retrieve created User");
    }
    return this.createInstance(model);
  }
  async create(newUser) {
    return await this.applyCreate(newUser);
  }
  static async create(newUser) {
    const instance = new UserModel(undefined);
    return await instance.applyCreate(newUser);
  }
  static async firstOrCreate(search, values = {}) {
    const instance = new UserModel(undefined);
    for (const [key, value] of Object.entries(search)) {
      instance.selectFromQuery = instance.selectFromQuery.where(key, "=", value);
    }
    const existingRecord = await instance.applyFirst();
    if (existingRecord) {
      return instance.createInstance(existingRecord);
    }
    const createData = { ...search, ...values };
    return await UserModel.create(createData);
  }
  static async updateOrCreate(search, values = {}) {
    const instance = new UserModel(undefined);
    for (const [key, value] of Object.entries(search)) {
      instance.selectFromQuery = instance.selectFromQuery.where(key, "=", value);
    }
    const existingRecord = await instance.applyFirst();
    if (existingRecord) {
      const model = instance.createInstance(existingRecord);
      const updatedModel = await model.update(values);
      if (updatedModel) {
        return updatedModel;
      }
      const refreshedModel = await instance.applyFirst();
      return instance.createInstance(refreshedModel);
    }
    const createData = { ...search, ...values };
    return await UserModel.create(createData);
  }
  async update(newUser) {
    const filteredValues = Object.fromEntries(Object.entries(newUser).filter(([key]) => !this.guarded.includes(key) && this.fillable.includes(key)));
    await this.mapCustomSetters(filteredValues);
    filteredValues.updated_at = new Date().toISOString();
    await DB.instance.updateTable("users").set(filteredValues).where("id", "=", this.id).executeTakeFirst();
    if (this.id) {
      const model = await DB.instance.selectFrom("users").where("id", "=", this.id).selectAll().executeTakeFirst();
      if (!model) {
        throw new HttpError10(500, "Failed to retrieve updated User");
      }
      return this.createInstance(model);
    }
    return;
  }
  async forceUpdate(newUser) {
    await DB.instance.updateTable("users").set(newUser).where("id", "=", this.id).executeTakeFirst();
    if (this.id) {
      const model = await DB.instance.selectFrom("users").where("id", "=", this.id).selectAll().executeTakeFirst();
      if (!model) {
        throw new HttpError10(500, "Failed to retrieve updated User");
      }
      return this.createInstance(model);
    }
    return;
  }
  async save() {
    if (this.id) {
      await DB.instance.updateTable("users").set(this.attributes).where("id", "=", this.id).executeTakeFirst();
      const model = await DB.instance.selectFrom("users").where("id", "=", this.id).selectAll().executeTakeFirst();
      if (!model) {
        throw new HttpError10(500, "Failed to retrieve updated User");
      }
      return this.createInstance(model);
    } else {
      const result = await DB.instance.insertInto("users").values(this.attributes).executeTakeFirst();
      const model = await DB.instance.selectFrom("users").where("id", "=", Number(result.insertId || result.numInsertedOrUpdatedRows)).selectAll().executeTakeFirst();
      if (!model) {
        throw new HttpError10(500, "Failed to retrieve created User");
      }
      return this.createInstance(model);
    }
  }
  static async createMany(newUser) {
    const instance = new UserModel(undefined);
    const valuesFiltered = newUser.map((newUser2) => {
      const filteredValues = Object.fromEntries(Object.entries(newUser2).filter(([key]) => !instance.guarded.includes(key) && instance.fillable.includes(key)));
      filteredValues["uuid"] = randomUUIDv7();
      return filteredValues;
    });
    await DB.instance.insertInto("users").values(valuesFiltered).executeTakeFirst();
  }
  static async forceCreate(newUser) {
    const result = await DB.instance.insertInto("users").values(newUser).executeTakeFirst();
    const instance = new UserModel(undefined);
    const model = await DB.instance.selectFrom("users").where("id", "=", Number(result.insertId || result.numInsertedOrUpdatedRows)).selectAll().executeTakeFirst();
    if (!model) {
      throw new HttpError10(500, "Failed to retrieve created User");
    }
    return instance.createInstance(model);
  }
  async delete() {
    if (this.id === undefined)
      this.deleteFromQuery.execute();
    const deleted = await DB.instance.deleteFrom("users").where("id", "=", this.id).execute();
    return deleted.numDeletedRows;
  }
  static async remove(id) {
    return await DB.instance.deleteFrom("users").where("id", "=", id).execute();
  }
  static whereName(value) {
    const instance = new UserModel(undefined);
    instance.selectFromQuery = instance.selectFromQuery.where("name", "=", value);
    return instance;
  }
  static whereEmail(value) {
    const instance = new UserModel(undefined);
    instance.selectFromQuery = instance.selectFromQuery.where("email", "=", value);
    return instance;
  }
  static wherePassword(value) {
    const instance = new UserModel(undefined);
    instance.selectFromQuery = instance.selectFromQuery.where("password", "=", value);
    return instance;
  }
  static whereIn(column, values) {
    const instance = new UserModel(undefined);
    return instance.applyWhereIn(column, values);
  }
  async userTeams() {
    if (this.id === undefined)
      throw new HttpError10(500, "Relation Error!");
    const results = await DB.instance.selectFrom("teams").where("team_id", "=", this.id).selectAll().execute();
    const tableRelationIds = results.map((result) => result.team_id);
    if (!tableRelationIds.length)
      throw new HttpError10(500, "Relation Error!");
    const relationResults = await Team.whereIn("id", tableRelationIds).get();
    return relationResults;
  }
  toSearchableObject() {
    return {
      id: this.id,
      name: this.name,
      email: this.email
    };
  }
  static distinct(column) {
    const instance = new UserModel(undefined);
    return instance.applyDistinct(column);
  }
  static join(table, firstCol, secondCol) {
    const instance = new UserModel(undefined);
    return instance.applyJoin(table, firstCol, secondCol);
  }
  toJSON() {
    const output = {
      uuid: this.uuid,
      id: this.id,
      name: this.name,
      email: this.email,
      created_at: this.created_at,
      updated_at: this.updated_at,
      personal_access_tokens: this.personal_access_tokens,
      oauth_access_tokens: this.oauth_access_tokens,
      customers: this.customers,
      ...this.customColumns,
      github_id: this.github_id,
      public_passkey: this.public_passkey
    };
    return output;
  }
  parseResult(model) {
    for (const hiddenAttribute of this.hidden) {
      delete model[hiddenAttribute];
    }
    return model;
  }
  async applyFind(id) {
    const model = await DB.instance.selectFrom(this.tableName).where("id", "=", id).selectAll().executeTakeFirst();
    if (!model)
      return;
    this.mapCustomGetters(model);
    await this.loadRelations(model);
    return this.createInstance(model);
  }
}
var User2 = UserModel;
var User_default = User2;
// ../../orm/src/models/PersonalAccessToken.ts
import { HttpError as HttpError11 } from "@stacksjs/error-handling";
// ../../orm/src/models/PrintDevice.ts
import { HttpError as HttpError12 } from "@stacksjs/error-handling";

// ../events/src/index.ts
function mitt(all) {
  if (!all)
    all = new Map;
  return {
    all,
    on(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        handlers.push(handler);
      } else {
        all.set(type, [handler]);
      }
    },
    off(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        if (handler) {
          const index = handlers.indexOf(handler);
          if (index > -1)
            handlers.splice(index, 1);
        } else {
          all.set(type, []);
        }
      }
    },
    emit(type, evt) {
      let handlers = all.get(type);
      if (handlers) {
        handlers.slice().forEach((handler) => {
          if (evt !== undefined)
            handler(evt);
        });
      }
      handlers = all.get("*");
      if (handlers) {
        handlers.slice().forEach((handler) => {
          if (evt !== undefined)
            handler(type, evt);
        });
      }
    }
  };
}
var events = mitt();
var emitter = events;
var dispatch = emitter.emit;
var all = emitter.all;
var listen = emitter.on;
var useListen = emitter.on;
var off = emitter.off;
// ../../orm/src/models/Category.ts
import { HttpError as HttpError13 } from "@stacksjs/error-handling";
// ../../orm/src/models/Payment.ts
import { HttpError as HttpError14 } from "@stacksjs/error-handling";
// ../../orm/src/models/Driver.ts
import { HttpError as HttpError15 } from "@stacksjs/error-handling";
// ../../orm/src/models/WaitlistProduct.ts
import { HttpError as HttpError16 } from "@stacksjs/error-handling";
// ../../orm/src/models/DigitalDelivery.ts
import { HttpError as HttpError17 } from "@stacksjs/error-handling";
// ../../orm/src/models/Manufacturer.ts
import { HttpError as HttpError18 } from "@stacksjs/error-handling";
// ../../orm/src/models/OrderItem.ts
import { HttpError as HttpError19 } from "@stacksjs/error-handling";
// ../../orm/src/models/ShippingZone.ts
import { HttpError as HttpError20 } from "@stacksjs/error-handling";
// ../../orm/src/models/Customer.ts
import { HttpError as HttpError21 } from "@stacksjs/error-handling";
// ../../orm/src/models/Product.ts
import { HttpError as HttpError22 } from "@stacksjs/error-handling";
// ../../orm/src/models/Receipt.ts
import { HttpError as HttpError23 } from "@stacksjs/error-handling";
// ../../orm/src/models/ProductVariant.ts
import { HttpError as HttpError24 } from "@stacksjs/error-handling";
// ../../orm/src/models/LicenseKey.ts
import { HttpError as HttpError25 } from "@stacksjs/error-handling";
// ../../orm/src/models/WaitlistRestaurant.ts
import { HttpError as HttpError26 } from "@stacksjs/error-handling";
// ../../orm/src/models/Review.ts
import { HttpError as HttpError27 } from "@stacksjs/error-handling";
// ../../orm/src/models/ProductUnit.ts
import { HttpError as HttpError28 } from "@stacksjs/error-handling";
// ../../orm/src/models/GiftCard.ts
import { HttpError as HttpError29 } from "@stacksjs/error-handling";
// ../../orm/src/models/Order.ts
import { HttpError as HttpError30 } from "@stacksjs/error-handling";
// ../../orm/src/models/Coupon.ts
import { HttpError as HttpError31 } from "@stacksjs/error-handling";
// ../../orm/src/models/TaxRate.ts
import { HttpError as HttpError32 } from "@stacksjs/error-handling";
// ../../orm/src/models/Transaction.ts
import { HttpError as HttpError33 } from "@stacksjs/error-handling";
// ../../orm/src/models/LoyaltyPoint.ts
import { HttpError as HttpError34 } from "@stacksjs/error-handling";
// ../../orm/src/models/LoyaltyReward.ts
import { HttpError as HttpError35 } from "@stacksjs/error-handling";
// ../../orm/src/models/ShippingMethod.ts
import { HttpError as HttpError36 } from "@stacksjs/error-handling";
// ../../orm/src/models/ShippingRate.ts
import { HttpError as HttpError37 } from "@stacksjs/error-handling";
// ../../orm/src/models/Cart.ts
import { HttpError as HttpError38 } from "@stacksjs/error-handling";
// ../../orm/src/models/DeliveryRoute.ts
import { HttpError as HttpError39 } from "@stacksjs/error-handling";
// ../../orm/src/models/CartItem.ts
import { HttpError as HttpError40 } from "@stacksjs/error-handling";
// ../../orm/src/models/PaymentProduct.ts
import { HttpError as HttpError41 } from "@stacksjs/error-handling";
// ../../orm/src/models/FailedJob.ts
import { HttpError as HttpError42 } from "@stacksjs/error-handling";
// ../../orm/src/models/PaymentMethod.ts
import { HttpError as HttpError43 } from "@stacksjs/error-handling";
// ../../orm/src/models/Page.ts
import { HttpError as HttpError44 } from "@stacksjs/error-handling";
// ../../orm/src/models/Author.ts
import { HttpError as HttpError45 } from "@stacksjs/error-handling";
// ../../orm/src/models/Post.ts
import { HttpError as HttpError46 } from "@stacksjs/error-handling";
// ../../orm/src/models/PaymentTransaction.ts
import { HttpError as HttpError47 } from "@stacksjs/error-handling";
// ../../orm/src/models/Websocket.ts
import { HttpError as HttpError48 } from "@stacksjs/error-handling";
// ../../orm/src/models/Request.ts
import { HttpError as HttpError49 } from "@stacksjs/error-handling";
// ../../orm/src/models/Job.ts
import { HttpError as HttpError50 } from "@stacksjs/error-handling";
// ../../orm/src/models/Log.ts
import { HttpError as HttpError51 } from "@stacksjs/error-handling";
// ../../orm/src/models/Subscription.ts
import { HttpError as HttpError52 } from "@stacksjs/error-handling";
// ../../orm/src/models/Error.ts
import { HttpError as HttpError53 } from "@stacksjs/error-handling";
// ../orm/src/db.ts
class DB {
  static dbInstance = null;
  static get instance() {
    return this.dbInstance || db;
  }
  static setTransaction(transaction) {
    this.dbInstance = transaction;
  }
  static clearTransaction() {
    this.dbInstance = db;
  }
}
// ../orm/src/generated/table-traits.ts
import { path } from "@stacksjs/path";
function generateMigrationsTableInterface() {
  return `
export interface MigrationsTable {
  name: string
  timestamp: string
}`;
}
function generatePasswordResetsTableInterface() {
  return `
export interface PasswordResetsTable {
  email: string
  token: string
  created_at?: string
}`;
}
function generatePasskeysTableInterface() {
  return `
export interface PasskeysTable {
  id?: number
  cred_public_key: string
  user_id: number
  webauthn_user_id: string
  counter: number
  credential_type: string
  device_type: string
  backup_eligible: boolean
  backup_status: boolean
  transports?: string
  created_at?: string
  updated_at?: string
  last_used_at: string
}`;
}
function generateCommentableInterface() {
  return `
export interface CommentablesTable {
  id?: number
  title: string
  body: string
  status: string
  approved_at: number | null
  rejected_at: number | null
  commentables_id: number
  commentables_type: string
  user_id: number | null
  created_at?: string
  updated_at?: string | null
}`;
}
function generateCommentableUpvotesTableInterface() {
  return `
export interface CommentableUpvotesTable {
  id?: number
  user_id: number
  upvoteable_id: number
  upvoteable_type: string
  created_at?: string
}`;
}
function generateCategorizableTableInterface() {
  return `
  export interface CategorizableTable {
    id?: number
    name: string
    slug: string
    description?: string
    is_active: boolean
    categorizable_type: string
    created_at?: string
    updated_at?: string
  }`;
}
function generateTaggableTableInterface() {
  return `
  export interface TaggableTable {
    id?: number
    name: string
    slug: string
    description?: string
    is_active: boolean
    taggable_type: string
    created_at?: string
    updated_at?: string
  }`;
}
function generateTaggableModelsTableInterface() {
  return `
  export interface TaggableModelsTable {
    id?: number
    tag_id: number
    taggable_type: string
    created_at?: string
    updated_at?: string
  }`;
}
function generateCategorizableModelsTableInterface() {
  return `
  export interface CategorizableModelsTable {
    id?: number
    category_id: number
    categorizable_type: string
    categorizable_id: number
    created_at?: string
    updated_at?: string
  }`;
}
function generateQueryLogsTableInterface() {
  return `
  export interface QueryLogsTable {
    id?: number
    query: string
    normalized_query: string
    duration: number
    connection: string
    status: 'completed' | 'failed' | 'slow'
    error?: string
    executed_at?: string
    bindings?: string
    trace?: string
    model?: string
    method?: string
    file?: string
    line?: number
    memory_usage?: number
    rows_affected?: number
    transaction_id?: string
    tags?: string
    affected_tables?: string
    indexes_used?: string
    missing_indexes?: string
    explain_plan?: string
    optimization_suggestions?: string
  }`;
}
function generateTraitTableInterfaces() {
  return [
    generateMigrationsTableInterface(),
    generatePasswordResetsTableInterface(),
    generatePasskeysTableInterface(),
    generateCommentableInterface(),
    generateCommentableUpvotesTableInterface(),
    generateCategorizableTableInterface(),
    generateTaggableTableInterface(),
    generateTaggableModelsTableInterface(),
    generateCategorizableModelsTableInterface(),
    generateQueryLogsTableInterface()
  ].join(`
`);
}
var traitInterfaces = [
  {
    name: "Migrations",
    fields: {
      name: "string",
      timestamp: "string"
    }
  },
  {
    name: "PasswordResets",
    fields: {
      email: "string",
      token: "string",
      created_at: "string"
    }
  },
  {
    name: "Passkeys",
    fields: {
      id: "number",
      cred_public_key: "string",
      user_id: "number",
      webauthn_user_id: "string",
      counter: "number",
      credential_type: "string",
      device_type: "string",
      backup_eligible: "boolean",
      backup_status: "boolean",
      transports: "string",
      created_at: "string",
      updated_at: "string",
      last_used_at: "string"
    }
  },
  {
    name: "Commentables",
    fields: {
      id: "number",
      title: "string",
      body: "string",
      status: "string",
      approved_at: "number | null",
      rejected_at: "number | null",
      commentables_id: "number",
      commentables_type: "string",
      user_id: "number | null",
      created_at: "string",
      updated_at: "string | null"
    }
  },
  {
    name: "CommentableUpvotes",
    fields: {
      id: "number",
      user_id: "number",
      upvoteable_id: "number",
      upvoteable_type: "string",
      created_at: "string"
    }
  },
  {
    name: "Categorizable",
    fields: {
      id: "number",
      name: "string",
      slug: "string",
      description: "string",
      is_active: "boolean",
      categorizable_type: "string",
      created_at: "string",
      updated_at: "string"
    }
  },
  {
    name: "Taggable",
    fields: {
      id: "number",
      name: "string",
      slug: "string",
      description: "string",
      is_active: "boolean",
      taggable_type: "string",
      created_at: "string",
      updated_at: "string"
    }
  },
  {
    name: "TaggableModels",
    fields: {
      id: "number",
      tag_id: "number",
      taggable_id: "number",
      taggable_type: "string",
      created_at: "string",
      updated_at: "string | null"
    }
  },
  {
    name: "CategorizableModels",
    fields: {
      id: "number",
      category_id: "number",
      categorizable_id: "number",
      categorizable_type: "string",
      created_at: "string",
      updated_at: "string | null"
    }
  }
];
async function generateTraitRequestTypes() {
  let typeString = `import { Request } from '../core/router/src/request'
import type { VineType } from '@stacksjs/types'

`;
  typeString += `interface ValidationField {
    rule: VineType
    message: Record<string, string>
  }

`;
  typeString += `interface CustomAttributes {
    [key: string]: ValidationField
  }

`;
  let importTypesString = "";
  for (let i = 0;i < traitInterfaces.length; i++) {
    const trait = traitInterfaces[i];
    let fieldString = "";
    let fieldStringType = "";
    for (const [field, type] of Object.entries(trait.fields)) {
      fieldString += ` ${field}: ${type}
     `;
    }
    fieldStringType += ` get: <T = string>(element: string, defaultValue?: T) => T`;
    const types = `export interface ${trait.name}RequestType extends Request {
      validate(attributes?: CustomAttributes): void
      ${fieldStringType}
      all(): RequestData${trait.name}
      ${fieldString}
    }

`;
    typeString += `interface RequestData${trait.name} {
      ${fieldString}
    }
`;
    typeString += types;
    importTypesString += `${trait.name}RequestType`;
    if (i < traitInterfaces.length - 1)
      importTypesString += " | ";
  }
  typeString += `export type TraitRequest = ${importTypesString}`;
  const traitsFile = Bun.file(path.frameworkPath("types/traits.d.ts"));
  const writer = traitsFile.writer();
  writer.write(typeString);
  await writer.end();
  return typeString;
}
// ../database/src/drivers/index.ts
import { path as path6 } from "@stacksjs/path";
import { fs as fs5, globSync as globSync4 } from "@stacksjs/storage";

// ../database/src/drivers/mysql.ts
import { italic as italic3, log as log3 } from "@stacksjs/cli";
import { ok } from "@stacksjs/error-handling";
import { path as path3 } from "@stacksjs/path";
import { fs as fs2, globSync } from "@stacksjs/storage";

// ../database/src/drivers/defaults/traits.ts
import { italic as italic2, log as log2 } from "@stacksjs/cli";
import { path as path2 } from "@stacksjs/path";
function getTraitTables() {
  return [
    "taggables",
    "categorizables",
    "commentables",
    "commentable_upvotes",
    "passkeys",
    "password_resets",
    "query_logs",
    "migrations"
  ];
}
// ../database/src/drivers/postgres.ts
import { italic as italic4, log as log4 } from "@stacksjs/cli";
import { ok as ok2 } from "@stacksjs/error-handling";
import { path as path4 } from "@stacksjs/path";
import { fs as fs3, globSync as globSync2 } from "@stacksjs/storage";
// ../database/src/drivers/sqlite.ts
import { italic as italic5, log as log5 } from "@stacksjs/cli";
import { app } from "@stacksjs/config";
import { ok as ok3 } from "@stacksjs/error-handling";
import { path as path5 } from "@stacksjs/path";
import { fs as fs4, globSync as globSync3 } from "@stacksjs/storage";
// ../database/src/custom/jobs.ts
import { log as log8 } from "@stacksjs/cli";
import { database as database2 } from "@stacksjs/config";
import { err, handleError, ok as ok4 } from "@stacksjs/error-handling";
import { path as path8 } from "@stacksjs/path";
// ../database/src/drivers/defaults/passwords.ts
import { italic as italic6, log as log9 } from "@stacksjs/cli";
import { path as path9 } from "@stacksjs/path";
// ../database/src/migrations.ts
import { log as log10 } from "@stacksjs/cli";
import { database as database3 } from "@stacksjs/config";
import { err as err2, handleError as handleError2, ok as ok5 } from "@stacksjs/error-handling";
import { path as path10 } from "@stacksjs/path";
import { fs as fs6, globSync as globSync5 } from "@stacksjs/storage";

// ../../../../node_modules/kysely/dist/esm/util/object-utils.js
function isUndefined(obj) {
  return typeof obj === "undefined" || obj === undefined;
}
function isString(obj) {
  return typeof obj === "string";
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function getLast(arr) {
  return arr[arr.length - 1];
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop(obj) {
  return obj;
}

// ../../../../node_modules/kysely/dist/esm/operation-node/alter-table-node.js
var AlterTableNode = freeze({
  is(node) {
    return node.kind === "AlterTableNode";
  },
  create(table) {
    return freeze({
      kind: "AlterTableNode",
      table
    });
  },
  cloneWithTableProps(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumnAlteration(node, columnAlteration) {
    return freeze({
      ...node,
      columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/identifier-node.js
var IdentifierNode = freeze({
  is(node) {
    return node.kind === "IdentifierNode";
  },
  create(name) {
    return freeze({
      kind: "IdentifierNode",
      name
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/create-index-node.js
var CreateIndexNode = freeze({
  is(node) {
    return node.kind === "CreateIndexNode";
  },
  create(name) {
    return freeze({
      kind: "CreateIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/create-schema-node.js
var CreateSchemaNode = freeze({
  is(node) {
    return node.kind === "CreateSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "CreateSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(createSchema, params) {
    return freeze({
      ...createSchema,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/create-table-node.js
var ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
var CreateTableNode = freeze({
  is(node) {
    return node.kind === "CreateTableNode";
  },
  create(table) {
    return freeze({
      kind: "CreateTableNode",
      table,
      columns: freeze([])
    });
  },
  cloneWithColumn(createTable, column) {
    return freeze({
      ...createTable,
      columns: freeze([...createTable.columns, column])
    });
  },
  cloneWithConstraint(createTable, constraint) {
    return freeze({
      ...createTable,
      constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
    });
  },
  cloneWithFrontModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWith(createTable, params) {
    return freeze({
      ...createTable,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js
var SchemableIdentifierNode = freeze({
  is(node) {
    return node.kind === "SchemableIdentifierNode";
  },
  create(identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      identifier: IdentifierNode.create(identifier)
    });
  },
  createWithSchema(schema, identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      schema: IdentifierNode.create(schema),
      identifier: IdentifierNode.create(identifier)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-index-node.js
var DropIndexNode = freeze({
  is(node) {
    return node.kind === "DropIndexNode";
  },
  create(name, params) {
    return freeze({
      kind: "DropIndexNode",
      name: SchemableIdentifierNode.create(name),
      ...params
    });
  },
  cloneWith(dropIndex, props) {
    return freeze({
      ...dropIndex,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-schema-node.js
var DropSchemaNode = freeze({
  is(node) {
    return node.kind === "DropSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "DropSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(dropSchema, params) {
    return freeze({
      ...dropSchema,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-table-node.js
var DropTableNode = freeze({
  is(node) {
    return node.kind === "DropTableNode";
  },
  create(table, params) {
    return freeze({
      kind: "DropTableNode",
      table,
      ...params
    });
  },
  cloneWith(dropIndex, params) {
    return freeze({
      ...dropIndex,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/alias-node.js
var AliasNode = freeze({
  is(node) {
    return node.kind === "AliasNode";
  },
  create(node, alias) {
    return freeze({
      kind: "AliasNode",
      node,
      alias
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/table-node.js
var TableNode = freeze({
  is(node) {
    return node.kind === "TableNode";
  },
  create(table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.create(table)
    });
  },
  createWithSchema(schema, table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.createWithSchema(schema, table)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/operation-node-source.js
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction(obj.toOperationNode);
}

// ../../../../node_modules/kysely/dist/esm/expression/expression.js
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString(obj.alias) && isOperationNodeSource(obj);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/select-modifier-node.js
var SelectModifierNode = freeze({
  is(node) {
    return node.kind === "SelectModifierNode";
  },
  create(modifier, of) {
    return freeze({
      kind: "SelectModifierNode",
      modifier,
      of
    });
  },
  createWithExpression(modifier) {
    return freeze({
      kind: "SelectModifierNode",
      rawModifier: modifier
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/and-node.js
var AndNode = freeze({
  is(node) {
    return node.kind === "AndNode";
  },
  create(left, right) {
    return freeze({
      kind: "AndNode",
      left,
      right
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/or-node.js
var OrNode = freeze({
  is(node) {
    return node.kind === "OrNode";
  },
  create(left, right) {
    return freeze({
      kind: "OrNode",
      left,
      right
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/on-node.js
var OnNode = freeze({
  is(node) {
    return node.kind === "OnNode";
  },
  create(filter) {
    return freeze({
      kind: "OnNode",
      on: filter
    });
  },
  cloneWithOperation(onNode, operator, operation) {
    return freeze({
      ...onNode,
      on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/join-node.js
var JoinNode = freeze({
  is(node) {
    return node.kind === "JoinNode";
  },
  create(joinType, table) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: undefined
    });
  },
  createWithOn(joinType, table, on) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: OnNode.create(on)
    });
  },
  cloneWithOn(joinNode, operation) {
    return freeze({
      ...joinNode,
      on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/binary-operation-node.js
var BinaryOperationNode = freeze({
  is(node) {
    return node.kind === "BinaryOperationNode";
  },
  create(leftOperand, operator, rightOperand) {
    return freeze({
      kind: "BinaryOperationNode",
      leftOperand,
      operator,
      rightOperand
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/operator-node.js
var COMPARISON_OPERATORS = [
  "=",
  "==",
  "!=",
  "<>",
  ">",
  ">=",
  "<",
  "<=",
  "in",
  "not in",
  "is",
  "is not",
  "like",
  "not like",
  "match",
  "ilike",
  "not ilike",
  "@>",
  "<@",
  "^@",
  "&&",
  "?",
  "?&",
  "?|",
  "!<",
  "!>",
  "<=>",
  "!~",
  "~",
  "~*",
  "!~*",
  "@@",
  "@@@",
  "!!",
  "<->",
  "regexp",
  "is distinct from",
  "is not distinct from"
];
var ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "&",
  "|",
  "#",
  "<<",
  ">>"
];
var JSON_OPERATORS = ["->", "->>"];
var BINARY_OPERATORS = [
  ...COMPARISON_OPERATORS,
  ...ARITHMETIC_OPERATORS,
  "&&",
  "||"
];
var UNARY_FILTER_OPERATORS = ["exists", "not exists"];
var UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
var OPERATORS = [
  ...BINARY_OPERATORS,
  ...JSON_OPERATORS,
  ...UNARY_OPERATORS,
  "between",
  "between symmetric"
];
var OperatorNode = freeze({
  is(node) {
    return node.kind === "OperatorNode";
  },
  create(operator) {
    return freeze({
      kind: "OperatorNode",
      operator
    });
  }
});
function isJSONOperator(op) {
  return isString(op) && JSON_OPERATORS.includes(op);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/column-node.js
var ColumnNode = freeze({
  is(node) {
    return node.kind === "ColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ColumnNode",
      column: IdentifierNode.create(column)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/select-all-node.js
var SelectAllNode = freeze({
  is(node) {
    return node.kind === "SelectAllNode";
  },
  create() {
    return freeze({
      kind: "SelectAllNode"
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/reference-node.js
var ReferenceNode = freeze({
  is(node) {
    return node.kind === "ReferenceNode";
  },
  create(column, table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column
    });
  },
  createSelectAll(table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column: SelectAllNode.create()
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js
class DynamicReferenceBuilder {
  #dynamicReference;
  get dynamicReference() {
    return this.#dynamicReference;
  }
  get refType() {
    return;
  }
  constructor(reference) {
    this.#dynamicReference = reference;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(this.#dynamicReference);
  }
}
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.dynamicReference);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/order-by-item-node.js
var OrderByItemNode = freeze({
  is(node) {
    return node.kind === "OrderByItemNode";
  },
  create(orderBy, direction) {
    return freeze({
      kind: "OrderByItemNode",
      orderBy,
      direction
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/raw-node.js
var RawNode = freeze({
  is(node) {
    return node.kind === "RawNode";
  },
  create(sqlFragments, parameters) {
    return freeze({
      kind: "RawNode",
      sqlFragments: freeze(sqlFragments),
      parameters: freeze(parameters)
    });
  },
  createWithSql(sql2) {
    return RawNode.create([sql2], []);
  },
  createWithChild(child) {
    return RawNode.create(["", ""], [child]);
  },
  createWithChildren(children) {
    return RawNode.create(new Array(children.length + 1).fill(""), children);
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/collate-node.js
var CollateNode = {
  is(node) {
    return node.kind === "CollateNode";
  },
  create(collation) {
    return freeze({
      kind: "CollateNode",
      collation: IdentifierNode.create(collation)
    });
  }
};

// ../../../../node_modules/kysely/dist/esm/query-builder/order-by-item-builder.js
class OrderByItemBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  desc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("desc")
      })
    });
  }
  asc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("asc")
      })
    });
  }
  nullsLast() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "last" })
    });
  }
  nullsFirst() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "first" })
    });
  }
  collate(collation) {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        collation: CollateNode.create(collation)
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}

// ../../../../node_modules/kysely/dist/esm/util/log-once.js
var LOGGED_MESSAGES = new Set;
function logOnce(message) {
  if (LOGGED_MESSAGES.has(message)) {
    return;
  }
  LOGGED_MESSAGES.add(message);
  console.log(message);
}

// ../../../../node_modules/kysely/dist/esm/parser/order-by-parser.js
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      logOnce("orderBy(array) is deprecated, use multiple orderBy calls instead.");
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(expr, modifiers) {
  const parsedRef = parseOrderByExpression(expr);
  if (OrderByItemNode.is(parsedRef)) {
    if (modifiers) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return parseOrderByWithModifiers(parsedRef, modifiers);
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref, direction] = expr.split(" ");
  if (direction) {
    logOnce("`orderBy('column asc')` is deprecated. Use `orderBy('column', 'asc')` instead.");
    return parseOrderByWithModifiers(parseStringReference(ref), direction);
  }
  return parseStringReference(expr);
}
function parseOrderByWithModifiers(expr, modifiers) {
  if (typeof modifiers === "string") {
    if (!isOrderByDirection(modifiers)) {
      throw new Error(`Invalid order by direction: ${modifiers}`);
    }
    return OrderByItemNode.create(expr, RawNode.createWithSql(modifiers));
  }
  if (isExpression(modifiers)) {
    logOnce("`orderBy(..., expr)` is deprecated. Use `orderBy(..., 'asc')` or `orderBy(..., (ob) => ...)` instead.");
    return OrderByItemNode.create(expr, modifiers.toOperationNode());
  }
  const node = OrderByItemNode.create(expr);
  if (!modifiers) {
    return node;
  }
  return modifiers(new OrderByItemBuilder({ node })).toOperationNode();
}

// ../../../../node_modules/kysely/dist/esm/operation-node/json-reference-node.js
var JSONReferenceNode = freeze({
  is(node) {
    return node.kind === "JSONReferenceNode";
  },
  create(reference, traversal) {
    return freeze({
      kind: "JSONReferenceNode",
      reference,
      traversal
    });
  },
  cloneWithTraversal(node, traversal) {
    return freeze({
      ...node,
      traversal
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js
var JSONOperatorChainNode = freeze({
  is(node) {
    return node.kind === "JSONOperatorChainNode";
  },
  create(operator) {
    return freeze({
      kind: "JSONOperatorChainNode",
      operator,
      values: freeze([])
    });
  },
  cloneWithValue(node, value) {
    return freeze({
      ...node,
      values: freeze([...node.values, value])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/json-path-node.js
var JSONPathNode = freeze({
  is(node) {
    return node.kind === "JSONPathNode";
  },
  create(inOperator) {
    return freeze({
      kind: "JSONPathNode",
      inOperator,
      pathLegs: freeze([])
    });
  },
  cloneWithLeg(jsonPathNode, pathLeg) {
    return freeze({
      ...jsonPathNode,
      pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/reference-parser.js
function parseSimpleReferenceExpression(exp) {
  if (isString(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
  const referenceNode = parseStringReference(ref);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
  const COLUMN_SEPARATOR = ".";
  if (!ref.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref));
  }
  const parts = ref.split(COLUMN_SEPARATOR).map(trim);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
  const ALIAS_SEPARATOR = " as ";
  if (ref.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim(str) {
  return str.trim();
}

// ../../../../node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js
var PrimitiveValueListNode = freeze({
  is(node) {
    return node.kind === "PrimitiveValueListNode";
  },
  create(values) {
    return freeze({
      kind: "PrimitiveValueListNode",
      values: freeze([...values])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/value-list-node.js
var ValueListNode = freeze({
  is(node) {
    return node.kind === "ValueListNode";
  },
  create(values) {
    return freeze({
      kind: "ValueListNode",
      values: freeze(values)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/value-node.js
var ValueNode = freeze({
  is(node) {
    return node.kind === "ValueNode";
  },
  create(value) {
    return freeze({
      kind: "ValueNode",
      value
    });
  },
  createImmediate(value) {
    return freeze({
      kind: "ValueNode",
      value,
      immediate: true
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/value-parser.js
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/parens-node.js
var ParensNode = freeze({
  is(node) {
    return node.kind === "ParensNode";
  },
  create(node) {
    return freeze({
      kind: "ParensNode",
      node
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/binary-operation-parser.js
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v]) => !isUndefined(v)).map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? "is" : "=", v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i = 1;i < list.length; ++i) {
    node = combine(node, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
  if (isString(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}

// ../../../../node_modules/kysely/dist/esm/operation-node/order-by-node.js
var OrderByNode = freeze({
  is(node) {
    return node.kind === "OrderByNode";
  },
  create(items) {
    return freeze({
      kind: "OrderByNode",
      items: freeze([...items])
    });
  },
  cloneWithItems(orderBy, items) {
    return freeze({
      ...orderBy,
      items: freeze([...orderBy.items, ...items])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/partition-by-node.js
var PartitionByNode = freeze({
  is(node) {
    return node.kind === "PartitionByNode";
  },
  create(items) {
    return freeze({
      kind: "PartitionByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(partitionBy, items) {
    return freeze({
      ...partitionBy,
      items: freeze([...partitionBy.items, ...items])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/over-node.js
var OverNode = freeze({
  is(node) {
    return node.kind === "OverNode";
  },
  create() {
    return freeze({
      kind: "OverNode"
    });
  },
  cloneWithOrderByItems(overNode, items) {
    return freeze({
      ...overNode,
      orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithPartitionByItems(overNode, items) {
    return freeze({
      ...overNode,
      partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/from-node.js
var FromNode = freeze({
  is(node) {
    return node.kind === "FromNode";
  },
  create(froms) {
    return freeze({
      kind: "FromNode",
      froms: freeze(froms)
    });
  },
  cloneWithFroms(from, froms) {
    return freeze({
      ...from,
      froms: freeze([...from.froms, ...froms])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/group-by-node.js
var GroupByNode = freeze({
  is(node) {
    return node.kind === "GroupByNode";
  },
  create(items) {
    return freeze({
      kind: "GroupByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(groupBy, items) {
    return freeze({
      ...groupBy,
      items: freeze([...groupBy.items, ...items])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/having-node.js
var HavingNode = freeze({
  is(node) {
    return node.kind === "HavingNode";
  },
  create(filter) {
    return freeze({
      kind: "HavingNode",
      having: filter
    });
  },
  cloneWithOperation(havingNode, operator, operation) {
    return freeze({
      ...havingNode,
      having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/insert-query-node.js
var InsertQueryNode = freeze({
  is(node) {
    return node.kind === "InsertQueryNode";
  },
  create(into, withNode, replace) {
    return freeze({
      kind: "InsertQueryNode",
      into,
      ...withNode && { with: withNode },
      replace
    });
  },
  createWithoutInto() {
    return freeze({
      kind: "InsertQueryNode"
    });
  },
  cloneWith(insertQuery, props) {
    return freeze({
      ...insertQuery,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/list-node.js
var ListNode = freeze({
  is(node) {
    return node.kind === "ListNode";
  },
  create(items) {
    return freeze({
      kind: "ListNode",
      items: freeze(items)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/update-query-node.js
var UpdateQueryNode = freeze({
  is(node) {
    return node.kind === "UpdateQueryNode";
  },
  create(tables, withNode) {
    return freeze({
      kind: "UpdateQueryNode",
      table: tables.length === 1 ? tables[0] : ListNode.create(tables),
      ...withNode && { with: withNode }
    });
  },
  createWithoutTable() {
    return freeze({
      kind: "UpdateQueryNode"
    });
  },
  cloneWithFromItems(updateQuery, fromItems) {
    return freeze({
      ...updateQuery,
      from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
    });
  },
  cloneWithUpdates(updateQuery, updates) {
    return freeze({
      ...updateQuery,
      updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
    });
  },
  cloneWithLimit(updateQuery, limit) {
    return freeze({
      ...updateQuery,
      limit
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/using-node.js
var UsingNode = freeze({
  is(node) {
    return node.kind === "UsingNode";
  },
  create(tables) {
    return freeze({
      kind: "UsingNode",
      tables: freeze(tables)
    });
  },
  cloneWithTables(using, tables) {
    return freeze({
      ...using,
      tables: freeze([...using.tables, ...tables])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/delete-query-node.js
var DeleteQueryNode = freeze({
  is(node) {
    return node.kind === "DeleteQueryNode";
  },
  create(fromItems, withNode) {
    return freeze({
      kind: "DeleteQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
  cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
  cloneWithLimit(deleteNode, limit) {
    return freeze({
      ...deleteNode,
      limit
    });
  },
  cloneWithoutLimit(deleteNode) {
    return freeze({
      ...deleteNode,
      limit: undefined
    });
  },
  cloneWithUsing(deleteNode, tables) {
    return freeze({
      ...deleteNode,
      using: deleteNode.using !== undefined ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/where-node.js
var WhereNode = freeze({
  is(node) {
    return node.kind === "WhereNode";
  },
  create(filter) {
    return freeze({
      kind: "WhereNode",
      where: filter
    });
  },
  cloneWithOperation(whereNode, operator, operation) {
    return freeze({
      ...whereNode,
      where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/returning-node.js
var ReturningNode = freeze({
  is(node) {
    return node.kind === "ReturningNode";
  },
  create(selections) {
    return freeze({
      kind: "ReturningNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(returning, selections) {
    return freeze({
      ...returning,
      selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/explain-node.js
var ExplainNode = freeze({
  is(node) {
    return node.kind === "ExplainNode";
  },
  create(format, options) {
    return freeze({
      kind: "ExplainNode",
      format,
      options
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/when-node.js
var WhenNode = freeze({
  is(node) {
    return node.kind === "WhenNode";
  },
  create(condition) {
    return freeze({
      kind: "WhenNode",
      condition
    });
  },
  cloneWithResult(whenNode, result) {
    return freeze({
      ...whenNode,
      result
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/merge-query-node.js
var MergeQueryNode = freeze({
  is(node) {
    return node.kind === "MergeQueryNode";
  },
  create(into, withNode) {
    return freeze({
      kind: "MergeQueryNode",
      into,
      ...withNode && { with: withNode }
    });
  },
  cloneWithUsing(mergeNode, using) {
    return freeze({
      ...mergeNode,
      using
    });
  },
  cloneWithWhen(mergeNode, when) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
    });
  },
  cloneWithThen(mergeNode, then) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([
        ...mergeNode.whens.slice(0, -1),
        WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
      ]) : undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/output-node.js
var OutputNode = freeze({
  is(node) {
    return node.kind === "OutputNode";
  },
  create(selections) {
    return freeze({
      kind: "OutputNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(output, selections) {
    return freeze({
      ...output,
      selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/query-node.js
var QueryNode = freeze({
  is(node) {
    return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithWhere(node, operation) {
    return freeze({
      ...node,
      where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithJoin(node, join) {
    return freeze({
      ...node,
      joins: node.joins ? freeze([...node.joins, join]) : freeze([join])
    });
  },
  cloneWithReturning(node, selections) {
    return freeze({
      ...node,
      returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
    });
  },
  cloneWithoutReturning(node) {
    return freeze({
      ...node,
      returning: undefined
    });
  },
  cloneWithoutWhere(node) {
    return freeze({
      ...node,
      where: undefined
    });
  },
  cloneWithExplain(node, format, options) {
    return freeze({
      ...node,
      explain: ExplainNode.create(format, options?.toOperationNode())
    });
  },
  cloneWithTop(node, top) {
    return freeze({
      ...node,
      top
    });
  },
  cloneWithOutput(node, selections) {
    return freeze({
      ...node,
      output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
    });
  },
  cloneWithOrderByItems(node, items) {
    return freeze({
      ...node,
      orderBy: node.orderBy ? OrderByNode.cloneWithItems(node.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithoutOrderBy(node) {
    return freeze({
      ...node,
      orderBy: undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/select-query-node.js
var SelectQueryNode = freeze({
  is(node) {
    return node.kind === "SelectQueryNode";
  },
  create(withNode) {
    return freeze({
      kind: "SelectQueryNode",
      ...withNode && { with: withNode }
    });
  },
  createFrom(fromItems, withNode) {
    return freeze({
      kind: "SelectQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithSelections(select, selections) {
    return freeze({
      ...select,
      selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
    });
  },
  cloneWithDistinctOn(select, expressions) {
    return freeze({
      ...select,
      distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
    });
  },
  cloneWithFrontModifier(select, modifier) {
    return freeze({
      ...select,
      frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
  cloneWithGroupByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
    });
  },
  cloneWithLimit(selectNode, limit) {
    return freeze({
      ...selectNode,
      limit
    });
  },
  cloneWithOffset(selectNode, offset) {
    return freeze({
      ...selectNode,
      offset
    });
  },
  cloneWithFetch(selectNode, fetch) {
    return freeze({
      ...selectNode,
      fetch
    });
  },
  cloneWithHaving(selectNode, operation) {
    return freeze({
      ...selectNode,
      having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
    });
  },
  cloneWithSetOperations(selectNode, setOperations) {
    return freeze({
      ...selectNode,
      setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
    });
  },
  cloneWithoutSelections(select) {
    return freeze({
      ...select,
      selections: []
    });
  },
  cloneWithoutLimit(select) {
    return freeze({
      ...select,
      limit: undefined
    });
  },
  cloneWithoutOffset(select) {
    return freeze({
      ...select,
      offset: undefined
    });
  },
  cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
  cloneWithoutGroupBy(select) {
    return freeze({
      ...select,
      groupBy: undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/join-builder.js
class JoinBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(...args) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  onRef(lhs, op, rhs) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  onTrue() {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.joinNode;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js
var PartitionByItemNode = freeze({
  is(node) {
    return node.kind === "PartitionByItemNode";
  },
  create(partitionBy) {
    return freeze({
      kind: "PartitionByItemNode",
      partitionBy
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/partition-by-parser.js
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}

// ../../../../node_modules/kysely/dist/esm/query-builder/over-builder.js
class OverBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  orderBy(...args) {
    return new OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new OverBuilder({
      overNode: QueryNode.cloneWithoutOrderBy(this.#props.overNode)
    });
  }
  partitionBy(partitionBy) {
    return new OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.overNode;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/selection-node.js
var SelectionNode = freeze({
  is(node) {
    return node.kind === "SelectionNode";
  },
  create(selection) {
    return freeze({
      kind: "SelectionNode",
      selection
    });
  },
  createSelectAll() {
    return freeze({
      kind: "SelectionNode",
      selection: SelectAllNode.create()
    });
  },
  createSelectAllFromTable(table) {
    return freeze({
      kind: "SelectionNode",
      selection: ReferenceNode.createSelectAll(table)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/select-parser.js
function parseSelectArg(selection) {
  if (isFunction(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/values-node.js
var ValuesNode = freeze({
  is(node) {
    return node.kind === "ValuesNode";
  },
  create(values) {
    return freeze({
      kind: "ValuesNode",
      values: freeze(values)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js
var DefaultInsertValueNode = freeze({
  is(node) {
    return node.kind === "DefaultInsertValueNode";
  },
  create() {
    return freeze({
      kind: "DefaultInsertValueNode"
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/insert-values-parser.js
function parseInsertExpression(arg) {
  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = new Map;
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== undefined) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/column-update-node.js
var ColumnUpdateNode = freeze({
  is(node) {
    return node.kind === "ColumnUpdateNode";
  },
  create(column, value) {
    return freeze({
      kind: "ColumnUpdateNode",
      column,
      value
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/update-set-parser.js
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== undefined).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}

// ../../../../node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js
var OnDuplicateKeyNode = freeze({
  is(node) {
    return node.kind === "OnDuplicateKeyNode";
  },
  create(updates) {
    return freeze({
      kind: "OnDuplicateKeyNode",
      updates
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/insert-result.js
class InsertResult {
  insertId;
  numInsertedOrUpdatedRows;
  constructor(insertId, numInsertedOrUpdatedRows) {
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/no-result-error.js
class NoResultError extends Error {
  node;
  constructor(node) {
    super("no result");
    this.node = node;
  }
}
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}

// ../../../../node_modules/kysely/dist/esm/operation-node/on-conflict-node.js
var OnConflictNode = freeze({
  is(node) {
    return node.kind === "OnConflictNode";
  },
  create() {
    return freeze({
      kind: "OnConflictNode"
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithIndexWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithIndexOrWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateOrWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithoutIndexWhere(node) {
    return freeze({
      ...node,
      indexWhere: undefined
    });
  },
  cloneWithoutUpdateWhere(node) {
    return freeze({
      ...node,
      updateWhere: undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
class OnConflictBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  constraint(constraintName) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  expression(expression) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
    });
  }
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        doNothing: true
      })
    });
  }
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  $call(func) {
    return func(this);
  }
}

class OnConflictDoNothingBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}

class OnConflictUpdateBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/top-node.js
var TopNode = freeze({
  is(node) {
    return node.kind === "TopNode";
  },
  create(expression, modifiers) {
    return freeze({
      kind: "TopNode",
      expression,
      modifiers
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/top-parser.js
function parseTop(expression, modifiers) {
  if (!isNumber(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}

// ../../../../node_modules/kysely/dist/esm/operation-node/or-action-node.js
var OrActionNode = freeze({
  is(node) {
    return node.kind === "OrActionNode";
  },
  create(action) {
    return freeze({
      kind: "OrActionNode",
      action
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
class InsertQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  values(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns,
        values
      })
    });
  }
  columns(columns) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  expression(expression) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  defaultValues() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        defaultValues: true
      })
    });
  }
  modifyEnd(modifier) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  ignore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  orIgnore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  orAbort() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("abort")
      })
    });
  }
  orFail() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("fail")
      })
    });
  }
  orReplace() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("replace")
      })
    });
  }
  orRollback() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("rollback")
      })
    });
  }
  top(expression, modifiers) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  onConflict(callback) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  onDuplicateKeyUpdate(update) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  clearReturning() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new InsertQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new InsertQueryBuilder(this.#props);
  }
  $narrowType() {
    return new InsertQueryBuilder(this.#props);
  }
  $assertType() {
    return new InsertQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new InsertQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new InsertResult(result.insertId, result.numAffectedRows ?? BigInt(0))
    ];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/delete-result.js
class DeleteResult {
  numDeletedRows;
  constructor(numDeletedRows) {
    this.numDeletedRows = numDeletedRows;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/limit-node.js
var LimitNode = freeze({
  is(node) {
    return node.kind === "LimitNode";
  },
  create(limit) {
    return freeze({
      kind: "LimitNode",
      limit
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
class DeleteQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  top(expression, modifiers) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  returning(selection) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  clearReturning() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  orderBy(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  limit(limit) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  modifyEnd(modifier) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new DeleteQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new DeleteQueryBuilder(this.#props);
  }
  $narrowType() {
    return new DeleteQueryBuilder(this.#props);
  }
  $assertType() {
    return new DeleteQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new DeleteQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new DeleteResult(result.numAffectedRows ?? BigInt(0))];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/update-result.js
class UpdateResult {
  numUpdatedRows;
  numChangedRows;
  constructor(numUpdatedRows, numChangedRows) {
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/update-query-builder.js
class UpdateQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  top(expression, modifiers) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  limit(limit) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  set(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  modifyEnd(modifier) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  clearReturning() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new UpdateQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new UpdateQueryBuilder(this.#props);
  }
  $narrowType() {
    return new UpdateQueryBuilder(this.#props);
  }
  $assertType() {
    return new UpdateQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new UpdateQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new UpdateResult(result.numAffectedRows ?? BigInt(0), result.numChangedRows)
    ];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js
var CommonTableExpressionNameNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNameNode";
  },
  create(tableName, columnNames) {
    return freeze({
      kind: "CommonTableExpressionNameNode",
      table: TableNode.create(tableName),
      columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js
var CommonTableExpressionNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNode";
  },
  create(name, expression) {
    return freeze({
      kind: "CommonTableExpressionNode",
      name,
      expression
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/cte-builder.js
class CTEBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  notMaterialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}

// ../../../../node_modules/kysely/dist/esm/parser/with-parser.js
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/with-node.js
var WithNode = freeze({
  is(node) {
    return node.kind === "WithNode";
  },
  create(expression, params) {
    return freeze({
      kind: "WithNode",
      expressions: freeze([expression]),
      ...params
    });
  },
  cloneWithExpression(withNode, expression) {
    return freeze({
      ...withNode,
      expressions: freeze([...withNode.expressions, expression])
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/util/random-string.js
var CHARS = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
function randomString(length) {
  let chars = "";
  for (let i = 0;i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}

// ../../../../node_modules/kysely/dist/esm/util/query-id.js
function createQueryId() {
  return new LazyQueryId;
}

class LazyQueryId {
  #queryId;
  get queryId() {
    if (this.#queryId === undefined) {
      this.#queryId = randomString(8);
    }
    return this.#queryId;
  }
}

// ../../../../node_modules/kysely/dist/esm/util/require-all-props.js
function requireAllProps(obj) {
  return obj;
}

// ../../../../node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
class OperationNodeTransformer {
  nodeStack = [];
  #transformers = freeze({
    AliasNode: this.transformAlias.bind(this),
    ColumnNode: this.transformColumn.bind(this),
    IdentifierNode: this.transformIdentifier.bind(this),
    SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
    RawNode: this.transformRaw.bind(this),
    ReferenceNode: this.transformReference.bind(this),
    SelectQueryNode: this.transformSelectQuery.bind(this),
    SelectionNode: this.transformSelection.bind(this),
    TableNode: this.transformTable.bind(this),
    FromNode: this.transformFrom.bind(this),
    SelectAllNode: this.transformSelectAll.bind(this),
    AndNode: this.transformAnd.bind(this),
    OrNode: this.transformOr.bind(this),
    ValueNode: this.transformValue.bind(this),
    ValueListNode: this.transformValueList.bind(this),
    PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
    ParensNode: this.transformParens.bind(this),
    JoinNode: this.transformJoin.bind(this),
    OperatorNode: this.transformOperator.bind(this),
    WhereNode: this.transformWhere.bind(this),
    InsertQueryNode: this.transformInsertQuery.bind(this),
    DeleteQueryNode: this.transformDeleteQuery.bind(this),
    ReturningNode: this.transformReturning.bind(this),
    CreateTableNode: this.transformCreateTable.bind(this),
    AddColumnNode: this.transformAddColumn.bind(this),
    ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
    DropTableNode: this.transformDropTable.bind(this),
    DataTypeNode: this.transformDataType.bind(this),
    OrderByNode: this.transformOrderBy.bind(this),
    OrderByItemNode: this.transformOrderByItem.bind(this),
    GroupByNode: this.transformGroupBy.bind(this),
    GroupByItemNode: this.transformGroupByItem.bind(this),
    UpdateQueryNode: this.transformUpdateQuery.bind(this),
    ColumnUpdateNode: this.transformColumnUpdate.bind(this),
    LimitNode: this.transformLimit.bind(this),
    OffsetNode: this.transformOffset.bind(this),
    OnConflictNode: this.transformOnConflict.bind(this),
    OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
    CreateIndexNode: this.transformCreateIndex.bind(this),
    DropIndexNode: this.transformDropIndex.bind(this),
    ListNode: this.transformList.bind(this),
    PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
    ReferencesNode: this.transformReferences.bind(this),
    CheckConstraintNode: this.transformCheckConstraint.bind(this),
    WithNode: this.transformWith.bind(this),
    CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
    HavingNode: this.transformHaving.bind(this),
    CreateSchemaNode: this.transformCreateSchema.bind(this),
    DropSchemaNode: this.transformDropSchema.bind(this),
    AlterTableNode: this.transformAlterTable.bind(this),
    DropColumnNode: this.transformDropColumn.bind(this),
    RenameColumnNode: this.transformRenameColumn.bind(this),
    AlterColumnNode: this.transformAlterColumn.bind(this),
    ModifyColumnNode: this.transformModifyColumn.bind(this),
    AddConstraintNode: this.transformAddConstraint.bind(this),
    DropConstraintNode: this.transformDropConstraint.bind(this),
    RenameConstraintNode: this.transformRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
    CreateViewNode: this.transformCreateView.bind(this),
    RefreshMaterializedViewNode: this.transformRefreshMaterializedView.bind(this),
    DropViewNode: this.transformDropView.bind(this),
    GeneratedNode: this.transformGenerated.bind(this),
    DefaultValueNode: this.transformDefaultValue.bind(this),
    OnNode: this.transformOn.bind(this),
    ValuesNode: this.transformValues.bind(this),
    SelectModifierNode: this.transformSelectModifier.bind(this),
    CreateTypeNode: this.transformCreateType.bind(this),
    DropTypeNode: this.transformDropType.bind(this),
    ExplainNode: this.transformExplain.bind(this),
    DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.transformAggregateFunction.bind(this),
    OverNode: this.transformOver.bind(this),
    PartitionByNode: this.transformPartitionBy.bind(this),
    PartitionByItemNode: this.transformPartitionByItem.bind(this),
    SetOperationNode: this.transformSetOperation.bind(this),
    BinaryOperationNode: this.transformBinaryOperation.bind(this),
    UnaryOperationNode: this.transformUnaryOperation.bind(this),
    UsingNode: this.transformUsing.bind(this),
    FunctionNode: this.transformFunction.bind(this),
    CaseNode: this.transformCase.bind(this),
    WhenNode: this.transformWhen.bind(this),
    JSONReferenceNode: this.transformJSONReference.bind(this),
    JSONPathNode: this.transformJSONPath.bind(this),
    JSONPathLegNode: this.transformJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
    TupleNode: this.transformTuple.bind(this),
    MergeQueryNode: this.transformMergeQuery.bind(this),
    MatchedNode: this.transformMatched.bind(this),
    AddIndexNode: this.transformAddIndex.bind(this),
    CastNode: this.transformCast.bind(this),
    FetchNode: this.transformFetch.bind(this),
    TopNode: this.transformTop.bind(this),
    OutputNode: this.transformOutput.bind(this),
    OrActionNode: this.transformOrAction.bind(this),
    CollateNode: this.transformCollate.bind(this)
  });
  transformNode(node, queryId) {
    if (!node) {
      return node;
    }
    this.nodeStack.push(node);
    const out = this.transformNodeImpl(node, queryId);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node, queryId) {
    return this.#transformers[node.kind](node, queryId);
  }
  transformNodeList(list, queryId) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node) => this.transformNode(node, queryId)));
  }
  transformSelectQuery(node, queryId) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node.from, queryId),
      selections: this.transformNodeList(node.selections, queryId),
      distinctOn: this.transformNodeList(node.distinctOn, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      groupBy: this.transformNode(node.groupBy, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      where: this.transformNode(node.where, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      limit: this.transformNode(node.limit, queryId),
      offset: this.transformNode(node.offset, queryId),
      with: this.transformNode(node.with, queryId),
      having: this.transformNode(node.having, queryId),
      explain: this.transformNode(node.explain, queryId),
      setOperations: this.transformNodeList(node.setOperations, queryId),
      fetch: this.transformNode(node.fetch, queryId),
      top: this.transformNode(node.top, queryId)
    });
  }
  transformSelection(node, queryId) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node.selection, queryId)
    });
  }
  transformColumn(node, queryId) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAlias(node, queryId) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node.node, queryId),
      alias: this.transformNode(node.alias, queryId)
    });
  }
  transformTable(node, queryId) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node.table, queryId)
    });
  }
  transformFrom(node, queryId) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node.froms, queryId)
    });
  }
  transformReference(node, queryId) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node.column, queryId),
      table: this.transformNode(node.table, queryId)
    });
  }
  transformAnd(node, queryId) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformOr(node, queryId) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformValueList(node, queryId) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformParens(node, queryId) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node.node, queryId)
    });
  }
  transformJoin(node, queryId) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node.joinType,
      table: this.transformNode(node.table, queryId),
      on: this.transformNode(node.on, queryId)
    });
  }
  transformRaw(node, queryId) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node.sqlFragments]),
      parameters: this.transformNodeList(node.parameters, queryId)
    });
  }
  transformWhere(node, queryId) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node.where, queryId)
    });
  }
  transformInsertQuery(node, queryId) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node.into, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      values: this.transformNode(node.values, queryId),
      returning: this.transformNode(node.returning, queryId),
      onConflict: this.transformNode(node.onConflict, queryId),
      onDuplicateKey: this.transformNode(node.onDuplicateKey, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      ignore: node.ignore,
      orAction: this.transformNode(node.orAction, queryId),
      replace: node.replace,
      explain: this.transformNode(node.explain, queryId),
      defaultValues: node.defaultValues,
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformValues(node, queryId) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformDeleteQuery(node, queryId) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node.from, queryId),
      using: this.transformNode(node.using, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      limit: this.transformNode(node.limit, queryId),
      explain: this.transformNode(node.explain, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformReturning(node, queryId) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformCreateTable(node, queryId) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      constraints: this.transformNodeList(node.constraints, queryId),
      temporary: node.temporary,
      ifNotExists: node.ifNotExists,
      onCommit: node.onCommit,
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      selectQuery: this.transformNode(node.selectQuery, queryId)
    });
  }
  transformColumnDefinition(node, queryId) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      references: this.transformNode(node.references, queryId),
      primaryKey: node.primaryKey,
      autoIncrement: node.autoIncrement,
      unique: node.unique,
      notNull: node.notNull,
      unsigned: node.unsigned,
      defaultTo: this.transformNode(node.defaultTo, queryId),
      check: this.transformNode(node.check, queryId),
      generated: this.transformNode(node.generated, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      identity: node.identity,
      ifNotExists: node.ifNotExists
    });
  }
  transformAddColumn(node, queryId) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformDropTable(node, queryId) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformOrderBy(node, queryId) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformOrderByItem(node, queryId) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      direction: this.transformNode(node.direction, queryId),
      collation: this.transformNode(node.collation, queryId),
      nulls: node.nulls
    });
  }
  transformGroupBy(node, queryId) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformGroupByItem(node, queryId) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node.groupBy, queryId)
    });
  }
  transformUpdateQuery(node, queryId) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node.table, queryId),
      from: this.transformNode(node.from, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      explain: this.transformNode(node.explain, queryId),
      limit: this.transformNode(node.limit, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId),
      orderBy: this.transformNode(node.orderBy, queryId)
    });
  }
  transformColumnUpdate(node, queryId) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node.column, queryId),
      value: this.transformNode(node.value, queryId)
    });
  }
  transformLimit(node, queryId) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node.limit, queryId)
    });
  }
  transformOffset(node, queryId) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node.offset, queryId)
    });
  }
  transformOnConflict(node, queryId) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node.columns, queryId),
      constraint: this.transformNode(node.constraint, queryId),
      indexExpression: this.transformNode(node.indexExpression, queryId),
      indexWhere: this.transformNode(node.indexWhere, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      updateWhere: this.transformNode(node.updateWhere, queryId),
      doNothing: node.doNothing
    });
  }
  transformOnDuplicateKey(node, queryId) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node.updates, queryId)
    });
  }
  transformCreateIndex(node, queryId) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists,
      where: this.transformNode(node.where, queryId),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformList(node, queryId) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformDropIndex(node, queryId) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformPrimaryKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformUniqueConstraint(node, queryId) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformForeignKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      references: this.transformNode(node.references, queryId),
      name: this.transformNode(node.name, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformSetOperation(node, queryId) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node.operator,
      expression: this.transformNode(node.expression, queryId),
      all: node.all
    });
  }
  transformReferences(node, queryId) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformCheckConstraint(node, queryId) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node.expression, queryId),
      name: this.transformNode(node.name, queryId)
    });
  }
  transformWith(node, queryId) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node.expressions, queryId),
      recursive: node.recursive
    });
  }
  transformCommonTableExpression(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node.name, queryId),
      materialized: node.materialized,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformCommonTableExpressionName(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId)
    });
  }
  transformHaving(node, queryId) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node.having, queryId)
    });
  }
  transformCreateSchema(node, queryId) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformDropSchema(node, queryId) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformAlterTable(node, queryId) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node.table, queryId),
      renameTo: this.transformNode(node.renameTo, queryId),
      setSchema: this.transformNode(node.setSchema, queryId),
      columnAlterations: this.transformNodeList(node.columnAlterations, queryId),
      addConstraint: this.transformNode(node.addConstraint, queryId),
      dropConstraint: this.transformNode(node.dropConstraint, queryId),
      renameConstraint: this.transformNode(node.renameConstraint, queryId),
      addIndex: this.transformNode(node.addIndex, queryId),
      dropIndex: this.transformNode(node.dropIndex, queryId)
    });
  }
  transformDropColumn(node, queryId) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformRenameColumn(node, queryId) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node.column, queryId),
      renameTo: this.transformNode(node.renameTo, queryId)
    });
  }
  transformAlterColumn(node, queryId) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      dataTypeExpression: this.transformNode(node.dataTypeExpression, queryId),
      setDefault: this.transformNode(node.setDefault, queryId),
      dropDefault: node.dropDefault,
      setNotNull: node.setNotNull,
      dropNotNull: node.dropNotNull
    });
  }
  transformModifyColumn(node, queryId) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAddConstraint(node, queryId) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node.constraint, queryId)
    });
  }
  transformDropConstraint(node, queryId) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node.constraintName, queryId),
      ifExists: node.ifExists,
      modifier: node.modifier
    });
  }
  transformRenameConstraint(node, queryId) {
    return requireAllProps({
      kind: "RenameConstraintNode",
      oldName: this.transformNode(node.oldName, queryId),
      newName: this.transformNode(node.newName, queryId)
    });
  }
  transformCreateView(node, queryId) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node.name, queryId),
      temporary: node.temporary,
      orReplace: node.orReplace,
      ifNotExists: node.ifNotExists,
      materialized: node.materialized,
      columns: this.transformNodeList(node.columns, queryId),
      as: this.transformNode(node.as, queryId)
    });
  }
  transformRefreshMaterializedView(node, queryId) {
    return requireAllProps({
      kind: "RefreshMaterializedViewNode",
      name: this.transformNode(node.name, queryId),
      concurrently: node.concurrently,
      withNoData: node.withNoData
    });
  }
  transformDropView(node, queryId) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists,
      materialized: node.materialized,
      cascade: node.cascade
    });
  }
  transformGenerated(node, queryId) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node.byDefault,
      always: node.always,
      identity: node.identity,
      stored: node.stored,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformDefaultValue(node, queryId) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node.defaultValue, queryId)
    });
  }
  transformOn(node, queryId) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node.on, queryId)
    });
  }
  transformSelectModifier(node, queryId) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node.modifier,
      rawModifier: this.transformNode(node.rawModifier, queryId),
      of: this.transformNodeList(node.of, queryId)
    });
  }
  transformCreateType(node, queryId) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node.name, queryId),
      enum: this.transformNode(node.enum, queryId)
    });
  }
  transformDropType(node, queryId) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists
    });
  }
  transformExplain(node, queryId) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node.format,
      options: this.transformNode(node.options, queryId)
    });
  }
  transformSchemableIdentifier(node, queryId) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node.schema, queryId),
      identifier: this.transformNode(node.identifier, queryId)
    });
  }
  transformAggregateFunction(node, queryId) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      func: node.func,
      aggregated: this.transformNodeList(node.aggregated, queryId),
      distinct: node.distinct,
      orderBy: this.transformNode(node.orderBy, queryId),
      withinGroup: this.transformNode(node.withinGroup, queryId),
      filter: this.transformNode(node.filter, queryId),
      over: this.transformNode(node.over, queryId)
    });
  }
  transformOver(node, queryId) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformPartitionBy(node, queryId) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformPartitionByItem(node, queryId) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformBinaryOperation(node, queryId) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node.leftOperand, queryId),
      operator: this.transformNode(node.operator, queryId),
      rightOperand: this.transformNode(node.rightOperand, queryId)
    });
  }
  transformUnaryOperation(node, queryId) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node.operator, queryId),
      operand: this.transformNode(node.operand, queryId)
    });
  }
  transformUsing(node, queryId) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node.tables, queryId)
    });
  }
  transformFunction(node, queryId) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node.func,
      arguments: this.transformNodeList(node.arguments, queryId)
    });
  }
  transformCase(node, queryId) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node.value, queryId),
      when: this.transformNodeList(node.when, queryId),
      else: this.transformNode(node.else, queryId),
      isStatement: node.isStatement
    });
  }
  transformWhen(node, queryId) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node.condition, queryId),
      result: this.transformNode(node.result, queryId)
    });
  }
  transformJSONReference(node, queryId) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node.reference, queryId),
      traversal: this.transformNode(node.traversal, queryId)
    });
  }
  transformJSONPath(node, queryId) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node.inOperator, queryId),
      pathLegs: this.transformNodeList(node.pathLegs, queryId)
    });
  }
  transformJSONPathLeg(node, _queryId) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node.type,
      value: node.value
    });
  }
  transformJSONOperatorChain(node, queryId) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node.operator, queryId),
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformTuple(node, queryId) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformMergeQuery(node, queryId) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node.into, queryId),
      using: this.transformNode(node.using, queryId),
      whens: this.transformNodeList(node.whens, queryId),
      with: this.transformNode(node.with, queryId),
      top: this.transformNode(node.top, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      output: this.transformNode(node.output, queryId),
      returning: this.transformNode(node.returning, queryId)
    });
  }
  transformMatched(node, _queryId) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node.not,
      bySource: node.bySource
    });
  }
  transformAddIndex(node, queryId) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node.name, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformCast(node, queryId) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node.expression, queryId),
      dataType: this.transformNode(node.dataType, queryId)
    });
  }
  transformFetch(node, queryId) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node.rowCount, queryId),
      modifier: node.modifier
    });
  }
  transformTop(node, _queryId) {
    return requireAllProps({
      kind: "TopNode",
      expression: node.expression,
      modifiers: node.modifiers
    });
  }
  transformOutput(node, queryId) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformDataType(node, _queryId) {
    return node;
  }
  transformSelectAll(node, _queryId) {
    return node;
  }
  transformIdentifier(node, _queryId) {
    return node;
  }
  transformValue(node, _queryId) {
    return node;
  }
  transformPrimitiveValueList(node, _queryId) {
    return node;
  }
  transformOperator(node, _queryId) {
    return node;
  }
  transformDefaultInsertValue(node, _queryId) {
    return node;
  }
  transformOrAction(node, _queryId) {
    return node;
  }
  transformCollate(node, _queryId) {
    return node;
  }
}

// ../../../../node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
var ROOT_OPERATION_NODES = freeze({
  AlterTableNode: true,
  CreateIndexNode: true,
  CreateSchemaNode: true,
  CreateTableNode: true,
  CreateTypeNode: true,
  CreateViewNode: true,
  RefreshMaterializedViewNode: true,
  DeleteQueryNode: true,
  DropIndexNode: true,
  DropSchemaNode: true,
  DropTableNode: true,
  DropTypeNode: true,
  DropViewNode: true,
  InsertQueryNode: true,
  RawNode: true,
  SelectQueryNode: true,
  UpdateQueryNode: true,
  MergeQueryNode: true
});
var SCHEMALESS_FUNCTIONS = {
  json_agg: true,
  to_json: true
};

class WithSchemaTransformer extends OperationNodeTransformer {
  #schema;
  #schemableIds = new Set;
  #ctes = new Set;
  constructor(schema) {
    super();
    this.#schema = schema;
  }
  transformNodeImpl(node, queryId) {
    if (!this.#isRootOperationNode(node)) {
      return super.transformNodeImpl(node, queryId);
    }
    const ctes = this.#collectCTEs(node);
    for (const cte of ctes) {
      this.#ctes.add(cte);
    }
    const tables = this.#collectSchemableIds(node);
    for (const table of tables) {
      this.#schemableIds.add(table);
    }
    const transformed = super.transformNodeImpl(node, queryId);
    for (const table of tables) {
      this.#schemableIds.delete(table);
    }
    for (const cte of ctes) {
      this.#ctes.delete(cte);
    }
    return transformed;
  }
  transformSchemableIdentifier(node, queryId) {
    const transformed = super.transformSchemableIdentifier(node, queryId);
    if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
      return transformed;
    }
    return {
      ...transformed,
      schema: IdentifierNode.create(this.#schema)
    };
  }
  transformReferences(node, queryId) {
    const transformed = super.transformReferences(node, queryId);
    if (transformed.table.table.schema) {
      return transformed;
    }
    return {
      ...transformed,
      table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
    };
  }
  transformAggregateFunction(node, queryId) {
    return {
      ...super.transformAggregateFunction({ ...node, aggregated: [] }, queryId),
      aggregated: this.#transformTableArgsWithoutSchemas(node, queryId, "aggregated")
    };
  }
  transformFunction(node, queryId) {
    return {
      ...super.transformFunction({ ...node, arguments: [] }, queryId),
      arguments: this.#transformTableArgsWithoutSchemas(node, queryId, "arguments")
    };
  }
  #transformTableArgsWithoutSchemas(node, queryId, argsKey) {
    return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg, queryId) : {
      ...arg,
      table: this.transformIdentifier(arg.table.identifier, queryId)
    }) : this.transformNodeList(node[argsKey], queryId);
  }
  #isRootOperationNode(node) {
    return node.kind in ROOT_OPERATION_NODES;
  }
  #collectSchemableIds(node) {
    const schemableIds = new Set;
    if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
      this.#collectSchemableId(node.name, schemableIds);
    }
    if ("from" in node && node.from) {
      for (const from of node.from.froms) {
        this.#collectSchemableIdsFromTableExpr(from, schemableIds);
      }
    }
    if ("into" in node && node.into) {
      this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
    }
    if ("table" in node && node.table) {
      this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
    }
    if ("joins" in node && node.joins) {
      for (const join of node.joins) {
        this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
      }
    }
    if ("using" in node && node.using) {
      this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
    }
    return schemableIds;
  }
  #collectCTEs(node) {
    const ctes = new Set;
    if ("with" in node && node.with) {
      this.#collectCTEIds(node.with, ctes);
    }
    return ctes;
  }
  #collectSchemableIdsFromTableExpr(node, schemableIds) {
    if (TableNode.is(node)) {
      this.#collectSchemableId(node.table, schemableIds);
    } else if (AliasNode.is(node) && TableNode.is(node.node)) {
      this.#collectSchemableId(node.node.table, schemableIds);
    } else if (ListNode.is(node)) {
      for (const table of node.items) {
        this.#collectSchemableIdsFromTableExpr(table, schemableIds);
      }
    }
  }
  #collectSchemableId(node, schemableIds) {
    const id = node.identifier.name;
    if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
      schemableIds.add(id);
    }
  }
  #collectCTEIds(node, ctes) {
    for (const expr of node.expressions) {
      const cteId = expr.name.table.table.identifier.name;
      if (!this.#ctes.has(cteId)) {
        ctes.add(cteId);
      }
    }
  }
}

// ../../../../node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
class WithSchemaPlugin {
  #transformer;
  constructor(schema) {
    this.#transformer = new WithSchemaTransformer(schema);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    return args.result;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/matched-node.js
var MatchedNode = freeze({
  is(node) {
    return node.kind === "MatchedNode";
  },
  create(not, bySource = false) {
    return freeze({
      kind: "MatchedNode",
      not,
      bySource
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/merge-parser.js
function parseMergeWhen(type, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type.isMatched, type.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}

// ../../../../node_modules/kysely/dist/esm/util/deferred.js
class Deferred {
  #promise;
  #resolve;
  #reject;
  constructor() {
    this.#promise = new Promise((resolve, reject) => {
      this.#reject = reject;
      this.#resolve = resolve;
    });
  }
  get promise() {
    return this.#promise;
  }
  resolve = (value) => {
    if (this.#resolve) {
      this.#resolve(value);
    }
  };
  reject = (reason) => {
    if (this.#reject) {
      this.#reject(reason);
    }
  };
}

// ../../../../node_modules/kysely/dist/esm/util/provide-controlled-connection.js
async function provideControlledConnection(connectionProvider) {
  const connectionDefer = new Deferred;
  const connectionReleaseDefer = new Deferred;
  connectionProvider.provideConnection(async (connection) => {
    connectionDefer.resolve(connection);
    return await connectionReleaseDefer.promise;
  }).catch((ex) => connectionDefer.reject(ex));
  return freeze({
    connection: await connectionDefer.promise,
    release: connectionReleaseDefer.resolve
  });
}

// ../../../../node_modules/kysely/dist/esm/query-executor/query-executor-base.js
var NO_PLUGINS = freeze([]);

class QueryExecutorBase {
  #plugins;
  constructor(plugins = NO_PLUGINS) {
    this.#plugins = plugins;
  }
  get plugins() {
    return this.#plugins;
  }
  transformQuery(node, queryId) {
    for (const plugin of this.#plugins) {
      const transformedNode = plugin.transformQuery({ node, queryId });
      if (transformedNode.kind === node.kind) {
        node = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node;
  }
  async executeQuery(compiledQuery, queryId) {
    return await this.provideConnection(async (connection) => {
      const result = await connection.executeQuery(compiledQuery);
      if ("numUpdatedOrDeletedRows" in result) {
        logOnce("kysely:warning: outdated driver/plugin detected! `QueryResult.numUpdatedOrDeletedRows` has been replaced with `QueryResult.numAffectedRows`.");
      }
      return await this.#transformResult(result, queryId);
    });
  }
  async* stream(compiledQuery, chunkSize, queryId) {
    const { connection, release } = await provideControlledConnection(this);
    try {
      for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
        yield await this.#transformResult(result, queryId);
      }
    } finally {
      release();
    }
  }
  async#transformResult(result, queryId) {
    for (const plugin of this.#plugins) {
      result = await plugin.transformResult({ result, queryId });
    }
    return result;
  }
}

// ../../../../node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
class NoopQueryExecutor extends QueryExecutorBase {
  get adapter() {
    throw new Error("this query cannot be compiled to SQL");
  }
  compileQuery() {
    throw new Error("this query cannot be compiled to SQL");
  }
  provideConnection() {
    throw new Error("this query cannot be executed");
  }
  withConnectionProvider() {
    throw new Error("this query cannot have a connection provider");
  }
  withPlugin(plugin) {
    return new NoopQueryExecutor([...this.plugins, plugin]);
  }
  withPlugins(plugins) {
    return new NoopQueryExecutor([...this.plugins, ...plugins]);
  }
  withPluginAtFront(plugin) {
    return new NoopQueryExecutor([plugin, ...this.plugins]);
  }
  withoutPlugins() {
    return new NoopQueryExecutor([]);
  }
}
var NOOP_QUERY_EXECUTOR = new NoopQueryExecutor;

// ../../../../node_modules/kysely/dist/esm/query-builder/merge-result.js
class MergeResult {
  numChangedRows;
  constructor(numChangedRows) {
    this.numChangedRows = numChangedRows;
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
class MergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  modifyEnd(modifier) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  top(expression, modifiers) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
    });
  }
  returning(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
}

class WheneableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  modifyEnd(modifier) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  top(expression, modifiers) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  whenMatched() {
    return this.#whenMatched([]);
  }
  whenMatchedAnd(...args) {
    return this.#whenMatched(args);
  }
  whenMatchedAndRef(lhs, op, rhs) {
    return this.#whenMatched([lhs, op, rhs], true);
  }
  #whenMatched(args, refRight) {
    return new MatchedThenableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
    });
  }
  whenNotMatched() {
    return this.#whenNotMatched([]);
  }
  whenNotMatchedAnd(...args) {
    return this.#whenNotMatched(args);
  }
  whenNotMatchedAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true);
  }
  whenNotMatchedBySource() {
    return this.#whenNotMatched([], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return this.#whenNotMatched(args, false, true);
  }
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true, true);
  }
  returning(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  #whenNotMatched(args, refRight = false, bySource = false) {
    const props = {
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
    };
    const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
    return new Builder(props);
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new WheneableMergeQueryBuilder({
      ...this.#props
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new MergeResult(result.numAffectedRows)];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
}

class MatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
    });
  }
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: this.#props.queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
}

class NotMatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values
      })))
    });
  }
}

// ../../../../node_modules/kysely/dist/esm/query-creator.js
class QueryCreator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
    });
  }
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
    });
  }
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
    });
  }
  deleteFrom(from) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  updateTable(tables) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: UpdateQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
    });
  }
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
    });
  }
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
    });
  }
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  withPlugin(plugin) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
}

// ../../../../node_modules/kysely/dist/esm/parser/parse-utils.js
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}

// ../../../../node_modules/kysely/dist/esm/parser/join-parser.js
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else if (args.length === 1) {
    return parseOnlessJoin(joinType, args[0]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}
function parseOnlessJoin(joinType, from) {
  return JoinNode.create(joinType, parseTableExpression(from));
}

// ../../../../node_modules/kysely/dist/esm/operation-node/offset-node.js
var OffsetNode = freeze({
  is(node) {
    return node.kind === "OffsetNode";
  },
  create(offset) {
    return freeze({
      kind: "OffsetNode",
      offset
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/group-by-item-node.js
var GroupByItemNode = freeze({
  is(node) {
    return node.kind === "GroupByItemNode";
  },
  create(groupBy) {
    return freeze({
      kind: "GroupByItemNode",
      groupBy
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/group-by-parser.js
function parseGroupBy(groupBy) {
  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/set-operation-node.js
var SetOperationNode = freeze({
  is(node) {
    return node.kind === "SetOperationNode";
  },
  create(operator, expression, all2) {
    return freeze({
      kind: "SetOperationNode",
      operator,
      expression,
      all: all2
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/set-operation-parser.js
function parseSetOperations(operator, expression, all2) {
  if (isFunction(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all2));
}

// ../../../../node_modules/kysely/dist/esm/expression/expression-wrapper.js
class ExpressionWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new ExpressionWrapper(this.#node);
  }
  $notNull() {
    return new ExpressionWrapper(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}

class AliasedExpressionWrapper {
  #expr;
  #alias;
  constructor(expr, alias) {
    this.#expr = expr;
    this.#alias = alias;
  }
  get expression() {
    return this.#expr;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}

class OrWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new OrWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}

class AndWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new AndWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/fetch-node.js
var FetchNode = {
  is(node) {
    return node.kind === "FetchNode";
  },
  create(rowCount, modifier) {
    return {
      kind: "FetchNode",
      rowCount: ValueNode.create(rowCount),
      modifier
    };
  }
};

// ../../../../node_modules/kysely/dist/esm/parser/fetch-parser.js
function parseFetch(rowCount, modifier) {
  if (!isNumber(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}

// ../../../../node_modules/kysely/dist/esm/query-builder/select-query-builder.js
class SelectQueryBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forKeyShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forNoKeyUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  skipLocked() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  crossJoin(...args) {
    return this.#join("CrossJoin", args);
  }
  innerJoinLateral(...args) {
    return this.#join("LateralInnerJoin", args);
  }
  leftJoinLateral(...args) {
    return this.#join("LateralLeftJoin", args);
  }
  crossJoinLateral(...args) {
    return this.#join("LateralCrossJoin", args);
  }
  crossApply(...args) {
    return this.#join("CrossApply", args);
  }
  outerApply(...args) {
    return this.#join("OuterApply", args);
  }
  #join(joinType, args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  offset(offset) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias) {
    return new AliasedSelectQueryBuilderImpl(this, alias);
  }
  clearSelect() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
    });
  }
  clearWhere() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  clearOffset() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
    });
  }
  clearOrderBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  clearGroupBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new SelectQueryBuilderImpl({
      ...this.#props
    });
  }
  $castTo() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $narrowType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $assertType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  $asScalar() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    return result.rows;
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}

class AliasedSelectQueryBuilderImpl {
  #queryBuilder;
  #alias;
  constructor(queryBuilder, alias) {
    this.#queryBuilder = queryBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#queryBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js
var AggregateFunctionNode = freeze({
  is(node) {
    return node.kind === "AggregateFunctionNode";
  },
  create(aggregateFunction, aggregated = []) {
    return freeze({
      kind: "AggregateFunctionNode",
      func: aggregateFunction,
      aggregated
    });
  },
  cloneWithDistinct(aggregateFunctionNode) {
    return freeze({
      ...aggregateFunctionNode,
      distinct: true
    });
  },
  cloneWithOrderBy(aggregateFunctionNode, orderItems, withinGroup = false) {
    const prop = withinGroup ? "withinGroup" : "orderBy";
    return freeze({
      ...aggregateFunctionNode,
      [prop]: aggregateFunctionNode[prop] ? OrderByNode.cloneWithItems(aggregateFunctionNode[prop], orderItems) : OrderByNode.create(orderItems)
    });
  },
  cloneWithFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOrFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOver(aggregateFunctionNode, over) {
    return freeze({
      ...aggregateFunctionNode,
      over
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/function-node.js
var FunctionNode = freeze({
  is(node) {
    return node.kind === "FunctionNode";
  },
  create(func, args) {
    return freeze({
      kind: "FunctionNode",
      func,
      arguments: args
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js
class AggregateFunctionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedAggregateFunctionBuilder(this, alias);
  }
  distinct() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
    });
  }
  orderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithOrderByItems(this.#props.aggregateFunctionNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithoutOrderBy(this.#props.aggregateFunctionNode)
    });
  }
  withinGroupOrderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy(args), true)
    });
  }
  filterWhere(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  filterWhereRef(lhs, op, rhs) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  over(over) {
    const builder = createOverBuilder();
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  $call(func) {
    return func(this);
  }
  $castTo() {
    return new AggregateFunctionBuilder(this.#props);
  }
  $notNull() {
    return new AggregateFunctionBuilder(this.#props);
  }
  toOperationNode() {
    return this.#props.aggregateFunctionNode;
  }
}

class AliasedAggregateFunctionBuilder {
  #aggregateFunctionBuilder;
  #alias;
  constructor(aggregateFunctionBuilder, alias) {
    this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#aggregateFunctionBuilder;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}

// ../../../../node_modules/kysely/dist/esm/query-builder/function-module.js
function createFunctionModule() {
  const fn = (name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
  };
  const agg = (name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : undefined)
    });
  };
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}

// ../../../../node_modules/kysely/dist/esm/operation-node/unary-operation-node.js
var UnaryOperationNode = freeze({
  is(node) {
    return node.kind === "UnaryOperationNode";
  },
  create(operator, operand) {
    return freeze({
      kind: "UnaryOperationNode",
      operator,
      operand
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/unary-operation-parser.js
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}

// ../../../../node_modules/kysely/dist/esm/operation-node/case-node.js
var CaseNode = freeze({
  is(node) {
    return node.kind === "CaseNode";
  },
  create(value) {
    return freeze({
      kind: "CaseNode",
      value
    });
  },
  cloneWithWhen(caseNode, when) {
    return freeze({
      ...caseNode,
      when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
    });
  },
  cloneWithThen(caseNode, then) {
    return freeze({
      ...caseNode,
      when: caseNode.when ? freeze([
        ...caseNode.when.slice(0, -1),
        WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
      ]) : undefined
    });
  },
  cloneWith(caseNode, props) {
    return freeze({
      ...caseNode,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/case-builder.js
class CaseBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
}

class CaseThenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
}

class CaseWhenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...this.#props,
      node: CaseNode.cloneWith(this.#props.node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}

class CaseEndBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js
var JSONPathLegNode = freeze({
  is(node) {
    return node.kind === "JSONPathLegNode";
  },
  create(type, value) {
    return freeze({
      kind: "JSONPathLegNode",
      type,
      value
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/query-builder/json-path-builder.js
class JSONPathBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  at(index) {
    return this.#createBuilderWithPathLeg("ArrayLocation", index);
  }
  key(key) {
    return this.#createBuilderWithPathLeg("Member", key);
  }
  #createBuilderWithPathLeg(legType, value) {
    if (JSONReferenceNode.is(this.#node)) {
      return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
    }
    return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
  }
}

class TraversedJSONPathBuilder extends JSONPathBuilder {
  #node;
  constructor(node) {
    super(node);
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedJSONPathBuilder(this, alias);
  }
  $castTo() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  $notNull() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}

class AliasedJSONPathBuilder {
  #jsonPath;
  #alias;
  constructor(jsonPath, alias) {
    this.#jsonPath = jsonPath;
    this.#alias = alias;
  }
  get expression() {
    return this.#jsonPath;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/tuple-node.js
var TupleNode = freeze({
  is(node) {
    return node.kind === "TupleNode";
  },
  create(values) {
    return freeze({
      kind: "TupleNode",
      values: freeze(values)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/data-type-node.js
var SIMPLE_COLUMN_DATA_TYPES = [
  "varchar",
  "char",
  "text",
  "integer",
  "int2",
  "int4",
  "int8",
  "smallint",
  "bigint",
  "boolean",
  "real",
  "double precision",
  "float4",
  "float8",
  "decimal",
  "numeric",
  "binary",
  "bytea",
  "date",
  "datetime",
  "time",
  "timetz",
  "timestamp",
  "timestamptz",
  "serial",
  "bigserial",
  "uuid",
  "json",
  "jsonb",
  "blob",
  "varbinary",
  "int4range",
  "int4multirange",
  "int8range",
  "int8multirange",
  "numrange",
  "nummultirange",
  "tsrange",
  "tsmultirange",
  "tstzrange",
  "tstzmultirange",
  "daterange",
  "datemultirange"
];
var COLUMN_DATA_TYPE_REGEX = [
  /^varchar\(\d+\)$/,
  /^char\(\d+\)$/,
  /^decimal\(\d+, \d+\)$/,
  /^numeric\(\d+, \d+\)$/,
  /^binary\(\d+\)$/,
  /^datetime\(\d+\)$/,
  /^time\(\d+\)$/,
  /^timetz\(\d+\)$/,
  /^timestamp\(\d+\)$/,
  /^timestamptz\(\d+\)$/,
  /^varbinary\(\d+\)$/
];
var DataTypeNode = freeze({
  is(node) {
    return node.kind === "DataTypeNode";
  },
  create(dataType) {
    return freeze({
      kind: "DataTypeNode",
      dataType
    });
  }
});
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType))) {
    return true;
  }
  return false;
}

// ../../../../node_modules/kysely/dist/esm/parser/data-type-parser.js
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/cast-node.js
var CastNode = freeze({
  is(node) {
    return node.kind === "CastNode";
  },
  create(expression, dataType) {
    return freeze({
      kind: "CastNode",
      expression,
      dataType
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/expression/expression-builder.js
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary, {
    fn: undefined,
    eb: undefined,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined(reference) ? undefined : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}

// ../../../../node_modules/kysely/dist/esm/parser/expression-parser.js
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}

// ../../../../node_modules/kysely/dist/esm/dynamic/dynamic-table-builder.js
class DynamicTableBuilder {
  #table;
  get table() {
    return this.#table;
  }
  constructor(table) {
    this.#table = table;
  }
  as(alias) {
    return new AliasedDynamicTableBuilder(this.#table, alias);
  }
}

class AliasedDynamicTableBuilder {
  #table;
  #alias;
  get table() {
    return this.#table;
  }
  get alias() {
    return this.#alias;
  }
  constructor(table, alias) {
    this.#table = table;
    this.#alias = alias;
  }
  toOperationNode() {
    return AliasNode.create(parseTable(this.#table), IdentifierNode.create(this.#alias));
  }
}
function isAliasedDynamicTableBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.table) && isString(obj.alias);
}

// ../../../../node_modules/kysely/dist/esm/parser/table-parser.js
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString(table)) {
    return parseAliasedTable(table);
  } else if (isAliasedDynamicTableBuilder(table)) {
    return table.toOperationNode();
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim2);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim2);
    return TableNode.createWithSchema(schema, table);
  } else {
    return TableNode.create(from);
  }
}
function trim2(str) {
  return str.trim();
}

// ../../../../node_modules/kysely/dist/esm/operation-node/add-column-node.js
var AddColumnNode = freeze({
  is(node) {
    return node.kind === "AddColumnNode";
  },
  create(column) {
    return freeze({
      kind: "AddColumnNode",
      column
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/column-definition-node.js
var ColumnDefinitionNode = freeze({
  is(node) {
    return node.kind === "ColumnDefinitionNode";
  },
  create(column, dataType) {
    return freeze({
      kind: "ColumnDefinitionNode",
      column: ColumnNode.create(column),
      dataType
    });
  },
  cloneWithFrontModifier(node, modifier) {
    return freeze({
      ...node,
      frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
    });
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-column-node.js
var DropColumnNode = freeze({
  is(node) {
    return node.kind === "DropColumnNode";
  },
  create(column) {
    return freeze({
      kind: "DropColumnNode",
      column: ColumnNode.create(column)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/rename-column-node.js
var RenameColumnNode = freeze({
  is(node) {
    return node.kind === "RenameColumnNode";
  },
  create(column, newColumn) {
    return freeze({
      kind: "RenameColumnNode",
      column: ColumnNode.create(column),
      renameTo: ColumnNode.create(newColumn)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/check-constraint-node.js
var CheckConstraintNode = freeze({
  is(node) {
    return node.kind === "CheckConstraintNode";
  },
  create(expression, constraintName) {
    return freeze({
      kind: "CheckConstraintNode",
      expression,
      name: constraintName ? IdentifierNode.create(constraintName) : undefined
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/references-node.js
var ON_MODIFY_FOREIGN_ACTIONS = [
  "no action",
  "restrict",
  "cascade",
  "set null",
  "set default"
];
var ReferencesNode = freeze({
  is(node) {
    return node.kind === "ReferencesNode";
  },
  create(table, columns) {
    return freeze({
      kind: "ReferencesNode",
      table,
      columns: freeze([...columns])
    });
  },
  cloneWithOnDelete(references, onDelete) {
    return freeze({
      ...references,
      onDelete
    });
  },
  cloneWithOnUpdate(references, onUpdate) {
    return freeze({
      ...references,
      onUpdate
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/default-value-parser.js
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/generated-node.js
var GeneratedNode = freeze({
  is(node) {
    return node.kind === "GeneratedNode";
  },
  create(params) {
    return freeze({
      kind: "GeneratedNode",
      ...params
    });
  },
  createWithExpression(expression) {
    return freeze({
      kind: "GeneratedNode",
      always: true,
      expression
    });
  },
  cloneWith(node, params) {
    return freeze({
      ...node,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/default-value-node.js
var DefaultValueNode = freeze({
  is(node) {
    return node.kind === "DefaultValueNode";
  },
  create(defaultValue) {
    return freeze({
      kind: "DefaultValueNode",
      defaultValue
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/parser/on-modify-action-parser.js
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}

// ../../../../node_modules/kysely/dist/esm/schema/column-definition-builder.js
class ColumnDefinitionBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  autoIncrement() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
  }
  identity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
  }
  primaryKey() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
  }
  references(ref) {
    const references = parseStringReference(ref);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  onDelete(onDelete) {
    if (!this.#node.references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
    }));
  }
  onUpdate(onUpdate) {
    if (!this.#node.references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  unique() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
  }
  notNull() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
  }
  unsigned() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
  }
  defaultTo(value) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  check(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  generatedAlwaysAs(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  generatedAlwaysAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  generatedByDefaultAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  stored() {
    if (!this.#node.generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.cloneWith(this.#node.generated, {
        stored: true
      })
    }));
  }
  modifyFront(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
  }
  nullsNotDistinct() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  ifNotExists() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
  }
  modifyEnd(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/modify-column-node.js
var ModifyColumnNode = freeze({
  is(node) {
    return node.kind === "ModifyColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ModifyColumnNode",
      column
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js
var ForeignKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "ForeignKeyConstraintNode";
  },
  create(sourceColumns, targetTable, targetColumns, constraintName) {
    return freeze({
      kind: "ForeignKeyConstraintNode",
      columns: sourceColumns,
      references: ReferencesNode.create(targetTable, targetColumns),
      name: constraintName ? IdentifierNode.create(constraintName) : undefined
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
class ForeignKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  onDelete(onDelete) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  deferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/add-constraint-node.js
var AddConstraintNode = freeze({
  is(node) {
    return node.kind === "AddConstraintNode";
  },
  create(constraint) {
    return freeze({
      kind: "AddConstraintNode",
      constraint
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js
var UniqueConstraintNode = freeze({
  is(node) {
    return node.kind === "UniqueConstraintNode";
  },
  create(columns, constraintName, nullsNotDistinct) {
    return freeze({
      kind: "UniqueConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : undefined,
      nullsNotDistinct
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js
var DropConstraintNode = freeze({
  is(node) {
    return node.kind === "DropConstraintNode";
  },
  create(constraintName) {
    return freeze({
      kind: "DropConstraintNode",
      constraintName: IdentifierNode.create(constraintName)
    });
  },
  cloneWith(dropConstraint, props) {
    return freeze({
      ...dropConstraint,
      ...props
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/alter-column-node.js
var AlterColumnNode = freeze({
  is(node) {
    return node.kind === "AlterColumnNode";
  },
  create(column, prop, value) {
    return freeze({
      kind: "AlterColumnNode",
      column: ColumnNode.create(column),
      [prop]: value
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/alter-column-builder.js
class AlterColumnBuilder {
  #column;
  constructor(column) {
    this.#column = column;
  }
  setDataType(dataType) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
  }
  $call(func) {
    return func(this);
  }
}

class AlteredColumnBuilder {
  #alterColumnNode;
  constructor(alterColumnNode) {
    this.#alterColumnNode = alterColumnNode;
  }
  toOperationNode() {
    return this.#alterColumnNode;
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/alter-table-executor.js
class AlterTableExecutor {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js
class AlterTableAddForeignKeyConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  onDelete(onDelete) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
    });
  }
  deferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.deferrable()
    });
  }
  notDeferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.notDeferrable()
    });
  }
  initiallyDeferred() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyDeferred()
    });
  }
  initiallyImmediate() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyImmediate()
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
      addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
    }), this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js
class AlterTableDropConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/primary-key-constraint-node.js
var PrimaryKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "PrimaryKeyConstraintNode";
  },
  create(columns, constraintName) {
    return freeze({
      kind: "PrimaryKeyConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : undefined
    });
  },
  cloneWith(node, props) {
    return freeze({ ...node, ...props });
  }
});

// ../../../../node_modules/kysely/dist/esm/operation-node/add-index-node.js
var AddIndexNode = freeze({
  is(node) {
    return node.kind === "AddIndexNode";
  },
  create(name) {
    return freeze({
      kind: "AddIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js
class AlterTableAddIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  unique() {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          unique: true
        })
      })
    });
  }
  column(column) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  columns(columns) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  expression(expression) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/unique-constraint-builder.js
class UniqueConstraintNodeBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  nullsNotDistinct() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  deferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/primary-key-constraint-builder.js
class PrimaryKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  deferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/check-constraint-builder.js
class CheckConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/rename-constraint-node.js
var RenameConstraintNode = freeze({
  is(node) {
    return node.kind === "RenameConstraintNode";
  },
  create(oldName, newName) {
    return freeze({
      kind: "RenameConstraintNode",
      oldName: IdentifierNode.create(oldName),
      newName: IdentifierNode.create(newName)
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/alter-table-builder.js
class AlterTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  addCheckConstraint(constraintName, checkExpression, build = noop) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
    const constraintBuilder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder
    });
  }
  addPrimaryKeyConstraint(constraintName, columns, build = noop) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  renameConstraint(oldName, newName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameConstraint: RenameConstraintNode.create(oldName, newName)
      })
    });
  }
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  $call(func) {
    return func(this);
  }
}

class AlterTableColumnAlteringBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js
class ImmediateValueTransformer extends OperationNodeTransformer {
  transformPrimitiveValueList(node) {
    return ValueListNode.create(node.values.map(ValueNode.createImmediate));
  }
  transformValue(node) {
    return ValueNode.createImmediate(node.value);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/create-index-builder.js
class CreateIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  unique() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        unique: true
      })
    });
  }
  nullsNotDistinct() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        nullsNotDistinct: true
      })
    });
  }
  on(table) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  column(column) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  columns(columns) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
    });
  }
  expression(expression) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer;
    return new CreateIndexBuilder({
      ...this.#props,
      node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args), this.#props.queryId))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/create-schema-builder.js
class CreateSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateSchemaBuilder({
      ...this.#props,
      node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/parser/on-commit-action-parse.js
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}

// ../../../../node_modules/kysely/dist/esm/schema/create-table-builder.js
class CreateTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  temporary() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  onCommit(onCommit) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  ifNotExists() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  addColumn(columnName, dataType, build = noop) {
    const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
    });
  }
  addPrimaryKeyConstraint(constraintName, columns, build = noop) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  addCheckConstraint(constraintName, checkExpression, build = noop) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
    const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
    });
  }
  modifyFront(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  modifyEnd(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  as(expression) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/drop-index-builder.js
class DropIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(table) {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/drop-schema-builder.js
class DropSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/drop-table-builder.js
class DropTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/create-view-node.js
var CreateViewNode = freeze({
  is(node) {
    return node.kind === "CreateViewNode";
  },
  create(name) {
    return freeze({
      kind: "CreateViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js
class ImmediateValuePlugin {
  #transformer = new ImmediateValueTransformer;
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/create-view-builder.js
class CreateViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  temporary() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifNotExists() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  as(query2) {
    const queryNode = query2.withPlugin(new ImmediateValuePlugin).toOperationNode();
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        as: queryNode
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-view-node.js
var DropViewNode = freeze({
  is(node) {
    return node.kind === "DropViewNode";
  },
  create(name) {
    return freeze({
      kind: "DropViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(dropView, params) {
    return freeze({
      ...dropView,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/drop-view-builder.js
class DropViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/create-type-node.js
var CreateTypeNode = freeze({
  is(node) {
    return node.kind === "CreateTypeNode";
  },
  create(name) {
    return freeze({
      kind: "CreateTypeNode",
      name
    });
  },
  cloneWithEnum(createType, values) {
    return freeze({
      ...createType,
      enum: ValueListNode.create(values.map(ValueNode.createImmediate))
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/create-type-builder.js
class CreateTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  asEnum(values) {
    return new CreateTypeBuilder({
      ...this.#props,
      node: CreateTypeNode.cloneWithEnum(this.#props.node, values)
    });
  }
  $call(func) {
    return func(this);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/operation-node/drop-type-node.js
var DropTypeNode = freeze({
  is(node) {
    return node.kind === "DropTypeNode";
  },
  create(name) {
    return freeze({
      kind: "DropTypeNode",
      name
    });
  },
  cloneWith(dropType, params) {
    return freeze({
      ...dropType,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/drop-type-builder.js
class DropTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTypeBuilder({
      ...this.#props,
      node: DropTypeNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/parser/identifier-parser.js
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim3);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim3(str) {
  return str.trim();
}

// ../../../../node_modules/kysely/dist/esm/operation-node/refresh-materialized-view-node.js
var RefreshMaterializedViewNode = freeze({
  is(node) {
    return node.kind === "RefreshMaterializedViewNode";
  },
  create(name) {
    return freeze({
      kind: "RefreshMaterializedViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/schema/refresh-materialized-view-builder.js
class RefreshMaterializedViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  concurrently() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        concurrently: true,
        withNoData: false
      })
    });
  }
  withData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: false
      })
    });
  }
  withNoData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: true,
        concurrently: false
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}

// ../../../../node_modules/kysely/dist/esm/schema/schema.js
class SchemaModule {
  #executor;
  constructor(executor) {
    this.#executor = executor;
  }
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTableNode.create(parseTable(table))
    });
  }
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTableNode.create(parseTable(table))
    });
  }
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateIndexNode.create(indexName)
    });
  }
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropIndexNode.create(indexName)
    });
  }
  createSchema(schema) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateSchemaNode.create(schema)
    });
  }
  dropSchema(schema) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropSchemaNode.create(schema)
    });
  }
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: AlterTableNode.create(parseTable(table))
    });
  }
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateViewNode.create(viewName)
    });
  }
  refreshMaterializedView(viewName) {
    return new RefreshMaterializedViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: RefreshMaterializedViewNode.create(viewName)
    });
  }
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropViewNode.create(viewName)
    });
  }
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  withPlugin(plugin) {
    return new SchemaModule(this.#executor.withPlugin(plugin));
  }
  withoutPlugins() {
    return new SchemaModule(this.#executor.withoutPlugins());
  }
  withSchema(schema) {
    return new SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema)));
  }
}

// ../../../../node_modules/kysely/dist/esm/dynamic/dynamic.js
class DynamicModule {
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
  table(table) {
    return new DynamicTableBuilder(table);
  }
}

// ../../../../node_modules/kysely/dist/esm/driver/default-connection-provider.js
class DefaultConnectionProvider {
  #driver;
  constructor(driver) {
    this.#driver = driver;
  }
  async provideConnection(consumer) {
    const connection = await this.#driver.acquireConnection();
    try {
      return await consumer(connection);
    } finally {
      await this.#driver.releaseConnection(connection);
    }
  }
}

// ../../../../node_modules/kysely/dist/esm/query-executor/default-query-executor.js
class DefaultQueryExecutor extends QueryExecutorBase {
  #compiler;
  #adapter;
  #connectionProvider;
  constructor(compiler, adapter, connectionProvider, plugins = []) {
    super(plugins);
    this.#compiler = compiler;
    this.#adapter = adapter;
    this.#connectionProvider = connectionProvider;
  }
  get adapter() {
    return this.#adapter;
  }
  compileQuery(node, queryId) {
    return this.#compiler.compileQuery(node, queryId);
  }
  provideConnection(consumer) {
    return this.#connectionProvider.provideConnection(consumer);
  }
  withPlugins(plugins) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
  }
  withPlugin(plugin) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);
  }
  withPluginAtFront(plugin) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);
  }
  withConnectionProvider(connectionProvider) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
  }
  withoutPlugins() {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
  }
}

// ../../../../node_modules/kysely/dist/esm/util/performance-now.js
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}

// ../../../../node_modules/kysely/dist/esm/driver/runtime-driver.js
class RuntimeDriver {
  #driver;
  #log;
  #initPromise;
  #initDone;
  #destroyPromise;
  #connections = new WeakSet;
  constructor(driver, log10) {
    this.#initDone = false;
    this.#driver = driver;
    this.#log = log10;
  }
  async init() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initPromise) {
      this.#initPromise = this.#driver.init().then(() => {
        this.#initDone = true;
      }).catch((err2) => {
        this.#initPromise = undefined;
        return Promise.reject(err2);
      });
    }
    await this.#initPromise;
  }
  async acquireConnection() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initDone) {
      await this.init();
    }
    const connection = await this.#driver.acquireConnection();
    if (!this.#connections.has(connection)) {
      if (this.#needsLogging()) {
        this.#addLogging(connection);
      }
      this.#connections.add(connection);
    }
    return connection;
  }
  async releaseConnection(connection) {
    await this.#driver.releaseConnection(connection);
  }
  beginTransaction(connection, settings) {
    return this.#driver.beginTransaction(connection, settings);
  }
  commitTransaction(connection) {
    return this.#driver.commitTransaction(connection);
  }
  rollbackTransaction(connection) {
    return this.#driver.rollbackTransaction(connection);
  }
  savepoint(connection, savepointName, compileQuery) {
    if (this.#driver.savepoint) {
      return this.#driver.savepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `savepoint` method is not supported by this driver");
  }
  rollbackToSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.rollbackToSavepoint) {
      return this.#driver.rollbackToSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `rollbackToSavepoint` method is not supported by this driver");
  }
  releaseSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.releaseSavepoint) {
      return this.#driver.releaseSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `releaseSavepoint` method is not supported by this driver");
  }
  async destroy() {
    if (!this.#initPromise) {
      return;
    }
    await this.#initPromise;
    if (!this.#destroyPromise) {
      this.#destroyPromise = this.#driver.destroy().catch((err2) => {
        this.#destroyPromise = undefined;
        return Promise.reject(err2);
      });
    }
    await this.#destroyPromise;
  }
  #needsLogging() {
    return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
  }
  #addLogging(connection) {
    const executeQuery = connection.executeQuery;
    const streamQuery = connection.streamQuery;
    const dis = this;
    connection.executeQuery = async (compiledQuery) => {
      let caughtError;
      const startTime = performanceNow();
      try {
        return await executeQuery.call(connection, compiledQuery);
      } catch (error) {
        caughtError = error;
        await dis.#logError(error, compiledQuery, startTime);
        throw error;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime);
        }
      }
    };
    connection.streamQuery = async function* (compiledQuery, chunkSize) {
      let caughtError;
      const startTime = performanceNow();
      try {
        for await (const result of streamQuery.call(connection, compiledQuery, chunkSize)) {
          yield result;
        }
      } catch (error) {
        caughtError = error;
        await dis.#logError(error, compiledQuery, startTime);
        throw error;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime, true);
        }
      }
    };
  }
  async#logError(error, compiledQuery, startTime) {
    await this.#log.error(() => ({
      level: "error",
      error,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  async#logQuery(compiledQuery, startTime, isStream = false) {
    await this.#log.query(() => ({
      level: "query",
      isStream,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  #calculateDurationMillis(startTime) {
    return performanceNow() - startTime;
  }
}

// ../../../../node_modules/kysely/dist/esm/driver/single-connection-provider.js
var ignoreError = () => {};

class SingleConnectionProvider {
  #connection;
  #runningPromise;
  constructor(connection) {
    this.#connection = connection;
  }
  async provideConnection(consumer) {
    while (this.#runningPromise) {
      await this.#runningPromise.catch(ignoreError);
    }
    this.#runningPromise = this.#run(consumer).finally(() => {
      this.#runningPromise = undefined;
    });
    return this.#runningPromise;
  }
  async#run(runner) {
    return await runner(this.#connection);
  }
}

// ../../../../node_modules/kysely/dist/esm/driver/driver.js
var TRANSACTION_ACCESS_MODES = ["read only", "read write"];
var TRANSACTION_ISOLATION_LEVELS = [
  "read uncommitted",
  "read committed",
  "repeatable read",
  "serializable",
  "snapshot"
];
function validateTransactionSettings(settings) {
  if (settings.accessMode && !TRANSACTION_ACCESS_MODES.includes(settings.accessMode)) {
    throw new Error(`invalid transaction access mode ${settings.accessMode}`);
  }
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}

// ../../../../node_modules/kysely/dist/esm/util/log.js
var LOG_LEVELS = freeze(["query", "error"]);

class Log {
  #levels;
  #logger;
  constructor(config) {
    if (isFunction(config)) {
      this.#logger = config;
      this.#levels = freeze({
        query: true,
        error: true
      });
    } else {
      this.#logger = defaultLogger;
      this.#levels = freeze({
        query: config.includes("query"),
        error: config.includes("error")
      });
    }
  }
  isLevelEnabled(level) {
    return this.#levels[level];
  }
  async query(getEvent) {
    if (this.#levels.query) {
      await this.#logger(getEvent());
    }
  }
  async error(getEvent) {
    if (this.#levels.error) {
      await this.#logger(getEvent());
    }
  }
}
function defaultLogger(event) {
  if (event.level === "query") {
    const prefix = `kysely:query:${event.isStream ? "stream:" : ""}`;
    console.log(`${prefix} ${event.query.sql}`);
    console.log(`${prefix} duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}

// ../../../../node_modules/kysely/dist/esm/util/compilable.js
function isCompilable(value) {
  return isObject(value) && isFunction(value.compile);
}

// ../../../../node_modules/kysely/dist/esm/kysely.js
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");

class Kysely extends QueryCreator {
  #props;
  constructor(args) {
    let superProps;
    let props;
    if (isKyselyProps(args)) {
      superProps = { executor: args.executor };
      props = { ...args };
    } else {
      const dialect = args.dialect;
      const driver = dialect.createDriver();
      const compiler = dialect.createQueryCompiler();
      const adapter = dialect.createAdapter();
      const log10 = new Log(args.log ?? []);
      const runtimeDriver = new RuntimeDriver(driver, log10);
      const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
      const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
      superProps = { executor };
      props = {
        config: args,
        executor,
        dialect,
        driver: runtimeDriver
      };
    }
    super(superProps);
    this.#props = freeze(props);
  }
  get schema() {
    return new SchemaModule(this.#props.executor);
  }
  get dynamic() {
    return new DynamicModule;
  }
  get introspection() {
    return this.#props.dialect.createIntrospector(this.withoutPlugins());
  }
  case(value) {
    return new CaseBuilder({
      node: CaseNode.create(isUndefined(value) ? undefined : parseExpression(value))
    });
  }
  get fn() {
    return createFunctionModule();
  }
  transaction() {
    return new TransactionBuilder({ ...this.#props });
  }
  startTransaction() {
    return new ControlledTransactionBuilder({ ...this.#props });
  }
  connection() {
    return new ConnectionBuilder({ ...this.#props });
  }
  withPlugin(plugin) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new Kysely({ ...this.#props });
  }
  async destroy() {
    await this.#props.driver.destroy();
  }
  get isTransaction() {
    return false;
  }
  getExecutor() {
    return this.#props.executor;
  }
  executeQuery(query2, queryId = createQueryId()) {
    const compiledQuery = isCompilable(query2) ? query2.compile() : query2;
    return this.getExecutor().executeQuery(compiledQuery, queryId);
  }
  async[Symbol.asyncDispose]() {
    await this.destroy();
  }
}

class Transaction extends Kysely {
  #props;
  constructor(props) {
    super(props);
    this.#props = props;
  }
  get isTransaction() {
    return true;
  }
  transaction() {
    throw new Error("calling the transaction method for a Transaction is not supported");
  }
  connection() {
    throw new Error("calling the connection method for a Transaction is not supported");
  }
  async destroy() {
    throw new Error("calling the destroy method for a Transaction is not supported");
  }
  withPlugin(plugin) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new Transaction({ ...this.#props });
  }
}
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}

class ConnectionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async execute(callback) {
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const db3 = new Kysely({
        ...this.#props,
        executor
      });
      return await callback(db3);
    });
  }
}

class TransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new TransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new TransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, accessMode, ...kyselyProps } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const transaction2 = new Transaction({
        ...kyselyProps,
        executor
      });
      try {
        await this.#props.driver.beginTransaction(connection, settings);
        const result = await callback(transaction2);
        await this.#props.driver.commitTransaction(connection);
        return result;
      } catch (error) {
        await this.#props.driver.rollbackTransaction(connection);
        throw error;
      }
    });
  }
}

class ControlledTransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute() {
    const { isolationLevel, accessMode, ...props } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    const connection = await provideControlledConnection(this.#props.executor);
    await this.#props.driver.beginTransaction(connection.connection, settings);
    return new ControlledTransaction({
      ...props,
      connection,
      executor: this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection.connection))
    });
  }
}

class ControlledTransaction extends Transaction {
  #props;
  #compileQuery;
  #state;
  constructor(props) {
    const state = { isCommitted: false, isRolledBack: false };
    props = {
      ...props,
      executor: new NotCommittedOrRolledBackAssertingExecutor(props.executor, state)
    };
    const { connection, ...transactionProps } = props;
    super(transactionProps);
    this.#props = freeze(props);
    this.#state = state;
    const queryId = createQueryId();
    this.#compileQuery = (node) => props.executor.compileQuery(node, queryId);
  }
  get isCommitted() {
    return this.#state.isCommitted;
  }
  get isRolledBack() {
    return this.#state.isRolledBack;
  }
  commit() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.commitTransaction(this.#props.connection.connection);
      this.#state.isCommitted = true;
      this.#props.connection.release();
    });
  }
  rollback() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackTransaction(this.#props.connection.connection);
      this.#state.isRolledBack = true;
      this.#props.connection.release();
    });
  }
  savepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.savepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  rollbackToSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackToSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  releaseSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.releaseSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  withPlugin(plugin) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new ControlledTransaction({ ...this.#props });
  }
}

class Command {
  #cb;
  constructor(cb) {
    this.#cb = cb;
  }
  async execute() {
    return await this.#cb();
  }
}
function assertNotCommittedOrRolledBack(state) {
  if (state.isCommitted) {
    throw new Error("Transaction is already committed");
  }
  if (state.isRolledBack) {
    throw new Error("Transaction is already rolled back");
  }
}

class NotCommittedOrRolledBackAssertingExecutor {
  #executor;
  #state;
  constructor(executor, state) {
    if (executor instanceof NotCommittedOrRolledBackAssertingExecutor) {
      this.#executor = executor.#executor;
    } else {
      this.#executor = executor;
    }
    this.#state = state;
  }
  get adapter() {
    return this.#executor.adapter;
  }
  get plugins() {
    return this.#executor.plugins;
  }
  transformQuery(node, queryId) {
    return this.#executor.transformQuery(node, queryId);
  }
  compileQuery(node, queryId) {
    return this.#executor.compileQuery(node, queryId);
  }
  provideConnection(consumer) {
    return this.#executor.provideConnection(consumer);
  }
  executeQuery(compiledQuery, queryId) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.executeQuery(compiledQuery, queryId);
  }
  stream(compiledQuery, chunkSize, queryId) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.stream(compiledQuery, chunkSize, queryId);
  }
  withConnectionProvider(connectionProvider) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withConnectionProvider(connectionProvider), this.#state);
  }
  withPlugin(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugin(plugin), this.#state);
  }
  withPlugins(plugins) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugins(plugins), this.#state);
  }
  withPluginAtFront(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPluginAtFront(plugin), this.#state);
  }
  withoutPlugins() {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withoutPlugins(), this.#state);
  }
}

// ../../../../node_modules/kysely/dist/esm/raw-builder/raw-builder.js
class RawBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias) {
    return new AliasedRawBuilderImpl(this, alias);
  }
  $castTo() {
    return new RawBuilderImpl({ ...this.#props });
  }
  $notNull() {
    return new RawBuilderImpl(this.#props);
  }
  withPlugin(plugin) {
    return new RawBuilderImpl({
      ...this.#props,
      plugins: this.#props.plugins !== undefined ? freeze([...this.#props.plugins, plugin]) : freeze([plugin])
    });
  }
  toOperationNode() {
    return this.#toOperationNode(this.#getExecutor());
  }
  compile(executorProvider) {
    return this.#compile(this.#getExecutor(executorProvider));
  }
  async execute(executorProvider) {
    const executor = this.#getExecutor(executorProvider);
    return executor.executeQuery(this.#compile(executor), this.#props.queryId);
  }
  #getExecutor(executorProvider) {
    const executor = executorProvider !== undefined ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
    return this.#props.plugins !== undefined ? executor.withPlugins(this.#props.plugins) : executor;
  }
  #toOperationNode(executor) {
    return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
  }
  #compile(executor) {
    return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
  }
}
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}

class AliasedRawBuilderImpl {
  #rawBuilder;
  #alias;
  constructor(rawBuilder, alias) {
    this.#rawBuilder = rawBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#rawBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get rawBuilder() {
    return this.#rawBuilder;
  }
  toOperationNode() {
    return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}

// ../../../../node_modules/kysely/dist/esm/raw-builder/sql.js
var sql = Object.assign((sqlFragments, ...parameters) => {
  return createRawBuilder({
    queryId: createQueryId(),
    rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])
  });
}, {
  ref(columnReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseStringReference(columnReference))
    });
  },
  val(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseValueExpression(value))
    });
  },
  value(value) {
    return this.val(value);
  },
  table(tableReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseTable(tableReference))
    });
  },
  id(...ids) {
    const fragments = new Array(ids.length + 1).fill(".");
    fragments[0] = "";
    fragments[fragments.length - 1] = "";
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
    });
  },
  lit(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
    });
  },
  literal(value) {
    return this.lit(value);
  },
  raw(sql2) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithSql(sql2)
    });
  },
  join(array, separator = sql`, `) {
    const nodes = new Array(Math.max(2 * array.length - 1, 0));
    const sep = separator.toOperationNode();
    for (let i = 0;i < array.length; ++i) {
      nodes[2 * i] = parseParameter(array[i]);
      if (i !== array.length - 1) {
        nodes[2 * i + 1] = sep;
      }
    }
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChildren(nodes)
    });
  }
});
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}

// ../../../../node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js
class OperationNodeVisitor {
  nodeStack = [];
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
  #visitors = freeze({
    AliasNode: this.visitAlias.bind(this),
    ColumnNode: this.visitColumn.bind(this),
    IdentifierNode: this.visitIdentifier.bind(this),
    SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
    RawNode: this.visitRaw.bind(this),
    ReferenceNode: this.visitReference.bind(this),
    SelectQueryNode: this.visitSelectQuery.bind(this),
    SelectionNode: this.visitSelection.bind(this),
    TableNode: this.visitTable.bind(this),
    FromNode: this.visitFrom.bind(this),
    SelectAllNode: this.visitSelectAll.bind(this),
    AndNode: this.visitAnd.bind(this),
    OrNode: this.visitOr.bind(this),
    ValueNode: this.visitValue.bind(this),
    ValueListNode: this.visitValueList.bind(this),
    PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
    ParensNode: this.visitParens.bind(this),
    JoinNode: this.visitJoin.bind(this),
    OperatorNode: this.visitOperator.bind(this),
    WhereNode: this.visitWhere.bind(this),
    InsertQueryNode: this.visitInsertQuery.bind(this),
    DeleteQueryNode: this.visitDeleteQuery.bind(this),
    ReturningNode: this.visitReturning.bind(this),
    CreateTableNode: this.visitCreateTable.bind(this),
    AddColumnNode: this.visitAddColumn.bind(this),
    ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
    DropTableNode: this.visitDropTable.bind(this),
    DataTypeNode: this.visitDataType.bind(this),
    OrderByNode: this.visitOrderBy.bind(this),
    OrderByItemNode: this.visitOrderByItem.bind(this),
    GroupByNode: this.visitGroupBy.bind(this),
    GroupByItemNode: this.visitGroupByItem.bind(this),
    UpdateQueryNode: this.visitUpdateQuery.bind(this),
    ColumnUpdateNode: this.visitColumnUpdate.bind(this),
    LimitNode: this.visitLimit.bind(this),
    OffsetNode: this.visitOffset.bind(this),
    OnConflictNode: this.visitOnConflict.bind(this),
    OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
    CreateIndexNode: this.visitCreateIndex.bind(this),
    DropIndexNode: this.visitDropIndex.bind(this),
    ListNode: this.visitList.bind(this),
    PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
    ReferencesNode: this.visitReferences.bind(this),
    CheckConstraintNode: this.visitCheckConstraint.bind(this),
    WithNode: this.visitWith.bind(this),
    CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
    HavingNode: this.visitHaving.bind(this),
    CreateSchemaNode: this.visitCreateSchema.bind(this),
    DropSchemaNode: this.visitDropSchema.bind(this),
    AlterTableNode: this.visitAlterTable.bind(this),
    DropColumnNode: this.visitDropColumn.bind(this),
    RenameColumnNode: this.visitRenameColumn.bind(this),
    AlterColumnNode: this.visitAlterColumn.bind(this),
    ModifyColumnNode: this.visitModifyColumn.bind(this),
    AddConstraintNode: this.visitAddConstraint.bind(this),
    DropConstraintNode: this.visitDropConstraint.bind(this),
    RenameConstraintNode: this.visitRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
    CreateViewNode: this.visitCreateView.bind(this),
    RefreshMaterializedViewNode: this.visitRefreshMaterializedView.bind(this),
    DropViewNode: this.visitDropView.bind(this),
    GeneratedNode: this.visitGenerated.bind(this),
    DefaultValueNode: this.visitDefaultValue.bind(this),
    OnNode: this.visitOn.bind(this),
    ValuesNode: this.visitValues.bind(this),
    SelectModifierNode: this.visitSelectModifier.bind(this),
    CreateTypeNode: this.visitCreateType.bind(this),
    DropTypeNode: this.visitDropType.bind(this),
    ExplainNode: this.visitExplain.bind(this),
    DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.visitAggregateFunction.bind(this),
    OverNode: this.visitOver.bind(this),
    PartitionByNode: this.visitPartitionBy.bind(this),
    PartitionByItemNode: this.visitPartitionByItem.bind(this),
    SetOperationNode: this.visitSetOperation.bind(this),
    BinaryOperationNode: this.visitBinaryOperation.bind(this),
    UnaryOperationNode: this.visitUnaryOperation.bind(this),
    UsingNode: this.visitUsing.bind(this),
    FunctionNode: this.visitFunction.bind(this),
    CaseNode: this.visitCase.bind(this),
    WhenNode: this.visitWhen.bind(this),
    JSONReferenceNode: this.visitJSONReference.bind(this),
    JSONPathNode: this.visitJSONPath.bind(this),
    JSONPathLegNode: this.visitJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
    TupleNode: this.visitTuple.bind(this),
    MergeQueryNode: this.visitMergeQuery.bind(this),
    MatchedNode: this.visitMatched.bind(this),
    AddIndexNode: this.visitAddIndex.bind(this),
    CastNode: this.visitCast.bind(this),
    FetchNode: this.visitFetch.bind(this),
    TopNode: this.visitTop.bind(this),
    OutputNode: this.visitOutput.bind(this),
    OrActionNode: this.visitOrAction.bind(this),
    CollateNode: this.visitCollate.bind(this)
  });
  visitNode = (node) => {
    this.nodeStack.push(node);
    this.#visitors[node.kind](node);
    this.nodeStack.pop();
  };
}

// ../../../../node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
var LIT_WRAP_REGEX = /'/g;

class DefaultQueryCompiler extends OperationNodeVisitor {
  #sql = "";
  #parameters = [];
  get numParameters() {
    return this.#parameters.length;
  }
  compileQuery(node, queryId) {
    this.#sql = "";
    this.#parameters = [];
    this.nodeStack.splice(0, this.nodeStack.length);
    this.visitNode(node);
    return freeze({
      query: node,
      queryId,
      sql: this.getSql(),
      parameters: [...this.#parameters]
    });
  }
  getSql() {
    return this.#sql;
  }
  visitSelectQuery(node) {
    const wrapInParens = this.parentNode !== undefined && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
    if (this.parentNode === undefined && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("select");
    if (node.distinctOn) {
      this.append(" ");
      this.compileDistinctOn(node.distinctOn);
    }
    if (node.frontModifiers?.length) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.selections) {
      this.append(" ");
      this.compileList(node.selections);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.groupBy) {
      this.append(" ");
      this.visitNode(node.groupBy);
    }
    if (node.having) {
      this.append(" ");
      this.visitNode(node.having);
    }
    if (node.setOperations) {
      this.append(" ");
      this.compileList(node.setOperations, " ");
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.offset) {
      this.append(" ");
      this.visitNode(node.offset);
    }
    if (node.fetch) {
      this.append(" ");
      this.visitNode(node.fetch);
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
    }
    if (wrapInParens) {
      this.append(")");
    }
  }
  visitFrom(node) {
    this.append("from ");
    this.compileList(node.froms);
  }
  visitSelection(node) {
    this.visitNode(node.selection);
  }
  visitColumn(node) {
    this.visitNode(node.column);
  }
  compileDistinctOn(expressions) {
    this.append("distinct on (");
    this.compileList(expressions);
    this.append(")");
  }
  compileList(nodes, separator = ", ") {
    const lastIndex = nodes.length - 1;
    for (let i = 0;i <= lastIndex; i++) {
      this.visitNode(nodes[i]);
      if (i < lastIndex) {
        this.append(separator);
      }
    }
  }
  visitWhere(node) {
    this.append("where ");
    this.visitNode(node.where);
  }
  visitHaving(node) {
    this.append("having ");
    this.visitNode(node.having);
  }
  visitInsertQuery(node) {
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append(node.replace ? "replace" : "insert");
    if (node.ignore) {
      logOnce("`InsertQueryNode.ignore` is deprecated. Use `InsertQueryNode.orAction` instead.");
      this.append(" ignore");
    }
    if (node.orAction) {
      this.append(" ");
      this.visitNode(node.orAction);
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.into) {
      this.append(" into ");
      this.visitNode(node.into);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.values) {
      this.append(" ");
      this.visitNode(node.values);
    }
    if (node.defaultValues) {
      this.append(" ");
      this.append("default values");
    }
    if (node.onConflict) {
      this.append(" ");
      this.visitNode(node.onConflict);
    }
    if (node.onDuplicateKey) {
      this.append(" ");
      this.visitNode(node.onDuplicateKey);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitValues(node) {
    this.append("values ");
    this.compileList(node.values);
  }
  visitDeleteQuery(node) {
    const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("delete ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.visitNode(node.from);
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitReturning(node) {
    this.append("returning ");
    this.compileList(node.selections);
  }
  visitAlias(node) {
    this.visitNode(node.node);
    this.append(" as ");
    this.visitNode(node.alias);
  }
  visitReference(node) {
    if (node.table) {
      this.visitNode(node.table);
      this.append(".");
    }
    this.visitNode(node.column);
  }
  visitSelectAll(_) {
    this.append("*");
  }
  visitIdentifier(node) {
    this.append(this.getLeftIdentifierWrapper());
    this.compileUnwrappedIdentifier(node);
    this.append(this.getRightIdentifierWrapper());
  }
  compileUnwrappedIdentifier(node) {
    if (!isString(node.name)) {
      throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
    }
    this.append(this.sanitizeIdentifier(node.name));
  }
  visitAnd(node) {
    this.visitNode(node.left);
    this.append(" and ");
    this.visitNode(node.right);
  }
  visitOr(node) {
    this.visitNode(node.left);
    this.append(" or ");
    this.visitNode(node.right);
  }
  visitValue(node) {
    if (node.immediate) {
      this.appendImmediateValue(node.value);
    } else {
      this.appendValue(node.value);
    }
  }
  visitValueList(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitTuple(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitPrimitiveValueList(node) {
    this.append("(");
    const { values } = node;
    for (let i = 0;i < values.length; ++i) {
      this.appendValue(values[i]);
      if (i !== values.length - 1) {
        this.append(", ");
      }
    }
    this.append(")");
  }
  visitParens(node) {
    this.append("(");
    this.visitNode(node.node);
    this.append(")");
  }
  visitJoin(node) {
    this.append(JOIN_TYPE_SQL[node.joinType]);
    this.append(" ");
    this.visitNode(node.table);
    if (node.on) {
      this.append(" ");
      this.visitNode(node.on);
    }
  }
  visitOn(node) {
    this.append("on ");
    this.visitNode(node.on);
  }
  visitRaw(node) {
    const { sqlFragments, parameters: params } = node;
    for (let i = 0;i < sqlFragments.length; ++i) {
      this.append(sqlFragments[i]);
      if (params.length > i) {
        this.visitNode(params[i]);
      }
    }
  }
  visitOperator(node) {
    this.append(node.operator);
  }
  visitTable(node) {
    this.visitNode(node.table);
  }
  visitSchemableIdentifier(node) {
    if (node.schema) {
      this.visitNode(node.schema);
      this.append(".");
    }
    this.visitNode(node.identifier);
  }
  visitCreateTable(node) {
    this.append("create ");
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.compileList(node.frontModifiers, " ");
      this.append(" ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("table ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.table);
    if (node.selectQuery) {
      this.append(" as ");
      this.visitNode(node.selectQuery);
    } else {
      this.append(" (");
      this.compileList([...node.columns, ...node.constraints ?? []]);
      this.append(")");
      if (node.onCommit) {
        this.append(" on commit ");
        this.append(node.onCommit);
      }
      if (node.endModifiers && node.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
  }
  visitColumnDefinition(node) {
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.column);
    this.append(" ");
    this.visitNode(node.dataType);
    if (node.unsigned) {
      this.append(" unsigned");
    }
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.generated) {
      this.append(" ");
      this.visitNode(node.generated);
    }
    if (node.identity) {
      this.append(" identity");
    }
    if (node.defaultTo) {
      this.append(" ");
      this.visitNode(node.defaultTo);
    }
    if (node.notNull) {
      this.append(" not null");
    }
    if (node.unique) {
      this.append(" unique");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.primaryKey) {
      this.append(" primary key");
    }
    if (node.autoIncrement) {
      this.append(" ");
      this.append(this.getAutoIncrement());
    }
    if (node.references) {
      this.append(" ");
      this.visitNode(node.references);
    }
    if (node.check) {
      this.append(" ");
      this.visitNode(node.check);
    }
    if (node.endModifiers && node.endModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  getAutoIncrement() {
    return "auto_increment";
  }
  visitReferences(node) {
    this.append("references ");
    this.visitNode(node.table);
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitDropTable(node) {
    this.append("drop table ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.table);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitDataType(node) {
    this.append(node.dataType);
  }
  visitOrderBy(node) {
    this.append("order by ");
    this.compileList(node.items);
  }
  visitOrderByItem(node) {
    this.visitNode(node.orderBy);
    if (node.collation) {
      this.append(" ");
      this.visitNode(node.collation);
    }
    if (node.direction) {
      this.append(" ");
      this.visitNode(node.direction);
    }
    if (node.nulls) {
      this.append(" nulls ");
      this.append(node.nulls);
    }
  }
  visitGroupBy(node) {
    this.append("group by ");
    this.compileList(node.items);
  }
  visitGroupByItem(node) {
    this.visitNode(node.groupBy);
  }
  visitUpdateQuery(node) {
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("update ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    if (node.table) {
      this.visitNode(node.table);
      this.append(" ");
    }
    this.append("set ");
    if (node.updates) {
      this.compileList(node.updates);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      if (!node.from) {
        throw new Error("Joins in an update query are only supported as a part of a PostgreSQL 'update set from join' query. If you want to create a MySQL 'update join set' query, see https://kysely.dev/docs/examples/update/my-sql-joins");
      }
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitColumnUpdate(node) {
    this.visitNode(node.column);
    this.append(" = ");
    this.visitNode(node.value);
  }
  visitLimit(node) {
    this.append("limit ");
    this.visitNode(node.limit);
  }
  visitOffset(node) {
    this.append("offset ");
    this.visitNode(node.offset);
  }
  visitOnConflict(node) {
    this.append("on conflict");
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    } else if (node.constraint) {
      this.append(" on constraint ");
      this.visitNode(node.constraint);
    } else if (node.indexExpression) {
      this.append(" (");
      this.visitNode(node.indexExpression);
      this.append(")");
    }
    if (node.indexWhere) {
      this.append(" ");
      this.visitNode(node.indexWhere);
    }
    if (node.doNothing === true) {
      this.append(" do nothing");
    } else if (node.updates) {
      this.append(" do update set ");
      this.compileList(node.updates);
      if (node.updateWhere) {
        this.append(" ");
        this.visitNode(node.updateWhere);
      }
    }
  }
  visitOnDuplicateKey(node) {
    this.append("on duplicate key update ");
    this.compileList(node.updates);
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
  visitDropIndex(node) {
    this.append("drop index ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitCreateSchema(node) {
    this.append("create schema ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.schema);
  }
  visitDropSchema(node) {
    this.append("drop schema ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.schema);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitPrimaryKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("primary key (");
    this.compileList(node.columns);
    this.append(")");
    this.buildDeferrable(node);
  }
  buildDeferrable(node) {
    if (node.deferrable !== undefined) {
      if (node.deferrable) {
        this.append(" deferrable");
      } else {
        this.append(" not deferrable");
      }
    }
    if (node.initiallyDeferred !== undefined) {
      if (node.initiallyDeferred) {
        this.append(" initially deferred");
      } else {
        this.append(" initially immediate");
      }
    }
  }
  visitUniqueConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("unique");
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    this.buildDeferrable(node);
  }
  visitCheckConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("check (");
    this.visitNode(node.expression);
    this.append(")");
  }
  visitForeignKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("foreign key (");
    this.compileList(node.columns);
    this.append(") ");
    this.visitNode(node.references);
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
    this.buildDeferrable(node);
  }
  visitList(node) {
    this.compileList(node.items);
  }
  visitWith(node) {
    this.append("with ");
    if (node.recursive) {
      this.append("recursive ");
    }
    this.compileList(node.expressions);
  }
  visitCommonTableExpression(node) {
    this.visitNode(node.name);
    this.append(" as ");
    if (isBoolean(node.materialized)) {
      if (!node.materialized) {
        this.append("not ");
      }
      this.append("materialized ");
    }
    this.visitNode(node.expression);
  }
  visitCommonTableExpressionName(node) {
    this.visitNode(node.table);
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(")");
    }
  }
  visitAlterTable(node) {
    this.append("alter table ");
    this.visitNode(node.table);
    this.append(" ");
    if (node.renameTo) {
      this.append("rename to ");
      this.visitNode(node.renameTo);
    }
    if (node.setSchema) {
      this.append("set schema ");
      this.visitNode(node.setSchema);
    }
    if (node.addConstraint) {
      this.visitNode(node.addConstraint);
    }
    if (node.dropConstraint) {
      this.visitNode(node.dropConstraint);
    }
    if (node.renameConstraint) {
      this.visitNode(node.renameConstraint);
    }
    if (node.columnAlterations) {
      this.compileColumnAlterations(node.columnAlterations);
    }
    if (node.addIndex) {
      this.visitNode(node.addIndex);
    }
    if (node.dropIndex) {
      this.visitNode(node.dropIndex);
    }
  }
  visitAddColumn(node) {
    this.append("add column ");
    this.visitNode(node.column);
  }
  visitRenameColumn(node) {
    this.append("rename column ");
    this.visitNode(node.column);
    this.append(" to ");
    this.visitNode(node.renameTo);
  }
  visitDropColumn(node) {
    this.append("drop column ");
    this.visitNode(node.column);
  }
  visitAlterColumn(node) {
    this.append("alter column ");
    this.visitNode(node.column);
    this.append(" ");
    if (node.dataType) {
      if (this.announcesNewColumnDataType()) {
        this.append("type ");
      }
      this.visitNode(node.dataType);
      if (node.dataTypeExpression) {
        this.append("using ");
        this.visitNode(node.dataTypeExpression);
      }
    }
    if (node.setDefault) {
      this.append("set default ");
      this.visitNode(node.setDefault);
    }
    if (node.dropDefault) {
      this.append("drop default");
    }
    if (node.setNotNull) {
      this.append("set not null");
    }
    if (node.dropNotNull) {
      this.append("drop not null");
    }
  }
  visitModifyColumn(node) {
    this.append("modify column ");
    this.visitNode(node.column);
  }
  visitAddConstraint(node) {
    this.append("add ");
    this.visitNode(node.constraint);
  }
  visitDropConstraint(node) {
    this.append("drop constraint ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.constraintName);
    if (node.modifier === "cascade") {
      this.append(" cascade");
    } else if (node.modifier === "restrict") {
      this.append(" restrict");
    }
  }
  visitRenameConstraint(node) {
    this.append("rename constraint ");
    this.visitNode(node.oldName);
    this.append(" to ");
    this.visitNode(node.newName);
  }
  visitSetOperation(node) {
    this.append(node.operator);
    this.append(" ");
    if (node.all) {
      this.append("all ");
    }
    this.visitNode(node.expression);
  }
  visitCreateView(node) {
    this.append("create ");
    if (node.orReplace) {
      this.append("or replace ");
    }
    if (node.materialized) {
      this.append("materialized ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("view ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    this.append(" ");
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(") ");
    }
    if (node.as) {
      this.append("as ");
      this.visitNode(node.as);
    }
  }
  visitRefreshMaterializedView(node) {
    this.append("refresh materialized view ");
    if (node.concurrently) {
      this.append("concurrently ");
    }
    this.visitNode(node.name);
    if (node.withNoData) {
      this.append(" with no data");
    } else {
      this.append(" with data");
    }
  }
  visitDropView(node) {
    this.append("drop ");
    if (node.materialized) {
      this.append("materialized ");
    }
    this.append("view ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitGenerated(node) {
    this.append("generated ");
    if (node.always) {
      this.append("always ");
    }
    if (node.byDefault) {
      this.append("by default ");
    }
    this.append("as ");
    if (node.identity) {
      this.append("identity");
    }
    if (node.expression) {
      this.append("(");
      this.visitNode(node.expression);
      this.append(")");
    }
    if (node.stored) {
      this.append(" stored");
    }
  }
  visitDefaultValue(node) {
    this.append("default ");
    this.visitNode(node.defaultValue);
  }
  visitSelectModifier(node) {
    if (node.rawModifier) {
      this.visitNode(node.rawModifier);
    } else {
      this.append(SELECT_MODIFIER_SQL[node.modifier]);
    }
    if (node.of) {
      this.append(" of ");
      this.compileList(node.of, ", ");
    }
  }
  visitCreateType(node) {
    this.append("create type ");
    this.visitNode(node.name);
    if (node.enum) {
      this.append(" as enum ");
      this.visitNode(node.enum);
    }
  }
  visitDropType(node) {
    this.append("drop type ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
  }
  visitExplain(node) {
    this.append("explain");
    if (node.options || node.format) {
      this.append(" ");
      this.append(this.getLeftExplainOptionsWrapper());
      if (node.options) {
        this.visitNode(node.options);
        if (node.format) {
          this.append(this.getExplainOptionsDelimiter());
        }
      }
      if (node.format) {
        this.append("format");
        this.append(this.getExplainOptionAssignment());
        this.append(node.format);
      }
      this.append(this.getRightExplainOptionsWrapper());
    }
  }
  visitDefaultInsertValue(_) {
    this.append("default");
  }
  visitAggregateFunction(node) {
    this.append(node.func);
    this.append("(");
    if (node.distinct) {
      this.append("distinct ");
    }
    this.compileList(node.aggregated);
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    this.append(")");
    if (node.withinGroup) {
      this.append(" within group (");
      this.visitNode(node.withinGroup);
      this.append(")");
    }
    if (node.filter) {
      this.append(" filter(");
      this.visitNode(node.filter);
      this.append(")");
    }
    if (node.over) {
      this.append(" ");
      this.visitNode(node.over);
    }
  }
  visitOver(node) {
    this.append("over(");
    if (node.partitionBy) {
      this.visitNode(node.partitionBy);
      if (node.orderBy) {
        this.append(" ");
      }
    }
    if (node.orderBy) {
      this.visitNode(node.orderBy);
    }
    this.append(")");
  }
  visitPartitionBy(node) {
    this.append("partition by ");
    this.compileList(node.items);
  }
  visitPartitionByItem(node) {
    this.visitNode(node.partitionBy);
  }
  visitBinaryOperation(node) {
    this.visitNode(node.leftOperand);
    this.append(" ");
    this.visitNode(node.operator);
    this.append(" ");
    this.visitNode(node.rightOperand);
  }
  visitUnaryOperation(node) {
    this.visitNode(node.operator);
    if (!this.isMinusOperator(node.operator)) {
      this.append(" ");
    }
    this.visitNode(node.operand);
  }
  isMinusOperator(node) {
    return OperatorNode.is(node) && node.operator === "-";
  }
  visitUsing(node) {
    this.append("using ");
    this.compileList(node.tables);
  }
  visitFunction(node) {
    this.append(node.func);
    this.append("(");
    this.compileList(node.arguments);
    this.append(")");
  }
  visitCase(node) {
    this.append("case");
    if (node.value) {
      this.append(" ");
      this.visitNode(node.value);
    }
    if (node.when) {
      this.append(" ");
      this.compileList(node.when, " ");
    }
    if (node.else) {
      this.append(" else ");
      this.visitNode(node.else);
    }
    this.append(" end");
    if (node.isStatement) {
      this.append(" case");
    }
  }
  visitWhen(node) {
    this.append("when ");
    this.visitNode(node.condition);
    if (node.result) {
      this.append(" then ");
      this.visitNode(node.result);
    }
  }
  visitJSONReference(node) {
    this.visitNode(node.reference);
    this.visitNode(node.traversal);
  }
  visitJSONPath(node) {
    if (node.inOperator) {
      this.visitNode(node.inOperator);
    }
    this.append("'$");
    for (const pathLeg of node.pathLegs) {
      this.visitNode(pathLeg);
    }
    this.append("'");
  }
  visitJSONPathLeg(node) {
    const isArrayLocation = node.type === "ArrayLocation";
    this.append(isArrayLocation ? "[" : ".");
    this.append(String(node.value));
    if (isArrayLocation) {
      this.append("]");
    }
  }
  visitJSONOperatorChain(node) {
    for (let i = 0, len = node.values.length;i < len; i++) {
      if (i === len - 1) {
        this.visitNode(node.operator);
      } else {
        this.append("->");
      }
      this.visitNode(node.values[i]);
    }
  }
  visitMergeQuery(node) {
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("merge ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.append("into ");
    this.visitNode(node.into);
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.whens) {
      this.append(" ");
      this.compileList(node.whens, " ");
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitMatched(node) {
    if (node.not) {
      this.append("not ");
    }
    this.append("matched");
    if (node.bySource) {
      this.append(" by source");
    }
  }
  visitAddIndex(node) {
    this.append("add ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    this.visitNode(node.name);
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
  }
  visitCast(node) {
    this.append("cast(");
    this.visitNode(node.expression);
    this.append(" as ");
    this.visitNode(node.dataType);
    this.append(")");
  }
  visitFetch(node) {
    this.append("fetch next ");
    this.visitNode(node.rowCount);
    this.append(` rows ${node.modifier}`);
  }
  visitOutput(node) {
    this.append("output ");
    this.compileList(node.selections);
  }
  visitTop(node) {
    this.append(`top(${node.expression})`);
    if (node.modifiers) {
      this.append(` ${node.modifiers}`);
    }
  }
  visitOrAction(node) {
    this.append(node.action);
  }
  visitCollate(node) {
    this.append("collate ");
    this.visitNode(node.collation);
  }
  append(str) {
    this.#sql += str;
  }
  appendValue(parameter) {
    this.addParameter(parameter);
    this.append(this.getCurrentParameterPlaceholder());
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getCurrentParameterPlaceholder() {
    return "$" + this.numParameters;
  }
  getLeftExplainOptionsWrapper() {
    return "(";
  }
  getExplainOptionAssignment() {
    return " ";
  }
  getExplainOptionsDelimiter() {
    return ", ";
  }
  getRightExplainOptionsWrapper() {
    return ")";
  }
  sanitizeIdentifier(identifier) {
    const leftWrap = this.getLeftIdentifierWrapper();
    const rightWrap = this.getRightIdentifierWrapper();
    let sanitized = "";
    for (const c of identifier) {
      sanitized += c;
      if (c === leftWrap) {
        sanitized += leftWrap;
      } else if (c === rightWrap) {
        sanitized += rightWrap;
      }
    }
    return sanitized;
  }
  sanitizeStringLiteral(value) {
    return value.replace(LIT_WRAP_REGEX, "''");
  }
  addParameter(parameter) {
    this.#parameters.push(parameter);
  }
  appendImmediateValue(value) {
    if (isString(value)) {
      this.appendStringLiteral(value);
    } else if (isNumber(value) || isBoolean(value)) {
      this.append(value.toString());
    } else if (isNull(value)) {
      this.append("null");
    } else if (isDate(value)) {
      this.appendImmediateValue(value.toISOString());
    } else if (isBigInt(value)) {
      this.appendImmediateValue(value.toString());
    } else {
      throw new Error(`invalid immediate value ${value}`);
    }
  }
  appendStringLiteral(value) {
    this.append("'");
    this.append(this.sanitizeStringLiteral(value));
    this.append("'");
  }
  sortSelectModifiers(arr) {
    arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
    return freeze(arr);
  }
  compileColumnAlterations(columnAlterations) {
    this.compileList(columnAlterations);
  }
  announcesNewColumnDataType() {
    return true;
  }
}
var SELECT_MODIFIER_SQL = freeze({
  ForKeyShare: "for key share",
  ForNoKeyUpdate: "for no key update",
  ForUpdate: "for update",
  ForShare: "for share",
  NoWait: "nowait",
  SkipLocked: "skip locked",
  Distinct: "distinct"
});
var SELECT_MODIFIER_PRIORITY = freeze({
  ForKeyShare: 1,
  ForNoKeyUpdate: 1,
  ForUpdate: 1,
  ForShare: 1,
  NoWait: 2,
  SkipLocked: 2,
  Distinct: 0
});
var JOIN_TYPE_SQL = freeze({
  InnerJoin: "inner join",
  LeftJoin: "left join",
  RightJoin: "right join",
  FullJoin: "full join",
  CrossJoin: "cross join",
  LateralInnerJoin: "inner join lateral",
  LateralLeftJoin: "left join lateral",
  LateralCrossJoin: "cross join lateral",
  OuterApply: "outer apply",
  CrossApply: "cross apply",
  Using: "using"
});

// ../../../../node_modules/kysely/dist/esm/query-compiler/compiled-query.js
var CompiledQuery = freeze({
  raw(sql2, parameters = []) {
    return freeze({
      sql: sql2,
      query: RawNode.createWithSql(sql2),
      parameters: freeze(parameters),
      queryId: createQueryId()
    });
  }
});

// ../../../../node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js
class DialectAdapterBase {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
}

// ../../../../node_modules/kysely/dist/esm/parser/savepoint-parser.js
function parseSavepointCommand(command, savepointName) {
  return RawNode.createWithChildren([
    RawNode.createWithSql(`${command} `),
    IdentifierNode.create(savepointName)
  ]);
}

// ../../../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js
var ID_WRAP_REGEX = /"/g;

class SqliteQueryCompiler extends DefaultQueryCompiler {
  visitOrAction(node) {
    this.append("or ");
    this.append(node.action);
  }
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getAutoIncrement() {
    return "autoincrement";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX, '""');
  }
  visitDefaultInsertValue(_) {
    this.append("null");
  }
}

// ../../../../node_modules/kysely/dist/esm/plugin/noop-plugin.js
class NoopPlugin {
  transformQuery(args) {
    return args.node;
  }
  async transformResult(args) {
    return args.result;
  }
}

// ../../../../node_modules/kysely/dist/esm/migration/migrator.js
var DEFAULT_MIGRATION_TABLE = "kysely_migration";
var DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
var DEFAULT_ALLOW_UNORDERED_MIGRATIONS = false;
var MIGRATION_LOCK_ID = "migration_lock";
var NO_MIGRATIONS = freeze({ __noMigrations__: true });

class Migrator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async getMigrations() {
    const executedMigrations = await this.#doesTableExists(this.#migrationTable) ? await this.#props.db.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationTable).select(["name", "timestamp"]).$narrowType().execute() : [];
    const migrations = await this.#resolveMigrations();
    return migrations.map(({ name, ...migration }) => {
      const executed = executedMigrations.find((it) => it.name === name);
      return {
        name,
        migration,
        executedAt: executed ? new Date(executed.timestamp) : undefined
      };
    });
  }
  async migrateToLatest() {
    return this.#migrate(() => ({ direction: "Up", step: Infinity }));
  }
  async migrateTo(targetMigrationName) {
    return this.#migrate(({ migrations, executedMigrations, pendingMigrations }) => {
      if (targetMigrationName === NO_MIGRATIONS) {
        return { direction: "Down", step: Infinity };
      }
      if (!migrations.find((m) => m.name === targetMigrationName)) {
        throw new Error(`migration "${targetMigrationName}" doesn't exist`);
      }
      const executedIndex = executedMigrations.indexOf(targetMigrationName);
      const pendingIndex = pendingMigrations.findIndex((m) => m.name === targetMigrationName);
      if (executedIndex !== -1) {
        return {
          direction: "Down",
          step: executedMigrations.length - executedIndex - 1
        };
      } else if (pendingIndex !== -1) {
        return { direction: "Up", step: pendingIndex + 1 };
      } else {
        throw new Error(`migration "${targetMigrationName}" isn't executed or pending`);
      }
    });
  }
  async migrateUp() {
    return this.#migrate(() => ({ direction: "Up", step: 1 }));
  }
  async migrateDown() {
    return this.#migrate(() => ({ direction: "Down", step: 1 }));
  }
  async#migrate(getMigrationDirectionAndStep) {
    try {
      await this.#ensureMigrationTablesExists();
      return await this.#runMigrations(getMigrationDirectionAndStep);
    } catch (error) {
      if (error instanceof MigrationResultSetError) {
        return error.resultSet;
      }
      return { error };
    }
  }
  get #migrationTableSchema() {
    return this.#props.migrationTableSchema;
  }
  get #migrationTable() {
    return this.#props.migrationTableName ?? DEFAULT_MIGRATION_TABLE;
  }
  get #migrationLockTable() {
    return this.#props.migrationLockTableName ?? DEFAULT_MIGRATION_LOCK_TABLE;
  }
  get #allowUnorderedMigrations() {
    return this.#props.allowUnorderedMigrations ?? DEFAULT_ALLOW_UNORDERED_MIGRATIONS;
  }
  get #schemaPlugin() {
    if (this.#migrationTableSchema) {
      return new WithSchemaPlugin(this.#migrationTableSchema);
    }
    return new NoopPlugin;
  }
  async#ensureMigrationTablesExists() {
    await this.#ensureMigrationTableSchemaExists();
    await this.#ensureMigrationTableExists();
    await this.#ensureMigrationLockTableExists();
    await this.#ensureLockRowExists();
  }
  async#ensureMigrationTableSchemaExists() {
    if (!this.#migrationTableSchema) {
      return;
    }
    if (!await this.#doesSchemaExists()) {
      try {
        await this.#createIfNotExists(this.#props.db.schema.createSchema(this.#migrationTableSchema));
      } catch (error) {
        if (!await this.#doesSchemaExists()) {
          throw error;
        }
      }
    }
  }
  async#ensureMigrationTableExists() {
    if (!await this.#doesTableExists(this.#migrationTable)) {
      try {
        if (this.#migrationTableSchema) {
          await this.#createIfNotExists(this.#props.db.schema.createSchema(this.#migrationTableSchema));
        }
        await this.#createIfNotExists(this.#props.db.schema.withPlugin(this.#schemaPlugin).createTable(this.#migrationTable).addColumn("name", "varchar(255)", (col) => col.notNull().primaryKey()).addColumn("timestamp", "varchar(255)", (col) => col.notNull()));
      } catch (error) {
        if (!await this.#doesTableExists(this.#migrationTable)) {
          throw error;
        }
      }
    }
  }
  async#ensureMigrationLockTableExists() {
    if (!await this.#doesTableExists(this.#migrationLockTable)) {
      try {
        await this.#createIfNotExists(this.#props.db.schema.withPlugin(this.#schemaPlugin).createTable(this.#migrationLockTable).addColumn("id", "varchar(255)", (col) => col.notNull().primaryKey()).addColumn("is_locked", "integer", (col) => col.notNull().defaultTo(0)));
      } catch (error) {
        if (!await this.#doesTableExists(this.#migrationLockTable)) {
          throw error;
        }
      }
    }
  }
  async#ensureLockRowExists() {
    if (!await this.#doesLockRowExists()) {
      try {
        await this.#props.db.withPlugin(this.#schemaPlugin).insertInto(this.#migrationLockTable).values({ id: MIGRATION_LOCK_ID, is_locked: 0 }).execute();
      } catch (error) {
        if (!await this.#doesLockRowExists()) {
          throw error;
        }
      }
    }
  }
  async#doesSchemaExists() {
    const schemas = await this.#props.db.introspection.getSchemas();
    return schemas.some((it) => it.name === this.#migrationTableSchema);
  }
  async#doesTableExists(tableName) {
    const schema = this.#migrationTableSchema;
    const tables = await this.#props.db.introspection.getTables({
      withInternalKyselyTables: true
    });
    return tables.some((it) => it.name === tableName && (!schema || it.schema === schema));
  }
  async#doesLockRowExists() {
    const lockRow = await this.#props.db.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationLockTable).where("id", "=", MIGRATION_LOCK_ID).select("id").executeTakeFirst();
    return !!lockRow;
  }
  async#runMigrations(getMigrationDirectionAndStep) {
    const adapter = this.#props.db.getExecutor().adapter;
    const lockOptions = freeze({
      lockTable: this.#props.migrationLockTableName ?? DEFAULT_MIGRATION_LOCK_TABLE,
      lockRowId: MIGRATION_LOCK_ID,
      lockTableSchema: this.#props.migrationTableSchema
    });
    const run = async (db3) => {
      try {
        await adapter.acquireMigrationLock(db3, lockOptions);
        const state = await this.#getState(db3);
        if (state.migrations.length === 0) {
          return { results: [] };
        }
        const { direction, step } = getMigrationDirectionAndStep(state);
        if (step <= 0) {
          return { results: [] };
        }
        if (direction === "Down") {
          return await this.#migrateDown(db3, state, step);
        } else if (direction === "Up") {
          return await this.#migrateUp(db3, state, step);
        }
        return { results: [] };
      } finally {
        await adapter.releaseMigrationLock(db3, lockOptions);
      }
    };
    if (adapter.supportsTransactionalDdl && !this.#props.disableTransactions) {
      return this.#props.db.transaction().execute(run);
    } else {
      return this.#props.db.connection().execute(run);
    }
  }
  async#getState(db3) {
    const migrations = await this.#resolveMigrations();
    const executedMigrations = await this.#getExecutedMigrations(db3);
    this.#ensureNoMissingMigrations(migrations, executedMigrations);
    if (!this.#allowUnorderedMigrations) {
      this.#ensureMigrationsInOrder(migrations, executedMigrations);
    }
    const pendingMigrations = this.#getPendingMigrations(migrations, executedMigrations);
    return freeze({
      migrations,
      executedMigrations,
      lastMigration: getLast(executedMigrations),
      pendingMigrations
    });
  }
  #getPendingMigrations(migrations, executedMigrations) {
    return migrations.filter((migration) => {
      return !executedMigrations.includes(migration.name);
    });
  }
  async#resolveMigrations() {
    const allMigrations = await this.#props.provider.getMigrations();
    return Object.keys(allMigrations).sort().map((name) => ({
      ...allMigrations[name],
      name
    }));
  }
  async#getExecutedMigrations(db3) {
    const executedMigrations = await db3.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationTable).select(["name", "timestamp"]).$narrowType().execute();
    const nameComparator = this.#props.nameComparator || ((a, b) => a.localeCompare(b));
    return executedMigrations.sort((a, b) => {
      if (a.timestamp === b.timestamp) {
        return nameComparator(a.name, b.name);
      }
      return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
    }).map((it) => it.name);
  }
  #ensureNoMissingMigrations(migrations, executedMigrations) {
    for (const executed of executedMigrations) {
      if (!migrations.some((it) => it.name === executed)) {
        throw new Error(`corrupted migrations: previously executed migration ${executed} is missing`);
      }
    }
  }
  #ensureMigrationsInOrder(migrations, executedMigrations) {
    for (let i = 0;i < executedMigrations.length; ++i) {
      if (migrations[i].name !== executedMigrations[i]) {
        throw new Error(`corrupted migrations: expected previously executed migration ${executedMigrations[i]} to be at index ${i} but ${migrations[i].name} was found in its place. New migrations must always have a name that comes alphabetically after the last executed migration.`);
      }
    }
  }
  async#migrateDown(db3, state, step) {
    const migrationsToRollback = state.executedMigrations.slice().reverse().slice(0, step).map((name) => {
      return state.migrations.find((it) => it.name === name);
    });
    const results = migrationsToRollback.map((migration) => {
      return {
        migrationName: migration.name,
        direction: "Down",
        status: "NotExecuted"
      };
    });
    for (let i = 0;i < results.length; ++i) {
      const migration = migrationsToRollback[i];
      try {
        if (migration.down) {
          await migration.down(db3);
          await db3.withPlugin(this.#schemaPlugin).deleteFrom(this.#migrationTable).where("name", "=", migration.name).execute();
          results[i] = {
            migrationName: migration.name,
            direction: "Down",
            status: "Success"
          };
        }
      } catch (error) {
        results[i] = {
          migrationName: migration.name,
          direction: "Down",
          status: "Error"
        };
        throw new MigrationResultSetError({
          error,
          results
        });
      }
    }
    return { results };
  }
  async#migrateUp(db3, state, step) {
    const migrationsToRun = state.pendingMigrations.slice(0, step);
    const results = migrationsToRun.map((migration) => {
      return {
        migrationName: migration.name,
        direction: "Up",
        status: "NotExecuted"
      };
    });
    for (let i = 0;i < results.length; i++) {
      const migration = state.pendingMigrations[i];
      try {
        await migration.up(db3);
        await db3.withPlugin(this.#schemaPlugin).insertInto(this.#migrationTable).values({
          name: migration.name,
          timestamp: new Date().toISOString()
        }).execute();
        results[i] = {
          migrationName: migration.name,
          direction: "Up",
          status: "Success"
        };
      } catch (error) {
        results[i] = {
          migrationName: migration.name,
          direction: "Up",
          status: "Error"
        };
        throw new MigrationResultSetError({
          error,
          results
        });
      }
    }
    return { results };
  }
  async#createIfNotExists(qb) {
    if (this.#props.db.getExecutor().adapter.supportsCreateIfNotExists) {
      qb = qb.ifNotExists();
    }
    await qb.execute();
  }
}

class MigrationResultSetError extends Error {
  #resultSet;
  constructor(result) {
    super();
    this.#resultSet = result;
  }
  get resultSet() {
    return this.#resultSet;
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
class SqliteIntrospector {
  #db;
  constructor(db3) {
    this.#db = db3;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    return await this.#getTableMetadata(options);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #tablesQuery(qb, options) {
    let tablesQuery = qb.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
    if (!options.withInternalKyselyTables) {
      tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    return tablesQuery;
  }
  async#getTableMetadata(options) {
    const tablesResult = await this.#tablesQuery(this.#db, options).execute();
    const tableMetadata = await this.#db.with("table_list", (qb) => this.#tablesQuery(qb, options)).selectFrom([
      "table_list as tl",
      sql`pragma_table_info(tl.name)`.as("p")
    ]).select([
      "tl.name as table",
      "p.cid",
      "p.name",
      "p.type",
      "p.notnull",
      "p.dflt_value",
      "p.pk"
    ]).orderBy("tl.name").orderBy("p.cid").execute();
    const columnsByTable = {};
    for (const row of tableMetadata) {
      columnsByTable[row.table] ??= [];
      columnsByTable[row.table].push(row);
    }
    return tablesResult.map(({ name, sql: sql2, type }) => {
      let autoIncrementCol = sql2?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.trimStart()?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
      const columns = columnsByTable[name] ?? [];
      if (!autoIncrementCol) {
        const pkCols = columns.filter((r) => r.pk > 0);
        if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
          autoIncrementCol = pkCols[0].name;
        }
      }
      return {
        name,
        isView: type === "view",
        columns: columns.map((col) => ({
          name: col.name,
          dataType: col.type,
          isNullable: !col.notnull,
          isAutoIncrementing: col.name === autoIncrementCol,
          hasDefaultValue: col.dflt_value != null,
          comment: undefined
        }))
      };
    });
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js
class SqliteAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(_db, _opt) {}
  async releaseMigrationLock(_db, _opt) {}
}

// ../../../../node_modules/kysely/dist/esm/dialect/postgres/postgres-query-compiler.js
var ID_WRAP_REGEX2 = /"/g;

class PostgresQueryCompiler extends DefaultQueryCompiler {
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX2, '""');
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/postgres/postgres-introspector.js
class PostgresIntrospector {
  #db;
  constructor(db3) {
    this.#db = db3;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("pg_catalog.pg_namespace").select("nspname").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.nspname }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query2 = this.#db.selectFrom("pg_catalog.pg_attribute as a").innerJoin("pg_catalog.pg_class as c", "a.attrelid", "c.oid").innerJoin("pg_catalog.pg_namespace as ns", "c.relnamespace", "ns.oid").innerJoin("pg_catalog.pg_type as typ", "a.atttypid", "typ.oid").innerJoin("pg_catalog.pg_namespace as dtns", "typ.typnamespace", "dtns.oid").select([
      "a.attname as column",
      "a.attnotnull as not_null",
      "a.atthasdef as has_default",
      "c.relname as table",
      "c.relkind as table_type",
      "ns.nspname as schema",
      "typ.typname as type",
      "dtns.nspname as type_schema",
      sql`col_description(a.attrelid, a.attnum)`.as("column_description"),
      sql`pg_get_serial_sequence(quote_ident(ns.nspname) || '.' || quote_ident(c.relname), a.attname)`.as("auto_incrementing")
    ]).where("c.relkind", "in", [
      "r",
      "v",
      "p"
    ]).where("ns.nspname", "!~", "^pg_").where("ns.nspname", "!=", "information_schema").where("a.attnum", ">=", 0).where("a.attisdropped", "!=", true).orderBy("ns.nspname").orderBy("c.relname").orderBy("a.attnum").$castTo();
    if (!options.withInternalKyselyTables) {
      query2 = query2.where("c.relname", "!=", DEFAULT_MIGRATION_TABLE).where("c.relname", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query2.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.table && tbl.schema === it.schema);
      if (!table) {
        table = freeze({
          name: it.table,
          isView: it.table_type === "v",
          schema: it.schema,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.column,
        dataType: it.type,
        dataTypeSchema: it.type_schema,
        isNullable: !it.not_null,
        isAutoIncrementing: it.auto_incrementing !== null,
        hasDefaultValue: it.has_default,
        comment: it.column_description ?? undefined
      }));
      return tables;
    }, []);
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/postgres/postgres-adapter.js
var LOCK_ID = BigInt("3853314791062309107");

class PostgresAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return true;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(db3, _opt) {
    await sql`select pg_advisory_xact_lock(${sql.lit(LOCK_ID)})`.execute(db3);
  }
  async releaseMigrationLock(_db, _opt) {}
}

// ../../../../node_modules/kysely/dist/esm/util/stack-trace-utils.js
function extendStackTrace(err2, stackError) {
  if (isStackHolder(err2) && stackError.stack) {
    const stackExtension = stackError.stack.split(`
`).slice(1).join(`
`);
    err2.stack += `
${stackExtension}`;
    return err2;
  }
  return err2;
}
function isStackHolder(obj) {
  return isObject(obj) && isString(obj.stack);
}

// ../../../../node_modules/kysely/dist/esm/dialect/mysql/mysql-driver.js
var PRIVATE_RELEASE_METHOD = Symbol();

class MysqlDriver {
  #config;
  #connections = new WeakMap;
  #pool;
  constructor(configOrPool) {
    this.#config = freeze({ ...configOrPool });
  }
  async init() {
    this.#pool = isFunction(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const rawConnection = await this.#acquireConnection();
    let connection = this.#connections.get(rawConnection);
    if (!connection) {
      connection = new MysqlConnection(rawConnection);
      this.#connections.set(rawConnection, connection);
      if (this.#config?.onCreateConnection) {
        await this.#config.onCreateConnection(connection);
      }
    }
    if (this.#config?.onReserveConnection) {
      await this.#config.onReserveConnection(connection);
    }
    return connection;
  }
  async#acquireConnection() {
    return new Promise((resolve, reject) => {
      this.#pool.getConnection(async (err2, rawConnection) => {
        if (err2) {
          reject(err2);
        } else {
          resolve(rawConnection);
        }
      });
    });
  }
  async beginTransaction(connection, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      const parts = [];
      if (settings.isolationLevel) {
        parts.push(`isolation level ${settings.isolationLevel}`);
      }
      if (settings.accessMode) {
        parts.push(settings.accessMode);
      }
      const sql2 = `set transaction ${parts.join(", ")}`;
      await connection.executeQuery(CompiledQuery.raw(sql2));
    }
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release savepoint", savepointName), createQueryId()));
  }
  async releaseConnection(connection) {
    connection[PRIVATE_RELEASE_METHOD]();
  }
  async destroy() {
    return new Promise((resolve, reject) => {
      this.#pool.end((err2) => {
        if (err2) {
          reject(err2);
        } else {
          resolve();
        }
      });
    });
  }
}
function isOkPacket(obj) {
  return isObject(obj) && "insertId" in obj && "affectedRows" in obj;
}

class MysqlConnection {
  #rawConnection;
  constructor(rawConnection) {
    this.#rawConnection = rawConnection;
  }
  async executeQuery(compiledQuery) {
    try {
      const result = await this.#executeQuery(compiledQuery);
      if (isOkPacket(result)) {
        const { insertId, affectedRows, changedRows } = result;
        return {
          insertId: insertId !== undefined && insertId !== null && insertId.toString() !== "0" ? BigInt(insertId) : undefined,
          numAffectedRows: affectedRows !== undefined && affectedRows !== null ? BigInt(affectedRows) : undefined,
          numChangedRows: changedRows !== undefined && changedRows !== null ? BigInt(changedRows) : undefined,
          rows: []
        };
      } else if (Array.isArray(result)) {
        return {
          rows: result
        };
      }
      return {
        rows: []
      };
    } catch (err2) {
      throw extendStackTrace(err2, new Error);
    }
  }
  #executeQuery(compiledQuery) {
    return new Promise((resolve, reject) => {
      this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters, (err2, result) => {
        if (err2) {
          reject(err2);
        } else {
          resolve(result);
        }
      });
    });
  }
  async* streamQuery(compiledQuery, _chunkSize) {
    const stream = this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters).stream({
      objectMode: true
    });
    try {
      for await (const row of stream) {
        yield {
          rows: [row]
        };
      }
    } catch (ex) {
      if (ex && typeof ex === "object" && "code" in ex && ex.code === "ERR_STREAM_PREMATURE_CLOSE") {
        return;
      }
      throw ex;
    }
  }
  [PRIVATE_RELEASE_METHOD]() {
    this.#rawConnection.release();
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/mysql/mysql-query-compiler.js
var ID_WRAP_REGEX3 = /`/g;

class MysqlQueryCompiler extends DefaultQueryCompiler {
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getExplainOptionAssignment() {
    return "=";
  }
  getExplainOptionsDelimiter() {
    return " ";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return "`";
  }
  getRightIdentifierWrapper() {
    return "`";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX3, "``");
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/mysql/mysql-introspector.js
class MysqlIntrospector {
  #db;
  constructor(db3) {
    this.#db = db3;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("information_schema.schemata").select("schema_name").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.SCHEMA_NAME }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query2 = this.#db.selectFrom("information_schema.columns as columns").innerJoin("information_schema.tables as tables", (b) => b.onRef("columns.TABLE_CATALOG", "=", "tables.TABLE_CATALOG").onRef("columns.TABLE_SCHEMA", "=", "tables.TABLE_SCHEMA").onRef("columns.TABLE_NAME", "=", "tables.TABLE_NAME")).select([
      "columns.COLUMN_NAME",
      "columns.COLUMN_DEFAULT",
      "columns.TABLE_NAME",
      "columns.TABLE_SCHEMA",
      "tables.TABLE_TYPE",
      "columns.IS_NULLABLE",
      "columns.DATA_TYPE",
      "columns.EXTRA",
      "columns.COLUMN_COMMENT"
    ]).where("columns.TABLE_SCHEMA", "=", sql`database()`).orderBy("columns.TABLE_NAME").orderBy("columns.ORDINAL_POSITION").$castTo();
    if (!options.withInternalKyselyTables) {
      query2 = query2.where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_TABLE).where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query2.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.TABLE_NAME);
      if (!table) {
        table = freeze({
          name: it.TABLE_NAME,
          isView: it.TABLE_TYPE === "VIEW",
          schema: it.TABLE_SCHEMA,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.COLUMN_NAME,
        dataType: it.DATA_TYPE,
        isNullable: it.IS_NULLABLE === "YES",
        isAutoIncrementing: it.EXTRA.toLowerCase().includes("auto_increment"),
        hasDefaultValue: it.COLUMN_DEFAULT !== null,
        comment: it.COLUMN_COMMENT === "" ? undefined : it.COLUMN_COMMENT
      }));
      return tables;
    }, []);
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/mysql/mysql-adapter.js
var LOCK_ID2 = "ea586330-2c93-47c8-908d-981d9d270f9d";
var LOCK_TIMEOUT_SECONDS = 60 * 60;

class MysqlAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  async acquireMigrationLock(db3, _opt) {
    await sql`select get_lock(${sql.lit(LOCK_ID2)}, ${sql.lit(LOCK_TIMEOUT_SECONDS)})`.execute(db3);
  }
  async releaseMigrationLock(db3, _opt) {
    await sql`select release_lock(${sql.lit(LOCK_ID2)})`.execute(db3);
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect.js
class MysqlDialect {
  #config;
  constructor(config) {
    this.#config = config;
  }
  createDriver() {
    return new MysqlDriver(this.#config);
  }
  createQueryCompiler() {
    return new MysqlQueryCompiler;
  }
  createAdapter() {
    return new MysqlAdapter;
  }
  createIntrospector(db3) {
    return new MysqlIntrospector(db3);
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/postgres/postgres-driver.js
var PRIVATE_RELEASE_METHOD2 = Symbol();

class PostgresDriver {
  #config;
  #connections = new WeakMap;
  #pool;
  constructor(config) {
    this.#config = freeze({ ...config });
  }
  async init() {
    this.#pool = isFunction(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const client = await this.#pool.connect();
    let connection = this.#connections.get(client);
    if (!connection) {
      connection = new PostgresConnection(client, {
        cursor: this.#config.cursor ?? null
      });
      this.#connections.set(client, connection);
      if (this.#config.onCreateConnection) {
        await this.#config.onCreateConnection(connection);
      }
    }
    if (this.#config.onReserveConnection) {
      await this.#config.onReserveConnection(connection);
    }
    return connection;
  }
  async beginTransaction(connection, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      let sql2 = "start transaction";
      if (settings.isolationLevel) {
        sql2 += ` isolation level ${settings.isolationLevel}`;
      }
      if (settings.accessMode) {
        sql2 += ` ${settings.accessMode}`;
      }
      await connection.executeQuery(CompiledQuery.raw(sql2));
    } else {
      await connection.executeQuery(CompiledQuery.raw("begin"));
    }
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection(connection) {
    connection[PRIVATE_RELEASE_METHOD2]();
  }
  async destroy() {
    if (this.#pool) {
      const pool = this.#pool;
      this.#pool = undefined;
      await pool.end();
    }
  }
}

class PostgresConnection {
  #client;
  #options;
  constructor(client, options) {
    this.#client = client;
    this.#options = options;
  }
  async executeQuery(compiledQuery) {
    try {
      const { command, rowCount, rows } = await this.#client.query(compiledQuery.sql, [...compiledQuery.parameters]);
      return {
        numAffectedRows: command === "INSERT" || command === "UPDATE" || command === "DELETE" || command === "MERGE" ? BigInt(rowCount) : undefined,
        rows: rows ?? []
      };
    } catch (err2) {
      throw extendStackTrace(err2, new Error);
    }
  }
  async* streamQuery(compiledQuery, chunkSize) {
    if (!this.#options.cursor) {
      throw new Error("'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres.");
    }
    if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
      throw new Error("chunkSize must be a positive integer");
    }
    const cursor = this.#client.query(new this.#options.cursor(compiledQuery.sql, compiledQuery.parameters.slice()));
    try {
      while (true) {
        const rows = await cursor.read(chunkSize);
        if (rows.length === 0) {
          break;
        }
        yield {
          rows
        };
      }
    } finally {
      await cursor.close();
    }
  }
  [PRIVATE_RELEASE_METHOD2]() {
    this.#client.release();
  }
}

// ../../../../node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect.js
class PostgresDialect {
  #config;
  constructor(config) {
    this.#config = config;
  }
  createDriver() {
    return new PostgresDriver(this.#config);
  }
  createQueryCompiler() {
    return new PostgresQueryCompiler;
  }
  createAdapter() {
    return new PostgresAdapter;
  }
  createIntrospector(db3) {
    return new PostgresIntrospector(db3);
  }
}

// ../database/src/utils.ts
import { projectPath } from "@stacksjs/path";
// ../../../../node_modules/kysely-bun-worker/dist/index.mjs
import { EventEmitter } from "events";
var BunWorkerDriver = class {
  constructor(config) {
    this.config = config;
  }
  worker;
  connection;
  connectionMutex = new ConnectionMutex;
  mitt;
  async init() {
    this.worker = this.config?.worker ?? new Worker(new URL("./worker", import.meta.url), { type: "module" });
    this.mitt = new EventEmitter;
    this.worker.onmessage = ({ data: [type, data, err2] }) => {
      this.mitt?.emit(type, data, err2);
    };
    this.worker.postMessage([
      0,
      this.config?.url,
      this.config?.cacheStatment
    ]);
    await new Promise((resolve, reject) => {
      this.mitt?.once(0, (_, err2) => err2 ? reject(err2) : resolve());
    });
    this.connection = new BunWorkerConnection(this.worker, this.mitt);
    await this.config?.onCreateConnection?.(this.connection);
  }
  async acquireConnection() {
    await this.connectionMutex.lock();
    return this.connection;
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async releaseConnection() {
    this.connectionMutex.unlock();
  }
  async destroy() {
    if (!this.worker) {
      return;
    }
    this.worker.postMessage([2]);
    return new Promise((resolve, reject) => {
      this.mitt?.once(2, (_, err2) => {
        if (err2) {
          reject(err2);
        } else {
          this.worker?.terminate();
          this.mitt?.removeAllListeners();
          this.mitt = undefined;
          resolve();
        }
      });
    });
  }
};
var ConnectionMutex = class {
  promise;
  resolve;
  async lock() {
    while (this.promise) {
      await this.promise;
    }
    this.promise = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  unlock() {
    const resolve = this.resolve;
    this.promise = undefined;
    this.resolve = undefined;
    resolve?.();
  }
};
var BunWorkerConnection = class {
  constructor(worker, mitt2) {
    this.worker = worker;
    this.mitt = mitt2;
  }
  async* streamQuery(compiledQuery) {
    const { parameters, sql: sql2, query: query2 } = compiledQuery;
    if (!SelectQueryNode.is(query2)) {
      throw new Error("bun:sqlite worker dialect only supported `SELECT` queries");
    }
    this.worker.postMessage([3, sql2, parameters]);
    let done = false;
    let resolveFn;
    let rejectFn;
    const dataListener = (data, err2) => {
      if (err2) {
        rejectFn(err2);
      } else {
        resolveFn({ value: { rows: data }, done: false });
      }
    };
    this.mitt.on(3, dataListener);
    const endListener = (_, err2) => {
      if (err2) {
        rejectFn(err2);
      } else {
        resolveFn({ value: undefined, done: true });
      }
    };
    this.mitt.on(4, endListener);
    while (!done) {
      const result = await new Promise((res, rej) => {
        resolveFn = res;
        rejectFn = rej;
      });
      if (result.done) {
        done = true;
        this.mitt?.off(3, dataListener);
        this.mitt?.off(4, endListener);
      } else {
        yield result.value;
      }
    }
  }
  async executeQuery(compiledQuery) {
    const { parameters, sql: sql2, query: query2 } = compiledQuery;
    const isSelect = SelectQueryNode.is(query2);
    this.worker.postMessage([1, isSelect, sql2, parameters]);
    return new Promise((resolve, reject) => {
      if (!this.mitt) {
        reject(new Error("kysely instance has been destroyed"));
      }
      this.mitt.once(1, (data, err2) => !err2 && data ? resolve(data) : reject(err2));
    });
  }
};
var BunWorkerDialect = class {
  constructor(config) {
    this.config = config;
  }
  createDriver() {
    return new BunWorkerDriver(this.config);
  }
  createQueryCompiler() {
    return new SqliteQueryCompiler;
  }
  createAdapter() {
    return new SqliteAdapter;
  }
  createIntrospector(db3) {
    return new SqliteIntrospector(db3);
  }
};

// ../database/src/utils.ts
var import_mysql2 = __toESM(require_mysql2(), 1);

// ../../../../node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib13(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types2 = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;

// ../database/src/utils.ts
var appEnv = "local";
var dbDriver = "mysql";
var dbConfig = {
  connections: {
    sqlite: {
      database: "database/stacks.sqlite",
      prefix: ""
    },
    mysql: {
      name: "stacks",
      host: "127.0.0.1",
      username: "root",
      password: "",
      port: 3306,
      prefix: ""
    },
    postgres: {
      name: "stacks",
      host: "127.0.0.1",
      username: "",
      password: "",
      port: 5432,
      prefix: ""
    }
  }
};
function getEnv() {
  return appEnv;
}
function getDriver() {
  return dbDriver;
}
function getDatabaseConfig() {
  return dbConfig;
}
function getDialect() {
  const appEnv2 = getEnv();
  const driver = getDriver();
  const database3 = getDatabaseConfig();
  if (driver === "sqlite") {
    const defaultName = appEnv2 !== "testing" ? "database/stacks.sqlite" : "database/stacks_testing.sqlite";
    const sqliteDbName = database3.connections?.sqlite?.database ?? defaultName;
    const dbPath = projectPath(sqliteDbName);
    return new BunWorkerDialect({
      url: dbPath
    });
  }
  if (driver === "mysql") {
    return new MysqlDialect({
      pool: import_mysql2.createPool({
        database: database3.connections?.mysql?.name || "stacks",
        host: database3.connections?.mysql?.host ?? "127.0.0.1",
        user: database3.connections?.mysql?.username ?? "root",
        password: database3.connections?.mysql?.password ?? "",
        port: database3.connections?.mysql?.port ?? 3306
      })
    });
  }
  if (driver === "postgres") {
    const pgDbName = database3.connections?.postgres?.name ?? "stacks";
    const finalPgDbName = appEnv2 === "testing" ? `${pgDbName}_testing` : pgDbName;
    return new PostgresDialect({
      pool: new Pool({
        database: finalPgDbName,
        host: database3.connections?.postgres?.host ?? "127.0.0.1",
        user: database3.connections?.postgres?.username ?? "",
        password: database3.connections?.postgres?.password ?? "",
        port: database3.connections?.postgres?.port ?? 5432
      })
    });
  }
  throw new Error(`Unsupported driver: ${driver}`);
}
var dbNow = sql`now()`;
var db = new Kysely({
  dialect: getDialect()
});
// ../database/src/schema.ts
import { log as log12 } from "@stacksjs/logging";

// ../database/src/table.ts
import { log as log11 } from "@stacksjs/logging";
// ../database/src/seeder.ts
import { italic as italic7, log as log14 } from "@stacksjs/cli";

// ../../../../node_modules/@faker-js/faker/dist/chunk-KERBADJJ.js
var e = [{ name: "Aegean Airlines", iataCode: "A3" }, { name: "Aeroflot", iataCode: "SU" }, { name: "Aerolineas Argentinas", iataCode: "AR" }, { name: "Aeromexico", iataCode: "AM" }, { name: "Air Algerie", iataCode: "AH" }, { name: "Air Arabia", iataCode: "G9" }, { name: "Air Canada", iataCode: "AC" }, { name: "Air China", iataCode: "CA" }, { name: "Air Europa", iataCode: "UX" }, { name: "Air France", iataCode: "AF" }, { name: "Air India", iataCode: "AI" }, { name: "Air Mauritius", iataCode: "MK" }, { name: "Air New Zealand", iataCode: "NZ" }, { name: "Air Niugini", iataCode: "PX" }, { name: "Air Tahiti", iataCode: "VT" }, { name: "Air Tahiti Nui", iataCode: "TN" }, { name: "Air Transat", iataCode: "TS" }, { name: "AirAsia X", iataCode: "D7" }, { name: "AirAsia", iataCode: "AK" }, { name: "Aircalin", iataCode: "SB" }, { name: "Alaska Airlines", iataCode: "AS" }, { name: "Alitalia", iataCode: "AZ" }, { name: "All Nippon Airways", iataCode: "NH" }, { name: "Allegiant Air", iataCode: "G4" }, { name: "American Airlines", iataCode: "AA" }, { name: "Asiana Airlines", iataCode: "OZ" }, { name: "Avianca", iataCode: "AV" }, { name: "Azul Linhas Aereas Brasileiras", iataCode: "AD" }, { name: "Azur Air", iataCode: "ZF" }, { name: "Beijing Capital Airlines", iataCode: "JD" }, { name: "Boliviana de Aviacion", iataCode: "OB" }, { name: "British Airways", iataCode: "BA" }, { name: "Cathay Pacific", iataCode: "CX" }, { name: "Cebu Pacific Air", iataCode: "5J" }, { name: "China Airlines", iataCode: "CI" }, { name: "China Eastern Airlines", iataCode: "MU" }, { name: "China Southern Airlines", iataCode: "CZ" }, { name: "Condor", iataCode: "DE" }, { name: "Copa Airlines", iataCode: "CM" }, { name: "Delta Air Lines", iataCode: "DL" }, { name: "Easyfly", iataCode: "VE" }, { name: "EasyJet", iataCode: "U2" }, { name: "EcoJet", iataCode: "8J" }, { name: "Egyptair", iataCode: "MS" }, { name: "El Al", iataCode: "LY" }, { name: "Emirates Airlines", iataCode: "EK" }, { name: "Ethiopian Airlines", iataCode: "ET" }, { name: "Etihad Airways", iataCode: "EY" }, { name: "EVA Air", iataCode: "BR" }, { name: "Fiji Airways", iataCode: "FJ" }, { name: "Finnair", iataCode: "AY" }, { name: "Flybondi", iataCode: "FO" }, { name: "Flydubai", iataCode: "FZ" }, { name: "FlySafair", iataCode: "FA" }, { name: "Frontier Airlines", iataCode: "F9" }, { name: "Garuda Indonesia", iataCode: "GA" }, { name: "Go First", iataCode: "G8" }, { name: "Gol Linhas Aereas Inteligentes", iataCode: "G3" }, { name: "Hainan Airlines", iataCode: "HU" }, { name: "Hawaiian Airlines", iataCode: "HA" }, { name: "IndiGo Airlines", iataCode: "6E" }, { name: "Japan Airlines", iataCode: "JL" }, { name: "Jeju Air", iataCode: "7C" }, { name: "Jet2", iataCode: "LS" }, { name: "JetBlue Airways", iataCode: "B6" }, { name: "JetSMART", iataCode: "JA" }, { name: "Juneyao Airlines", iataCode: "HO" }, { name: "Kenya Airways", iataCode: "KQ" }, { name: "KLM Royal Dutch Airlines", iataCode: "KL" }, { name: "Korean Air", iataCode: "KE" }, { name: "Kulula.com", iataCode: "MN" }, { name: "LATAM Airlines", iataCode: "LA" }, { name: "Lion Air", iataCode: "JT" }, { name: "LOT Polish Airlines", iataCode: "LO" }, { name: "Lufthansa", iataCode: "LH" }, { name: "Libyan Airlines", iataCode: "LN" }, { name: "Linea Aerea Amaszonas", iataCode: "Z8" }, { name: "Malaysia Airlines", iataCode: "MH" }, { name: "Nordwind Airlines", iataCode: "N4" }, { name: "Norwegian Air Shuttle", iataCode: "DY" }, { name: "Oman Air", iataCode: "WY" }, { name: "Pakistan International Airlines", iataCode: "PK" }, { name: "Pegasus Airlines", iataCode: "PC" }, { name: "Philippine Airlines", iataCode: "PR" }, { name: "Qantas Group", iataCode: "QF" }, { name: "Qatar Airways", iataCode: "QR" }, { name: "Republic Airways", iataCode: "YX" }, { name: "Royal Air Maroc", iataCode: "AT" }, { name: "Ryanair", iataCode: "FR" }, { name: "S7 Airlines", iataCode: "S7" }, { name: "SAS", iataCode: "SK" }, { name: "Satena", iataCode: "9R" }, { name: "Saudia", iataCode: "SV" }, { name: "Shandong Airlines", iataCode: "SC" }, { name: "Sichuan Airlines", iataCode: "3U" }, { name: "Singapore Airlines", iataCode: "SQ" }, { name: "Sky Airline", iataCode: "H2" }, { name: "SkyWest Airlines", iataCode: "OO" }, { name: "South African Airways", iataCode: "SA" }, { name: "Southwest Airlines", iataCode: "WN" }, { name: "SpiceJet", iataCode: "SG" }, { name: "Spirit Airlines", iataCode: "NK" }, { name: "Spring Airlines", iataCode: "9S" }, { name: "SriLankan Airlines", iataCode: "UL" }, { name: "Star Peru", iataCode: "2I" }, { name: "Sun Country Airlines", iataCode: "SY" }, { name: "SunExpress", iataCode: "XQ" }, { name: "TAP Air Portugal", iataCode: "TP" }, { name: "Thai AirAsia", iataCode: "FD" }, { name: "Thai Airways", iataCode: "TG" }, { name: "TUI Airways", iataCode: "BY" }, { name: "Tunisair", iataCode: "TU" }, { name: "Turkish Airlines", iataCode: "TK" }, { name: "Ukraine International", iataCode: "PS" }, { name: "United Airlines", iataCode: "UA" }, { name: "Ural Airlines", iataCode: "U6" }, { name: "VietJet Air", iataCode: "VJ" }, { name: "Vietnam Airlines", iataCode: "VN" }, { name: "Virgin Atlantic Airways", iataCode: "VS" }, { name: "Virgin Australia", iataCode: "VA" }, { name: "VivaAerobus", iataCode: "VB" }, { name: "VOEPASS Linhas Aereas", iataCode: "2Z" }, { name: "Volaris", iataCode: "Y4" }, { name: "WestJet", iataCode: "WS" }, { name: "Wingo", iataCode: "P5" }, { name: "Wizz Air", iataCode: "W6" }];
var a = [{ name: "Aerospatiale/BAC Concorde", iataTypeCode: "SSC" }, { name: "Airbus A300", iataTypeCode: "AB3" }, { name: "Airbus A310", iataTypeCode: "310" }, { name: "Airbus A310-200", iataTypeCode: "312" }, { name: "Airbus A310-300", iataTypeCode: "313" }, { name: "Airbus A318", iataTypeCode: "318" }, { name: "Airbus A319", iataTypeCode: "319" }, { name: "Airbus A319neo", iataTypeCode: "31N" }, { name: "Airbus A320", iataTypeCode: "320" }, { name: "Airbus A320neo", iataTypeCode: "32N" }, { name: "Airbus A321", iataTypeCode: "321" }, { name: "Airbus A321neo", iataTypeCode: "32Q" }, { name: "Airbus A330", iataTypeCode: "330" }, { name: "Airbus A330-200", iataTypeCode: "332" }, { name: "Airbus A330-300", iataTypeCode: "333" }, { name: "Airbus A330-800neo", iataTypeCode: "338" }, { name: "Airbus A330-900neo", iataTypeCode: "339" }, { name: "Airbus A340", iataTypeCode: "340" }, { name: "Airbus A340-200", iataTypeCode: "342" }, { name: "Airbus A340-300", iataTypeCode: "343" }, { name: "Airbus A340-500", iataTypeCode: "345" }, { name: "Airbus A340-600", iataTypeCode: "346" }, { name: "Airbus A350", iataTypeCode: "350" }, { name: "Airbus A350-900", iataTypeCode: "359" }, { name: "Airbus A350-1000", iataTypeCode: "351" }, { name: "Airbus A380", iataTypeCode: "380" }, { name: "Airbus A380-800", iataTypeCode: "388" }, { name: "Antonov An-12", iataTypeCode: "ANF" }, { name: "Antonov An-24", iataTypeCode: "AN4" }, { name: "Antonov An-26", iataTypeCode: "A26" }, { name: "Antonov An-28", iataTypeCode: "A28" }, { name: "Antonov An-30", iataTypeCode: "A30" }, { name: "Antonov An-32", iataTypeCode: "A32" }, { name: "Antonov An-72", iataTypeCode: "AN7" }, { name: "Antonov An-124 Ruslan", iataTypeCode: "A4F" }, { name: "Antonov An-140", iataTypeCode: "A40" }, { name: "Antonov An-148", iataTypeCode: "A81" }, { name: "Antonov An-158", iataTypeCode: "A58" }, { name: "Antonov An-225 Mriya", iataTypeCode: "A5F" }, { name: "Boeing 707", iataTypeCode: "703" }, { name: "Boeing 717", iataTypeCode: "717" }, { name: "Boeing 720B", iataTypeCode: "B72" }, { name: "Boeing 727", iataTypeCode: "727" }, { name: "Boeing 727-100", iataTypeCode: "721" }, { name: "Boeing 727-200", iataTypeCode: "722" }, { name: "Boeing 737 MAX 7", iataTypeCode: "7M7" }, { name: "Boeing 737 MAX 8", iataTypeCode: "7M8" }, { name: "Boeing 737 MAX 9", iataTypeCode: "7M9" }, { name: "Boeing 737 MAX 10", iataTypeCode: "7MJ" }, { name: "Boeing 737", iataTypeCode: "737" }, { name: "Boeing 737-100", iataTypeCode: "731" }, { name: "Boeing 737-200", iataTypeCode: "732" }, { name: "Boeing 737-300", iataTypeCode: "733" }, { name: "Boeing 737-400", iataTypeCode: "734" }, { name: "Boeing 737-500", iataTypeCode: "735" }, { name: "Boeing 737-600", iataTypeCode: "736" }, { name: "Boeing 737-700", iataTypeCode: "73G" }, { name: "Boeing 737-800", iataTypeCode: "738" }, { name: "Boeing 737-900", iataTypeCode: "739" }, { name: "Boeing 747", iataTypeCode: "747" }, { name: "Boeing 747-100", iataTypeCode: "741" }, { name: "Boeing 747-200", iataTypeCode: "742" }, { name: "Boeing 747-300", iataTypeCode: "743" }, { name: "Boeing 747-400", iataTypeCode: "744" }, { name: "Boeing 747-400D", iataTypeCode: "74J" }, { name: "Boeing 747-8", iataTypeCode: "748" }, { name: "Boeing 747SP", iataTypeCode: "74L" }, { name: "Boeing 747SR", iataTypeCode: "74R" }, { name: "Boeing 757", iataTypeCode: "757" }, { name: "Boeing 757-200", iataTypeCode: "752" }, { name: "Boeing 757-300", iataTypeCode: "753" }, { name: "Boeing 767", iataTypeCode: "767" }, { name: "Boeing 767-200", iataTypeCode: "762" }, { name: "Boeing 767-300", iataTypeCode: "763" }, { name: "Boeing 767-400", iataTypeCode: "764" }, { name: "Boeing 777", iataTypeCode: "777" }, { name: "Boeing 777-200", iataTypeCode: "772" }, { name: "Boeing 777-200LR", iataTypeCode: "77L" }, { name: "Boeing 777-300", iataTypeCode: "773" }, { name: "Boeing 777-300ER", iataTypeCode: "77W" }, { name: "Boeing 787", iataTypeCode: "787" }, { name: "Boeing 787-8", iataTypeCode: "788" }, { name: "Boeing 787-9", iataTypeCode: "789" }, { name: "Boeing 787-10", iataTypeCode: "781" }, { name: "Canadair Challenger", iataTypeCode: "CCJ" }, { name: "Canadair CL-44", iataTypeCode: "CL4" }, { name: "Canadair Regional Jet 100", iataTypeCode: "CR1" }, { name: "Canadair Regional Jet 200", iataTypeCode: "CR2" }, { name: "Canadair Regional Jet 700", iataTypeCode: "CR7" }, { name: "Canadair Regional Jet 705", iataTypeCode: "CRA" }, { name: "Canadair Regional Jet 900", iataTypeCode: "CR9" }, { name: "Canadair Regional Jet 1000", iataTypeCode: "CRK" }, { name: "De Havilland Canada DHC-2 Beaver", iataTypeCode: "DHP" }, { name: "De Havilland Canada DHC-2 Turbo-Beaver", iataTypeCode: "DHR" }, { name: "De Havilland Canada DHC-3 Otter", iataTypeCode: "DHL" }, { name: "De Havilland Canada DHC-4 Caribou", iataTypeCode: "DHC" }, { name: "De Havilland Canada DHC-6 Twin Otter", iataTypeCode: "DHT" }, { name: "De Havilland Canada DHC-7 Dash 7", iataTypeCode: "DH7" }, { name: "De Havilland Canada DHC-8-100 Dash 8 / 8Q", iataTypeCode: "DH1" }, { name: "De Havilland Canada DHC-8-200 Dash 8 / 8Q", iataTypeCode: "DH2" }, { name: "De Havilland Canada DHC-8-300 Dash 8 / 8Q", iataTypeCode: "DH3" }, { name: "De Havilland Canada DHC-8-400 Dash 8Q", iataTypeCode: "DH4" }, { name: "De Havilland DH.104 Dove", iataTypeCode: "DHD" }, { name: "De Havilland DH.114 Heron", iataTypeCode: "DHH" }, { name: "Douglas DC-3", iataTypeCode: "D3F" }, { name: "Douglas DC-6", iataTypeCode: "D6F" }, { name: "Douglas DC-8-50", iataTypeCode: "D8T" }, { name: "Douglas DC-8-62", iataTypeCode: "D8L" }, { name: "Douglas DC-8-72", iataTypeCode: "D8Q" }, { name: "Douglas DC-9-10", iataTypeCode: "D91" }, { name: "Douglas DC-9-20", iataTypeCode: "D92" }, { name: "Douglas DC-9-30", iataTypeCode: "D93" }, { name: "Douglas DC-9-40", iataTypeCode: "D94" }, { name: "Douglas DC-9-50", iataTypeCode: "D95" }, { name: "Douglas DC-10", iataTypeCode: "D10" }, { name: "Douglas DC-10-10", iataTypeCode: "D1X" }, { name: "Douglas DC-10-30", iataTypeCode: "D1Y" }, { name: "Embraer 170", iataTypeCode: "E70" }, { name: "Embraer 175", iataTypeCode: "E75" }, { name: "Embraer 190", iataTypeCode: "E90" }, { name: "Embraer 195", iataTypeCode: "E95" }, { name: "Embraer E190-E2", iataTypeCode: "290" }, { name: "Embraer E195-E2", iataTypeCode: "295" }, { name: "Embraer EMB.110 Bandeirante", iataTypeCode: "EMB" }, { name: "Embraer EMB.120 Brasilia", iataTypeCode: "EM2" }, { name: "Embraer Legacy 600", iataTypeCode: "ER3" }, { name: "Embraer Phenom 100", iataTypeCode: "EP1" }, { name: "Embraer Phenom 300", iataTypeCode: "EP3" }, { name: "Embraer RJ135", iataTypeCode: "ER3" }, { name: "Embraer RJ140", iataTypeCode: "ERD" }, { name: "Embraer RJ145 Amazon", iataTypeCode: "ER4" }, { name: "Ilyushin IL18", iataTypeCode: "IL8" }, { name: "Ilyushin IL62", iataTypeCode: "IL6" }, { name: "Ilyushin IL76", iataTypeCode: "IL7" }, { name: "Ilyushin IL86", iataTypeCode: "ILW" }, { name: "Ilyushin IL96-300", iataTypeCode: "I93" }, { name: "Ilyushin IL114", iataTypeCode: "I14" }, { name: "Lockheed L-182 / 282 / 382 (L-100) Hercules", iataTypeCode: "LOH" }, { name: "Lockheed L-188 Electra", iataTypeCode: "LOE" }, { name: "Lockheed L-1011 Tristar", iataTypeCode: "L10" }, { name: "Lockheed L-1049 Super Constellation", iataTypeCode: "L49" }, { name: "McDonnell Douglas MD11", iataTypeCode: "M11" }, { name: "McDonnell Douglas MD80", iataTypeCode: "M80" }, { name: "McDonnell Douglas MD81", iataTypeCode: "M81" }, { name: "McDonnell Douglas MD82", iataTypeCode: "M82" }, { name: "McDonnell Douglas MD83", iataTypeCode: "M83" }, { name: "McDonnell Douglas MD87", iataTypeCode: "M87" }, { name: "McDonnell Douglas MD88", iataTypeCode: "M88" }, { name: "McDonnell Douglas MD90", iataTypeCode: "M90" }, { name: "Sukhoi Superjet 100-95", iataTypeCode: "SU9" }, { name: "Tupolev Tu-134", iataTypeCode: "TU3" }, { name: "Tupolev Tu-154", iataTypeCode: "TU5" }, { name: "Tupolev Tu-204", iataTypeCode: "T20" }, { name: "Yakovlev Yak-40", iataTypeCode: "YK4" }, { name: "Yakovlev Yak-42", iataTypeCode: "YK2" }];
var r = [{ name: "Adelaide International Airport", iataCode: "ADL" }, { name: "Adolfo Suarez Madrid-Barajas Airport", iataCode: "MAD" }, { name: "Aeroparque Jorge Newbery Airport", iataCode: "AEP" }, { name: "Afonso Pena International Airport", iataCode: "CWB" }, { name: "Alfonso Bonilla Aragon International Airport", iataCode: "CLO" }, { name: "Amsterdam Airport Schiphol", iataCode: "AMS" }, { name: "Arturo Merino Benitez International Airport", iataCode: "SCL" }, { name: "Auckland International Airport", iataCode: "AKL" }, { name: "Beijing Capital International Airport", iataCode: "PEK" }, { name: "Belem Val de Cans International Airport", iataCode: "BEL" }, { name: "Belo Horizonte Tancredo Neves International Airport", iataCode: "CNF" }, { name: "Berlin-Tegel Airport", iataCode: "TXL" }, { name: "Bole International Airport", iataCode: "ADD" }, { name: "Brasilia-Presidente Juscelino Kubitschek International Airport", iataCode: "BSB" }, { name: "Brisbane International Airport", iataCode: "BNE" }, { name: "Brussels Airport", iataCode: "BRU" }, { name: "Cairns Airport", iataCode: "CNS" }, { name: "Cairo International Airport", iataCode: "CAI" }, { name: "Canberra Airport", iataCode: "CBR" }, { name: "Capetown International Airport", iataCode: "CPT" }, { name: "Charles de Gaulle International Airport", iataCode: "CDG" }, { name: "Charlotte Douglas International Airport", iataCode: "CLT" }, { name: "Chengdu Shuangliu International Airport", iataCode: "CTU" }, { name: "Chhatrapati Shivaji International Airport", iataCode: "BOM" }, { name: "Chicago O'Hare International Airport", iataCode: "ORD" }, { name: "Chongqing Jiangbei International Airport", iataCode: "CKG" }, { name: "Christchurch International Airport", iataCode: "CHC" }, { name: "Copenhagen Kastrup Airport", iataCode: "CPH" }, { name: "Dallas Fort Worth International Airport", iataCode: "DFW" }, { name: "Daniel K. Inouye International Airport", iataCode: "HNL" }, { name: "Denver International Airport", iataCode: "DEN" }, { name: "Don Mueang International Airport", iataCode: "DMK" }, { name: "Dubai International Airport", iataCode: "DXB" }, { name: "Dublin Airport", iataCode: "DUB" }, { name: "Dusseldorf Airport", iataCode: "DUS" }, { name: "El Dorado International Airport", iataCode: "BOG" }, { name: "Eleftherios Venizelos International Airport", iataCode: "ATH" }, { name: "Faa'a International Airport", iataCode: "PPT" }, { name: "Fort Lauderdale Hollywood International Airport", iataCode: "FLL" }, { name: "Fortaleza Pinto Martins International Airport", iataCode: "FOR" }, { name: "Frankfurt am Main Airport", iataCode: "FRA" }, { name: "George Bush Intercontinental Houston Airport", iataCode: "IAH" }, { name: "Gold Coast Airport", iataCode: "OOL" }, { name: "Guarulhos - Governador Andre Franco Montoro International Airport", iataCode: "GRU" }, { name: "Hartsfield-Jackson Atlanta International Airport", iataCode: "ATL" }, { name: "Helsinki Vantaa Airport", iataCode: "HEL" }, { name: "Hobart International Airport", iataCode: "HBA" }, { name: "Hong Kong International Airport", iataCode: "HKG" }, { name: "Houari Boumediene Airport", iataCode: "ALG" }, { name: "Hurgada International Airport", iataCode: "HRG" }, { name: "Incheon International Airport", iataCode: "ICN" }, { name: "Indira Gandhi International Airport", iataCode: "DEL" }, { name: "Istanbul Airport", iataCode: "IST" }, { name: "Jacksons International Airport", iataCode: "POM" }, { name: "Jeju International Airport", iataCode: "CJU" }, { name: "John F Kennedy International Airport", iataCode: "JFK" }, { name: "Jorge Chavez International Airport", iataCode: "LIM" }, { name: "Jose Maria Cordova International Airport", iataCode: "MDE" }, { name: "Josep Tarradellas Barcelona-El Prat Airport", iataCode: "BCN" }, { name: "Kahului Airport", iataCode: "OGG" }, { name: "King Abdulaziz International Airport", iataCode: "JED" }, { name: "Kuala Lumpur International Airport", iataCode: "KUL" }, { name: "Kunming Changshui International Airport", iataCode: "KMG" }, { name: "La Tontouta International Airport", iataCode: "NOU" }, { name: "Leonardo da Vinci-Fiumicino Airport", iataCode: "FCO" }, { name: "London Heathrow Airport", iataCode: "LHR" }, { name: "Los Angeles International Airport", iataCode: "LAX" }, { name: "McCarran International Airport", iataCode: "LAS" }, { name: "Melbourne International Airport", iataCode: "MEL" }, { name: "Mexico City International Airport", iataCode: "MEX" }, { name: "Miami International Airport", iataCode: "MIA" }, { name: "Ministro Pistarini International Airport", iataCode: "EZE" }, { name: "Minneapolis-St Paul International/Wold-Chamberlain Airport", iataCode: "MSP" }, { name: "Mohammed V International Airport", iataCode: "CMN" }, { name: "Moscow Domodedovo Airport", iataCode: "DME" }, { name: "Munich Airport", iataCode: "MUC" }, { name: "Murtala Muhammed International Airport", iataCode: "LOS" }, { name: "Nadi International Airport", iataCode: "NAN" }, { name: "Nairobi Jomo Kenyatta International Airport", iataCode: "NBO" }, { name: "Narita International Airport", iataCode: "NRT" }, { name: "Newark Liberty International Airport", iataCode: "EWR" }, { name: "Ninoy Aquino International Airport", iataCode: "MNL" }, { name: "Noumea Magenta Airport", iataCode: "GEA" }, { name: "O. R. Tambo International Airport", iataCode: "JNB" }, { name: "Orlando International Airport", iataCode: "MCO" }, { name: "Oslo Lufthavn", iataCode: "OSL" }, { name: "Perth Airport", iataCode: "PER" }, { name: "Phoenix Sky Harbor International Airport", iataCode: "PHX" }, { name: "Recife Guararapes-Gilberto Freyre International Airport", iataCode: "REC" }, { name: "Rio de Janeiro Galeao International Airport", iataCode: "GIG" }, { name: "Salgado Filho International Airport", iataCode: "POA" }, { name: "Salvador Deputado Luis Eduardo Magalhaes International Airport", iataCode: "SSA" }, { name: "San Francisco International Airport", iataCode: "SFO" }, { name: "Santos Dumont Airport", iataCode: "SDU" }, { name: "Sao Paulo-Congonhas Airport", iataCode: "CGH" }, { name: "Seattle Tacoma International Airport", iataCode: "SEA" }, { name: "Shanghai Hongqiao International Airport", iataCode: "SHA" }, { name: "Shanghai Pudong International Airport", iataCode: "PVG" }, { name: "Shenzhen Bao'an International Airport", iataCode: "SZX" }, { name: "Sheremetyevo International Airport", iataCode: "SVO" }, { name: "Singapore Changi Airport", iataCode: "SIN" }, { name: "Soekarno-Hatta International Airport", iataCode: "CGK" }, { name: 'Stockholm-Arlanda Airport"', iataCode: "ARN" }, { name: "Suvarnabhumi Airport", iataCode: "BKK" }, { name: "Sydney Kingsford Smith International Airport", iataCode: "SYD" }, { name: "Taiwan Taoyuan International Airport", iataCode: "TPE" }, { name: "Tan Son Nhat International Airport", iataCode: "SGN" }, { name: "Tokyo Haneda International Airport", iataCode: "HND" }, { name: "Toronto Pearson International Airport", iataCode: "YYZ" }, { name: "Tunis Carthage International Airport", iataCode: "TUN" }, { name: "Vancouver International Airport", iataCode: "YVR" }, { name: "Vienna International Airport", iataCode: "VIE" }, { name: "Viracopos International Airport", iataCode: "VCP" }, { name: "Vnukovo International Airport", iataCode: "VKO" }, { name: "Wellington International Airport", iataCode: "WLG" }, { name: "Xi'an Xianyang International Airport", iataCode: "XIY" }, { name: "Zhukovsky International Airport", iataCode: "ZIA" }, { name: "Zurich Airport", iataCode: "ZRH" }];
var Za = { airline: e, airplane: a, airport: r };
var o = Za;
var n = ["American black bear", "Asian black bear", "Brown bear", "Giant panda", "Polar bear", "Sloth bear", "Spectacled bear", "Sun bear"];
var i = ["Abert's Towhee", "Acadian Flycatcher", "Acorn Woodpecker", "Alder Flycatcher", "Aleutian Tern", "Allen's Hummingbird", "Altamira Oriole", "American Avocet", "American Bittern", "American Black Duck", "American Coot", "American Crow", "American Dipper", "American Golden-Plover", "American Goldfinch", "American Kestrel", "American Oystercatcher", "American Pipit", "American Redstart", "American Robin", "American Tree Sparrow", "American White Pelican", "American Wigeon", "American Woodcock", "Ancient Murrelet", "Anhinga", "Anna's Hummingbird", "Antillean Nighthawk", "Antillean Palm Swift", "Aplomado Falcon", "Arctic Loon", "Arctic Tern", "Arctic Warbler", "Ash-throated Flycatcher", "Ashy Storm-Petrel", "Asian Brown Flycatcher", "Atlantic Puffin", "Audubon's Oriole", "Audubon's Shearwater", "Aztec Thrush", "Azure Gallinule", "Bachman's Sparrow", "Bachman's Warbler", "Bahama Mockingbird", "Bahama Swallow", "Bahama Woodstar", "Baikal Teal", "Baird's Sandpiper", "Baird's Sparrow", "Bald Eagle", "Baltimore Oriole", "Bananaquit", "Band-rumped Storm-Petrel", "Band-tailed Gull", "Band-tailed Pigeon", "Bank Swallow", "Bar-tailed Godwit", "Barn Owl", "Barn Swallow", "Barnacle Goose", "Barred Owl", "Barrow's Goldeneye", "Bay-breasted Warbler", "Bean Goose", "Bell's Vireo", "Belted Kingfisher", "Bendire's Thrasher", "Berylline Hummingbird", "Bewick's Wren", "Bicknell's Thrush", "Black Catbird", "Black Guillemot", "Black Noddy", "Black Oystercatcher", "Black Phoebe", "Black Rail", "Black Rosy-Finch", "Black Scoter", "Black Skimmer", "Black Storm-Petrel", "Black Swift", "Black Tern", "Black Turnstone", "Black Vulture", "Black-and-white Warbler", "Black-backed Wagtail", "Black-backed Woodpecker", "Black-bellied Plover", "Black-bellied Whistling-Duck", "Black-billed Cuckoo", "Black-billed Magpie", "Black-browed Albatross", "Black-capped Chickadee", "Black-capped Gnatcatcher", "Black-capped Petrel", "Black-capped Vireo", "Black-chinned Hummingbird", "Black-chinned Sparrow", "Black-crowned Night-Heron", "Black-faced Grassquit", "Black-footed Albatross", "Black-headed Grosbeak", "Black-headed Gull", "Black-legged Kittiwake", "Black-necked Stilt", "Black-tailed Gnatcatcher", "Black-tailed Godwit", "Black-tailed Gull", "Black-throated Blue Warbler", "Black-throated Gray Warbler", "Black-throated Green Warbler", "Black-throated Sparrow", "Black-vented Oriole", "Black-vented Shearwater", "Black-whiskered Vireo", "Black-winged Stilt", "Blackburnian Warbler", "Blackpoll Warbler", "Blue Bunting", "Blue Grosbeak", "Blue Grouse", "Blue Jay", "Blue Mockingbird", "Blue-footed Booby", "Blue-gray Gnatcatcher", "Blue-headed Vireo", "Blue-throated Hummingbird", "Blue-winged Teal", "Blue-winged Warbler", "Bluethroat", "Boat-tailed Grackle", "Bobolink", "Bohemian Waxwing", "Bonaparte's Gull", "Boreal Chickadee", "Boreal Owl", "Botteri's Sparrow", "Brambling", "Brandt's Cormorant", "Brant", "Brewer's Blackbird", "Brewer's Sparrow", "Bridled Tern", "Bridled Titmouse", "Bristle-thighed Curlew", "Broad-billed Hummingbird", "Broad-billed Sandpiper", "Broad-tailed Hummingbird", "Broad-winged Hawk", "Bronzed Cowbird", "Brown Booby", "Brown Creeper", "Brown Jay", "Brown Noddy", "Brown Pelican", "Brown Shrike", "Brown Thrasher", "Brown-capped Rosy-Finch", "Brown-chested Martin", "Brown-crested Flycatcher", "Brown-headed Cowbird", "Brown-headed Nuthatch", "Budgerigar", "Buff-bellied Hummingbird", "Buff-breasted Flycatcher", "Buff-breasted Sandpiper", "Buff-collared Nightjar", "Bufflehead", "Buller's Shearwater", "Bullock's Oriole", "Bumblebee Hummingbird", "Burrowing Owl", "Bushtit", "Cactus Wren", "California Condor", "California Gnatcatcher", "California Gull", "California Quail", "California Thrasher", "California Towhee", "Calliope Hummingbird", "Canada Goose", "Canada Warbler", "Canvasback", "Canyon Towhee", "Canyon Wren", "Cape May Warbler", "Caribbean Elaenia", "Carolina Chickadee", "Carolina Parakeet", "Carolina Wren", "Caspian Tern", "Cassin's Auklet", "Cassin's Finch", "Cassin's Kingbird", "Cassin's Sparrow", "Cassin's Vireo", "Cattle Egret", "Cave Swallow", "Cedar Waxwing", "Cerulean Warbler", "Chestnut-backed Chickadee", "Chestnut-collared Longspur", "Chestnut-sided Warbler", "Chihuahuan Raven", "Chimney Swift", "Chinese Egret", "Chipping Sparrow", "Chuck-will's-widow", "Chukar", "Cinnamon Hummingbird", "Cinnamon Teal", "Citrine Wagtail", "Clapper Rail", "Clark's Grebe", "Clark's Nutcracker", "Clay-colored Robin", "Clay-colored Sparrow", "Cliff Swallow", "Colima Warbler", "Collared Forest-Falcon", "Collared Plover", "Common Black-Hawk", "Common Chaffinch", "Common Crane", "Common Cuckoo", "Common Eider", "Common Goldeneye", "Common Grackle", "Common Greenshank", "Common Ground-Dove", "Common House-Martin", "Common Loon", "Common Merganser", "Common Moorhen", "Common Murre", "Common Nighthawk", "Common Pauraque", "Common Pochard", "Common Poorwill", "Common Raven", "Common Redpoll", "Common Ringed Plover", "Common Rosefinch", "Common Sandpiper", "Common Snipe", "Common Swift", "Common Tern", "Common Yellowthroat", "Connecticut Warbler", "Cook's Petrel", "Cooper's Hawk", "Cordilleran Flycatcher", "Corn Crake", "Cory's Shearwater", "Costa's Hummingbird", "Couch's Kingbird", "Crane Hawk", "Craveri's Murrelet", "Crescent-chested Warbler", "Crested Auklet", "Crested Caracara", "Crested Myna", "Crimson-collared Grosbeak", "Crissal Thrasher", "Cuban Martin", "Curlew Sandpiper", "Curve-billed Thrasher", "Dark-eyed Junco", "Dickcissel", "Double-crested Cormorant", "Double-striped Thick-knee", "Dovekie", "Downy Woodpecker", "Dunlin", "Dusky Flycatcher", "Dusky Thrush", "Dusky Warbler", "Dusky-capped Flycatcher", "Eared Grebe", "Eared Trogon", "Eastern Bluebird", "Eastern Kingbird", "Eastern Meadowlark", "Eastern Phoebe", "Eastern Screech-Owl", "Eastern Towhee", "Eastern Wood-Pewee", "Elegant Tern", "Elegant Trogon", "Elf Owl", "Emperor Goose", "Eskimo Curlew", "Eurasian Blackbird", "Eurasian Bullfinch", "Eurasian Collared-Dove", "Eurasian Coot", "Eurasian Curlew", "Eurasian Dotterel", "Eurasian Hobby", "Eurasian Jackdaw", "Eurasian Kestrel", "Eurasian Oystercatcher", "Eurasian Siskin", "Eurasian Tree Sparrow", "Eurasian Wigeon", "Eurasian Woodcock", "Eurasian Wryneck", "European Golden-Plover", "European Starling", "European Storm-Petrel", "European Turtle-Dove", "Evening Grosbeak", "Eyebrowed Thrush", "Falcated Duck", "Fan-tailed Warbler", "Far Eastern Curlew", "Ferruginous Hawk", "Ferruginous Pygmy-Owl", "Field Sparrow", "Fieldfare", "Fish Crow", "Five-striped Sparrow", "Flame-colored Tanager", "Flammulated Owl", "Flesh-footed Shearwater", "Florida Scrub-Jay", "Fork-tailed Flycatcher", "Fork-tailed Storm-Petrel", "Fork-tailed Swift", "Forster's Tern", "Fox Sparrow", "Franklin's Gull", "Fulvous Whistling-Duck", "Gadwall", "Gambel's Quail", "Garganey", "Gila Woodpecker", "Gilded Flicker", "Glaucous Gull", "Glaucous-winged Gull", "Glossy Ibis", "Golden Eagle", "Golden-cheeked Warbler", "Golden-crowned Kinglet", "Golden-crowned Sparrow", "Golden-crowned Warbler", "Golden-fronted Woodpecker", "Golden-winged Warbler", "Grace's Warbler", "Grasshopper Sparrow", "Gray Bunting", "Gray Catbird", "Gray Flycatcher", "Gray Hawk", "Gray Jay", "Gray Kingbird", "Gray Partridge", "Gray Silky-flycatcher", "Gray Vireo", "Gray Wagtail", "Gray-breasted Martin", "Gray-cheeked Thrush", "Gray-crowned Rosy-Finch", "Gray-crowned Yellowthroat", "Gray-headed Chickadee", "Gray-spotted Flycatcher", "Gray-tailed Tattler", "Great Auk", "Great Black-backed Gull", "Great Blue Heron", "Great Cormorant", "Great Crested Flycatcher", "Great Egret", "Great Frigatebird", "Great Gray Owl", "Great Horned Owl", "Great Kiskadee", "Great Knot", "Great Skua", "Great Spotted Woodpecker", "Great-tailed Grackle", "Greater Flamingo", "Greater Pewee", "Greater Prairie-chicken", "Greater Roadrunner", "Greater Scaup", "Greater Shearwater", "Greater White-fronted Goose", "Greater Yellowlegs", "Green Heron", "Green Jay", "Green Kingfisher", "Green Sandpiper", "Green Violet-ear", "Green-breasted Mango", "Green-tailed Towhee", "Green-winged Teal", "Greenish Elaenia", "Groove-billed Ani", "Gull-billed Tern", "Gyrfalcon", "Hairy Woodpecker", "Hammond's Flycatcher", "Harlequin Duck", "Harris's Hawk", "Harris's Sparrow", "Hawfinch", "Heermann's Gull", "Henslow's Sparrow", "Hepatic Tanager", "Herald Petrel", "Hermit Thrush", "Hermit Warbler", "Herring Gull", "Himalayan Snowcock", "Hoary Redpoll", "Hooded Merganser", "Hooded Oriole", "Hooded Warbler", "Hook-billed Kite", "Hoopoe", "Horned Grebe", "Horned Lark", "Horned Puffin", "House Finch", "House Sparrow", "House Wren", "Hudsonian Godwit", "Hutton's Vireo", "Iceland Gull", "Inca Dove", "Indigo Bunting", "Island Scrub-Jay", "Ivory Gull", "Ivory-billed Woodpecker", "Jabiru", "Jack Snipe", "Jungle Nightjar", "Juniper Titmouse", "Kentucky Warbler", "Key West Quail-Dove", "Killdeer", "King Eider", "King Rail", "Kirtland's Warbler", "Kittlitz's Murrelet", "La Sagra's Flycatcher", "Labrador Duck", "Ladder-backed Woodpecker", "Lanceolated Warbler", "Lapland Longspur", "Large-billed Tern", "Lark Bunting", "Lark Sparrow", "Laughing Gull", "Lawrence's Goldfinch", "Laysan Albatross", "Lazuli Bunting", "Le Conte's Sparrow", "Le Conte's Thrasher", "Leach's Storm-Petrel", "Least Auklet", "Least Bittern", "Least Flycatcher", "Least Grebe", "Least Sandpiper", "Least Storm-Petrel", "Least Tern", "Lesser Black-backed Gull", "Lesser Frigatebird", "Lesser Goldfinch", "Lesser Nighthawk", "Lesser Prairie-chicken", "Lesser Scaup", "Lesser White-fronted Goose", "Lesser Yellowlegs", "Lewis's Woodpecker", "Limpkin", "Lincoln's Sparrow", "Little Blue Heron", "Little Bunting", "Little Curlew", "Little Egret", "Little Gull", "Little Ringed Plover", "Little Shearwater", "Little Stint", "Loggerhead Kingbird", "Loggerhead Shrike", "Long-billed Curlew", "Long-billed Dowitcher", "Long-billed Murrelet", "Long-billed Thrasher", "Long-eared Owl", "Long-tailed Jaeger", "Long-toed Stint", "Louisiana Waterthrush", "Lucifer Hummingbird", "Lucy's Warbler", "MacGillivray's Warbler", "Magnificent Frigatebird", "Magnificent Hummingbird", "Magnolia Warbler", "Mallard", "Mangrove Cuckoo", "Manx Shearwater", "Marbled Godwit", "Marbled Murrelet", "Marsh Sandpiper", "Marsh Wren", "Masked Booby", "Masked Duck", "Masked Tityra", "McCown's Longspur", "McKay's Bunting", "Merlin", "Mew Gull", "Mexican Chickadee", "Mexican Jay", "Middendorff's Grasshopper-Warbler", "Mississippi Kite", "Mongolian Plover", "Monk Parakeet", "Montezuma Quail", "Mottled Duck", "Mottled Owl", "Mottled Petrel", "Mountain Bluebird", "Mountain Chickadee", "Mountain Plover", "Mountain Quail", "Mourning Dove", "Mourning Warbler", "Mugimaki Flycatcher", "Murphy's Petrel", "Muscovy Duck", "Mute Swan", "Narcissus Flycatcher", "Nashville Warbler", "Nelson's Sharp-tailed Sparrow", "Neotropic Cormorant", "Northern Beardless-Tyrannulet", "Northern Bobwhite", "Northern Cardinal", "Northern Flicker", "Northern Fulmar", "Northern Gannet", "Northern Goshawk", "Northern Harrier", "Northern Hawk Owl", "Northern Jacana", "Northern Lapwing", "Northern Mockingbird", "Northern Parula", "Northern Pintail", "Northern Pygmy-Owl", "Northern Rough-winged Swallow", "Northern Saw-whet Owl", "Northern Shoveler", "Northern Shrike", "Northern Waterthrush", "Northern Wheatear", "Northwestern Crow", "Nuttall's Woodpecker", "Nutting's Flycatcher", "Oak Titmouse", "Oldsquaw", "Olive Sparrow", "Olive Warbler", "Olive-backed Pipit", "Olive-sided Flycatcher", "Orange-crowned Warbler", "Orchard Oriole", "Oriental Cuckoo", "Oriental Greenfinch", "Oriental Pratincole", "Oriental Scops-Owl", "Oriental Turtle-Dove", "Osprey", "Ovenbird", "Pacific Golden-Plover", "Pacific Loon", "Pacific-slope Flycatcher", "Paint-billed Crake", "Painted Bunting", "Painted Redstart", "Pallas's Bunting", "Palm Warbler", "Parakeet Auklet", "Parasitic Jaeger", "Passenger Pigeon", "Pechora Pipit", "Pectoral Sandpiper", "Pelagic Cormorant", "Peregrine Falcon", "Phainopepla", "Philadelphia Vireo", "Pied-billed Grebe", "Pigeon Guillemot", "Pileated Woodpecker", "Pin-tailed Snipe", "Pine Bunting", "Pine Grosbeak", "Pine Siskin", "Pine Warbler", "Pink-footed Goose", "Pink-footed Shearwater", "Pinyon Jay", "Piping Plover", "Plain Chachalaca", "Plain-capped Starthroat", "Plumbeous Vireo", "Pomarine Jaeger", "Prairie Falcon", "Prairie Warbler", "Prothonotary Warbler", "Purple Finch", "Purple Gallinule", "Purple Martin", "Purple Sandpiper", "Pygmy Nuthatch", "Pyrrhuloxia", "Razorbill", "Red Crossbill", "Red Knot", "Red Phalarope", "Red-bellied Woodpecker", "Red-billed Pigeon", "Red-billed Tropicbird", "Red-breasted Flycatcher", "Red-breasted Merganser", "Red-breasted Nuthatch", "Red-breasted Sapsucker", "Red-cockaded Woodpecker", "Red-crowned Parrot", "Red-eyed Vireo", "Red-faced Cormorant", "Red-faced Warbler", "Red-flanked Bluetail", "Red-footed Booby", "Red-headed Woodpecker", "Red-legged Kittiwake", "Red-naped Sapsucker", "Red-necked Grebe", "Red-necked Phalarope", "Red-necked Stint", "Red-shouldered Hawk", "Red-tailed Hawk", "Red-tailed Tropicbird", "Red-throated Loon", "Red-throated Pipit", "Red-whiskered Bulbul", "Red-winged Blackbird", "Reddish Egret", "Redhead", "Redwing", "Reed Bunting", "Rhinoceros Auklet", "Ring-billed Gull", "Ring-necked Duck", "Ring-necked Pheasant", "Ringed Kingfisher", "Roadside Hawk", "Rock Dove", "Rock Ptarmigan", "Rock Sandpiper", "Rock Wren", "Rose-breasted Grosbeak", "Rose-throated Becard", "Roseate Spoonbill", "Roseate Tern", "Ross's Goose", "Ross's Gull", "Rough-legged Hawk", "Royal Tern", "Ruby-crowned Kinglet", "Ruby-throated Hummingbird", "Ruddy Duck", "Ruddy Ground-Dove", "Ruddy Quail-Dove", "Ruddy Turnstone", "Ruff", "Ruffed Grouse", "Rufous Hummingbird", "Rufous-backed Robin", "Rufous-capped Warbler", "Rufous-crowned Sparrow", "Rufous-winged Sparrow", "Rustic Bunting", "Rusty Blackbird", "Sabine's Gull", "Sage Grouse", "Sage Sparrow", "Sage Thrasher", "Saltmarsh Sharp-tailed Sparrow", "Sanderling", "Sandhill Crane", "Sandwich Tern", "Savannah Sparrow", "Say's Phoebe", "Scaled Quail", "Scaly-naped Pigeon", "Scarlet Ibis", "Scarlet Tanager", "Scissor-tailed Flycatcher", "Scott's Oriole", "Seaside Sparrow", "Sedge Wren", "Semipalmated Plover", "Semipalmated Sandpiper", "Sharp-shinned Hawk", "Sharp-tailed Grouse", "Sharp-tailed Sandpiper", "Shiny Cowbird", "Short-billed Dowitcher", "Short-eared Owl", "Short-tailed Albatross", "Short-tailed Hawk", "Short-tailed Shearwater", "Shy Albatross", "Siberian Accentor", "Siberian Blue Robin", "Siberian Flycatcher", "Siberian Rubythroat", "Sky Lark", "Slate-throated Redstart", "Slaty-backed Gull", "Slender-billed Curlew", "Smew", "Smith's Longspur", "Smooth-billed Ani", "Snail Kite", "Snow Bunting", "Snow Goose", "Snowy Egret", "Snowy Owl", "Snowy Plover", "Solitary Sandpiper", "Song Sparrow", "Sooty Shearwater", "Sooty Tern", "Sora", "South Polar Skua", "Southern Martin", "Spectacled Eider", "Spoonbill Sandpiper", "Spot-billed Duck", "Spot-breasted Oriole", "Spotted Dove", "Spotted Owl", "Spotted Rail", "Spotted Redshank", "Spotted Sandpiper", "Spotted Towhee", "Sprague's Pipit", "Spruce Grouse", "Stejneger's Petrel", "Steller's Eider", "Steller's Jay", "Steller's Sea-Eagle", "Stilt Sandpiper", "Stonechat", "Streak-backed Oriole", "Streaked Shearwater", "Strickland's Woodpecker", "Stripe-headed Tanager", "Sulphur-bellied Flycatcher", "Summer Tanager", "Surf Scoter", "Surfbird", "Swainson's Hawk", "Swainson's Thrush", "Swainson's Warbler", "Swallow-tailed Kite", "Swamp Sparrow", "Tamaulipas Crow", "Tawny-shouldered Blackbird", "Temminck's Stint", "Tennessee Warbler", "Terek Sandpiper", "Thayer's Gull", "Thick-billed Kingbird", "Thick-billed Murre", "Thick-billed Parrot", "Thick-billed Vireo", "Three-toed Woodpecker", "Townsend's Solitaire", "Townsend's Warbler", "Tree Pipit", "Tree Swallow", "Tricolored Blackbird", "Tricolored Heron", "Tropical Kingbird", "Tropical Parula", "Trumpeter Swan", "Tufted Duck", "Tufted Flycatcher", "Tufted Puffin", "Tufted Titmouse", "Tundra Swan", "Turkey Vulture", "Upland Sandpiper", "Varied Bunting", "Varied Thrush", "Variegated Flycatcher", "Vaux's Swift", "Veery", "Verdin", "Vermilion Flycatcher", "Vesper Sparrow", "Violet-crowned Hummingbird", "Violet-green Swallow", "Virginia Rail", "Virginia's Warbler", "Wandering Albatross", "Wandering Tattler", "Warbling Vireo", "Wedge-rumped Storm-Petrel", "Wedge-tailed Shearwater", "Western Bluebird", "Western Grebe", "Western Gull", "Western Kingbird", "Western Meadowlark", "Western Reef-Heron", "Western Sandpiper", "Western Screech-Owl", "Western Scrub-Jay", "Western Tanager", "Western Wood-Pewee", "Whimbrel", "Whip-poor-will", "Whiskered Auklet", "Whiskered Screech-Owl", "Whiskered Tern", "White Ibis", "White Wagtail", "White-breasted Nuthatch", "White-cheeked Pintail", "White-chinned Petrel", "White-collared Seedeater", "White-collared Swift", "White-crowned Pigeon", "White-crowned Sparrow", "White-eared Hummingbird", "White-eyed Vireo", "White-faced Ibis", "White-faced Storm-Petrel", "White-headed Woodpecker", "White-rumped Sandpiper", "White-tailed Eagle", "White-tailed Hawk", "White-tailed Kite", "White-tailed Ptarmigan", "White-tailed Tropicbird", "White-throated Needletail", "White-throated Robin", "White-throated Sparrow", "White-throated Swift", "White-tipped Dove", "White-winged Crossbill", "White-winged Dove", "White-winged Parakeet", "White-winged Scoter", "White-winged Tern", "Whooper Swan", "Whooping Crane", "Wild Turkey", "Willet", "Williamson's Sapsucker", "Willow Flycatcher", "Willow Ptarmigan", "Wilson's Phalarope", "Wilson's Plover", "Wilson's Storm-Petrel", "Wilson's Warbler", "Winter Wren", "Wood Duck", "Wood Sandpiper", "Wood Stork", "Wood Thrush", "Wood Warbler", "Worm-eating Warbler", "Worthen's Sparrow", "Wrentit", "Xantus's Hummingbird", "Xantus's Murrelet", "Yellow Bittern", "Yellow Grosbeak", "Yellow Rail", "Yellow Wagtail", "Yellow Warbler", "Yellow-bellied Flycatcher", "Yellow-bellied Sapsucker", "Yellow-billed Cuckoo", "Yellow-billed Loon", "Yellow-billed Magpie", "Yellow-breasted Bunting", "Yellow-breasted Chat", "Yellow-crowned Night-Heron", "Yellow-eyed Junco", "Yellow-faced Grassquit", "Yellow-footed Gull", "Yellow-green Vireo", "Yellow-headed Blackbird", "Yellow-legged Gull", "Yellow-nosed Albatross", "Yellow-rumped Warbler", "Yellow-throated Vireo", "Yellow-throated Warbler", "Yucatan Vireo", "Zenaida Dove", "Zone-tailed Hawk"];
var t = ["Abyssinian", "American Bobtail", "American Curl", "American Shorthair", "American Wirehair", "Balinese", "Bengal", "Birman", "Bombay", "British Shorthair", "Burmese", "Chartreux", "Chausie", "Cornish Rex", "Devon Rex", "Donskoy", "Egyptian Mau", "Exotic Shorthair", "Havana", "Highlander", "Himalayan", "Japanese Bobtail", "Korat", "Kurilian Bobtail", "LaPerm", "Maine Coon", "Manx", "Minskin", "Munchkin", "Nebelung", "Norwegian Forest Cat", "Ocicat", "Ojos Azules", "Oriental", "Persian", "Peterbald", "Pixiebob", "Ragdoll", "Russian Blue", "Savannah", "Scottish Fold", "Selkirk Rex", "Serengeti", "Siamese", "Siberian", "Singapura", "Snowshoe", "Sokoke", "Somali", "Sphynx", "Thai", "Tonkinese", "Toyger", "Turkish Angora", "Turkish Van"];
var l = ["Amazon River Dolphin", "Arnoux's Beaked Whale", "Atlantic Humpbacked Dolphin", "Atlantic Spotted Dolphin", "Atlantic White-Sided Dolphin", "Australian Snubfin Dolphin", "Australian humpback Dolphin", "Blue Whale", "Bottlenose Dolphin", "Bryde\u2019s whale", "Burrunan Dolphin", "Chilean Dolphin", "Chinese River Dolphin", "Chinese White Dolphin", "Clymene Dolphin", "Commerson\u2019s Dolphin", "Costero", "Dusky Dolphin", "False Killer Whale", "Fin Whale", "Fraser\u2019s Dolphin", "Ganges River Dolphin", "Guiana Dolphin", "Heaviside\u2019s Dolphin", "Hector\u2019s Dolphin", "Hourglass Dolphin", "Humpback whale", "Indo-Pacific Bottlenose Dolphin", "Indo-Pacific Hump-backed Dolphin", "Irrawaddy Dolphin", "Killer Whale (Orca)", "La Plata Dolphin", "Long-Beaked Common Dolphin", "Long-finned Pilot Whale", "Longman's Beaked Whale", "Melon-headed Whale", "Northern Rightwhale Dolphin", "Omura\u2019s whale", "Pacific White-Sided Dolphin", "Pantropical Spotted Dolphin", "Peale\u2019s Dolphin", "Pygmy Killer Whale", "Risso\u2019s Dolphin", "Rough-Toothed Dolphin", "Sei Whale", "Short-Beaked Common Dolphin", "Short-finned Pilot Whale", "Southern Bottlenose Whale", "Southern Rightwhale Dolphin", "Sperm Whale", "Spinner Dolphin", "Striped Dolphin", "Tucuxi", "White-Beaked Dolphin"];
var s = ["Aberdeen Angus", "Abergele", "Abigar", "Abondance", "Abyssinian Shorthorned Zebu", "Aceh", "Achham", "Adamawa", "Adaptaur", "Afar", "Africangus", "Afrikaner", "Agerolese", "Alambadi", "Alatau", "Albanian", "Albera", "Alderney", "Alentejana", "Aleutian wild cattle", "Aliad Dinka", "Alistana-Sanabresa", "Allmogekor", "Alur", "American", "American Angus", "American Beef Friesian", "American Brown Swiss", "American Milking Devon", "American White Park", "Amerifax", "Amrit Mahal", "Amsterdam Island cattle", "Anatolian Black", "Andalusian Black", "Andalusian Blond", "Andalusian Grey", "Angeln", "Angoni", "Ankina", "Ankole", "Ankole-Watusi", "Aracena", "Arado", "Argentine Criollo", "Argentine Friesian", "Armorican", "Arouquesa", "Arsi", "Asturian Mountain", "Asturian Valley", "Aubrac", "Aulie-Ata", "Aure et Saint-Girons", "Australian Braford", "Australian Brangus", "Australian Charbray", "Australian Friesian Sahiwal", "Australian Lowline", "Australian Milking Zebu", "Australian Shorthorn", "Austrian Simmental", "Austrian Yellow", "Avile\xF1a-Negra Ib\xE9rica", "Av\xE9tonou", "Aweil Dinka", "Ayrshire", "Azaouak", "Azebuado", "Azerbaijan Zebu", "Azores", "Bachaur cattle", "Baherie cattle", "Bakosi cattle", "Balancer", "Baoule", "Bargur cattle", "Barros\xE3", "Barzona", "Bazadaise", "Beef Freisian", "Beefalo", "Beefmaker", "Beefmaster", "Begayt", "Belgian Blue", "Belgian Red", "Belgian Red Pied", "Belgian White-and-Red", "Belmont Red", "Belted Galloway", "Bernese", "Berrenda cattle", "Betizu", "Bianca Modenese", "Blaarkop", "Black Angus", "Black Baldy", "Black Hereford", "Blanca Cacere\xF1a", "Blanco Orejinegro BON", "Blonde d'Aquitaine", "Blue Albion", "Blue Grey", "Bohuskulla", "Bonsmara", "Boran", "Bo\u0161karin", "Braford", "Brahman", "Brahmousin", "Brangus", "Braunvieh", "Brava", "Breed", "British Friesian", "British White", "Brown Carpathian", "Brown Caucasian", "Brown Swiss", "Bue Lingo", "Burlina", "Bushuyev", "Butana cattle", "Bu\u0161a cattle", "Cachena", "Caldelana", "Camargue", "Campbell Island cattle", "Canadian Speckle Park", "Canadienne", "Canaria", "Canchim", "Caracu", "Carinthian Blondvieh", "Carora", "Charbray", "Charolais", "Chateaubriand", "Chiangus", "Chianina", "Chillingham cattle", "Chinese Black Pied", "Cholistani", "Coloursided White Back", "Commercial", "Corriente", "Corsican cattle", "Coste\xF1o con Cuernos", "Crioulo Lageano", "C\xE1rdena Andaluza", "Dajal", "Dangi cattle", "Danish Black-Pied", "Danish Jersey", "Danish Red", "Deep Red cattle", "Deoni", "Devon", "Dexter cattle", "Dhanni", "Doayo cattle", "Doela", "Drakensberger", "Droughtmaster", "Dulong'", "Dutch Belted", "Dutch Friesian", "Dwarf Lulu", "D\xF8lafe", "East Anatolian Red", "Eastern Finncattle", "Eastern Red Polled", "Enderby Island cattle", "English Longhorn", "Ennstaler Bergscheck", "Estonian Holstein", "Estonian Native", "Estonian Red cattle", "Finncattle", "Finnish Ayrshire", "Finnish Holstein-Friesian", "Fj\xE4ll", "Fleckvieh", "Florida Cracker cattle", "Fogera", "French Simmental", "Fribourgeoise", "Friesian Red and White", "Fulani Sudanese", "F\u0113ng Cattle", "Galician Blond", "Galloway cattle", "Gangatiri", "Gaolao", "Garvonesa", "Gascon cattle", "Gelbvieh", "Georgian Mountain cattle", "German Angus", "German Black Pied Dairy", "German Black Pied cattle", "German Red Pied", "Gir", "Glan cattle", "Gloucester", "Gobra", "Greek Shorthorn", "Greek Steppe", "Greyman cattle", "Gudali", "Guernsey cattle", "Guzer\xE1", "Hallikar4", "Hanwoo", "Hariana cattle", "Hart\xF3n del Valle", "Harzer Rotvieh", "Hays Converter", "Heck cattle", "Hereford", "Herens", "Highland cattle", "Hinterwald", "Holando-Argentino", "Holstein Friesian cattle", "Horro", "Hungarian Grey", "Hu\xE1ng Cattle", "Hybridmaster", "Iberian cattle", "Icelandic", "Illawarra cattle", "Improved Red and White", "Indo-Brazilian", "Irish Moiled", "Israeli Holstein", "Israeli Red", "Istoben cattle", "Istrian cattle", "Jamaica Black", "Jamaica Hope", "Jamaica Red", "Japanese Brown", "Jarmelista", "Javari cattle", "Jersey cattle", "Jutland cattle", "Kabin Buri cattle", "Kalmyk cattle", "Kamphaeng Saen cattle", "Kangayam", "Kankrej", "Karan Swiss", "Kasaragod Dwarf cattle", "Kathiawadi", "Kazakh Whiteheaded", "Kenana cattle", "Kenkatha cattle", "Kerry cattle", "Kherigarh", "Khillari cattle", "Kholomogory", "Korat Wagyu", "Kostroma cattle", "Krishna Valley cattle", "Kurgan cattle", "Kuri", "La Reina cattle", "Lakenvelder cattle", "Lampurger", "Latvian Blue", "Latvian Brown", "Latvian Danish Red", "Lebedyn", "Levantina", "Limia cattle", "Limousin", "Limpurger", "Lincoln Red", "Lineback", "Lithuanian Black-and-White", "Lithuanian Light Grey", "Lithuanian Red", "Lithuanian White-Backed", "Lohani cattle", "Lourdais", "Lucerna cattle", "Luing", "Madagascar Zebu", "Madura", "Maine-Anjou", "Malnad Gidda", "Malvi", "Mandalong Special", "Mantequera Leonesa", "Maramure\u015F Brown", "Marchigiana", "Maremmana", "Marinhoa", "Maronesa", "Masai", "Mashona", "Menorquina", "Mertolenga", "Meuse-Rhine-Issel", "Mewati", "Milking Shorthorn", "Minhota", "Mirandesa", "Mirkadim", "Moc\u0103ni\u0163\u0103", "Mollie", "Monchina", "Mongolian", "Montb\xE9liarde", "Morucha", "Murboden", "Murnau-Werdenfels", "Murray Grey", "Muturu", "N'Dama", "Nagori", "Negra Andaluza", "Nelore", "Nguni", "Nimari", "Normande", "North Bengal Grey", "Northern Finncattle", "Northern Shorthorn", "Norwegian Red", "Ongole", "Original Simmental", "Pajuna", "Palmera", "Pantaneiro", "Parda Alpina", "Parthenaise", "Pasiega", "Pembroke", "Philippine Native", "Pie Rouge des Plaines", "Piedmontese cattle", "Pineywoods", "Pinzgauer", "Pirenaica", "Podolac", "Podolica", "Polish Black-and-White", "Polish Red", "Poll Shorthorn", "Polled Hereford", "Polled Shorthorn", "Ponwar", "Preta", "Pulikulam", "Punganur", "Pustertaler Sprinzen", "Qinchaun", "Queensland Miniature Boran", "RX3", "Ramo Grande", "Randall", "Raramuri Criollo", "Rathi", "Raya", "Red Angus", "Red Brangus", "Red Chittagong", "Red Fulani", "Red Gorbatov", "Red Holstein", "Red Kandhari", "Red Mingrelian", "Red Poll", "Red Polled \xD8stland", "Red Sindhi", "Retinta", "Riggit Galloway", "Ringam\xE5la", "Rohjan", "Romagnola", "Romanian B\u0103l\u0163ata", "Romanian Steppe Gray", "Romosinuano", "Russian Black Pied", "R\xE4tisches Grauvieh", "Sahiwal", "Salers", "Salorn", "Sanga", "Sanhe", "Santa Cruz", "Santa Gertrudis", "Sayaguesa", "Schwyz", "Selembu", "Senepol", "Serbian Pied", "Serbian Steppe", "Sheko", "Shetland", "Shorthorn", "Siboney de Cuba", "Simbrah", "Simford", "Simmental", "Siri", "South Devon", "Spanish Fighting Bull", "Speckle Park", "Square Meater", "Sussex", "Swedish Friesian", "Swedish Polled", "Swedish Red Pied", "Swedish Red Polled", "Swedish Red-and-White", "Tabapu\xE3", "Tarentaise", "Tasmanian Grey", "Tauros", "Telemark", "Texas Longhorn", "Texon", "Thai Black", "Thai Fighting Bull", "Thai Friesian", "Thai Milking Zebu", "Tharparkar", "Tswana", "Tudanca", "Tuli", "Tulim", "Turkish Grey Steppe", "Tux-Zillertal", "Tyrol Grey", "Ukrainian Grey", "Umblachery", "Valdostana Castana", "Valdostana Pezzata Nera", "Valdostana Pezzata Rossa", "Vaynol", "Vechur8", "Vestland Fjord", "Vestland Red Polled", "Vianesa", "Volinian Beef", "Vorderwald", "Vosgienne", "V\xE4neko", "Waguli", "Wagyu", "Wangus", "Welsh Black", "Western Finncattle", "White C\xE1ceres", "White Fulani", "White Lamphun", "White Park", "Whitebred Shorthorn", "Xingjiang Brown", "Yakutian", "Yanbian", "Yanhuang", "Yurino", "Zebu", "\xC9vol\xE8ne cattle", "\u017Bubro\u0144"];
var d = ["African Slender-snouted Crocodile", "Alligator mississippiensis", "American Crocodile", "Australian Freshwater Crocodile", "Black Caiman", "Broad-snouted Caiman", "Chinese Alligator", "Cuban Crocodile", "Cuvier\u2019s Dwarf Caiman", "Dwarf Crocodile", "Gharial", "Morelet\u2019s Crocodile", "Mugger Crocodile", "New Guinea Freshwater Crocodile", "Nile Crocodile", "Orinoco Crocodile", "Philippine Crocodile", "Saltwater Crocodile", "Schneider\u2019s Smooth-fronted Caiman", "Siamese Crocodile", "Spectacled Caiman", "Tomistoma", "West African Crocodile", "Yacare Caiman"];
var u = ["Affenpinscher", "Afghan Hound", "Aidi", "Airedale Terrier", "Akbash", "Akita", "Alano Espa\xF1ol", "Alapaha Blue Blood Bulldog", "Alaskan Husky", "Alaskan Klee Kai", "Alaskan Malamute", "Alopekis", "Alpine Dachsbracke", "American Bulldog", "American Bully", "American Cocker Spaniel", "American English Coonhound", "American Foxhound", "American Hairless Terrier", "American Pit Bull Terrier", "American Staffordshire Terrier", "American Water Spaniel", "Andalusian Hound", "Anglo-Fran\xE7ais de Petite V\xE9nerie", "Appenzeller Sennenhund", "Ariegeois", "Armant", "Armenian Gampr dog", "Artois Hound", "Australian Cattle Dog", "Australian Kelpie", "Australian Shepherd", "Australian Stumpy Tail Cattle Dog", "Australian Terrier", "Austrian Black and Tan Hound", "Austrian Pinscher", "Azawakh", "Bakharwal dog", "Banjara Hound", "Barbado da Terceira", "Barbet", "Basenji", "Basque Shepherd Dog", "Basset Art\xE9sien Normand", "Basset Bleu de Gascogne", "Basset Fauve de Bretagne", "Basset Hound", "Bavarian Mountain Hound", "Beagle", "Beagle-Harrier", "Bearded Collie", "Beauceron", "Bedlington Terrier", "Belgian Shepherd", "Bergamasco Shepherd", "Berger Picard", "Bernese Mountain Dog", "Bhotia", "Bichon Fris\xE9", "Billy", "Black Mouth Cur", "Black Norwegian Elkhound", "Black Russian Terrier", "Black and Tan Coonhound", "Bloodhound", "Blue Lacy", "Blue Picardy Spaniel", "Bluetick Coonhound", "Boerboel", "Bohemian Shepherd", "Bolognese", "Border Collie", "Border Terrier", "Borzoi", "Bosnian Coarse-haired Hound", "Boston Terrier", "Bouvier des Ardennes", "Bouvier des Flandres", "Boxer", "Boykin Spaniel", "Bracco Italiano", "Braque Francais", "Braque Saint-Germain", "Braque d'Auvergne", "Braque de l'Ari\xE8ge", "Braque du Bourbonnais", "Briard", "Briquet Griffon Vend\xE9en", "Brittany", "Broholmer", "Bruno Jura Hound", "Brussels Griffon", "Bucovina Shepherd Dog", "Bull Arab", "Bull Terrier", "Bulldog", "Bullmastiff", "Bully Kutta", "Burgos Pointer", "Cairn Terrier", "Campeiro Bulldog", "Can de Chira", "Canaan Dog", "Canadian Eskimo Dog", "Cane Corso", "Cane Paratore", "Cane di Oropa", "Cantabrian Water Dog", "Cardigan Welsh Corgi", "Carea Castellano Manchego", "Carolina Dog", "Carpathian Shepherd Dog", "Catahoula Leopard Dog", "Catalan Sheepdog", "Caucasian Shepherd Dog", "Cavalier King Charles Spaniel", "Central Asian Shepherd Dog", "Cesky Fousek", "Cesky Terrier", "Chesapeake Bay Retriever", "Chien Fran\xE7ais Blanc et Noir", "Chien Fran\xE7ais Blanc et Orange", "Chien Fran\xE7ais Tricolore", "Chihuahua", "Chilean Terrier", "Chinese Chongqing Dog", "Chinese Crested Dog", "Chinook", "Chippiparai", "Chongqing dog", "Chortai", "Chow Chow", "Cimarr\xF3n Uruguayo", "Cirneco dell'Etna", "Clumber Spaniel", "Colombian fino hound", "Coton de Tulear", "Cretan Hound", "Croatian Sheepdog", "Curly-Coated Retriever", "Cursinu", "Czechoslovakian Wolfdog", "C\xE3o Fila de S\xE3o Miguel", "C\xE3o da Serra de Aires", "C\xE3o de Castro Laboreiro", "C\xE3o de Gado Transmontano", "Dachshund", "Dalmatian", "Dandie Dinmont Terrier", "Danish-Swedish Farmdog", "Denmark Feist", "Dingo", "Doberman Pinscher", "Dogo Argentino", "Dogo Guatemalteco", "Dogo Sardesco", "Dogue Brasileiro", "Dogue de Bordeaux", "Drentse Patrijshond", "Drever", "Dunker", "Dutch Shepherd", "Dutch Smoushond", "East European Shepherd", "East Siberian Laika", "English Cocker Spaniel", "English Foxhound", "English Mastiff", "English Setter", "English Shepherd", "English Springer Spaniel", "English Toy Terrier", "Entlebucher Mountain Dog", "Estonian Hound", "Estrela Mountain Dog", "Eurasier", "Field Spaniel", "Fila Brasileiro", "Finnish Hound", "Finnish Lapphund", "Finnish Spitz", "Flat-Coated Retriever", "French Bulldog", "French Spaniel", "Galgo Espa\xF1ol", "Galician Shepherd Dog", "Garafian Shepherd", "Gascon Saintongeois", "Georgian Shepherd", "German Hound", "German Longhaired Pointer", "German Pinscher", "German Roughhaired Pointer", "German Shepherd Dog", "German Shorthaired Pointer", "German Spaniel", "German Spitz", "German Wirehaired Pointer", "Giant Schnauzer", "Glen of Imaal Terrier", "Golden Retriever", "Gordon Setter", "Go\u0144czy Polski", "Grand Anglo-Fran\xE7ais Blanc et Noir", "Grand Anglo-Fran\xE7ais Blanc et Orange", "Grand Anglo-Fran\xE7ais Tricolore", "Grand Basset Griffon Vend\xE9en", "Grand Bleu de Gascogne", "Grand Griffon Vend\xE9en", "Great Dane", "Greater Swiss Mountain Dog", "Greek Harehound", "Greek Shepherd", "Greenland Dog", "Greyhound", "Griffon Bleu de Gascogne", "Griffon Fauve de Bretagne", "Griffon Nivernais", "Gull Dong", "Gull Terrier", "Hamiltonst\xF6vare", "Hanover Hound", "Harrier", "Havanese", "Hierran Wolfdog", "Hokkaido", "Hovawart", "Huntaway", "Hygen Hound", "H\xE4llefors Elkhound", "Ibizan Hound", "Icelandic Sheepdog", "Indian Spitz", "Indian pariah dog", "Irish Red and White Setter", "Irish Setter", "Irish Terrier", "Irish Water Spaniel", "Irish Wolfhound", "Istrian Coarse-haired Hound", "Istrian Shorthaired Hound", "Italian Greyhound", "Jack Russell Terrier", "Jagdterrier", "Japanese Chin", "Japanese Spitz", "Japanese Terrier", "Jindo", "Jonangi", "Kai Ken", "Kaikadi", "Kangal Shepherd Dog", "Kanni", "Karakachan dog", "Karelian Bear Dog", "Kars", "Karst Shepherd", "Keeshond", "Kerry Beagle", "Kerry Blue Terrier", "King Charles Spaniel", "King Shepherd", "Kintamani", "Kishu", "Kokoni", "Kombai", "Komondor", "Kooikerhondje", "Koolie", "Koyun dog", "Kromfohrl\xE4nder", "Kuchi", "Kuvasz", "Labrador Retriever", "Lagotto Romagnolo", "Lakeland Terrier", "Lancashire Heeler", "Landseer", "Lapponian Herder", "Large M\xFCnsterl\xE4nder", "Leonberger", "Levriero Sardo", "Lhasa Apso", "Lithuanian Hound", "Lupo Italiano", "L\xF6wchen", "Mackenzie River Husky", "Magyar ag\xE1r", "Mahratta Greyhound", "Maltese", "Manchester Terrier", "Maremmano-Abruzzese Sheepdog", "McNab dog", "Miniature American Shepherd", "Miniature Bull Terrier", "Miniature Fox Terrier", "Miniature Pinscher", "Miniature Schnauzer", "Molossus of Epirus", "Montenegrin Mountain Hound", "Mountain Cur", "Mountain Feist", "Mucuchies", "Mudhol Hound", "Mudi", "Neapolitan Mastiff", "New Guinea Singing Dog", "New Zealand Heading Dog", "Newfoundland", "Norfolk Terrier", "Norrbottenspets", "Northern Inuit Dog", "Norwegian Buhund", "Norwegian Elkhound", "Norwegian Lundehund", "Norwich Terrier", "Nova Scotia Duck Tolling Retriever", "Old Croatian Sighthound", "Old Danish Pointer", "Old English Sheepdog", "Old English Terrier", "Olde English Bulldogge", "Otterhound", "Pachon Navarro", "Paisley Terrier", "Pampas Deerhound", "Papillon", "Parson Russell Terrier", "Pastore della Lessinia e del Lagorai", "Patagonian Sheepdog", "Patterdale Terrier", "Pekingese", "Pembroke Welsh Corgi", "Perro Majorero", "Perro de Pastor Mallorquin", "Perro de Presa Canario", "Perro de Presa Mallorquin", "Peruvian Inca Orchid", "Petit Basset Griffon Vend\xE9en", "Petit Bleu de Gascogne", "Phal\xE8ne", "Pharaoh Hound", "Phu Quoc Ridgeback", "Picardy Spaniel", "Plott Hound", "Plummer Terrier", "Podenco Canario", "Podenco Valenciano", "Pointer", "Poitevin", "Polish Greyhound", "Polish Hound", "Polish Lowland Sheepdog", "Polish Tatra Sheepdog", "Pomeranian", "Pont-Audemer Spaniel", "Poodle", "Porcelaine", "Portuguese Podengo", "Portuguese Pointer", "Portuguese Water Dog", "Posavac Hound", "Pra\u017Esk\xFD Krysa\u0159\xEDk", "Pshdar Dog", "Pudelpointer", "Pug", "Puli", "Pumi", "Pungsan Dog", "Pyrenean Mastiff", "Pyrenean Mountain Dog", "Pyrenean Sheepdog", "Rafeiro do Alentejo", "Rajapalayam", "Rampur Greyhound", "Rat Terrier", "Ratonero Bodeguero Andaluz", "Ratonero Mallorquin", "Ratonero Murciano de Huerta", "Ratonero Valenciano", "Redbone Coonhound", "Rhodesian Ridgeback", "Romanian Mioritic Shepherd Dog", "Romanian Raven Shepherd Dog", "Rottweiler", "Rough Collie", "Russian Spaniel", "Russian Toy", "Russo-European Laika", "Saarloos Wolfdog", "Sabueso Espa\xF1ol", "Saint Bernard", "Saint Hubert Jura Hound", "Saint-Usuge Spaniel", "Saluki", "Samoyed", "Sapsali", "Sarabi dog", "Sardinian Shepherd Dog", "Schapendoes", "Schillerst\xF6vare", "Schipperke", "Schweizer Laufhund", "Schweizerischer Niederlaufhund", "Scottish Deerhound", "Scottish Terrier", "Sealyham Terrier", "Segugio Italiano", "Segugio Maremmano", "Segugio dell'Appennino", "Seppala Siberian Sleddog", "Serbian Hound", "Serbian Tricolour Hound", "Serrano Bulldog", "Shar Pei", "Shetland Sheepdog", "Shiba Inu", "Shih Tzu", "Shikoku", "Shiloh Shepherd", "Siberian Husky", "Silken Windhound", "Silky Terrier", "Sinhala Hound", "Skye Terrier", "Sloughi", "Slovakian Wirehaired Pointer", "Slovensk\xFD Cuvac", "Slovensk\xFD Kopov", "Smalandst\xF6vare", "Small Greek domestic dog", "Small M\xFCnsterl\xE4nder", "Smooth Collie", "Smooth Fox Terrier", "Soft-Coated Wheaten Terrier", "South Russian Ovcharka", "Spanish Mastiff", "Spanish Water Dog", "Spinone Italiano", "Sporting Lucas Terrier", "Stabyhoun", "Staffordshire Bull Terrier", "Standard Schnauzer", "Stephens Stock", "Styrian Coarse-haired Hound", "Sussex Spaniel", "Swedish Elkhound", "Swedish Lapphund", "Swedish Vallhund", "Swedish White Elkhound", "Taigan", "Taiwan Dog", "Tamaskan Dog", "Teddy Roosevelt Terrier", "Telomian", "Tenterfield Terrier", "Terrier Brasileiro", "Thai Bangkaew Dog", "Thai Ridgeback", "Tibetan Mastiff", "Tibetan Spaniel", "Tibetan Terrier", "Tornjak", "Tosa", "Toy Fox Terrier", "Toy Manchester Terrier", "Transylvanian Hound", "Treeing Cur", "Treeing Feist", "Treeing Tennessee Brindle", "Treeing Walker Coonhound", "Trigg Hound", "Tyrolean Hound", "Vikhan", "Villano de Las Encartaciones", "Villanuco de Las Encartaciones", "Vizsla", "Volpino Italiano", "Weimaraner", "Welsh Sheepdog", "Welsh Springer Spaniel", "Welsh Terrier", "West Highland White Terrier", "West Siberian Laika", "Westphalian Dachsbracke", "Wetterhoun", "Whippet", "White Shepherd", "White Swiss Shepherd Dog", "Wire Fox Terrier", "Wirehaired Pointing Griffon", "Wirehaired Vizsla", "Xiasi Dog", "Xoloitzcuintli", "Yakutian Laika", "Yorkshire Terrier", "\u0160arplaninac"];
var c = ["Alaska pollock", "Albacore", "Amur catfish", "Araucanian herring", "Argentine hake", "Asari", "Asian swamp eel", "Atlantic cod", "Atlantic herring", "Atlantic horse mackerel", "Atlantic mackerel", "Atlantic menhaden", "Atlantic salmon", "Bigeye scad", "Bigeye tuna", "Bighead carp", "Black carp", "Blood cockle", "Blue swimming crab", "Blue whiting", "Bombay-duck", "Bonga shad", "California pilchard", "Cape horse mackerel", "Capelin", "Catla", "Channel catfish", "Chilean jack mackerel", "Chinese perch", "Chinese softshell turtle", "Chub mackerel", "Chum salmon", "Common carp", "Crucian carp", "Daggertooth pike conger", "European anchovy", "European pilchard", "European sprat", "Filipino Venus", "Gazami crab", "Goldstripe sardinella", "Grass carp", "Gulf menhaden", "Haddock", "Hilsa shad", "Indian mackerel", "Indian oil sardine", "Iridescent shark", "Japanese anchovy", "Japanese cockle", "Japanese common catfish", "Japanese flying squid", "Japanese jack mackerel", "Japanese littleneck", "Japanese pilchard", "Jumbo flying squid", "Kawakawa", "Korean bullhead", "Largehead hairtail", "Longtail tuna", "Madeiran sardinella", "Mandarin fish", "Milkfish", "Mrigal carp", "Narrow-barred Spanish mackerel", "Nile perch", "Nile tilapia", "North Pacific hake", "Northern snakehead", "Pacific anchoveta", "Pacific cod", "Pacific herring", "Pacific sand lance", "Pacific sandlance", "Pacific saury", "Pacific thread herring", "Peruvian anchoveta", "Pink salmon", "Pollock", "Pond loach", "Rainbow trout", "Rohu", "Round sardinella", "Short mackerel", "Silver carp", "Silver cyprinid", "Skipjack tuna", "Southern African anchovy", "Southern rough shrimp", "Whiteleg shrimp", "Wuchang bream", "Yellow croaker", "Yellowfin tuna", "Yellowhead catfish", "Yellowstripe scad"];
var m = ["Abaco Barb", "Abtenauer", "Abyssinian", "Aegidienberger", "Akhal-Teke", "Albanian Horse", "Altai Horse", "Alt\xE8r Real", "American Albino", "American Cream Draft", "American Indian Horse", "American Paint Horse", "American Quarter Horse", "American Saddlebred", "American Warmblood", "Andalusian Horse", "Andravida Horse", "Anglo-Arabian", "Anglo-Arabo-Sardo", "Anglo-Kabarda", "Appaloosa", "AraAppaloosa", "Arabian Horse", "Ardennes Horse", "Arenberg-Nordkirchen", "Argentine Criollo", "Asian wild Horse", "Assateague Horse", "Asturc\xF3n", "Augeron", "Australian Brumby", "Australian Draught Horse", "Australian Stock Horse", "Austrian Warmblood", "Auvergne Horse", "Auxois", "Azerbaijan Horse", "Azteca Horse", "Baise Horse", "Bale", "Balearic Horse", "Balikun Horse", "Baluchi Horse", "Banker Horse", "Barb Horse", "Bardigiano", "Bashkir Curly", "Basque Mountain Horse", "Bavarian Warmblood", "Belgian Half-blood", "Belgian Horse", "Belgian Warmblood", "Bhutia Horse", "Black Forest Horse", "Blazer Horse", "Boerperd", "Borana", "Boulonnais Horse", "Brabant", "Brandenburger", "Brazilian Sport Horse", "Breton Horse", "Brumby", "Budyonny Horse", "Burguete Horse", "Burmese Horse", "Byelorussian Harness Horse", "Calabrese Horse", "Camargue Horse", "Camarillo White Horse", "Campeiro", "Campolina", "Canadian Horse", "Canadian Pacer", "Carolina Marsh Tacky", "Carthusian Horse", "Caspian Horse", "Castilian Horse", "Castillonnais", "Catria Horse", "Cavallo Romano della Maremma Laziale", "Cerbat Mustang", "Chickasaw Horse", "Chilean Corralero", "Choctaw Horse", "Cleveland Bay", "Clydesdale Horse", "Cob", "Coldblood Trotter", "Colonial Spanish Horse", "Colorado Ranger", "Comtois Horse", "Corsican Horse", "Costa Rican Saddle Horse", "Cretan Horse", "Criollo Horse", "Croatian Coldblood", "Cuban Criollo", "Cumberland Island Horse", "Curly Horse", "Czech Warmblood", "Daliboz", "Danish Warmblood", "Danube Delta Horse", "Dole Gudbrandsdal", "Don", "Dongola Horse", "Draft Trotter", "Dutch Harness Horse", "Dutch Heavy Draft", "Dutch Warmblood", "Dzungarian Horse", "East Bulgarian", "East Friesian Horse", "Estonian Draft", "Estonian Horse", "Falabella", "Faroese", "Finnhorse", "Fjord Horse", "Fleuve", "Florida Cracker Horse", "Foutank\xE9", "Frederiksborg Horse", "Freiberger", "French Trotter", "Friesian Cross", "Friesian Horse", "Friesian Sporthorse", "Furioso-North Star", "Galice\xF1o", "Galician Pony", "Gelderland Horse", "Georgian Grande Horse", "German Warmblood", "Giara Horse", "Gidran", "Groningen Horse", "Gypsy Horse", "Hackney Horse", "Haflinger", "Hanoverian Horse", "Heck Horse", "Heihe Horse", "Henson Horse", "Hequ Horse", "Hirzai", "Hispano-Bret\xF3n", "Holsteiner Horse", "Horro", "Hungarian Warmblood", "Icelandic Horse", "Iomud", "Irish Draught", "Irish Sport Horse sometimes called Irish Hunter", "Italian Heavy Draft", "Italian Trotter", "Jaca Navarra", "Jeju Horse", "Jutland Horse", "Kabarda Horse", "Kafa", "Kaimanawa Horses", "Kalmyk Horse", "Karabair", "Karabakh Horse", "Karachai Horse", "Karossier", "Kathiawari", "Kazakh Horse", "Kentucky Mountain Saddle Horse", "Kiger Mustang", "Kinsky Horse", "Kisber Felver", "Kiso Horse", "Kladruber", "Knabstrupper", "Konik", "Kundudo", "Kustanair", "Kyrgyz Horse", "Latvian Horse", "Lipizzan", "Lithuanian Heavy Draught", "Lokai", "Losino Horse", "Lusitano", "Lyngshest", "M'Bayar", "M'Par", "Mallorqu\xEDn", "Malopolski", "Mangalarga", "Mangalarga Marchador", "Maremmano", "Marisme\xF1o Horse", "Marsh Tacky", "Marwari Horse", "Mecklenburger", "Menorqu\xEDn", "Messara Horse", "Metis Trotter", "Mez\u0151hegyesi Sport Horse", "Me\u0111imurje Horse", "Miniature Horse", "Misaki Horse", "Missouri Fox Trotter", "Monchina", "Mongolian Horse", "Mongolian Wild Horse", "Monterufolino", "Morab", "Morgan Horse", "Mountain Pleasure Horse", "Moyle Horse", "Murakoz Horse", "Murgese", "Mustang Horse", "M\xE9rens Horse", "Namib Desert Horse", "Nangchen Horse", "National Show Horse", "Nez Perce Horse", "Nivernais Horse", "Nokota Horse", "Noma", "Nonius Horse", "Nooitgedachter", "Nordlandshest", "Noriker Horse", "Norman Cob", "North American Single-Footer Horse", "North Swedish Horse", "Norwegian Coldblood Trotter", "Norwegian Fjord", "Novokirghiz", "Oberlander Horse", "Ogaden", "Oldenburg Horse", "Orlov trotter", "Ostfriesen", "Paint", "Pampa Horse", "Paso Fino", "Pentro Horse", "Percheron", "Persano Horse", "Peruvian Paso", "Pintabian", "Pleven Horse", "Poitevin Horse", "Posavac Horse", "Pottok", "Pryor Mountain Mustang", "Przewalski's Horse", "Pura Raza Espa\xF1ola", "Purosangue Orientale", "Qatgani", "Quarab", "Quarter Horse", "Racking Horse", "Retuerta Horse", "Rhenish German Coldblood", "Rhinelander Horse", "Riwoche Horse", "Rocky Mountain Horse", "Romanian Sporthorse", "Rottaler", "Russian Don", "Russian Heavy Draft", "Russian Trotter", "Saddlebred", "Salerno Horse", "Samolaco Horse", "San Fratello Horse", "Sarcidano Horse", "Sardinian Anglo-Arab", "Schleswig Coldblood", "Schwarzw\xE4lder Kaltblut", "Selale", "Sella Italiano", "Selle Fran\xE7ais", "Shagya Arabian", "Shan Horse", "Shire Horse", "Siciliano Indigeno", "Silesian Horse", "Sokolsky Horse", "Sorraia", "South German Coldblood", "Soviet Heavy Draft", "Spanish Anglo-Arab", "Spanish Barb", "Spanish Jennet Horse", "Spanish Mustang", "Spanish Tarpan", "Spanish-Norman Horse", "Spiti Horse", "Spotted Saddle Horse", "Standardbred Horse", "Suffolk Punch", "Swedish Ardennes", "Swedish Warmblood", "Swedish coldblood trotter", "Swiss Warmblood", "Taish\u016B Horse", "Takhi", "Tawleed", "Tchernomor", "Tennessee Walking Horse", "Tersk Horse", "Thoroughbred", "Tiger Horse", "Tinker Horse", "Tolfetano", "Tori Horse", "Trait Du Nord", "Trakehner", "Tsushima", "Tuigpaard", "Ukrainian Riding Horse", "Unmol Horse", "Uzunyayla", "Ventasso Horse", "Virginia Highlander", "Vlaamperd", "Vladimir Heavy Draft", "Vyatka", "Waler", "Waler Horse", "Walkaloosa", "Warlander", "Warmblood", "Welsh Cob", "Westphalian Horse", "Wielkopolski", "W\xFCrttemberger", "Xilingol Horse", "Yakutian Horse", "Yili Horse", "Yonaguni Horse", "Zaniskari", "Zhemaichu", "Zweibr\xFCcker", "\u017Demaitukas"];
var h = ["Acacia-ants", "Acorn-plum gall", "Aerial yellowjacket", "Africanized honey bee", "Allegheny mound ant", "Almond stone wasp", "Ant", "Arboreal ant", "Argentine ant", "Asian paper wasp", "Baldfaced hornet", "Bee", "Bigheaded ant", "Black and yellow mud dauber", "Black carpenter ant", "Black imported fire ant", "Blue horntail woodwasp", "Blue orchard bee", "Braconid wasp", "Bumble bee", "Carpenter ant", "Carpenter wasp", "Chalcid wasp", "Cicada killer", "Citrus blackfly parasitoid", "Common paper wasp", "Crazy ant", "Cuckoo wasp", "Cynipid gall wasp", "Eastern Carpenter bee", "Eastern yellowjacket", "Elm sawfly", "Encyrtid wasp", "Erythrina gall wasp", "Eulophid wasp", "European hornet", "European imported fire ant", "False honey ant", "Fire ant", "Forest bachac", "Forest yellowjacket", "German yellowjacket", "Ghost ant", "Giant ichneumon wasp", "Giant resin bee", "Giant wood wasp", "Golden northern bumble bee", "Golden paper wasp", "Gouty oak gall", "Grass Carrying Wasp", "Great black wasp", "Great golden digger wasp", "Hackberry nipple gall parasitoid", "Honey bee", "Horned oak gall", "Horse guard wasp", "Hunting wasp", "Ichneumonid wasp", "Keyhole wasp", "Knopper gall", "Large garden bumble bee", "Large oak-apple gall", "Leafcutting bee", "Little fire ant", "Little yellow ant", "Long-horned bees", "Long-legged ant", "Macao paper wasp", "Mallow bee", "Marble gall", "Mossyrose gall wasp", "Mud-daubers", "Multiflora rose seed chalcid", "Oak apple gall wasp", "Oak rough bulletgall wasp", "Oak saucer gall", "Oak shoot sawfly", "Odorous house ant", "Orange-tailed bumble bee", "Orangetailed potter wasp", "Oriental chestnut gall wasp", "Paper wasp", "Pavement ant", "Pigeon tremex", "Pip gall wasp", "Prairie yellowjacket", "Pteromalid wasp", "Pyramid ant", "Raspberry Horntail", "Red ant", "Red carpenter ant", "Red harvester ant", "Red imported fire ant", "Red wasp", "Red wood ant", "Red-tailed wasp", "Reddish carpenter ant", "Rough harvester ant", "Sawfly parasitic wasp", "Scale parasitoid", "Silky ant", "Sirex woodwasp", "Siricid woodwasp", "Smaller yellow ant", "Southeastern blueberry bee", "Southern fire ant", "Southern yellowjacket", "Sphecid wasp", "Stony gall", "Sweat bee", "Texas leafcutting ant", "Tiphiid wasp", "Torymid wasp", "Tramp ant", "Valentine ant", "Velvet ant", "Vespid wasp", "Weevil parasitoid", "Western harvester ant", "Western paper wasp", "Western thatching ant", "Western yellowjacket", "White-horned horntail", "Willow shoot sawfly", "Woodwasp", "Wool sower gall maker", "Yellow Crazy Ant", "Yellow and black potter wasp", "Yellow-horned horntail"];
var y = ["Asiatic Lion", "Barbary Lion", "Cape lion", "Masai Lion", "Northeast Congo Lion", "Transvaal lion", "West African Lion"];
var p2 = ["Ace", "Archie", "Bailey", "Bandit", "Bella", "Bentley", "Bruno", "Buddy", "Charlie", "Coco", "Cookie", "Cooper", "Daisy", "Dixie", "Finn", "Ginger", "Gracie", "Gus", "Hank", "Jack", "Jax", "Joey", "Kobe", "Leo", "Lola", "Louie", "Lucy", "Maggie", "Max", "Mia", "Milo", "Molly", "Murphey", "Nala", "Nova", "Ollie", "Oreo", "Rosie", "Scout", "Stella", "Teddy", "Tuffy"];
var g = ["American", "American Chinchilla", "American Fuzzy Lop", "American Sable", "Argente Brun", "Belgian Hare", "Beveren", "Blanc de Hotot", "Britannia Petite", "Californian", "Champagne D\u2019Argent", "Checkered Giant", "Cinnamon", "Cr\xE8me D\u2019Argent", "Dutch", "Dwarf Hotot", "English Angora", "English Lop", "English Spot", "Flemish Giant", "Florida White", "French Angora", "French Lop", "Giant Angora", "Giant Chinchilla", "Harlequin", "Havana", "Himalayan", "Holland Lop", "Jersey Wooly", "Lilac", "Lionhead", "Mini Lop", "Mini Rex", "Mini Satin", "Netherland Dwarf", "New Zealand", "Palomino", "Polish", "Rex", "Rhinelander", "Satin", "Satin Angora", "Silver", "Silver Fox", "Silver Marten", "Standard Chinchilla", "Tan", "Thrianta"];
var b = ["Abrocoma", "Abrocoma schistacea", "Aconaemys", "Aconaemys porteri", "African brush-tailed porcupine", "Andean mountain cavy", "Argentine tuco-tuco", "Ashy chinchilla rat", "Asiatic brush-tailed porcupine", "Atherurus", "Azara's agouti", "Azara's tuco-tuco", "Bahia porcupine", "Bathyergus", "Bathyergus janetta", "Bathyergus suillus", "Bennett's chinchilla rat", "Bicolored-spined porcupine", "Black agouti", "Black dwarf porcupine", "Black-rumped agouti", "Black-tailed hairy dwarf porcupine", "Bolivian chinchilla rat", "Bolivian tuco-tuco", "Bonetto's tuco-tuco", "Brandt's yellow-toothed cavy", "Brazilian guinea pig", "Brazilian porcupine", "Brazilian tuco-tuco", "Bridge's degu", "Brown hairy dwarf porcupine", "Budin's chinchilla rat, A. budini", "Cape porcupine", "Catamarca tuco-tuco", "Cavia", "Central American agouti", "Chacoan tuco-tuco", "Chilean rock rat", "Chinchilla", "Coendou", "Coiban agouti", "Colburn's tuco-tuco", "Collared tuco-tuco", "Common degu", "Common yellow-toothed cavy", "Conover's tuco-tuco", "Coruro", "Crested agouti", "Crested porcupine", "Cryptomys", "Cryptomys bocagei", "Cryptomys damarensis", "Cryptomys foxi", "Cryptomys hottentotus", "Cryptomys mechowi", "Cryptomys ochraceocinereus", "Cryptomys zechi", "Ctenomys", "Cuniculus", "Cuscomys", "Cuscomys ashanika", "Dactylomys", "Dactylomys boliviensis", "Dactylomys dactylinus", "Dactylomys peruanus", "Dasyprocta", "Domestic guinea pig", "Emily's tuco-tuco", "Erethizon", "Famatina chinchilla rat", "Frosted hairy dwarf porcupine", "Fukomys", "Fukomys amatus", "Fukomys anselli", "Fukomys bocagei", "Fukomys damarensis", "Fukomys darlingi", "Fukomys foxi", "Fukomys ilariae", "Fukomys kafuensis", "Fukomys mechowii", "Fukomys micklemi", "Fukomys occlusus", "Fukomys ochraceocinereus", "Fukomys whytei", "Fukomys zechi", "Furtive tuco-tuco", "Galea", "Georychus", "Georychus capensis", "Golden viscacha-rat", "Goya tuco-tuco", "Greater guinea pig", "Green acouchi", "Haig's tuco-tuco", "Heliophobius", "Heliophobius argenteocinereus", "Heterocephalus", "Heterocephalus glaber", "Highland tuco-tuco", "Hystrix", "Indian porcupine", "Isla Mocha degu", "Kalinowski agouti", "Kannabateomys", "Kannabateomys amblyonyx", "Lagidium", "Lagostomus", "Lewis' tuco-tuco", "Long-tailed chinchilla", "Long-tailed porcupine", "Los Chalchaleros' viscacha-rat", "Lowland paca", "Magellanic tuco-tuco", "Malayan porcupine", "Maule tuco-tuco", "Mendoza tuco-tuco", "Mexican agouti", "Mexican hairy dwarf porcupine", "Microcavia", "Montane guinea pig", "Moon-toothed degu", "Mottled tuco-tuco", "Mountain degu", "Mountain paca", "Mountain viscacha-rat", "Myoprocta", "Natterer's tuco-tuco", "North American porcupine", "Northern viscacha", "Octodon", "Octodontomys", "Octomys", "Olallamys", "Olallamys albicauda", "Olallamys edax", "Orinoco agouti", "Paraguaian hairy dwarf porcupine", "Pearson's tuco-tuco", "Peruvian tuco-tuco", "Philippine porcupine", "Pipanacoctomys", "Plains viscacha", "Plains viscacha-rat", "Porteous' tuco-tuco", "Punta de Vacas chinchilla rat", "Red acouchi", "Red-rumped agouti", "Reddish tuco-tuco", "Rio Negro tuco-tuco", "Robust tuco-tuco", "Roosmalen's dwarf porcupine", "Rothschild's porcupine", "Ruatan Island agouti", "Sage's rock rat", "Salinoctomys", "Salta tuco-tuco", "San Luis tuco-tuco", "Santa Catarina's guinea pig", "Shiny guinea pig", "Shipton's mountain cavy", "Short-tailed chinchilla", "Silky tuco-tuco", "Social tuco-tuco", "Southern mountain cavy", "Southern tuco-tuco", "Southern viscacha", "Spalacopus", "Spix's yellow-toothed cavy", "Steinbach's tuco-tuco", "Streaked dwarf porcupine", "Strong tuco-tuco", "Stump-tailed porcupine", "Sumatran porcupine", "Sunda porcupine", "Talas tuco-tuco", "Tawny tuco-tuco", "Thick-spined porcupine", "Tiny tuco-tuco", "Trichys", "Tucuman tuco-tuco", "Tympanoctomys", "Uspallata chinchilla rat", "White-toothed tuco-tuco", "Wolffsohn's viscacha"];
var C = ["Abaco Island boa", "Aesculapian snake", "African beaked snake", "African puff adder", "African rock python", "African twig snake", "African wolf snake", "Amazon tree boa", "Amazonian palm viper", "American Vine Snake", "American copperhead", "Amethystine python", "Anaconda", "Andaman cat snake", "Andaman cobra", "Angolan python", "Annulated sea snake", "Arabian cobra", "Arafura file snake", "Arizona black rattlesnake", "Arizona coral snake", "Aruba rattlesnake", "Asian Vine Snake, Whip Snake", "Asian cobra", "Asian keelback", "Asian pipe snake", "Asp", "Asp viper", "Assam keelback", "Australian copperhead", "Australian scrub python", "Baird's rat snake", "Baja California lyresnake", "Ball Python", "Ball python", "Bamboo pitviper", "Bamboo viper", "Banded Flying Snake", "Banded cat-eyed snake", "Banded krait", "Banded pitviper", "Banded water cobra", "Barbour's pit viper", "Barred wolf snake", "Beaked sea snake", "Beauty rat snake", "Beddome's cat snake", "Beddome's coral snake", "Bimini racer", "Bird snake", "Bismarck ringed python", "Black headed python", "Black krait", "Black mamba", "Black rat snake", "Black snake", "Black tree cobra", "Black-banded trinket snake", "Black-headed snake", "Black-necked cobra", "Black-necked spitting cobra", "Black-speckled palm-pitviper", "Black-striped keelback", "Black-tailed horned pit viper", "Blanding's tree snake", "Blind snake", "Blonde hognose snake", "Blood python", "Blue krait", "Blunt-headed tree snake", "Bluntnose viper", "Boa", "Boa constrictor", "Bocourt's water snake", "Boelen python", "Boiga", "Bolivian anaconda", "Boomslang", "Bornean pitviper", "Borneo short-tailed python", "Brahminy blind snake", "Brazilian coral snake", "Brazilian mud Viper", "Brazilian smooth snake", "Bredl's python", "Brongersma's pitviper", "Brown snake", "Brown spotted pitviper[4]", "Brown tree snake", "Brown water python", "Brown white-lipped python", "Buff striped keelback", "Bull snake", "Burmese keelback", "Burmese krait", "Burmese python", "Burrowing cobra", "Burrowing viper", "Bush viper", "Bushmaster", "Buttermilk racer", "Calabar python", "California kingsnake", "Canebrake", "Cantil", "Cantor's pitviper", "Cape cobra", "Cape coral snake", "Cape gopher snake", "Carpet viper", "Cascabel", "Caspian cobra", "Cat snake", "Cat-eyed night snake", "Cat-eyed snake", "Central American lyre snake", "Central ranges taipan", "Centralian carpet python", "Ceylon krait", "Chappell Island tiger snake", "Checkered garter snake", "Checkered keelback", "Chicken snake", "Chihuahuan ridge-nosed rattlesnake", "Children's python", "Chinese tree viper", "Coachwhip snake", "Coastal carpet python", "Coastal taipan", "Cobra", "Collett's snake", "Colorado desert sidewinder", "Common adder", "Common cobra", "Common garter snake", "Common ground snake", "Common keelback", "Common lancehead", "Common tiger snake", "Common worm snake", "Congo snake", "Congo water cobra", "Copperhead", "Coral snake", "Corn snake", "Coronado Island rattlesnake", "Cottonmouth", "Crossed viper", "Crowned snake", "Cuban boa", "Cuban wood snake", "Cyclades blunt-nosed viper", "Dauan Island water python", "De Schauensee's anaconda", "Death Adder", "Desert death adder", "Desert kingsnake", "Desert woma python", "Diamond python", "Dog-toothed cat snake", "Down's tiger snake", "Dubois's sea snake", "Dumeril's boa", "Durango rock rattlesnake", "Dusky pigmy rattlesnake", "Dusty hognose snake", "Dwarf beaked snake", "Dwarf boa", "Dwarf pipe snake", "Dwarf sand adder", "Eastern brown snake", "Eastern coral snake", "Eastern diamondback rattlesnake", "Eastern green mamba", "Eastern hognose snake", "Eastern lyre snake", "Eastern mud snake", "Eastern racer", "Eastern tiger snake", "Eastern water cobra", "Eastern yellowbelly sad racer", "Egg-eater", "Egyptian asp", "Egyptian cobra", "Elegant pitviper", "Emerald tree boa", "Equatorial spitting cobra", "European asp", "European smooth snake", "Eyelash palm-pitviper", "Eyelash pit viper", "Eyelash viper", "False cobra", "False horned viper", "False water cobra", "Fan-Si-Pan horned pitviper", "Fea's viper", "Fer-de-lance", "Fierce snake", "Fifty pacer", "Fishing snake", "Flat-nosed pitviper", "Flinders python", "Flying snake", "Forest cobra", "Forest flame snake", "Forsten's cat snake", "Fox snake, three species of Pantherophis", "Gaboon viper", "Garter snake", "Giant Malagasy hognose snake", "Godman's pit viper", "Gold tree cobra", "Gold-ringed cat snake", "Golden tree snake", "Grand Canyon rattlesnake", "Grass snake", "Gray cat snake", "Great Basin rattlesnake", "Great Lakes bush viper", "Great Plains rat snake", "Green anaconda", "Green cat-eyed snake", "Green mamba", "Green palm viper", "Green rat snake", "Green snake", "Green tree pit viper", "Green tree python", "Grey Lora", "Grey-banded kingsnake", "Ground snake", "Guatemalan palm viper", "Guatemalan tree viper", "Habu", "Habu pit viper", "Hagen's pitviper", "Hairy bush viper", "Halmahera python", "Hardwicke's sea snake", "Harlequin coral snake", "High Woods coral snake", "Hill keelback", "Himalayan keelback", "Hogg Island boa", "Hognose snake", "Hognosed viper", "Honduran palm viper", "Hook Nosed Sea Snake", "Hopi rattlesnake", "Horned adder", "Horned desert viper", "Horned viper", "Horseshoe pitviper", "Hundred pacer", "Hutton's tree viper", "Ikaheka snake", "Indian cobra", "Indian flying snake", "Indian krait", "Indian python", "Indian tree viper", "Indigo snake", "Indochinese spitting cobra", "Indonesian water python", "Inland carpet python", "Inland taipan", "Jamaican Tree Snake", "Jamaican boa", "Jan's hognose snake", "Japanese forest rat snake", "Japanese rat snake", "Japanese striped snake", "Javan spitting cobra", "Jerdon's pitviper", "Jumping viper", "Jungle carpet python", "Kanburian pit viper", "Kaulback's lance-headed pitviper", "Kayaudi dwarf reticulated python", "Kaznakov's viper", "Keelback", "Kham Plateau pitviper", "Khasi Hills keelback", "King Island tiger snake", "King brown", "King cobra", "King rat snake", "King snake", "Krait", "Krefft's tiger snake", "Lance-headed rattlesnake", "Lancehead", "Large shield snake", "Large-eyed pitviper", "Large-scaled tree viper", "Leaf viper", "Leaf-nosed viper", "Lesser black krait", "Levant viper", "Long-nosed adder", "Long-nosed tree snake", "Long-nosed viper", "Long-nosed whip snake", "Long-tailed rattlesnake", "Longnosed worm snake", "Lora", "Lyre snake", "Machete savane", "Macklot's python", "Madagascar ground boa", "Madagascar tree boa", "Malabar rock pitviper", "Malayan krait", "Malayan long-glanded coral snake", "Malayan pit viper", "Malcolm's tree viper", "Mamba", "Mamushi", "Manchurian Black Water Snake", "Mandalay cobra", "Mandarin rat snake", "Mangrove pit viper", "Mangrove snake", "Mangshan pitviper", "Many-banded krait", "Many-banded tree snake", "Many-horned adder", "Many-spotted cat snake", "Massasauga rattlesnake", "McMahon's viper", "Mexican black kingsnake", "Mexican green rattlesnake", "Mexican hognose snake", "Mexican palm-pitviper", "Mexican parrot snake", "Mexican racer", "Mexican vine snake", "Mexican west coast rattlesnake", "Midget faded rattlesnake", "Milk snake", "Moccasin snake", "Modest keelback", "Mojave desert sidewinder", "Mojave rattlesnake", "Mole viper", "Mollucan python", "Moluccan flying snake", "Montpellier snake", "Motuo bamboo pitviper", "Mountain adder", "Mozambique spitting cobra", "Mud adder", "Mud snake", "Mussurana", "Namaqua dwarf adder", "Namib dwarf sand adder", "Narrowhead Garter Snake", "New Guinea carpet python", "Nichell snake", "Nicobar Island keelback", "Nicobar bamboo pitviper", "Night snake", "Nightingale adder", "Nilgiri keelback", "Nitsche's bush viper", "Nitsche's tree viper", "North Philippine cobra", "North eastern king snake", "Northeastern hill krait", "Northern black-tailed rattlesnake", "Northern tree snake", "Northern water snake", "Northern white-lipped python", "Northwestern carpet python", "Nose-horned viper", "Nubian spitting cobra", "Oaxacan small-headed rattlesnake", "Oenpelli python", "Olive python", "Olive sea snake", "Orange-collared keelback", "Ornate flying snake", "Palestine viper", "Pallas' viper", "Palm viper", "Papuan python", "Paradise flying snake", "Parrot snake", "Patchnose snake", "Paupan taipan", "Pelagic sea snake", "Peninsula tiger snake", "Peringuey's adder", "Perrotet's shieldtail snake", "Persian rat snake", "Philippine cobra", "Philippine pitviper", "Pine snake", "Pipe snake", "Pit viper", "Pointed-scaled pit viper[5]", "Pope's tree viper", "Portuguese viper", "Prairie kingsnake", "Puerto Rican boa", "Puff adder", "Pygmy python", "Python", "Queen snake", "Racer", "Raddysnake", "Rainbow boa", "Rat snake", "Rattler", "Rattlesnake", "Red blood python", "Red diamond rattlesnake", "Red spitting cobra", "Red-backed rat snake", "Red-bellied black snake", "Red-headed krait", "Red-necked keelback", "Red-tailed bamboo pitviper", "Red-tailed boa", "Red-tailed pipe snake", "Reticulated python", "Rhinoceros viper", "Rhombic night adder", "Ribbon snake", "Rinkhals", "Rinkhals cobra", "River jack", "Rosy boa", "Rough green snake", "Rough-scaled bush viper", "Rough-scaled python", "Rough-scaled tree viper", "Royal python", "Rubber boa", "Rufous beaked snake", "Rungwe tree viper", "San Francisco garter snake", "Sand adder", "Sand boa", "Savu python", "Saw-scaled viper", "Scarlet kingsnake", "Schlegel's viper", "Schultze's pitviper", "Sea snake", "Sedge viper", "Selayer reticulated python", "Sharp-nosed viper", "Shield-nosed cobra", "Shield-tailed snake", "Siamese palm viper", "Side-striped palm-pitviper", "Sidewinder", "Sikkim keelback", "Sinai desert cobra", "Sind krait", "Small-eyed snake", "Smooth green snake", "Smooth snake", "Snorkel viper", "Snouted cobra", "Sonoran sidewinder", "South American hognose snake", "South eastern corn snake", "Southern Indonesian spitting cobra", "Southern Pacific rattlesnake", "Southern Philippine cobra", "Southern black racer", "Southern white-lipped python", "Southwestern black spitting cobra", "Southwestern blackhead snake", "Southwestern carpet python", "Southwestern speckled rattlesnake", "Speckle-bellied keelback", "Speckled kingsnake", "Spectacled cobra", "Spiny bush viper", "Spitting cobra", "Spotted python", "Sri Lankan pit viper", "Stejneger's bamboo pitviper", "Stiletto snake", "Stimson's python", "Stoke's sea snake", "Storm water cobra", "Striped snake", "Sumatran short-tailed python", "Sumatran tree viper", "Sunbeam snake", "Taipan", "Taiwan cobra", "Tan racer", "Tancitaran dusky rattlesnake", "Tanimbar python", "Tasmanian tiger snake", "Tawny cat snake", "Temple pit viper", "Temple viper", "Tentacled snake", "Texas Coral Snake", "Texas blind snake", "Texas garter snake", "Texas lyre snake", "Texas night snake", "Thai cobra", "Three-lined ground snake", "Tibetan bamboo pitviper", "Tic polonga", "Tiger pit viper", "Tiger rattlesnake", "Tiger snake", "Tigre snake", "Timber rattlesnake", "Timor python", "Titanboa", "Tree boa", "Tree snake", "Tree viper", "Trinket snake", "Tropical rattlesnake", "Twig snake", "Twin Headed King Snake", "Twin-Barred tree snake", "Twin-spotted rat snake", "Twin-spotted rattlesnake", "Undulated pit viper", "Uracoan rattlesnake", "Ursini's viper", "Urutu", "Vine snake", "Viper", "Viper Adder", "Vipera ammodytes", "Wagler's pit viper", "Wart snake", "Water adder", "Water moccasin", "Water snake", "West Indian racer", "Western blind snake", "Western carpet python", "Western coral snake", "Western diamondback rattlesnake", "Western green mamba", "Western ground snake", "Western hog-nosed viper", "Western mud snake", "Western tiger snake", "Western woma python", "Wetar Island python", "Whip snake", "White-lipped keelback", "White-lipped python", "White-lipped tree viper", "Wirot's pit viper", "Wolf snake", "Woma python", "Worm snake", "Wutu", "Wynaad keelback", "Yarara", "Yellow anaconda", "Yellow-banded sea snake", "Yellow-bellied sea snake", "Yellow-lined palm viper", "Yellow-lipped sea snake", "Yellow-striped rat snake", "Yunnan keelback", "Zebra snake", "Zebra spitting cobra"];
var S = ["bat", "bear", "bee", "bird", "butterfly", "cat", "cow", "crocodile", "deer", "dog", "dolphin", "eagle", "elephant", "fish", "flamingo", "fox", "frog", "gecko", "giraffe", "gorilla", "hamster", "hippopotamus", "horse", "kangaroo", "koala", "lion", "monkey", "ostrich", "panda", "parrot", "peacock", "penguin", "polar bear", "rabbit", "rhinoceros", "sea lion", "shark", "snake", "squirrel", "tiger", "turtle", "whale", "wolf", "zebra"];
var _a = { bear: n, bird: i, cat: t, cetacean: l, cow: s, crocodilia: d, dog: u, fish: c, horse: m, insect: h, lion: y, pet_name: p2, rabbit: g, rodent: b, snake: C, type: S };
var k = _a;
var f = ["{{person.name}}", "{{company.name}}"];
var v = ["Redhold", "Treeflex", "Trippledex", "Kanlam", "Bigtax", "Daltfresh", "Toughjoyfax", "Mat Lam Tam", "Otcom", "Tres-Zap", "Y-Solowarm", "Tresom", "Voltsillam", "Biodex", "Greenlam", "Viva", "Matsoft", "Temp", "Zoolab", "Subin", "Rank", "Job", "Stringtough", "Tin", "It", "Home Ing", "Zamit", "Sonsing", "Konklab", "Alpha", "Latlux", "Voyatouch", "Alphazap", "Holdlamis", "Zaam-Dox", "Sub-Ex", "Quo Lux", "Bamity", "Ventosanzap", "Lotstring", "Hatity", "Tempsoft", "Overhold", "Fixflex", "Konklux", "Zontrax", "Tampflex", "Span", "Namfix", "Transcof", "Stim", "Fix San", "Sonair", "Stronghold", "Fintone", "Y-find", "Opela", "Lotlux", "Ronstring", "Zathin", "Duobam", "Keylex"];
var A = ["0.#.#", "0.##", "#.##", "#.#", "#.#.#"];
var Qa = { author: f, name: v, version: A };
var B = Qa;
var T = ["A.A. Milne", "Agatha Christie", "Alan Moore and Dave Gibbons", "Albert Camus", "Aldous Huxley", "Alexander Pope", "Alexandre Dumas", "Alice Walker", "Andrew Lang", "Anne Frank", "Anthony Burgess", "Anthony Trollope", "Antoine de Saint-Exup\xE9ry", "Anton Chekhov", "Anton Pavlovich Chekhov", "Arthur Conan Doyle", "Arthur Schopenhauer", "Aylmer Maude", "Ayn Rand", "Beatrix Potter", "Benjamin Disraeli", "Benjamin Jowett", "Bernard Shaw", "Bertrand Russell", "Bhagavanlal Indrajit", "Boris Pasternak", "Bram Stoker", "Brian Evenson", "C.E. Brock", "C.S. Lewis", "Carson McCallers", "Charles Dickens", "Charles E. Derbyshire", "Charlotte Bront\xEB", "Charlotte Perkins Gilman", "Chinua Achebe", "Clifford R. Adams", "Constance Garnett", "Cormac McCarthy", "D.H. Lawrence", "Dan Brown", "Daniel Defoe", "Dante Alighieri", "Dashiell Hammett", "David Widger", "David Wyllie", "Dean Koontz", "Don DeLillo", "E.M. Forster", "Edgar Allan Poe", "Edgar Rice Burroughs", "Elizabeth Cleghorn Gaskell", "Elizabeth Von Arnim", "Emily Bront\xEB", "Erich Remarque", "Ernest Hemingway", "Evelyn Waugh", "F. Scott Fitzgerald", "Ford Madox Ford", "Frances Hodgson Burnett", "Frank Herbert", "Frank T. Merrill", "Franz Kafka", "Friedrich Wilhelm Nietzsche", "Fyodor Dostoyevsky", "G.K. Chesterton", "Gabriel Garcia Marquez", "Geoffrey Chaucer", "George Eliot", "George Grossmith", "George Orwell", "George R. R. Martin", "George Saunders", "Grady Ward", "Graham Greene", "Gustave Dor\xE9", "Gustave Flaubert", "Guy de Maupassant", "G\xFCnter Grass", "H.G. Wells", "H.P. Lovecraft", "Harper Lee", "Harriet Beecher Stowe", "Haruki Murakami", "Henrik Ibsen", "Henry David Thoreau", "Henry Fielding", "Henry James", "Henry Miller", "Henry Morley", "Herman Melville", "Hermann Broch", "Homer", "Honor\xE9 de Balzac", "Ian McEwan", "Isabel Florence Hapgood", "Italo Calvino", "J.D. Salinger", "J.K. Rowling", "J.M. Barrie", "J.R.R. Tolkien", "Jack Kerouac", "Jack London", "Jacob Grimm", "Jacqueline Crooks", "James Baldwin", "James Dickey", "James Ellroy", "James Joyce", "James Patterson", "Jane Austen", "Johann Wolfgang von Goethe", "John Bunyan", "John Camden Hotten", "John Dos Passos", "John Green", "John Grisham", "John Kennedy Toole", "John Milton", "John Ormsby", "John Steinbeck", "John Updike", "Jonathan Franzen", "Jonathan Swift", "Joseph Conrad", "Joseph Heller", "Jos\xE9 Rizal", "Judy Blume", "Jules Verne", "Junot Diaz", "Karl Marx", "Kazuo Ishiguro", "Ken Follett", "Ken Kesey", "Kenneth Grahame", "Khaled Hosseini", "Kingsley Amis", "Kurt Vonnegut", "L. Frank Baum", "L.M. Montgomery", "Laurence Sterne", "Leo Tolstoy", "Lewis Carroll", "Louisa May Alcott", "Louise Maude", "Malcolm Lowry", "Marcel Proust", "Margaret Atwood", "Margaret Mitchell", "Marilynne Robinson", "Mark Twain", "Martin Amis", "Mary Shelley", "Michael Chabon", "Miguel de Cervantes", "Mikhail Bulgakov", "Muriel Spark", "Nancy Mitford", "Nathanael West", "Nathaniel Hawthorne", "Neil Gaiman", "Niccolo Machiavelli", "Norman Mailer", "Oscar Levy", "Oscar Wilde", "P.G. Wodehouse", "Paulo Coelho", "Peter Carey", "Philip Pullman", "Philip Roth", "Plato", "R.L. Stine", "Rachel Kushner", "Ralph Ellison", "Ray Bradbury", "Raymond Chandler", "Richard Wagner", "Richard Wright", "Richard Yates", "Roald Dahl", "Robert Graves", "Robert Louis Stevenson", "Robert Penn Warren", "Rudyard Kipling", "Salman Rushdie", "Samuel Beckett", "Samuel Butler", "Samuel Richardson", "Saul Bellow", "Shivaram Parashuram Bhide", "Sir Arthur Conan Doyle", "Sir Richard Francis Burton", "Stendhal", "Stephen Hawking", "Stephen King", "Sun Tzu", "Suzanne Collins", "T. Smollett", "T.S. Eliot", "Theodore Alois Buckley", "Theodore Dreiser", "Thomas Hardy", "Thomas Love Peacock", "Thomas Mann", "Toni Morrison", "Truman Capote", "V.S. Naipaul", "Vance Packard", "Vatsyayana", "Victor Hugo", "Virgil", "Virginia Woolf", "Vladimir Nabokov", "Voltaire", "W.G. Sebald", "W.K. Marriott", "Walker Percy", "Walt Whitman", "Walter Scott", "Wilhelm Grimm", "Wilkie Collins", "William Faulkner", "William Gibson", "William Golding", "William Makepeace Thackeray", "William Shakespeare", "Zadie Smith"];
var M = ["Audiobook", "Ebook", "Hardcover", "Paperback"];
var w = ["Adventure", "Biography", "Business", "Children's Literature", "Classic", "Comedy", "Comic", "Detective", "Drama", "Fantasy", "Graphic Novel", "Historical Fiction", "Horror", "Memoir", "Mystery", "Mythology", "Philosophy", "Poetry", "Psychology", "Religion", "Romance", "Science Fiction", "Thriller", "Western", "Young Adult"];
var L = ["Academic Press", "Ace Books", "Addison-Wesley", "Adis International", "Airiti Press", "Allen Ltd", "Andrews McMeel Publishing", "Anova Books", "Anvil Press Poetry", "Applewood Books", "Apress", "Athabasca University Press", "Atheneum Books", "Atheneum Publishers", "Atlantic Books", "Atlas Press", "BBC Books", "Ballantine Books", "Banner of Truth Trust", "Bantam Books", "Bantam Spectra", "Barrie & Jenkins", "Basic Books", "Belknap Press", "Bella Books", "Bellevue Literary Press", "Berg Publishers", "Berkley Books", "Bison Books", "Black Dog Publishing", "Black Library", "Black Sparrow Books", "Blackie and Son Limited", "Blackstaff Press", "Blackwell Publishing", "Bloodaxe Books", "Bloomsbury Publishing Plc", "Blue Ribbon Books", "Book League of America", "Book Works", "Booktrope", "Borgo Press", "Bowes & Bowes", "Boydell & Brewer", "Breslov Research Institute", "Brill", "Brimstone Press", "Broadview Press", "Burns & Oates", "Butterworth-Heinemann", "Caister Academic Press", "Cambridge University Press", "Candlewick Press", "Canongate Books", "Carcanet Press", "Carlton Books", "Carlton Publishing Group", "Carnegie Mellon University Press", "Casemate Publishers", "Cengage Learning", "Central European University Press", "Chambers Harrap", "Charles Scribner's Sons", "Chatto and Windus", "Chick Publications", "Chronicle Books", "Churchill Livingstone", "Cisco Press", "City Lights Publishers", "Cloverdale Corporation", "D. Appleton & Company", "D. Reidel", "DAW Books", "Da Capo Press", "Daedalus Publishing", "Dalkey Archive Press", "Darakwon Press", "David & Charles", "Dedalus Books", "Del Rey Books", "E. P. Dutton", "ECW Press", "Earthscan", "Edupedia Publications", "Eel Pie Publishing", "Eerdmans Publishing", "Ellora's Cave", "Elsevier", "Emerald Group Publishing", "Etruscan Press", "FabJob", "Faber and Faber", "Fairview Press", "Farrar, Straus & Giroux", "Fearless Books", "Felony & Mayhem Press", "Firebrand Books", "Flame Tree Publishing", "Focal Press", "G-Unit Books", "G. P. Putnam's Sons", "Gaspereau Press", "Gay Men's Press", "Gefen Publishing House", "George H. Doran Company", "George Newnes", "George Routledge & Sons", "Godwit Press", "Golden Cockerel Press", "HMSO", "Hachette Book Group USA", "Hackett Publishing Company", "Hamish Hamilton", "Happy House", "Harcourt Assessment", "Harcourt Trade Publishers", "Harlequin Enterprises Ltd", "Harper & Brothers", "Harper & Row", "HarperCollins", "HarperPrism", "HarperTrophy", "Harry N. Abrams, Inc.", "Harvard University Press", "Harvest House", "Harvill Press at Random House", "Hawthorne Books", "Hay House", "Haynes Manuals", "Heyday Books", "Hodder & Stoughton", "Hodder Headline", "Hogarth Press", "Holland Park Press", "Holt McDougal", "Horizon Scientific Press", "Ian Allan Publishing", "Ignatius Press", "Imperial War Museum", "Indiana University Press", "J. M. Dent", "Jaico Publishing House", "Jarrolds Publishing", "John Blake Publishing", "Karadi Tales", "Kensington Books", "Kessinger Publishing", "Kodansha", "Kogan Page", "Koren Publishers Jerusalem", "Ladybird Books", "Leaf Books", "Leafwood Publishers", "Left Book Club", "Legend Books", "Lethe Press", "Libertas Academica", "Liberty Fund", "Library of America", "Lion Hudson", "Macmillan Publishers", "Mainstream Publishing", "Manchester University Press", "Mandrake Press", "Mandrake of Oxford", "Manning Publications", "Manor House Publishing", "Mapin Publishing", "Marion Boyars Publishers", "Mark Batty Publisher", "Marshall Cavendish", "Marshall Pickering", "Martinus Nijhoff Publishers", "Mascot Books", "Matthias Media", "McClelland and Stewart", "McFarland & Company", "McGraw Hill Financial", "McGraw-Hill Education", "Medknow Publications", "Naiad Press", "Nauka", "NavPress", "New Directions Publishing", "New English Library", "New Holland Publishers", "New Village Press", "Newnes", "No Starch Press", "Nonesuch Press", "O'Reilly Media", "Oberon Books", "Open Court Publishing Company", "Open University Press", "Orchard Books", "Orion Books", "Packt Publishing", "Palgrave Macmillan", "Pan Books", "Pantheon Books at Random House", "Papadakis Publisher", "Parachute Publishing", "Parragon", "Pathfinder Press", "Paulist Press", "Pavilion Books", "Peace Hill Press", "Pecan Grove Press", "Pen and Sword Books", "Penguin Books", "Random House", "Reed Elsevier", "Reed Publishing", "SAGE Publications", "Salt Publishing", "Sams Publishing", "Schocken Books", "Scholastic Press", "Seagull Books", "Secker & Warburg", "Shambhala Publications", "Shire Books", "Shoemaker & Hoard Publishers", "Shuter & Shooter Publishers", "Sidgwick & Jackson", "Signet Books", "Simon & Schuster", "St. Martin's Press", "T & T Clark", "Tachyon Publications", "Tammi", "Target Books", "Tarpaulin Sky Press", "Tartarus Press", "Tate Publishing & Enterprises", "Taunton Press", "Taylor & Francis", "Ten Speed Press", "UCL Press", "Unfinished Monument Press", "United States Government Publishing Office", "University of Akron Press", "University of Alaska Press", "University of California Press", "University of Chicago Press", "University of Michigan Press", "University of Minnesota Press", "University of Nebraska Press", "Velazquez Press", "Verso Books", "Victor Gollancz Ltd", "Viking Press", "Vintage Books", "Vintage Books at Random House", "Virago Press", "Virgin Publishing", "Voyager Books", "Zed Books", "Ziff Davis Media", "Zondervan"];
var D = ["A Song of Ice and Fire", "Anna Karenina", "Colonel Race", "Discworld", "Dune", "Harry Potter", "Hercule Poirot", "His Dark Materials", "Jane Austen Murder Mysteries", "Little Women", "Outlander", "Percy Jackson", "Sherlock Holmes", "The Arc of a Scythe", "The Bartimaeus Trilogy", "The Border Trilogy", "The Chronicles of Narnia", "The Dark Tower", "The Dresden Files", "The Eighth Life", "The Foundation Series", "The Hitchhiker's Guide to the Galaxy", "The Hunger Games", "The Infinity Cycle", "The Inheritance Cycle", "The Lord of the Rings", "The Maze Runner", "The Prison Healer", "The Red Rising Saga", "The Southern Reach", "The Wheel of Time", "Thursday Next Series", "Twilight", "War and Peace"];
var R = ["1984", "20,000 Leagues Under the Sea", "A Bend in the River", "A Brief History of Time", "A Clockwork Orange", "A Confederacy of Dunces", "A Doll's House", "A Handful of Dust", "A Modest Proposal", "A Passage to India", "A Portrait of the Artist as a Young Man", "A Room with a View", "A Study in Scarlet", "A Tale of Two Cities", "A Wrinkle in Time", "Absalom, Absalom!", "Adventures of Huckleberry Finn", "Alice's Adventures in Wonderland", "All Quiet on the Western Front", "All the King's Men", "American Pastoral", "An American Tragedy", "And Then There Were None", "Animal Farm", "Anna Karenina", "Anne of Green Gables", "Are You There God? It's Me, Margaret", "As I Lay Dying", "Atlas Shrugged", "Atonement", "Austerlitz", "Beloved", "Beyond Good and Evil", "Bible", "Bleak House", "Blood Meridian", "Brave New World", "Brideshead Revisited", "Candide", "Carmilla", "Catch-22", "Charlie and the Chocolate Factory", "Charlotte's Web", "Clarissa", "Cranford", "Crime and Punishment", "Dao De Jing: A Minimalist Translation", "David Copperfield", "Deliverance", "Don Quixote", "Dora", "Dr. Zhivago", "Dracula", "Dubliners", "Dune", "East of Eden", "Emma", "Fahrenheit 451", "Faust", "For Whom the Bell Tolls", "Frankenstein", "Freakonomics", "Go Tell It on the Mountain", "Gone with the Wind", "Great Expectations", "Grimms' Fairy Tales", "Gulliver's Travels", "Hamlet", "Harry Potter and the Sorcerer's Stone", "Heart of Darkness", "Herzog", "His Dark Materials", "Hitting the line", "Housekeeping", "I, Claudius", "If on a Winter's Night a Traveler", "In Cold Blood", "In Search of Lost Time", "Invisible Man", "It", "Jane Eyre", "Josefine Mutzenbacher", "Jude the Obscure", "L.A. Confidential", "Leaves of Grass", "Les Miserables", "Life of Pi", "Little Women", "Lolita", "Long Walk to Freedom", "Lord Jim", "Lord of the Flies", "Lucky Jim", "Madame Bovary", "Malone Dies", "Meditations", "Men Without Women", "Metamorphosis", "Middlemarch", "Midnight's Children", "Moby Dick", "Money", "Mrs. Dalloway", "My Bondage and My Freedom", "My Life", "Native Son", "Neuromancer", "Never Let Me Go", "Nightmare Abbey", "Nineteen Eighty Four", "Nostromo", "Notes from the Underground", "Of Mice and Men", "Oliver Twist", "On the Duty of Civil Disobedience", "On the Road", "One Flew Over the Cuckoo's Nest", "One Hundred Years of Solitude", "One Thousand and One Nights", "Oscar and Lucinda", "Pale Fire", "Paradise Lost", "Peter Pan", "Portnoy's Complaint", "Pride and Prejudice", "Rabbit, Run", "Republic", "Revolutionary Road", "Robinson Crusoe", "Romeo and Juliet", "Ruth Fielding in Alaska", "Scoop", "Second Treatise of Government", "Slaughterhouse Five", "Stories of Anton Chekhov", "Sybil", "Tess of the d'Urbervilles", "The Adventures of Augie March", "The Adventures of Huckleberry Finn", "The Adventures of Sherlock Holmes", "The Adventures of Tom Sawyer", "The Aeneid", "The Alchemist", "The Ambassadors", "The Art of War", "The Big Sleep", "The Black Sheep", "The Blue Castle", "The Brief Wondrous Life of Oscar Wao", "The Brothers Karamazov", "The Call of the Wild", "The Canterbury Tales", "The Catcher in the Rye", "The Color Purple", "The Complete Works of Edgar Allen Poe", "The Corrections", "The Count of Monte Cristo", "The Day of the Locust", "The Diary of a Nobody", "The Diary of a Young Girl", "The Divine Comedy", "The Enchanted April", "The Fountainhead", "The Golden Bowl", "The Golden Notebook", "The Good Soldier", "The Grapes of Wrath", "The Great Gatsby", "The Handmaid's Tale", "The Heart is a Lonely Hunter", "The Heart of the Matter", "The Hobbit", "The Hound of the Baskervilles", "The Idiot", "The Iliad", "The King in Yellow", "The Kite Runner", "The Lion, the Witch, and the Wardrobe", "The Little Prince", "The Lord of the Rings", "The Magic Mountain", "The Maltese Falcon", "The Master and Margarita", "The Moviegoer", "The Naked and the Dead", "The Odyssey", "The Old Man and the Sea", "The Pickwick Papers", "The Picture of Dorian Gray", "The Pilgrim's Progress", "The Pillars of the Earth", "The Plague", "The Portrait of a Lady", "The Prime of Miss Jean Brodie", "The Prince", "The Problems of Philosophy", "The Prophet", "The Pursuit of Love", "The Rainbow", "The Red and the Black", "The Remains of the Day", "The Republic", "The Scarlet Letter", "The Sleepwalkers", "The Sound and the Fury", "The Stand", "The Strange Case of Dr. Jekyll and Mr. Hyde", "The Stranger", "The Sun Also Rises", "The Thirty-Nine Steps", "The Three Musketeers", "The Time Machine", "The Tin Drum", "The Trial", "The War of the Worlds", "The Waste Land", "The Way We Live Now", "The Wind in the Willows", "The Woman in White", "The Wonderful Wizard of Oz", "The Works of Edgar Allan Poe", "The Yellow Wallpaper", "Things Fall Apart", "Tinker, Tailor, Soldier, Spy", "To Kill a Mockingbird", "To the Lighthouse", "Tom Jones", "Treasure Island", "Tristram Shandy", "Tropic of Cancer", "U.S.A. Trilogy", "Ulysses", "Uncle Tom's Cabin", "Under the Volcano", "Underworld", "Vanity Fair", "Walden", "War and Peace", "Watchmen", "Winnie-the-Pooh", "Wuthering Heights"];
var Xa = { author: T, format: M, genre: w, publisher: L, series: D, title: R };
var P = Xa;
var H = ["###-###-####", "(###) ###-####", "1-###-###-####", "###.###.####"];
var $a = { formats: H };
var W = $a;
var G = ["azure", "black", "blue", "cyan", "fuchsia", "gold", "green", "grey", "indigo", "ivory", "lavender", "lime", "magenta", "maroon", "mint green", "olive", "orange", "orchid", "pink", "plum", "purple", "red", "salmon", "silver", "sky blue", "tan", "teal", "turquoise", "violet", "white", "yellow"];
var er = { human: G };
var F = er;
var N = ["Automotive", "Baby", "Beauty", "Books", "Clothing", "Computers", "Electronics", "Games", "Garden", "Grocery", "Health", "Home", "Industrial", "Jewelry", "Kids", "Movies", "Music", "Outdoors", "Shoes", "Sports", "Tools", "Toys"];
var E = ["Discover the {{animal.type}}-like agility of our {{commerce.product}}, perfect for {{word.adjective}} users", "Discover the {{word.adjective}} new {{commerce.product}} with an exciting mix of {{commerce.productMaterial}} ingredients", "Ergonomic {{commerce.product}} made with {{commerce.productMaterial}} for all-day {{word.adjective}} support", "Experience the {{color.human}} brilliance of our {{commerce.product}}, perfect for {{word.adjective}} environments", "Featuring {{science.chemical_element.name}}-enhanced technology, our {{commerce.product}} offers unparalleled {{word.adjective}} performance", "Innovative {{commerce.product}} featuring {{word.adjective}} technology and {{commerce.productMaterial}} construction", "Introducing the {{location.country}}-inspired {{commerce.product}}, blending {{word.adjective}} style with local craftsmanship", "New {{color.human}} {{commerce.product}} with ergonomic design for {{word.adjective}} comfort", 'New {{commerce.product}} model with {{number.int({"min": 1, "max": 100})}} GB RAM, {{number.int({"min": 1, "max": 1000})}} GB storage, and {{word.adjective}} features', "Our {{animal.type}}-friendly {{commerce.product}} ensures {{word.adjective}} comfort for your pets", "Our {{food.adjective}}-inspired {{commerce.product}} brings a taste of luxury to your {{word.adjective}} lifestyle", "Professional-grade {{commerce.product}} perfect for {{word.adjective}} training and recreational use", "Savor the {{food.adjective}} essence in our {{commerce.product}}, designed for {{word.adjective}} culinary adventures", "Stylish {{commerce.product}} designed to make you stand out with {{word.adjective}} looks", "The sleek and {{word.adjective}} {{commerce.product}} comes with {{color.human}} LED lighting for smart functionality", "The {{color.human}} {{commerce.product}} combines {{location.country}} aesthetics with {{science.chemical_element.name}}-based durability", "The {{company.catchPhrase}} {{commerce.product}} offers reliable performance and {{word.adjective}} design", "The {{person.firstName}} {{commerce.product}} is the latest in a series of {{word.adjective}} products from {{company.name}}", "{{commerce.productAdjective}} {{commerce.product}} designed with {{commerce.productMaterial}} for {{word.adjective}} performance", "{{company.name}}'s most advanced {{commerce.product}} technology increases {{word.adjective}} capabilities"];
var J = { adjective: ["Awesome", "Bespoke", "Electronic", "Elegant", "Ergonomic", "Fantastic", "Fresh", "Frozen", "Generic", "Gorgeous", "Handcrafted", "Handmade", "Incredible", "Intelligent", "Licensed", "Luxurious", "Modern", "Oriental", "Practical", "Recycled", "Refined", "Rustic", "Sleek", "Small", "Soft", "Tasty", "Unbranded"], material: ["Aluminum", "Bamboo", "Bronze", "Ceramic", "Concrete", "Cotton", "Gold", "Granite", "Marble", "Metal", "Plastic", "Rubber", "Silk", "Steel", "Wooden"], product: ["Bacon", "Ball", "Bike", "Car", "Chair", "Cheese", "Chicken", "Chips", "Computer", "Fish", "Gloves", "Hat", "Keyboard", "Mouse", "Pants", "Pizza", "Salad", "Sausages", "Shirt", "Shoes", "Soap", "Table", "Towels", "Tuna"] };
var ar = { department: N, product_description: E, product_name: J };
var I = ar;
var K = ["AI-driven", "Adaptive", "Advanced", "Automated", "Balanced", "Business-focused", "Centralized", "Compatible", "Configurable", "Cross-platform", "Customer-focused", "Customizable", "Decentralized", "Devolved", "Digitized", "Distributed", "Diverse", "Enhanced", "Ergonomic", "Exclusive", "Expanded", "Extended", "Face to face", "Focused", "Front-line", "Fully-configurable", "Fundamental", "Future-proofed", "Grass-roots", "Horizontal", "Immersive", "Implemented", "Innovative", "Integrated", "Intuitive", "Managed", "Monitored", "Multi-tiered", "Networked", "Open-architected", "Open-source", "Operative", "Optimized", "Optional", "Organic", "Organized", "Persevering", "Persistent", "Phased", "Polarised", "Proactive", "Profit-focused", "Profound", "Programmable", "Progressive", "Public-key", "Quality-focused", "Reactive", "Realigned", "Reduced", "Reverse-engineered", "Robust", "Seamless", "Secured", "Self-enabling", "Sharable", "Smart", "Stand-alone", "Streamlined", "Sustainable", "Synchronised", "Team-oriented", "Total", "Triple-buffered", "Universal", "Upgradable", "User-centric", "User-friendly", "Versatile", "Virtual", "Visionary"];
var O = ["24/7", "AI-driven", "B2B", "B2C", "back-end", "best-of-breed", "bleeding-edge", "collaborative", "compelling", "cross-media", "cross-platform", "customized", "cutting-edge", "decentralized", "distributed", "dynamic", "efficient", "end-to-end", "enterprise", "extensible", "frictionless", "front-end", "generative", "global", "granular", "holistic", "immersive", "impactful", "innovative", "integrated", "interactive", "intuitive", "killer", "leading-edge", "magnetic", "mission-critical", "next-generation", "one-to-one", "open-source", "out-of-the-box", "plug-and-play", "proactive", "quantum", "real-time", "revolutionary", "rich", "robust", "scalable", "seamless", "smart", "sticky", "strategic", "sustainable", "synergistic", "transparent", "turn-key", "ubiquitous", "user-centric", "value-added", "vertical", "viral", "virtual", "visionary", "world-class"];
var x = ["AI", "ROI", "applications", "architectures", "blockchains", "channels", "communities", "content", "convergence", "deliverables", "e-commerce", "experiences", "functionalities", "infrastructures", "initiatives", "interfaces", "large language models", "lifetime value", "markets", "methodologies", "metrics", "mindshare", "models", "networks", "niches", "paradigms", "partnerships", "platforms", "relationships", "schemas", "smart contracts", "solutions", "supply-chains", "synergies", "systems", "technologies", "users", "web services"];
var z = ["aggregate", "architect", "benchmark", "brand", "collaborate", "cultivate", "deliver", "deploy", "disintermediate", "drive", "embrace", "empower", "enable", "engage", "engineer", "enhance", "evolve", "expedite", "exploit", "extend", "facilitate", "gamify", "generate", "grow", "harness", "implement", "incentivize", "incubate", "innovate", "integrate", "iterate", "leverage", "maximize", "mesh", "monetize", "optimize", "orchestrate", "productize", "redefine", "reinvent", "repurpose", "revolutionize", "scale", "seize", "simplify", "strategize", "streamline", "syndicate", "synthesize", "target", "transform", "transition", "unleash", "utilize", "visualize", "whiteboard"];
var V = ["24 hour", "24/7", "AI-powered", "actuating", "analyzing", "asymmetric", "asynchronous", "attitude-oriented", "bifurcated", "bottom-line", "clear-thinking", "client-driven", "client-server", "cloud-native", "coherent", "cohesive", "composite", "content-based", "context-sensitive", "contextually-based", "data-driven", "dedicated", "demand-driven", "directional", "discrete", "disintermediate", "dynamic", "eco-centric", "empowering", "encompassing", "executive", "explicit", "exuding", "fault-tolerant", "fresh-thinking", "full-range", "global", "heuristic", "high-level", "holistic", "homogeneous", "human-resource", "hybrid", "immersive", "impactful", "incremental", "intangible", "interactive", "intermediate", "leading edge", "local", "logistical", "maximized", "methodical", "mission-critical", "mobile", "modular", "motivating", "national", "needs-based", "neutral", "next generation", "optimal", "optimizing", "radical", "real-time", "reciprocal", "regional", "resilient", "responsive", "scalable", "secondary", "stable", "static", "sustainable", "system-worthy", "systematic", "systemic", "tangible", "tertiary", "transitional", "uniform", "user-facing", "value-added", "well-modulated", "zero administration", "zero defect", "zero tolerance", "zero trust"];
var Y = ["Group", "Inc", "LLC", "and Sons"];
var j = ["{{person.last_name.generic}} - {{person.last_name.generic}}", "{{person.last_name.generic}} {{company.legal_entity_type}}", "{{person.last_name.generic}}, {{person.last_name.generic}} and {{person.last_name.generic}}"];
var q = ["ability", "access", "adapter", "algorithm", "alliance", "analyzer", "application", "approach", "architecture", "archive", "array", "artificial intelligence", "attitude", "benchmark", "budgetary management", "capability", "capacity", "challenge", "circuit", "collaboration", "complexity", "concept", "conglomeration", "contingency", "core", "customer loyalty", "data-warehouse", "database", "definition", "emulation", "encoding", "encryption", "firmware", "flexibility", "focus group", "forecast", "frame", "framework", "function", "functionalities", "generative AI", "hardware", "help-desk", "hierarchy", "hub", "implementation", "infrastructure", "initiative", "installation", "instruction set", "interface", "internet solution", "intranet", "knowledge base", "knowledge user", "leverage", "local area network", "matrices", "matrix", "methodology", "microservice", "middleware", "migration", "model", "moderator", "monitoring", "moratorium", "neural-net", "open architecture", "orchestration", "paradigm", "parallelism", "policy", "portal", "pricing structure", "process improvement", "product", "productivity", "project", "projection", "protocol", "service-desk", "software", "solution", "standardization", "strategy", "structure", "success", "support", "synergy", "system engine", "task-force", "throughput", "time-frame", "toolset", "utilisation", "website", "workforce"];
var rr = { adjective: K, buzz_adjective: O, buzz_noun: x, buzz_verb: z, descriptor: V, legal_entity_type: Y, name_pattern: j, noun: q };
var U = rr;
var Z = ["avatar", "category", "comment", "createdAt", "email", "group", "id", "name", "password", "phone", "status", "title", "token", "updatedAt"];
var or = { column: Z };
var _ = or;
var Q = { wide: ["April", "August", "December", "February", "January", "July", "June", "March", "May", "November", "October", "September"], abbr: ["Apr", "Aug", "Dec", "Feb", "Jan", "Jul", "Jun", "Mar", "May", "Nov", "Oct", "Sep"] };
var X = { wide: ["Friday", "Monday", "Saturday", "Sunday", "Thursday", "Tuesday", "Wednesday"], abbr: ["Fri", "Mon", "Sat", "Sun", "Thu", "Tue", "Wed"] };
var nr = { month: Q, weekday: X };
var $ = nr;
var ee = ["Auto Loan", "Checking", "Credit Card", "Home Loan", "Investment", "Money Market", "Personal Loan", "Savings"];
var ae = ["34##-######-####L", "37##-######-####L"];
var re = ["30[0-5]#-######-###L", "36##-######-###L", "54##-####-####-###L"];
var oe = ["6011-####-####-###L", "64[4-9]#-####-####-###L", "65##-####-####-###L"];
var ne = ["3528-####-####-###L", "3529-####-####-###L", "35[3-8]#-####-####-###L"];
var ie = ["2[221-720]-####-####-###L", "5[1-5]##-####-####-###L"];
var te = ["4###########L", "4###-####-####-###L"];
var ir = { american_express: ae, diners_club: re, discover: oe, jcb: ne, mastercard: ie, visa: te };
var le = ir;
var se = [{ name: "UAE Dirham", code: "AED", symbol: "", numericCode: "784" }, { name: "Afghani", code: "AFN", symbol: "\u060B", numericCode: "971" }, { name: "Lek", code: "ALL", symbol: "Lek", numericCode: "008" }, { name: "Armenian Dram", code: "AMD", symbol: "", numericCode: "051" }, { name: "Netherlands Antillian Guilder", code: "ANG", symbol: "\u0192", numericCode: "532" }, { name: "Kwanza", code: "AOA", symbol: "", numericCode: "973" }, { name: "Argentine Peso", code: "ARS", symbol: "$", numericCode: "032" }, { name: "Australian Dollar", code: "AUD", symbol: "$", numericCode: "036" }, { name: "Aruban Guilder", code: "AWG", symbol: "\u0192", numericCode: "533" }, { name: "Azerbaijanian Manat", code: "AZN", symbol: "\u043C\u0430\u043D", numericCode: "944" }, { name: "Convertible Marks", code: "BAM", symbol: "KM", numericCode: "977" }, { name: "Barbados Dollar", code: "BBD", symbol: "$", numericCode: "052" }, { name: "Taka", code: "BDT", symbol: "", numericCode: "050" }, { name: "Bulgarian Lev", code: "BGN", symbol: "\u043B\u0432", numericCode: "975" }, { name: "Bahraini Dinar", code: "BHD", symbol: "", numericCode: "048" }, { name: "Burundi Franc", code: "BIF", symbol: "", numericCode: "108" }, { name: "Bermudian Dollar (customarily known as Bermuda Dollar)", code: "BMD", symbol: "$", numericCode: "060" }, { name: "Brunei Dollar", code: "BND", symbol: "$", numericCode: "096" }, { name: "Boliviano boliviano", code: "BOB", symbol: "Bs", numericCode: "068" }, { name: "Brazilian Real", code: "BRL", symbol: "R$", numericCode: "986" }, { name: "Bahamian Dollar", code: "BSD", symbol: "$", numericCode: "044" }, { name: "Pula", code: "BWP", symbol: "P", numericCode: "072" }, { name: "Belarusian Ruble", code: "BYN", symbol: "Rbl", numericCode: "933" }, { name: "Belize Dollar", code: "BZD", symbol: "BZ$", numericCode: "084" }, { name: "Canadian Dollar", code: "CAD", symbol: "$", numericCode: "124" }, { name: "Congolese Franc", code: "CDF", symbol: "", numericCode: "976" }, { name: "Swiss Franc", code: "CHF", symbol: "CHF", numericCode: "756" }, { name: "Chilean Peso", code: "CLP", symbol: "$", numericCode: "152" }, { name: "Yuan Renminbi", code: "CNY", symbol: "\xA5", numericCode: "156" }, { name: "Colombian Peso", code: "COP", symbol: "$", numericCode: "170" }, { name: "Costa Rican Colon", code: "CRC", symbol: "\u20A1", numericCode: "188" }, { name: "Cuban Peso", code: "CUP", symbol: "\u20B1", numericCode: "192" }, { name: "Cape Verde Escudo", code: "CVE", symbol: "", numericCode: "132" }, { name: "Czech Koruna", code: "CZK", symbol: "K\u010D", numericCode: "203" }, { name: "Djibouti Franc", code: "DJF", symbol: "", numericCode: "262" }, { name: "Danish Krone", code: "DKK", symbol: "kr", numericCode: "208" }, { name: "Dominican Peso", code: "DOP", symbol: "RD$", numericCode: "214" }, { name: "Algerian Dinar", code: "DZD", symbol: "", numericCode: "012" }, { name: "Egyptian Pound", code: "EGP", symbol: "\xA3", numericCode: "818" }, { name: "Nakfa", code: "ERN", symbol: "", numericCode: "232" }, { name: "Ethiopian Birr", code: "ETB", symbol: "", numericCode: "230" }, { name: "Euro", code: "EUR", symbol: "\u20AC", numericCode: "978" }, { name: "Fiji Dollar", code: "FJD", symbol: "$", numericCode: "242" }, { name: "Falkland Islands Pound", code: "FKP", symbol: "\xA3", numericCode: "238" }, { name: "Pound Sterling", code: "GBP", symbol: "\xA3", numericCode: "826" }, { name: "Lari", code: "GEL", symbol: "", numericCode: "981" }, { name: "Cedi", code: "GHS", symbol: "", numericCode: "936" }, { name: "Gibraltar Pound", code: "GIP", symbol: "\xA3", numericCode: "292" }, { name: "Dalasi", code: "GMD", symbol: "", numericCode: "270" }, { name: "Guinea Franc", code: "GNF", symbol: "", numericCode: "324" }, { name: "Quetzal", code: "GTQ", symbol: "Q", numericCode: "320" }, { name: "Guyana Dollar", code: "GYD", symbol: "$", numericCode: "328" }, { name: "Hong Kong Dollar", code: "HKD", symbol: "$", numericCode: "344" }, { name: "Lempira", code: "HNL", symbol: "L", numericCode: "340" }, { name: "Gourde", code: "HTG", symbol: "", numericCode: "332" }, { name: "Forint", code: "HUF", symbol: "Ft", numericCode: "348" }, { name: "Rupiah", code: "IDR", symbol: "Rp", numericCode: "360" }, { name: "New Israeli Sheqel", code: "ILS", symbol: "\u20AA", numericCode: "376" }, { name: "Bhutanese Ngultrum", code: "BTN", symbol: "Nu", numericCode: "064" }, { name: "Indian Rupee", code: "INR", symbol: "\u20B9", numericCode: "356" }, { name: "Iraqi Dinar", code: "IQD", symbol: "", numericCode: "368" }, { name: "Iranian Rial", code: "IRR", symbol: "\uFDFC", numericCode: "364" }, { name: "Iceland Krona", code: "ISK", symbol: "kr", numericCode: "352" }, { name: "Jamaican Dollar", code: "JMD", symbol: "J$", numericCode: "388" }, { name: "Jordanian Dinar", code: "JOD", symbol: "", numericCode: "400" }, { name: "Yen", code: "JPY", symbol: "\xA5", numericCode: "392" }, { name: "Kenyan Shilling", code: "KES", symbol: "", numericCode: "404" }, { name: "Som", code: "KGS", symbol: "\u043B\u0432", numericCode: "417" }, { name: "Riel", code: "KHR", symbol: "\u17DB", numericCode: "116" }, { name: "Comoro Franc", code: "KMF", symbol: "", numericCode: "174" }, { name: "North Korean Won", code: "KPW", symbol: "\u20A9", numericCode: "408" }, { name: "Won", code: "KRW", symbol: "\u20A9", numericCode: "410" }, { name: "Kuwaiti Dinar", code: "KWD", symbol: "", numericCode: "414" }, { name: "Cayman Islands Dollar", code: "KYD", symbol: "$", numericCode: "136" }, { name: "Tenge", code: "KZT", symbol: "\u043B\u0432", numericCode: "398" }, { name: "Kip", code: "LAK", symbol: "\u20AD", numericCode: "418" }, { name: "Lebanese Pound", code: "LBP", symbol: "\xA3", numericCode: "422" }, { name: "Sri Lanka Rupee", code: "LKR", symbol: "\u20A8", numericCode: "144" }, { name: "Liberian Dollar", code: "LRD", symbol: "$", numericCode: "430" }, { name: "Libyan Dinar", code: "LYD", symbol: "", numericCode: "434" }, { name: "Moroccan Dirham", code: "MAD", symbol: "", numericCode: "504" }, { name: "Moldovan Leu", code: "MDL", symbol: "", numericCode: "498" }, { name: "Malagasy Ariary", code: "MGA", symbol: "", numericCode: "969" }, { name: "Denar", code: "MKD", symbol: "\u0434\u0435\u043D", numericCode: "807" }, { name: "Kyat", code: "MMK", symbol: "", numericCode: "104" }, { name: "Tugrik", code: "MNT", symbol: "\u20AE", numericCode: "496" }, { name: "Pataca", code: "MOP", symbol: "", numericCode: "446" }, { name: "Ouguiya", code: "MRU", symbol: "", numericCode: "929" }, { name: "Mauritius Rupee", code: "MUR", symbol: "\u20A8", numericCode: "480" }, { name: "Rufiyaa", code: "MVR", symbol: "", numericCode: "462" }, { name: "Kwacha", code: "MWK", symbol: "", numericCode: "454" }, { name: "Mexican Peso", code: "MXN", symbol: "$", numericCode: "484" }, { name: "Malaysian Ringgit", code: "MYR", symbol: "RM", numericCode: "458" }, { name: "Metical", code: "MZN", symbol: "MT", numericCode: "943" }, { name: "Naira", code: "NGN", symbol: "\u20A6", numericCode: "566" }, { name: "Cordoba Oro", code: "NIO", symbol: "C$", numericCode: "558" }, { name: "Norwegian Krone", code: "NOK", symbol: "kr", numericCode: "578" }, { name: "Nepalese Rupee", code: "NPR", symbol: "\u20A8", numericCode: "524" }, { name: "New Zealand Dollar", code: "NZD", symbol: "$", numericCode: "554" }, { name: "Rial Omani", code: "OMR", symbol: "\uFDFC", numericCode: "512" }, { name: "Balboa", code: "PAB", symbol: "B/.", numericCode: "590" }, { name: "Nuevo Sol", code: "PEN", symbol: "S/.", numericCode: "604" }, { name: "Kina", code: "PGK", symbol: "", numericCode: "598" }, { name: "Philippine Peso", code: "PHP", symbol: "Php", numericCode: "608" }, { name: "Pakistan Rupee", code: "PKR", symbol: "\u20A8", numericCode: "586" }, { name: "Zloty", code: "PLN", symbol: "z\u0142", numericCode: "985" }, { name: "Guarani", code: "PYG", symbol: "Gs", numericCode: "600" }, { name: "Qatari Rial", code: "QAR", symbol: "\uFDFC", numericCode: "634" }, { name: "New Leu", code: "RON", symbol: "lei", numericCode: "946" }, { name: "Serbian Dinar", code: "RSD", symbol: "\u0414\u0438\u043D.", numericCode: "941" }, { name: "Russian Ruble", code: "RUB", symbol: "\u0440\u0443\u0431", numericCode: "643" }, { name: "Rwanda Franc", code: "RWF", symbol: "", numericCode: "646" }, { name: "Saudi Riyal", code: "SAR", symbol: "\uFDFC", numericCode: "682" }, { name: "Solomon Islands Dollar", code: "SBD", symbol: "$", numericCode: "090" }, { name: "Seychelles Rupee", code: "SCR", symbol: "\u20A8", numericCode: "690" }, { name: "Sudanese Pound", code: "SDG", symbol: "", numericCode: "938" }, { name: "Swedish Krona", code: "SEK", symbol: "kr", numericCode: "752" }, { name: "Singapore Dollar", code: "SGD", symbol: "$", numericCode: "702" }, { name: "Saint Helena Pound", code: "SHP", symbol: "\xA3", numericCode: "654" }, { name: "Leone", code: "SLE", symbol: "", numericCode: "925" }, { name: "Somali Shilling", code: "SOS", symbol: "S", numericCode: "706" }, { name: "Surinam Dollar", code: "SRD", symbol: "$", numericCode: "968" }, { name: "South Sudanese pound", code: "SSP", symbol: "", numericCode: "728" }, { name: "Dobra", code: "STN", symbol: "Db", numericCode: "930" }, { name: "Syrian Pound", code: "SYP", symbol: "\xA3", numericCode: "760" }, { name: "Lilangeni", code: "SZL", symbol: "", numericCode: "748" }, { name: "Baht", code: "THB", symbol: "\u0E3F", numericCode: "764" }, { name: "Somoni", code: "TJS", symbol: "", numericCode: "972" }, { name: "Manat", code: "TMT", symbol: "", numericCode: "934" }, { name: "Tunisian Dinar", code: "TND", symbol: "", numericCode: "788" }, { name: "Pa'anga", code: "TOP", symbol: "", numericCode: "776" }, { name: "Turkish Lira", code: "TRY", symbol: "\u20BA", numericCode: "949" }, { name: "Trinidad and Tobago Dollar", code: "TTD", symbol: "TT$", numericCode: "780" }, { name: "New Taiwan Dollar", code: "TWD", symbol: "NT$", numericCode: "901" }, { name: "Tanzanian Shilling", code: "TZS", symbol: "", numericCode: "834" }, { name: "Hryvnia", code: "UAH", symbol: "\u20B4", numericCode: "980" }, { name: "Uganda Shilling", code: "UGX", symbol: "", numericCode: "800" }, { name: "US Dollar", code: "USD", symbol: "$", numericCode: "840" }, { name: "Peso Uruguayo", code: "UYU", symbol: "$U", numericCode: "858" }, { name: "Uzbekistan Sum", code: "UZS", symbol: "\u043B\u0432", numericCode: "860" }, { name: "Venezuelan bol\xEDvar", code: "VES", symbol: "Bs", numericCode: "928" }, { name: "Dong", code: "VND", symbol: "\u20AB", numericCode: "704" }, { name: "Vatu", code: "VUV", symbol: "", numericCode: "548" }, { name: "Tala", code: "WST", symbol: "", numericCode: "882" }, { name: "CFA Franc BEAC", code: "XAF", symbol: "", numericCode: "950" }, { name: "East Caribbean Dollar", code: "XCD", symbol: "$", numericCode: "951" }, { name: "CFA Franc BCEAO", code: "XOF", symbol: "", numericCode: "952" }, { name: "CFP Franc", code: "XPF", symbol: "", numericCode: "953" }, { name: "Yemeni Rial", code: "YER", symbol: "\uFDFC", numericCode: "886" }, { name: "Rand", code: "ZAR", symbol: "R", numericCode: "710" }, { name: "Lesotho Loti", code: "LSL", symbol: "", numericCode: "426" }, { name: "Namibia Dollar", code: "NAD", symbol: "N$", numericCode: "516" }, { name: "Zambian Kwacha", code: "ZMW", symbol: "K", numericCode: "967" }, { name: "Zimbabwe Dollar", code: "ZWL", symbol: "", numericCode: "932" }];
var de = ["A {{finance.transactionType}} for {{finance.currencyCode}} {{finance.amount}} was made at {{company.name}} via card ending ****{{string.numeric(4)}} on account ***{{string.numeric(4)}}.", "A {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} occurred at {{company.name}} using a card ending in ****{{string.numeric(4)}} for account ***{{string.numeric(4)}}.", "Payment of {{finance.currencyCode}} {{finance.amount}} for {{finance.transactionType}} at {{company.name}}, processed with card ending ****{{string.numeric(4)}} linked to account ***{{string.numeric(4)}}.", "Transaction alert: {{finance.transactionType}} at {{company.name}} using card ending ****{{string.numeric(4)}} for an amount of {{finance.currencyCode}} {{finance.amount}} on account ***{{string.numeric(4)}}.", "You made a {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} using card ending in ****{{string.numeric(4)}} from account ***{{string.numeric(4)}}.", "Your {{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} was successful. Charged via card ****{{string.numeric(4)}} to account ***{{string.numeric(4)}}.", "{{finance.transactionType}} at {{company.name}} with a card ending in ****{{string.numeric(4)}} for {{finance.currencyCode}} {{finance.amount}} from account ***{{string.numeric(4)}}.", "{{finance.transactionType}} confirmed at {{company.name}} for {{finance.currencyCode}} {{finance.amount}}, card ending in ****{{string.numeric(4)}} associated with account ***{{string.numeric(4)}}.", "{{finance.transactionType}} of {{finance.currencyCode}} {{finance.amount}} at {{company.name}} charged to account ending in {{string.numeric(4)}} using card ending in ****{{string.numeric(4)}}.", "{{finance.transactionType}} processed at {{company.name}} for {{finance.currencyCode}} {{finance.amount}}, using card ending ****{{string.numeric(4)}}. Account: ***{{string.numeric(4)}}.", "{{finance.transactionType}} transaction at {{company.name}} using card ending with ****{{string.numeric(4)}} for {{finance.currencyCode}} {{finance.amount}} in account ***{{string.numeric(4)}}."];
var ue = ["deposit", "invoice", "payment", "withdrawal"];
var tr = { account_type: ee, credit_card: le, currency: se, transaction_description_pattern: de, transaction_type: ue };
var ce = tr;
var me = ["bitter", "creamy", "crispy", "crunchy", "delicious", "fluffy", "fresh", "golden", "juicy", "moist", "rich", "salty", "savory", "smoky", "sour", "spicy", "sweet", "tangy", "tender", "zesty"];
var he = ["A classic pie filled with delicious {{food.meat}} and {{food.adjective}} {{food.ingredient}}, baked in a {{food.adjective}} pastry crust and topped with a golden-brown lattice.", "A delightful tart combining {{food.adjective}} {{food.vegetable}} and sweet {{food.fruit}}, set in a buttery pastry shell and finished with a hint of {{food.spice}}.", "A heartwarming {{food.ethnic_category}} soup, featuring fresh {{food.ingredient}} and an aromatic blend of traditional spices.", "A robust {{food.adjective}} stew featuring {{food.ethnic_category}} flavors, loaded with {{food.adjective}} meat, {{food.adjective}} vegetables, and a {{food.adjective}}, {{food.adjective}} broth.", "A simple {{food.fruit}} pie. No fancy stuff. Just pie.", "A slow-roasted {{animal.bird}} with a {{food.adjective}}, {{food.adjective}} exterior. Stuffed with {{food.fruit}} and covered in {{food.fruit}} sauce. Sides with {{food.vegetable}} puree and wild {{food.vegetable}}.", "A special {{color.human}} {{food.ingredient}} from {{location.country}}. To support the strong flavor it is sided with a tablespoon of {{food.spice}}.", "A succulent {{food.meat}} steak, encased in a {{food.adjective}} {{food.spice}} crust, served with a side of {{food.spice}} mashed {{food.vegetable}}.", "An exquisite {{food.meat}} roast, infused with the essence of {{food.fruit}}, slow-roasted to bring out its natural flavors and served with a side of creamy {{food.vegetable}}", "Baked {{food.ingredient}}-stuffed {{food.meat}}, seasoned with {{food.spice}} and {{food.adjective}} herbs, accompanied by roasted {{food.vegetable}} medley.", "Crispy fried {{food.meat}} bites, seasoned with {{food.spice}} and served with a tangy {{food.fruit}} dipping sauce.", "Fresh mixed greens tossed with {{food.spice}}-rubbed {{food.meat}}, {{food.vegetable}}, and a light dressing.", "Fresh {{food.ingredient}} with a pinch of {{food.spice}}, topped by a caramelized {{food.fruit}} with whipped cream", "Grilled {{food.meat}} kebabs, marinated in {{food.ethnic_category}} spices and served with a fresh {{food.vegetable}} and {{food.fruit}} salad.", "Hearty {{food.ingredient}} and {{food.meat}} stew, slow-cooked with {{food.spice}} and {{food.vegetable}} for a comforting, flavorful meal.", "Juicy {{food.meat}}, grilled to your liking and drizzled with a bold {{food.spice}} sauce, served alongside roasted {{food.vegetable}}.", "Our {{food.adjective}} {{food.meat}}, slow-cooked to perfection, accompanied by steamed {{food.vegetable}} and a rich, savory gravy.", "Tender {{food.meat}} skewers, glazed with a sweet and tangy {{food.fruit}} sauce, served over a bed of fragrant jasmine rice.", "Tenderly braised {{food.meat}} in a rich {{food.spice}} and {{food.vegetable}} sauce, served with a side of creamy {{food.vegetable}}.", "Three {{food.ingredient}} with {{food.vegetable}}, {{food.vegetable}}, {{food.vegetable}}, {{food.vegetable}} and {{food.ingredient}}. With a side of baked {{food.fruit}}, and your choice of {{food.ingredient}} or {{food.ingredient}}.", '{{number.int({"min":1, "max":99})}}-day aged {{food.meat}} steak, with choice of {{number.int({"min":2, "max":4})}} sides.'];
var ye = ["California maki", "Peking duck", "Philadelphia maki", "arepas", "barbecue ribs", "bruschette with tomato", "bunny chow", "caesar salad", "caprese salad", "cauliflower penne", "cheeseburger", "chicken fajitas", "chicken milanese", "chicken parm", "chicken wings", "chilli con carne", "ebiten maki", "fettuccine alfredo", "fish and chips", "french fries with sausages", "french toast", "hummus", "katsu curry", "kebab", "lasagne", "linguine with clams", "massaman curry", "meatballs with sauce", "mushroom risotto", "pappardelle alla bolognese", "pasta and beans", "pasta carbonara", "pasta with tomato and basil", "pho", "pierogi", "pizza", "poke", "pork belly buns", "pork sausage roll", "poutine", "ricotta stuffed ravioli", "risotto with seafood", "salmon nigiri", "scotch eggs", "seafood paella", "som tam", "souvlaki", "stinky tofu", "sushi", "tacos", "teriyaki chicken donburi", "tiramis\xF9", "tuna sashimi", "vegetable soup"];
var pe = ["{{food.adjective}} {{food.ethnic_category}} stew", "{{food.adjective}} {{food.meat}} with {{food.vegetable}}", "{{food.ethnic_category}} {{food.ingredient}} soup", "{{food.fruit}} and {{food.fruit}} tart", "{{food.fruit}} pie", "{{food.fruit}}-glazed {{food.meat}} skewers", "{{food.fruit}}-infused {{food.meat}} roast", "{{food.ingredient}} and {{food.meat}} pie", "{{food.ingredient}}-infused {{food.meat}}", "{{food.meat}} steak", "{{food.meat}} with {{food.fruit}} sauce", "{{food.spice}}-crusted {{food.meat}}", "{{food.spice}}-rubbed {{food.meat}} salad", "{{food.vegetable}} salad", "{{person.first_name.generic}}'s special {{food.ingredient}}"];
var ge = ["Ainu", "Albanian", "American", "Andhra", "Anglo-Indian", "Arab", "Argentine", "Armenian", "Assyrian", "Awadhi", "Azerbaijani", "Balochi", "Bangladeshi", "Bashkir", "Belarusian", "Bengali", "Berber", "Brazilian", "British", "Buddhist", "Bulgarian", "Cajun", "Cantonese", "Caribbean", "Chechen", "Chinese", "Chinese Islamic", "Circassian", "Crimean Tatar", "Cypriot", "Czech", "Danish", "Egyptian", "English", "Eritrean", "Estonian", "Ethiopian", "Filipino", "French", "Georgian", "German", "Goan", "Goan Catholic", "Greek", "Gujarati", "Hyderabad", "Indian", "Indian Chinese", "Indian Singaporean", "Indonesian", "Inuit", "Irish", "Italian", "Italian-American", "Jamaican", "Japanese", "Jewish - Israeli", "Karnataka", "Kazakh", "Keralite", "Korean", "Kurdish", "Laotian", "Latvian", "Lebanese", "Lithuanian", "Louisiana Creole", "Maharashtrian", "Malay", "Malaysian Chinese", "Malaysian Indian", "Mangalorean", "Mediterranean", "Mennonite", "Mexican", "Mordovian", "Mughal", "Native American", "Nepalese", "New Mexican", "Odia", "Pakistani", "Parsi", "Pashtun", "Pennsylvania Dutch", "Peranakan", "Persian", "Peruvian", "Polish", "Portuguese", "Punjabi", "Qu\xE9b\xE9cois", "Rajasthani", "Romani", "Romanian", "Russian", "Sami", "Serbian", "Sindhi", "Slovak", "Slovenian", "Somali", "South Indian", "Soviet", "Spanish", "Sri Lankan", "Taiwanese", "Tamil", "Tatar", "Texan", "Thai", "Turkish", "Udupi", "Ukrainian", "Vietnamese", "Yamal", "Zambian", "Zanzibari"];
var be = ["apple", "apricot", "aubergine", "avocado", "banana", "berry", "blackberry", "blood orange", "blueberry", "bush tomato", "butternut pumpkin", "cantaloupe", "cavalo", "cherry", "corella pear", "cranberry", "cumquat", "currant", "custard apple", "custard apples daikon", "date", "dragonfruit", "dried apricot", "elderberry", "feijoa", "fig", "fingerlime", "goji berry", "grape", "grapefruit", "guava", "honeydew melon", "incaberry", "jarrahdale pumpkin", "juniper berry", "kiwi fruit", "kiwiberry", "lemon", "lime", "longan", "loquat", "lychee", "mandarin", "mango", "mangosteen", "melon", "mulberry", "nashi pear", "nectarine", "olive", "orange", "papaw", "papaya", "passionfruit", "peach", "pear", "pineapple", "plum", "pomegranate", "prune", "rockmelon", "snowpea", "sprout", "starfruit", "strawberry", "sultana", "tangelo", "tomato", "watermelon"];
var Ce = ["achacha", "adzuki beans", "agar", "agave syrup", "ajowan seed", "albacore tuna", "alfalfa", "allspice", "almond oil", "almonds", "amaranth", "amchur", "anchovies", "aniseed", "annatto seed", "apple cider vinegar", "apple juice", "apple juice concentrate", "apples", "apricots", "arborio rice", "arrowroot", "artichoke", "arugula", "asafoetida", "asian greens", "asian noodles", "asparagus", "aubergine", "avocado", "avocado oil", "avocado spread", "bacon", "baking powder", "baking soda", "balsamic vinegar", "bamboo shoots", "banana", "barberry", "barley", "barramundi", "basil basmati rice", "bay leaves", "bean shoots", "bean sprouts", "beans", "beef", "beef stock", "beetroot", "berries", "besan", "black eyed beans", "blackberries", "blood oranges", "blue cheese", "blue eye trevalla", "blue swimmer crab", "blueberries", "bocconcini", "bok choy", "bonito flakes", "bonza", "borlotti beans", "bran", "brazil nut", "bread", "brie", "broccoli", "broccolini", "brown flour", "brown mushrooms", "brown rice", "brown rice vinegar", "brussels sprouts", "buckwheat", "buckwheat flour", "buckwheat noodles", "bulghur", "bush tomato", "butter", "butter beans", "buttermilk", "butternut lettuce", "butternut pumpkin", "cabbage", "cacao", "cake", "calamari", "camellia tea oil", "camembert", "camomile", "candle nut", "cannellini beans", "canola oil", "cantaloupe", "capers", "capsicum", "caraway seed", "cardamom", "carob carrot", "carrot", "cashews", "cassia bark", "cauliflower", "cavalo", "cayenne", "celery", "celery seed", "cheddar", "cherries", "chestnut", "chia seeds", "chicken", "chicken stock", "chickory", "chickpea", "chilli pepper", "chinese cabbage", "chinese five spice", "chives", "choy sum", "cinnamon", "clams", "cloves", "cocoa powder", "coconut", "coconut oil", "coconut water", "coffee", "common cultivated mushrooms", "corella pear", "coriander leaves", "coriander seed", "corn oil", "corn syrup", "corn tortilla", "cornichons", "cornmeal", "cos lettuce", "cottage cheese", "cous cous", "crabs", "cranberry", "cream", "cream cheese", "cucumber", "cumin", "cumquat", "currants", "curry leaves", "curry powder", "custard apples", "dandelion", "dark chocolate", "dashi", "dates", "dill", "dragonfruit", "dried apricots", "dried chinese broccoli", "duck", "edam", "edamame", "eggplant", "eggs", "elderberry", "endive", "english spinach", "enoki mushrooms", "extra virgin olive oil", "farmed prawns", "feijoa", "fennel", "fennel seeds", "fenugreek", "feta", "figs", "file powder", "fingerlime", "fish sauce", "fish stock", "flat mushrooms", "flathead", "flaxseed", "flaxseed oil", "flounder", "flour", "freekeh", "french eschallots", "fresh chillies", "fromage blanc", "fruit", "galangal", "garam masala", "garlic", "goat cheese", "goat milk", "goji berry", "grape seed oil", "grapefruit", "grapes", "green beans", "green pepper", "green tea", "green tea noodles", "greenwheat freekeh", "gruyere", "guava", "gula melaka", "haloumi", "ham", "haricot beans", "harissa", "hazelnut", "hijiki", "hiramasa kingfish", "hokkien noodles", "honey", "honeydew melon", "horseradish", "hot smoked salmon", "hummus", "iceberg lettuce", "incaberries", "jarrahdale pumpkin", "jasmine rice", "jelly", "jerusalem artichoke", "jewfish", "jicama", "juniper berries", "kale", "kangaroo", "kecap manis", "kenchur", "kidney beans", "kidneys", "kiwi berries", "kiwi fruit", "kohlrabi", "kokam", "kombu", "koshihikari rice", "kudzu", "kumera", "lamb", "lavender flowers", "leeks", "lemon", "lemongrass", "lentils", "lettuce", "licorice", "lime leaves", "limes", "liver", "lobster", "longan", "loquats", "lotus root", "lychees", "macadamia nut", "macadamia oil", "mace", "mackerel", "mahi mahi", "mahlab", "malt vinegar", "mandarins", "mango", "mangosteens", "maple syrup", "margarine", "marigold", "marjoram", "mastic", "melon", "milk", "milk chocolate", "mint", "miso", "molasses", "monkfish", "morwong", "mountain bread", "mozzarella", "muesli", "mulberries", "mullet", "mung beans", "mussels", "mustard", "mustard seed", "nashi pear", "nasturtium", "nectarines", "nori", "nutmeg", "nutritional yeast", "nuts", "oat flour", "oatmeal", "oats", "octopus", "okra", "olive oil", "olives", "omega spread", "onion", "oranges", "oregano", "oyster mushrooms", "oyster sauce", "oysters", "pandanus leaves", "papaw", "papaya", "paprik", "parmesan cheese", "parrotfish", "parsley", "parsnip", "passionfruit", "pasta", "peaches", "peanuts", "pear", "pear juice", "pears", "peas", "pecan nut", "pecorino", "pepitas", "peppercorns", "peppermint", "peppers", "persimmon", "pine nut", "pineapple", "pinto beans", "pistachio nut", "plums", "polenta", "pomegranate", "poppy seed", "porcini mushrooms", "pork", "potato flour", "potatoes", "provolone", "prunes", "pumpkin", "pumpkin seed", "purple carrot", "purple rice", "quark", "quince", "quinoa", "radicchio", "radish", "raisin", "raspberry", "red cabbage", "red lentils", "red pepper", "red wine", "red wine vinegar", "redfish", "rhubarb", "rice flour", "rice noodles", "rice paper", "rice syrup", "ricemilk", "ricotta", "rockmelon", "rose water", "rosemary", "rye", "rye bread", "safflower oil", "saffron", "sage", "sake", "salmon", "sardines", "sausages", "scallops", "sea salt", "semolina", "sesame oil", "sesame seeds", "shark", "shiitake mushrooms", "silverbeet", "slivered almonds", "smoked trout", "snapper", "snowpea sprouts", "snowpeas", "soba", "sour dough bread", "soy", "soy beans", "soy flour", "soy milk", "soy sauce", "soymilk", "spearmint", "spelt", "spelt bread", "spinach", "spring onions", "sprouts", "squash", "squid", "star anise", "star fruit", "starfruit", "stevia", "strawberries", "sugar", "sultanas", "sun-dried tomatoes", "sunflower oil", "sunflower seeds", "sweet chilli sauce", "sweet potato", "swiss chard", "swordfish", "szechuan pepperberry", "tabasco", "tahini", "taleggio cheese", "tamari", "tamarillo", "tangelo", "tapioca", "tapioca flour", "tarragon", "tea", "tea oil", "tempeh", "thyme", "tinned", "tofu", "tom yum", "tomatoes", "trout", "tuna", "turkey", "turmeric", "turnips", "unbleached flour", "vanilla beans", "vegetable oil", "vegetable spaghetti", "vegetable stock", "vermicelli noodles", "vinegar", "wakame", "walnut", "warehou", "wasabi", "water", "watercress", "watermelon", "wattleseed", "wheat", "wheatgrass juice", "white bread", "white flour", "white rice", "white wine", "white wine vinegar", "whiting wild rice", "wholegrain bread", "wholemeal", "wholewheat flour", "william pear", "yeast", "yellow papaw", "yellowtail kingfish", "yoghurt", "yogurt", "zucchini"];
var Se = ["beef", "chicken", "crocodile", "duck", "emu", "goose", "kangaroo", "lamb", "ostrich", "pigeon", "pork", "quail", "rabbit", "salmon", "turkey", "venison"];
var ke = ["achiote seed", "ajwain seed", "ajwan seed", "allspice", "amchoor", "anise", "anise star", "aniseed", "annatto seed", "arrowroot", "asafoetida", "baharat", "balti masala", "balti stir fry mix", "basil", "bay leaves", "bbq", "caraway seed", "cardamom", "cassia", "cayenne pepper", "celery", "chamomile", "chervil", "chilli", "chilli pepper", "chillies", "china star", "chives", "cinnamon", "cloves", "colombo", "coriander", "cumin", "curly leaf parsley", "curry", "dhansak", "dill", "fennel seed", "fenugreek", "fines herbes", "five spice", "french lavender", "galangal", "garam masala", "garlic", "german chamomile", "ginger", "green cardamom", "herbes de provence", "jalfrezi", "jerk", "kaffir leaves", "korma", "lavender", "lemon grass", "lemon pepper", "lime leaves", "liquorice root", "mace", "mango", "marjoram", "methi", "mint", "mustard", "nutmeg", "onion seed", "orange zest", "oregano", "paprika", "parsley", "pepper", "peppercorns", "pimento", "piri piri", "poppy seed", "pot marjoram", "poudre de colombo", "ras-el-hanout", "rice paper", "rogan josh", "rose baie", "rosemary", "saffron", "sage", "sesame seed", "spearmint", "sumac", "sweet basil", "sweet laurel", "tagine", "tandoori masala", "tarragon", "thyme", "tikka masala", "turmeric", "vanilla", "zahtar"];
var fe = ["artichoke", "arugula", "asian greens", "asparagus", "bean shoots", "bean sprouts", "beans", "beetroot", "bok choy", "broccoli", "broccolini", "brussels sprouts", "butternut lettuce", "cabbage", "capers", "carob carrot", "carrot", "cauliflower", "celery", "chilli pepper", "chinese cabbage", "chives", "cornichons", "cos lettuce", "cucumber", "dried chinese broccoli", "eggplant", "endive", "english spinach", "french eschallots", "fresh chillies", "garlic", "green beans", "green pepper", "hijiki", "iceberg lettuce", "jerusalem artichoke", "jicama", "kale", "kohlrabi", "leeks", "lettuce", "okra", "onion", "parsnip", "peas", "peppers", "potatoes", "pumpkin", "purple carrot", "radicchio", "radish", "raspberry", "red cabbage", "red pepper", "rhubarb", "snowpea sprouts", "spinach", "squash", "sun dried tomatoes", "sweet potato", "swiss chard", "turnips", "zucchini"];
var lr = { adjective: me, description_pattern: he, dish: ye, dish_pattern: pe, ethnic_category: ge, fruit: be, ingredient: Ce, meat: Se, spice: ke, vegetable: fe };
var ve = lr;
var Ae = ["1080p", "auxiliary", "back-end", "bluetooth", "cross-platform", "digital", "haptic", "mobile", "multi-byte", "neural", "online", "open-source", "optical", "primary", "redundant", "solid state", "virtual", "wireless"];
var Be = ["backing up", "bypassing", "calculating", "compressing", "connecting", "copying", "generating", "hacking", "indexing", "navigating", "overriding", "parsing", "programming", "quantifying", "synthesizing", "transmitting"];
var Te = ["alarm", "application", "array", "bandwidth", "bus", "capacitor", "card", "circuit", "driver", "feed", "firewall", "hard drive", "interface", "matrix", "microchip", "monitor", "panel", "pixel", "port", "program", "protocol", "sensor", "system", "transmitter"];
var Me = ["I'll {{verb}} the {{adjective}} {{abbreviation}} {{noun}}, that should {{noun}} the {{abbreviation}} {{noun}}!", "If we {{verb}} the {{noun}}, we can get to the {{abbreviation}} {{noun}} through the {{adjective}} {{abbreviation}} {{noun}}!", "The {{abbreviation}} {{noun}} is down, {{verb}} the {{adjective}} {{noun}} so we can {{verb}} the {{abbreviation}} {{noun}}!", "Try to {{verb}} the {{abbreviation}} {{noun}}, maybe it will {{verb}} the {{adjective}} {{noun}}!", "Use the {{adjective}} {{abbreviation}} {{noun}}, then you can {{verb}} the {{adjective}} {{noun}}!", "We need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!", "You can't {{verb}} the {{noun}} without {{ingverb}} the {{adjective}} {{abbreviation}} {{noun}}!", "{{ingverb}} the {{noun}} won't do anything, we need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!"];
var we = ["back up", "bypass", "calculate", "compress", "connect", "copy", "generate", "hack", "index", "input", "navigate", "override", "parse", "program", "quantify", "reboot", "synthesize", "transmit"];
var sr = { adjective: Ae, ingverb: Be, noun: Te, phrase: Me, verb: we };
var Le = sr;
var De = ["biz", "com", "info", "name", "net", "org"];
var Re = ["example.com", "example.net", "example.org"];
var Pe = ["gmail.com", "hotmail.com", "yahoo.com"];
var dr = { domain_suffix: De, example_email: Re, free_email: Pe };
var He = dr;
var We = ["#####", "####", "###"];
var Ge = ["Abilene", "Akron", "Alafaya", "Alameda", "Albany", "Albuquerque", "Alexandria", "Alhambra", "Aliso Viejo", "Allen", "Allentown", "Aloha", "Alpharetta", "Altadena", "Altamonte Springs", "Altoona", "Amarillo", "Ames", "Anaheim", "Anchorage", "Anderson", "Ankeny", "Ann Arbor", "Annandale", "Antelope", "Antioch", "Apex", "Apopka", "Apple Valley", "Appleton", "Arcadia", "Arden-Arcade", "Arecibo", "Arlington", "Arlington Heights", "Arvada", "Ashburn", "Asheville", "Aspen Hill", "Atascocita", "Athens-Clarke County", "Atlanta", "Attleboro", "Auburn", "Augusta-Richmond County", "Aurora", "Austin", "Avondale", "Azusa", "Bakersfield", "Baldwin Park", "Baltimore", "Barnstable Town", "Bartlett", "Baton Rouge", "Battle Creek", "Bayamon", "Bayonne", "Baytown", "Beaumont", "Beavercreek", "Beaverton", "Bedford", "Bel Air South", "Bell Gardens", "Belleville", "Bellevue", "Bellflower", "Bellingham", "Bend", "Bentonville", "Berkeley", "Berwyn", "Bethesda", "Bethlehem", "Billings", "Biloxi", "Binghamton", "Birmingham", "Bismarck", "Blacksburg", "Blaine", "Bloomington", "Blue Springs", "Boca Raton", "Boise City", "Bolingbrook", "Bonita Springs", "Bossier City", "Boston", "Bothell", "Boulder", "Bountiful", "Bowie", "Bowling Green", "Boynton Beach", "Bozeman", "Bradenton", "Brandon", "Brentwood", "Bridgeport", "Bristol", "Brockton", "Broken Arrow", "Brookhaven", "Brookline", "Brooklyn Park", "Broomfield", "Brownsville", "Bryan", "Buckeye", "Buena Park", "Buffalo", "Buffalo Grove", "Burbank", "Burien", "Burke", "Burleson", "Burlington", "Burnsville", "Caguas", "Caldwell", "Camarillo", "Cambridge", "Camden", "Canton", "Cape Coral", "Carlsbad", "Carmel", "Carmichael", "Carolina", "Carrollton", "Carson", "Carson City", "Cary", "Casa Grande", "Casas Adobes", "Casper", "Castle Rock", "Castro Valley", "Catalina Foothills", "Cathedral City", "Catonsville", "Cedar Hill", "Cedar Park", "Cedar Rapids", "Centennial", "Centreville", "Ceres", "Cerritos", "Champaign", "Chandler", "Chapel Hill", "Charleston", "Charlotte", "Charlottesville", "Chattanooga", "Cheektowaga", "Chesapeake", "Chesterfield", "Cheyenne", "Chicago", "Chico", "Chicopee", "Chino", "Chino Hills", "Chula Vista", "Cicero", "Cincinnati", "Citrus Heights", "Clarksville", "Clearwater", "Cleveland", "Cleveland Heights", "Clifton", "Clovis", "Coachella", "Coconut Creek", "Coeur d'Alene", "College Station", "Collierville", "Colorado Springs", "Colton", "Columbia", "Columbus", "Commerce City", "Compton", "Concord", "Conroe", "Conway", "Coon Rapids", "Coral Gables", "Coral Springs", "Corona", "Corpus Christi", "Corvallis", "Costa Mesa", "Council Bluffs", "Country Club", "Covina", "Cranston", "Cupertino", "Cutler Bay", "Cuyahoga Falls", "Cypress", "Dale City", "Dallas", "Daly City", "Danbury", "Danville", "Davenport", "Davie", "Davis", "Dayton", "Daytona Beach", "DeKalb", "DeSoto", "Dearborn", "Dearborn Heights", "Decatur", "Deerfield Beach", "Delano", "Delray Beach", "Deltona", "Denton", "Denver", "Des Moines", "Des Plaines", "Detroit", "Diamond Bar", "Doral", "Dothan", "Downers Grove", "Downey", "Draper", "Dublin", "Dubuque", "Duluth", "Dundalk", "Dunwoody", "Durham", "Eagan", "East Hartford", "East Honolulu", "East Lansing", "East Los Angeles", "East Orange", "East Providence", "Eastvale", "Eau Claire", "Eden Prairie", "Edina", "Edinburg", "Edmond", "El Cajon", "El Centro", "El Dorado Hills", "El Monte", "El Paso", "Elgin", "Elizabeth", "Elk Grove", "Elkhart", "Ellicott City", "Elmhurst", "Elyria", "Encinitas", "Enid", "Enterprise", "Erie", "Escondido", "Euclid", "Eugene", "Euless", "Evanston", "Evansville", "Everett", "Fairfield", "Fall River", "Fargo", "Farmington", "Farmington Hills", "Fayetteville", "Federal Way", "Findlay", "Fishers", "Flagstaff", "Flint", "Florence-Graham", "Florin", "Florissant", "Flower Mound", "Folsom", "Fond du Lac", "Fontana", "Fort Collins", "Fort Lauderdale", "Fort Myers", "Fort Pierce", "Fort Smith", "Fort Wayne", "Fort Worth", "Fountain Valley", "Fountainebleau", "Framingham", "Franklin", "Frederick", "Freeport", "Fremont", "Fresno", "Frisco", "Fullerton", "Gainesville", "Gaithersburg", "Galveston", "Garden Grove", "Gardena", "Garland", "Gary", "Gastonia", "Georgetown", "Germantown", "Gilbert", "Gilroy", "Glen Burnie", "Glendale", "Glendora", "Glenview", "Goodyear", "Grand Forks", "Grand Island", "Grand Junction", "Grand Prairie", "Grand Rapids", "Grapevine", "Great Falls", "Greeley", "Green Bay", "Greensboro", "Greenville", "Greenwood", "Gresham", "Guaynabo", "Gulfport", "Hacienda Heights", "Hackensack", "Haltom City", "Hamilton", "Hammond", "Hampton", "Hanford", "Harlingen", "Harrisburg", "Harrisonburg", "Hartford", "Hattiesburg", "Haverhill", "Hawthorne", "Hayward", "Hemet", "Hempstead", "Henderson", "Hendersonville", "Hesperia", "Hialeah", "Hicksville", "High Point", "Highland", "Highlands Ranch", "Hillsboro", "Hilo", "Hoboken", "Hoffman Estates", "Hollywood", "Homestead", "Honolulu", "Hoover", "Houston", "Huntersville", "Huntington", "Huntington Beach", "Huntington Park", "Huntsville", "Hutchinson", "Idaho Falls", "Independence", "Indianapolis", "Indio", "Inglewood", "Iowa City", "Irondequoit", "Irvine", "Irving", "Jackson", "Jacksonville", "Janesville", "Jefferson City", "Jeffersonville", "Jersey City", "Johns Creek", "Johnson City", "Joliet", "Jonesboro", "Joplin", "Jupiter", "Jurupa Valley", "Kalamazoo", "Kannapolis", "Kansas City", "Kearny", "Keller", "Kendale Lakes", "Kendall", "Kenner", "Kennewick", "Kenosha", "Kent", "Kentwood", "Kettering", "Killeen", "Kingsport", "Kirkland", "Kissimmee", "Knoxville", "Kokomo", "La Crosse", "La Habra", "La Mesa", "La Mirada", "Lacey", "Lafayette", "Laguna Niguel", "Lake Charles", "Lake Elsinore", "Lake Forest", "Lake Havasu City", "Lake Ridge", "Lakeland", "Lakeville", "Lakewood", "Lancaster", "Lansing", "Laredo", "Largo", "Las Cruces", "Las Vegas", "Lauderhill", "Lawrence", "Lawton", "Layton", "League City", "Lee's Summit", "Leesburg", "Lehi", "Lehigh Acres", "Lenexa", "Levittown", "Lewisville", "Lexington-Fayette", "Lincoln", "Linden", "Little Rock", "Littleton", "Livermore", "Livonia", "Lodi", "Logan", "Lombard", "Lompoc", "Long Beach", "Longmont", "Longview", "Lorain", "Los Angeles", "Louisville/Jefferson County", "Loveland", "Lowell", "Lubbock", "Lynchburg", "Lynn", "Lynwood", "Macon-Bibb County", "Madera", "Madison", "Malden", "Manchester", "Manhattan", "Mansfield", "Manteca", "Maple Grove", "Margate", "Maricopa", "Marietta", "Marysville", "Mayaguez", "McAllen", "McKinney", "McLean", "Medford", "Melbourne", "Memphis", "Menifee", "Mentor", "Merced", "Meriden", "Meridian", "Mesa", "Mesquite", "Metairie", "Methuen Town", "Miami", "Miami Beach", "Miami Gardens", "Middletown", "Midland", "Midwest City", "Milford", "Millcreek", "Milpitas", "Milwaukee", "Minneapolis", "Minnetonka", "Minot", "Miramar", "Mishawaka", "Mission", "Mission Viejo", "Missoula", "Missouri City", "Mobile", "Modesto", "Moline", "Monroe", "Montebello", "Monterey Park", "Montgomery", "Moore", "Moreno Valley", "Morgan Hill", "Mount Pleasant", "Mount Prospect", "Mount Vernon", "Mountain View", "Muncie", "Murfreesboro", "Murray", "Murrieta", "Nampa", "Napa", "Naperville", "Nashua", "Nashville-Davidson", "National City", "New Bedford", "New Braunfels", "New Britain", "New Brunswick", "New Haven", "New Orleans", "New Rochelle", "New York", "Newark", "Newport Beach", "Newport News", "Newton", "Niagara Falls", "Noblesville", "Norfolk", "Normal", "Norman", "North Bethesda", "North Charleston", "North Highlands", "North Las Vegas", "North Lauderdale", "North Little Rock", "North Miami", "North Miami Beach", "North Port", "North Richland Hills", "Norwalk", "Novato", "Novi", "O'Fallon", "Oak Lawn", "Oak Park", "Oakland", "Oakland Park", "Ocala", "Oceanside", "Odessa", "Ogden", "Oklahoma City", "Olathe", "Olympia", "Omaha", "Ontario", "Orange", "Orem", "Orland Park", "Orlando", "Oro Valley", "Oshkosh", "Overland Park", "Owensboro", "Oxnard", "Palatine", "Palm Bay", "Palm Beach Gardens", "Palm Coast", "Palm Desert", "Palm Harbor", "Palm Springs", "Palmdale", "Palo Alto", "Paradise", "Paramount", "Parker", "Parma", "Pasadena", "Pasco", "Passaic", "Paterson", "Pawtucket", "Peabody", "Pearl City", "Pearland", "Pembroke Pines", "Pensacola", "Peoria", "Perris", "Perth Amboy", "Petaluma", "Pflugerville", "Pharr", "Philadelphia", "Phoenix", "Pico Rivera", "Pine Bluff", "Pine Hills", "Pinellas Park", "Pittsburg", "Pittsburgh", "Pittsfield", "Placentia", "Plainfield", "Plano", "Plantation", "Pleasanton", "Plymouth", "Pocatello", "Poinciana", "Pomona", "Pompano Beach", "Ponce", "Pontiac", "Port Arthur", "Port Charlotte", "Port Orange", "Port St. Lucie", "Portage", "Porterville", "Portland", "Portsmouth", "Potomac", "Poway", "Providence", "Provo", "Pueblo", "Quincy", "Racine", "Raleigh", "Rancho Cordova", "Rancho Cucamonga", "Rancho Palos Verdes", "Rancho Santa Margarita", "Rapid City", "Reading", "Redding", "Redlands", "Redmond", "Redondo Beach", "Redwood City", "Reno", "Renton", "Reston", "Revere", "Rialto", "Richardson", "Richland", "Richmond", "Rio Rancho", "Riverside", "Riverton", "Riverview", "Roanoke", "Rochester", "Rochester Hills", "Rock Hill", "Rockford", "Rocklin", "Rockville", "Rockwall", "Rocky Mount", "Rogers", "Rohnert Park", "Rosemead", "Roseville", "Roswell", "Round Rock", "Rowland Heights", "Rowlett", "Royal Oak", "Sacramento", "Saginaw", "Salem", "Salina", "Salinas", "Salt Lake City", "Sammamish", "San Angelo", "San Antonio", "San Bernardino", "San Bruno", "San Buenaventura (Ventura)", "San Clemente", "San Diego", "San Francisco", "San Jacinto", "San Jose", "San Juan", "San Leandro", "San Luis Obispo", "San Marcos", "San Mateo", "San Rafael", "San Ramon", "San Tan Valley", "Sandy", "Sandy Springs", "Sanford", "Santa Ana", "Santa Barbara", "Santa Clara", "Santa Clarita", "Santa Cruz", "Santa Fe", "Santa Maria", "Santa Monica", "Santa Rosa", "Santee", "Sarasota", "Savannah", "Sayreville", "Schaumburg", "Schenectady", "Scottsdale", "Scranton", "Seattle", "Severn", "Shawnee", "Sheboygan", "Shoreline", "Shreveport", "Sierra Vista", "Silver Spring", "Simi Valley", "Sioux City", "Sioux Falls", "Skokie", "Smyrna", "Somerville", "South Bend", "South Gate", "South Hill", "South Jordan", "South San Francisco", "South Valley", "South Whittier", "Southaven", "Southfield", "Sparks", "Spokane", "Spokane Valley", "Spring", "Spring Hill", "Spring Valley", "Springdale", "Springfield", "St. Charles", "St. Clair Shores", "St. Cloud", "St. George", "St. Joseph", "St. Louis", "St. Louis Park", "St. Paul", "St. Peters", "St. Petersburg", "Stamford", "State College", "Sterling Heights", "Stillwater", "Stockton", "Stratford", "Strongsville", "Suffolk", "Sugar Land", "Summerville", "Sunnyvale", "Sunrise", "Sunrise Manor", "Surprise", "Syracuse", "Tacoma", "Tallahassee", "Tamarac", "Tamiami", "Tampa", "Taunton", "Taylor", "Taylorsville", "Temecula", "Tempe", "Temple", "Terre Haute", "Texas City", "The Hammocks", "The Villages", "The Woodlands", "Thornton", "Thousand Oaks", "Tigard", "Tinley Park", "Titusville", "Toledo", "Toms River", "Tonawanda", "Topeka", "Torrance", "Town 'n' Country", "Towson", "Tracy", "Trenton", "Troy", "Trujillo Alto", "Tuckahoe", "Tucson", "Tulare", "Tulsa", "Turlock", "Tuscaloosa", "Tustin", "Twin Falls", "Tyler", "Union City", "University", "Upland", "Urbana", "Urbandale", "Utica", "Vacaville", "Valdosta", "Vallejo", "Vancouver", "Victoria", "Victorville", "Vineland", "Virginia Beach", "Visalia", "Vista", "Waco", "Waipahu", "Waldorf", "Walnut Creek", "Waltham", "Warner Robins", "Warren", "Warwick", "Washington", "Waterbury", "Waterloo", "Watsonville", "Waukegan", "Waukesha", "Wauwatosa", "Wellington", "Wesley Chapel", "West Allis", "West Babylon", "West Covina", "West Des Moines", "West Hartford", "West Haven", "West Jordan", "West Lafayette", "West New York", "West Palm Beach", "West Sacramento", "West Seneca", "West Valley City", "Westfield", "Westland", "Westminster", "Weston", "Weymouth Town", "Wheaton", "White Plains", "Whittier", "Wichita", "Wichita Falls", "Wilmington", "Wilson", "Winston-Salem", "Woodbury", "Woodland", "Worcester", "Wylie", "Wyoming", "Yakima", "Yonkers", "Yorba Linda", "York", "Youngstown", "Yuba City", "Yucaipa", "Yuma"];
var Fe = ["{{location.city_prefix}} {{person.first_name.generic}}{{location.city_suffix}}", "{{location.city_prefix}} {{person.first_name.generic}}", "{{person.first_name.generic}}{{location.city_suffix}}", "{{person.last_name.generic}}{{location.city_suffix}}", "{{location.city_name}}"];
var Ne = ["North", "East", "West", "South", "New", "Lake", "Port", "Fort"];
var Ee = ["town", "ton", "land", "ville", "berg", "burgh", "boro", "borough", "bury", "view", "port", "mouth", "stad", "stead", "furt", "chester", "cester", "fort", "field", "haven", "side", "shire", "worth"];
var Je = ["Africa", "Antarctica", "Asia", "Australia", "Europe", "North America", "South America"];
var Ie = ["Afghanistan", "Aland Islands", "Albania", "Algeria", "American Samoa", "Andorra", "Angola", "Anguilla", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Aruba", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bonaire, Sint Eustatius and Saba", "Bosnia and Herzegovina", "Botswana", "Bouvet Island", "Brazil", "British Indian Ocean Territory (Chagos Archipelago)", "Brunei Darussalam", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Cayman Islands", "Central African Republic", "Chad", "Chile", "China", "Christmas Island", "Cocos (Keeling) Islands", "Colombia", "Comoros", "Congo", "Cook Islands", "Costa Rica", "Cote d'Ivoire", "Croatia", "Cuba", "Curacao", "Cyprus", "Czechia", "Democratic Republic of the Congo", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Eswatini", "Ethiopia", "Faroe Islands", "Falkland Islands (Malvinas)", "Fiji", "Finland", "France", "French Guiana", "French Polynesia", "French Southern Territories", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guadeloupe", "Guam", "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Heard Island and McDonald Islands", "Holy See (Vatican City State)", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", "Isle of Man", "Israel", "Italy", "Jamaica", "Japan", "Jersey", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Democratic People's Republic of Korea", "Republic of Korea", "Kuwait", "Kyrgyz Republic", "Lao People's Democratic Republic", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libyan Arab Jamahiriya", "Liechtenstein", "Lithuania", "Luxembourg", "Macao", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Martinique", "Mauritania", "Mauritius", "Mayotte", "Mexico", "Micronesia", "Moldova", "Monaco", "Mongolia", "Montenegro", "Montserrat", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "New Caledonia", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Niue", "Norfolk Island", "North Macedonia", "Northern Mariana Islands", "Norway", "Oman", "Pakistan", "Palau", "Palestine", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Pitcairn Islands", "Poland", "Portugal", "Puerto Rico", "Qatar", "Reunion", "Romania", "Russian Federation", "Rwanda", "Saint Barthelemy", "Saint Helena", "Saint Kitts and Nevis", "Saint Lucia", "Saint Martin", "Saint Pierre and Miquelon", "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe", "Saudi Arabia", "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Sint Maarten", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Georgia and the South Sandwich Islands", "South Sudan", "Spain", "Sri Lanka", "Sudan", "Suriname", "Svalbard & Jan Mayen Islands", "Sweden", "Switzerland", "Syrian Arab Republic", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "Timor-Leste", "Togo", "Tokelau", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Turks and Caicos Islands", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States of America", "United States Minor Outlying Islands", "Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Vietnam", "Virgin Islands, British", "Virgin Islands, U.S.", "Wallis and Futuna", "Western Sahara", "Yemen", "Zambia", "Zimbabwe"];
var Ke = ["Adams County", "Calhoun County", "Carroll County", "Clark County", "Clay County", "Crawford County", "Douglas County", "Fayette County", "Franklin County", "Grant County", "Greene County", "Hamilton County", "Hancock County", "Henry County", "Jackson County", "Jefferson County", "Johnson County", "Lake County", "Lawrence County", "Lee County", "Lincoln County", "Logan County", "Madison County", "Marion County", "Marshall County", "Monroe County", "Montgomery County", "Morgan County", "Perry County", "Pike County", "Polk County", "Scott County", "Union County", "Warren County", "Washington County", "Wayne County", "Avon", "Bedfordshire", "Berkshire", "Borders", "Buckinghamshire", "Cambridgeshire", "Central", "Cheshire", "Cleveland", "Clwyd", "Cornwall", "County Antrim", "County Armagh", "County Down", "County Fermanagh", "County Londonderry", "County Tyrone", "Cumbria", "Derbyshire", "Devon", "Dorset", "Dumfries and Galloway", "Durham", "Dyfed", "East Sussex", "Essex", "Fife", "Gloucestershire", "Grampian", "Greater Manchester", "Gwent", "Gwynedd County", "Hampshire", "Herefordshire", "Hertfordshire", "Highlands and Islands", "Humberside", "Isle of Wight", "Kent", "Lancashire", "Leicestershire", "Lincolnshire", "Lothian", "Merseyside", "Mid Glamorgan", "Norfolk", "North Yorkshire", "Northamptonshire", "Northumberland", "Nottinghamshire", "Oxfordshire", "Powys", "Rutland", "Shropshire", "Somerset", "South Glamorgan", "South Yorkshire", "Staffordshire", "Strathclyde", "Suffolk", "Surrey", "Tayside", "Tyne and Wear", "Warwickshire", "West Glamorgan", "West Midlands", "West Sussex", "West Yorkshire", "Wiltshire", "Worcestershire"];
var Oe = { cardinal: ["North", "East", "South", "West"], cardinal_abbr: ["N", "E", "S", "W"], ordinal: ["Northeast", "Northwest", "Southeast", "Southwest"], ordinal_abbr: ["NE", "NW", "SE", "SW"] };
var xe = [{ name: "Afrikaans", alpha2: "af", alpha3: "afr" }, { name: "Azerbaijani", alpha2: "az", alpha3: "aze" }, { name: "Maldivian", alpha2: "dv", alpha3: "div" }, { name: "Farsi/Persian", alpha2: "fa", alpha3: "fas" }, { name: "Latvian", alpha2: "lv", alpha3: "lav" }, { name: "Indonesian", alpha2: "id", alpha3: "ind" }, { name: "Nepali", alpha2: "ne", alpha3: "nep" }, { name: "Thai", alpha2: "th", alpha3: "tha" }, { name: "Uzbek", alpha2: "uz", alpha3: "uzb" }, { name: "Yoruba", alpha2: "yo", alpha3: "yor" }, { name: "Pashto", alpha2: "ps", alpha3: "pus" }, { name: "English", alpha2: "en", alpha3: "eng" }, { name: "Urdu", alpha2: "ur", alpha3: "urd" }, { name: "German", alpha2: "de", alpha3: "deu" }, { name: "French", alpha2: "fr", alpha3: "fra" }, { name: "Spanish", alpha2: "es", alpha3: "spa" }, { name: "Italian", alpha2: "it", alpha3: "ita" }, { name: "Dutch", alpha2: "nl", alpha3: "nld" }, { name: "Russian", alpha2: "ru", alpha3: "rus" }, { name: "Portuguese", alpha2: "pt", alpha3: "por" }, { name: "Polish", alpha2: "pl", alpha3: "pol" }, { name: "Arabic", alpha2: "ar", alpha3: "ara" }, { name: "Japanese", alpha2: "ja", alpha3: "jpn" }, { name: "Chinese", alpha2: "zh", alpha3: "zho" }, { name: "Hindi", alpha2: "hi", alpha3: "hin" }, { name: "Bengali", alpha2: "bn", alpha3: "ben" }, { name: "Gujarati", alpha2: "gu", alpha3: "guj" }, { name: "Tamil", alpha2: "ta", alpha3: "tam" }, { name: "Telugu", alpha2: "te", alpha3: "tel" }, { name: "Punjabi", alpha2: "pa", alpha3: "pan" }, { name: "Vietnamese", alpha2: "vi", alpha3: "vie" }, { name: "Korean", alpha2: "ko", alpha3: "kor" }, { name: "Turkish", alpha2: "tr", alpha3: "tur" }, { name: "Swedish", alpha2: "sv", alpha3: "swe" }, { name: "Greek", alpha2: "el", alpha3: "ell" }, { name: "Czech", alpha2: "cs", alpha3: "ces" }, { name: "Hungarian", alpha2: "hu", alpha3: "hun" }, { name: "Romanian", alpha2: "ro", alpha3: "ron" }, { name: "Ukrainian", alpha2: "uk", alpha3: "ukr" }, { name: "Norwegian", alpha2: "no", alpha3: "nor" }, { name: "Serbian", alpha2: "sr", alpha3: "srp" }, { name: "Croatian", alpha2: "hr", alpha3: "hrv" }, { name: "Slovak", alpha2: "sk", alpha3: "slk" }, { name: "Slovenian", alpha2: "sl", alpha3: "slv" }, { name: "Icelandic", alpha2: "is", alpha3: "isl" }, { name: "Finnish", alpha2: "fi", alpha3: "fin" }, { name: "Danish", alpha2: "da", alpha3: "dan" }, { name: "Swahili", alpha2: "sw", alpha3: "swa" }, { name: "Bashkir", alpha2: "ba", alpha3: "bak" }, { name: "Basque", alpha2: "eu", alpha3: "eus" }, { name: "Catalan", alpha2: "ca", alpha3: "cat" }, { name: "Galician", alpha2: "gl", alpha3: "glg" }, { name: "Esperanto", alpha2: "eo", alpha3: "epo" }, { name: "Fijian", alpha2: "fj", alpha3: "fij" }, { name: "Malagasy", alpha2: "mg", alpha3: "mlg" }, { name: "Maltese", alpha2: "mt", alpha3: "mlt" }, { name: "Albanian", alpha2: "sq", alpha3: "sqi" }, { name: "Armenian", alpha2: "hy", alpha3: "hye" }, { name: "Georgian", alpha2: "ka", alpha3: "kat" }, { name: "Macedonian", alpha2: "mk", alpha3: "mkd" }, { name: "Kazakh", alpha2: "kk", alpha3: "kaz" }, { name: "Haitian Creole", alpha2: "ht", alpha3: "hat" }, { name: "Mongolian", alpha2: "mn", alpha3: "mon" }, { name: "Kyrgyz", alpha2: "ky", alpha3: "kir" }, { name: "Finnish", alpha2: "fi", alpha3: "fin" }, { name: "Tagalog", alpha2: "tl", alpha3: "tgl" }, { name: "Malay", alpha2: "ms", alpha3: "msa" }, { name: "Tajik", alpha2: "tg", alpha3: "tgk" }, { name: "Swati", alpha2: "ss", alpha3: "ssw" }, { name: "Tatar", alpha2: "tt", alpha3: "tat" }, { name: "Zulu", alpha2: "zu", alpha3: "zul" }];
var ze = ["#####", "#####-####"];
var Ve = ["Apt. ###", "Suite ###"];
var Ye = ["Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming"];
var je = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
var qe = { normal: "{{location.buildingNumber}} {{location.street}}", full: "{{location.buildingNumber}} {{location.street}} {{location.secondaryAddress}}" };
var Ue = ["10th Street", "11th Street", "12th Street", "13th Street", "14th Street", "15th Street", "16th Street", "1st Avenue", "1st Street", "2nd Avenue", "2nd Street", "3rd Avenue", "3rd Street", "4th Avenue", "4th Street", "5th Avenue", "5th Street", "6th Avenue", "6th Street", "7th Avenue", "7th Street", "8th Avenue", "8th Street", "9th Street", "A Street", "Abbey Road", "Adams Avenue", "Adams Street", "Airport Road", "Albany Road", "Albert Road", "Albion Street", "Alexandra Road", "Alfred Street", "Alma Street", "Ash Close", "Ash Grove", "Ash Road", "Ash Street", "Aspen Close", "Atlantic Avenue", "Avenue Road", "Back Lane", "Baker Street", "Balmoral Road", "Barn Close", "Barton Road", "Bath Road", "Bath Street", "Bay Street", "Beach Road", "Bedford Road", "Beech Close", "Beech Drive", "Beech Grove", "Beech Road", "Beechwood Avenue", "Bell Lane", "Belmont Road", "Birch Avenue", "Birch Close", "Birch Grove", "Birch Road", "Blind Lane", "Bluebell Close", "Boundary Road", "Bramble Close", "Bramley Close", "Bridge Road", "Bridge Street", "Broad Lane", "Broad Street", "Broadway", "Broadway Avenue", "Broadway Street", "Brook Lane", "Brook Road", "Brook Street", "Brookside", "Buckingham Road", "Cambridge Street", "Canal Street", "Castle Close", "Castle Lane", "Castle Road", "Castle Street", "Cavendish Road", "Cedar Avenue", "Cedar Close", "Cedar Grove", "Cedar Road", "Cedar Street", "Cemetery Road", "Center Avenue", "Center Road", "Center Street", "Central Avenue", "Central Street", "Chapel Close", "Chapel Hill", "Chapel Road", "Chapel Street", "Charles Street", "Cherry Close", "Cherry Street", "Cherry Tree Close", "Chester Road", "Chestnut Close", "Chestnut Drive", "Chestnut Grove", "Chestnut Street", "Church Avenue", "Church Close", "Church Hill", "Church Lane", "Church Path", "Church Road", "Church Street", "Church View", "Church Walk", "Claremont Road", "Clarence Road", "Clarence Street", "Clarendon Road", "Clark Street", "Clay Lane", "Cleveland Street", "Cliff Road", "Clifton Road", "Clinton Street", "College Avenue", "College Street", "Columbia Avenue", "Commerce Street", "Commercial Road", "Commercial Street", "Common Lane", "Coronation Avenue", "Coronation Road", "County Line Road", "County Road", "Court Street", "Cow Lane", "Crescent Road", "Cromwell Road", "Cross Lane", "Cross Street", "Crown Street", "Cumberland Street", "Dale Street", "Dark Lane", "Davis Street", "Depot Street", "Derby Road", "Derwent Close", "Devonshire Road", "Division Street", "Douglas Road", "Duke Street", "E 10th Street", "E 11th Street", "E 12th Street", "E 14th Street", "E 1st Street", "E 2nd Street", "E 3rd Street", "E 4th Avenue", "E 4th Street", "E 5th Street", "E 6th Avenue", "E 6th Street", "E 7th Street", "E 8th Street", "E 9th Street", "E Bridge Street", "E Broad Street", "E Broadway", "E Broadway Street", "E Cedar Street", "E Center Street", "E Central Avenue", "E Church Street", "E Elm Street", "E Franklin Street", "E Front Street", "E Grand Avenue", "E High Street", "E Jackson Street", "E Jefferson Street", "E Main", "E Main Street", "E Maple Street", "E Market Street", "E North Street", "E Oak Street", "E Park Avenue", "E Pine Street", "E River Road", "E South Street", "E State Street", "E Union Street", "E Walnut Street", "E Washington Avenue", "E Washington Street", "E Water Street", "East Avenue", "East Road", "East Street", "Edward Street", "Elm Close", "Elm Grove", "Elm Road", "Elm Street", "Euclid Avenue", "Fairfield Road", "Farm Close", "Ferry Road", "Field Close", "Field Lane", "First Avenue", "First Street", "Fore Street", "Forest Avenue", "Forest Road", "Fourth Avenue", "Franklin Avenue", "Franklin Road", "Franklin Street", "Front Street", "Frontage Road", "Garden Close", "Garden Street", "George Street", "Gladstone Road", "Glebe Close", "Gloucester Road", "Gordon Road", "Gordon Street", "Grand Avenue", "Grange Avenue", "Grange Close", "Grange Road", "Grant Street", "Green Close", "Green Lane", "Green Street", "Greenville Road", "Greenway", "Greenwood Road", "Grove Lane", "Grove Road", "Grove Street", "Hall Lane", "Hall Street", "Harrison Avenue", "Harrison Street", "Hawthorn Avenue", "Hawthorn Close", "Hazel Close", "Hazel Grove", "Heath Road", "Heather Close", "Henry Street", "Heron Close", "Hickory Street", "High Road", "High Street", "Highfield Avenue", "Highfield Close", "Highfield Road", "Highland Avenue", "Hill Road", "Hill Street", "Hillside", "Hillside Avenue", "Hillside Close", "Hillside Road", "Holly Close", "Honeysuckle Close", "Howard Road", "Howard Street", "Jackson Avenue", "Jackson Street", "James Street", "Jefferson Avenue", "Jefferson Street", "Johnson Street", "Jubilee Close", "Juniper Close", "Kent Road", "Kestrel Close", "King Street", "King's Road", "Kingfisher Close", "Kings Highway", "Kingsway", "Laburnum Grove", "Lafayette Street", "Lake Avenue", "Lake Drive", "Lake Road", "Lake Street", "Lancaster Road", "Lansdowne Road", "Larch Close", "Laurel Close", "Lawrence Street", "Lee Street", "Liberty Street", "Lime Grove", "Lincoln Avenue", "Lincoln Highway", "Lincoln Road", "Lincoln Street", "Locust Street", "Lodge Close", "Lodge Lane", "London Road", "Long Lane", "Low Road", "Madison Avenue", "Madison Street", "Main", "Main Avenue", "Main Road", "Main Street", "Main Street E", "Main Street N", "Main Street S", "Main Street W", "Manchester Road", "Manor Close", "Manor Drive", "Manor Gardens", "Manor Road", "Manor Way", "Maple Avenue", "Maple Close", "Maple Drive", "Maple Road", "Maple Street", "Market Place", "Market Square", "Market Street", "Marlborough Road", "Marsh Lane", "Martin Luther King Boulevard", "Martin Luther King Drive", "Martin Luther King Jr Boulevard", "Mary Street", "Mayfield Road", "Meadow Close", "Meadow Drive", "Meadow Lane", "Meadow View", "Meadow Way", "Memorial Drive", "Middle Street", "Mill Close", "Mill Lane", "Mill Road", "Mill Street", "Milton Road", "Milton Street", "Monroe Street", "Moor Lane", "Moss Lane", "Mount Pleasant", "Mount Street", "Mulberry Street", "N 1st Street", "N 2nd Street", "N 3rd Street", "N 4th Street", "N 5th Street", "N 6th Street", "N 7th Street", "N 8th Street", "N 9th Street", "N Bridge Street", "N Broad Street", "N Broadway", "N Broadway Street", "N Cedar Street", "N Center Street", "N Central Avenue", "N Chestnut Street", "N Church Street", "N College Street", "N Court Street", "N Division Street", "N East Street", "N Elm Street", "N Franklin Street", "N Front Street", "N Harrison Street", "N High Street", "N Jackson Street", "N Jefferson Street", "N Lincoln Street", "N Locust Street", "N Main", "N Main Avenue", "N Main Street", "N Maple Street", "N Market Street", "N Monroe Street", "N Oak Street", "N Park Street", "N Pearl Street", "N Pine Street", "N Poplar Street", "N Railroad Street", "N State Street", "N Union Street", "N Walnut Street", "N Washington Avenue", "N Washington Street", "N Water Street", "Nelson Road", "Nelson Street", "New Lane", "New Road", "New Street", "Newton Road", "Nightingale Close", "Norfolk Road", "North Avenue", "North Lane", "North Road", "North Street", "Northfield Road", "Oak Avenue", "Oak Drive", "Oak Lane", "Oak Road", "Oak Street", "Oakfield Road", "Oaklands", "Old Lane", "Old Military Road", "Old Road", "Old State Road", "Orchard Drive", "Orchard Lane", "Orchard Road", "Orchard Street", "Oxford Road", "Oxford Street", "Park Avenue", "Park Crescent", "Park Drive", "Park Lane", "Park Place", "Park Road", "Park Street", "Park View", "Parkside", "Pearl Street", "Pennsylvania Avenue", "Pine Close", "Pine Grove", "Pine Street", "Pinfold Lane", "Pleasant Street", "Poplar Avenue", "Poplar Close", "Poplar Road", "Poplar Street", "Post Road", "Pound Lane", "Princes Street", "Princess Street", "Priory Close", "Priory Road", "Prospect Avenue", "Prospect Place", "Prospect Road", "Prospect Street", "Quarry Lane", "Quarry Road", "Queen's Road", "Railroad Avenue", "Railroad Street", "Railway Street", "Rectory Close", "Rectory Lane", "Richmond Close", "Richmond Road", "Ridge Road", "River Road", "River Street", "Riverside", "Riverside Avenue", "Riverside Drive", "Roman Road", "Roman Way", "Rowan Close", "Russell Street", "S 10th Street", "S 14th Street", "S 1st Avenue", "S 1st Street", "S 2nd Street", "S 3rd Street", "S 4th Street", "S 5th Street", "S 6th Street", "S 7th Street", "S 8th Street", "S 9th Street", "S Bridge Street", "S Broad Street", "S Broadway", "S Broadway Street", "S Center Street", "S Central Avenue", "S Chestnut Street", "S Church Street", "S College Street", "S Division Street", "S East Street", "S Elm Street", "S Franklin Street", "S Front Street", "S Grand Avenue", "S High Street", "S Jackson Street", "S Jefferson Street", "S Lincoln Street", "S Main", "S Main Avenue", "S Main Street", "S Maple Street", "S Market Street", "S Mill Street", "S Monroe Street", "S Oak Street", "S Park Street", "S Pine Street", "S Railroad Street", "S State Street", "S Union Street", "S Walnut Street", "S Washington Avenue", "S Washington Street", "S Water Street", "S West Street", "Salisbury Road", "Sandringham Road", "Sandy Lane", "School Close", "School Lane", "School Road", "School Street", "Second Avenue", "Silver Street", "Skyline Drive", "Smith Street", "Somerset Road", "South Avenue", "South Drive", "South Road", "South Street", "South View", "Spring Gardens", "Spring Street", "Springfield Close", "Springfield Road", "Spruce Street", "St Andrew's Road", "St Andrews Close", "St George's Road", "St John's Road", "St Mary's Close", "St Mary's Road", "Stanley Road", "Stanley Street", "State Avenue", "State Line Road", "State Road", "State Street", "Station Road", "Station Street", "Stoney Lane", "Sycamore Avenue", "Sycamore Close", "Sycamore Drive", "Sycamore Street", "Talbot Road", "Tennyson Road", "The Avenue", "The Beeches", "The Causeway", "The Chase", "The Coppice", "The Copse", "The Crescent", "The Croft", "The Dell", "The Drive", "The Fairway", "The Glebe", "The Grange", "The Green", "The Grove", "The Hawthorns", "The Lane", "The Laurels", "The Limes", "The Maltings", "The Meadows", "The Mews", "The Mount", "The Oaks", "The Orchard", "The Oval", "The Paddock", "The Paddocks", "The Poplars", "The Ridgeway", "The Ridings", "The Rise", "The Sidings", "The Spinney", "The Square", "The Willows", "The Woodlands", "Third Avenue", "Third Street", "Tower Road", "Trinity Road", "Tudor Close", "Union Avenue", "Union Street", "University Avenue", "University Drive", "Valley Road", "Veterans Memorial Drive", "Veterans Memorial Highway", "Vicarage Close", "Vicarage Lane", "Vicarage Road", "Victoria Place", "Victoria Road", "Victoria Street", "Vine Street", "W 10th Street", "W 11th Street", "W 12th Street", "W 14th Street", "W 1st Street", "W 2nd Street", "W 3rd Street", "W 4th Avenue", "W 4th Street", "W 5th Street", "W 6th Avenue", "W 6th Street", "W 7th Street", "W 8th Street", "W 9th Street", "W Bridge Street", "W Broad Street", "W Broadway", "W Broadway Avenue", "W Broadway Street", "W Center Street", "W Central Avenue", "W Chestnut Street", "W Church Street", "W Division Street", "W Elm Street", "W Franklin Street", "W Front Street", "W Grand Avenue", "W High Street", "W Jackson Street", "W Jefferson Street", "W Lake Street", "W Main", "W Main Street", "W Maple Street", "W Market Street", "W Monroe Street", "W North Street", "W Oak Street", "W Park Street", "W Pine Street", "W River Road", "W South Street", "W State Street", "W Union Street", "W Walnut Street", "W Washington Avenue", "W Washington Street", "Walnut Close", "Walnut Street", "Warren Close", "Warren Road", "Washington Avenue", "Washington Boulevard", "Washington Road", "Washington Street", "Water Lane", "Water Street", "Waterloo Road", "Waterside", "Watery Lane", "Waverley Road", "Well Lane", "Wellington Road", "Wellington Street", "West Avenue", "West End", "West Lane", "West Road", "West Street", "West View", "Western Avenue", "Western Road", "Westfield Road", "Westgate", "William Street", "Willow Close", "Willow Drive", "Willow Grove", "Willow Road", "Willow Street", "Windermere Road", "Windmill Close", "Windmill Lane", "Windsor Avenue", "Windsor Close", "Windsor Drive", "Wood Lane", "Wood Street", "Woodland Close", "Woodland Road", "Woodlands", "Woodlands Avenue", "Woodlands Close", "Woodlands Road", "Woodside", "Woodside Road", "Wren Close", "Yew Tree Close", "York Road", "York Street"];
var Ze = ["{{person.first_name.generic}} {{location.street_suffix}}", "{{person.last_name.generic}} {{location.street_suffix}}", "{{location.street_name}}"];
var _e = ["Alley", "Avenue", "Branch", "Bridge", "Brook", "Brooks", "Burg", "Burgs", "Bypass", "Camp", "Canyon", "Cape", "Causeway", "Center", "Centers", "Circle", "Circles", "Cliff", "Cliffs", "Club", "Common", "Corner", "Corners", "Course", "Court", "Courts", "Cove", "Coves", "Creek", "Crescent", "Crest", "Crossing", "Crossroad", "Curve", "Dale", "Dam", "Divide", "Drive", "Drives", "Estate", "Estates", "Expressway", "Extension", "Extensions", "Fall", "Falls", "Ferry", "Field", "Fields", "Flat", "Flats", "Ford", "Fords", "Forest", "Forge", "Forges", "Fork", "Forks", "Fort", "Freeway", "Garden", "Gardens", "Gateway", "Glen", "Glens", "Green", "Greens", "Grove", "Groves", "Harbor", "Harbors", "Haven", "Heights", "Highway", "Hill", "Hills", "Hollow", "Inlet", "Island", "Islands", "Isle", "Junction", "Junctions", "Key", "Keys", "Knoll", "Knolls", "Lake", "Lakes", "Land", "Landing", "Lane", "Light", "Lights", "Loaf", "Lock", "Locks", "Lodge", "Loop", "Mall", "Manor", "Manors", "Meadow", "Meadows", "Mews", "Mill", "Mills", "Mission", "Motorway", "Mount", "Mountain", "Mountains", "Neck", "Orchard", "Oval", "Overpass", "Park", "Parks", "Parkway", "Parkways", "Pass", "Passage", "Path", "Pike", "Pine", "Pines", "Place", "Plain", "Plains", "Plaza", "Point", "Points", "Port", "Ports", "Prairie", "Radial", "Ramp", "Ranch", "Rapid", "Rapids", "Rest", "Ridge", "Ridges", "River", "Road", "Roads", "Route", "Row", "Rue", "Run", "Shoal", "Shoals", "Shore", "Shores", "Skyway", "Spring", "Springs", "Spur", "Spurs", "Square", "Squares", "Station", "Stravenue", "Stream", "Street", "Streets", "Summit", "Terrace", "Throughway", "Trace", "Track", "Trafficway", "Trail", "Tunnel", "Turnpike", "Underpass", "Union", "Unions", "Valley", "Valleys", "Via", "Viaduct", "View", "Views", "Village", "Villages", "Ville", "Vista", "Walk", "Walks", "Wall", "Way", "Ways", "Well", "Wells"];
var ur = { building_number: We, city_name: Ge, city_pattern: Fe, city_prefix: Ne, city_suffix: Ee, continent: Je, country: Ie, county: Ke, direction: Oe, language: xe, postcode: ze, secondary_address: Ve, state: Ye, state_abbr: je, street_address: qe, street_name: Ue, street_pattern: Ze, street_suffix: _e };
var Qe = ur;
var Xe = ["a", "ab", "abbas", "abduco", "abeo", "abscido", "absconditus", "absens", "absorbeo", "absque", "abstergo", "absum", "abundans", "abutor", "accedo", "accendo", "acceptus", "accommodo", "accusamus", "accusantium", "accusator", "acer", "acerbitas", "acervus", "acidus", "acies", "acquiro", "acsi", "ad", "adamo", "adaugeo", "addo", "adduco", "ademptio", "adeo", "adeptio", "adfectus", "adfero", "adficio", "adflicto", "adhaero", "adhuc", "adicio", "adimpleo", "adinventitias", "adipisci", "adipiscor", "adiuvo", "administratio", "admiratio", "admitto", "admoneo", "admoveo", "adnuo", "adopto", "adsidue", "adstringo", "adsuesco", "adsum", "adulatio", "adulescens", "aduro", "advenio", "adversus", "advoco", "aedificium", "aeger", "aegre", "aegrotatio", "aegrus", "aeneus", "aequitas", "aequus", "aer", "aestas", "aestivus", "aestus", "aetas", "aeternus", "ager", "aggero", "aggredior", "agnitio", "agnosco", "ago", "ait", "aiunt", "alias", "alienus", "alii", "alioqui", "aliqua", "aliquam", "aliquid", "alius", "allatus", "alo", "alter", "altus", "alveus", "amaritudo", "ambitus", "ambulo", "amet", "amicitia", "amiculum", "amissio", "amita", "amitto", "amo", "amor", "amoveo", "amplexus", "amplitudo", "amplus", "ancilla", "angelus", "angulus", "angustus", "animadverto", "animi", "animus", "annus", "anser", "ante", "antea", "antepono", "antiquus", "aperiam", "aperio", "aperte", "apostolus", "apparatus", "appello", "appono", "appositus", "approbo", "apto", "aptus", "apud", "aqua", "ara", "aranea", "arbitro", "arbor", "arbustum", "arca", "arceo", "arcesso", "architecto", "arcus", "argentum", "argumentum", "arguo", "arma", "armarium", "aro", "ars", "articulus", "artificiose", "arto", "arx", "ascisco", "ascit", "asper", "asperiores", "aspernatur", "aspicio", "asporto", "assentator", "assumenda", "astrum", "at", "atavus", "ater", "atque", "atqui", "atrocitas", "atrox", "attero", "attollo", "attonbitus", "auctor", "auctus", "audacia", "audax", "audentia", "audeo", "audio", "auditor", "aufero", "aureus", "aurum", "aut", "autem", "autus", "auxilium", "avaritia", "avarus", "aveho", "averto", "baiulus", "balbus", "barba", "bardus", "basium", "beatae", "beatus", "bellicus", "bellum", "bene", "beneficium", "benevolentia", "benigne", "bestia", "bibo", "bis", "blandior", "blanditiis", "bonus", "bos", "brevis", "cado", "caecus", "caelestis", "caelum", "calamitas", "calcar", "calco", "calculus", "callide", "campana", "candidus", "canis", "canonicus", "canto", "capillus", "capio", "capitulus", "capto", "caput", "carbo", "carcer", "careo", "caries", "cariosus", "caritas", "carmen", "carpo", "carus", "casso", "caste", "casus", "catena", "caterva", "cattus", "cauda", "causa", "caute", "caveo", "cavus", "cedo", "celebrer", "celer", "celo", "cena", "cenaculum", "ceno", "censura", "centum", "cerno", "cernuus", "certe", "certus", "cervus", "cetera", "charisma", "chirographum", "cibo", "cibus", "cicuta", "cilicium", "cimentarius", "ciminatio", "cinis", "circumvenio", "cito", "civis", "civitas", "clam", "clamo", "claro", "clarus", "claudeo", "claustrum", "clementia", "clibanus", "coadunatio", "coaegresco", "coepi", "coerceo", "cogito", "cognatus", "cognomen", "cogo", "cohaero", "cohibeo", "cohors", "colligo", "collum", "colo", "color", "coma", "combibo", "comburo", "comedo", "comes", "cometes", "comis", "comitatus", "commemoro", "comminor", "commodi", "commodo", "communis", "comparo", "compello", "complectus", "compono", "comprehendo", "comptus", "conatus", "concedo", "concido", "conculco", "condico", "conduco", "confero", "confido", "conforto", "confugo", "congregatio", "conicio", "coniecto", "conitor", "coniuratio", "conor", "conqueror", "conscendo", "consectetur", "consequatur", "consequuntur", "conservo", "considero", "conspergo", "constans", "consuasor", "contabesco", "contego", "contigo", "contra", "conturbo", "conventus", "convoco", "copia", "copiose", "cornu", "corona", "corporis", "corpus", "correptius", "corrigo", "corroboro", "corrumpo", "corrupti", "coruscus", "cotidie", "crapula", "cras", "crastinus", "creator", "creber", "crebro", "credo", "creo", "creptio", "crepusculum", "cresco", "creta", "cribro", "crinis", "cruciamentum", "crudelis", "cruentus", "crur", "crustulum", "crux", "cubicularis", "cubitum", "cubo", "cui", "cuius", "culpa", "culpo", "cultellus", "cultura", "cum", "cumque", "cunabula", "cunae", "cunctatio", "cupiditas", "cupiditate", "cupio", "cuppedia", "cupressus", "cur", "cura", "curatio", "curia", "curiositas", "curis", "curo", "curriculum", "currus", "cursim", "curso", "cursus", "curto", "curtus", "curvo", "custodia", "damnatio", "damno", "dapifer", "debeo", "debilito", "debitis", "decens", "decerno", "decet", "decimus", "decipio", "decor", "decretum", "decumbo", "dedecor", "dedico", "deduco", "defaeco", "defendo", "defero", "defessus", "defetiscor", "deficio", "defleo", "defluo", "defungo", "degenero", "degero", "degusto", "deinde", "delectatio", "delectus", "delego", "deleniti", "deleo", "delibero", "delicate", "delinquo", "deludo", "demens", "demergo", "demitto", "demo", "demonstro", "demoror", "demulceo", "demum", "denego", "denique", "dens", "denuncio", "denuo", "deorsum", "depereo", "depono", "depopulo", "deporto", "depraedor", "deprecator", "deprimo", "depromo", "depulso", "deputo", "derelinquo", "derideo", "deripio", "deserunt", "desidero", "desino", "desipio", "desolo", "desparatus", "despecto", "dicta", "dignissimos", "distinctio", "dolor", "dolore", "dolorem", "doloremque", "dolores", "doloribus", "dolorum", "ducimus", "ea", "eaque", "earum", "eius", "eligendi", "enim", "eos", "error", "esse", "est", "et", "eum", "eveniet", "ex", "excepturi", "exercitationem", "expedita", "explicabo", "facere", "facilis", "fuga", "fugiat", "fugit", "harum", "hic", "id", "illo", "illum", "impedit", "in", "incidunt", "infit", "inflammatio", "inventore", "ipsa", "ipsam", "ipsum", "iste", "itaque", "iure", "iusto", "labore", "laboriosam", "laborum", "laudantium", "libero", "magnam", "magni", "maiores", "maxime", "minima", "minus", "modi", "molestiae", "molestias", "mollitia", "nam", "natus", "necessitatibus", "nemo", "neque", "nesciunt", "nihil", "nisi", "nobis", "non", "nostrum", "nulla", "numquam", "occaecati", "ocer", "odio", "odit", "officia", "officiis", "omnis", "optio", "paens", "pariatur", "patior", "patria", "patrocinor", "patruus", "pauci", "paulatim", "pauper", "pax", "peccatus", "pecco", "pecto", "pectus", "pecus", "peior", "pel", "perferendis", "perspiciatis", "placeat", "porro", "possimus", "praesentium", "provident", "quae", "quaerat", "quam", "quas", "quasi", "qui", "quia", "quibusdam", "quidem", "quis", "quisquam", "quo", "quod", "quos", "ratione", "recusandae", "reiciendis", "rem", "repellat", "repellendus", "reprehenderit", "repudiandae", "rerum", "saepe", "sapiente", "sed", "sequi", "similique", "sint", "sit", "socius", "sodalitas", "sol", "soleo", "solio", "solitudo", "solium", "sollers", "sollicito", "solum", "solus", "soluta", "solutio", "solvo", "somniculosus", "somnus", "sonitus", "sono", "sophismata", "sopor", "sordeo", "sortitus", "spargo", "speciosus", "spectaculum", "speculum", "sperno", "spero", "spes", "spiculum", "spiritus", "spoliatio", "sponte", "stabilis", "statim", "statua", "stella", "stillicidium", "stipes", "stips", "sto", "strenuus", "strues", "studio", "stultus", "suadeo", "suasoria", "sub", "subito", "subiungo", "sublime", "subnecto", "subseco", "substantia", "subvenio", "succedo", "succurro", "sufficio", "suffoco", "suffragium", "suggero", "sui", "sulum", "sum", "summa", "summisse", "summopere", "sumo", "sumptus", "sunt", "supellex", "super", "suppellex", "supplanto", "suppono", "supra", "surculus", "surgo", "sursum", "suscipio", "suscipit", "suspendo", "sustineo", "suus", "synagoga", "tabella", "tabernus", "tabesco", "tabgo", "tabula", "taceo", "tactus", "taedium", "talio", "talis", "talus", "tam", "tamdiu", "tamen", "tametsi", "tamisium", "tamquam", "tandem", "tantillus", "tantum", "tardus", "tego", "temeritas", "temperantia", "templum", "tempora", "tempore", "temporibus", "temptatio", "tempus", "tenax", "tendo", "teneo", "tener", "tenetur", "tenuis", "tenus", "tepesco", "tepidus", "ter", "terebro", "teres", "terga", "tergeo", "tergiversatio", "tergo", "tergum", "termes", "terminatio", "tero", "terra", "terreo", "territo", "terror", "tersus", "tertius", "testimonium", "texo", "textilis", "textor", "textus", "thalassinus", "theatrum", "theca", "thema", "theologus", "thermae", "thesaurus", "thesis", "thorax", "thymbra", "thymum", "tibi", "timidus", "timor", "titulus", "tolero", "tollo", "tondeo", "tonsor", "torqueo", "torrens", "tot", "totam", "totidem", "toties", "totus", "tracto", "trado", "traho", "trans", "tredecim", "tremo", "trepide", "tres", "tribuo", "tricesimus", "triduana", "tripudio", "tristis", "triumphus", "trucido", "truculenter", "tubineus", "tui", "tum", "tumultus", "tunc", "turba", "turbo", "turpis", "tutamen", "tutis", "tyrannus", "uberrime", "ubi", "ulciscor", "ullam", "ullus", "ulterius", "ultio", "ultra", "umbra", "umerus", "umquam", "una", "unde", "undique", "universe", "unus", "urbanus", "urbs", "uredo", "usitas", "usque", "ustilo", "ustulo", "usus", "ut", "uter", "uterque", "utilis", "utique", "utor", "utpote", "utrimque", "utroque", "utrum", "uxor", "vaco", "vacuus", "vado", "vae", "valde", "valens", "valeo", "valetudo", "validus", "vallum", "vapulus", "varietas", "varius", "vehemens", "vel", "velit", "velociter", "velum", "velut", "venia", "veniam", "venio", "ventito", "ventosus", "ventus", "venustas", "ver", "verbera", "verbum", "vere", "verecundia", "vereor", "vergo", "veritas", "veritatis", "vero", "versus", "verto", "verumtamen", "verus", "vesco", "vesica", "vesper", "vespillo", "vester", "vestigium", "vestrum", "vetus", "via", "vicinus", "vicissitudo", "victoria", "victus", "videlicet", "video", "viduo", "vigilo", "vigor", "vilicus", "vilis", "vilitas", "villa", "vinco", "vinculum", "vindico", "vinitor", "vinum", "vir", "virga", "virgo", "viridis", "viriliter", "virtus", "vis", "viscus", "vita", "vitae", "vitiosus", "vitium", "vito", "vivo", "vix", "vobis", "vociferor", "voco", "volaticus", "volo", "volubilis", "voluntarius", "volup", "voluptas", "voluptate", "voluptatem", "voluptates", "voluptatibus", "voluptatum", "volutabrum", "volva", "vomer", "vomica", "vomito", "vorago", "vorax", "voro", "vos", "votum", "voveo", "vox", "vulariter", "vulgaris", "vulgivagus", "vulgo", "vulgus", "vulnero", "vulnus", "vulpes", "vulticulus", "xiphias"];
var cr = { word: Xe };
var $e = cr;
var mr = { title: "English", code: "en", language: "en", endonym: "English", dir: "ltr", script: "Latn" };
var ea = mr;
var aa = ['"Awaken, My Love!"', "(What's The Story) Morning Glory?", "- Tragedy +", "13 Reasons Why (Season 3)", "21st Century Breakdown", "30 De Febrero", "432 Hz Deep Healing", "5-Star", "528 Hz Meditation Music", "54+1", "8 Mile", "808s & Heartbreak", "9 To 5 And Odd Jobs", "A Beautiful Lie", "A Day At The Races", "A Day Without Rain", "A Fever You Can't Sweat Out", "A Gangsta's Pain", "A Gift & A Curse", "A Hard Day's Night", "A Head Full Of Dreams", "A Kind Of Magic", "A Million Ways To Murder", "A Moment Apart", "A Song For Every Moon", "A Thousand Suns", "A Winter Romance", "ABBA", "AI YoungBoy", "AJ Tracey", "Act One", "After Hours", "Agent Provocateur", "All About You", "All I Know So Far: Setlist", "All Or Nothing", "All Out", "All Over The Place", "All Stand Together", "All The Lost Souls", "All The Things I Never Said", "All Things Must Pass", "Alleen", "Alright, Still", "Alta Suciedad", "America", "American Heartbreak", "American Teen", "And Justice For None", "Animal Songs", "Another Friday Night", "Anything Goes", "Ao Vivo Em S\xE3o Paulo", "Ao Vivo No Ibirapuera", "Apricot Princess", "Aqui E Agora (Ao Vivo)", "Arcane League Of Legends", "Ardipithecus", "Aretha Now", "Around The Fur", "Arrival", "Artist 2.0", "As She Pleases", "Ascend", "Ashlyn", "Astro Lounge", "At Night, Alone.", "At. Long. Last. ASAP", "Atlas", "Audioslave", "Aura", "Austin", "Awake", "Away From The Sun", "Ayayay!", "Baby On Baby", "Back For Everything", "Back From The Edge", "Back In Black", "Back To Black", "Back To The Game", "Bad", "Bah\xEDa Ducati", "Baila", "Barbie The Album", "Battleground", "Bayou Country", "Bcos U Will Never B Free", "Be", "Be Here Now", "Beautiful Mind", "Beautiful Thugger Girls", "Beautiful Trauma", "Beauty And The Beast", "Beggars Banquet", "Being Funny In A Foreign Language", "Berlin Lebt", "Berry Is On Top", "Best White Noise For Baby Sleep - Loopable With No Fade", "Big Baby DRAM", "Bigger, Better, Faster, More!", "Billy Talent II", "Black Star Elephant", "Blackout", "Blank Face LP", "Bleach", "Blizzard Of Ozz", "Blonde", "Blood Sugar Sex Magik", "Bloom", "Blowin' Your Mind!", "Blu Celeste", "Blue", "Blue Banisters", "Blue Hawaii", "Blue Neighbourhood", "Bluebird Days", "Bobby Tarantino", "Bobby Tarantino II", "Bon Iver", "Born Pink", "Born To Run", "Brand New Eyes", "Break The Cycle", "Breakfast In America", "Breakthrough", "Brett Young", "Bridge Over Troubled Water", "Bright: The Album", "Brol", "Buds", "Buena Vista Social Club", "Built On Glass", "Bury Me At Makeout Creek", "Busyhead", "By The Way", "CB6", "CNCO", "California Sunrise", "Californication", "Call Me Irresponsible", "Calm", "Camino Palmero", "Camp", "Caracal", "Carbon Fiber Hits", "Carnival", "Carry On", "Cartel De Santa", "Certified Lover Boy", "Chaaama", "Chama Meu Nome", "Chapter 1: Snake Oil", "Chapter 2: Swamp Savant", "Chapter One", "Charlie's Angels", "Cherry Bomb", "Chief", "Chocolate Factory", "Chosen", "Chris Brown", "Christina Aguilera", "Chromatica", "Church", "City Of Evil", "Clandestino", "Clouds", "Coco", "Collision Course", "Colour Vision", "Combat Rock", "Come Around Sundown", "Come Away With Me", "Come Home The Kids Miss You", "Come What(ever) May", "Commando", "Common Sense", "Communion", "Conditions", "Confident", "Confrontation", "Control The Streets, Volume 2", "Corinne Bailey Rae", "Costello Music", "Cottonwood", "Covers, Vol. 2", "Cozy Tapes Vol. 2: Too Cozy", "Crash Talk", "Crazy Love", "Crazysexycool", "Crowded House", "Cruisin' With Junior H", "Culture", "Current Mood", "DS2", "Dale", "Danger Days: The True Lives Of The Fabulous Killjoys", "Dangerous Woman", "Dangerous: The Double Album", "Dark Horse", "Day69", "Daydream", "De Fiesta", "De Viaje", "DeAnn", "Death Race For Love", "Delirium", "Delta", "Demidevil", "Depression Cherry", "Descendants", "Desgenerados Mixtape", "Destin", "Destiny Fulfilled", "Desvelado", "Detroit 2", "Dex Meets Dexter", "Dharma", "Die A Legend", "Different World", "Dig Your Roots", "Digital Druglord", "Dirt", "Disclaimer I / II", "Discovery", "Disraeli Gears", "Disumano", "Dizzy Up The Girl", "Don't Play That Song", "Donda", "Donde Quiero Estar", "Doo-Wops & Hooligans", "Down The Way", "Dr. Feelgood", "Dream Your Life Away", "Dreaming Out Loud", "Drip Harder", "Drive", "Drones", "Dropped Outta College", "Drowning", "Dua Warna Cinta", "Dulce Beat", "Dusty In Memphis", "Dutty Rock", "Dying To Live", "ENR", "East Atlanta Love Letter", "Editorial", "Edna", "El Abayarde", "El Amor En Los Tiempos Del Perreo", "El Camino", "El Comienzo", "El Dorado", "El Karma", "El Mal Querer", "El Malo", "El Trabajo Es La Suerte", "El Viaje De Copperpot", "Electric Ladyland", "Emotion", "En Tus Planes", "Endless Summer Vacation", "Enter The Wu-Tang (36 Chambers)", "Equals (=)", "Estrella", "Euphoria", "Europop", "Evermore", "Every Kingdom", "Everyday Life", "Evolve", "Expectations", "Face Yourself", "Facelift", "Fallin'", "Fancy You", "Fantas\xEDa", "Favourite Worst Nightmare", "Fear Of The Dark", "Fearless", "Feel Something", "Feels Like Home", "Femme Fatale", "Ferxxocalipsis", "Fifty Shades Darker", "Fifty Shades Freed", "Fifty Shades Of Grey", "Final (Vol.1)", "Finding Beauty In Negative Spaces", "Fine Line", "First Impressions Of Earth", "First Steps", "Five Seconds Flat", "Folklore", "For Emma, Forever Ago", "Forajido EP 1", "Forever", "Forever Young", "Formula Of Love: O+T=<3", "Free 6lack", "Freudian", "Frozen II", "Full Moon Fever", "Funhouse", "Funk Wav Bounces Vol.1", "Future History", "FutureSex/LoveSounds", "Fuzzybrain", "Gallery", "Gangsta's Paradise", "Gemini", "Gemini Rights", "Generationwhy", "Get A Grip", "Get Up", "Gettin' Old", "Girl", "Gladiator", "Glisten", "Globalization", "Gloria", "Glory Days", "God's Project", "Gold Skies", "Golden", "Good Evening", "Good Thing", "Goodbye Yellow Brick Road", "Gossip Columns", "Got Your Six", "Graceland", "Graduation", "Grand Champ", "Grandson, Vol. 1", "Green River", "Guerra", "Ha*Ash Primera Fila - Hecho Realidad", "Haiz", "Hamilton", "Happy Endings", "Harry Styles", "Hasta La Ra\xEDz", "Hatful Of Hollow", "Head In The Clouds", "Heard It In A Past Life", "Heart Shaped World", "Heartbeat City", "Heartbreak On A Full Moon / Cuffing Season - 12 Days Of Christmas", "Heaven Or Hell", "Heaven knows", "Hellbilly Deluxe", "Hellboy", "Help!", "Her Loss", "Here Comes The Cowboy", "Hey World", "High School Musical", "High Tide In The Snake's Nest", "Historias De Un Capricornio", "Hndrxx", "Hombres G (Devu\xE9lveme A Mi Chica)", "Homerun", "Homework", "Hot Fuss", "Hot Pink", "Hot Sauce / Hello Future", "Hot Space", "Hotel Diablo", "Houses Of The Holy", "How Big, How Blue, How Beautiful", "How I'm Feeling", "How To Be Human", "How To Save A Life", "How To: Friend, Love, Freefall", "Hozier", "Human", "Huncho Jack, Jack Huncho", "Hunter Hayes", "Hysteria", "I Am...Sasha Fierce", "I Can't Handle Change", "I Met You When I Was 18. (The Playlist)", "I Never Liked You", "I Never Loved A Man The Way I Love You", "I See You", "I Think You Think Too Much Of Me", "I Used To Know Her", "I Used To Think I Could Fly", "I'm Comin' Over", "Ich & Keine Maske", "If You Can Believe Your Eyes & Ears", "Il Ballo Della Vita", "Ill Communication", "Imagination & The Misfit Kid", "Imagine", "Immortalized", "In A Perfect World...", "In Colour", "In My Own Words", "In Rainbows", "In Return", "In The Lonely Hour", "Infest", "Innuendo", "Inter Shibuya - La Mafia", "Interstellar", "Is This It", "It Was Written", "It's Not Me, It's You", "It's Only Me", "Ivory", "JackBoys", "Jamie", "Jazz", "Jibrail & Iblis", "Jordi", "Jordin Sparks", "Jose", "Just As I Am", "Just Cause Y'all Waited 2", "Just Like You", "Justified", "K-12 / After School", "K.I.D.S.", "K.O.", "K.O.B. Live", "KG0516", "KOD", "Kane Brown", "Kid A", "Kid Krow", "Kids See Ghosts", "Kids in Love", "Kinks (You Really Got Me)", "Know-It-All", "Konvicted", "Kring", "LANY", "LM5", "La Criatura", "La Flaca", "La Melodia De La Calle", "La Revolucion", "Lady Lady", "Lady Wood", "Langit Mong Bughaw", "Las Que No Iban A Salir", "Last Day Of Summer", "Last Year Was Complicated", "Layers", "Layover", "Lazarus", "Led Zeppelin", "Left Of The Middle", "Leftoverture", "Legends Never Die", "Let's Skip To The Wedding", "Let's Talk About Love", "Licensed To Ill", "Life In Cartoon Motion", "Life Thru A Lens", "Lifelines", "Like..?", "Lil Big Pac", "Lil Boat", "Lil Boat 2", "Lil Boat 3.5", "Lil Kiwi", "Lil Pump", "Limon Y Sal", "Listen Without Prejudice", "Little Voice", "Live On Red Barn Radio I & II", "Lo Que And\xE1bamos Buscando", "Lofi Fruits Music 2021", "London Calling", "Los Campeones Del Pueblo", "Los Extraterrestres", "Los Favoritos 2", "Lost", "Lost In Love", "Loud", "Love Sick", "Love Story", "Love Stuff", "Love Yourself: Tear", "Lover", "Luca Brasi 2: Gangsta Grillz", "Lust For Life", "Luv Is Rage", "M!ssundaztood", "Ma Fleur", "Made In Lagos", "Mafia Bidness", "Magazines Or Novels", "Mainstream Sellout", "Majestic", "Make It Big", "Make Yourself", "Making Mirrors", "Mamma Mia! Here We Go Again", "Man Of The Woods", "Manic", "Me And My Gang", "Meduza", "Meet The Orphans", "Meet The Woo", "Melim", "Mellon Collie And The Infinite Sadness", "Melly vs. Melvin", "Memories...Do Not Open", "Menagerie", "Midnights", "Minecraft - Volume Alpha", "Minutes To Midnight", "Mix Pa Llorar En Tu Cuarto", "Modo Avi\xF3n", "Monkey Business", "Mono.", "Montana", "Montevallo", "Moosetape", "Morning View", "Motivan2", "Moving Pictures", "Mr. Davis", "Mr. Misunderstood", "Mulan", "Mura Masa", "Music From The Edge Of Heaven", "Music Of The Sun", "My House", "My Kinda Party", "My Krazy Life", "My Liver Will Handle What My Heart Can't", "My Moment", "My Own Lane", "My Turn", "My Worlds", "Na Praia (Ao Vivo)", "Nakamura", "Nation Of Two", "Navegando", "Need You Now", "Neon Future III", "Neotheater", "Never Trust A Happy Song", "New English", "News Of The World", "Nicole", "Night & Day", "Nimmerland", "Nimrod", "Nine Track Mind", "No Angel", "No Me Pidas Perd\xF3n", "No More Drama", "No Protection", "No Strings Attached", "No Time To Die", "Nobody Is Listening", "Non Stop Erotic Cabaret", "Non-Fiction", "Northsbest", "Nostalgia", "Nostalgia, Ultra", "Notes On A Conditional Form", "Now Or Never", "O Embaixador (Ao Vivo)", "O My Heart", "OK Computer", "Ocean", "Ocean Avenue", "Ocean Eyes", "Odisea", "Oh My My", "Oh, What A Life", "On The 6", "One In A Million", "One More Light", "One Of These Nights", "Open Up And Say...Ahh!", "Ordinary Man", "Origins", "Out Of The Blue", "Over It", "OzuTochi", "PTSD", "Pa Las Baby's Y Belikeada", "Pa Que Hablen", "Pa' Luego Es Tarde", "Pa' Otro La 'O", "Pablo Honey", "Pain Is Love", "Pain Is Temporary", "Painting Pictures", "Palmen Aus Plastik 2", "Para Mi Ex", "Para Siempre", "Partners In Crime", "Pawn Shop", "Pegasus / Neon Shark VS Pegasus", "Pet Sounds", "Piece By Piece", "Pier Pressure", "Pineapple Sunrise", "Piseiro 2020 Ao Vivo", "Planet Pit", "Plans", "Play Deep", "Playa Saturno", "Por Primera Vez", "Por Vida", "Positions", "Post Human: Survival Horror", "Poster Girl", "Prazer, Eu Sou Ferrugem (Ao Vivo)", "Pretty Girls Like Trap Music", "Pretty. Odd.", "Prince Royce", "Prisma", "Prometo", "Providence", "Puberty 2", "Punisher", "Purgatory", "Purple Rain", "Que Bendici\xF3n", "Queen Of The Clouds", "Quiero Volver", "R&G (Rhythm & Gangsta): The Masterpiece", "Raise!", "Ransom 2", "Rapunzel", "Rare", "Re Mida", "Ready To Die", "Realer", "Rebelde", "Reclassified", "Recovery", "Recuerden Mi Estilo", "Reggatta De Blanc", "Regulate\u2026 G Funk Era", "Reik", "Reise, Reise", "Relapse", "Relaxing Piano Lullabies And Natural Sleep Aid For Baby Sleep Music", "Religiously. The Album.", "Replay", "Results May Vary", "Revenge", "Revolve", "Revolver", "Ricky Martin", "Rien 100 Rien", "Ripcord", "Rise And Fall, Rage And Grace", "Rise Of An Empire", "Robin Hood: Prince Of Thieves", "Rock N Roll Jesus", "Romance", "Romances", "Ronan", "Royal Blood", "Rumours", "Sad Boyz 4 Life II", "San Lucas", "Santana World", "Saturation III", "Sauce Boyz", "Savage Mode", "Saxobeats", "Scarlet", "Schwarzes Herz", "Seal The Deal & Let's Boogie", "Section.80", "Segundo Romance", "Sehnsucht", "Shake The Snow Globe", "Shang-Chi And The Legend Of The Ten Rings: The Album", "Sheer Heart Attack", "Shiesty Season", "Shock Value", "Shoot For The Stars, Aim For The Moon", "Signed Sealed And Delivered", "Signos", "Silent Alarm", "Simplemente Gracias", "Sin Bandera", "Sing Me A Lullaby, My Sweet Temptation", "Sinner", "Sirio", "Sit Still, Look Pretty", "Skin", "Slowhand", "Smash", "Smithereens", "Snow Cougar", "Social Cues", "Some Girls", "Song Hits From Holiday Inn", "Songs For Dads", "Songs For The Deaf", "Songs For You, Truths For Me", "Songs In The Key Of Life", "Souled Out", "Sounds Of Silence", "Soy Como Quiero Ser", "Speak Now", "Speak Your Mind", "Speakerboxxx/The Love Below", "Spider-Man: Into The Spider-Verse", "Split Decision", "Square Up", "SremmLife", "Starboy", "Stay +", "Stay Dangerous", "Staying At Tamara's", "Steppenwolf", "Stick Season", "Still Bill", "Straight Outta Compton", "Strange Trails", "Stronger", "Suavemente", "Sublime", "Suck It and See", "Sucker", "Sue\xF1os", "Sugar", "Summer Forever", "Summer,", "Sunset Season", "Sunshine On Leith", "Surfer Rosa", "Sweet Talker", "SweetSexySavage", "System Of A Down", "TA13OO", "Talk That Talk", "Talking Heads: 77", "Tangled Up", "Tango In The Night", "Taxi Driver", "Taylor Swift", "Tell Me It's Real", "Ten", "Ten Summoner's Tales", "Terra Sem Cep (Ao Vivo)", "Terral", "Testing", "Tha Carter III", "Thank Me Later", "That's Christmas To Me", "The Academy", "The Adventures Of Bobby Ray", "The Album", "The Andy Williams Christmas Album", "The Aviary", "The Balcony", "The Battle Of Los Angeles", "The Beatles (White Album)", "The Beginning", "The Better Life", "The Big Day", "The Book", "The Breakfast Club", "The Cars", "The Colour And The Shape", "The Death Of Peace Of Mind", "The Diary Of Alicia Keys", "The Documentary", "The Emancipation Of Mimi", "The Eminem Show", "The End Of Everything", "The Final Countdown", "The Forever Story", "The Foundation", "The Goat", "The Golden Child", "The Good Parts", "The Greatest Showman: Reimagined", "The Green Trip", "The Hardest Love", "The Head And The Heart", "The Human Condition", "The Infamous", "The Lady Killer", "The Last Don II", "The Lion King", "The Lockdown Sessions", "The London Sessions", "The Lord Of The Rings: The Fellowship Of The Ring", "The Lost Boy", "The Magic Of Christmas / The Christmas Song", "The Marshall Mathers LP", "The Martin Garrix Collection", "The Melodic Blue", "The Mockingbird & The Crow", "The Pains Of Growing", "The Papercut Chronicles", "The Perfect Luv Tape", "The Pinkprint", "The Predator", "The Queen Is Dead", "The ReVe Festival: Finale", "The Rise And Fall Of Ziggy Stardust And The Spiders From Mars", "The Rising Tied", "The River", "The Stone Roses", "The Story Of Us", "The Stranger", "The Sufferer & The Witness", "The Sun's Tirade", "The Temptations Sing Smokey", "The Time Of Our Lives", "The Way It Is", "The Wonderful World Of Sam Cooke", "The Writing's On The Wall", "The Young And The Hopeless", "Therapy", "Therapy Session", "There Is More (Live)", "There Is Nothing Left To Lose", "These Things Happen", "Third Eye Blind", "This Is Me...Then", "This Unruly Mess I've Made", "Threat to Survival", "Thrill Of The Chase", "Time", "Timelezz", "To Let A Good Thing Die", "To Pimp A Butterfly", "Toast To Our Differences", "Todos Os Cantos, Vol. 1 (Ao Vivo)", "Too Hard", "Torches X", "Total Xanarchy", "Toto IV", "Toulouse Street", "Tourist History", "Toxicity", "Tragic Kingdom", "Tranquility Base Hotel & Casino", "Traumazine", "Traveler", "Tres Hombres", "Trip At Knight", "Tron: Legacy", "True Blue", "True Colors", "Trustfall", "Tu Veneno Mortal", "Tudo Em Paz", "Ubuntu", "Ugly Is Beautiful", "Ultra 2021", "Una Mattina", "Unbroken", "Uncovered", "Under Pressure", "Unsponsored Content", "Unstoppable", "Unwritten", "Urban Flora", "Urban Hymns", "Use Your Illusion I", "Veneer", "Versions Of Me", "Vibes", "Vice Versa", "Vices & Virtues", "Victory", "Vida", "Viejo Marihuano", "Visual\xEDzate", "Walk Away", "Walk Me Home...", "Watch The Throne", "Wave", "We Broke The Rules", "We Love You Tecca", "We Love You Tecca 2", "Weezer (Green Album)", "Welcome To The Madhouse", "Westlife", "What A Time To Be Alive", "What Do You Think About The Car?", "What Is Love?", "What Makes You Country", "What Separates Me From You", "What You See Is What You Get / What You See Ain't Always What You Get", "When It's Dark Out", "When We All Fall Asleep, Where Do We Go?", "Where The Light Is", "While The World Was Burning", "White Pony", "Whitney", "Who Really Cares", "Who You Are", "Who's Next", "Wide Open", "Wilder Mind", "Wildfire", "Willy And The Poor Boys", "Wings / You Never Walk Alone", "Wish", "Wish You Were Here", "Without Warning", "Wonder", "X&Y", "XOXO", "Y Que Quede Claro", "YBN: The Mixtape", "Yo Creo", "You Will Regret", "Youngblood", "Younger Now", "Youth"];
var ra = ["$NOT", "$uicideboy$", "(G)I-DLE", "*NSYNC", "2 Chainz", "21 Savage", "6LACK", "? & The Mysterians", "A Boogie Wit da Hoodie", "A Taste of Honey", "A Tribe Called Quest", "A-Ha", "ABBA", "AC/DC", "AJ Tracey", "ATEEZ", "Ace of Base", "Adele", "Ado", "Aerosmith", "Agust D", "Aitana", "Al Dexter & his Troopers", "Al Green", "Al Jolson", "Al Martino", "Alan Jackson", "Alannah Myles", "Alec Benjamin", "Alejandro Sanz", "Alesso", "Alfredo Olivas", "Ali Gatie", "Alice In Chains", "Alina Baraz", "All Time Low", "All-4-One", "All-American Rejects", "Alok", "America", "American Quartet", "Amii Stewart", "Amitabh Bhattacharya", "Ana Castela", "Anderson .Paak", "Andy Grammer", "Angus & Julia Stone", "Anirudh Ravichander", "Anita Ward", "Anitta", "Anton Karas", "Anuel AA", "Arcade Fire", "Archie Bell & The Drells", "Archies", "Aretha Franklin", "Arizona Zervas", "Armin van Buuren", "Arthur Conley", "Artie Shaw", "Asake", "Asees Kaur", "Association", "Atif Aslam", "Audioslave", "Aventura", "Avril Lavigne", "Aya Nakamura", "B J Thomas", "B.o.B", "BLACKPINK", "BONES", "BROCKHAMPTON", "BTS", "Baby Keem", "Bachman-Turner Overdrive", "Backstreet Boys", "Bad Bunny", "Badshah", "Bailey Zimmerman", "Banda El Recodo", "Barbra Streisand", "Barry White", "Bazzi", "Bebe Rexha", "Becky G", "Becky Hill", "Bee Gees", "Ben Bernie", "Ben Howard", "Ben Selvin", "Berlin", "Bessie Smith", "Bethel Music", "Bette Midler", "Beyonce", "Bibi Blocksberg", "Bibi und Tina", "BigXthaPlug", "Bill Doggett", "Bill Haley & his Comets", "Bill Withers", "Billy Davis Jr", "Billy Joel", "Billy Paul", "Billy Preston", "Billy Swan", "Birdy", "Bizarrap", "Blake Shelton", "Blur", "Bob Marley & The Wailers", "Bob Seger", "Bobby Darin", "Bobby Lewis", "Bobby McFerrin", "Bobby Vinton", "Boney M.", "Bonez MC", "Bonnie Tyler", "Booba", "Boston", "BoyWithUke", "Boyce Avenue", "Bradley Cooper", "Bread", "Brent Faiyaz", "Brett Young", "Bring Me The Horizon", "Britney Spears", "Brooks & Dunn", "Bruce Channel", "Bruno & Marrone", "Bryan Adams", "Bryce Vine", "Buddy Holly", "Burna Boy", "C. Tangana", "CKay", "CRO", "Camilo", "Capital Bra", "Captain & Tennille", "Cardi B", "Carin Leon", "Carlos Vives", "Carly Simon", "Carpenters", "Cavetown", "Celine Dion", "Central Cee", "Chaka Khan", "Champs", "Charlie Rich", "Chayanne", "Cheat Codes", "Cher", "Chic", "Chicago", "Chris Brown", "Chris Isaak", "Chris Young", "Christina Aguilera", "Christina Perri", "Christopher Cross", "Chuck Berry", "Ciara", "Cigarettes After Sex", "Cliff Edwards (Ukelele Ike)", "Cody Johnson", "Colbie Caillat", "Colby O'Donis", "Cole Swindell", "Coleman Hawkins", "Contours", "Coolio", "Count Basie", "Cris Mj", "Culture Club", "Cyndi Lauper", "D-Block Europe", "DAY6", "DJ Khaled", "DJ Luian", "DJ Nelson", "DMX", "DNCE", "DaVido", "Dadju", "Daft Punk", "Dan + Shay", "Daniel Powter", "Danny Ocean", "Darius Rucker", "Dave", "David Bowie", "David Guetta", "Daya", "Dean Martin", "Deee-Lite", "Deep Purple", "Deftones", "Demi Lovato", "Dennis Lloyd", "Denzel Curry", "Dermot Kennedy", "Desiigner", "Devo", "Dewa 19", "Dexys Midnight Runners", "Diddy", "Dido", "Die drei !!!", "Diego & Victor Hugo", "Diljit Dosanjh", "Dimitri Vegas & Like Mike", "Dinah Shore", "Dionne Warwick", "Dire Straits", "Disclosure", "Dixie Cups", "Doja Cat", "Dolly Parton", "Don Diablo", "Don Henley", "Don McLean", "Don Omar", "Donna Summer", "Donovan", "Dr. Dre", "Drake", "Dreamville", "Dua Lipa", "EMF", "ENHYPEN", "Earth, Wind & Fire", "Ed Sheeran", "Eddie Cantor", "Eddie Cochran", "Eddy Howard", "Edgar Winter Group", "Edwin Hawkins Singers", "Edwin Starr", "El Alfa", "Eladio Carrion", "Electric Light Orchestra", "Elevation Worship", "Ella Henderson", "Ellie Goulding", "Elton John", "Elvis Presley", "Empire of the Sun", "En Vogue", "Enrique Iglesias", "Eslabon Armado", "Ethel Waters", "Etta James", "Evanescence", "Exile", "Extreme", "Faith Hill", "Fall Out Boy", "Fanny Brice", "Farruko", "Fats Domino", "Fats Waller", "Feid", "Felix Jaehn", "Fergie", "Fetty Wap", "Fiersa Besari", "Fifth Harmony", "Fine Young Cannibals", "Five Finger Death Punch", "Fleetwood Mac", "Flo-Rida", "Florence + The Machine", "Flume", "Foo Fighters", "Foreigner", "Foster The People", "Four Aces", "Frank Ocean", "Frank Sinatra", "Frankie Avalon", "Frankie Valli", "Fred Astaire", "Freda Payne", "Freddie Dredd", "Freddy Fender", "French Montana", "Fuerza Regida", "Fujii Kaze", "Future", "G-Eazy", "Garfunkel and Oates", "Gary Lewis & The Playboys", "Gary Numan", "Gene Autry", "Gene Chandler", "Gene Vincent", "George Michael", "George Strait", "Gera MX", "Ghost", "Ghostemane", "Gigi D'Agostino", "Gladys Knight & The Pips", "Glass Animals", "Glee Cast", "Gloria Gaynor", "Godsmack", "Gorillaz", "Gotye", "Grand Funk Railroad", "Green Day", "Grouplove", "Grupo Firme", "Grupo Marca Registrada", "Gryffin", "Gucci Mane", "Guess Who", "Gunna", "Gusttavo Lima", "Guy Mitchell", "Gwen Stefani", "Gzuz", "H.E.R.", "HARDY", "Hailee Steinfeld", "Halsey", "Hans Zimmer", "Harris Jayaraj", "Harry Chapin", "Harry James", "Harry Nilsson", "Harry Styles", "Hayley Williams", "Herb Alpert", "Herman's Hermits", "Hillsong UNITED", "Hillsong Worship", "Hollywood Undead", "Honey Cone", "Hoobastank", "Hues Corporation", "I Prevail", "ITZY", "IVE", "Ice Cube", "Ice Spice", "Iggy Azalea", "Imagine Dragons", "Incubus", "Internet Money", "Isaac Hayes", "J Geils Band", "J. Cole", "JAY-Z", "JJ Lin", "JP Saxe", "JVKE", "Jack Harlow", "Jack Johnson", "Jackie Wilson", "Jacquees", "James Arthur", "James Brown", "James TW", "James Taylor", "Jamie Foxx", "Janet Jackson", "Janis Joplin", "Jason Aldean", "Jason Mraz", "Jay Chou", "Jay Sean", "Jay Wheeler", "Jaymes Young", "Jean Knight", "Jeezy", "Jennifer Lopez", "Jennifer Warnes", "Jeremih", "Jeremy Zucker", "Jerry Lee Lewis", "Jerry Murad's Harmonicats", "Jess Glynne", "Jessie J", "Jewel", "Jimi Hendrix", "Jimin", "Jimmie Rodgers", "Jimmy Dean", "Jo Stafford", "Joan Jett & The Blackhearts", "Joao Gilberto", "Joel Corry", "John Fred & The Playboy Band", "John Legend", "John Mayer", "John Williams", "Johnnie Ray", "Johnnie Taylor", "Johnny Cash", "Johnny Horton", "Johnny Mathis", "Johnny Mercer", "Johnny Nash", "Joji", "Jon Bellion", "Jonas Blue", "Jonas Brothers", "Joni James", "Jorja Smith", "Juan Gabriel", "Juan Luis Guerra 4.40", "Juanes", "Juice Newton", "Julia Michaels", "Justin Bieber", "Justin Quiles", "KALEO", "KAROL G", "KAYTRANADA", "KK", "KSI", "KYLE", "Kacey Musgraves", "Kane Brown", "Kanye West", "Karan Aujla", "Kate Smith", "Katy Perry", "Kay Kyser", "Ke$ha", "Kehlani", "Kelly Clarkson", "Kenny Chesney", "Kenny Loggins", "Kenny Rogers", "Kenshi Yonezu", "Kenya Grace", "Kevin Gates", "Key Glock", "Khalid", "Kim Carnes", "Kim Petras", "Kimbra", "Kina", "King Gnu", "Kings of Leon", "Kingsmen", "Kitty Kallen", "Kodak Black", "Kodaline", "Kollegah", "Kool & The Gang", "Kungs", "Kygo", "Kylie Minogue", "LE SSERAFIM", "LISA", "LMFAO", "LUDMILLA", "La Adictiva Banda San Jos\xE9 de Mesillas", "La Oreja de Van Gogh", "Labrinth", "Lady Antebellum", "Lady GaGa", "Lainey Wilson", "Lana Del Rey", "Latto", "Lauryn Hill", "Lauv", "League of Legends", "Lee Brice", "Leon Bridges", "Leona Lewis", "Lesley Gore", "Leslie Odom Jr.", "Liam Payne", "Lifehouse", "Lil Baby", "Lil Dicky", "Lil Durk", "Lil Mosey", "Lil Nas X", "Lil Pump", "Lil Skies", "Lil Tjay", "Lil Uzi Vert", "Lil Yachty", "Lil' Kim", "Lil' Wayne", "Lin-Manuel Miranda", "Linkin Park", "Lionel Richie", "Lipps Inc", "Lisa Loeb", "Little Peggy March", "Little Richard", "Lofi Fruits Music", "Lord Huron", "Los Del Rio", "Los Dos Carnales", "Los Lobos", "Los Temerarios", "Los Tigres Del Norte", "Los Tucanes De Tijuana", "Lou Reed", "Loud Luxury", "Louis Jordan", "Louis Tomlinson", "Love Unlimited", "Lovin' Spoonful", "Luan Santana", "Luciano", "Luis Miguel", "Luis R Conriquez", "Lulu", "Lunay", "Lupe Fiasco", "M", "MAX", "MC Hammer", "MC Ryan SP", "MKTO", "Mabel", "Machine Gun Kelly", "Madison Beer", "Madonna", "Mahalini", "Major Lazer", "Mambo Kingz", "Maneskin", "Marco Antonio Sol\xEDs", "Margaret Whiting", "Maria Becerra", "Mario", "Mario Lanza", "Mark Ronson", "Maroon 5", "Marshmello", "Martin Garrix", "Mary Ford", "Mary J Blige", "Mary J. Blige", "Mary Wells", "Matoma", "Mau y Ricky", "Meek Mill", "Megadeth", "Melanie", "Melanie Martinez", "Melendi", "Men At Work", "Metro Boomin", "Michael Bubl\xE9", "Michael Jackson", "Michael McDonald", "Michael Sembello", "Miguel", "Mike Posner", "Miley Cyrus", "Milky Chance", "Minnie Riperton", "Miracle Tones", "Miranda Lambert", "Mohit Chauhan", "Mon Laferte", "Moneybagg Yo", "Monsta X", "Mora", "Morad", "Morat", "Mother Mother", "Motley Crue", "Ms. Lauryn Hill", "Mumford & Sons", "Muse", "Mya", "Myke Towers", "NCT 127", "NCT DREAM", "NEFFEX", "Nadin Amizah", "Nancy Sinatra", "Nat King Cole", "Nate Smith", "Natti Natasha", "Nayer", "Neil Diamond", "Neil Sedaka", "Nekfeu", "Nelly", "New Vaudeville Band", "Next", "Nickelback", "Nicki Minaj", "Nicki Nicole", "Nicky Jam", "Nina Simone", "Ninho", "Nipsey Hussle", "Nirvana", "Niska", "No Doubt", "Norah Jones", "Normani", "OMI", "ONE OK ROCK", "Oasis", "Official HIGE DANdism", "Offset", "Old Dominion", "Oliver Heldens", "Olivia Rodrigo", "Omah Lay", "One Direction", "Otis Redding", "OutKast", "Owl City", "P Diddy", "P!nk", "PLK", "PNL", "Pamungkas", "Passenger", "Pat Boone", "Patsy Cline", "Patti LaBelle", "Patti Page", "Paul & Paula", "Paul Revere & the Raiders", "Paul Robeson", "Paul Russell", "Paul Whiteman", "Paula Abdul", "Peaches & Herb", "Pearl Jam", "Pee Wee Hunt", "Pee Wee King", "Pentatonix", "Percy Faith", "Percy Sledge", "Peso Pluma", "Peter Cetera", "Peter Gabriel", "Peter, Paul & Mary", "Pharrell Williams", "Pierce The Veil", "Pineapple StormTv", "Pink Floyd", "Pink Sweat$", "Piso 21", "Pitbull", "Plan B", "Player", "Polo G", "Pop Smoke", "Portugal. The Man", "Pouya", "Prince", "Prince Royce", "Pusha T", "Quality Control", "Queen", "Quinn XCII", "R. Kelly", "RAF Camora", "RAYE", "REM", "REO Speedwagon", "Radiohead", "Rag'n'Bone Man", "Rage Against The Machine", "Rahat Fateh Ali Khan", "Rainbow Kitten Surprise", "Rammstein", "Rauw Alejandro", "Ray Charles", "Ray Parker Jr", "Ray Stevens", "Red Foley", "Red Hot Chili Peppers", "Red Velvet", "Regard", "Regina Belle", "Reik", "Rels B", "Rema", "Ricardo Arjona", "Rich The Kid", "Rick Astley", "Rick Dees & his Cast of Idiots", "Rick Ross", "Rick Springfield", "Ricky Martin", "Ricky Nelson", "Rihanna", "Rita Ora", "Ritchie Valens", "Rizky Febian", "Rob Thomas", "Roberta Flack", "Robin Schulz", "Robin Thicke", "Rod Stewart", "Rod Wave", "Roddy Ricch", "Roger Miller", "Romeo Santos", "Rosemary Clooney", "Roxette", "Roy Acuff", "Roy Orbison", "Rudimental", "Ruel", "Ruth B.", "Ryan Lewis", "SCH", "SEVENTEEN", "SWV", "Sabaton", "Sabrina Carpenter", "Sachet Tandon", "Sachin-Jigar", "Sade", "Sam Cooke", "Sam Feldt", "Sam Hunt", "Sam Smith", "Sam The Sham & The Pharaohs", "Sammy Davis Jr", "Sammy Kaye", "Santana", "Sasha Alex Sloan", "Savage Garden", "Saweetie", "Scorpions", "Sean Kingston", "Sean Paul", "Sebastian Yatra", "Sech", "Seeb", "Sezen Aksu", "Sfera Ebbasta", "Shaggy", "Shania Twain", "Shawn Mendes", "Sheena Easton", "Shinedown", "Shubh", "Sia", "Sid Sriram", "Sidhu Moose Wala", "Silk", "Silver Convention", "Simon & Garfunkel", "Sinead O'Connor", "Sir Mix-a-Lot", "Sister Sledge", "Ski Mask The Slump God", "Skillet", "Skrillex", "Sleeping At Last", "Smokey Robinson", "Snoop Dogg", "Snow Patrol", "Soda Stereo", "Sonu Nigam", "Sophie Ellis-Bextor", "Spencer Davis Group", "Spice Girls", "Stan Getz", "Starland Vocal Band", "Stephen Sanchez", "Steve Aoki", "Steve Lacy", "Steve Winwood", "Stevie B", "Sting", "Stormzy", "Strawberry Alarm Clock", "Stray Kids", "Stromae", "Sublime", "Sum 41", "Summer Walker", "Supertramp", "Survivor", "Swedish House Mafia", "System Of A Down", "T-Pain", "T.I.", "TAEYEON", "TKKG", "TLC", "TOMORROW X TOGETHER", "TOTO", "TWICE", "Tag Team", "Tainy", "Tammi Terrell", "Tanishk Bagchi", "Tate McRae", "Taylor Swift", "Tears For Fears", "Tems", "Tennessee Ernie Ford", "Terence Trent D'Arby", "Teresa Brewer", "Terry Jacks", "The Ames Brothers", "The Animals", "The B52s", "The Bangles", "The Beatles", "The Black Eyed Peas", "The Black Keys", "The Box Tops", "The Chainsmokers", "The Chiffons", "The Chordettes", "The Clash", "The Coasters", "The Commodores", "The Cowsills", "The Cranberries", "The Crew-Cuts", "The Cure", "The Detroit Spinners", "The Diamonds", "The Doobie Brothers", "The Doors", "The Drifters", "The Emotions", "The Eurythmics", "The Fireballs", "The Flamingos", "The Foundations", "The Four Seasons", "The Fray", "The Game", "The Go Gos", "The Goo Goo Dolls", "The Head And The Heart", "The Hollies", "The Ink Spots", "The Isley Brothers", "The Jackson 5", "The Kid LAROI", "The Killers", "The Kingston Trio", "The Kooks", "The Lemon Pipers", "The Living Tombstone", "The Lumineers", "The Mamas & The Papas", "The Marvelettes", "The McCoys", "The Mills Brothers", "The Miracles", "The Monkees", "The Moody Blues", "The National", "The Neighbourhood", "The Notorious B.I.G.", "The O'Jays", "The Offspring", "The Osmonds", "The Partridge Family", "The Penguins", "The Pet Shop Boys", "The Platters", "The Righteous Brothers", "The Rolling Stones", "The Ronettes", "The Score", "The Script", "The Seekers", "The Shangri-Las", "The Smashing Pumpkins", "The Staple Singers", "The Strokes", "The Supremes", "The Temptations", "The Turtles", "The Vamps", "The Verve", "The Village People", "The Weavers", "The White Stripes", "The Young Rascals", "The Zombies", "Thelma Houston", "Thomas Rhett", "Three Days Grace", "Three Dog Night", "Three Man Down", "Timbaland", "Timmy Trumpet", "Toby Keith", "Tom Jones", "Tom Petty and the Heartbreakers", "Tommy Dorsey", "Tommy Edwards", "Tommy James & the Shondells", "Tone Loc", "Toni Braxton", "Topic", "Tory Lanez", "Tove Lo", "Trevor Daniel", "Trey Songz", "Trippie Redd", "Trueno", "Tulsi Kumar", "Tulus", "Twenty One Pilots", "Two Feet", "Ty Dolla $ign", "Tyga", "Tyler Hubbard", "U2", "UB40", "UZI", "Ufo361", "Upchurch", "V", "Vampire Weekend", "Van McCoy", "Van Morrison", "Vance Joy", "Vanessa Carlton", "Vanessa Williams", "Vera Lynn", "Vernon Dalhart", "Vicente Fernandez", "Vishal-Shekhar", "Volbeat", "WILLOW", "Wale", "Wallows", "Weezer", "Wham!", "Whitney Houston", "Why Don't We", "Wilbert Harrison", "Wilson Phillips", "Wiz Khalifa", "Woody Guthrie", "Wyclef Jean", "XXXTENTACION", "Xavi", "YG", "YNW Melly", "YOASOBI", "Yandel", "Years & Years", "Yeat", "Yo Gotti", "Young Dolph", "Young Miko", "Young Thug", "YoungBoy Never Broke Again", "Yung Gravy", "Yuuri", "Yuvan Shankar Raja", "ZAYN", "ZZ Top", "Zac Brown Band", "Zach Bryan", "Zara Larsson", "aespa", "benny blanco", "blink-182", "d4vd", "deadmau5", "girl in red", "gnash", "iann dior", "will.i.am"];
var oa = ["Acid House", "Acid Jazz", "Acid Rock", "Acoustic", "Acoustic Blues", "Afro-Pop", "Afrobeat", "Alt-Rock", "Alternative", "Ambient", "American Trad Rock", "Americana", "Anime", "Arena Rock", "Art-Rock", "Avant-Garde", "Avant-Punk", "Baladas y Boleros", "Barbershop", "Baroque", "Bebop", "Big Band", "Black Metal", "Blue Note", "Bluegrass", "Blues", "Boogaloo", "Bop", "Bossa Nova", "Bounce", "Brazilian Funk", "Breakbeat", "Britpop", "CCM", "Cajun", "Cantopop", "Celtic", "Celtic Folk", "Chamber Music", "Chant", "Chanukah", "Chicago Blues", "Chicago House", "Chicano", "Children\u2019s Music", "Chill", "Choral", "Christian", "Christmas", "Classical", "Club", "College Rock", "Conjunto", "Cool Jazz", "Country", "Crunk", "Dance", "Dancehall", "Death Metal", "Deep House", "Delta Blues", "Detroit Techno", "Dirty South", "Disco", "Disney", "Dixieland", "Doo-wop", "Downtempo", "Dream Pop", "Drill", "Drinking Songs", "Drone", "Drum'n'bass", "Dub", "Dubstep", "EDM", "Early Music", "East Coast Rap", "Easter", "Easy Listening", "Eclectic", "Electric Blues", "Electro", "Electronic", "Electronica", "Emo", "Enka", "Environmental", "Ethio-jazz", "Experimental", "Experimental Rock", "Flamenco", "Folk", "Folk-Rock", "Forro", "French Pop", "Funk", "Fusion", "Gangsta Rap", "Garage", "German Folk", "German Pop", "Glam Rock", "Gospel", "Goth", "Grime", "Grindcore", "Groove", "Grunge", "Hair Metal", "Halloween", "Happy", "Hard Bop", "Hard Dance", "Hard Rock", "Hardcore", "Hardcore Punk", "Hardcore Rap", "Hardstyle", "Healing", "Heavy Metal", "High Classical", "Hip Hop", "Holiday", "Honky Tonk", "House", "IDM", "Impressionist", "Indie", "Industrial", "Instrumental", "J-Dance", "J-Idol", "J-Pop", "J-Punk", "J-Rock", "J-Ska", "J-Synth", "Jackin House", "Jam Bands", "Japanese Pop", "Jazz", "Jungle", "K-Pop", "Karaoke", "Kayokyoku", "Kids", "Kitsch", "Klezmer", "Krautrock", "Latin", "Latin Jazz", "Latin Rap", "Local", "Lounge", "Lullabies", "MPB", "Mainstream Jazz", "Malay", "Mandopop", "March", "Mariachi", "Mawwal", "Medieval", "Meditation", "Metal", "Metalcore", "Minimal Techno", "Minimalism", "Modern", "Motown", "Mugham", "Musicals", "Musique Concr\xE8te", "Nature", "Neo-Soul", "Nerdcore", "New Acoustic", "New Age", "New Mex", "New Wave", "No Wave", "Noise", "Nordic", "Novelty", "OPM", "Oi!", "Old School Rap", "Opera", "Orchestral", "Original Score", "Outlaw Country", "Pagode", "Party", "Piano", "Polka", "Pop", "Pop Film", "Pop Latino", "Post Dubstep", "Power Pop", "Praise & Worship", "Progressive House", "Progressive Rock", "Proto-punk", "Psych Rock", "Psychedelic", "Punk", "Punk Rock", "Qawwali", "Quiet Storm", "R&B", "Ragtime", "Rainy Day", "Rap", "Reggae", "Reggaeton", "Regional Mexicano", "Relaxation", "Renaissance", "Retro", "Rock", "Rockabilly", "Rocksteady", "Romance", "Romantic", "Roots Reggae", "Roots Rock", "SKA", "Sad", "Salsa", "Samba", "Second Line", "Sertanejo", "Shaabi", "Shoegaze", "Sleep", "Smooth Jazz", "Soft Rock", "Soul", "Soundtrack", "Southern Gospel", "Southern Rock", "Space Rock", "Stage And Screen", "Steampunk", "Summer", "Surf", "Swamp Pop", "Swing", "Synth Pop", "Tango", "Techno", "Teen Pop", "Tejano", "Tex-Mex", "Thanksgiving", "Traditional", "Trance", "Trip Hop", "Tropical", "Underground Rap", "Urban", "Urban Cowboy", "West Coast Rap", "Western Swing", "World", "Worldbeat", "Zydeco"];
var na = ["(Everything I Do) I Do it For You", "(Ghost) Riders in the Sky", "(I Can't Get No) Satisfaction", "(I've Got a Gal In) Kalamazoo", "(I've Had) the Time of My Life", "(It's No) Sin", "(Just Like) Starting Over", "(Let Me Be Your) Teddy Bear", "(Put Another Nickel In) Music! Music! Music!", "(Sexual) Healing", "(Sittin' On) the Dock of the Bay", "(They Long to Be) Close to You", "(You Keep Me) Hangin' On", "(You're My) Soul & Inspiration", "(Your Love Keeps Lifting Me) Higher & Higher", "12th Street Rag", "1999", "19th Nervous Breakdown", "50 Ways to Leave Your Lover", "9 to 5", "96 Tears", "A Boy Named Sue", "A Hard Day's Night", "A String of Pearls", "A Thousand Miles", "A Tree in the Meadow", "A Whiter Shade of Pale", "A Whole New World (Aladdin's Theme)", "A Woman in Love", "A-Tisket A-Tasket", "ABC", "Abracadabra", "Ac-cent-tchu-ate the Positive", "Addicted to Love", "After You've Gone", "Afternoon Delight", "Again", "Against All Odds (Take a Look At Me Now)", "Ain't Misbehavin'", "Ain't No Mountain High Enough", "Ain't No Sunshine", "Ain't That a Shame", "Airplanes", "All Along the Watchtower", "All I Have to Do is Dream", "All I Wanna Do", "All My Lovin' (You're Never Gonna Get It)", "All Night Long (All Night)", "All Out of Love", "All Shook Up", "All You Need is Love", "Alone", "Alone Again (Naturally)", "Always On My Mind", "American Pie", "American Woman", "Angie", "Another Brick in the Wall (part 2)", "Another Day in Paradise", "Another Night", "Another One Bites the Dust", "Apologize", "April Showers", "Aquarius/Let The Sunshine In", "Are You Lonesome Tonight?", "Arthur's Theme (Best That You Can Do)", "As Time Goes By", "At Last", "At the Hop", "Auf Wiederseh'n Sweetheart", "Baby Baby", "Baby Come Back", "Baby Got Back", "Baby Love", "Baby One More Time", "Bad Day", "Bad Girls", "Bad Moon Rising", "Bad Romance", "Bad, Bad Leroy Brown", "Baker Street", "Ball of Confusion (That's What the World is Today)", "Ballad of the Green Berets", "Ballerina", "Band On the Run", "Band of Gold", "Battle of New Orleans", "Be Bop a Lula", "Be My Baby", "Be My Love", "Beat It", "Beautiful Day", "Beauty & the Beast", "Because I Love You (The Postman Song)", "Because You Loved Me", "Because of You", "Before The Next Teardrop Falls", "Begin the Beguine", "Behind Closed Doors", "Being With You", "Believe", "Ben", "Bennie & the Jets", "Besame Mucho", "Best of My Love", "Bette Davis Eyes", "Big Bad John", "Big Girls Don't Cry", "Billie Jean", "Bitter Sweet Symphony", "Black Or White", "Black Velvet", "Blaze of Glory", "Bleeding Love", "Blue Suede Shoes", "Blue Tango", "Blueberry Hill", "Blurred Lines", "Body & Soul", "Bohemian Rhapsody", "Boogie Oogie Oogie", "Boogie Woogie Bugle Boy", "Boom Boom Pow", "Born in the USA", "Born to Be Wild", "Born to Run", "Boulevard of Broken Dreams", "Brand New Key", "Brandy (You're A Fine Girl)", "Breaking Up is Hard to Do", "Breathe", "Bridge Over Troubled Water", "Brother Louie", "Brother, Can You Spare a Dime?", "Brown Eyed Girl", "Brown Sugar", "Build Me Up Buttercup", "Burn", "Buttons & Bows", "Bye Bye Love", "Bye Bye, Blackbird", "Bye, Bye, Bye", "Caldonia Boogie (What Makes Your Big Head So Hard)", "California Dreamin'", "California Girls", "Call Me", "Call Me Maybe", "Can You Feel the Love Tonight", "Can't Buy Me Love", "Can't Get Enough of Your Love, Babe", "Can't Help Falling in Love", "Candle in the Wind '97", "Candy Man", "Car Wash", "Careless Whisper", "Cars", "Cat's in the Cradle", "Cathy's Clown", "Celebration", "Centerfold", "Chain of Fools", "Chances Are", "Change the World", "Chapel of Love", "Chattanooga Choo Choo", "Chattanoogie Shoe-Shine Boy", "Check On It", "Cheek to Cheek", "Cherish", "Cherry Pink & Apple Blossom White", "Cold, Cold Heart", "Colors of the Wind", "Come On Eileen", "Come On-a My House", "Come Together", "Coming Up", "Cracklin' Rosie", "Crazy", "Crazy For You", "Crazy Little Thing Called Love", "Crazy in Love", "Creep", "Crimson & Clover", "Crocodile Rock", "Cry", "Cry Like a Baby", "Crying", "Da Doo Ron Ron (When He Walked Me Home)", "Dance to the Music", "Dancing Queen", "Dancing in the Dark", "Dancing in the Street", "Dardanella", "Daydream Believer", "December 1963 (Oh What a Night)", "Delicado", "Dilemma", "Disco Duck", "Disco Lady", "Disturbia", "Dizzy", "Do That to Me One More Time", "Do Wah Diddy Diddy", "Do Ya Think I'm Sexy?", "Do You Love Me?", "Don't Be Cruel", "Don't Fence Me In", "Don't Go Breaking My Heart", "Don't Leave Me This Way", "Don't Let the Stars Get in Your Eyes", "Don't Let the Sun Go Down On Me", "Don't Speak", "Don't Stop 'Til You Get Enough", "Don't Worry Be Happy", "Don't You (Forget About Me)", "Don't You Want Me", "Doo Wop (That Thing)", "Down", "Down Hearted Blues", "Down Under", "Downtown", "Dreamlover", "Dreams", "Drop it Like It's Hot", "Drops of Jupiter (Tell Me)", "Duke of Earl", "E.T.", "Earth Angel", "Ebony & Ivory", "Eight Days a Week", "Empire State Of Mind", "End of the Road", "Endless Love", "Escape (The Pina Colada Song)", "Eve of Destruction", "Every Breath You Take", "Every Little Thing She Does is Magic", "Everybody Loves Somebody", "Everybody Wants to Rule the World", "Everyday People", "Eye of the Tiger", "Faith", "Fallin'", "Fame", "Family Affair", "Fantasy", "Fast Car", "Feel Good Inc", "Feel Like Making Love", "Fire & Rain", "Firework", "Flashdance. What a Feeling", "Fly Robin Fly", "Foolish Games", "Footloose", "For What It's Worth (Stop, Hey What's That Sound)", "Fortunate Son", "Frankenstein", "Freak Me", "Freebird", "Frenesi", "Funkytown", "Gangsta's Paradise", "Georgia On My Mind", "Georgy Girl", "Get Back", "Get Down Tonight", "Get Off of My Cloud", "Ghostbusters", "Gimme Some Lovin'", "Girls Just Wanna Have Fun", "Give Me Everything", "Gives You Hell", "Glamorous", "Glory of Love", "Go Your Own Way", "God Bless America", "God Bless the Child", "Gold Digger", "Gonna Make You Sweat (Everybody Dance Now)", "Good Lovin'", "Good Times", "Good Vibrations", "Goodbye Yellow Brick Road", "Goodnight, Irene", "Got to Give it Up", "Grease", "Great Balls of Fire", "Greatest Love of All", "Green Onions", "Green River", "Green Tambourine", "Grenade", "Groove is in the Heart", "Groovin'", "Gypsies, Tramps & Thieves", "Hair", "Hang On Sloopy", "Hanging by a Moment", "Hanky Panky", "Happy Days Are Here Again", "Happy Together", "Harbour Lights", "Hard to Say I'm Sorry", "Harper Valley PTA", "Have You Ever Really Loved a Woman?", "He'll Have to Go", "He's So Fine", "He's a Rebel", "Heart of Glass", "Heart of Gold", "Heartbreak Hotel", "Hello Dolly", "Hello, I Love You, Won't You Tell Me Your Name?", "Help Me, Rhonda", "Help!", "Here Without You", "Here in My Heart", "Hero", "Hey Baby", "Hey Jude", "Hey Paula", "Hey There", "Hey There Delilah", "Hey Ya!", "Higher Love", "Hips don't lie", "Hit the Road, Jack", "Hold On", "Hollaback Girl", "Honey", "Honky Tonk", "Honky Tonk Woman", "Horse With No Name", "Hot Child In The City", "Hot Stuff", "Hotel California", "Hound Dog", "House of the Rising Sun", "How Deep is Your Love?", "How Do I Live?", "How Do You Mend a Broken Heart", "How High the Moon", "How Much is That Doggy in the Window?", "How Will I Know", "How You Remind Me", "How to Save a Life", "Hungry Heart", "Hurt So Good", "I Believe I Can Fly", "I Can Dream, Can't I?", "I Can Help", "I Can See Clearly Now", "I Can't Get Next to You", "I Can't Get Started", "I Can't Go For That (No Can Do)", "I Can't Help Myself (Sugar Pie, Honey Bunch)", "I Can't Stop Loving You", "I Don't Want to Miss a Thing", "I Fall to Pieces", "I Feel Fine", "I Feel For You", "I Feel Love", "I Get Around", "I Got You (I Feel Good)", "I Got You Babe", "I Gotta Feeling", "I Heard it Through the Grapevine", "I Honestly Love You", "I Just Called to Say I Love You", "I Just Wanna Be Your Everything", "I Kissed A Girl", "I Love Rock 'n' Roll", "I Need You Now", "I Only Have Eyes For You", "I Shot the Sheriff", "I Still Haven't Found What I'm Looking For", "I Swear", "I Think I Love You", "I Walk the Line", "I Wanna Dance With Somebody (Who Loves Me)", "I Wanna Love You", "I Want You Back", "I Want to Hold Your Hand", "I Want to Know What Love Is", "I Went to Your Wedding", "I Will Always Love You", "I Will Follow Him", "I Will Survive", "I Write the Songs", "I'll Be Missing You", "I'll Be There", "I'll Make Love to You", "I'll Never Smile Again", "I'll Take You There", "I'll Walk Alone", "I'll be seeing you", "I'm Looking Over a Four Leaf Clover", "I'm So Lonesome I Could Cry", "I'm Sorry", "I'm Walking Behind You", "I'm Your Boogie Man", "I'm Yours", "I'm a Believer", "I've Heard That Song Before", "If (They Made Me a King)", "If I Didn't Care", "If You Don't Know Me By Now", "If You Leave Me Now", "Imagine", "In Da Club", "In the End", "In the Ghetto", "In the Mood", "In the Summertime", "In the Year 2525 (Exordium & Terminus)", "Incense & Peppermints", "Indian Reservation (The Lament Of The Cherokee Reservation Indian)", "Instant Karma", "Iris", "Ironic", "Irreplaceable", "It Had to Be You", "It's All in the Game", "It's My Party", "It's Now Or Never", "It's Still Rock 'n' Roll to Me", "It's Too Late", "Jack & Diane", "Jailhouse Rock", "Jessie's Girl", "Jive Talkin'", "Johnny B Goode", "Joy to the World", "Judy in Disguise (With Glasses)", "Jump", "Jumpin' Jack Flash", "Just Dance", "Just My Imagination (Running Away With Me)", "Just the Way You Are", "Kansas City", "Karma Chameleon", "Keep On Loving You", "Killing Me Softly With His Song", "King of the Road", "Kiss", "Kiss & Say Goodbye", "Kiss From a Rose", "Kiss Me", "Kiss On My List", "Kiss You All Over", "Knock On Wood", "Knock Three Times", "Kokomo", "Kryptonite", "Kung Fu Fighting", "La Bamba", "Lady", "Lady Marmalade (Voulez-Vous Coucher Aver Moi Ce Soir?)", "Last Train to Clarksville", "Layla", "Le Freak", "Leader of the Pack", "Lean On Me", "Leaving, on a Jet Plane", "Let Me Call You Sweetheart", "Let Me Love You", "Let it Be", "Let it Snow! Let it Snow! Let it Snow!", "Let's Dance", "Let's Get it On", "Let's Groove", "Let's Hear it For the Boy", "Let's Stay Together", "Light My Fire", "Lights", "Like a Prayer", "Like a Rolling Stone", "Like a Virgin", "Little Darlin'", "Little Things Mean a Lot", "Live & Let Die", "Livin' La Vida Loca", "Livin' On a Prayer", "Living For the City", "Locked Out Of Heaven", "Lola", "Lonely Boy", "Long Cool Woman in a Black Dress", "Long Tall Sally", "Look Away", "Lookin' Out My Back Door", "Lose Yourself", "Losing My Religion", "Louie Louie", "Love Child", "Love Hangover", "Love In This Club", "Love Is Blue (L'Amour Est Bleu)", "Love Letters in the Sand", "Love Me Do", "Love Me Tender", "Love Shack", "Love Theme From 'A Star is Born' (Evergreen)", "Love Train", "Love Will Keep Us Together", "Love is a Many Splendoured Thing", "Love to Love You Baby", "Love's Theme", "Loving You", "Low", "Macarena", "Mack the Knife", "Maggie May", "Magic", "Magic Carpet Ride", "Make Love to Me", "Make it With You", "Makin' Whoopee", "Mama Told Me Not to Come", "Man in the Mirror", "Manana (Is Soon Enough For Me)", "Maneater", "Maniac", "Maybellene", "Me & Bobby McGee", "Me & Mrs Jones", "Memories Are Made of This", "Mercy Mercy Me (The Ecology)", "Mickey", "Midnight Train to Georgia", "Minnie the Moocher", "Miss You", "Miss You Much", "Mister Sandman", "Mmmbop", "Mona Lisa", "Monday Monday", "Money For Nothing", "Mony Mony", "Mood Indigo", "Moonlight Cocktail", "Moonlight Serenade", "More Than Words", "More Than a Feeling", "Morning Train (Nine to Five)", "Mr Big Stuff", "Mr Brightside", "Mr Tambourine Man", "Mrs Brown You've Got a Lovely Daughter", "Mrs Robinson", "Mule Train", "Music", "My Blue Heaven", "My Boyfriend's Back", "My Eyes Adored You", "My Girl", "My Guy", "My Heart Will Go On", "My Life", "My Love", "My Man", "My Prayer", "My Sharona", "My Sweet Lord", "Na Na Hey Hey (Kiss Him Goodbye)", "Nature Boy", "Near You", "Need You Now", "Need You Tonight", "Never Gonna Give You Up", "Night & Day", "Night Fever", "Nights in White Satin", "No One", "No Scrubs", "Nobody Does it Better", "Nothin' on You", "Nothing Compares 2 U", "Nothing's Gonna Stop Us Now", "Ode To Billie Joe", "Oh Happy Day", "Oh My Papa (O Mein Papa)", "Oh, Pretty Woman", "Ol' Man River", "Ole Buttermilk Sky", "On Bended Knee", "On My Own", "On the Atchison, Topeka & the Santa Fe", "One", "One Bad Apple", "One More Try", "One O'Clock Jump", "One Sweet Day", "One of These Nights", "One of Us", "Only The Lonely (Know The Way I Feel)", "Only You (And You Alone)", "Open Arms", "Over There", "Over the Rainbow", "Paint it Black", "Papa Don't Preach", "Papa Was a Rolling Stone", "Papa's Got a Brand New Bag", "Paper Doll", "Paper Planes", "Paperback Writer", "Party Rock Anthem", "Peg o' My Heart", "Peggy Sue", "Pennies From Heaven", "Penny Lane", "People", "People Got to Be Free", "Personality", "Philadelphia Freedom", "Physical", "Piano Man", "Pick Up the Pieces", "Pistol Packin' Mama", "Play That Funky Music", "Please Mr Postman", "Poker Face", "Pon De Replay", "Pony Time", "Pop Muzik", "Prisoner of Love", "Private Eyes", "Promiscuous", "Proud Mary", "Purple Haze", "Purple Rain", "Puttin' on the Ritz", "Que sera sera (Whatever will be will be)", "Queen of Hearts", "Rag Doll", "Rag Mop", "Rags to Riches", "Raindrops Keep Falling On My Head", "Rapture", "Ray of Light", "Reach Out (I'll Be There)", "Red Red Wine", "Rehab", "Respect", "Return to Sender", "Reunited", "Revolution", "Rhapsody in Blue", "Rhinestone Cowboy", "Rich Girl", "Riders On the Storm", "Right Back Where We Started From", "Ring My Bell", "Ring of Fire", "Rock Around the Clock", "Rock With You", "Rock Your Baby", "Rock the Boat", "Rock the Casbah", "Roll Over Beethoven", "Roll With It", "Rolling In The Deep", "Rosanna", "Roses Are Red", "Royals", "Ruby Tuesday", "Rudolph, the Red-Nosed Reindeer", "Rum & Coca-Cola", "Runaround Sue", "Runaway", "Running Scared", "Rush Rush", "Sailing", "Save the Best For Last", "Save the Last Dance For Me", "Say It Right", "Say My Name", "Say Say Say", "Say You, Say Me", "School's Out", "Seasons in the Sun", "Secret Love", "Sentimental Journey", "Sexyback", "Sh-Boom (Life Could Be a Dream)", "Shadow Dancing", "Shake Down", "Shake You Down", "She Drives Me Crazy", "She Loves You", "She's a Lady", "Shining Star", "Shop Around", "Shout", "Silly Love Songs", "Since U Been Gone", "Sing, Sing, Sing (With A Swing)", "Singing The Blues", "Single Ladies (Put A Ring On It)", "Sir Duke", "Sixteen Tons", "Sledgehammer", "Sleep Walk", "Sleepy Lagoon", "Slow Poke", "Smells Like Teen Spirit", "Smoke Gets in Your Eyes", "Smoke On the Water", "Smoke! Smoke! Smoke! (That Cigarette)", "Smooth", "So Much in Love", "Soldier Boy", "Some Enchanted Evening", "Some of These Days", "Somebody That I Used to Know", "Somebody to Love", "Someday", "Somethin' Stupid", "Something", "Soul Man", "Spanish Harlem", "Spill the Wine", "Spinning Wheel", "Spirit in the Sky", "St George & the Dragonette", "St Louis Blues", "Stagger Lee", "Stairway to Heaven", "Stand By Me", "Stardust", "Stars & Stripes Forever", "Stay (I Missed You)", "Stayin' Alive", "Stop! in the Name of Love", "Stormy Weather (Keeps Rainin' All the Time)", "Straight Up", "Strange Fruit", "Stranger On the Shore", "Strangers in the Night", "Strawberry Fields Forever", "Streets of Philadelphia", "Stronger", "Stuck On You", "Sugar Shack", "Sugar Sugar", "Summer in the City", "Summertime Blues", "Sunday, Monday or Always", "Sunshine Superman", "Sunshine of Your Love", "Superstar", "Superstition", "Surfin' USA", "Suspicious Minds", "Swanee", "Sweet Caroline (Good Times Never Seemed So Good)", "Sweet Child O' Mine", "Sweet Dreams (Are Made of This)", "Sweet Georgia Brown", "Sweet Home Alabama", "Sweet Soul Music", "Swinging On a Star", "T For Texas (Blue Yodel No 1)", "TSOP (The Sound of Philadelphia)", "Take Me Home, Country Roads", "Take My Breath Away", "Take On Me", "Take The 'A' Train", "Take a Bow", "Tammy", "Tangerine", "Tears in Heaven", "Tears of a Clown", "Temperature", "Tennessee Waltz", "Tequila", "Tha Crossroads", "Thank You (Falettinme be Mice Elf Again)", "That Lucky Old Sun (Just Rolls Around Heaven All Day)", "That Old Black Magic", "That'll Be the Day", "That's Amore", "That's What Friends Are For", "That's the Way (I Like It)", "That's the Way Love Goes", "The Boy is Mine", "The Boys of Summer", "The Christmas Song (Chestnuts Roasting On An Open Fire)", "The End of the World", "The First Time Ever I Saw Your Face", "The Girl From Ipanema", "The Glow-Worm", "The Great Pretender", "The Gypsy", "The Hustle", "The Joker", "The Last Dance", "The Letter", "The Loco-Motion", "The Long & Winding Road", "The Love You Save", "The Morning After", "The Power of Love", "The Prisoner's Song", "The Reason", "The Rose", "The Sign", "The Song From Moulin Rouge (Where Is Your Heart)", "The Sounds of Silence", "The Streak", "The Sweet Escape", "The Thing", "The Tide is High", "The Tracks of My Tears", "The Twist", "The Wanderer", "The Way We Were", "The Way You Look Tonight", "The Way You Move", "Theme From 'A Summer Place'", "Theme From 'Greatest American Hero' (Believe It Or Not)", "Theme From 'Shaft'", "There goes my baby", "These Boots Are Made For Walking", "Third Man Theme", "This Diamond Ring", "This Guy's in Love With You", "This Land is Your Land", "This Love", "This Ole House", "This Used to Be My Playground", "Three Coins in the Fountain", "Three Times a Lady", "Thrift Shop", "Thriller", "Ticket to Ride", "Tie a Yellow Ribbon 'round the Old Oak Tree", "Tiger Rag", "Tighten Up", "Tik-Toc", "Till I Waltz Again With You", "Till The End of Time", "Time After Time", "Time of the Season", "To Sir, with Love", "Tom Dooley", "Tonight's the Night (Gonna Be Alright)", "Too Close", "Too Young", "Tossing & Turning", "Total Eclipse of the Heart", "Touch Me", "Toxic", "Travellin' Band", "Travellin' Man", "Truly Madly Deeply", "Turn! Turn! Turn! (To Everything There is a Season)", "Tutti Frutti", "Twist & Shout", "Two Hearts", "U Can't Touch This", "U Got it Bad", "Umbrella", "Un-Break My Heart", "Unbelievable", "Unchained Melody", "Uncle Albert (Admiral Halsey)", "Under the Boardwalk", "Under the Bridge", "Unforgettable", "Up Around the Bend", "Up Up & Away", "Up Where We Belong", "Upside Down", "Use Somebody", "Vaya Con Dios (may God Be With You)", "Venus", "Vision of Love", "Viva La Vida", "Vogue", "Volare", "Wabash Cannonball", "Waiting For a Girl Like You", "Wake Me Up Before You Go Go", "Wake Up Little Susie", "Walk Don't Run", "Walk Like a Man", "Walk Like an Egyptian", "Walk On By", "Walk On the Wild Side", "Walk This Way", "Wannabe", "Want Ads", "Wanted", "War", "Waterfalls", "Wayward Wind", "We Are Family", "We Are Young", "We Are the Champions", "We Are the World", "We Belong Together", "We Built This City", "We Can Work it Out", "We Didn't Start the Fire", "We Found Love", "We Got The Beat", "We Will Rock You", "We've Only Just Begun", "Weak", "Wedding Bell Blues", "West End Blues", "West End Girls", "What Goes Around Comes Around", "What a Fool Believes", "What'd I Say", "What's Going On?", "What's Love Got to Do With It?", "Whatcha Say", "Wheel of Fortune", "When Doves Cry", "When You Wish Upon a Star", "When a Man Loves a Woman", "Where Did Our Love Go", "Where is the Love?", "Whip It", "Whispering", "White Christmas", "White Rabbit", "Whole Lotta Love", "Whole Lotta Shakin' Goin' On", "Whoomp! (There it Is)", "Why Do Fools Fall in Love?", "Why Don't You Believe Me?", "Wichita Lineman", "Wicked Game", "Wild Thing", "Wild Wild West", "Will It Go Round In Circles", "Will You Love Me Tomorrow", "Winchester Cathedral", "Wind Beneath My Wings", "Wipe Out", "Wishing Well", "With Or Without You", "Without Me", "Without You", "Woman", "Won't Get Fooled Again", "Wooly Bully", "Working My Way Back to You", "YMCA", "Yakety Yak", "Yeah!", "Yellow Rose of Texas", "Yesterday", "You Ain't Seen Nothin' Yet", "You Always Hurt the One You Love", "You Are the Sunshine of My Life", "You Belong With Me", "You Belong to Me", "You Can't Hurry Love", "You Don't Bring Me Flowers", "You Don't Have to Be a Star (To Be in My Show)", "You Light Up My Life", "You Make Me Feel Brand New", "You Make Me Feel Like Dancing", "You Really Got Me", "You Send Me", "You Sexy Thing", "You Were Meant for Me", "You make Me Wanna", "You'll Never Know", "You're Beautiful", "You're So Vain", "You're Still the One", "You're the One That I Want", "You've Got a Friend", "You've Lost That Lovin' Feelin'", "Your Cheatin' Heart", "Your Song"];
var hr = { album: aa, artist: ra, genre: oa, song_name: na };
var ia = hr;
var ta = ["activist", "artist", "author", "blogger", "business owner", "coach", "creator", "designer", "developer", "dreamer", "educator", "engineer", "entrepreneur", "environmentalist", "film lover", "filmmaker", "foodie", "founder", "friend", "gamer", "geek", "grad", "inventor", "leader", "model", "musician", "nerd", "parent", "patriot", "person", "philosopher", "photographer", "public speaker", "scientist", "singer", "streamer", "student", "teacher", "traveler", "veteran", "writer"];
var la = ["{{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}, {{person.bio_part}}", "{{person.bio_part}}, {{person.bio_part}}, {{person.bio_part}} {{internet.emoji}}", "{{word.noun}} {{person.bio_supporter}}", "{{word.noun}} {{person.bio_supporter}}  {{internet.emoji}}", "{{word.noun}} {{person.bio_supporter}}, {{person.bio_part}}", "{{word.noun}} {{person.bio_supporter}}, {{person.bio_part}} {{internet.emoji}}"];
var sa = ["advocate", "devotee", "enthusiast", "fan", "junkie", "lover", "supporter"];
var da = { generic: ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aimee", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "D'angelo", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gayle", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"], female: ["Ada", "Adrienne", "Agnes", "Alberta", "Alexandra", "Alexis", "Alice", "Alicia", "Alison", "Allison", "Alma", "Alyssa", "Amanda", "Amber", "Amelia", "Amy", "Ana", "Andrea", "Angel", "Angela", "Angelica", "Angelina", "Angie", "Anita", "Ann", "Anna", "Anne", "Annette", "Annie", "Antoinette", "Antonia", "April", "Arlene", "Ashley", "Audrey", "Barbara", "Beatrice", "Becky", "Belinda", "Bernadette", "Bernice", "Bertha", "Bessie", "Beth", "Bethany", "Betsy", "Betty", "Beulah", "Beverly", "Billie", "Blanca", "Blanche", "Bobbie", "Bonnie", "Brandi", "Brandy", "Brenda", "Bridget", "Brittany", "Brooke", "Camille", "Candace", "Candice", "Carla", "Carmen", "Carol", "Carole", "Caroline", "Carolyn", "Carrie", "Casey", "Cassandra", "Catherine", "Cathy", "Cecelia", "Cecilia", "Celia", "Charlene", "Charlotte", "Chelsea", "Cheryl", "Christie", "Christina", "Christine", "Christy", "Cindy", "Claire", "Clara", "Claudia", "Colleen", "Connie", "Constance", "Cora", "Courtney", "Cristina", "Crystal", "Cynthia", "Daisy", "Dana", "Danielle", "Darla", "Darlene", "Dawn", "Deanna", "Debbie", "Deborah", "Debra", "Delia", "Della", "Delores", "Denise", "Desiree", "Diana", "Diane", "Dianna", "Dianne", "Dixie", "Dolores", "Donna", "Dora", "Doreen", "Doris", "Dorothy", "Ebony", "Edith", "Edna", "Eileen", "Elaine", "Eleanor", "Elena", "Elisa", "Elizabeth", "Ella", "Ellen", "Eloise", "Elsa", "Elsie", "Elvira", "Emily", "Emma", "Erica", "Erika", "Erin", "Erma", "Ernestine", "Essie", "Estelle", "Esther", "Ethel", "Eula", "Eunice", "Eva", "Evelyn", "Faith", "Fannie", "Faye", "Felicia", "Flora", "Florence", "Frances", "Francis", "Freda", "Gail", "Gayle", "Geneva", "Genevieve", "Georgia", "Geraldine", "Gertrude", "Gina", "Ginger", "Gladys", "Glenda", "Gloria", "Grace", "Gretchen", "Guadalupe", "Gwen", "Gwendolyn", "Hannah", "Harriet", "Hattie", "Hazel", "Heather", "Heidi", "Helen", "Henrietta", "Hilda", "Holly", "Hope", "Ida", "Inez", "Irene", "Iris", "Irma", "Isabel", "Jackie", "Jacqueline", "Jacquelyn", "Jaime", "Jamie", "Jan", "Jana", "Jane", "Janet", "Janice", "Janie", "Janis", "Jasmine", "Jean", "Jeanette", "Jeanne", "Jeannette", "Jeannie", "Jenna", "Jennie", "Jennifer", "Jenny", "Jessica", "Jessie", "Jill", "Jo", "Joan", "Joann", "Joanna", "Joanne", "Jodi", "Jody", "Johanna", "Johnnie", "Josefina", "Josephine", "Joy", "Joyce", "Juana", "Juanita", "Judith", "Judy", "Julia", "Julie", "June", "Kara", "Karen", "Kari", "Karla", "Kate", "Katherine", "Kathleen", "Kathryn", "Kathy", "Katie", "Katrina", "Kay", "Kayla", "Kelley", "Kelli", "Kellie", "Kelly", "Kendra", "Kerry", "Kim", "Kimberly", "Krista", "Kristen", "Kristi", "Kristie", "Kristin", "Kristina", "Kristine", "Kristy", "Krystal", "Lana", "Latoya", "Laura", "Lauren", "Laurie", "Laverne", "Leah", "Lee", "Leigh", "Lela", "Lena", "Leona", "Leslie", "Leticia", "Lila", "Lillian", "Lillie", "Linda", "Lindsay", "Lindsey", "Lisa", "Lois", "Lola", "Lora", "Lorena", "Lorene", "Loretta", "Lori", "Lorraine", "Louise", "Lucia", "Lucille", "Lucy", "Lula", "Luz", "Lydia", "Lynda", "Lynette", "Lynn", "Lynne", "Mabel", "Mable", "Madeline", "Mae", "Maggie", "Mamie", "Mandy", "Marcella", "Marcia", "Margaret", "Margarita", "Margie", "Marguerite", "Maria", "Marian", "Marianne", "Marie", "Marilyn", "Marion", "Marjorie", "Marlene", "Marsha", "Marta", "Martha", "Mary", "Maryann", "Mattie", "Maureen", "Maxine", "May", "Megan", "Meghan", "Melanie", "Melba", "Melinda", "Melissa", "Melody", "Mercedes", "Meredith", "Michele", "Michelle", "Mildred", "Mindy", "Minnie", "Miranda", "Miriam", "Misty", "Molly", "Mona", "Monica", "Monique", "Muriel", "Myra", "Myrtle", "Nadine", "Nancy", "Naomi", "Natalie", "Natasha", "Nellie", "Nettie", "Nichole", "Nicole", "Nina", "Nora", "Norma", "Olga", "Olive", "Olivia", "Ollie", "Opal", "Ora", "Pam", "Pamela", "Pat", "Patricia", "Patsy", "Patti", "Patty", "Paula", "Paulette", "Pauline", "Pearl", "Peggy", "Penny", "Phyllis", "Priscilla", "Rachael", "Rachel", "Ramona", "Raquel", "Rebecca", "Regina", "Renee", "Rhonda", "Rita", "Roberta", "Robin", "Robyn", "Rochelle", "Rosa", "Rosalie", "Rose", "Rosemarie", "Rosemary", "Rosie", "Roxanne", "Ruby", "Ruth", "Sabrina", "Sadie", "Sally", "Samantha", "Sandra", "Sandy", "Sara", "Sarah", "Shannon", "Shari", "Sharon", "Shawna", "Sheila", "Shelia", "Shelley", "Shelly", "Sheri", "Sherri", "Sherry", "Sheryl", "Shirley", "Silvia", "Sonia", "Sonja", "Sonya", "Sophia", "Sophie", "Stacey", "Stacy", "Stella", "Stephanie", "Sue", "Susan", "Susie", "Suzanne", "Sylvia", "Tabitha", "Tamara", "Tami", "Tammy", "Tanya", "Tara", "Tasha", "Teresa", "Teri", "Terri", "Terry", "Thelma", "Theresa", "Tiffany", "Tina", "Toni", "Tonya", "Tracey", "Traci", "Tracy", "Tricia", "Valerie", "Vanessa", "Velma", "Vera", "Verna", "Veronica", "Vicki", "Vickie", "Vicky", "Victoria", "Viola", "Violet", "Virginia", "Vivian", "Wanda", "Wendy", "Whitney", "Willie", "Wilma", "Winifred", "Yolanda", "Yvette", "Yvonne"], male: ["Aaron", "Abel", "Abraham", "Adam", "Adrian", "Al", "Alan", "Albert", "Alberto", "Alejandro", "Alex", "Alexander", "Alfonso", "Alfred", "Alfredo", "Allan", "Allen", "Alonzo", "Alton", "Alvin", "Amos", "Andre", "Andres", "Andrew", "Andy", "Angel", "Angelo", "Anthony", "Antonio", "Archie", "Armando", "Arnold", "Arthur", "Arturo", "Aubrey", "Austin", "Barry", "Ben", "Benjamin", "Bennie", "Benny", "Bernard", "Bert", "Bill", "Billy", "Blake", "Bob", "Bobby", "Boyd", "Brad", "Bradford", "Bradley", "Brandon", "Brendan", "Brent", "Brett", "Brian", "Bruce", "Bryan", "Bryant", "Byron", "Caleb", "Calvin", "Cameron", "Carl", "Carlos", "Carlton", "Carroll", "Cary", "Casey", "Cecil", "Cedric", "Cesar", "Chad", "Charles", "Charlie", "Chester", "Chris", "Christian", "Christopher", "Clarence", "Clark", "Claude", "Clay", "Clayton", "Clifford", "Clifton", "Clint", "Clinton", "Clyde", "Cody", "Colin", "Conrad", "Corey", "Cornelius", "Cory", "Courtney", "Craig", "Curtis", "Dale", "Dallas", "Damon", "Dan", "Dana", "Daniel", "Danny", "Darin", "Darnell", "Darrel", "Darrell", "Darren", "Darrin", "Darryl", "Daryl", "Dave", "David", "Dean", "Delbert", "Dennis", "Derek", "Derrick", "Devin", "Dewey", "Dexter", "Domingo", "Dominic", "Dominick", "Don", "Donald", "Donnie", "Doug", "Douglas", "Doyle", "Drew", "Duane", "Dustin", "Dwayne", "Dwight", "Earl", "Earnest", "Ed", "Eddie", "Edgar", "Edmond", "Edmund", "Eduardo", "Edward", "Edwin", "Elbert", "Elias", "Elijah", "Ellis", "Elmer", "Emanuel", "Emilio", "Emmett", "Enrique", "Eric", "Erick", "Erik", "Ernest", "Ernesto", "Ervin", "Eugene", "Evan", "Everett", "Felipe", "Felix", "Fernando", "Floyd", "Forrest", "Francis", "Francisco", "Frank", "Frankie", "Franklin", "Fred", "Freddie", "Frederick", "Fredrick", "Gabriel", "Garrett", "Garry", "Gary", "Gene", "Geoffrey", "George", "Gerald", "Gerard", "Gerardo", "Gilbert", "Gilberto", "Glen", "Glenn", "Gordon", "Grady", "Grant", "Greg", "Gregg", "Gregory", "Guadalupe", "Guillermo", "Gustavo", "Guy", "Harold", "Harry", "Harvey", "Hector", "Henry", "Herbert", "Herman", "Homer", "Horace", "Howard", "Hubert", "Hugh", "Hugo", "Ian", "Ignacio", "Ira", "Irvin", "Irving", "Isaac", "Ismael", "Israel", "Ivan", "Jack", "Jackie", "Jacob", "Jaime", "Jake", "James", "Jamie", "Jan", "Jared", "Jason", "Javier", "Jay", "Jean", "Jeff", "Jeffery", "Jeffrey", "Jerald", "Jeremiah", "Jeremy", "Jermaine", "Jerome", "Jerry", "Jesse", "Jessie", "Jesus", "Jim", "Jimmie", "Jimmy", "Jody", "Joe", "Joel", "Joey", "John", "Johnathan", "Johnnie", "Johnny", "Jon", "Jonathan", "Jonathon", "Jordan", "Jorge", "Jose", "Joseph", "Josh", "Joshua", "Juan", "Julian", "Julio", "Julius", "Justin", "Karl", "Keith", "Kelly", "Kelvin", "Ken", "Kenneth", "Kenny", "Kent", "Kerry", "Kevin", "Kim", "Kirk", "Kristopher", "Kurt", "Kyle", "Lamar", "Lance", "Larry", "Laurence", "Lawrence", "Lee", "Leland", "Leo", "Leon", "Leonard", "Leroy", "Leslie", "Lester", "Levi", "Lewis", "Lionel", "Lloyd", "Lonnie", "Loren", "Lorenzo", "Louis", "Lowell", "Lucas", "Luis", "Luke", "Luther", "Lyle", "Lynn", "Mack", "Malcolm", "Manuel", "Marc", "Marco", "Marcos", "Marcus", "Mario", "Marion", "Mark", "Marlon", "Marshall", "Martin", "Marty", "Marvin", "Mathew", "Matt", "Matthew", "Maurice", "Max", "Melvin", "Merle", "Michael", "Micheal", "Miguel", "Mike", "Milton", "Mitchell", "Morris", "Moses", "Myron", "Nathan", "Nathaniel", "Neal", "Neil", "Nelson", "Nicholas", "Nick", "Nicolas", "Noah", "Noel", "Norman", "Oliver", "Omar", "Orlando", "Orville", "Oscar", "Otis", "Owen", "Pablo", "Pat", "Patrick", "Paul", "Pedro", "Percy", "Perry", "Pete", "Peter", "Phil", "Philip", "Phillip", "Preston", "Rafael", "Ralph", "Ramiro", "Ramon", "Randal", "Randall", "Randolph", "Randy", "Raul", "Ray", "Raymond", "Reginald", "Rene", "Rex", "Ricardo", "Richard", "Rick", "Rickey", "Ricky", "Robert", "Roberto", "Robin", "Roderick", "Rodney", "Rodolfo", "Rogelio", "Roger", "Roland", "Rolando", "Roman", "Ron", "Ronald", "Ronnie", "Roosevelt", "Ross", "Roy", "Ruben", "Rudolph", "Rudy", "Rufus", "Russell", "Ryan", "Salvador", "Salvatore", "Sam", "Sammy", "Samuel", "Santiago", "Santos", "Saul", "Scott", "Sean", "Sergio", "Seth", "Shane", "Shannon", "Shaun", "Shawn", "Sheldon", "Sherman", "Sidney", "Simon", "Spencer", "Stanley", "Stephen", "Steve", "Steven", "Stewart", "Stuart", "Sylvester", "Taylor", "Ted", "Terence", "Terrance", "Terrell", "Terrence", "Terry", "Theodore", "Thomas", "Tim", "Timmy", "Timothy", "Toby", "Todd", "Tom", "Tomas", "Tommie", "Tommy", "Tony", "Tracy", "Travis", "Trevor", "Troy", "Tyler", "Tyrone", "Van", "Vernon", "Victor", "Vincent", "Virgil", "Wade", "Wallace", "Walter", "Warren", "Wayne", "Wendell", "Wesley", "Wilbert", "Wilbur", "Wilfred", "Willard", "William", "Willie", "Willis", "Wilson", "Winston", "Wm", "Woodrow", "Zachary"] };
var ua = ["Agender", "Androgyne", "Androgynous", "Bigender", "Cis female", "Cis male", "Cis man", "Cis woman", "Cis", "Cisgender female", "Cisgender male", "Cisgender man", "Cisgender woman", "Cisgender", "Demi-boy", "Demi-girl", "Demi-man", "Demi-woman", "Demiflux", "Demigender", "F2M", "FTM", "Female to male trans man", "Female to male transgender man", "Female to male transsexual man", "Female to male", "Gender fluid", "Gender neutral", "Gender nonconforming", "Gender questioning", "Gender variant", "Genderflux", "Genderqueer", "Hermaphrodite", "Intersex man", "Intersex person", "Intersex woman", "Intersex", "M2F", "MTF", "Male to female trans woman", "Male to female transgender woman", "Male to female transsexual woman", "Male to female", "Man", "Multigender", "Neither", "Neutrois", "Non-binary", "Omnigender", "Other", "Pangender", "Polygender", "T* man", "T* woman", "Trans female", "Trans male", "Trans man", "Trans person", "Trans woman", "Trans", "Transsexual female", "Transsexual male", "Transsexual man", "Transsexual person", "Transsexual woman", "Transsexual", "Transgender female", "Transgender person", "Transmasculine", "Trigender", "Two* person", "Two-spirit person", "Two-spirit", "Woman", "Xenogender"];
var ca = ["Solutions", "Program", "Brand", "Security", "Research", "Marketing", "Directives", "Implementation", "Integration", "Functionality", "Response", "Paradigm", "Tactics", "Identity", "Markets", "Group", "Division", "Applications", "Optimization", "Operations", "Infrastructure", "Intranet", "Communications", "Web", "Branding", "Quality", "Assurance", "Mobility", "Accounts", "Data", "Creative", "Configuration", "Accountability", "Interactions", "Factors", "Usability", "Metrics"];
var ma = ["Lead", "Senior", "Direct", "Corporate", "Dynamic", "Future", "Product", "National", "Regional", "District", "Central", "Global", "Customer", "Investor", "International", "Legacy", "Forward", "Internal", "Human", "Chief", "Principal"];
var ha = ["{{person.jobDescriptor}} {{person.jobArea}} {{person.jobType}}"];
var ya = ["Supervisor", "Associate", "Executive", "Liaison", "Officer", "Manager", "Engineer", "Specialist", "Director", "Coordinator", "Administrator", "Architect", "Analyst", "Designer", "Planner", "Orchestrator", "Technician", "Developer", "Producer", "Consultant", "Assistant", "Facilitator", "Agent", "Representative", "Strategist"];
var pa = { generic: ["Abbott", "Abernathy", "Abshire", "Adams", "Altenwerth", "Anderson", "Ankunding", "Armstrong", "Auer", "Aufderhar", "Bahringer", "Bailey", "Balistreri", "Barrows", "Bartell", "Bartoletti", "Barton", "Bashirian", "Batz", "Bauch", "Baumbach", "Bayer", "Beahan", "Beatty", "Bechtelar", "Becker", "Bednar", "Beer", "Beier", "Berge", "Bergnaum", "Bergstrom", "Bernhard", "Bernier", "Bins", "Blanda", "Blick", "Block", "Bode", "Boehm", "Bogan", "Bogisich", "Borer", "Bosco", "Botsford", "Boyer", "Boyle", "Bradtke", "Brakus", "Braun", "Breitenberg", "Brekke", "Brown", "Bruen", "Buckridge", "Carroll", "Carter", "Cartwright", "Casper", "Cassin", "Champlin", "Christiansen", "Cole", "Collier", "Collins", "Conn", "Connelly", "Conroy", "Considine", "Corkery", "Cormier", "Corwin", "Cremin", "Crist", "Crona", "Cronin", "Crooks", "Cruickshank", "Cummerata", "Cummings", "D'Amore", "Dach", "Daniel", "Dare", "Daugherty", "Davis", "Deckow", "Denesik", "Dibbert", "Dickens", "Dicki", "Dickinson", "Dietrich", "Donnelly", "Dooley", "Douglas", "Doyle", "DuBuque", "Durgan", "Ebert", "Effertz", "Emard", "Emmerich", "Erdman", "Ernser", "Fadel", "Fahey", "Farrell", "Fay", "Feeney", "Feest", "Feil", "Ferry", "Fisher", "Flatley", "Frami", "Franecki", "Franey", "Friesen", "Fritsch", "Funk", "Gerhold", "Gerlach", "Gibson", "Gislason", "Gleason", "Gleichner", "Glover", "Goldner", "Goodwin", "Gorczany", "Gottlieb", "Goyette", "Grady", "Graham", "Grant", "Green", "Greenfelder", "Greenholt", "Grimes", "Gulgowski", "Gusikowski", "Gutkowski", "Gutmann", "Haag", "Hackett", "Hagenes", "Hahn", "Haley", "Halvorson", "Hamill", "Hammes", "Hand", "Hane", "Hansen", "Harber", "Harris", "Hartmann", "Harvey", "Hauck", "Hayes", "Heaney", "Heathcote", "Hegmann", "Heidenreich", "Heller", "Herman", "Hermann", "Hermiston", "Herzog", "Hessel", "Hettinger", "Hickle", "Hilll", "Hills", "Hilpert", "Hintz", "Hirthe", "Hodkiewicz", "Hoeger", "Homenick", "Hoppe", "Howe", "Howell", "Hudson", "Huel", "Huels", "Hyatt", "Jacobi", "Jacobs", "Jacobson", "Jakubowski", "Jaskolski", "Jast", "Jenkins", "Jerde", "Johns", "Johnson", "Johnston", "Jones", "Kassulke", "Kautzer", "Keebler", "Keeling", "Kemmer", "Kerluke", "Kertzmann", "Kessler", "Kiehn", "Kihn", "Kilback", "King", "Kirlin", "Klein", "Kling", "Klocko", "Koch", "Koelpin", "Koepp", "Kohler", "Konopelski", "Koss", "Kovacek", "Kozey", "Krajcik", "Kreiger", "Kris", "Kshlerin", "Kub", "Kuhic", "Kuhlman", "Kuhn", "Kulas", "Kunde", "Kunze", "Kuphal", "Kutch", "Kuvalis", "Labadie", "Lakin", "Lang", "Langosh", "Langworth", "Larkin", "Larson", "Leannon", "Lebsack", "Ledner", "Leffler", "Legros", "Lehner", "Lemke", "Lesch", "Leuschke", "Lind", "Lindgren", "Littel", "Little", "Lockman", "Lowe", "Lubowitz", "Lueilwitz", "Luettgen", "Lynch", "MacGyver", "Macejkovic", "Maggio", "Mann", "Mante", "Marks", "Marquardt", "Marvin", "Mayer", "Mayert", "McClure", "McCullough", "McDermott", "McGlynn", "McKenzie", "McLaughlin", "Medhurst", "Mertz", "Metz", "Miller", "Mills", "Mitchell", "Moen", "Mohr", "Monahan", "Moore", "Morar", "Morissette", "Mosciski", "Mraz", "Mueller", "Muller", "Murazik", "Murphy", "Murray", "Nader", "Nicolas", "Nienow", "Nikolaus", "Nitzsche", "Nolan", "O'Connell", "O'Conner", "O'Hara", "O'Keefe", "O'Kon", "O'Reilly", "Oberbrunner", "Okuneva", "Olson", "Ondricka", "Orn", "Ortiz", "Osinski", "Pacocha", "Padberg", "Pagac", "Parisian", "Parker", "Paucek", "Pfannerstill", "Pfeffer", "Pollich", "Pouros", "Powlowski", "Predovic", "Price", "Prohaska", "Prosacco", "Purdy", "Quigley", "Quitzon", "Rath", "Ratke", "Rau", "Raynor", "Reichel", "Reichert", "Reilly", "Reinger", "Rempel", "Renner", "Reynolds", "Rice", "Rippin", "Ritchie", "Robel", "Roberts", "Rodriguez", "Rogahn", "Rohan", "Rolfson", "Romaguera", "Roob", "Rosenbaum", "Rowe", "Ruecker", "Runolfsdottir", "Runolfsson", "Runte", "Russel", "Rutherford", "Ryan", "Sanford", "Satterfield", "Sauer", "Sawayn", "Schaden", "Schaefer", "Schamberger", "Schiller", "Schimmel", "Schinner", "Schmeler", "Schmidt", "Schmitt", "Schneider", "Schoen", "Schowalter", "Schroeder", "Schulist", "Schultz", "Schumm", "Schuppe", "Schuster", "Senger", "Shanahan", "Shields", "Simonis", "Sipes", "Skiles", "Smith", "Smitham", "Spencer", "Spinka", "Sporer", "Stamm", "Stanton", "Stark", "Stehr", "Steuber", "Stiedemann", "Stokes", "Stoltenberg", "Stracke", "Streich", "Stroman", "Strosin", "Swaniawski", "Swift", "Terry", "Thiel", "Thompson", "Tillman", "Torp", "Torphy", "Towne", "Toy", "Trantow", "Tremblay", "Treutel", "Tromp", "Turcotte", "Turner", "Ullrich", "Upton", "Vandervort", "Veum", "Volkman", "Von", "VonRueden", "Waelchi", "Walker", "Walsh", "Walter", "Ward", "Waters", "Watsica", "Weber", "Wehner", "Weimann", "Weissnat", "Welch", "West", "White", "Wiegand", "Wilderman", "Wilkinson", "Will", "Williamson", "Willms", "Windler", "Wintheiser", "Wisoky", "Wisozk", "Witting", "Wiza", "Wolf", "Wolff", "Wuckert", "Wunsch", "Wyman", "Yost", "Yundt", "Zboncak", "Zemlak", "Ziemann", "Zieme", "Zulauf"] };
var ga = { generic: [{ value: "{{person.last_name.generic}}", weight: 95 }, { value: "{{person.last_name.generic}}-{{person.last_name.generic}}", weight: 5 }] };
var ba = { generic: ["Addison", "Alex", "Anderson", "Angel", "Arden", "August", "Austin", "Avery", "Bailey", "Billie", "Blake", "Bowie", "Brooklyn", "Cameron", "Charlie", "Corey", "Dakota", "Drew", "Elliott", "Ellis", "Emerson", "Finley", "Gray", "Greer", "Harper", "Hayden", "Jaden", "James", "Jamie", "Jordan", "Jules", "Kai", "Kendall", "Kennedy", "Kyle", "Leslie", "Logan", "London", "Marlowe", "Micah", "Nico", "Noah", "North", "Parker", "Phoenix", "Quinn", "Reagan", "Reese", "Reign", "Riley", "River", "Robin", "Rory", "Rowan", "Ryan", "Sage", "Sasha", "Sawyer", "Shawn", "Shiloh", "Skyler", "Taylor"], female: ["Abigail", "Adele", "Alex", "Alice", "Alisha", "Amber", "Amelia", "Amora", "Ana\xEFs", "Angelou", "Anika", "Anise", "Annabel", "Anne", "Aphrodite", "Aretha", "Arya", "Ashton", "Aster", "Audrey", "Avery", "Bailee", "Bay", "Belle", "Beth", "Billie", "Blair", "Blaise", "Blake", "Blanche", "Blue", "Bree", "Brielle", "Brienne", "Brooke", "Caleen", "Candice", "Caprice", "Carelyn", "Caylen", "Celine", "Cerise", "Cia", "Claire", "Claudia", "Clementine", "Coral", "Coraline", "Dahlia", "Dakota", "Dawn", "Della", "Demi", "Denise", "Denver", "Devine", "Devon", "Diana", "Dylan", "Ebony", "Eden", "Eleanor", "Elein", "Elizabeth", "Ellen", "Elodie", "Eloise", "Ember", "Emma", "Erin", "Eyre", "Faith", "Farrah", "Fawn", "Fayre", "Fern", "France", "Francis", "Frida", "Genisis", "Georgia", "Grace", "Gwen", "Harley", "Harper", "Hazel", "Helen", "Hippolyta", "Holly", "Hope", "Imani", "Iowa", "Ireland", "Irene", "Iris", "Isa", "Isla", "Ivy", "Jade", "Jane", "Jazz", "Jean", "Jess", "Jett", "Jo", "Joan", "Jolie", "Jordan", "Josie", "Journey", "Joy", "Jules", "Julien", "Juliet", "Juniper", "Justice", "Kali", "Karma", "Kat", "Kate", "Kennedy", "Keva", "Kylie", "Lake", "Lane", "Lark", "Layla", "Lee", "Leigh", "Leona", "Lexi", "London", "Lou", "Louise", "Love", "Luna", "Lux", "Lynn", "Lyric", "Maddie", "Mae", "Marie", "Matilda", "Maude", "Maybel", "Meadow", "Medusa", "Mercy", "Michelle", "Mirabel", "Monroe", "Morgan", "Nalia", "Naomi", "Nova", "Olive", "Paige", "Parker", "Pax", "Pearl", "Penelope", "Phoenix", "Quinn", "Rae", "Rain", "Raven", "Ray", "Raye", "Rebel", "Reese", "Reeve", "Regan", "Riley", "River", "Robin", "Rory", "Rose", "Royal", "Ruth", "Rylie", "Sage", "Sam", "Saturn", "Scout", "Serena", "Sky", "Skylar", "Sofia", "Sophia", "Storm", "Sue", "Suzanne", "Sydney", "Taylen", "Taylor", "Teagan", "Tempest", "Tenley", "Thea", "Trinity", "Valerie", "Venus", "Vera", "Violet", "Willow", "Winter", "Xena", "Zaylee", "Zion", "Zoe"], male: ["Ace", "Aiden", "Alexander", "Ander", "Anthony", "Asher", "August", "Aziel", "Bear", "Beckham", "Benjamin", "Buddy", "Calvin", "Carter", "Charles", "Christopher", "Clyde", "Cooper", "Daniel", "David", "Dior", "Dylan", "Elijah", "Ellis", "Emerson", "Ethan", "Ezra", "Fletcher", "Flynn", "Gabriel", "Grayson", "Gus", "Hank", "Harrison", "Hendrix", "Henry", "Houston", "Hudson", "Hugh", "Isaac", "Jack", "Jackson", "Jacob", "Jakobe", "James", "Jaxon", "Jaxtyn", "Jayden", "John", "Joseph", "Josiah", "Jude", "Julian", "Karsyn", "Kenji", "Kobe", "Kylo", "Lennon", "Leo", "Levi", "Liam", "Lincoln", "Logan", "Louis", "Lucas", "Lucky", "Luke", "Mason", "Mateo", "Matthew", "Maverick", "Michael", "Monroe", "Nixon", "Ocean", "Oliver", "Otis", "Otto", "Owen", "Ozzy", "Parker", "Rocky", "Samuel", "Sebastian", "Sonny", "Teddy", "Theo", "Theodore", "Thomas", "Truett", "Walter", "Warren", "Watson", "William", "Wison", "Wyatt", "Ziggy", "Zyair"] };
var Ca = [{ value: "{{person.firstName}} {{person.lastName}}", weight: 49 }, { value: "{{person.prefix}} {{person.firstName}} {{person.lastName}}", weight: 7 }, { value: "{{person.firstName}} {{person.lastName}} {{person.suffix}}", weight: 7 }, { value: "{{person.prefix}} {{person.firstName}} {{person.lastName}} {{person.suffix}}", weight: 1 }];
var Sa = { generic: ["Dr.", "Miss", "Mr.", "Mrs.", "Ms."], female: ["Dr.", "Miss", "Mrs.", "Ms."], male: ["Dr.", "Mr."] };
var ka = ["female", "male"];
var fa = ["Jr.", "Sr.", "I", "II", "III", "IV", "V", "MD", "DDS", "PhD", "DVM"];
var va = ["Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn"];
var yr = { bio_part: ta, bio_pattern: la, bio_supporter: sa, first_name: da, gender: ua, job_area: ca, job_descriptor: ma, job_title_pattern: ha, job_type: ya, last_name: pa, last_name_pattern: ga, middle_name: ba, name: Ca, prefix: Sa, sex: ka, suffix: fa, western_zodiac_sign: va };
var Aa = yr;
var Ba = ["!##-!##-####", "(!##) !##-####", "1-!##-!##-####", "!##.!##.####", "!##-!##-#### x###", "(!##) !##-#### x###", "1-!##-!##-#### x###", "!##.!##.#### x###", "!##-!##-#### x####", "(!##) !##-#### x####", "1-!##-!##-#### x####", "!##.!##.#### x####", "!##-!##-#### x#####", "(!##) !##-#### x#####", "1-!##-!##-#### x#####", "!##.!##.#### x#####"];
var Ta = ["+1!##!######"];
var Ma = ["(!##) !##-####"];
var pr = { human: Ba, international: Ta, national: Ma };
var wa = pr;
var gr = { format: wa };
var La = gr;
var Da = [{ symbol: "H", name: "Hydrogen", atomicNumber: 1 }, { symbol: "He", name: "Helium", atomicNumber: 2 }, { symbol: "Li", name: "Lithium", atomicNumber: 3 }, { symbol: "Be", name: "Beryllium", atomicNumber: 4 }, { symbol: "B", name: "Boron", atomicNumber: 5 }, { symbol: "C", name: "Carbon", atomicNumber: 6 }, { symbol: "N", name: "Nitrogen", atomicNumber: 7 }, { symbol: "O", name: "Oxygen", atomicNumber: 8 }, { symbol: "F", name: "Fluorine", atomicNumber: 9 }, { symbol: "Ne", name: "Neon", atomicNumber: 10 }, { symbol: "Na", name: "Sodium", atomicNumber: 11 }, { symbol: "Mg", name: "Magnesium", atomicNumber: 12 }, { symbol: "Al", name: "Aluminium", atomicNumber: 13 }, { symbol: "Si", name: "Silicon", atomicNumber: 14 }, { symbol: "P", name: "Phosphorus", atomicNumber: 15 }, { symbol: "S", name: "Sulfur", atomicNumber: 16 }, { symbol: "Cl", name: "Chlorine", atomicNumber: 17 }, { symbol: "Ar", name: "Argon", atomicNumber: 18 }, { symbol: "K", name: "Potassium", atomicNumber: 19 }, { symbol: "Ca", name: "Calcium", atomicNumber: 20 }, { symbol: "Sc", name: "Scandium", atomicNumber: 21 }, { symbol: "Ti", name: "Titanium", atomicNumber: 22 }, { symbol: "V", name: "Vanadium", atomicNumber: 23 }, { symbol: "Cr", name: "Chromium", atomicNumber: 24 }, { symbol: "Mn", name: "Manganese", atomicNumber: 25 }, { symbol: "Fe", name: "Iron", atomicNumber: 26 }, { symbol: "Co", name: "Cobalt", atomicNumber: 27 }, { symbol: "Ni", name: "Nickel", atomicNumber: 28 }, { symbol: "Cu", name: "Copper", atomicNumber: 29 }, { symbol: "Zn", name: "Zinc", atomicNumber: 30 }, { symbol: "Ga", name: "Gallium", atomicNumber: 31 }, { symbol: "Ge", name: "Germanium", atomicNumber: 32 }, { symbol: "As", name: "Arsenic", atomicNumber: 33 }, { symbol: "Se", name: "Selenium", atomicNumber: 34 }, { symbol: "Br", name: "Bromine", atomicNumber: 35 }, { symbol: "Kr", name: "Krypton", atomicNumber: 36 }, { symbol: "Rb", name: "Rubidium", atomicNumber: 37 }, { symbol: "Sr", name: "Strontium", atomicNumber: 38 }, { symbol: "Y", name: "Yttrium", atomicNumber: 39 }, { symbol: "Zr", name: "Zirconium", atomicNumber: 40 }, { symbol: "Nb", name: "Niobium", atomicNumber: 41 }, { symbol: "Mo", name: "Molybdenum", atomicNumber: 42 }, { symbol: "Tc", name: "Technetium", atomicNumber: 43 }, { symbol: "Ru", name: "Ruthenium", atomicNumber: 44 }, { symbol: "Rh", name: "Rhodium", atomicNumber: 45 }, { symbol: "Pd", name: "Palladium", atomicNumber: 46 }, { symbol: "Ag", name: "Silver", atomicNumber: 47 }, { symbol: "Cd", name: "Cadmium", atomicNumber: 48 }, { symbol: "In", name: "Indium", atomicNumber: 49 }, { symbol: "Sn", name: "Tin", atomicNumber: 50 }, { symbol: "Sb", name: "Antimony", atomicNumber: 51 }, { symbol: "Te", name: "Tellurium", atomicNumber: 52 }, { symbol: "I", name: "Iodine", atomicNumber: 53 }, { symbol: "Xe", name: "Xenon", atomicNumber: 54 }, { symbol: "Cs", name: "Caesium", atomicNumber: 55 }, { symbol: "Ba", name: "Barium", atomicNumber: 56 }, { symbol: "La", name: "Lanthanum", atomicNumber: 57 }, { symbol: "Ce", name: "Cerium", atomicNumber: 58 }, { symbol: "Pr", name: "Praseodymium", atomicNumber: 59 }, { symbol: "Nd", name: "Neodymium", atomicNumber: 60 }, { symbol: "Pm", name: "Promethium", atomicNumber: 61 }, { symbol: "Sm", name: "Samarium", atomicNumber: 62 }, { symbol: "Eu", name: "Europium", atomicNumber: 63 }, { symbol: "Gd", name: "Gadolinium", atomicNumber: 64 }, { symbol: "Tb", name: "Terbium", atomicNumber: 65 }, { symbol: "Dy", name: "Dysprosium", atomicNumber: 66 }, { symbol: "Ho", name: "Holmium", atomicNumber: 67 }, { symbol: "Er", name: "Erbium", atomicNumber: 68 }, { symbol: "Tm", name: "Thulium", atomicNumber: 69 }, { symbol: "Yb", name: "Ytterbium", atomicNumber: 70 }, { symbol: "Lu", name: "Lutetium", atomicNumber: 71 }, { symbol: "Hf", name: "Hafnium", atomicNumber: 72 }, { symbol: "Ta", name: "Tantalum", atomicNumber: 73 }, { symbol: "W", name: "Tungsten", atomicNumber: 74 }, { symbol: "Re", name: "Rhenium", atomicNumber: 75 }, { symbol: "Os", name: "Osmium", atomicNumber: 76 }, { symbol: "Ir", name: "Iridium", atomicNumber: 77 }, { symbol: "Pt", name: "Platinum", atomicNumber: 78 }, { symbol: "Au", name: "Gold", atomicNumber: 79 }, { symbol: "Hg", name: "Mercury", atomicNumber: 80 }, { symbol: "Tl", name: "Thallium", atomicNumber: 81 }, { symbol: "Pb", name: "Lead", atomicNumber: 82 }, { symbol: "Bi", name: "Bismuth", atomicNumber: 83 }, { symbol: "Po", name: "Polonium", atomicNumber: 84 }, { symbol: "At", name: "Astatine", atomicNumber: 85 }, { symbol: "Rn", name: "Radon", atomicNumber: 86 }, { symbol: "Fr", name: "Francium", atomicNumber: 87 }, { symbol: "Ra", name: "Radium", atomicNumber: 88 }, { symbol: "Ac", name: "Actinium", atomicNumber: 89 }, { symbol: "Th", name: "Thorium", atomicNumber: 90 }, { symbol: "Pa", name: "Protactinium", atomicNumber: 91 }, { symbol: "U", name: "Uranium", atomicNumber: 92 }, { symbol: "Np", name: "Neptunium", atomicNumber: 93 }, { symbol: "Pu", name: "Plutonium", atomicNumber: 94 }, { symbol: "Am", name: "Americium", atomicNumber: 95 }, { symbol: "Cm", name: "Curium", atomicNumber: 96 }, { symbol: "Bk", name: "Berkelium", atomicNumber: 97 }, { symbol: "Cf", name: "Californium", atomicNumber: 98 }, { symbol: "Es", name: "Einsteinium", atomicNumber: 99 }, { symbol: "Fm", name: "Fermium", atomicNumber: 100 }, { symbol: "Md", name: "Mendelevium", atomicNumber: 101 }, { symbol: "No", name: "Nobelium", atomicNumber: 102 }, { symbol: "Lr", name: "Lawrencium", atomicNumber: 103 }, { symbol: "Rf", name: "Rutherfordium", atomicNumber: 104 }, { symbol: "Db", name: "Dubnium", atomicNumber: 105 }, { symbol: "Sg", name: "Seaborgium", atomicNumber: 106 }, { symbol: "Bh", name: "Bohrium", atomicNumber: 107 }, { symbol: "Hs", name: "Hassium", atomicNumber: 108 }, { symbol: "Mt", name: "Meitnerium", atomicNumber: 109 }, { symbol: "Ds", name: "Darmstadtium", atomicNumber: 110 }, { symbol: "Rg", name: "Roentgenium", atomicNumber: 111 }, { symbol: "Cn", name: "Copernicium", atomicNumber: 112 }, { symbol: "Nh", name: "Nihonium", atomicNumber: 113 }, { symbol: "Fl", name: "Flerovium", atomicNumber: 114 }, { symbol: "Mc", name: "Moscovium", atomicNumber: 115 }, { symbol: "Lv", name: "Livermorium", atomicNumber: 116 }, { symbol: "Ts", name: "Tennessine", atomicNumber: 117 }, { symbol: "Og", name: "Oganesson", atomicNumber: 118 }];
var Ra = [{ name: "meter", symbol: "m" }, { name: "second", symbol: "s" }, { name: "mole", symbol: "mol" }, { name: "ampere", symbol: "A" }, { name: "kelvin", symbol: "K" }, { name: "candela", symbol: "cd" }, { name: "kilogram", symbol: "kg" }, { name: "radian", symbol: "rad" }, { name: "hertz", symbol: "Hz" }, { name: "newton", symbol: "N" }, { name: "pascal", symbol: "Pa" }, { name: "joule", symbol: "J" }, { name: "watt", symbol: "W" }, { name: "coulomb", symbol: "C" }, { name: "volt", symbol: "V" }, { name: "ohm", symbol: "\u03A9" }, { name: "tesla", symbol: "T" }, { name: "degree Celsius", symbol: "\xB0C" }, { name: "lumen", symbol: "lm" }, { name: "becquerel", symbol: "Bq" }, { name: "gray", symbol: "Gy" }, { name: "sievert", symbol: "Sv" }, { name: "steradian", symbol: "sr" }, { name: "farad", symbol: "F" }, { name: "siemens", symbol: "S" }, { name: "weber", symbol: "Wb" }, { name: "henry", symbol: "H" }, { name: "lux", symbol: "lx" }, { name: "katal", symbol: "kat" }];
var br = { chemical_element: Da, unit: Ra };
var Pa = br;
var Ha = ["ants", "bats", "bears", "bees", "birds", "buffalo", "cats", "chickens", "cattle", "dogs", "dolphins", "ducks", "elephants", "fishes", "foxes", "frogs", "geese", "goats", "horses", "kangaroos", "lions", "monkeys", "owls", "oxen", "penguins", "people", "pigs", "rabbits", "sheep", "tigers", "whales", "wolves", "zebras", "banshees", "crows", "black cats", "chimeras", "ghosts", "conspirators", "dragons", "dwarves", "elves", "enchanters", "exorcists", "sons", "foes", "giants", "gnomes", "goblins", "gooses", "griffins", "lycanthropes", "nemesis", "ogres", "oracles", "prophets", "sorcerors", "spiders", "spirits", "vampires", "warlocks", "vixens", "werewolves", "witches", "worshipers", "zombies", "druids"];
var Wa = ["{{location.state}} {{team.creature}}"];
var Cr = { creature: Ha, name: Wa };
var Ga = Cr;
var Fa = ["Adventure Road Bicycle", "BMX Bicycle", "City Bicycle", "Cruiser Bicycle", "Cyclocross Bicycle", "Dual-Sport Bicycle", "Fitness Bicycle", "Flat-Foot Comfort Bicycle", "Folding Bicycle", "Hybrid Bicycle", "Mountain Bicycle", "Recumbent Bicycle", "Road Bicycle", "Tandem Bicycle", "Touring Bicycle", "Track/Fixed-Gear Bicycle", "Triathlon/Time Trial Bicycle", "Tricycle"];
var Na = ["Diesel", "Electric", "Gasoline", "Hybrid"];
var Ea = ["Aston Martin", "Audi", "BMW", "BYD", "Bentley", "Bugatti", "Cadillac", "Chevrolet", "Chrysler", "Citro\xEBn", "Dodge", "Ferrari", "Fiat", "Ford", "Honda", "Hyundai", "Jaguar", "Jeep", "Kia", "Lamborghini", "Land Rover", "MG", "Mahindra & Mahindra", "Maruti", "Maserati", "Mazda", "Mercedes Benz", "Mini", "Mitsubishi", "NIO", "Nissan", "Peugeot", "Polestar", "Porsche", "Renault", "Rivian", "Rolls Royce", "Skoda", "Smart", "Subaru", "Suzuki", "Tata", "Tesla", "Toyota", "Vauxhall", "Volkswagen", "Volvo"];
var Ja = ["1", "2", "911", "A4", "A8", "ATS", "Accord", "Alpine", "Altima", "Aventador", "Beetle", "CTS", "CX-9", "Camaro", "Camry", "Challenger", "Charger", "Civic", "Colorado", "Corvette", "Countach", "Cruze", "Durango", "El Camino", "Element", "Escalade", "Expedition", "Explorer", "F-150", "Fiesta", "Focus", "Fortwo", "Golf", "Grand Caravan", "Grand Cherokee", "Impala", "Jetta", "Land Cruiser", "LeBaron", "Malibu", "Mercielago", "Model 3", "Model S", "Model T", "Model X", "Model Y", "Mustang", "PT Cruiser", "Prius", "Ranchero", "Roadster", "Sentra", "Silverado", "Spyder", "Taurus", "V90", "Volt", "Wrangler", "XC90", "XTS"];
var Ia = ["Cargo Van", "Convertible", "Coupe", "Crew Cab Pickup", "Extended Cab Pickup", "Hatchback", "Minivan", "Passenger Van", "SUV", "Sedan", "Wagon"];
var Sr = { bicycle_type: Fa, fuel: Na, manufacturer: Ea, model: Ja, type: Ia };
var Ka = Sr;
var Oa = ["abandoned", "able", "acceptable", "acclaimed", "accomplished", "accurate", "aching", "acidic", "actual", "admired", "adolescent", "advanced", "affectionate", "afraid", "aged", "aggravating", "aggressive", "agile", "agitated", "agreeable", "ajar", "alarmed", "alert", "alienated", "alive", "all", "altruistic", "amazing", "ambitious", "ample", "amused", "angelic", "anguished", "animated", "annual", "another", "antique", "any", "apprehensive", "appropriate", "apt", "arid", "artistic", "ashamed", "assured", "astonishing", "athletic", "austere", "authentic", "authorized", "avaricious", "average", "aware", "awesome", "awful", "babyish", "back", "bad", "baggy", "bare", "basic", "beloved", "beneficial", "best", "better", "big", "biodegradable", "bitter", "black", "black-and-white", "blank", "blaring", "bleak", "blind", "blond", "blue", "blushing", "bogus", "boiling", "bony", "boring", "bossy", "both", "bouncy", "bowed", "brave", "breakable", "bright", "brilliant", "brisk", "broken", "brown", "bruised", "bulky", "burdensome", "burly", "bustling", "busy", "buttery", "buzzing", "calculating", "candid", "carefree", "careless", "caring", "cautious", "cavernous", "celebrated", "charming", "cheap", "cheerful", "chilly", "chubby", "circular", "classic", "clean", "clear", "clear-cut", "close", "closed", "cloudy", "clueless", "clumsy", "cluttered", "coarse", "colorful", "colorless", "colossal", "comfortable", "common", "compassionate", "competent", "complete", "complicated", "concerned", "concrete", "confused", "considerate", "content", "cool", "cooperative", "coordinated", "corny", "corrupt", "courageous", "courteous", "crafty", "crazy", "creamy", "creative", "criminal", "critical", "crooked", "crowded", "cruel", "crushing", "cuddly", "cultivated", "cumbersome", "curly", "cute", "damaged", "damp", "dapper", "dark", "darling", "dazzling", "dead", "deadly", "deafening", "dearest", "decent", "decisive", "deep", "defenseless", "defensive", "deficient", "definite", "definitive", "delectable", "delicious", "delirious", "dense", "dental", "dependable", "dependent", "descriptive", "deserted", "determined", "devoted", "different", "difficult", "digital", "diligent", "dim", "direct", "dirty", "discrete", "disloyal", "dismal", "distant", "distinct", "distorted", "doting", "downright", "drab", "dramatic", "dreary", "dual", "dull", "dutiful", "each", "early", "earnest", "easy", "ecstatic", "edible", "educated", "elastic", "elderly", "electric", "elegant", "elementary", "elliptical", "eminent", "emotional", "empty", "enchanted", "enchanting", "energetic", "enlightened", "enraged", "entire", "equatorial", "essential", "esteemed", "ethical", "everlasting", "every", "evil", "exalted", "excellent", "excitable", "excited", "exhausted", "exotic", "expensive", "experienced", "expert", "extra-large", "extroverted", "failing", "faint", "fair", "fake", "familiar", "fantastic", "far", "far-flung", "far-off", "faraway", "fat", "fatal", "fatherly", "favorable", "favorite", "fearless", "feline", "filthy", "fine", "finished", "firm", "first", "firsthand", "fixed", "flashy", "flawed", "flawless", "flickering", "flimsy", "flowery", "fluffy", "flustered", "focused", "fond", "foolhardy", "foolish", "forceful", "formal", "forsaken", "fortunate", "fragrant", "frail", "frank", "free", "french", "frequent", "friendly", "frightened", "frilly", "frivolous", "frizzy", "front", "frozen", "frugal", "fruitful", "functional", "funny", "fussy", "fuzzy", "gaseous", "general", "gentle", "genuine", "gifted", "gigantic", "giving", "glaring", "glass", "gleaming", "glittering", "gloomy", "glorious", "glossy", "glum", "golden", "good", "good-natured", "gorgeous", "graceful", "gracious", "grandiose", "granular", "grave", "gray", "great", "greedy", "grim", "grimy", "gripping", "grizzled", "grouchy", "grounded", "growing", "grown", "grubby", "gruesome", "grumpy", "guilty", "gullible", "gummy", "hairy", "handsome", "handy", "happy", "happy-go-lucky", "hard-to-find", "harmful", "hasty", "hateful", "haunting", "heartfelt", "heavenly", "heavy", "hefty", "helpful", "helpless", "hidden", "hoarse", "hollow", "homely", "honorable", "honored", "hopeful", "hospitable", "hot", "huge", "humble", "humiliating", "hungry", "hurtful", "husky", "icy", "ideal", "idealistic", "idolized", "ignorant", "ill", "ill-fated", "illiterate", "illustrious", "imaginary", "imaginative", "immaculate", "immediate", "immense", "impartial", "impassioned", "impeccable", "impish", "impolite", "important", "impossible", "impractical", "impressionable", "impressive", "improbable", "impure", "inborn", "incomparable", "incomplete", "inconsequential", "indelible", "indolent", "inexperienced", "infamous", "infatuated", "inferior", "infinite", "informal", "innocent", "insecure", "insidious", "insignificant", "insistent", "instructive", "intelligent", "intent", "interesting", "internal", "international", "intrepid", "ironclad", "irresponsible", "jagged", "jam-packed", "jaunty", "jealous", "jittery", "joyful", "joyous", "jubilant", "judicious", "juicy", "jumbo", "junior", "juvenile", "kaleidoscopic", "key", "knotty", "knowledgeable", "known", "kooky", "kosher", "lanky", "last", "lasting", "late", "lavish", "lawful", "lazy", "leading", "lean", "left", "legal", "light", "lighthearted", "likable", "likely", "limited", "limp", "limping", "linear", "lined", "liquid", "little", "live", "lively", "livid", "lone", "lonely", "long", "long-term", "lost", "lovable", "lovely", "low", "lucky", "lumbering", "lumpy", "lustrous", "mad", "made-up", "magnificent", "majestic", "major", "male", "mammoth", "married", "marvelous", "massive", "mature", "meager", "mealy", "mean", "measly", "meaty", "mediocre", "medium", "memorable", "menacing", "merry", "messy", "metallic", "mild", "milky", "mindless", "minor", "minty", "miserable", "miserly", "misguided", "mixed", "moist", "monstrous", "monthly", "monumental", "moral", "motionless", "muddy", "muffled", "multicolored", "mundane", "murky", "mushy", "musty", "muted", "mysterious", "narrow", "natural", "naughty", "nautical", "near", "neat", "necessary", "needy", "negative", "neglected", "negligible", "neighboring", "nervous", "new", "next", "nice", "nifty", "nimble", "nippy", "nocturnal", "normal", "noted", "noteworthy", "noxious", "numb", "nutritious", "obedient", "oblong", "obvious", "odd", "oddball", "official", "oily", "old", "old-fashioned", "only", "optimal", "optimistic", "orange", "orderly", "ordinary", "ornate", "ornery", "other", "our", "outgoing", "outlandish", "outlying", "outrageous", "outstanding", "oval", "overcooked", "overdue", "palatable", "pale", "paltry", "parallel", "parched", "partial", "passionate", "pastel", "peaceful", "peppery", "perfumed", "perky", "personal", "pertinent", "pessimistic", "petty", "phony", "physical", "pink", "pitiful", "plain", "pleasant", "pleased", "pleasing", "plump", "pointed", "pointless", "polished", "polite", "political", "poor", "portly", "posh", "possible", "potable", "powerful", "powerless", "practical", "precious", "present", "prestigious", "pretty", "pricey", "prickly", "primary", "prime", "private", "probable", "productive", "profitable", "profuse", "proper", "proud", "prudent", "punctual", "puny", "pure", "purple", "pushy", "putrid", "puzzled", "qualified", "quarrelsome", "quarterly", "queasy", "querulous", "questionable", "quick", "quick-witted", "quiet", "quintessential", "quixotic", "radiant", "ragged", "rapid", "rare", "raw", "realistic", "reasonable", "recent", "reckless", "rectangular", "red", "reflecting", "regal", "regular", "remarkable", "remorseful", "repentant", "respectful", "responsible", "rewarding", "rich", "right", "rigid", "ripe", "roasted", "robust", "rosy", "rotating", "rotten", "rough", "round", "rowdy", "royal", "rubbery", "ruddy", "rundown", "runny", "rural", "rusty", "sad", "salty", "same", "sandy", "sarcastic", "sardonic", "scaly", "scared", "scary", "scented", "scientific", "scornful", "scratchy", "second", "second-hand", "secondary", "secret", "self-assured", "self-reliant", "selfish", "sentimental", "separate", "serene", "serpentine", "severe", "shabby", "shadowy", "shady", "shallow", "shameful", "shameless", "shimmering", "shiny", "shocked", "shoddy", "short", "short-term", "showy", "shrill", "shy", "sick", "silent", "silky", "silver", "similar", "simple", "simplistic", "sinful", "sizzling", "skeletal", "sleepy", "slight", "slimy", "slow", "slushy", "small", "smart", "smoggy", "smooth", "smug", "snappy", "snarling", "sneaky", "sniveling", "snoopy", "sociable", "soft", "soggy", "somber", "some", "sophisticated", "sore", "sorrowful", "soulful", "soupy", "sour", "spanish", "sparkling", "sparse", "specific", "speedy", "spherical", "spiffy", "spirited", "spiteful", "splendid", "spotless", "square", "squeaky", "squiggly", "stable", "staid", "stained", "stale", "standard", "stark", "steel", "steep", "sticky", "stiff", "stingy", "stormy", "straight", "strange", "strict", "strident", "striking", "strong", "stunning", "stupendous", "sturdy", "stylish", "subdued", "submissive", "substantial", "subtle", "suburban", "sudden", "sugary", "sunny", "super", "superb", "superficial", "superior", "supportive", "sure-footed", "surprised", "svelte", "sweet", "swift", "talkative", "tall", "tame", "tangible", "tasty", "tattered", "taut", "tedious", "teeming", "tempting", "tender", "tense", "tepid", "terrible", "that", "these", "thick", "thin", "thorny", "thorough", "those", "thrifty", "tidy", "tight", "timely", "tinted", "tiny", "tired", "torn", "total", "tough", "tragic", "trained", "triangular", "tricky", "trim", "trivial", "troubled", "true", "trusting", "trustworthy", "trusty", "turbulent", "twin", "ugly", "ultimate", "unaware", "uncomfortable", "uncommon", "unconscious", "understated", "uneven", "unfinished", "unfit", "unfortunate", "unhappy", "unhealthy", "uniform", "unimportant", "unique", "unkempt", "unknown", "unlawful", "unlined", "unlucky", "unpleasant", "unrealistic", "unripe", "unruly", "unselfish", "unsightly", "unsteady", "unsung", "untidy", "untimely", "untried", "untrue", "unused", "unusual", "unwelcome", "unwieldy", "unwilling", "unwritten", "upbeat", "upright", "upset", "urban", "usable", "useless", "utilized", "utter", "vague", "vain", "valuable", "variable", "vast", "velvety", "vengeful", "vibrant", "victorious", "violent", "vivacious", "vivid", "voluminous", "warlike", "warm", "warmhearted", "warped", "wasteful", "waterlogged", "watery", "wavy", "wealthy", "weary", "webbed", "wee", "weekly", "weighty", "weird", "well-documented", "well-groomed", "well-lit", "well-made", "well-off", "well-to-do", "well-worn", "which", "whimsical", "whirlwind", "whispered", "white", "whole", "whopping", "wicked", "wide", "wide-eyed", "wiggly", "willing", "wilted", "winding", "windy", "winged", "wise", "witty", "wobbly", "woeful", "wonderful", "wordy", "worldly", "worse", "worst", "worthless", "worthwhile", "worthy", "wrathful", "wretched", "writhing", "wrong", "wry", "yearly", "yellow", "yellowish", "young", "youthful", "yummy", "zany", "zealous", "zesty"];
var xa = ["abnormally", "absentmindedly", "accidentally", "acidly", "actually", "adventurously", "afterwards", "almost", "always", "angrily", "annually", "anxiously", "arrogantly", "awkwardly", "badly", "bashfully", "beautifully", "bitterly", "bleakly", "blindly", "blissfully", "boastfully", "boldly", "bravely", "briefly", "brightly", "briskly", "broadly", "busily", "calmly", "carefully", "carelessly", "cautiously", "certainly", "cheerfully", "clearly", "cleverly", "closely", "coaxingly", "colorfully", "commonly", "continually", "coolly", "correctly", "courageously", "crossly", "cruelly", "curiously", "daily", "daintily", "dearly", "deceivingly", "deeply", "defiantly", "deliberately", "delightfully", "diligently", "dimly", "doubtfully", "dreamily", "easily", "elegantly", "energetically", "enormously", "enthusiastically", "equally", "especially", "even", "evenly", "eventually", "exactly", "excitedly", "extremely", "fairly", "faithfully", "famously", "far", "fast", "fatally", "ferociously", "fervently", "fiercely", "fondly", "foolishly", "fortunately", "frankly", "frantically", "freely", "frenetically", "frightfully", "fully", "furiously", "generally", "generously", "gently", "gladly", "gleefully", "gracefully", "gratefully", "greatly", "greedily", "happily", "hastily", "healthily", "heavily", "helpfully", "helplessly", "highly", "honestly", "hopelessly", "hourly", "hungrily", "immediately", "innocently", "inquisitively", "instantly", "intensely", "intently", "interestingly", "inwardly", "irritably", "jaggedly", "jealously", "joshingly", "jovially", "joyfully", "joyously", "jubilantly", "judgementally", "justly", "keenly", "kiddingly", "kindheartedly", "kindly", "kissingly", "knavishly", "knottily", "knowingly", "knowledgeably", "kookily", "lazily", "less", "lightly", "likely", "limply", "lively", "loftily", "longingly", "loosely", "loudly", "lovingly", "loyally", "madly", "majestically", "meaningfully", "mechanically", "merrily", "miserably", "mockingly", "monthly", "more", "mortally", "mostly", "mysteriously", "naturally", "nearly", "neatly", "needily", "nervously", "never", "nicely", "noisily", "not", "obediently", "obnoxiously", "oddly", "offensively", "officially", "often", "only", "openly", "optimistically", "overconfidently", "owlishly", "painfully", "partially", "patiently", "perfectly", "physically", "playfully", "politely", "poorly", "positively", "potentially", "powerfully", "promptly", "properly", "punctually", "quaintly", "quarrelsomely", "queasily", "questionably", "questioningly", "quicker", "quickly", "quietly", "quirkily", "quizzically", "rapidly", "rarely", "readily", "really", "reassuringly", "recklessly", "regularly", "reluctantly", "repeatedly", "reproachfully", "restfully", "righteously", "rightfully", "rigidly", "roughly", "rudely", "sadly", "safely", "scarcely", "scarily", "searchingly", "sedately", "seemingly", "seldom", "selfishly", "separately", "seriously", "shakily", "sharply", "sheepishly", "shrilly", "shyly", "silently", "sleepily", "slowly", "smoothly", "softly", "solemnly", "solidly", "sometimes", "soon", "speedily", "stealthily", "sternly", "strictly", "successfully", "suddenly", "surprisingly", "suspiciously", "sweetly", "swiftly", "sympathetically", "tenderly", "tensely", "terribly", "thankfully", "thoroughly", "thoughtfully", "tightly", "tomorrow", "too", "tremendously", "triumphantly", "truly", "truthfully", "ultimately", "unabashedly", "unaccountably", "unbearably", "unethically", "unexpectedly", "unfortunately", "unimpressively", "unnaturally", "unnecessarily", "upbeat", "upliftingly", "upright", "upside-down", "upward", "upwardly", "urgently", "usefully", "uselessly", "usually", "utterly", "vacantly", "vaguely", "vainly", "valiantly", "vastly", "verbally", "very", "viciously", "victoriously", "violently", "vivaciously", "voluntarily", "warmly", "weakly", "wearily", "well", "wetly", "wholly", "wildly", "willfully", "wisely", "woefully", "wonderfully", "worriedly", "wrongly", "yawningly", "yearly", "yearningly", "yesterday", "yieldingly", "youthfully"];
var za = ["after", "although", "and", "as", "because", "before", "but", "consequently", "even", "finally", "for", "furthermore", "hence", "how", "however", "if", "inasmuch", "incidentally", "indeed", "instead", "lest", "likewise", "meanwhile", "nor", "now", "once", "or", "provided", "since", "so", "supposing", "than", "that", "though", "till", "unless", "until", "what", "when", "whenever", "where", "whereas", "wherever", "whether", "which", "while", "who", "whoever", "whose", "why", "yet"];
var Va = ["yuck", "oh", "phooey", "blah", "boo", "whoa", "yowza", "huzzah", "boohoo", "fooey", "geez", "pfft", "ew", "ah", "yum", "brr", "hm", "yahoo", "aha", "woot", "drat", "gah", "meh", "psst", "aw", "ugh", "yippee", "eek", "gee", "bah", "gadzooks", "duh", "ha", "mmm", "ouch", "phew", "ack", "uh-huh", "gosh", "hmph", "pish", "zowie", "er", "ick", "oof", "um"];
var Ya = ["CD", "SUV", "abacus", "academics", "accelerator", "accompanist", "account", "accountability", "acquaintance", "ad", "adaptation", "address", "adrenalin", "adult", "advancement", "advertisement", "adviser", "affect", "affiliate", "aftermath", "agreement", "airbus", "aircraft", "airline", "airmail", "airman", "airport", "alb", "alert", "allegation", "alliance", "alligator", "allocation", "almighty", "amendment", "amnesty", "analogy", "angle", "annual", "antelope", "anticodon", "apparatus", "appliance", "approach", "apricot", "arcade", "archaeology", "armchair", "armoire", "asset", "assist", "atrium", "attraction", "availability", "avalanche", "awareness", "babushka", "backbone", "backburn", "bakeware", "bandwidth", "bar", "barge", "baritone", "barracks", "baseboard", "basket", "bathhouse", "bathrobe", "battle", "begonia", "behest", "bell", "bench", "bend", "beret", "best-seller", "bid", "bidet", "bin", "birdbath", "birdcage", "birth", "blight", "blossom", "blowgun", "bob", "bog", "bonfire", "bonnet", "bookcase", "bookend", "boulevard", "bourgeoisie", "bowler", "bowling", "boyfriend", "brace", "bracelet", "bran", "breastplate", "brief", "brochure", "brook", "brush", "bug", "bump", "bungalow", "cafe", "cake", "calculus", "cannon", "cantaloupe", "cap", "cappelletti", "captain", "caption", "carboxyl", "cardboard", "carnival", "case", "casement", "cash", "casket", "cassava", "castanet", "catalyst", "cauliflower", "cellar", "celsius", "cemetery", "ceramic", "ceramics", "certification", "chainstay", "chairperson", "challenge", "championship", "chap", "chapel", "character", "characterization", "charlatan", "charm", "chasuble", "cheese", "cheetah", "chiffonier", "chops", "chow", "cinder", "cinema", "circumference", "citizen", "clamp", "clavicle", "cleaner", "climb", "co-producer", "coal", "coast", "cod", "coil", "coin", "coliseum", "collaboration", "collectivization", "colon", "colonialism", "comestible", "commercial", "commodity", "community", "comparison", "completion", "complication", "compromise", "concentration", "configuration", "confusion", "conservation", "conservative", "consistency", "contractor", "contrail", "convection", "conversation", "cook", "coordination", "cop-out", "cope", "cork", "cornet", "corporation", "corral", "cosset", "costume", "couch", "council", "councilman", "countess", "courtroom", "cow", "creator", "creature", "crest", "cricket", "crocodile", "cross-contamination", "cruelty", "cuckoo", "curl", "custody", "custom", "cutlet", "cutover", "cycle", "daddy", "dandelion", "dash", "daughter", "dead", "decision", "deck", "declaration", "decongestant", "decryption", "deduction", "deed", "deer", "defendant", "density", "department", "dependency", "deployment", "depot", "derby", "descendant", "descent", "design", "designation", "desk", "detective", "devastation", "developing", "developmental", "devil", "diagram", "digestive", "digit", "dime", "director", "disadvantage", "disappointment", "disclosure", "disconnection", "discourse", "dish", "disk", "disposer", "distinction", "diver", "diversity", "dividend", "divine", "doing", "doorpost", "doubter", "draft", "draw", "dream", "dredger", "dress", "drive", "drug", "duffel", "dulcimer", "dusk", "duster", "dwell", "e-mail", "earth", "ecliptic", "ectoderm", "edge", "editor", "effector", "eggplant", "electronics", "elevation", "elevator", "elver", "embarrassment", "embossing", "emergent", "encouragement", "entry", "epic", "equal", "essence", "eternity", "ethyl", "euphonium", "event", "exasperation", "excess", "executor", "exhaust", "expansion", "expense", "experience", "exploration", "extension", "extent", "exterior", "eyebrow", "eyeliner", "farm", "farmer", "fat", "fax", "feather", "fedora", "fellow", "fen", "fencing", "ferret", "festival", "fibre", "filter", "final", "finding", "finer", "finger", "fireplace", "fisherman", "fishery", "fit", "flame", "flat", "fledgling", "flight", "flint", "flood", "flu", "fog", "fold", "folklore", "follower", "following", "foodstuffs", "footrest", "forage", "forager", "forgery", "fork", "formamide", "formation", "formula", "fort", "fowl", "fraudster", "freckle", "freezing", "freight", "fuel", "fun", "fund", "fundraising", "futon", "gallery", "galoshes", "gastropod", "gazebo", "gerbil", "ghost", "giant", "gift", "giggle", "glider", "gloom", "goat", "godfather", "godparent", "going", "goodwill", "governance", "government", "gown", "gradient", "graffiti", "grandpa", "grandson", "granny", "grass", "gray", "gripper", "grouper", "guacamole", "guard", "guidance", "guide", "gym", "gymnast", "habit", "haircut", "halt", "hamburger", "hammock", "handful", "handle", "handover", "harp", "haversack", "hawk", "heartache", "heartbeat", "heating", "hello", "help", "hepatitis", "heroine", "hexagon", "hierarchy", "hippodrome", "honesty", "hoof", "hope", "horde", "hornet", "horst", "hose", "hospitalization", "hovel", "hovercraft", "hubris", "humidity", "humor", "hundred", "hunger", "hunt", "husband", "hutch", "hydrant", "hydrocarbon", "hydrolyse", "hydrolyze", "hyena", "hygienic", "hyphenation", "ice-cream", "icebreaker", "igloo", "ignorance", "illusion", "impact", "import", "importance", "impostor", "in-joke", "incandescence", "independence", "individual", "information", "injunction", "innovation", "insolence", "inspection", "instance", "institute", "instruction", "instructor", "integer", "intellect", "intent", "interchange", "interior", "intervention", "interviewer", "invite", "iridescence", "issue", "jacket", "jazz", "jellyfish", "jet", "jogging", "joy", "juggernaut", "jump", "jungle", "junior", "jury", "kettledrum", "kick", "kielbasa", "kinase", "king", "kiss", "kit", "knickers", "knight", "knitting", "knuckle", "label", "labourer", "lace", "lady", "lamp", "language", "larva", "lashes", "laughter", "lava", "lawmaker", "lay", "leading", "league", "legend", "legging", "legislature", "lender", "license", "lid", "lieu", "lifestyle", "lift", "linseed", "litter", "loaf", "lobster", "longboat", "lotion", "lounge", "louse", "lox", "loyalty", "luck", "lyre", "maestro", "mainstream", "maintainer", "majority", "makeover", "making", "mallard", "management", "manner", "mantua", "marathon", "march", "marimba", "marketplace", "marksman", "markup", "marten", "massage", "masterpiece", "mathematics", "meadow", "meal", "meander", "meatloaf", "mechanic", "median", "membership", "mentor", "merit", "metabolite", "metal", "middle", "midwife", "milestone", "millet", "minion", "minister", "minor", "minority", "mixture", "mobility", "molasses", "mom", "moment", "monasticism", "monocle", "monster", "morbidity", "morning", "mortise", "mountain", "mouser", "mousse", "mozzarella", "muscat", "mythology", "napkin", "necklace", "nectarine", "negotiation", "nephew", "nerve", "netsuke", "newsletter", "newsprint", "newsstand", "nightlife", "noon", "nougat", "nucleotidase", "nudge", "numeracy", "numeric", "nun", "obedience", "obesity", "object", "obligation", "ocelot", "octave", "offset", "oil", "omelet", "onset", "opera", "operating", "optimal", "orchid", "order", "ostrich", "other", "outlaw", "outrun", "outset", "overcoat", "overheard", "overload", "ownership", "pacemaker", "packaging", "paintwork", "palate", "pants", "pantyhose", "papa", "parade", "parsnip", "partridge", "passport", "pasta", "patroller", "pear", "pearl", "pecan", "pendant", "peninsula", "pension", "peony", "pepper", "perfection", "permafrost", "perp", "petal", "petticoat", "pharmacopoeia", "phrase", "pick", "piglet", "pigpen", "pigsty", "pile", "pillbox", "pillow", "pilot", "pine", "pinstripe", "place", "plain", "planula", "plastic", "platter", "platypus", "pleasure", "pliers", "plugin", "plumber", "pneumonia", "pocket-watch", "poetry", "polarisation", "polyester", "pomelo", "pop", "poppy", "popularity", "populist", "porter", "possession", "postbox", "precedent", "premeditation", "premier", "premise", "premium", "pressure", "presume", "priesthood", "printer", "privilege", "procurement", "produce", "programme", "prohibition", "promise", "pronoun", "providence", "provider", "provision", "publication", "publicity", "pulse", "punctuation", "pupil", "puppet", "puritan", "quart", "quinoa", "quit", "railway", "range", "rationale", "ravioli", "rawhide", "reach", "reasoning", "reboot", "receptor", "recommendation", "reconsideration", "recovery", "redesign", "relative", "release", "remark", "reorganisation", "repeat", "replacement", "reporter", "representation", "republican", "request", "requirement", "reservation", "resolve", "resource", "responsibility", "restaurant", "retention", "retrospectivity", "reward", "ribbon", "rim", "riser", "roadway", "role", "rosemary", "roundabout", "rubric", "ruin", "rule", "runway", "rust", "safe", "sailor", "saloon", "sand", "sandbar", "sanity", "sarong", "sauerkraut", "saw", "scaffold", "scale", "scarification", "scenario", "schedule", "schnitzel", "scholarship", "scorn", "scorpion", "scout", "scrap", "scratch", "seafood", "seagull", "seal", "season", "secrecy", "secret", "section", "sediment", "self-confidence", "sermon", "sesame", "settler", "shadowbox", "shark", "shipper", "shore", "shoulder", "sideboard", "siege", "sightseeing", "signature", "silk", "simple", "singing", "skean", "skeleton", "skyline", "skyscraper", "slide", "slime", "slipper", "smog", "smoke", "sock", "soliloquy", "solution", "solvency", "someplace", "sonar", "sonata", "sonnet", "soup", "soybean", "space", "spear", "spirit", "spork", "sport", "spring", "sprinkles", "squid", "stall", "starboard", "statue", "status", "stay", "steak", "steeple", "step", "step-mother", "sticker", "stir-fry", "stitcher", "stock", "stool", "story", "strait", "stranger", "strategy", "straw", "stump", "subexpression", "submitter", "subsidy", "substitution", "suitcase", "summary", "summer", "sunbeam", "sundae", "supplier", "surface", "sushi", "suspension", "sustenance", "swanling", "swath", "sweatshop", "swim", "swine", "swing", "switch", "switchboard", "swordfish", "synergy", "t-shirt", "tabletop", "tackle", "tail", "tapioca", "taro", "tarragon", "taxicab", "teammate", "technician", "technologist", "tectonics", "tenant", "tenement", "tennis", "tentacle", "teriyaki", "term", "testimonial", "testing", "thigh", "thongs", "thorn", "thread", "thunderbolt", "thyme", "tinderbox", "toaster", "tomatillo", "tomb", "tomography", "tool", "tooth", "toothbrush", "toothpick", "topsail", "traditionalism", "traffic", "translation", "transom", "transparency", "trash", "travel", "tray", "trench", "tribe", "tributary", "trick", "trolley", "tuba", "tuber", "tune-up", "turret", "tusk", "tuxedo", "typeface", "typewriter", "unblinking", "underneath", "underpants", "understanding", "unibody", "unique", "unit", "utilization", "valentine", "validity", "valley", "valuable", "vanadyl", "vein", "velocity", "venom", "version", "verve", "vestment", "veto", "viability", "vibraphone", "vibration", "vicinity", "video", "violin", "vision", "vista", "vol", "volleyball", "wafer", "waist", "wallaby", "warming", "wasabi", "waterspout", "wear", "wedding", "whack", "whale", "wheel", "widow", "wilderness", "willow", "window", "wombat", "word", "worth", "wriggler", "yak", "yarmulke", "yeast", "yin", "yogurt", "zebra", "zen"];
var ja = ["a", "abaft", "aboard", "about", "above", "absent", "across", "afore", "after", "against", "along", "alongside", "amid", "amidst", "among", "amongst", "an", "anenst", "anti", "apropos", "apud", "around", "as", "aside", "astride", "at", "athwart", "atop", "barring", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "but", "by", "circa", "concerning", "considering", "despite", "down", "during", "except", "excepting", "excluding", "failing", "following", "for", "forenenst", "from", "given", "in", "including", "inside", "into", "lest", "like", "mid", "midst", "minus", "modulo", "near", "next", "notwithstanding", "of", "off", "on", "onto", "opposite", "out", "outside", "over", "pace", "past", "per", "plus", "pro", "qua", "regarding", "round", "sans", "save", "since", "than", "the", "through", "throughout", "till", "times", "to", "toward", "towards", "under", "underneath", "unlike", "until", "unto", "up", "upon", "versus", "via", "vice", "with", "within", "without", "worth"];
var qa = ["abnegate", "abscond", "abseil", "absolve", "accentuate", "accept", "access", "accessorise", "accompany", "account", "accredit", "achieve", "acknowledge", "acquire", "adjourn", "adjudge", "admonish", "adumbrate", "advocate", "afford", "airbrush", "ameliorate", "amend", "amount", "anaesthetise", "analyse", "anesthetize", "anneal", "annex", "antagonize", "ape", "apologise", "apostrophize", "appertain", "appreciate", "appropriate", "approximate", "arbitrate", "archive", "arraign", "arrange", "ascertain", "ascribe", "assail", "atomize", "attend", "attest", "attribute", "augment", "avow", "axe", "baa", "banish", "bank", "baptise", "battle", "beard", "beep", "behold", "belabor", "bemuse", "besmirch", "bestride", "better", "bewail", "bicycle", "bide", "bind", "biodegrade", "blacken", "blaspheme", "bleach", "blend", "blink", "bliss", "bloom", "bludgeon", "bobble", "boggle", "bolster", "book", "boom", "bootleg", "border", "bore", "boss", "braid", "brand", "brandish", "break", "breed", "broadcast", "broadside", "brood", "browse", "buck", "burgeon", "bus", "butter", "buzzing", "camouflage", "cannibalise", "canter", "cap", "capitalise", "capitalize", "capsize", "card", "carouse", "carp", "carpool", "catalog", "catalyze", "catch", "categorise", "cease", "celebrate", "censor", "certify", "char", "charter", "chase", "chatter", "chime", "chip", "christen", "chromakey", "chunder", "chunter", "cinch", "circle", "circulate", "circumnavigate", "clamor", "clamour", "claw", "cleave", "clinch", "clinking", "clone", "clonk", "coagulate", "coexist", "coincide", "collaborate", "colligate", "colorize", "colour", "comb", "come", "commandeer", "commemorate", "communicate", "compete", "conceal", "conceptualize", "conclude", "concrete", "condense", "cone", "confide", "confirm", "confiscate", "confound", "confute", "congregate", "conjecture", "connect", "consign", "construe", "contradict", "contrast", "contravene", "controvert", "convalesce", "converse", "convince", "convoke", "coop", "cop", "corner", "covenant", "cow", "crackle", "cram", "crank", "creak", "creaking", "cripple", "croon", "cross", "crumble", "crystallize", "culminate", "culture", "curry", "curse", "customise", "cycle", "dally", "dampen", "darn", "debit", "debut", "decide", "decode", "decouple", "decriminalize", "deduce", "deduct", "deflate", "deflect", "deform", "defrag", "degenerate", "degrease", "delete", "delight", "deliquesce", "demob", "demobilise", "democratize", "demonstrate", "denitrify", "deny", "depart", "depend", "deplore", "deploy", "deprave", "depute", "dereference", "describe", "desecrate", "deselect", "destock", "detain", "develop", "devise", "dial", "dicker", "digitize", "dilate", "disapprove", "disarm", "disbar", "discontinue", "disgorge", "dishearten", "dishonor", "disinherit", "dislocate", "dispense", "display", "dispose", "disrespect", "dissemble", "ditch", "divert", "dock", "doodle", "downchange", "downshift", "dowse", "draft", "drag", "drain", "dramatize", "drowse", "drum", "dwell", "economise", "edge", "efface", "egg", "eke", "electrify", "embalm", "embed", "embody", "emboss", "emerge", "emphasise", "emphasize", "emulsify", "encode", "endow", "enfold", "engage", "engender", "enhance", "enlist", "enrage", "enrich", "enroll", "entice", "entomb", "entrench", "entwine", "equate", "essay", "etch", "eulogise", "even", "evince", "exacerbate", "exaggerate", "exalt", "exempt", "exonerate", "expatiate", "explode", "expostulate", "extract", "extricate", "eyeglasses", "fabricate", "facilitate", "factorise", "factorize", "fail", "fall", "familiarize", "fashion", "father", "fathom", "fax", "federate", "feminize", "fence", "fess", "fictionalize", "fiddle", "fidget", "fill", "flash", "fleck", "flight", "floodlight", "floss", "fluctuate", "fluff", "fly", "focalise", "foot", "forearm", "forecast", "foretell", "forgather", "forgo", "fork", "form", "forswear", "founder", "fraternise", "fray", "frizz", "fumigate", "function", "furlough", "fuss", "gad", "gallivant", "galvanize", "gape", "garage", "garrote", "gasp", "gestate", "give", "glimmer", "glisten", "gloat", "gloss", "glow", "gnash", "gnaw", "goose", "govern", "grade", "graduate", "graft", "grok", "guest", "guilt", "gulp", "gum", "gurn", "gust", "gut", "guzzle", "ham", "harangue", "harvest", "hassle", "haul", "haze", "headline", "hearten", "heighten", "highlight", "hoick", "hold", "hole", "hollow", "holster", "home", "homeschool", "hoot", "horn", "horse", "hotfoot", "house", "hover", "howl", "huddle", "huff", "hunger", "hunt", "husk", "hype", "hypothesise", "hypothesize", "idle", "ignite", "imagineer", "impact", "impanel", "implode", "incinerate", "incline", "inculcate", "industrialize", "ingratiate", "inhibit", "inject", "innovate", "inscribe", "insert", "insist", "inspect", "institute", "institutionalize", "intend", "intermarry", "intermesh", "intermix", "internalise", "internalize", "internationalize", "intrigue", "inure", "inveigle", "inventory", "investigate", "irk", "iterate", "jaywalk", "jell", "jeopardise", "jiggle", "jive", "joint", "jot", "jut", "keel", "knife", "knit", "know", "kowtow", "lack", "lampoon", "large", "leap", "lecture", "legitimize", "lend", "libel", "liberalize", "license", "ligate", "list", "lobotomise", "lock", "log", "loose", "low", "lowball", "machine", "magnetize", "major", "make", "malfunction", "manage", "manipulate", "maroon", "masculinize", "mash", "mask", "masquerade", "massage", "masticate", "materialise", "matter", "maul", "memorise", "merge", "mesh", "metabolise", "microblog", "microchip", "micromanage", "militate", "mill", "minister", "minor", "misappropriate", "miscalculate", "misfire", "misjudge", "miskey", "mismatch", "mispronounce", "misread", "misreport", "misspend", "mob", "mobilise", "mobilize", "moisten", "mooch", "moor", "moralise", "mortar", "mosh", "mothball", "motivate", "motor", "mould", "mount", "muddy", "mummify", "mutate", "mystify", "nab", "narrate", "narrowcast", "nasalise", "nauseate", "navigate", "neaten", "neck", "neglect", "norm", "notarize", "object", "obscure", "observe", "obsess", "obstruct", "obtrude", "offend", "offset", "option", "orchestrate", "orient", "orientate", "outbid", "outdo", "outfit", "outflank", "outfox", "outnumber", "outrank", "outrun", "outsource", "overburden", "overcharge", "overcook", "overdub", "overfeed", "overload", "overplay", "overproduce", "overreact", "override", "overspend", "overstay", "overtrain", "overvalue", "overwork", "own", "oxidise", "oxidize", "oxygenate", "pace", "pack", "pale", "pant", "paralyse", "parody", "part", "pause", "pave", "penalise", "persecute", "personalise", "perspire", "pertain", "peter", "pike", "pillory", "pinion", "pip", "pity", "pivot", "pixellate", "plagiarise", "plait", "plan", "please", "pluck", "ponder", "popularize", "portray", "prance", "preclude", "preheat", "prejudge", "preregister", "presell", "preside", "pretend", "print", "prioritize", "probate", "probe", "proceed", "procrastinate", "profane", "progress", "proliferate", "proofread", "propound", "proselytise", "provision", "pry", "publicize", "puff", "pull", "pulp", "pulverize", "purse", "put", "putrefy", "quadruple", "quaff", "quantify", "quarrel", "quash", "quaver", "question", "quiet", "quintuple", "quip", "quit", "rag", "rally", "ramp", "randomize", "rationalise", "rationalize", "ravage", "ravel", "react", "readies", "readjust", "readmit", "ready", "reapply", "rear", "reassemble", "rebel", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuke", "recede", "reckon", "reclassify", "recompense", "reconstitute", "record", "recount", "redact", "redevelop", "redound", "redraw", "redress", "reel", "refer", "reference", "refine", "reflate", "refute", "regulate", "reiterate", "rejigger", "rejoin", "rekindle", "relaunch", "relieve", "remand", "remark", "reopen", "reorient", "replicate", "repossess", "represent", "reprimand", "reproach", "reprove", "repurpose", "requite", "reschedule", "resort", "respray", "restructure", "retool", "retract", "revere", "revitalise", "revoke", "reword", "rewrite", "ride", "ridge", "rim", "ring", "rise", "rival", "roger", "rosin", "rot", "rout", "row", "rue", "rule", "safeguard", "sashay", "sate", "satirise", "satirize", "satisfy", "saturate", "savour", "scale", "scamper", "scar", "scare", "scarper", "scent", "schematise", "scheme", "schlep", "scoff", "scoop", "scope", "scotch", "scowl", "scrabble", "scram", "scramble", "scrape", "screw", "scruple", "scrutinise", "scuffle", "scuttle", "search", "secularize", "see", "segregate", "sell", "sense", "sensitize", "sequester", "serenade", "serialize", "serve", "service", "settle", "sew", "shaft", "sham", "shampoo", "shanghai", "shear", "sheathe", "shell", "shinny", "shirk", "shoot", "shoulder", "shout", "shovel", "showboat", "shred", "shrill", "shudder", "shush", "sidetrack", "sign", "silt", "sin", "singe", "sit", "sizzle", "skateboard", "ski", "slake", "slap", "slather", "sleet", "slink", "slip", "slope", "slump", "smarten", "smuggle", "snack", "sneak", "sniff", "snoop", "snow", "snowplow", "snuggle", "soap", "solace", "solder", "solicit", "source", "spark", "spattering", "spectacles", "spectate", "spellcheck", "spew", "spice", "spirit", "splash", "splay", "split", "splosh", "splurge", "spook", "square", "squirm", "stabilise", "stable", "stack", "stage", "stake", "starch", "state", "statement", "stiffen", "stigmatize", "sting", "stint", "stoop", "store", "storyboard", "stratify", "structure", "stuff", "stunt", "substantiate", "subtract", "suckle", "suffice", "suffocate", "summarise", "sun", "sunbathe", "sunder", "sup", "surge", "surprise", "swat", "swathe", "sway", "swear", "swelter", "swerve", "swill", "swing", "symbolise", "synthesise", "syringe", "table", "tabulate", "tag", "tame", "tank", "tankful", "tarry", "task", "taxicab", "team", "telescope", "tenant", "terraform", "terrorise", "testify", "think", "throbbing", "thump", "tighten", "toady", "toe", "tough", "tousle", "traduce", "train", "transcend", "transplant", "trash", "treasure", "treble", "trek", "trial", "tromp", "trouser", "trust", "tune", "tut", "twine", "twist", "typify", "unbalance", "uncork", "uncover", "underachieve", "undergo", "underplay", "unearth", "unfreeze", "unfurl", "unlearn", "unscramble", "unzip", "uproot", "upsell", "usher", "vacation", "vamoose", "vanish", "vary", "veg", "venture", "verify", "vet", "veto", "volunteer", "vulgarise", "waft", "wallop", "waltz", "warp", "wash", "waver", "weary", "weatherize", "wedge", "weep", "weight", "welcome", "westernise", "westernize", "while", "whine", "whisper", "whistle", "whitewash", "whup", "wilt", "wing", "wire", "wisecrack", "wolf", "wound", "wring", "writ", "yak", "yawn", "yearn", "yuppify"];
var kr = { adjective: Oa, adverb: xa, conjunction: za, interjection: Va, noun: Ya, preposition: ja, verb: qa };
var Ua = kr;
var fr = { airline: o, animal: k, app: B, book: P, cell_phone: W, color: F, commerce: I, company: U, database: _, date: $, finance: ce, food: ve, hacker: Le, internet: He, location: Qe, lorem: $e, metadata: ea, music: ia, person: Aa, phone_number: La, science: Pa, team: Ga, vehicle: Ka, word: Ua };
var ys = fr;

// ../../../../node_modules/@faker-js/faker/dist/chunk-YQYVFZYE.js
var m2 = class extends Error {
};
function Ne2(i2) {
  let e2 = Object.getPrototypeOf(i2);
  do {
    for (let r2 of Object.getOwnPropertyNames(e2))
      typeof i2[r2] == "function" && r2 !== "constructor" && (i2[r2] = i2[r2].bind(i2));
    e2 = Object.getPrototypeOf(e2);
  } while (e2 !== Object.prototype);
}
var x2 = class {
  constructor(e2) {
    this.faker = e2;
    Ne2(this);
  }
};
var p3 = class extends x2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
};
var De2 = ((t2) => (t2.Narrowbody = "narrowbody", t2.Regional = "regional", t2.Widebody = "widebody", t2))(De2 || {});
var xr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var Ar = ["0", "O", "1", "I", "L"];
var Er = { regional: 20, narrowbody: 35, widebody: 60 };
var wr = { regional: ["A", "B", "C", "D"], narrowbody: ["A", "B", "C", "D", "E", "F"], widebody: ["A", "B", "C", "D", "E", "F", "G", "H", "J", "K"] };
var G2 = class extends p3 {
  airport() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airport);
  }
  airline() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airline);
  }
  airplane() {
    return this.faker.helpers.arrayElement(this.faker.definitions.airline.airplane);
  }
  recordLocator(e2 = {}) {
    let { allowNumerics: r2 = false, allowVisuallySimilarCharacters: t2 = false } = e2, a2 = [];
    return r2 || a2.push(...xr), t2 || a2.push(...Ar), this.faker.string.alphanumeric({ length: 6, casing: "upper", exclude: a2 });
  }
  seat(e2 = {}) {
    let { aircraftType: r2 = "narrowbody" } = e2, t2 = Er[r2], a2 = wr[r2], n2 = this.faker.number.int({ min: 1, max: t2 }), o2 = this.faker.helpers.arrayElement(a2);
    return `${n2}${o2}`;
  }
  aircraftType() {
    return this.faker.helpers.enumValue(De2);
  }
  flightNumber(e2 = {}) {
    let { length: r2 = { min: 1, max: 4 }, addLeadingZeros: t2 = false } = e2, a2 = this.faker.string.numeric({ length: r2, allowLeadingZeros: false });
    return t2 ? a2.padStart(4, "0") : a2;
  }
};
var Re2 = ((n2) => (n2.SRGB = "sRGB", n2.DisplayP3 = "display-p3", n2.REC2020 = "rec2020", n2.A98RGB = "a98-rgb", n2.ProphotoRGB = "prophoto-rgb", n2))(Re2 || {});
var Le2 = ((c2) => (c2.RGB = "rgb", c2.RGBA = "rgba", c2.HSL = "hsl", c2.HSLA = "hsla", c2.HWB = "hwb", c2.CMYK = "cmyk", c2.LAB = "lab", c2.LCH = "lch", c2.COLOR = "color", c2))(Le2 || {});
function Sr2(i2, e2) {
  let { prefix: r2, casing: t2 } = e2;
  switch (t2) {
    case "upper": {
      i2 = i2.toUpperCase();
      break;
    }
    case "lower": {
      i2 = i2.toLowerCase();
      break;
    }
    case "mixed":
  }
  return r2 && (i2 = r2 + i2), i2;
}
function Pe2(i2) {
  return i2.map((r2) => {
    if (r2 % 1 !== 0) {
      let a2 = new ArrayBuffer(4);
      new DataView(a2).setFloat32(0, r2);
      let n2 = new Uint8Array(a2);
      return Pe2([...n2]).replaceAll(" ", "");
    }
    return (r2 >>> 0).toString(2).padStart(8, "0");
  }).join(" ");
}
function A2(i2) {
  return Math.round(i2 * 100);
}
function Mr(i2, e2 = "rgb", r2 = "sRGB") {
  switch (e2) {
    case "rgba":
      return `rgba(${i2[0]}, ${i2[1]}, ${i2[2]}, ${i2[3]})`;
    case "color":
      return `color(${r2} ${i2[0]} ${i2[1]} ${i2[2]})`;
    case "cmyk":
      return `cmyk(${A2(i2[0])}%, ${A2(i2[1])}%, ${A2(i2[2])}%, ${A2(i2[3])}%)`;
    case "hsl":
      return `hsl(${i2[0]}deg ${A2(i2[1])}% ${A2(i2[2])}%)`;
    case "hsla":
      return `hsl(${i2[0]}deg ${A2(i2[1])}% ${A2(i2[2])}% / ${A2(i2[3])})`;
    case "hwb":
      return `hwb(${i2[0]} ${A2(i2[1])}% ${A2(i2[2])}%)`;
    case "lab":
      return `lab(${A2(i2[0])}% ${i2[1]} ${i2[2]})`;
    case "lch":
      return `lch(${A2(i2[0])}% ${i2[1]} ${i2[2]})`;
    case "rgb":
      return `rgb(${i2[0]}, ${i2[1]}, ${i2[2]})`;
  }
}
function D2(i2, e2, r2 = "rgb", t2 = "sRGB") {
  switch (e2) {
    case "css":
      return Mr(i2, r2, t2);
    case "binary":
      return Pe2(i2);
    case "decimal":
      return i2;
  }
}
var O2 = class extends p3 {
  human() {
    return this.faker.helpers.arrayElement(this.faker.definitions.color.human);
  }
  space() {
    return this.faker.helpers.arrayElement(this.faker.definitions.color.space);
  }
  cssSupportedFunction() {
    return this.faker.helpers.enumValue(Le2);
  }
  cssSupportedSpace() {
    return this.faker.helpers.enumValue(Re2);
  }
  rgb(e2 = {}) {
    let { format: r2 = "hex", includeAlpha: t2 = false, prefix: a2 = "#", casing: n2 = "lower" } = e2, o2, s2 = "rgb";
    return r2 === "hex" ? (o2 = this.faker.string.hexadecimal({ length: t2 ? 8 : 6, prefix: "" }), o2 = Sr2(o2, { prefix: a2, casing: n2 }), o2) : (o2 = Array.from({ length: 3 }, () => this.faker.number.int(255)), t2 && (o2.push(this.faker.number.float({ multipleOf: 0.01 })), s2 = "rgba"), D2(o2, r2, s2));
  }
  cmyk(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = Array.from({ length: 4 }, () => this.faker.number.float({ multipleOf: 0.01 }));
    return D2(t2, r2, "cmyk");
  }
  hsl(e2 = {}) {
    let { format: r2 = "decimal", includeAlpha: t2 = false } = e2, a2 = [this.faker.number.int(360)];
    for (let n2 = 0;n2 < (e2?.includeAlpha ? 3 : 2); n2++)
      a2.push(this.faker.number.float({ multipleOf: 0.01 }));
    return D2(a2, r2, t2 ? "hsla" : "hsl");
  }
  hwb(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.int(360)];
    for (let a2 = 0;a2 < 2; a2++)
      t2.push(this.faker.number.float({ multipleOf: 0.01 }));
    return D2(t2, r2, "hwb");
  }
  lab(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.float({ multipleOf: 0.000001 })];
    for (let a2 = 0;a2 < 2; a2++)
      t2.push(this.faker.number.float({ min: -100, max: 100, multipleOf: 0.0001 }));
    return D2(t2, r2, "lab");
  }
  lch(e2 = {}) {
    let { format: r2 = "decimal" } = e2, t2 = [this.faker.number.float({ multipleOf: 0.000001 })];
    for (let a2 = 0;a2 < 2; a2++)
      t2.push(this.faker.number.float({ max: 230, multipleOf: 0.1 }));
    return D2(t2, r2, "lch");
  }
  colorByCSSColorSpace(e2 = {}) {
    let { format: r2 = "decimal", space: t2 = "sRGB" } = e2, a2 = Array.from({ length: 3 }, () => this.faker.number.float({ multipleOf: 0.0001 }));
    return D2(a2, r2, "color", t2);
  }
};
var de2 = ((a2) => (a2.Legacy = "legacy", a2.Segwit = "segwit", a2.Bech32 = "bech32", a2.Taproot = "taproot", a2))(de2 || {});
var Be2 = ((r2) => (r2.Mainnet = "mainnet", r2.Testnet = "testnet", r2))(Be2 || {});
var ve2 = { legacy: { prefix: { mainnet: "1", testnet: "m" }, length: { min: 26, max: 34 }, casing: "mixed", exclude: "0OIl" }, segwit: { prefix: { mainnet: "3", testnet: "2" }, length: { min: 26, max: 34 }, casing: "mixed", exclude: "0OIl" }, bech32: { prefix: { mainnet: "bc1", testnet: "tb1" }, length: { min: 42, max: 42 }, casing: "lower", exclude: "1bBiIoO" }, taproot: { prefix: { mainnet: "bc1p", testnet: "tb1p" }, length: { min: 62, max: 62 }, casing: "lower", exclude: "1bBiIoO" } };
var ge2 = typeof Buffer > "u" || !$e2("base64") ? (i2) => {
  let e2 = new TextEncoder().encode(i2), r2 = Array.from(e2, (t2) => String.fromCodePoint(t2)).join("");
  return btoa(r2);
} : (i2) => Buffer.from(i2).toString("base64");
var ye2 = typeof Buffer > "u" || !$e2("base64url") ? (i2) => ge2(i2).replaceAll("+", "-").replaceAll("/", "_").replaceAll(/=+$/g, "") : (i2) => Buffer.from(i2).toString("base64url");
function $e2(i2) {
  try {
    return typeof Buffer.from("test").toString(i2) == "string";
  } catch {
    return false;
  }
}
function w2(i2) {
  let { deprecated: e2, since: r2, until: t2, proposed: a2 } = i2, n2 = `[@faker-js/faker]: ${e2} is deprecated`;
  r2 && (n2 += ` since v${r2}`), t2 && (n2 += ` and will be removed in v${t2}`), a2 && (n2 += `. Please use ${a2} instead`), console.warn(`${n2}.`);
}
var Tr = Object.fromEntries([["\u0410", "A"], ["\u0430", "a"], ["\u0411", "B"], ["\u0431", "b"], ["\u0412", "V"], ["\u0432", "v"], ["\u0413", "G"], ["\u0433", "g"], ["\u0414", "D"], ["\u0434", "d"], ["\u044A\u0435", "ye"], ["\u042A\u0435", "Ye"], ["\u044A\u0415", "yE"], ["\u042A\u0415", "YE"], ["\u0415", "E"], ["\u0435", "e"], ["\u0401", "Yo"], ["\u0451", "yo"], ["\u0416", "Zh"], ["\u0436", "zh"], ["\u0417", "Z"], ["\u0437", "z"], ["\u0418", "I"], ["\u0438", "i"], ["\u044B\u0439", "iy"], ["\u042B\u0439", "Iy"], ["\u042B\u0419", "IY"], ["\u044B\u0419", "iY"], ["\u0419", "Y"], ["\u0439", "y"], ["\u041A", "K"], ["\u043A", "k"], ["\u041B", "L"], ["\u043B", "l"], ["\u041C", "M"], ["\u043C", "m"], ["\u041D", "N"], ["\u043D", "n"], ["\u041E", "O"], ["\u043E", "o"], ["\u041F", "P"], ["\u043F", "p"], ["\u0420", "R"], ["\u0440", "r"], ["\u0421", "S"], ["\u0441", "s"], ["\u0422", "T"], ["\u0442", "t"], ["\u0423", "U"], ["\u0443", "u"], ["\u0424", "F"], ["\u0444", "f"], ["\u0425", "Kh"], ["\u0445", "kh"], ["\u0426", "Ts"], ["\u0446", "ts"], ["\u0427", "Ch"], ["\u0447", "ch"], ["\u0428", "Sh"], ["\u0448", "sh"], ["\u0429", "Sch"], ["\u0449", "sch"], ["\u042A", ""], ["\u044A", ""], ["\u042B", "Y"], ["\u044B", "y"], ["\u042C", ""], ["\u044C", ""], ["\u042D", "E"], ["\u044D", "e"], ["\u042E", "Yu"], ["\u044E", "yu"], ["\u042F", "Ya"], ["\u044F", "ya"]]);
var Cr2 = Object.fromEntries([["\u03B1", "a"], ["\u03B2", "v"], ["\u03B3", "g"], ["\u03B4", "d"], ["\u03B5", "e"], ["\u03B6", "z"], ["\u03B7", "i"], ["\u03B8", "th"], ["\u03B9", "i"], ["\u03BA", "k"], ["\u03BB", "l"], ["\u03BC", "m"], ["\u03BD", "n"], ["\u03BE", "ks"], ["\u03BF", "o"], ["\u03C0", "p"], ["\u03C1", "r"], ["\u03C3", "s"], ["\u03C4", "t"], ["\u03C5", "y"], ["\u03C6", "f"], ["\u03C7", "x"], ["\u03C8", "ps"], ["\u03C9", "o"], ["\u03AC", "a"], ["\u03AD", "e"], ["\u03AF", "i"], ["\u03CC", "o"], ["\u03CD", "y"], ["\u03AE", "i"], ["\u03CE", "o"], ["\u03C2", "s"], ["\u03CA", "i"], ["\u03B0", "y"], ["\u03CB", "y"], ["\u0390", "i"], ["\u0391", "A"], ["\u0392", "B"], ["\u0393", "G"], ["\u0394", "D"], ["\u0395", "E"], ["\u0396", "Z"], ["\u0397", "I"], ["\u0398", "TH"], ["\u0399", "I"], ["\u039A", "K"], ["\u039B", "L"], ["\u039C", "M"], ["\u039D", "N"], ["\u039E", "KS"], ["\u039F", "O"], ["\u03A0", "P"], ["\u03A1", "R"], ["\u03A3", "S"], ["\u03A4", "T"], ["\u03A5", "Y"], ["\u03A6", "F"], ["\u03A7", "X"], ["\u03A8", "PS"], ["\u03A9", "O"], ["\u0386", "A"], ["\u0388", "E"], ["\u038A", "I"], ["\u038C", "O"], ["\u038E", "Y"], ["\u0389", "I"], ["\u038F", "O"], ["\u03AA", "I"], ["\u03AB", "Y"]]);
var Nr = Object.fromEntries([["\u0621", "e"], ["\u0622", "a"], ["\u0623", "a"], ["\u0624", "w"], ["\u0625", "i"], ["\u0626", "y"], ["\u0627", "a"], ["\u0628", "b"], ["\u0629", "t"], ["\u062A", "t"], ["\u062B", "th"], ["\u062C", "j"], ["\u062D", "h"], ["\u062E", "kh"], ["\u062F", "d"], ["\u0630", "dh"], ["\u0631", "r"], ["\u0632", "z"], ["\u0633", "s"], ["\u0634", "sh"], ["\u0635", "s"], ["\u0636", "d"], ["\u0637", "t"], ["\u0638", "z"], ["\u0639", "e"], ["\u063A", "gh"], ["\u0640", "_"], ["\u0641", "f"], ["\u0642", "q"], ["\u0643", "k"], ["\u0644", "l"], ["\u0645", "m"], ["\u0646", "n"], ["\u0647", "h"], ["\u0648", "w"], ["\u0649", "a"], ["\u064A", "y"], ["\u064E\u200E", "a"], ["\u064F", "u"], ["\u0650\u200E", "i"]]);
var Dr = Object.fromEntries([["\u0561", "a"], ["\u0531", "A"], ["\u0562", "b"], ["\u0532", "B"], ["\u0563", "g"], ["\u0533", "G"], ["\u0564", "d"], ["\u0534", "D"], ["\u0565", "ye"], ["\u0535", "Ye"], ["\u0566", "z"], ["\u0536", "Z"], ["\u0567", "e"], ["\u0537", "E"], ["\u0568", "y"], ["\u0538", "Y"], ["\u0569", "t"], ["\u0539", "T"], ["\u056A", "zh"], ["\u053A", "Zh"], ["\u056B", "i"], ["\u053B", "I"], ["\u056C", "l"], ["\u053C", "L"], ["\u056D", "kh"], ["\u053D", "Kh"], ["\u056E", "ts"], ["\u053E", "Ts"], ["\u056F", "k"], ["\u053F", "K"], ["\u0570", "h"], ["\u0540", "H"], ["\u0571", "dz"], ["\u0541", "Dz"], ["\u0572", "gh"], ["\u0542", "Gh"], ["\u0573", "tch"], ["\u0543", "Tch"], ["\u0574", "m"], ["\u0544", "M"], ["\u0575", "y"], ["\u0545", "Y"], ["\u0576", "n"], ["\u0546", "N"], ["\u0577", "sh"], ["\u0547", "Sh"], ["\u0578", "vo"], ["\u0548", "Vo"], ["\u0579", "ch"], ["\u0549", "Ch"], ["\u057A", "p"], ["\u054A", "P"], ["\u057B", "j"], ["\u054B", "J"], ["\u057C", "r"], ["\u054C", "R"], ["\u057D", "s"], ["\u054D", "S"], ["\u057E", "v"], ["\u054E", "V"], ["\u057F", "t"], ["\u054F", "T"], ["\u0580", "r"], ["\u0550", "R"], ["\u0581", "c"], ["\u0551", "C"], ["\u0578\u0582", "u"], ["\u0548\u0552", "U"], ["\u0548\u0582", "U"], ["\u0583", "p"], ["\u0553", "P"], ["\u0584", "q"], ["\u0554", "Q"], ["\u0585", "o"], ["\u0555", "O"], ["\u0586", "f"], ["\u0556", "F"], ["\u0587", "yev"]]);
var Rr = Object.fromEntries([["\u0686", "ch"], ["\u06A9", "k"], ["\u06AF", "g"], ["\u067E", "p"], ["\u0698", "zh"], ["\u06CC", "y"]]);
var Lr = Object.fromEntries([["\u05D0", "a"], ["\u05D1", "b"], ["\u05D2", "g"], ["\u05D3", "d"], ["\u05D4", "h"], ["\u05D5", "v"], ["\u05D6", "z"], ["\u05D7", "ch"], ["\u05D8", "t"], ["\u05D9", "y"], ["\u05DB", "k"], ["\u05DA", "kh"], ["\u05DC", "l"], ["\u05DD", "m"], ["\u05DE", "m"], ["\u05DF", "n"], ["\u05E0", "n"], ["\u05E1", "s"], ["\u05E2", "a"], ["\u05E4", "f"], ["\u05E3", "ph"], ["\u05E6", "ts"], ["\u05E5", "ts"], ["\u05E7", "k"], ["\u05E8", "r"], ["\u05E9", "sh"], ["\u05EA", "t"], ["\u05D5", "v"]]);
var ke2 = { ...Tr, ...Cr2, ...Nr, ...Rr, ...Dr, ...Lr };
var Pr = ((u2) => (u2.Any = "any", u2.Loopback = "loopback", u2.PrivateA = "private-a", u2.PrivateB = "private-b", u2.PrivateC = "private-c", u2.TestNet1 = "test-net-1", u2.TestNet2 = "test-net-2", u2.TestNet3 = "test-net-3", u2.LinkLocal = "link-local", u2.Multicast = "multicast", u2))(Pr || {});
var Br = { any: "0.0.0.0/0", loopback: "127.0.0.0/8", "private-a": "10.0.0.0/8", "private-b": "172.16.0.0/12", "private-c": "192.168.0.0/16", "test-net-1": "192.0.2.0/24", "test-net-2": "198.51.100.0/24", "test-net-3": "203.0.113.0/24", "link-local": "169.254.0.0/16", multicast: "224.0.0.0/4" };
function Ie2(i2) {
  return /^[a-z][a-z-]*[a-z]$/i.exec(i2) !== null;
}
function _e2(i2, e2) {
  let r2 = i2.helpers.slugify(e2);
  if (Ie2(r2))
    return r2;
  let t2 = i2.helpers.slugify(i2.lorem.word());
  return Ie2(t2) ? t2 : i2.string.alpha({ casing: "lower", length: i2.number.int({ min: 4, max: 8 }) });
}
function xe2(i2, e2) {
  return Math.floor((i2.number.int(256) + e2) / 2).toString(16).padStart(2, "0");
}
var U2 = class extends p3 {
  email(e2 = {}) {
    let { firstName: r2, lastName: t2, provider: a2 = this.faker.helpers.arrayElement(this.faker.definitions.internet.free_email), allowSpecialCharacters: n2 = false } = e2, o2 = this.username({ firstName: r2, lastName: t2 });
    if (o2 = o2.replaceAll(/[^A-Za-z0-9._+-]+/g, ""), o2 = o2.substring(0, 50), n2) {
      let s2 = [..."._-"], l2 = [...".!#$%&'*+-/=?^_`{|}~"];
      o2 = o2.replace(this.faker.helpers.arrayElement(s2), this.faker.helpers.arrayElement(l2));
    }
    return o2 = o2.replaceAll(/\.{2,}/g, "."), o2 = o2.replace(/^\./, ""), o2 = o2.replace(/\.$/, ""), `${o2}@${a2}`;
  }
  exampleEmail(e2 = {}) {
    let { firstName: r2, lastName: t2, allowSpecialCharacters: a2 = false } = e2, n2 = this.faker.helpers.arrayElement(this.faker.definitions.internet.example_email);
    return this.email({ firstName: r2, lastName: t2, provider: n2, allowSpecialCharacters: a2 });
  }
  userName(e2 = {}) {
    return w2({ deprecated: "faker.internet.userName()", proposed: "faker.internet.username()", since: "9.1.0", until: "10.0.0" }), this.username(e2);
  }
  username(e2 = {}) {
    let { firstName: r2 = this.faker.person.firstName(), lastName: t2 = this.faker.person.lastName(), lastName: a2 } = e2, n2 = this.faker.helpers.arrayElement([".", "_"]), o2 = this.faker.number.int(99), s2 = [() => `${r2}${n2}${t2}${o2}`, () => `${r2}${n2}${t2}`];
    a2 || s2.push(() => `${r2}${o2}`);
    let l2 = this.faker.helpers.arrayElement(s2)();
    return l2 = l2.normalize("NFKD").replaceAll(/[\u0300-\u036F]/g, ""), l2 = [...l2].map((c2) => {
      if (ke2[c2])
        return ke2[c2];
      let u2 = c2.codePointAt(0) ?? Number.NaN;
      return u2 < 128 ? c2 : u2.toString(36);
    }).join(""), l2 = l2.toString().replaceAll("'", ""), l2 = l2.replaceAll(" ", ""), l2;
  }
  displayName(e2 = {}) {
    let { firstName: r2 = this.faker.person.firstName(), lastName: t2 = this.faker.person.lastName() } = e2, a2 = this.faker.helpers.arrayElement([".", "_"]), n2 = this.faker.number.int(99), o2 = [() => `${r2}${n2}`, () => `${r2}${a2}${t2}`, () => `${r2}${a2}${t2}${n2}`], s2 = this.faker.helpers.arrayElement(o2)();
    return s2 = s2.toString().replaceAll("'", ""), s2 = s2.replaceAll(" ", ""), s2;
  }
  protocol() {
    let e2 = ["http", "https"];
    return this.faker.helpers.arrayElement(e2);
  }
  httpMethod() {
    let e2 = ["GET", "POST", "PUT", "DELETE", "PATCH"];
    return this.faker.helpers.arrayElement(e2);
  }
  httpStatusCode(e2 = {}) {
    let { types: r2 = Object.keys(this.faker.definitions.internet.http_status_code) } = e2, t2 = this.faker.helpers.arrayElement(r2);
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.http_status_code[t2]);
  }
  url(e2 = {}) {
    let { appendSlash: r2 = this.faker.datatype.boolean(), protocol: t2 = "https" } = e2;
    return `${t2}://${this.domainName()}${r2 ? "/" : ""}`;
  }
  domainName() {
    return `${this.domainWord()}.${this.domainSuffix()}`;
  }
  domainSuffix() {
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.domain_suffix);
  }
  domainWord() {
    let e2 = _e2(this.faker, this.faker.word.adjective()), r2 = _e2(this.faker, this.faker.word.noun());
    return `${e2}-${r2}`.toLowerCase();
  }
  ip() {
    return this.faker.datatype.boolean() ? this.ipv4() : this.ipv6();
  }
  ipv4(e2 = {}) {
    let { network: r2 = "any", cidrBlock: t2 = Br[r2] } = e2;
    if (!/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}$/.test(t2))
      throw new m2(`Invalid CIDR block provided: ${t2}. Must be in the format x.x.x.x/y.`);
    let [a2, n2] = t2.split("/"), o2 = 4294967295 >>> Number.parseInt(n2), [s2, l2, c2, u2] = a2.split(".").map(Number), f2 = (s2 << 24 | l2 << 16 | c2 << 8 | u2) & ~o2, g2 = this.faker.number.int(o2), b2 = f2 | g2;
    return [b2 >>> 24 & 255, b2 >>> 16 & 255, b2 >>> 8 & 255, b2 & 255].join(".");
  }
  ipv6() {
    return Array.from({ length: 8 }, () => this.faker.string.hexadecimal({ length: 4, casing: "lower", prefix: "" })).join(":");
  }
  port() {
    return this.faker.number.int(65535);
  }
  userAgent() {
    return this.faker.helpers.fake(this.faker.definitions.internet.user_agent_pattern);
  }
  color(e2 = {}) {
    w2({ deprecated: "faker.internet.color()", proposed: "faker.color.rgb()", since: "9.6.0", until: "10.0.0" });
    let { redBase: r2 = 0, greenBase: t2 = 0, blueBase: a2 = 0 } = e2, n2 = xe2(this.faker, r2), o2 = xe2(this.faker, t2), s2 = xe2(this.faker, a2);
    return `#${n2}${o2}${s2}`;
  }
  mac(e2 = {}) {
    typeof e2 == "string" && (e2 = { separator: e2 });
    let { separator: r2 = ":" } = e2, t2, a2 = "";
    for ([":", "-", ""].includes(r2) || (r2 = ":"), t2 = 0;t2 < 12; t2++)
      a2 += this.faker.number.hex(15), t2 % 2 === 1 && t2 !== 11 && (a2 += r2);
    return a2;
  }
  password(e2 = {}) {
    let r2 = /[aeiouAEIOU]$/, t2 = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/, a2 = (c2, u2, h2, f2) => {
      if (f2.length >= c2)
        return f2;
      u2 && (h2 = t2.test(f2) ? r2 : t2);
      let g2 = this.faker.number.int(94) + 33, b2 = String.fromCodePoint(g2);
      return u2 && (b2 = b2.toLowerCase()), h2.test(b2) ? a2(c2, u2, h2, f2 + b2) : a2(c2, u2, h2, f2);
    }, { length: n2 = 15, memorable: o2 = false, pattern: s2 = /\w/, prefix: l2 = "" } = e2;
    return a2(n2, o2, s2, l2);
  }
  emoji(e2 = {}) {
    let { types: r2 = Object.keys(this.faker.definitions.internet.emoji) } = e2, t2 = this.faker.helpers.arrayElement(r2);
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.emoji[t2]);
  }
  jwtAlgorithm() {
    return this.faker.helpers.arrayElement(this.faker.definitions.internet.jwt_algorithm);
  }
  jwt(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = this.faker.date.recent({ refDate: r2 }), { header: a2 = { alg: this.jwtAlgorithm(), typ: "JWT" }, payload: n2 = { iat: Math.round(t2.valueOf() / 1000), exp: Math.round(this.faker.date.soon({ refDate: t2 }).valueOf() / 1000), nbf: Math.round(this.faker.date.anytime({ refDate: r2 }).valueOf() / 1000), iss: this.faker.company.name(), sub: this.faker.string.uuid(), aud: this.faker.string.uuid(), jti: this.faker.string.uuid() } } = e2, o2 = ye2(JSON.stringify(a2)), s2 = ye2(JSON.stringify(n2)), l2 = this.faker.string.alphanumeric(64);
    return `${o2}.${s2}.${l2}`;
  }
};
var Fe2 = ((r2) => (r2.Female = "female", r2.Male = "male", r2))(Fe2 || {});
function R2(i2, e2, r2) {
  let { generic: t2, female: a2, male: n2 } = r2;
  switch (e2) {
    case "female":
      return a2 ?? t2;
    case "male":
      return n2 ?? t2;
    default:
      return t2 ?? i2.helpers.arrayElement([a2, n2]) ?? [];
  }
}
var K2 = class extends p3 {
  firstName(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.first_name));
  }
  lastName(e2) {
    if (this.faker.rawDefinitions.person?.last_name_pattern != null) {
      let r2 = this.faker.helpers.weightedArrayElement(R2(this.faker, e2, this.faker.rawDefinitions.person.last_name_pattern));
      return this.faker.helpers.fake(r2);
    }
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.last_name));
  }
  middleName(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.middle_name));
  }
  fullName(e2 = {}) {
    let { sex: r2 = this.faker.helpers.arrayElement(["female", "male"]), firstName: t2 = this.firstName(r2), lastName: a2 = this.lastName(r2) } = e2, n2 = this.faker.helpers.weightedArrayElement(this.faker.definitions.person.name);
    return this.faker.helpers.mustache(n2, { "person.prefix": () => this.prefix(r2), "person.firstName": () => t2, "person.middleName": () => this.middleName(r2), "person.lastName": () => a2, "person.suffix": () => this.suffix() });
  }
  gender() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.gender);
  }
  sex() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.sex);
  }
  sexType() {
    return this.faker.helpers.enumValue(Fe2);
  }
  bio() {
    let { bio_pattern: e2 } = this.faker.definitions.person;
    return this.faker.helpers.fake(e2);
  }
  prefix(e2) {
    return this.faker.helpers.arrayElement(R2(this.faker, e2, this.faker.definitions.person.prefix));
  }
  suffix() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.suffix);
  }
  jobTitle() {
    return this.faker.helpers.fake(this.faker.definitions.person.job_title_pattern);
  }
  jobDescriptor() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_descriptor);
  }
  jobArea() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_area);
  }
  jobType() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.job_type);
  }
  zodiacSign() {
    return this.faker.helpers.arrayElement(this.faker.definitions.person.western_zodiac_sign);
  }
};
var vr = 0.00000000023283064365386963;
var $r = 1 / 9007199254740992;
var { imul: Ee2, trunc: we2 } = Math;
function Ge2(i2) {
  return typeof i2 == "number" ? Oe2(i2) : Ir(i2);
}
function Oe2(i2) {
  let e2 = Array.from({ length: 624 });
  e2[0] = i2;
  for (let r2 = 1;r2 !== 624; ++r2) {
    let t2 = e2[r2 - 1] ^ e2[r2 - 1] >>> 30;
    e2[r2] = we2(Ee2(1812433253, t2) + r2);
  }
  return e2;
}
function Ir(i2) {
  let e2 = Oe2(19650218), r2 = 1, t2 = 0;
  for (let a2 = Math.max(624, i2.length);a2 !== 0; --a2) {
    let n2 = e2[r2 - 1] ^ e2[r2 - 1] >>> 30;
    e2[r2] = we2((e2[r2] ^ Ee2(n2, 1664525)) + i2[t2] + t2), r2++, t2++, r2 >= 624 && (e2[0] = e2[623], r2 = 1), t2 >= i2.length && (t2 = 0);
  }
  for (let a2 = 623;a2 !== 0; a2--)
    e2[r2] = we2((e2[r2] ^ Ee2(e2[r2 - 1] ^ e2[r2 - 1] >>> 30, 1566083941)) - r2), r2++, r2 >= 624 && (e2[0] = e2[623], r2 = 1);
  return e2[0] = 2147483648, e2;
}
function Ae2(i2) {
  for (let r2 = 0;r2 !== 227; ++r2) {
    let t2 = (i2[r2] & 2147483648) + (i2[r2 + 1] & 2147483647);
    i2[r2] = i2[r2 + 397] ^ t2 >>> 1 ^ -(t2 & 1) & 2567483615;
  }
  for (let r2 = 227;r2 !== 623; ++r2) {
    let t2 = (i2[r2] & 2147483648) + (i2[r2 + 1] & 2147483647);
    i2[r2] = i2[r2 + 397 - 624] ^ t2 >>> 1 ^ -(t2 & 1) & 2567483615;
  }
  let e2 = (i2[623] & 2147483648) + (i2[0] & 2147483647);
  return i2[623] = i2[396] ^ e2 >>> 1 ^ -(e2 & 1) & 2567483615, i2;
}
var L2 = class {
  constructor(e2 = Math.random() * Number.MAX_SAFE_INTEGER, r2 = Ae2(Ge2(e2)), t2 = 0) {
    this.states = r2;
    this.index = t2;
  }
  nextU32() {
    let e2 = this.states[this.index];
    return e2 ^= this.states[this.index] >>> 11, e2 ^= e2 << 7 & 2636928640, e2 ^= e2 << 15 & 4022730752, e2 ^= e2 >>> 18, ++this.index >= 624 && (this.states = Ae2(this.states), this.index = 0), e2 >>> 0;
  }
  nextF32() {
    return this.nextU32() * vr;
  }
  nextU53() {
    let e2 = this.nextU32() >>> 5, r2 = this.nextU32() >>> 6;
    return e2 * 67108864 + r2;
  }
  nextF53() {
    return this.nextU53() * $r;
  }
  seed(e2) {
    this.states = Ae2(Ge2(e2)), this.index = 0;
  }
};
function P2() {
  return Math.ceil(Math.random() * Number.MAX_SAFE_INTEGER);
}
function Ue2(i2 = P2()) {
  let e2 = new L2(i2);
  return { next() {
    return e2.nextF53();
  }, seed(r2) {
    e2.seed(r2);
  } };
}
var j2 = class extends x2 {
  boolean(e2 = {}) {
    typeof e2 == "number" && (e2 = { probability: e2 });
    let { probability: r2 = 0.5 } = e2;
    return r2 <= 0 ? false : r2 >= 1 ? true : this.faker.number.float() < r2;
  }
};
function S2(i2, e2 = "refDate") {
  let r2 = new Date(i2);
  if (Number.isNaN(r2.valueOf()))
    throw new m2(`Invalid ${e2} date: ${i2.toString()}`);
  return r2;
}
var H2 = () => {
  throw new m2("You cannot edit the locale data on the faker instance");
};
function Ke2(i2) {
  let e2 = {};
  return new Proxy(i2, { has() {
    return true;
  }, get(r2, t2) {
    return typeof t2 == "symbol" || t2 === "nodeType" ? r2[t2] : (t2 in e2) ? e2[t2] : e2[t2] = _r(t2, r2[t2]);
  }, set: H2, deleteProperty: H2 });
}
function V2(i2, ...e2) {
  if (i2 === null)
    throw new m2(`The locale data for '${e2.join(".")}' aren't applicable to this locale.
  If you think this is a bug, please report it at: https://github.com/faker-js/faker`);
  if (i2 === undefined)
    throw new m2(`The locale data for '${e2.join(".")}' are missing in this locale.
  If this is a custom Faker instance, please make sure all required locales are used e.g. '[de_AT, de, en, base]'.
  Please contribute the missing data to the project or use a locale/Faker instance that has these data.
  For more information see https://fakerjs.dev/guide/localization.html`);
}
function _r(i2, e2 = {}) {
  return new Proxy(e2, { has(r2, t2) {
    return r2[t2] != null;
  }, get(r2, t2) {
    let a2 = r2[t2];
    return typeof t2 == "symbol" || t2 === "nodeType" || V2(a2, i2, t2.toString()), a2;
  }, set: H2, deleteProperty: H2 });
}
var B2 = class extends x2 {
  anytime(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = S2(r2).getTime();
    return this.between({ from: t2 - 1000 * 60 * 60 * 24 * 365, to: t2 + 1000 * 60 * 60 * 24 * 365 });
  }
  past(e2 = {}) {
    let { years: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0)
      throw new m2("Years must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 - r2 * 365 * 24 * 3600 * 1000, to: a2 - 1000 });
  }
  future(e2 = {}) {
    let { years: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0)
      throw new m2("Years must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 + 1000, to: a2 + r2 * 365 * 24 * 3600 * 1000 });
  }
  between(e2) {
    if (e2 == null || e2.from == null || e2.to == null)
      throw new m2("Must pass an options object with `from` and `to` values.");
    let { from: r2, to: t2 } = e2, a2 = S2(r2, "from").getTime(), n2 = S2(t2, "to").getTime();
    if (a2 > n2)
      throw new m2("`from` date must be before `to` date.");
    return new Date(this.faker.number.int({ min: a2, max: n2 }));
  }
  betweens(e2) {
    if (e2 == null || e2.from == null || e2.to == null)
      throw new m2("Must pass an options object with `from` and `to` values.");
    let { from: r2, to: t2, count: a2 = 3 } = e2;
    return this.faker.helpers.multiple(() => this.between({ from: r2, to: t2 }), { count: a2 }).sort((n2, o2) => n2.getTime() - o2.getTime());
  }
  recent(e2 = {}) {
    let { days: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0)
      throw new m2("Days must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 - r2 * 24 * 3600 * 1000, to: a2 - 1000 });
  }
  soon(e2 = {}) {
    let { days: r2 = 1, refDate: t2 = this.faker.defaultRefDate() } = e2;
    if (r2 <= 0)
      throw new m2("Days must be greater than 0.");
    let a2 = S2(t2).getTime();
    return this.between({ from: a2 + 1000, to: a2 + r2 * 24 * 3600 * 1000 });
  }
  birthdate(e2 = {}) {
    let { mode: r2 = "age", min: t2 = 18, max: a2 = 80, refDate: n2 = this.faker.defaultRefDate(), mode: o2, min: s2, max: l2 } = e2;
    if ([s2, l2, o2].filter((f2) => f2 != null).length % 3 !== 0)
      throw new m2("The 'min', 'max', and 'mode' options must be set together.");
    let u2 = S2(n2), h2 = u2.getUTCFullYear();
    switch (r2) {
      case "age": {
        let g2 = new Date(u2).setUTCFullYear(h2 - a2 - 1) + 86400000, b2 = new Date(u2).setUTCFullYear(h2 - t2);
        if (g2 > b2)
          throw new m2(`Max age ${a2} should be greater than or equal to min age ${t2}.`);
        return this.between({ from: g2, to: b2 });
      }
      case "year": {
        let f2 = new Date(Date.UTC(0, 0, 2)).setUTCFullYear(t2), g2 = new Date(Date.UTC(0, 11, 30)).setUTCFullYear(a2);
        if (f2 > g2)
          throw new m2(`Max year ${a2} should be greater than or equal to min year ${t2}.`);
        return this.between({ from: f2, to: g2 });
      }
    }
  }
};
var z2 = class extends B2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
  month(r2 = {}) {
    let { abbreviated: t2 = false, context: a2 = false } = r2, n2 = this.faker.definitions.date.month, o2;
    t2 ? o2 = a2 && n2.abbr_context != null ? "abbr_context" : "abbr" : o2 = a2 && n2.wide_context != null ? "wide_context" : "wide";
    let s2 = n2[o2];
    return V2(s2, "date.month", o2), this.faker.helpers.arrayElement(s2);
  }
  weekday(r2 = {}) {
    let { abbreviated: t2 = false, context: a2 = false } = r2, n2 = this.faker.definitions.date.weekday, o2;
    t2 ? o2 = a2 && n2.abbr_context != null ? "abbr_context" : "abbr" : o2 = a2 && n2.wide_context != null ? "wide_context" : "wide";
    let s2 = n2[o2];
    return V2(s2, "date.weekday", o2), this.faker.helpers.arrayElement(s2);
  }
  timeZone() {
    return this.faker.helpers.arrayElement(this.faker.definitions.date.time_zone);
  }
};
var Fr = /\.|\(/;
function je2(i2, e2, r2 = [e2, e2.rawDefinitions]) {
  if (i2.length === 0)
    throw new m2("Eval expression cannot be empty.");
  if (r2.length === 0)
    throw new m2("Eval entrypoints cannot be empty.");
  let t2 = r2, a2 = i2;
  do {
    let o2;
    a2.startsWith("(") ? [o2, t2] = Gr(a2, t2, i2) : [o2, t2] = Ur(a2, t2), a2 = a2.substring(o2), t2 = t2.filter((s2) => s2 != null).map((s2) => Array.isArray(s2) ? e2.helpers.arrayElement(s2) : s2);
  } while (a2.length > 0 && t2.length > 0);
  if (t2.length === 0)
    throw new m2(`Cannot resolve expression '${i2}'`);
  let n2 = t2[0];
  return typeof n2 == "function" ? n2() : n2;
}
function Gr(i2, e2, r2) {
  let [t2, a2] = Or(i2), n2 = i2[t2 + 1];
  switch (n2) {
    case ".":
    case "(":
    case undefined:
      break;
    default:
      throw new m2(`Expected dot ('.'), open parenthesis ('('), or nothing after function call but got '${n2}'`);
  }
  return [t2 + (n2 === "." ? 2 : 1), e2.map((o2) => typeof o2 == "function" ? o2(...a2) : (console.warn(`[@faker-js/faker]: Invoking expressions which are not functions is deprecated since v9.0 and will be removed in v10.0.
Please remove the parentheses or replace the expression with an actual function.
${r2}
${" ".repeat(r2.length - i2.length)}^`), o2))];
}
function Or(i2) {
  let e2 = i2.indexOf(")", 1);
  if (e2 === -1)
    throw new m2(`Missing closing parenthesis in '${i2}'`);
  for (;e2 !== -1; ) {
    let t2 = i2.substring(1, e2);
    try {
      return [e2, JSON.parse(`[${t2}]`)];
    } catch {
      if (!t2.includes("'") && !t2.includes('"'))
        try {
          return [e2, JSON.parse(`["${t2}"]`)];
        } catch {}
    }
    e2 = i2.indexOf(")", e2 + 1);
  }
  e2 = i2.lastIndexOf(")");
  let r2 = i2.substring(1, e2);
  return [e2, [r2]];
}
function Ur(i2, e2) {
  let r2 = Fr.exec(i2), t2 = (r2?.[0] ?? "") === ".", a2 = r2?.index ?? i2.length, n2 = i2.substring(0, a2);
  if (n2.length === 0)
    throw new m2(`Expression parts cannot be empty in '${i2}'`);
  let o2 = i2[a2 + 1];
  if (t2 && (o2 == null || o2 === "." || o2 === "("))
    throw new m2(`Found dot without property name in '${i2}'`);
  return [a2 + (t2 ? 1 : 0), e2.map((s2) => Kr(s2, n2))];
}
function Kr(i2, e2) {
  switch (typeof i2) {
    case "function": {
      try {
        i2 = i2();
      } catch {
        return;
      }
      return i2?.[e2];
    }
    case "object":
      return i2?.[e2];
    default:
      return;
  }
}
function He2(i2) {
  let e2 = jr(i2.replace(/L?$/, "0"));
  return e2 === 0 ? 0 : 10 - e2;
}
function jr(i2) {
  i2 = i2.replaceAll(/[\s-]/g, "");
  let e2 = 0, r2 = false;
  for (let t2 = i2.length - 1;t2 >= 0; t2--) {
    let a2 = Number.parseInt(i2[t2]);
    r2 && (a2 *= 2, a2 > 9 && (a2 = a2 % 10 + 1)), e2 += a2, r2 = !r2;
  }
  return e2 % 10;
}
function Ve2(i2, e2, r2, t2) {
  let a2 = 1;
  if (e2)
    switch (e2) {
      case "?": {
        a2 = i2.datatype.boolean() ? 0 : 1;
        break;
      }
      case "*": {
        let n2 = 1;
        for (;i2.datatype.boolean(); )
          n2 *= 2;
        a2 = i2.number.int({ min: 0, max: n2 });
        break;
      }
      case "+": {
        let n2 = 1;
        for (;i2.datatype.boolean(); )
          n2 *= 2;
        a2 = i2.number.int({ min: 1, max: n2 });
        break;
      }
      default:
        throw new m2("Unknown quantifier symbol provided.");
    }
  else
    r2 != null && t2 != null ? a2 = i2.number.int({ min: Number.parseInt(r2), max: Number.parseInt(t2) }) : r2 != null && t2 == null && (a2 = Number.parseInt(r2));
  return a2;
}
function Hr(i2, e2 = "") {
  let r2 = /(.)\{(\d+),(\d+)\}/, t2 = /(.)\{(\d+)\}/, a2 = /\[(\d+)-(\d+)\]/, n2, o2, s2, l2, c2 = r2.exec(e2);
  for (;c2 != null; )
    n2 = Number.parseInt(c2[2]), o2 = Number.parseInt(c2[3]), n2 > o2 && (s2 = o2, o2 = n2, n2 = s2), l2 = i2.number.int({ min: n2, max: o2 }), e2 = e2.slice(0, c2.index) + c2[1].repeat(l2) + e2.slice(c2.index + c2[0].length), c2 = r2.exec(e2);
  for (c2 = t2.exec(e2);c2 != null; )
    l2 = Number.parseInt(c2[2]), e2 = e2.slice(0, c2.index) + c2[1].repeat(l2) + e2.slice(c2.index + c2[0].length), c2 = t2.exec(e2);
  for (c2 = a2.exec(e2);c2 != null; )
    n2 = Number.parseInt(c2[1]), o2 = Number.parseInt(c2[2]), n2 > o2 && (s2 = o2, o2 = n2, n2 = s2), e2 = e2.slice(0, c2.index) + i2.number.int({ min: n2, max: o2 }).toString() + e2.slice(c2.index + c2[0].length), c2 = a2.exec(e2);
  return e2;
}
function Se2(i2, e2 = "", r2 = "#") {
  let t2 = "";
  for (let a2 = 0;a2 < e2.length; a2++)
    e2.charAt(a2) === r2 ? t2 += i2.number.int(9) : e2.charAt(a2) === "!" ? t2 += i2.number.int({ min: 2, max: 9 }) : t2 += e2.charAt(a2);
  return t2;
}
var v2 = class extends x2 {
  slugify(e2 = "") {
    return e2.normalize("NFKD").replaceAll(/[\u0300-\u036F]/g, "").replaceAll(" ", "-").replaceAll(/[^\w.-]+/g, "");
  }
  replaceSymbols(e2 = "") {
    let r2 = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], t2 = "";
    for (let a2 = 0;a2 < e2.length; a2++)
      e2.charAt(a2) === "#" ? t2 += this.faker.number.int(9) : e2.charAt(a2) === "?" ? t2 += this.arrayElement(r2) : e2.charAt(a2) === "*" ? t2 += this.faker.datatype.boolean() ? this.arrayElement(r2) : this.faker.number.int(9) : t2 += e2.charAt(a2);
    return t2;
  }
  replaceCreditCardSymbols(e2 = "6453-####-####-####-###L", r2 = "#") {
    e2 = Hr(this.faker, e2), e2 = Se2(this.faker, e2, r2);
    let t2 = He2(e2);
    return e2.replace("L", String(t2));
  }
  fromRegExp(e2) {
    let r2 = false;
    e2 instanceof RegExp && (r2 = e2.flags.includes("i"), e2 = e2.toString(), e2 = /\/(.+?)\//.exec(e2)?.[1] ?? "");
    let t2, a2, n2, o2 = /([.A-Za-z0-9])(?:\{(\d+)(?:,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/, s2 = o2.exec(e2);
    for (;s2 != null; ) {
      let f2 = s2[2], g2 = s2[3], b2 = s2[4];
      n2 = Ve2(this.faker, b2, f2, g2);
      let y2;
      s2[1] === "." ? y2 = this.faker.string.alphanumeric(n2) : r2 ? y2 = this.faker.string.fromCharacters([s2[1].toLowerCase(), s2[1].toUpperCase()], n2) : y2 = s2[1].repeat(n2), e2 = e2.slice(0, s2.index) + y2 + e2.slice(s2.index + s2[0].length), s2 = o2.exec(e2);
    }
    let l2 = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/, c2 = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:,(\d+)|)\}|(\?|\*|\+)|)/;
    for (s2 = c2.exec(e2);s2 != null; ) {
      let f2 = s2[1] === "^", g2 = s2[2] === "-", b2 = s2[4], y2 = s2[5], N2 = s2[6], k2 = [], F2 = s2[3], C2 = l2.exec(F2);
      for (g2 && k2.push(45);C2 != null; ) {
        if (C2[0].includes("-")) {
          let E2 = C2[0].split("-").map((d2) => d2.codePointAt(0) ?? Number.NaN);
          if (t2 = E2[0], a2 = E2[1], t2 > a2)
            throw new m2("Character range provided is out of order.");
          for (let d2 = t2;d2 <= a2; d2++)
            if (r2 && Number.isNaN(Number(String.fromCodePoint(d2)))) {
              let Ce2 = String.fromCodePoint(d2);
              k2.push(Ce2.toUpperCase().codePointAt(0) ?? Number.NaN, Ce2.toLowerCase().codePointAt(0) ?? Number.NaN);
            } else
              k2.push(d2);
        } else
          r2 && Number.isNaN(Number(C2[0])) ? k2.push(C2[0].toUpperCase().codePointAt(0) ?? Number.NaN, C2[0].toLowerCase().codePointAt(0) ?? Number.NaN) : k2.push(C2[0].codePointAt(0) ?? Number.NaN);
        F2 = F2.substring(C2[0].length), C2 = l2.exec(F2);
      }
      if (n2 = Ve2(this.faker, N2, b2, y2), f2) {
        let E2 = -1;
        for (let d2 = 48;d2 <= 57; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
        for (let d2 = 65;d2 <= 90; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
        for (let d2 = 97;d2 <= 122; d2++) {
          if (E2 = k2.indexOf(d2), E2 > -1) {
            k2.splice(E2, 1);
            continue;
          }
          k2.push(d2);
        }
      }
      let kr2 = this.multiple(() => String.fromCodePoint(this.arrayElement(k2)), { count: n2 }).join("");
      e2 = e2.slice(0, s2.index) + kr2 + e2.slice(s2.index + s2[0].length), s2 = c2.exec(e2);
    }
    let u2 = /(.)\{(\d+),(\d+)\}/;
    for (s2 = u2.exec(e2);s2 != null; ) {
      if (t2 = Number.parseInt(s2[2]), a2 = Number.parseInt(s2[3]), t2 > a2)
        throw new m2("Numbers out of order in {} quantifier.");
      n2 = this.faker.number.int({ min: t2, max: a2 }), e2 = e2.slice(0, s2.index) + s2[1].repeat(n2) + e2.slice(s2.index + s2[0].length), s2 = u2.exec(e2);
    }
    let h2 = /(.)\{(\d+)\}/;
    for (s2 = h2.exec(e2);s2 != null; )
      n2 = Number.parseInt(s2[2]), e2 = e2.slice(0, s2.index) + s2[1].repeat(n2) + e2.slice(s2.index + s2[0].length), s2 = h2.exec(e2);
    return e2;
  }
  shuffle(e2, r2 = {}) {
    let { inplace: t2 = false } = r2;
    t2 || (e2 = [...e2]);
    for (let a2 = e2.length - 1;a2 > 0; --a2) {
      let n2 = this.faker.number.int(a2);
      [e2[a2], e2[n2]] = [e2[n2], e2[a2]];
    }
    return e2;
  }
  uniqueArray(e2, r2) {
    if (Array.isArray(e2)) {
      let n2 = [...new Set(e2)];
      return this.shuffle(n2).splice(0, r2);
    }
    let t2 = new Set;
    try {
      if (typeof e2 == "function") {
        let a2 = 1000 * r2, n2 = 0;
        for (;t2.size < r2 && n2 < a2; )
          t2.add(e2()), n2++;
      }
    } catch {}
    return [...t2];
  }
  mustache(e2, r2) {
    if (e2 == null)
      return "";
    for (let t2 in r2) {
      let a2 = new RegExp(`{{${t2}}}`, "g"), n2 = r2[t2];
      typeof n2 == "string" && (n2 = n2.replaceAll("$", "$$$$")), e2 = e2.replace(a2, n2);
    }
    return e2;
  }
  maybe(e2, r2 = {}) {
    if (this.faker.datatype.boolean(r2))
      return e2();
  }
  objectKey(e2) {
    let r2 = Object.keys(e2);
    return this.arrayElement(r2);
  }
  objectValue(e2) {
    let r2 = this.faker.helpers.objectKey(e2);
    return e2[r2];
  }
  objectEntry(e2) {
    let r2 = this.faker.helpers.objectKey(e2);
    return [r2, e2[r2]];
  }
  arrayElement(e2) {
    if (e2.length === 0)
      throw new m2("Cannot get value from empty dataset.");
    let r2 = e2.length > 1 ? this.faker.number.int({ max: e2.length - 1 }) : 0;
    return e2[r2];
  }
  weightedArrayElement(e2) {
    if (e2.length === 0)
      throw new m2("weightedArrayElement expects an array with at least one element");
    if (!e2.every((n2) => n2.weight > 0))
      throw new m2("weightedArrayElement expects an array of { weight, value } objects where weight is a positive number");
    let r2 = e2.reduce((n2, { weight: o2 }) => n2 + o2, 0), t2 = this.faker.number.float({ min: 0, max: r2 }), a2 = 0;
    for (let { weight: n2, value: o2 } of e2)
      if (a2 += n2, t2 < a2)
        return o2;
    return e2.at(-1).value;
  }
  arrayElements(e2, r2) {
    if (e2.length === 0)
      return [];
    let t2 = this.rangeToNumber(r2 ?? { min: 1, max: e2.length });
    if (t2 >= e2.length)
      return this.shuffle(e2);
    if (t2 <= 0)
      return [];
    let a2 = [...e2], n2 = e2.length, o2 = n2 - t2, s2, l2;
    for (;n2-- > o2; )
      l2 = this.faker.number.int(n2), s2 = a2[l2], a2[l2] = a2[n2], a2[n2] = s2;
    return a2.slice(o2);
  }
  enumValue(e2) {
    let r2 = Object.keys(e2).filter((a2) => Number.isNaN(Number(a2))), t2 = this.arrayElement(r2);
    return e2[t2];
  }
  rangeToNumber(e2) {
    return typeof e2 == "number" ? e2 : this.faker.number.int(e2);
  }
  multiple(e2, r2 = {}) {
    let t2 = this.rangeToNumber(r2.count ?? 3);
    return t2 <= 0 ? [] : Array.from({ length: t2 }, e2);
  }
};
var W2 = class extends v2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
  fake(r2) {
    r2 = typeof r2 == "string" ? r2 : this.arrayElement(r2);
    let t2 = r2.search(/{{[a-z]/), a2 = r2.indexOf("}}", t2);
    if (t2 === -1 || a2 === -1)
      return r2;
    let o2 = r2.substring(t2 + 2, a2 + 2).replace("}}", "").replace("{{", ""), s2 = je2(o2, this.faker), l2 = String(s2), c2 = r2.substring(0, t2) + l2 + r2.substring(a2 + 2);
    return this.fake(c2);
  }
};
var $2 = class extends x2 {
  latitude(e2 = {}) {
    let { max: r2 = 90, min: t2 = -90, precision: a2 = 4 } = e2;
    return this.faker.number.float({ min: t2, max: r2, fractionDigits: a2 });
  }
  longitude(e2 = {}) {
    let { max: r2 = 180, min: t2 = -180, precision: a2 = 4 } = e2;
    return this.faker.number.float({ max: r2, min: t2, fractionDigits: a2 });
  }
  nearbyGPSCoordinate(e2 = {}) {
    let { origin: r2, radius: t2 = 10, isMetric: a2 = false } = e2;
    if (r2 == null)
      return [this.latitude(), this.longitude()];
    let n2 = this.faker.number.float({ max: 2 * Math.PI, fractionDigits: 5 }), o2 = a2 ? t2 : t2 * 1.60934, l2 = this.faker.number.float({ max: o2, fractionDigits: 3 }) * 0.995, c2 = 40000 / 360, u2 = l2 / c2, h2 = [r2[0] + Math.sin(n2) * u2, r2[1] + Math.cos(n2) * u2];
    return h2[0] = h2[0] % 180, (h2[0] < -90 || h2[0] > 90) && (h2[0] = Math.sign(h2[0]) * 180 - h2[0], h2[1] += 180), h2[1] = (h2[1] % 360 + 540) % 360 - 180, [h2[0], h2[1]];
  }
};
var Y2 = class extends $2 {
  constructor(r2) {
    super(r2);
    this.faker = r2;
  }
  zipCode(r2 = {}) {
    typeof r2 == "string" && (r2 = { format: r2 });
    let { state: t2 } = r2;
    if (t2 != null) {
      let n2 = this.faker.definitions.location.postcode_by_state[t2];
      if (n2 == null)
        throw new m2(`No zip code definition found for state "${t2}"`);
      return this.faker.helpers.fake(n2);
    }
    let { format: a2 = this.faker.definitions.location.postcode } = r2;
    return typeof a2 == "string" && (a2 = [a2]), a2 = this.faker.helpers.arrayElement(a2), this.faker.helpers.replaceSymbols(a2);
  }
  city() {
    return this.faker.helpers.fake(this.faker.definitions.location.city_pattern);
  }
  buildingNumber() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.building_number).replaceAll(/#+/g, (r2) => this.faker.string.numeric({ length: r2.length, allowLeadingZeros: false }));
  }
  street() {
    return this.faker.helpers.fake(this.faker.definitions.location.street_pattern);
  }
  streetAddress(r2 = {}) {
    typeof r2 == "boolean" && (r2 = { useFullAddress: r2 });
    let { useFullAddress: t2 } = r2, n2 = this.faker.definitions.location.street_address[t2 ? "full" : "normal"];
    return this.faker.helpers.fake(n2);
  }
  secondaryAddress() {
    return this.faker.helpers.fake(this.faker.definitions.location.secondary_address).replaceAll(/#+/g, (r2) => this.faker.string.numeric({ length: r2.length, allowLeadingZeros: false }));
  }
  county() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.county);
  }
  country() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.country);
  }
  continent() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.continent);
  }
  countryCode(r2 = {}) {
    typeof r2 == "string" && (r2 = { variant: r2 });
    let { variant: t2 = "alpha-2" } = r2, a2 = (() => {
      switch (t2) {
        case "numeric":
          return "numeric";
        case "alpha-3":
          return "alpha3";
        case "alpha-2":
          return "alpha2";
      }
    })();
    return this.faker.helpers.arrayElement(this.faker.definitions.location.country_code)[a2];
  }
  state(r2 = {}) {
    let { abbreviated: t2 = false } = r2, a2 = t2 ? this.faker.definitions.location.state_abbr : this.faker.definitions.location.state;
    return this.faker.helpers.arrayElement(a2);
  }
  direction(r2 = {}) {
    let { abbreviated: t2 = false } = r2;
    return t2 ? this.faker.helpers.arrayElement([...this.faker.definitions.location.direction.cardinal_abbr, ...this.faker.definitions.location.direction.ordinal_abbr]) : this.faker.helpers.arrayElement([...this.faker.definitions.location.direction.cardinal, ...this.faker.definitions.location.direction.ordinal]);
  }
  cardinalDirection(r2 = {}) {
    let { abbreviated: t2 = false } = r2;
    return t2 ? this.faker.helpers.arrayElement(this.faker.definitions.location.direction.cardinal_abbr) : this.faker.helpers.arrayElement(this.faker.definitions.location.direction.cardinal);
  }
  ordinalDirection(r2 = {}) {
    let { abbreviated: t2 = false } = r2;
    return t2 ? this.faker.helpers.arrayElement(this.faker.definitions.location.direction.ordinal_abbr) : this.faker.helpers.arrayElement(this.faker.definitions.location.direction.ordinal);
  }
  timeZone() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.time_zone);
  }
  language() {
    return this.faker.helpers.arrayElement(this.faker.definitions.location.language);
  }
};
var Z2 = class extends x2 {
  int(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = Number.MAX_SAFE_INTEGER, multipleOf: a2 = 1 } = e2;
    if (!Number.isInteger(a2))
      throw new m2("multipleOf should be an integer.");
    if (a2 <= 0)
      throw new m2("multipleOf should be greater than 0.");
    let n2 = Math.ceil(r2 / a2), o2 = Math.floor(t2 / a2);
    if (n2 === o2)
      return n2 * a2;
    if (o2 < n2)
      throw t2 >= r2 ? new m2(`No suitable integer value between ${r2} and ${t2} found.`) : new m2(`Max ${t2} should be greater than min ${r2}.`);
    let l2 = this.faker._randomizer.next(), c2 = o2 - n2 + 1;
    return Math.floor(l2 * c2 + n2) * a2;
  }
  float(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 1, fractionDigits: a2, multipleOf: n2, multipleOf: o2 = a2 == null ? undefined : 10 ** -a2 } = e2;
    if (t2 < r2)
      throw new m2(`Max ${t2} should be greater than min ${r2}.`);
    if (a2 != null) {
      if (n2 != null)
        throw new m2("multipleOf and fractionDigits cannot be set at the same time.");
      if (!Number.isInteger(a2))
        throw new m2("fractionDigits should be an integer.");
      if (a2 < 0)
        throw new m2("fractionDigits should be greater than or equal to 0.");
    }
    if (o2 != null) {
      if (o2 <= 0)
        throw new m2("multipleOf should be greater than 0.");
      let c2 = Math.log10(o2), u2 = o2 < 1 && Number.isInteger(c2) ? 10 ** -c2 : 1 / o2;
      return this.int({ min: r2 * u2, max: t2 * u2 }) / u2;
    }
    return this.faker._randomizer.next() * (t2 - r2) + r2;
  }
  binary(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 1 } = e2;
    return this.int({ max: t2, min: r2 }).toString(2);
  }
  octal(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 7 } = e2;
    return this.int({ max: t2, min: r2 }).toString(8);
  }
  hex(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: r2 = 0, max: t2 = 15 } = e2;
    return this.int({ max: t2, min: r2 }).toString(16);
  }
  bigInt(e2 = {}) {
    (typeof e2 == "bigint" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "boolean") && (e2 = { max: e2 });
    let r2 = BigInt(e2.min ?? 0), t2 = BigInt(e2.max ?? r2 + BigInt(999999999999999)), a2 = BigInt(e2.multipleOf ?? 1);
    if (t2 < r2)
      throw new m2(`Max ${t2} should be larger than min ${r2}.`);
    if (a2 <= BigInt(0))
      throw new m2("multipleOf should be greater than 0.");
    let n2 = r2 / a2 + (r2 % a2 > 0n ? 1n : 0n), o2 = t2 / a2 - (t2 % a2 < 0n ? 1n : 0n);
    if (n2 === o2)
      return n2 * a2;
    if (o2 < n2)
      throw new m2(`No suitable bigint value between ${r2} and ${t2} found.`);
    let s2 = o2 - n2 + 1n, l2 = BigInt(this.faker.string.numeric({ length: s2.toString(10).length, allowLeadingZeros: true })) % s2;
    return (n2 + l2) * a2;
  }
  romanNumeral(e2 = {}) {
    typeof e2 == "number" && (e2 = { max: e2 });
    let { min: a2 = 1, max: n2 = 3999 } = e2;
    if (a2 < 1)
      throw new m2(`Min value ${a2} should be 1 or greater.`);
    if (n2 > 3999)
      throw new m2(`Max value ${n2} should be 3999 or less.`);
    let o2 = this.int({ min: a2, max: n2 }), s2 = [["M", 1000], ["CM", 900], ["D", 500], ["CD", 400], ["C", 100], ["XC", 90], ["L", 50], ["XL", 40], ["X", 10], ["IX", 9], ["V", 5], ["IV", 4], ["I", 1]], l2 = "";
    for (let [c2, u2] of s2)
      l2 += c2.repeat(Math.floor(o2 / u2)), o2 %= u2;
    return l2;
  }
};
var Me2 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function ze2(i2) {
  let e2 = i2.valueOf(), r2 = "";
  for (let t2 = 10;t2 > 0; t2--) {
    let a2 = e2 % 32;
    r2 = Me2[a2] + r2, e2 = (e2 - a2) / 32;
  }
  return r2;
}
var J2 = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
var X2 = [..."abcdefghijklmnopqrstuvwxyz"];
var We2 = [..."0123456789"];
var Q2 = class extends x2 {
  fromCharacters(e2, r2 = 1) {
    if (r2 = this.faker.helpers.rangeToNumber(r2), r2 <= 0)
      return "";
    if (typeof e2 == "string" && (e2 = [...e2]), e2.length === 0)
      throw new m2("Unable to generate string: No characters to select from.");
    return this.faker.helpers.multiple(() => this.faker.helpers.arrayElement(e2), { count: r2 }).join("");
  }
  alpha(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0)
      return "";
    let { casing: t2 = "mixed" } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2;
    switch (t2) {
      case "upper": {
        n2 = [...J2];
        break;
      }
      case "lower": {
        n2 = [...X2];
        break;
      }
      case "mixed": {
        n2 = [...X2, ...J2];
        break;
      }
    }
    return n2 = n2.filter((o2) => !a2.includes(o2)), this.fromCharacters(n2, r2);
  }
  alphanumeric(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0)
      return "";
    let { casing: t2 = "mixed" } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2 = [...We2];
    switch (t2) {
      case "upper": {
        n2.push(...J2);
        break;
      }
      case "lower": {
        n2.push(...X2);
        break;
      }
      case "mixed": {
        n2.push(...X2, ...J2);
        break;
      }
    }
    return n2 = n2.filter((o2) => !a2.includes(o2)), this.fromCharacters(n2, r2);
  }
  binary(e2 = {}) {
    let { prefix: r2 = "0b" } = e2, t2 = r2;
    return t2 += this.fromCharacters(["0", "1"], e2.length ?? 1), t2;
  }
  octal(e2 = {}) {
    let { prefix: r2 = "0o" } = e2, t2 = r2;
    return t2 += this.fromCharacters(["0", "1", "2", "3", "4", "5", "6", "7"], e2.length ?? 1), t2;
  }
  hexadecimal(e2 = {}) {
    let { casing: r2 = "mixed", prefix: t2 = "0x" } = e2, a2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (a2 <= 0)
      return t2;
    let n2 = this.fromCharacters(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"], a2);
    return r2 === "upper" ? n2 = n2.toUpperCase() : r2 === "lower" && (n2 = n2.toLowerCase()), `${t2}${n2}`;
  }
  numeric(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let r2 = this.faker.helpers.rangeToNumber(e2.length ?? 1);
    if (r2 <= 0)
      return "";
    let { allowLeadingZeros: t2 = true } = e2, { exclude: a2 = [] } = e2;
    typeof a2 == "string" && (a2 = [...a2]);
    let n2 = We2.filter((s2) => !a2.includes(s2));
    if (n2.length === 0 || n2.length === 1 && !t2 && n2[0] === "0")
      throw new m2("Unable to generate numeric string, because all possible digits are excluded.");
    let o2 = "";
    return !t2 && !a2.includes("0") && (o2 += this.faker.helpers.arrayElement(n2.filter((s2) => s2 !== "0"))), o2 += this.fromCharacters(n2, r2 - o2.length), o2;
  }
  sample(e2 = 10) {
    e2 = this.faker.helpers.rangeToNumber(e2);
    let r2 = { min: 33, max: 125 }, t2 = "";
    for (;t2.length < e2; )
      t2 += String.fromCodePoint(this.faker.number.int(r2));
    return t2;
  }
  uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replaceAll("x", () => this.faker.number.hex({ min: 0, max: 15 })).replaceAll("y", () => this.faker.number.hex({ min: 8, max: 11 }));
  }
  ulid(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = S2(r2);
    return ze2(t2) + this.fromCharacters(Me2, 16);
  }
  nanoid(e2 = 21) {
    if (e2 = this.faker.helpers.rangeToNumber(e2), e2 <= 0)
      return "";
    let r2 = [{ value: () => this.alphanumeric(1), weight: 62 }, { value: () => this.faker.helpers.arrayElement(["_", "-"]), weight: 2 }], t2 = "";
    for (;t2.length < e2; ) {
      let a2 = this.faker.helpers.weightedArrayElement(r2);
      t2 += a2();
    }
    return t2;
  }
  symbol(e2 = 1) {
    return this.fromCharacters(["!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"], e2);
  }
};
var I2 = class {
  _defaultRefDate = () => new Date;
  get defaultRefDate() {
    return this._defaultRefDate;
  }
  setDefaultRefDate(e2 = () => new Date) {
    typeof e2 == "function" ? this._defaultRefDate = e2 : this._defaultRefDate = () => new Date(e2);
  }
  _randomizer;
  datatype = new j2(this);
  date = new B2(this);
  helpers = new v2(this);
  location = new $2(this);
  number = new Z2(this);
  string = new Q2(this);
  constructor(e2 = {}) {
    let { randomizer: r2, seed: t2 } = e2;
    r2 != null && t2 != null && r2.seed(t2), this._randomizer = r2 ?? Ue2(t2);
  }
  seed(e2 = P2()) {
    return this._randomizer.seed(e2), e2;
  }
};
var ka2 = new I2;
function Ye2(i2) {
  let e2 = {};
  for (let r2 of i2)
    for (let t2 in r2) {
      let a2 = r2[t2];
      e2[t2] === undefined ? e2[t2] = { ...a2 } : e2[t2] = { ...a2, ...e2[t2] };
    }
  return e2;
}
var q2 = class extends p3 {
  dog() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.dog);
  }
  cat() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cat);
  }
  snake() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.snake);
  }
  bear() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.bear);
  }
  lion() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.lion);
  }
  cetacean() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cetacean);
  }
  horse() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.horse);
  }
  bird() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.bird);
  }
  cow() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.cow);
  }
  fish() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.fish);
  }
  crocodilia() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.crocodilia);
  }
  insect() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.insect);
  }
  rabbit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.rabbit);
  }
  rodent() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.rodent);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.type);
  }
  petName() {
    return this.faker.helpers.arrayElement(this.faker.definitions.animal.pet_name);
  }
};
var ee2 = class extends p3 {
  author() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.author);
  }
  format() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.format);
  }
  genre() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.genre);
  }
  publisher() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.publisher);
  }
  series() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.series);
  }
  title() {
    return this.faker.helpers.arrayElement(this.faker.definitions.book.title);
  }
};
var Vr = { 0: [[1999999, 2], [2279999, 3], [2289999, 4], [3689999, 3], [3699999, 4], [6389999, 3], [6397999, 4], [6399999, 7], [6449999, 3], [6459999, 7], [6479999, 3], [6489999, 7], [6549999, 3], [6559999, 4], [6999999, 3], [8499999, 4], [8999999, 5], [9499999, 6], [9999999, 7]], 1: [[99999, 3], [299999, 2], [349999, 3], [399999, 4], [499999, 3], [699999, 2], [999999, 4], [3979999, 3], [5499999, 4], [6499999, 5], [6799999, 4], [6859999, 5], [7139999, 4], [7169999, 3], [7319999, 4], [7399999, 7], [7749999, 5], [7753999, 7], [7763999, 5], [7764999, 7], [7769999, 5], [7782999, 7], [7899999, 5], [7999999, 4], [8004999, 5], [8049999, 5], [8379999, 5], [8384999, 7], [8671999, 5], [8675999, 4], [8697999, 5], [9159999, 6], [9165059, 7], [9168699, 6], [9169079, 7], [9195999, 6], [9196549, 7], [9729999, 6], [9877999, 4], [9911499, 6], [9911999, 7], [9989899, 6], [9999999, 7]] };
var re2 = class extends p3 {
  department() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.department);
  }
  productName() {
    return `${this.productAdjective()} ${this.productMaterial()} ${this.product()}`;
  }
  price(e2 = {}) {
    let { dec: r2 = 2, max: t2 = 1000, min: a2 = 1, symbol: n2 = "" } = e2;
    if (a2 < 0 || t2 < 0)
      return `${n2}0`;
    if (a2 === t2)
      return `${n2}${a2.toFixed(r2)}`;
    let o2 = this.faker.number.float({ min: a2, max: t2, fractionDigits: r2 });
    if (r2 === 0)
      return `${n2}${o2.toFixed(r2)}`;
    let s2 = o2 * 10 ** r2 % 10, l2 = this.faker.helpers.weightedArrayElement([{ weight: 5, value: 9 }, { weight: 3, value: 5 }, { weight: 1, value: 0 }, { weight: 1, value: this.faker.number.int({ min: 0, max: 9 }) }]), c2 = (1 / 10) ** r2, u2 = s2 * c2, h2 = l2 * c2, f2 = o2 - u2 + h2;
    return a2 <= f2 && f2 <= t2 ? `${n2}${f2.toFixed(r2)}` : `${n2}${o2.toFixed(r2)}`;
  }
  productAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.adjective);
  }
  productMaterial() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.material);
  }
  product() {
    return this.faker.helpers.arrayElement(this.faker.definitions.commerce.product_name.product);
  }
  productDescription() {
    return this.faker.helpers.fake(this.faker.definitions.commerce.product_description);
  }
  isbn(e2 = {}) {
    typeof e2 == "number" && (e2 = { variant: e2 });
    let { variant: r2 = 13, separator: t2 = "-" } = e2, a2 = "978", [n2, o2] = this.faker.helpers.objectEntry(Vr), s2 = this.faker.string.numeric(8), l2 = Number.parseInt(s2.slice(0, -1)), c2 = o2.find(([y2]) => l2 <= y2)?.[1];
    if (!c2)
      throw new m2(`Unable to find a registrant length for the group ${n2}`);
    let u2 = s2.slice(0, c2), h2 = s2.slice(c2), f2 = [a2, n2, u2, h2];
    r2 === 10 && f2.shift();
    let g2 = f2.join(""), b2 = 0;
    for (let y2 = 0;y2 < r2 - 1; y2++) {
      let N2 = r2 === 10 ? y2 + 1 : y2 % 2 ? 3 : 1;
      b2 += N2 * Number.parseInt(g2[y2]);
    }
    return b2 = r2 === 10 ? b2 % 11 : (10 - b2 % 10) % 10, f2.push(b2 === 10 ? "X" : b2.toString()), f2.join(t2);
  }
};
var te2 = class extends p3 {
  name() {
    return this.faker.helpers.fake(this.faker.definitions.company.name_pattern);
  }
  catchPhrase() {
    return [this.catchPhraseAdjective(), this.catchPhraseDescriptor(), this.catchPhraseNoun()].join(" ");
  }
  buzzPhrase() {
    return [this.buzzVerb(), this.buzzAdjective(), this.buzzNoun()].join(" ");
  }
  catchPhraseAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.adjective);
  }
  catchPhraseDescriptor() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.descriptor);
  }
  catchPhraseNoun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.noun);
  }
  buzzAdjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_adjective);
  }
  buzzVerb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_verb);
  }
  buzzNoun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.company.buzz_noun);
  }
};
var ae2 = class extends p3 {
  column() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.column);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.type);
  }
  collation() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.collation);
  }
  engine() {
    return this.faker.helpers.arrayElement(this.faker.definitions.database.engine);
  }
  mongodbObjectId() {
    return this.faker.string.hexadecimal({ length: 24, casing: "lower", prefix: "" });
  }
};
var zr = { alpha: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], formats: [{ country: "AL", total: 28, bban: [{ type: "n", count: 8 }, { type: "c", count: 16 }], format: "ALkk bbbs sssx cccc cccc cccc cccc" }, { country: "AD", total: 24, bban: [{ type: "n", count: 8 }, { type: "c", count: 12 }], format: "ADkk bbbb ssss cccc cccc cccc" }, { country: "AT", total: 20, bban: [{ type: "n", count: 5 }, { type: "n", count: 11 }], format: "ATkk bbbb bccc cccc cccc" }, { country: "AZ", total: 28, bban: [{ type: "a", count: 4 }, { type: "n", count: 20 }], format: "AZkk bbbb cccc cccc cccc cccc cccc" }, { country: "BH", total: 22, bban: [{ type: "a", count: 4 }, { type: "c", count: 14 }], format: "BHkk bbbb cccc cccc cccc cc" }, { country: "BE", total: 16, bban: [{ type: "n", count: 3 }, { type: "n", count: 9 }], format: "BEkk bbbc cccc ccxx" }, { country: "BA", total: 20, bban: [{ type: "n", count: 6 }, { type: "n", count: 10 }], format: "BAkk bbbs sscc cccc ccxx" }, { country: "BR", total: 29, bban: [{ type: "n", count: 13 }, { type: "n", count: 10 }, { type: "a", count: 1 }, { type: "c", count: 1 }], format: "BRkk bbbb bbbb ssss sccc cccc ccct n" }, { country: "BG", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "c", count: 8 }], format: "BGkk bbbb ssss ddcc cccc cc" }, { country: "CR", total: 22, bban: [{ type: "n", count: 1 }, { type: "n", count: 3 }, { type: "n", count: 14 }], format: "CRkk xbbb cccc cccc cccc cc" }, { country: "HR", total: 21, bban: [{ type: "n", count: 7 }, { type: "n", count: 10 }], format: "HRkk bbbb bbbc cccc cccc c" }, { country: "CY", total: 28, bban: [{ type: "n", count: 8 }, { type: "c", count: 16 }], format: "CYkk bbbs ssss cccc cccc cccc cccc" }, { country: "CZ", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "CZkk bbbb ssss sscc cccc cccc" }, { country: "DK", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "DKkk bbbb cccc cccc cc" }, { country: "DO", total: 28, bban: [{ type: "a", count: 4 }, { type: "n", count: 20 }], format: "DOkk bbbb cccc cccc cccc cccc cccc" }, { country: "TL", total: 23, bban: [{ type: "n", count: 3 }, { type: "n", count: 16 }], format: "TLkk bbbc cccc cccc cccc cxx" }, { country: "EE", total: 20, bban: [{ type: "n", count: 4 }, { type: "n", count: 12 }], format: "EEkk bbss cccc cccc cccx" }, { country: "FO", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "FOkk bbbb cccc cccc cx" }, { country: "FI", total: 18, bban: [{ type: "n", count: 6 }, { type: "n", count: 8 }], format: "FIkk bbbb bbcc cccc cx" }, { country: "FR", total: 27, bban: [{ type: "n", count: 10 }, { type: "c", count: 11 }, { type: "n", count: 2 }], format: "FRkk bbbb bggg ggcc cccc cccc cxx" }, { country: "GE", total: 22, bban: [{ type: "a", count: 2 }, { type: "n", count: 16 }], format: "GEkk bbcc cccc cccc cccc cc" }, { country: "DE", total: 22, bban: [{ type: "n", count: 8 }, { type: "n", count: 10 }], format: "DEkk bbbb bbbb cccc cccc cc" }, { country: "GI", total: 23, bban: [{ type: "a", count: 4 }, { type: "c", count: 15 }], format: "GIkk bbbb cccc cccc cccc ccc" }, { country: "GR", total: 27, bban: [{ type: "n", count: 7 }, { type: "c", count: 16 }], format: "GRkk bbbs sssc cccc cccc cccc ccc" }, { country: "GL", total: 18, bban: [{ type: "n", count: 4 }, { type: "n", count: 10 }], format: "GLkk bbbb cccc cccc cc" }, { country: "GT", total: 28, bban: [{ type: "c", count: 4 }, { type: "c", count: 4 }, { type: "c", count: 16 }], format: "GTkk bbbb mmtt cccc cccc cccc cccc" }, { country: "HU", total: 28, bban: [{ type: "n", count: 8 }, { type: "n", count: 16 }], format: "HUkk bbbs sssk cccc cccc cccc cccx" }, { country: "IS", total: 26, bban: [{ type: "n", count: 6 }, { type: "n", count: 16 }], format: "ISkk bbbb sscc cccc iiii iiii ii" }, { country: "IE", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "n", count: 8 }], format: "IEkk aaaa bbbb bbcc cccc cc" }, { country: "IL", total: 23, bban: [{ type: "n", count: 6 }, { type: "n", count: 13 }], format: "ILkk bbbn nncc cccc cccc ccc" }, { country: "IT", total: 27, bban: [{ type: "a", count: 1 }, { type: "n", count: 10 }, { type: "c", count: 12 }], format: "ITkk xaaa aabb bbbc cccc cccc ccc" }, { country: "JO", total: 30, bban: [{ type: "a", count: 4 }, { type: "n", count: 4 }, { type: "n", count: 18 }], format: "JOkk bbbb nnnn cccc cccc cccc cccc cc" }, { country: "KZ", total: 20, bban: [{ type: "n", count: 3 }, { type: "c", count: 13 }], format: "KZkk bbbc cccc cccc cccc" }, { country: "XK", total: 20, bban: [{ type: "n", count: 4 }, { type: "n", count: 12 }], format: "XKkk bbbb cccc cccc cccc" }, { country: "KW", total: 30, bban: [{ type: "a", count: 4 }, { type: "c", count: 22 }], format: "KWkk bbbb cccc cccc cccc cccc cccc cc" }, { country: "LV", total: 21, bban: [{ type: "a", count: 4 }, { type: "c", count: 13 }], format: "LVkk bbbb cccc cccc cccc c" }, { country: "LB", total: 28, bban: [{ type: "n", count: 4 }, { type: "c", count: 20 }], format: "LBkk bbbb cccc cccc cccc cccc cccc" }, { country: "LI", total: 21, bban: [{ type: "n", count: 5 }, { type: "c", count: 12 }], format: "LIkk bbbb bccc cccc cccc c" }, { country: "LT", total: 20, bban: [{ type: "n", count: 5 }, { type: "n", count: 11 }], format: "LTkk bbbb bccc cccc cccc" }, { country: "LU", total: 20, bban: [{ type: "n", count: 3 }, { type: "c", count: 13 }], format: "LUkk bbbc cccc cccc cccc" }, { country: "MK", total: 19, bban: [{ type: "n", count: 3 }, { type: "c", count: 10 }, { type: "n", count: 2 }], format: "MKkk bbbc cccc cccc cxx" }, { country: "MT", total: 31, bban: [{ type: "a", count: 4 }, { type: "n", count: 5 }, { type: "c", count: 18 }], format: "MTkk bbbb ssss sccc cccc cccc cccc ccc" }, { country: "MR", total: 27, bban: [{ type: "n", count: 10 }, { type: "n", count: 13 }], format: "MRkk bbbb bsss sscc cccc cccc cxx" }, { country: "MU", total: 30, bban: [{ type: "a", count: 4 }, { type: "n", count: 4 }, { type: "n", count: 15 }, { type: "a", count: 3 }], format: "MUkk bbbb bbss cccc cccc cccc 000d dd" }, { country: "MC", total: 27, bban: [{ type: "n", count: 10 }, { type: "c", count: 11 }, { type: "n", count: 2 }], format: "MCkk bbbb bsss sscc cccc cccc cxx" }, { country: "MD", total: 24, bban: [{ type: "c", count: 2 }, { type: "c", count: 18 }], format: "MDkk bbcc cccc cccc cccc cccc" }, { country: "ME", total: 22, bban: [{ type: "n", count: 3 }, { type: "n", count: 15 }], format: "MEkk bbbc cccc cccc cccc xx" }, { country: "NL", total: 18, bban: [{ type: "a", count: 4 }, { type: "n", count: 10 }], format: "NLkk bbbb cccc cccc cc" }, { country: "NO", total: 15, bban: [{ type: "n", count: 4 }, { type: "n", count: 7 }], format: "NOkk bbbb cccc ccx" }, { country: "PK", total: 24, bban: [{ type: "a", count: 4 }, { type: "n", count: 16 }], format: "PKkk bbbb cccc cccc cccc cccc" }, { country: "PS", total: 29, bban: [{ type: "a", count: 4 }, { type: "n", count: 9 }, { type: "n", count: 12 }], format: "PSkk bbbb xxxx xxxx xccc cccc cccc c" }, { country: "PL", total: 28, bban: [{ type: "n", count: 8 }, { type: "n", count: 16 }], format: "PLkk bbbs sssx cccc cccc cccc cccc" }, { country: "PT", total: 25, bban: [{ type: "n", count: 8 }, { type: "n", count: 13 }], format: "PTkk bbbb ssss cccc cccc cccx x" }, { country: "QA", total: 29, bban: [{ type: "a", count: 4 }, { type: "c", count: 21 }], format: "QAkk bbbb cccc cccc cccc cccc cccc c" }, { country: "RO", total: 24, bban: [{ type: "a", count: 4 }, { type: "c", count: 16 }], format: "ROkk bbbb cccc cccc cccc cccc" }, { country: "SM", total: 27, bban: [{ type: "a", count: 1 }, { type: "n", count: 10 }, { type: "c", count: 12 }], format: "SMkk xaaa aabb bbbc cccc cccc ccc" }, { country: "SA", total: 24, bban: [{ type: "n", count: 2 }, { type: "c", count: 18 }], format: "SAkk bbcc cccc cccc cccc cccc" }, { country: "RS", total: 22, bban: [{ type: "n", count: 3 }, { type: "n", count: 15 }], format: "RSkk bbbc cccc cccc cccc xx" }, { country: "SK", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "SKkk bbbb ssss sscc cccc cccc" }, { country: "SI", total: 19, bban: [{ type: "n", count: 5 }, { type: "n", count: 10 }], format: "SIkk bbss sccc cccc cxx" }, { country: "ES", total: 24, bban: [{ type: "n", count: 10 }, { type: "n", count: 10 }], format: "ESkk bbbb gggg xxcc cccc cccc" }, { country: "SE", total: 24, bban: [{ type: "n", count: 3 }, { type: "n", count: 17 }], format: "SEkk bbbc cccc cccc cccc cccc" }, { country: "CH", total: 21, bban: [{ type: "n", count: 5 }, { type: "c", count: 12 }], format: "CHkk bbbb bccc cccc cccc c" }, { country: "TN", total: 24, bban: [{ type: "n", count: 5 }, { type: "n", count: 15 }], format: "TNkk bbss sccc cccc cccc cccc" }, { country: "TR", total: 26, bban: [{ type: "n", count: 5 }, { type: "n", count: 1 }, { type: "n", count: 16 }], format: "TRkk bbbb bxcc cccc cccc cccc cc" }, { country: "AE", total: 23, bban: [{ type: "n", count: 3 }, { type: "n", count: 16 }], format: "AEkk bbbc cccc cccc cccc ccc" }, { country: "GB", total: 22, bban: [{ type: "a", count: 4 }, { type: "n", count: 6 }, { type: "n", count: 8 }], format: "GBkk bbbb ssss sscc cccc cc" }, { country: "VG", total: 24, bban: [{ type: "a", count: 4 }, { type: "n", count: 16 }], format: "VGkk bbbb cccc cccc cccc cccc" }], iso3166: ["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"], mod97: (i2) => {
  let e2 = 0;
  for (let r2 of i2)
    e2 = (e2 * 10 + +r2) % 97;
  return e2;
}, pattern10: ["01", "02", "03", "04", "05", "06", "07", "08", "09"], pattern100: ["001", "002", "003", "004", "005", "006", "007", "008", "009"], toDigitString: (i2) => i2.replaceAll(/[A-Z]/gi, (e2) => String((e2.toUpperCase().codePointAt(0) ?? Number.NaN) - 55)) };
var M2 = zr;
function Wr(i2) {
  let e2 = "";
  for (let r2 = 0;r2 < i2.length; r2 += 4)
    e2 += `${i2.substring(r2, r2 + 4)} `;
  return e2.trimEnd();
}
var ne2 = class extends p3 {
  accountNumber(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let { length: r2 = 8 } = e2;
    return this.faker.string.numeric({ length: r2, allowLeadingZeros: true });
  }
  accountName() {
    return [this.faker.helpers.arrayElement(this.faker.definitions.finance.account_type), "Account"].join(" ");
  }
  routingNumber() {
    let e2 = this.faker.string.numeric({ length: 8, allowLeadingZeros: true }), r2 = 0;
    for (let t2 = 0;t2 < e2.length; t2 += 3)
      r2 += Number(e2[t2]) * 3, r2 += Number(e2[t2 + 1]) * 7, r2 += Number(e2[t2 + 2]) || 0;
    return `${e2}${Math.ceil(r2 / 10) * 10 - r2}`;
  }
  maskedNumber(e2 = {}) {
    w2({ deprecated: "faker.finance.maskedNumber()", proposed: "faker.finance.iban().replace(/(?<=.{4})\\w(?=.{2})/g, '*') or a similar approach", since: "9.3.0", until: "10.0.0" }), typeof e2 == "number" && (e2 = { length: e2 });
    let { ellipsis: r2 = true, length: t2 = 4, parens: a2 = true } = e2, n2 = this.faker.string.numeric({ length: t2 });
    return r2 && (n2 = `...${n2}`), a2 && (n2 = `(${n2})`), n2;
  }
  amount(e2 = {}) {
    let { autoFormat: r2 = false, dec: t2 = 2, max: a2 = 1000, min: n2 = 0, symbol: o2 = "" } = e2, s2 = this.faker.number.float({ max: a2, min: n2, fractionDigits: t2 }), l2 = r2 ? s2.toLocaleString(undefined, { minimumFractionDigits: t2 }) : s2.toFixed(t2);
    return o2 + l2;
  }
  transactionType() {
    return this.faker.helpers.arrayElement(this.faker.definitions.finance.transaction_type);
  }
  currency() {
    return this.faker.helpers.arrayElement(this.faker.definitions.finance.currency);
  }
  currencyCode() {
    return this.currency().code;
  }
  currencyName() {
    return this.currency().name;
  }
  currencySymbol() {
    let e2;
    do
      e2 = this.currency().symbol;
    while (e2.length === 0);
    return e2;
  }
  currencyNumericCode() {
    return this.currency().numericCode;
  }
  bitcoinAddress(e2 = {}) {
    let { type: r2 = this.faker.helpers.enumValue(de2), network: t2 = "mainnet" } = e2, a2 = ve2[r2], n2 = a2.prefix[t2], o2 = this.faker.number.int(a2.length), s2 = this.faker.string.alphanumeric({ length: o2 - n2.length, casing: a2.casing, exclude: a2.exclude });
    return n2 + s2;
  }
  litecoinAddress() {
    let e2 = this.faker.number.int({ min: 26, max: 33 });
    return this.faker.string.fromCharacters("LM3") + this.faker.string.fromCharacters("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", e2 - 1);
  }
  creditCardNumber(e2 = {}) {
    typeof e2 == "string" && (e2 = { issuer: e2 });
    let { issuer: r2 = "" } = e2, t2, a2 = this.faker.definitions.finance.credit_card, n2 = r2.toLowerCase();
    if (n2 in a2)
      t2 = this.faker.helpers.arrayElement(a2[n2]);
    else if (r2.includes("#"))
      t2 = r2;
    else {
      let o2 = this.faker.helpers.objectValue(a2);
      t2 = this.faker.helpers.arrayElement(o2);
    }
    return t2 = t2.replaceAll("/", ""), this.faker.helpers.replaceCreditCardSymbols(t2);
  }
  creditCardCVV() {
    return this.faker.string.numeric({ length: 3, allowLeadingZeros: true });
  }
  creditCardIssuer() {
    return this.faker.helpers.objectKey(this.faker.definitions.finance.credit_card);
  }
  pin(e2 = {}) {
    typeof e2 == "number" && (e2 = { length: e2 });
    let { length: r2 = 4 } = e2;
    if (r2 < 1)
      throw new m2("minimum length is 1");
    return this.faker.string.numeric({ length: r2, allowLeadingZeros: true });
  }
  ethereumAddress() {
    return this.faker.string.hexadecimal({ length: 40, casing: "lower" });
  }
  iban(e2 = {}) {
    let { countryCode: r2, formatted: t2 = false } = e2, a2 = r2 ? M2.formats.find((c2) => c2.country === r2) : this.faker.helpers.arrayElement(M2.formats);
    if (!a2)
      throw new m2(`Country code ${r2} not supported.`);
    let n2 = "", o2 = 0;
    for (let c2 of a2.bban) {
      let u2 = c2.count;
      for (o2 += c2.count;u2 > 0; )
        c2.type === "a" ? n2 += this.faker.helpers.arrayElement(M2.alpha) : c2.type === "c" ? this.faker.datatype.boolean(0.8) ? n2 += this.faker.number.int(9) : n2 += this.faker.helpers.arrayElement(M2.alpha) : u2 >= 3 && this.faker.datatype.boolean(0.3) ? this.faker.datatype.boolean() ? (n2 += this.faker.helpers.arrayElement(M2.pattern100), u2 -= 2) : (n2 += this.faker.helpers.arrayElement(M2.pattern10), u2--) : n2 += this.faker.number.int(9), u2--;
      n2 = n2.substring(0, o2);
    }
    let s2 = 98 - M2.mod97(M2.toDigitString(`${n2}${a2.country}00`));
    s2 < 10 && (s2 = `0${s2}`);
    let l2 = `${a2.country}${s2}${n2}`;
    return t2 ? Wr(l2) : l2;
  }
  bic(e2 = {}) {
    let { includeBranchCode: r2 = this.faker.datatype.boolean() } = e2, t2 = this.faker.string.alpha({ length: 4, casing: "upper" }), a2 = this.faker.helpers.arrayElement(M2.iso3166), n2 = this.faker.string.alphanumeric({ length: 2, casing: "upper" }), o2 = r2 ? this.faker.datatype.boolean() ? this.faker.string.alphanumeric({ length: 3, casing: "upper" }) : "XXX" : "";
    return `${t2}${a2}${n2}${o2}`;
  }
  transactionDescription() {
    return this.faker.helpers.fake(this.faker.definitions.finance.transaction_description_pattern);
  }
};
function Ze2(i2) {
  return i2.split(" ").map((e2) => e2.charAt(0).toUpperCase() + e2.slice(1)).join(" ");
}
var ie2 = class extends p3 {
  adjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.adjective);
  }
  description() {
    return this.faker.helpers.fake(this.faker.definitions.food.description_pattern);
  }
  dish() {
    return this.faker.datatype.boolean() ? Ze2(this.faker.helpers.fake(this.faker.definitions.food.dish_pattern)) : Ze2(this.faker.helpers.arrayElement(this.faker.definitions.food.dish));
  }
  ethnicCategory() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.ethnic_category);
  }
  fruit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.fruit);
  }
  ingredient() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.ingredient);
  }
  meat() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.meat);
  }
  spice() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.spice);
  }
  vegetable() {
    return this.faker.helpers.arrayElement(this.faker.definitions.food.vegetable);
  }
};
var Yr = "\xA0";
var oe2 = class extends p3 {
  branch() {
    let e2 = this.faker.hacker.noun().replace(" ", "-"), r2 = this.faker.hacker.verb().replace(" ", "-");
    return `${e2}-${r2}`;
  }
  commitEntry(e2 = {}) {
    let { merge: r2 = this.faker.datatype.boolean({ probability: 0.2 }), eol: t2 = "CRLF", refDate: a2 } = e2, n2 = [`commit ${this.faker.git.commitSha()}`];
    r2 && n2.push(`Merge: ${this.commitSha({ length: 7 })} ${this.commitSha({ length: 7 })}`);
    let o2 = this.faker.person.firstName(), s2 = this.faker.person.lastName(), l2 = this.faker.person.fullName({ firstName: o2, lastName: s2 }), c2 = this.faker.internet.username({ firstName: o2, lastName: s2 }), u2 = this.faker.helpers.arrayElement([l2, c2]), h2 = this.faker.internet.email({ firstName: o2, lastName: s2 });
    u2 = u2.replaceAll(/^[.,:;"\\']|[<>\n]|[.,:;"\\']$/g, ""), n2.push(`Author: ${u2} <${h2}>`, `Date: ${this.commitDate({ refDate: a2 })}`, "", `${Yr.repeat(4)}${this.commitMessage()}`, "");
    let f2 = t2 === "CRLF" ? `\r
` : `
`;
    return n2.join(f2);
  }
  commitMessage() {
    return `${this.faker.hacker.verb()} ${this.faker.hacker.adjective()} ${this.faker.hacker.noun()}`;
  }
  commitDate(e2 = {}) {
    let { refDate: r2 = this.faker.defaultRefDate() } = e2, t2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], a2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], n2 = this.faker.date.recent({ days: 1, refDate: r2 }), o2 = t2[n2.getUTCDay()], s2 = a2[n2.getUTCMonth()], l2 = n2.getUTCDate(), c2 = n2.getUTCHours().toString().padStart(2, "0"), u2 = n2.getUTCMinutes().toString().padStart(2, "0"), h2 = n2.getUTCSeconds().toString().padStart(2, "0"), f2 = n2.getUTCFullYear(), g2 = this.faker.number.int({ min: -11, max: 12 }), b2 = Math.abs(g2).toString().padStart(2, "0"), y2 = "00", N2 = g2 >= 0 ? "+" : "-";
    return `${o2} ${s2} ${l2} ${c2}:${u2}:${h2} ${f2} ${N2}${b2}${y2}`;
  }
  commitSha(e2 = {}) {
    let { length: r2 = 40 } = e2;
    return this.faker.string.hexadecimal({ length: r2, casing: "lower", prefix: "" });
  }
};
var se2 = class extends p3 {
  abbreviation() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.abbreviation);
  }
  adjective() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.adjective);
  }
  noun() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.noun);
  }
  verb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.verb);
  }
  ingverb() {
    return this.faker.helpers.arrayElement(this.faker.definitions.hacker.ingverb);
  }
  phrase() {
    let e2 = { abbreviation: this.abbreviation, adjective: this.adjective, ingverb: this.ingverb, noun: this.noun, verb: this.verb }, r2 = this.faker.helpers.arrayElement(this.faker.definitions.hacker.phrase);
    return this.faker.helpers.mustache(r2, e2);
  }
};
var ce2 = class extends p3 {
  avatar() {
    return this.faker.helpers.arrayElement([this.personPortrait, this.avatarGitHub])();
  }
  avatarGitHub() {
    return `https://avatars.githubusercontent.com/u/${this.faker.number.int(1e8)}`;
  }
  personPortrait(e2 = {}) {
    let { sex: r2 = this.faker.person.sexType(), size: t2 = 512 } = e2;
    return `https://cdn.jsdelivr.net/gh/faker-js/assets-person-portrait/${r2}/${t2}/${this.faker.number.int({ min: 0, max: 99 })}.jpg`;
  }
  avatarLegacy() {
    return w2({ deprecated: "faker.image.avatarLegacy()", proposed: "faker.image.avatar() or faker.image.personPortrait()", since: "9.0.2", until: "10.0.0" }), `https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/${this.faker.number.int(1249)}.jpg`;
  }
  url(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }) } = e2;
    return this.faker.helpers.arrayElement([this.urlLoremFlickr, ({ width: n2, height: o2 }) => this.urlPicsumPhotos({ width: n2, height: o2, grayscale: false, blur: 0 })])({ width: r2, height: t2 });
  }
  urlLoremFlickr(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), category: a2 } = e2;
    return `https://loremflickr.com/${r2}/${t2}${a2 == null ? "" : `/${a2}`}?lock=${this.faker.number.int()}`;
  }
  urlPicsumPhotos(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), grayscale: a2 = this.faker.datatype.boolean(), blur: n2 = this.faker.number.int({ max: 10 }) } = e2, o2 = `https://picsum.photos/seed/${this.faker.string.alphanumeric({ length: { min: 5, max: 10 } })}/${r2}/${t2}`, s2 = typeof n2 == "number" && n2 >= 1 && n2 <= 10;
    return (a2 || s2) && (o2 += "?", a2 && (o2 += "grayscale"), a2 && s2 && (o2 += "&"), s2 && (o2 += `blur=${n2}`)), o2;
  }
  urlPlaceholder(e2 = {}) {
    w2({ deprecated: "faker.image.urlPlaceholder()", proposed: "faker.image.url() or faker.image.dataUri()", since: "9.4.0", until: "10.0.0" });
    let { width: r2 = this.faker.number.int({ min: 1, max: 3500 }), height: t2 = this.faker.number.int({ min: 1, max: 3500 }), backgroundColor: a2 = this.faker.color.rgb({ format: "hex", prefix: "" }), textColor: n2 = this.faker.color.rgb({ format: "hex", prefix: "" }), format: o2 = this.faker.helpers.arrayElement(["gif", "jpeg", "jpg", "png", "webp"]), text: s2 = this.faker.lorem.words() } = e2, l2 = "https://via.placeholder.com";
    return l2 += `/${r2}`, l2 += `x${t2}`, l2 += `/${a2}`, l2 += `/${n2}`, l2 += `.${o2}`, l2 += `?text=${encodeURIComponent(s2)}`, l2;
  }
  dataUri(e2 = {}) {
    let { width: r2 = this.faker.number.int({ min: 1, max: 3999 }), height: t2 = this.faker.number.int({ min: 1, max: 3999 }), color: a2 = this.faker.color.rgb(), type: n2 = this.faker.helpers.arrayElement(["svg-uri", "svg-base64"]) } = e2, o2 = `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" baseProfile="full" width="${r2}" height="${t2}"><rect width="100%" height="100%" fill="${a2}"/><text x="${r2 / 2}" y="${t2 / 2}" font-size="20" alignment-baseline="middle" text-anchor="middle" fill="white">${r2}x${t2}</text></svg>`;
    return n2 === "svg-uri" ? `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(o2)}` : `data:image/svg+xml;base64,${ge2(o2)}`;
  }
};
function Je2(i2, e2, r2 = (t2) => t2) {
  let t2 = {};
  for (let a2 of i2) {
    let n2 = e2(a2);
    t2[n2] === undefined && (t2[n2] = []), t2[n2].push(r2(a2));
  }
  return t2;
}
var Te2 = { fail: () => {
  throw new m2("No words found that match the given length.");
}, closest: (i2, e2) => {
  let r2 = Je2(i2, (s2) => s2.length), t2 = Object.keys(r2).map(Number), a2 = Math.min(...t2), n2 = Math.max(...t2), o2 = Math.min(e2.min - a2, n2 - e2.max);
  return i2.filter((s2) => s2.length === e2.min - o2 || s2.length === e2.max + o2);
}, shortest: (i2) => {
  let e2 = Math.min(...i2.map((r2) => r2.length));
  return i2.filter((r2) => r2.length === e2);
}, longest: (i2) => {
  let e2 = Math.max(...i2.map((r2) => r2.length));
  return i2.filter((r2) => r2.length === e2);
}, "any-length": (i2) => [...i2] };
function T2(i2) {
  let { wordList: e2, length: r2, strategy: t2 = "any-length" } = i2;
  if (r2 != null) {
    let a2 = typeof r2 == "number" ? (o2) => o2.length === r2 : (o2) => o2.length >= r2.min && o2.length <= r2.max, n2 = e2.filter(a2);
    return n2.length > 0 ? n2 : typeof r2 == "number" ? Te2[t2](e2, { min: r2, max: r2 }) : Te2[t2](e2, r2);
  } else if (t2 === "shortest" || t2 === "longest")
    return Te2[t2](e2);
  return [...e2];
}
var le2 = class extends p3 {
  word(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.lorem.word }));
  }
  words(e2 = 3) {
    return this.faker.helpers.multiple(() => this.word(), { count: e2 }).join(" ");
  }
  sentence(e2 = { min: 3, max: 10 }) {
    let r2 = this.words(e2);
    return `${r2.charAt(0).toUpperCase() + r2.substring(1)}.`;
  }
  slug(e2 = 3) {
    let r2 = this.words(e2);
    return this.faker.helpers.slugify(r2);
  }
  sentences(e2 = { min: 2, max: 6 }, r2 = " ") {
    return this.faker.helpers.multiple(() => this.sentence(), { count: e2 }).join(r2);
  }
  paragraph(e2 = 3) {
    return this.sentences(e2);
  }
  paragraphs(e2 = 3, r2 = `
`) {
    return this.faker.helpers.multiple(() => this.paragraph(), { count: e2 }).join(r2);
  }
  text() {
    let e2 = ["sentence", "sentences", "paragraph", "paragraphs", "lines"], r2 = this.faker.helpers.arrayElement(e2);
    return this[r2]();
  }
  lines(e2 = { min: 1, max: 5 }) {
    return this.sentences(e2, `
`);
  }
};
var me2 = class extends p3 {
  album() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.album);
  }
  artist() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.artist);
  }
  genre() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.genre);
  }
  songName() {
    return this.faker.helpers.arrayElement(this.faker.definitions.music.song_name);
  }
};
var ue2 = class extends p3 {
  number(e2 = {}) {
    let { style: r2 = "human" } = e2, a2 = this.faker.definitions.phone_number.format[r2];
    if (!a2)
      throw new Error(`No definitions for ${r2} in this locale`);
    let n2 = this.faker.helpers.arrayElement(a2);
    return Se2(this.faker, n2);
  }
  imei() {
    return this.faker.helpers.replaceCreditCardSymbols("##-######-######-L", "#");
  }
};
var pe2 = class extends p3 {
  chemicalElement() {
    return this.faker.helpers.arrayElement(this.faker.definitions.science.chemical_element);
  }
  unit() {
    return this.faker.helpers.arrayElement(this.faker.definitions.science.unit);
  }
};
var Zr = ["video", "audio", "image", "text", "application"];
var Jr = ["application/pdf", "audio/mpeg", "audio/wav", "image/png", "image/jpeg", "image/gif", "video/mp4", "video/mpeg", "text/html"];
var Xr = ["en", "wl", "ww"];
var Xe2 = { index: "o", slot: "s", mac: "x", pci: "p" };
var Qr = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
var he2 = class extends p3 {
  fileName(e2 = {}) {
    let { extensionCount: r2 = 1 } = e2, t2 = this.faker.word.words().toLowerCase().replaceAll(/\W/g, "_"), a2 = this.faker.helpers.multiple(() => this.fileExt(), { count: r2 }).join(".");
    return a2.length === 0 ? t2 : `${t2}.${a2}`;
  }
  commonFileName(e2) {
    return `${this.fileName({ extensionCount: 0 })}.${e2 || this.commonFileExt()}`;
  }
  mimeType() {
    let e2 = Object.keys(this.faker.definitions.system.mime_type);
    return this.faker.helpers.arrayElement(e2);
  }
  commonFileType() {
    return this.faker.helpers.arrayElement(Zr);
  }
  commonFileExt() {
    return this.fileExt(this.faker.helpers.arrayElement(Jr));
  }
  fileType() {
    let e2 = this.faker.definitions.system.mime_type, r2 = new Set(Object.keys(e2).map((t2) => t2.split("/")[0]));
    return this.faker.helpers.arrayElement([...r2]);
  }
  fileExt(e2) {
    let r2 = this.faker.definitions.system.mime_type;
    if (typeof e2 == "string")
      return this.faker.helpers.arrayElement(r2[e2].extensions);
    let t2 = new Set(Object.values(r2).flatMap(({ extensions: a2 }) => a2));
    return this.faker.helpers.arrayElement([...t2]);
  }
  directoryPath() {
    let e2 = this.faker.definitions.system.directory_path;
    return this.faker.helpers.arrayElement(e2);
  }
  filePath() {
    return `${this.directoryPath()}/${this.fileName()}`;
  }
  semver() {
    return [this.faker.number.int(9), this.faker.number.int(20), this.faker.number.int(20)].join(".");
  }
  networkInterface(e2 = {}) {
    let { interfaceType: r2 = this.faker.helpers.arrayElement(Xr), interfaceSchema: t2 = this.faker.helpers.objectKey(Xe2) } = e2, a2, n2 = "";
    switch (t2) {
      case "index": {
        a2 = this.faker.string.numeric();
        break;
      }
      case "slot": {
        a2 = `${this.faker.string.numeric()}${this.faker.helpers.maybe(() => `f${this.faker.string.numeric()}`) ?? ""}${this.faker.helpers.maybe(() => `d${this.faker.string.numeric()}`) ?? ""}`;
        break;
      }
      case "mac": {
        a2 = this.faker.internet.mac("");
        break;
      }
      case "pci": {
        n2 = this.faker.helpers.maybe(() => `P${this.faker.string.numeric()}`) ?? "", a2 = `${this.faker.string.numeric()}s${this.faker.string.numeric()}${this.faker.helpers.maybe(() => `f${this.faker.string.numeric()}`) ?? ""}${this.faker.helpers.maybe(() => `d${this.faker.string.numeric()}`) ?? ""}`;
        break;
      }
    }
    return `${n2}${r2}${Xe2[t2]}${a2}`;
  }
  cron(e2 = {}) {
    let { includeYear: r2 = false, includeNonStandard: t2 = false } = e2, a2 = [this.faker.number.int(59), "*"], n2 = [this.faker.number.int(23), "*"], o2 = [this.faker.number.int({ min: 1, max: 31 }), "*", "?"], s2 = [this.faker.number.int({ min: 1, max: 12 }), "*"], l2 = [this.faker.number.int(6), this.faker.helpers.arrayElement(Qr), "*", "?"], c2 = [this.faker.number.int({ min: 1970, max: 2099 }), "*"], u2 = this.faker.helpers.arrayElement(a2), h2 = this.faker.helpers.arrayElement(n2), f2 = this.faker.helpers.arrayElement(o2), g2 = this.faker.helpers.arrayElement(s2), b2 = this.faker.helpers.arrayElement(l2), y2 = this.faker.helpers.arrayElement(c2), N2 = `${u2} ${h2} ${f2} ${g2} ${b2}`;
    r2 && (N2 += ` ${y2}`);
    let k2 = ["@annually", "@daily", "@hourly", "@monthly", "@reboot", "@weekly", "@yearly"];
    return !t2 || this.faker.datatype.boolean() ? N2 : this.faker.helpers.arrayElement(k2);
  }
};
var fe2 = class extends p3 {
  vehicle() {
    return `${this.manufacturer()} ${this.model()}`;
  }
  manufacturer() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.manufacturer);
  }
  model() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.model);
  }
  type() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.type);
  }
  fuel() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.fuel);
  }
  vin() {
    let e2 = ["o", "i", "q", "O", "I", "Q"];
    return `${this.faker.string.alphanumeric({ length: 10, casing: "upper", exclude: e2 })}${this.faker.string.alpha({ length: 1, casing: "upper", exclude: e2 })}${this.faker.string.alphanumeric({ length: 1, casing: "upper", exclude: e2 })}${this.faker.string.numeric({ length: 5, allowLeadingZeros: true })}`;
  }
  color() {
    return this.faker.color.human();
  }
  vrm() {
    return `${this.faker.string.alpha({ length: 2, casing: "upper" })}${this.faker.string.numeric({ length: 2, allowLeadingZeros: true })}${this.faker.string.alpha({ length: 3, casing: "upper" })}`;
  }
  bicycle() {
    return this.faker.helpers.arrayElement(this.faker.definitions.vehicle.bicycle_type);
  }
};
var be2 = class extends p3 {
  adjective(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.adjective }));
  }
  adverb(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.adverb }));
  }
  conjunction(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.conjunction }));
  }
  interjection(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.interjection }));
  }
  noun(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.noun }));
  }
  preposition(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.preposition }));
  }
  verb(e2 = {}) {
    return typeof e2 == "number" && (e2 = { length: e2 }), this.faker.helpers.arrayElement(T2({ ...e2, wordList: this.faker.definitions.word.verb }));
  }
  sample(e2 = {}) {
    let r2 = this.faker.helpers.shuffle([this.adjective, this.adverb, this.conjunction, this.interjection, this.noun, this.preposition, this.verb]);
    for (let t2 of r2)
      try {
        return t2(e2);
      } catch {
        continue;
      }
    throw new m2("No matching word data available for the current locale");
  }
  words(e2 = {}) {
    typeof e2 == "number" && (e2 = { count: e2 });
    let { count: r2 = { min: 1, max: 3 } } = e2;
    return this.faker.helpers.multiple(() => this.sample(), { count: r2 }).join(" ");
  }
};
var Qe2 = class extends I2 {
  rawDefinitions;
  definitions;
  airline = new G2(this);
  animal = new q2(this);
  book = new ee2(this);
  color = new O2(this);
  commerce = new re2(this);
  company = new te2(this);
  database = new ae2(this);
  date = new z2(this);
  finance = new ne2(this);
  food = new ie2(this);
  git = new oe2(this);
  hacker = new se2(this);
  helpers = new W2(this);
  image = new ce2(this);
  internet = new U2(this);
  location = new Y2(this);
  lorem = new le2(this);
  music = new me2(this);
  person = new K2(this);
  phone = new ue2(this);
  science = new pe2(this);
  system = new he2(this);
  vehicle = new fe2(this);
  word = new be2(this);
  get address() {
    return w2({ deprecated: "faker.address", proposed: "faker.location", since: "8.0", until: "10.0" }), this.location;
  }
  get name() {
    return w2({ deprecated: "faker.name", proposed: "faker.person", since: "8.0", until: "10.0" }), this.person;
  }
  constructor(e2) {
    super({ randomizer: e2.randomizer, seed: e2.seed });
    let { locale: r2 } = e2;
    if (Array.isArray(r2)) {
      if (r2.length === 0)
        throw new m2("The locale option must contain at least one locale definition.");
      r2 = Ye2(r2);
    }
    this.rawDefinitions = r2, this.definitions = Ke2(this.rawDefinitions);
  }
  getMetadata() {
    return this.rawDefinitions.metadata ?? {};
  }
};
var qe2 = ["Academy Color Encoding System (ACES)", "Adobe RGB", "Adobe Wide Gamut RGB", "British Standard Colour (BS)", "CIE 1931 XYZ", "CIELAB", "CIELUV", "CIEUVW", "CMY", "CMYK", "DCI-P3", "Display-P3", "Federal Standard 595C", "HKS", "HSL", "HSLA", "HSLuv", "HSV", "HWB", "LCh", "LMS", "Munsell Color System", "Natural Color System (NSC)", "Pantone Matching System (PMS)", "ProPhoto RGB Color Space", "RAL", "RG", "RGBA", "RGK", "Rec. 2020", "Rec. 2100", "Rec. 601", "Rec. 709", "Uniform Color Spaces (UCSs)", "YDbDr", "YIQ", "YPbPr", "sRGB", "sYCC", "scRGB", "xvYCC"];
var qr = { space: qe2 };
var er2 = qr;
var rr2 = ["ascii_bin", "ascii_general_ci", "cp1250_bin", "cp1250_general_ci", "utf8_bin", "utf8_general_ci", "utf8_unicode_ci"];
var tr2 = ["ARCHIVE", "BLACKHOLE", "CSV", "InnoDB", "MEMORY", "MyISAM"];
var ar2 = ["bigint", "binary", "bit", "blob", "boolean", "date", "datetime", "decimal", "double", "enum", "float", "geometry", "int", "mediumint", "point", "real", "serial", "set", "smallint", "text", "time", "timestamp", "tinyint", "varchar"];
var et = { collation: rr2, engine: tr2, type: ar2 };
var nr2 = et;
var _2 = ["Africa/Abidjan", "Africa/Accra", "Africa/Addis_Ababa", "Africa/Algiers", "Africa/Asmara", "Africa/Bamako", "Africa/Bangui", "Africa/Banjul", "Africa/Bissau", "Africa/Blantyre", "Africa/Brazzaville", "Africa/Bujumbura", "Africa/Cairo", "Africa/Casablanca", "Africa/Ceuta", "Africa/Conakry", "Africa/Dakar", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Douala", "Africa/El_Aaiun", "Africa/Freetown", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Juba", "Africa/Kampala", "Africa/Khartoum", "Africa/Kigali", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Lome", "Africa/Luanda", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Malabo", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Mogadishu", "Africa/Monrovia", "Africa/Nairobi", "Africa/Ndjamena", "Africa/Niamey", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Porto-Novo", "Africa/Sao_Tome", "Africa/Tripoli", "Africa/Tunis", "Africa/Windhoek", "America/Adak", "America/Anchorage", "America/Anguilla", "America/Antigua", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Aruba", "America/Asuncion", "America/Atikokan", "America/Bahia", "America/Bahia_Banderas", "America/Barbados", "America/Belem", "America/Belize", "America/Blanc-Sablon", "America/Boa_Vista", "America/Bogota", "America/Boise", "America/Cambridge_Bay", "America/Campo_Grande", "America/Cancun", "America/Caracas", "America/Cayenne", "America/Cayman", "America/Chicago", "America/Chihuahua", "America/Ciudad_Juarez", "America/Costa_Rica", "America/Creston", "America/Cuiaba", "America/Curacao", "America/Danmarkshavn", "America/Dawson", "America/Dawson_Creek", "America/Denver", "America/Detroit", "America/Dominica", "America/Edmonton", "America/Eirunepe", "America/El_Salvador", "America/Fort_Nelson", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guatemala", "America/Guayaquil", "America/Guyana", "America/Halifax", "America/Havana", "America/Hermosillo", "America/Indiana/Indianapolis", "America/Indiana/Knox", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Tell_City", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Inuvik", "America/Iqaluit", "America/Jamaica", "America/Juneau", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Lima", "America/Los_Angeles", "America/Lower_Princes", "America/Maceio", "America/Managua", "America/Manaus", "America/Marigot", "America/Martinique", "America/Matamoros", "America/Mazatlan", "America/Menominee", "America/Merida", "America/Metlakatla", "America/Mexico_City", "America/Miquelon", "America/Moncton", "America/Monterrey", "America/Montevideo", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nome", "America/Noronha", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Nuuk", "America/Ojinaga", "America/Panama", "America/Paramaribo", "America/Phoenix", "America/Port-au-Prince", "America/Port_of_Spain", "America/Porto_Velho", "America/Puerto_Rico", "America/Punta_Arenas", "America/Rankin_Inlet", "America/Recife", "America/Regina", "America/Resolute", "America/Rio_Branco", "America/Santarem", "America/Santiago", "America/Santo_Domingo", "America/Sao_Paulo", "America/Scoresbysund", "America/Sitka", "America/St_Barthelemy", "America/St_Johns", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Swift_Current", "America/Tegucigalpa", "America/Thule", "America/Tijuana", "America/Toronto", "America/Tortola", "America/Vancouver", "America/Whitehorse", "America/Winnipeg", "America/Yakutat", "America/Yellowknife", "Antarctica/Casey", "Antarctica/Davis", "Antarctica/DumontDUrville", "Antarctica/Macquarie", "Antarctica/Mawson", "Antarctica/McMurdo", "Antarctica/Palmer", "Antarctica/Rothera", "Antarctica/Syowa", "Antarctica/Troll", "Antarctica/Vostok", "Arctic/Longyearbyen", "Asia/Aden", "Asia/Almaty", "Asia/Amman", "Asia/Anadyr", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Atyrau", "Asia/Baghdad", "Asia/Bahrain", "Asia/Baku", "Asia/Bangkok", "Asia/Barnaul", "Asia/Beirut", "Asia/Bishkek", "Asia/Brunei", "Asia/Chita", "Asia/Choibalsan", "Asia/Colombo", "Asia/Damascus", "Asia/Dhaka", "Asia/Dili", "Asia/Dubai", "Asia/Dushanbe", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Ho_Chi_Minh", "Asia/Hong_Kong", "Asia/Hovd", "Asia/Irkutsk", "Asia/Jakarta", "Asia/Jayapura", "Asia/Jerusalem", "Asia/Kabul", "Asia/Kamchatka", "Asia/Karachi", "Asia/Kathmandu", "Asia/Khandyga", "Asia/Kolkata", "Asia/Krasnoyarsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Kuwait", "Asia/Macau", "Asia/Magadan", "Asia/Makassar", "Asia/Manila", "Asia/Muscat", "Asia/Nicosia", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Omsk", "Asia/Oral", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Pyongyang", "Asia/Qatar", "Asia/Qostanay", "Asia/Qyzylorda", "Asia/Riyadh", "Asia/Sakhalin", "Asia/Samarkand", "Asia/Seoul", "Asia/Shanghai", "Asia/Singapore", "Asia/Srednekolymsk", "Asia/Taipei", "Asia/Tashkent", "Asia/Tbilisi", "Asia/Tehran", "Asia/Thimphu", "Asia/Tokyo", "Asia/Tomsk", "Asia/Ulaanbaatar", "Asia/Urumqi", "Asia/Ust-Nera", "Asia/Vientiane", "Asia/Vladivostok", "Asia/Yakutsk", "Asia/Yangon", "Asia/Yekaterinburg", "Asia/Yerevan", "Atlantic/Azores", "Atlantic/Bermuda", "Atlantic/Canary", "Atlantic/Cape_Verde", "Atlantic/Faroe", "Atlantic/Madeira", "Atlantic/Reykjavik", "Atlantic/South_Georgia", "Atlantic/St_Helena", "Atlantic/Stanley", "Australia/Adelaide", "Australia/Brisbane", "Australia/Broken_Hill", "Australia/Darwin", "Australia/Eucla", "Australia/Hobart", "Australia/Lindeman", "Australia/Lord_Howe", "Australia/Melbourne", "Australia/Perth", "Australia/Sydney", "Europe/Amsterdam", "Europe/Andorra", "Europe/Astrakhan", "Europe/Athens", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Bucharest", "Europe/Budapest", "Europe/Busingen", "Europe/Chisinau", "Europe/Copenhagen", "Europe/Dublin", "Europe/Gibraltar", "Europe/Guernsey", "Europe/Helsinki", "Europe/Isle_of_Man", "Europe/Istanbul", "Europe/Jersey", "Europe/Kaliningrad", "Europe/Kirov", "Europe/Kyiv", "Europe/Lisbon", "Europe/Ljubljana", "Europe/London", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Mariehamn", "Europe/Minsk", "Europe/Monaco", "Europe/Moscow", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Riga", "Europe/Rome", "Europe/Samara", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Saratov", "Europe/Simferopol", "Europe/Skopje", "Europe/Sofia", "Europe/Stockholm", "Europe/Tallinn", "Europe/Tirane", "Europe/Ulyanovsk", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Vilnius", "Europe/Volgograd", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Indian/Antananarivo", "Indian/Chagos", "Indian/Christmas", "Indian/Cocos", "Indian/Comoro", "Indian/Kerguelen", "Indian/Mahe", "Indian/Maldives", "Indian/Mauritius", "Indian/Mayotte", "Indian/Reunion", "Pacific/Apia", "Pacific/Auckland", "Pacific/Bougainville", "Pacific/Chatham", "Pacific/Chuuk", "Pacific/Easter", "Pacific/Efate", "Pacific/Fakaofo", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Galapagos", "Pacific/Gambier", "Pacific/Guadalcanal", "Pacific/Guam", "Pacific/Honolulu", "Pacific/Kanton", "Pacific/Kiritimati", "Pacific/Kosrae", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Marquesas", "Pacific/Midway", "Pacific/Nauru", "Pacific/Niue", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pago_Pago", "Pacific/Palau", "Pacific/Pitcairn", "Pacific/Pohnpei", "Pacific/Port_Moresby", "Pacific/Rarotonga", "Pacific/Saipan", "Pacific/Tahiti", "Pacific/Tarawa", "Pacific/Tongatapu", "Pacific/Wake", "Pacific/Wallis"];
var rt = { time_zone: _2 };
var ir2 = rt;
var or2 = ["ADP", "AGP", "AI", "API", "ASCII", "CLI", "COM", "CSS", "DNS", "DRAM", "EXE", "FTP", "GB", "HDD", "HEX", "HTTP", "IB", "IP", "JBOD", "JSON", "OCR", "PCI", "PNG", "RAM", "RSS", "SAS", "SCSI", "SDD", "SMS", "SMTP", "SQL", "SSD", "SSL", "TCP", "THX", "TLS", "UDP", "USB", "UTF8", "VGA", "XML", "XSS"];
var tt = { abbreviation: or2 };
var sr2 = tt;
var cr2 = { smiley: ["\u2620\uFE0F", "\u2639\uFE0F", "\u263A\uFE0F", "\u2763\uFE0F", "\u2764\uFE0F", "\u2764\uFE0F\u200D\uD83D\uDD25", "\u2764\uFE0F\u200D\uD83E\uDE79", "\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F", "\uD83D\uDC79", "\uD83D\uDC7A", "\uD83D\uDC7B", "\uD83D\uDC7D", "\uD83D\uDC7E", "\uD83D\uDC7F", "\uD83D\uDC80", "\uD83D\uDC8B", "\uD83D\uDC8C", "\uD83D\uDC93", "\uD83D\uDC94", "\uD83D\uDC95", "\uD83D\uDC96", "\uD83D\uDC97", "\uD83D\uDC98", "\uD83D\uDC99", "\uD83D\uDC9A", "\uD83D\uDC9B", "\uD83D\uDC9C", "\uD83D\uDC9D", "\uD83D\uDC9E", "\uD83D\uDC9F", "\uD83D\uDCA2", "\uD83D\uDCA3", "\uD83D\uDCA4", "\uD83D\uDCA5", "\uD83D\uDCA6", "\uD83D\uDCA8", "\uD83D\uDCA9", "\uD83D\uDCAB", "\uD83D\uDCAC", "\uD83D\uDCAD", "\uD83D\uDCAF", "\uD83D\uDD73\uFE0F", "\uD83D\uDDA4", "\uD83D\uDDE8\uFE0F", "\uD83D\uDDEF\uFE0F", "\uD83D\uDE00", "\uD83D\uDE01", "\uD83D\uDE02", "\uD83D\uDE03", "\uD83D\uDE04", "\uD83D\uDE05", "\uD83D\uDE06", "\uD83D\uDE07", "\uD83D\uDE08", "\uD83D\uDE09", "\uD83D\uDE0A", "\uD83D\uDE0B", "\uD83D\uDE0C", "\uD83D\uDE0D", "\uD83D\uDE0E", "\uD83D\uDE0F", "\uD83D\uDE10", "\uD83D\uDE11", "\uD83D\uDE12", "\uD83D\uDE13", "\uD83D\uDE14", "\uD83D\uDE15", "\uD83D\uDE16", "\uD83D\uDE17", "\uD83D\uDE18", "\uD83D\uDE19", "\uD83D\uDE1A", "\uD83D\uDE1B", "\uD83D\uDE1C", "\uD83D\uDE1D", "\uD83D\uDE1E", "\uD83D\uDE1F", "\uD83D\uDE20", "\uD83D\uDE21", "\uD83D\uDE22", "\uD83D\uDE23", "\uD83D\uDE24", "\uD83D\uDE25", "\uD83D\uDE26", "\uD83D\uDE27", "\uD83D\uDE28", "\uD83D\uDE29", "\uD83D\uDE2A", "\uD83D\uDE2B", "\uD83D\uDE2C", "\uD83D\uDE2D", "\uD83D\uDE2E", "\uD83D\uDE2E\u200D\uD83D\uDCA8", "\uD83D\uDE2F", "\uD83D\uDE30", "\uD83D\uDE31", "\uD83D\uDE32", "\uD83D\uDE33", "\uD83D\uDE34", "\uD83D\uDE35", "\uD83D\uDE35\u200D\uD83D\uDCAB", "\uD83D\uDE36", "\uD83D\uDE36\u200D\uD83C\uDF2B\uFE0F", "\uD83D\uDE37", "\uD83D\uDE38", "\uD83D\uDE39", "\uD83D\uDE3A", "\uD83D\uDE3B", "\uD83D\uDE3C", "\uD83D\uDE3D", "\uD83D\uDE3E", "\uD83D\uDE3F", "\uD83D\uDE40", "\uD83D\uDE41", "\uD83D\uDE42", "\uD83D\uDE43", "\uD83D\uDE44", "\uD83D\uDE48", "\uD83D\uDE49", "\uD83D\uDE4A", "\uD83E\uDD0D", "\uD83E\uDD0E", "\uD83E\uDD10", "\uD83E\uDD11", "\uD83E\uDD12", "\uD83E\uDD13", "\uD83E\uDD14", "\uD83E\uDD15", "\uD83E\uDD16", "\uD83E\uDD17", "\uD83E\uDD20", "\uD83E\uDD21", "\uD83E\uDD22", "\uD83E\uDD23", "\uD83E\uDD24", "\uD83E\uDD25", "\uD83E\uDD27", "\uD83E\uDD28", "\uD83E\uDD29", "\uD83E\uDD2A", "\uD83E\uDD2B", "\uD83E\uDD2C", "\uD83E\uDD2D", "\uD83E\uDD2E", "\uD83E\uDD2F", "\uD83E\uDD70", "\uD83E\uDD71", "\uD83E\uDD72", "\uD83E\uDD73", "\uD83E\uDD74", "\uD83E\uDD75", "\uD83E\uDD76", "\uD83E\uDD78", "\uD83E\uDD7A", "\uD83E\uDDD0", "\uD83E\uDDE1"], body: ["\u261D\uD83C\uDFFB", "\u261D\uD83C\uDFFC", "\u261D\uD83C\uDFFD", "\u261D\uD83C\uDFFE", "\u261D\uD83C\uDFFF", "\u261D\uFE0F", "\u270A", "\u270A\uD83C\uDFFB", "\u270A\uD83C\uDFFC", "\u270A\uD83C\uDFFD", "\u270A\uD83C\uDFFE", "\u270A\uD83C\uDFFF", "\u270B", "\u270B\uD83C\uDFFB", "\u270B\uD83C\uDFFC", "\u270B\uD83C\uDFFD", "\u270B\uD83C\uDFFE", "\u270B\uD83C\uDFFF", "\u270C\uD83C\uDFFB", "\u270C\uD83C\uDFFC", "\u270C\uD83C\uDFFD", "\u270C\uD83C\uDFFE", "\u270C\uD83C\uDFFF", "\u270C\uFE0F", "\u270D\uD83C\uDFFB", "\u270D\uD83C\uDFFC", "\u270D\uD83C\uDFFD", "\u270D\uD83C\uDFFE", "\u270D\uD83C\uDFFF", "\u270D\uFE0F", "\uD83D\uDC40", "\uD83D\uDC41\uFE0F", "\uD83D\uDC42", "\uD83D\uDC42\uD83C\uDFFB", "\uD83D\uDC42\uD83C\uDFFC", "\uD83D\uDC42\uD83C\uDFFD", "\uD83D\uDC42\uD83C\uDFFE", "\uD83D\uDC42\uD83C\uDFFF", "\uD83D\uDC43", "\uD83D\uDC43\uD83C\uDFFB", "\uD83D\uDC43\uD83C\uDFFC", "\uD83D\uDC43\uD83C\uDFFD", "\uD83D\uDC43\uD83C\uDFFE", "\uD83D\uDC43\uD83C\uDFFF", "\uD83D\uDC44", "\uD83D\uDC45", "\uD83D\uDC46", "\uD83D\uDC46\uD83C\uDFFB", "\uD83D\uDC46\uD83C\uDFFC", "\uD83D\uDC46\uD83C\uDFFD", "\uD83D\uDC46\uD83C\uDFFE", "\uD83D\uDC46\uD83C\uDFFF", "\uD83D\uDC47", "\uD83D\uDC47\uD83C\uDFFB", "\uD83D\uDC47\uD83C\uDFFC", "\uD83D\uDC47\uD83C\uDFFD", "\uD83D\uDC47\uD83C\uDFFE", "\uD83D\uDC47\uD83C\uDFFF", "\uD83D\uDC48", "\uD83D\uDC48\uD83C\uDFFB", "\uD83D\uDC48\uD83C\uDFFC", "\uD83D\uDC48\uD83C\uDFFD", "\uD83D\uDC48\uD83C\uDFFE", "\uD83D\uDC48\uD83C\uDFFF", "\uD83D\uDC49", "\uD83D\uDC49\uD83C\uDFFB", "\uD83D\uDC49\uD83C\uDFFC", "\uD83D\uDC49\uD83C\uDFFD", "\uD83D\uDC49\uD83C\uDFFE", "\uD83D\uDC49\uD83C\uDFFF", "\uD83D\uDC4A", "\uD83D\uDC4A\uD83C\uDFFB", "\uD83D\uDC4A\uD83C\uDFFC", "\uD83D\uDC4A\uD83C\uDFFD", "\uD83D\uDC4A\uD83C\uDFFE", "\uD83D\uDC4A\uD83C\uDFFF", "\uD83D\uDC4B", "\uD83D\uDC4B\uD83C\uDFFB", "\uD83D\uDC4B\uD83C\uDFFC", "\uD83D\uDC4B\uD83C\uDFFD", "\uD83D\uDC4B\uD83C\uDFFE", "\uD83D\uDC4B\uD83C\uDFFF", "\uD83D\uDC4C", "\uD83D\uDC4C\uD83C\uDFFB", "\uD83D\uDC4C\uD83C\uDFFC", "\uD83D\uDC4C\uD83C\uDFFD", "\uD83D\uDC4C\uD83C\uDFFE", "\uD83D\uDC4C\uD83C\uDFFF", "\uD83D\uDC4D", "\uD83D\uDC4D\uD83C\uDFFB", "\uD83D\uDC4D\uD83C\uDFFC", "\uD83D\uDC4D\uD83C\uDFFD", "\uD83D\uDC4D\uD83C\uDFFE", "\uD83D\uDC4D\uD83C\uDFFF", "\uD83D\uDC4E", "\uD83D\uDC4E\uD83C\uDFFB", "\uD83D\uDC4E\uD83C\uDFFC", "\uD83D\uDC4E\uD83C\uDFFD", "\uD83D\uDC4E\uD83C\uDFFE", "\uD83D\uDC4E\uD83C\uDFFF", "\uD83D\uDC4F", "\uD83D\uDC4F\uD83C\uDFFB", "\uD83D\uDC4F\uD83C\uDFFC", "\uD83D\uDC4F\uD83C\uDFFD", "\uD83D\uDC4F\uD83C\uDFFE", "\uD83D\uDC4F\uD83C\uDFFF", "\uD83D\uDC50", "\uD83D\uDC50\uD83C\uDFFB", "\uD83D\uDC50\uD83C\uDFFC", "\uD83D\uDC50\uD83C\uDFFD", "\uD83D\uDC50\uD83C\uDFFE", "\uD83D\uDC50\uD83C\uDFFF", "\uD83D\uDC85", "\uD83D\uDC85\uD83C\uDFFB", "\uD83D\uDC85\uD83C\uDFFC", "\uD83D\uDC85\uD83C\uDFFD", "\uD83D\uDC85\uD83C\uDFFE", "\uD83D\uDC85\uD83C\uDFFF", "\uD83D\uDCAA", "\uD83D\uDCAA\uD83C\uDFFB", "\uD83D\uDCAA\uD83C\uDFFC", "\uD83D\uDCAA\uD83C\uDFFD", "\uD83D\uDCAA\uD83C\uDFFE", "\uD83D\uDCAA\uD83C\uDFFF", "\uD83D\uDD90\uD83C\uDFFB", "\uD83D\uDD90\uD83C\uDFFC", "\uD83D\uDD90\uD83C\uDFFD", "\uD83D\uDD90\uD83C\uDFFE", "\uD83D\uDD90\uD83C\uDFFF", "\uD83D\uDD90\uFE0F", "\uD83D\uDD95", "\uD83D\uDD95\uD83C\uDFFB", "\uD83D\uDD95\uD83C\uDFFC", "\uD83D\uDD95\uD83C\uDFFD", "\uD83D\uDD95\uD83C\uDFFE", "\uD83D\uDD95\uD83C\uDFFF", "\uD83D\uDD96", "\uD83D\uDD96\uD83C\uDFFB", "\uD83D\uDD96\uD83C\uDFFC", "\uD83D\uDD96\uD83C\uDFFD", "\uD83D\uDD96\uD83C\uDFFE", "\uD83D\uDD96\uD83C\uDFFF", "\uD83D\uDE4C", "\uD83D\uDE4C\uD83C\uDFFB", "\uD83D\uDE4C\uD83C\uDFFC", "\uD83D\uDE4C\uD83C\uDFFD", "\uD83D\uDE4C\uD83C\uDFFE", "\uD83D\uDE4C\uD83C\uDFFF", "\uD83D\uDE4F", "\uD83D\uDE4F\uD83C\uDFFB", "\uD83D\uDE4F\uD83C\uDFFC", "\uD83D\uDE4F\uD83C\uDFFD", "\uD83D\uDE4F\uD83C\uDFFE", "\uD83D\uDE4F\uD83C\uDFFF", "\uD83E\uDD0C", "\uD83E\uDD0C\uD83C\uDFFB", "\uD83E\uDD0C\uD83C\uDFFC", "\uD83E\uDD0C\uD83C\uDFFD", "\uD83E\uDD0C\uD83C\uDFFE", "\uD83E\uDD0C\uD83C\uDFFF", "\uD83E\uDD0F", "\uD83E\uDD0F\uD83C\uDFFB", "\uD83E\uDD0F\uD83C\uDFFC", "\uD83E\uDD0F\uD83C\uDFFD", "\uD83E\uDD0F\uD83C\uDFFE", "\uD83E\uDD0F\uD83C\uDFFF", "\uD83E\uDD18", "\uD83E\uDD18\uD83C\uDFFB", "\uD83E\uDD18\uD83C\uDFFC", "\uD83E\uDD18\uD83C\uDFFD", "\uD83E\uDD18\uD83C\uDFFE", "\uD83E\uDD18\uD83C\uDFFF", "\uD83E\uDD19", "\uD83E\uDD19\uD83C\uDFFB", "\uD83E\uDD19\uD83C\uDFFC", "\uD83E\uDD19\uD83C\uDFFD", "\uD83E\uDD19\uD83C\uDFFE", "\uD83E\uDD19\uD83C\uDFFF", "\uD83E\uDD1A", "\uD83E\uDD1A\uD83C\uDFFB", "\uD83E\uDD1A\uD83C\uDFFC", "\uD83E\uDD1A\uD83C\uDFFD", "\uD83E\uDD1A\uD83C\uDFFE", "\uD83E\uDD1A\uD83C\uDFFF", "\uD83E\uDD1B", "\uD83E\uDD1B\uD83C\uDFFB", "\uD83E\uDD1B\uD83C\uDFFC", "\uD83E\uDD1B\uD83C\uDFFD", "\uD83E\uDD1B\uD83C\uDFFE", "\uD83E\uDD1B\uD83C\uDFFF", "\uD83E\uDD1C", "\uD83E\uDD1C\uD83C\uDFFB", "\uD83E\uDD1C\uD83C\uDFFC", "\uD83E\uDD1C\uD83C\uDFFD", "\uD83E\uDD1C\uD83C\uDFFE", "\uD83E\uDD1C\uD83C\uDFFF", "\uD83E\uDD1D", "\uD83E\uDD1E", "\uD83E\uDD1E\uD83C\uDFFB", "\uD83E\uDD1E\uD83C\uDFFC", "\uD83E\uDD1E\uD83C\uDFFD", "\uD83E\uDD1E\uD83C\uDFFE", "\uD83E\uDD1E\uD83C\uDFFF", "\uD83E\uDD1F", "\uD83E\uDD1F\uD83C\uDFFB", "\uD83E\uDD1F\uD83C\uDFFC", "\uD83E\uDD1F\uD83C\uDFFD", "\uD83E\uDD1F\uD83C\uDFFE", "\uD83E\uDD1F\uD83C\uDFFF", "\uD83E\uDD32", "\uD83E\uDD32\uD83C\uDFFB", "\uD83E\uDD32\uD83C\uDFFC", "\uD83E\uDD32\uD83C\uDFFD", "\uD83E\uDD32\uD83C\uDFFE", "\uD83E\uDD32\uD83C\uDFFF", "\uD83E\uDD33", "\uD83E\uDD33\uD83C\uDFFB", "\uD83E\uDD33\uD83C\uDFFC", "\uD83E\uDD33\uD83C\uDFFD", "\uD83E\uDD33\uD83C\uDFFE", "\uD83E\uDD33\uD83C\uDFFF", "\uD83E\uDDB4", "\uD83E\uDDB5", "\uD83E\uDDB5\uD83C\uDFFB", "\uD83E\uDDB5\uD83C\uDFFC", "\uD83E\uDDB5\uD83C\uDFFD", "\uD83E\uDDB5\uD83C\uDFFE", "\uD83E\uDDB5\uD83C\uDFFF", "\uD83E\uDDB6", "\uD83E\uDDB6\uD83C\uDFFB", "\uD83E\uDDB6\uD83C\uDFFC", "\uD83E\uDDB6\uD83C\uDFFD", "\uD83E\uDDB6\uD83C\uDFFE", "\uD83E\uDDB6\uD83C\uDFFF", "\uD83E\uDDB7", "\uD83E\uDDBB", "\uD83E\uDDBB\uD83C\uDFFB", "\uD83E\uDDBB\uD83C\uDFFC", "\uD83E\uDDBB\uD83C\uDFFD", "\uD83E\uDDBB\uD83C\uDFFE", "\uD83E\uDDBB\uD83C\uDFFF", "\uD83E\uDDBE", "\uD83E\uDDBF", "\uD83E\uDDE0", "\uD83E\uDEC0", "\uD83E\uDEC1"], person: ["\uD83C\uDF85", "\uD83C\uDF85\uD83C\uDFFB", "\uD83C\uDF85\uD83C\uDFFC", "\uD83C\uDF85\uD83C\uDFFD", "\uD83C\uDF85\uD83C\uDFFE", "\uD83C\uDF85\uD83C\uDFFF", "\uD83D\uDC66", "\uD83D\uDC66\uD83C\uDFFB", "\uD83D\uDC66\uD83C\uDFFC", "\uD83D\uDC66\uD83C\uDFFD", "\uD83D\uDC66\uD83C\uDFFE", "\uD83D\uDC66\uD83C\uDFFF", "\uD83D\uDC67", "\uD83D\uDC67\uD83C\uDFFB", "\uD83D\uDC67\uD83C\uDFFC", "\uD83D\uDC67\uD83C\uDFFD", "\uD83D\uDC67\uD83C\uDFFE", "\uD83D\uDC67\uD83C\uDFFF", "\uD83D\uDC68", "\uD83D\uDC68\u200D\u2695\uFE0F", "\uD83D\uDC68\u200D\u2696\uFE0F", "\uD83D\uDC68\u200D\u2708\uFE0F", "\uD83D\uDC68\u200D\uD83C\uDF3E", "\uD83D\uDC68\u200D\uD83C\uDF73", "\uD83D\uDC68\u200D\uD83C\uDF7C", "\uD83D\uDC68\u200D\uD83C\uDF93", "\uD83D\uDC68\u200D\uD83C\uDFA4", "\uD83D\uDC68\u200D\uD83C\uDFA8", "\uD83D\uDC68\u200D\uD83C\uDFEB", "\uD83D\uDC68\u200D\uD83C\uDFED", "\uD83D\uDC68\u200D\uD83D\uDCBB", "\uD83D\uDC68\u200D\uD83D\uDCBC", "\uD83D\uDC68\u200D\uD83D\uDD27", "\uD83D\uDC68\u200D\uD83D\uDD2C", "\uD83D\uDC68\u200D\uD83D\uDE80", "\uD83D\uDC68\u200D\uD83D\uDE92", "\uD83D\uDC68\u200D\uD83E\uDDB0", "\uD83D\uDC68\u200D\uD83E\uDDB1", "\uD83D\uDC68\u200D\uD83E\uDDB2", "\uD83D\uDC68\u200D\uD83E\uDDB3", "\uD83D\uDC68\uD83C\uDFFB", "\uD83D\uDC68\uD83C\uDFFB\u200D\u2695\uFE0F", "\uD83D\uDC68\uD83C\uDFFB\u200D\u2696\uFE0F", "\uD83D\uDC68\uD83C\uDFFB\u200D\u2708\uFE0F", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDF3E", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDF73", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDF7C", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDF93", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDFA4", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDFA8", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDFEB", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDFED", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDCBB", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDCBC", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDD27", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDD2C", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDE80", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83D\uDE92", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83E\uDDB0", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83E\uDDB1", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83E\uDDB2", "\uD83D\uDC68\uD83C\uDFFB\u200D\uD83E\uDDB3", "\uD83D\uDC68\uD83C\uDFFC", "\uD83D\uDC68\uD83C\uDFFC\u200D\u2695\uFE0F", "\uD83D\uDC68\uD83C\uDFFC\u200D\u2696\uFE0F", "\uD83D\uDC68\uD83C\uDFFC\u200D\u2708\uFE0F", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDF3E", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDF73", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDF7C", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDF93", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDFA4", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDFA8", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDFEB", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83C\uDFED", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDCBB", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDCBC", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDD27", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDD2C", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDE80", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83D\uDE92", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83E\uDDB0", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83E\uDDB1", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83E\uDDB2", "\uD83D\uDC68\uD83C\uDFFC\u200D\uD83E\uDDB3", "\uD83D\uDC68\uD83C\uDFFD", "\uD83D\uDC68\uD83C\uDFFD\u200D\u2695\uFE0F", "\uD83D\uDC68\uD83C\uDFFD\u200D\u2696\uFE0F", "\uD83D\uDC68\uD83C\uDFFD\u200D\u2708\uFE0F", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDF3E", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDF73", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDF7C", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDF93", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDFA4", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDFA8", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDFEB", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83C\uDFED", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDCBB", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDCBC", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDD27", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDD2C", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDE80", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83D\uDE92", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83E\uDDB0", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83E\uDDB1", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83E\uDDB2", "\uD83D\uDC68\uD83C\uDFFD\u200D\uD83E\uDDB3", "\uD83D\uDC68\uD83C\uDFFE", "\uD83D\uDC68\uD83C\uDFFE\u200D\u2695\uFE0F", "\uD83D\uDC68\uD83C\uDFFE\u200D\u2696\uFE0F", "\uD83D\uDC68\uD83C\uDFFE\u200D\u2708\uFE0F", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDF3E", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDF73", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDF7C", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDF93", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDFA4", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDFA8", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDFEB", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83C\uDFED", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDCBB", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDCBC", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDD27", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDD2C", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDE80", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83D\uDE92", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83E\uDDB0", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83E\uDDB1", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83E\uDDB2", "\uD83D\uDC68\uD83C\uDFFE\u200D\uD83E\uDDB3", "\uD83D\uDC68\uD83C\uDFFF", "\uD83D\uDC68\uD83C\uDFFF\u200D\u2695\uFE0F", "\uD83D\uDC68\uD83C\uDFFF\u200D\u2696\uFE0F", "\uD83D\uDC68\uD83C\uDFFF\u200D\u2708\uFE0F", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDF3E", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDF73", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDF7C", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDF93", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDFA4", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDFA8", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDFEB", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83C\uDFED", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDCBB", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDCBC", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDD27", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDD2C", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDE80", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83D\uDE92", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83E\uDDB0", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83E\uDDB1", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83E\uDDB2", "\uD83D\uDC68\uD83C\uDFFF\u200D\uD83E\uDDB3", "\uD83D\uDC69", "\uD83D\uDC69\u200D\u2695\uFE0F", "\uD83D\uDC69\u200D\u2696\uFE0F", "\uD83D\uDC69\u200D\u2708\uFE0F", "\uD83D\uDC69\u200D\uD83C\uDF3E", "\uD83D\uDC69\u200D\uD83C\uDF73", "\uD83D\uDC69\u200D\uD83C\uDF7C", "\uD83D\uDC69\u200D\uD83C\uDF93", "\uD83D\uDC69\u200D\uD83C\uDFA4", "\uD83D\uDC69\u200D\uD83C\uDFA8", "\uD83D\uDC69\u200D\uD83C\uDFEB", "\uD83D\uDC69\u200D\uD83C\uDFED", "\uD83D\uDC69\u200D\uD83D\uDCBB", "\uD83D\uDC69\u200D\uD83D\uDCBC", "\uD83D\uDC69\u200D\uD83D\uDD27", "\uD83D\uDC69\u200D\uD83D\uDD2C", "\uD83D\uDC69\u200D\uD83D\uDE80", "\uD83D\uDC69\u200D\uD83D\uDE92", "\uD83D\uDC69\u200D\uD83E\uDDB0", "\uD83D\uDC69\u200D\uD83E\uDDB1", "\uD83D\uDC69\u200D\uD83E\uDDB2", "\uD83D\uDC69\u200D\uD83E\uDDB3", "\uD83D\uDC69\uD83C\uDFFB", "\uD83D\uDC69\uD83C\uDFFB\u200D\u2695\uFE0F", "\uD83D\uDC69\uD83C\uDFFB\u200D\u2696\uFE0F", "\uD83D\uDC69\uD83C\uDFFB\u200D\u2708\uFE0F", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDF3E", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDF73", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDF7C", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDF93", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDFA4", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDFA8", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDFEB", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83C\uDFED", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDCBB", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDCBC", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDD27", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDD2C", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDE80", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83D\uDE92", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDDB0", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDDB1", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDDB2", "\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDDB3", "\uD83D\uDC69\uD83C\uDFFC", "\uD83D\uDC69\uD83C\uDFFC\u200D\u2695\uFE0F", "\uD83D\uDC69\uD83C\uDFFC\u200D\u2696\uFE0F", "\uD83D\uDC69\uD83C\uDFFC\u200D\u2708\uFE0F", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDF3E", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDF73", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDF7C", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDF93", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDFA4", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDFA8", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDFEB", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83C\uDFED", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDCBB", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDCBC", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDD27", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDD2C", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDE80", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83D\uDE92", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDDB0", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDDB1", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDDB2", "\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDDB3", "\uD83D\uDC69\uD83C\uDFFD", "\uD83D\uDC69\uD83C\uDFFD\u200D\u2695\uFE0F", "\uD83D\uDC69\uD83C\uDFFD\u200D\u2696\uFE0F", "\uD83D\uDC69\uD83C\uDFFD\u200D\u2708\uFE0F", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDF3E", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDF73", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDF7C", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDF93", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDFA4", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDFA8", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDFEB", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDFED", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDCBB", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDCBC", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDD27", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDD2C", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDE80", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83D\uDE92", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB0", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB1", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB2", "\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB3", "\uD83D\uDC69\uD83C\uDFFE", "\uD83D\uDC69\uD83C\uDFFE\u200D\u2695\uFE0F", "\uD83D\uDC69\uD83C\uDFFE\u200D\u2696\uFE0F", "\uD83D\uDC69\uD83C\uDFFE\u200D\u2708\uFE0F", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDF3E", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDF73", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDF7C", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDF93", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDFA4", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDFA8", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDFEB", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83C\uDFED", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDCBB", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDCBC", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDD27", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDD2C", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDE80", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83D\uDE92", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDDB0", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDDB1", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDDB2", "\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDDB3", "\uD83D\uDC69\uD83C\uDFFF", "\uD83D\uDC69\uD83C\uDFFF\u200D\u2695\uFE0F", "\uD83D\uDC69\uD83C\uDFFF\u200D\u2696\uFE0F", "\uD83D\uDC69\uD83C\uDFFF\u200D\u2708\uFE0F", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDF3E", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDF73", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDF7C", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDF93", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDFA4", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDFA8", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDFEB", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83C\uDFED", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDCBB", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDCBC", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDD27", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDD2C", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDE80", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83D\uDE92", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDDB0", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDDB1", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDDB2", "\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDDB3", "\uD83D\uDC6E", "\uD83D\uDC6E\u200D\u2640\uFE0F", "\uD83D\uDC6E\u200D\u2642\uFE0F", "\uD83D\uDC6E\uD83C\uDFFB", "\uD83D\uDC6E\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC6E\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC6E\uD83C\uDFFC", "\uD83D\uDC6E\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC6E\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC6E\uD83C\uDFFD", "\uD83D\uDC6E\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC6E\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC6E\uD83C\uDFFE", "\uD83D\uDC6E\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC6E\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC6E\uD83C\uDFFF", "\uD83D\uDC6E\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC6E\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC70", "\uD83D\uDC70\u200D\u2640\uFE0F", "\uD83D\uDC70\u200D\u2642\uFE0F", "\uD83D\uDC70\uD83C\uDFFB", "\uD83D\uDC70\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC70\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC70\uD83C\uDFFC", "\uD83D\uDC70\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC70\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC70\uD83C\uDFFD", "\uD83D\uDC70\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC70\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC70\uD83C\uDFFE", "\uD83D\uDC70\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC70\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC70\uD83C\uDFFF", "\uD83D\uDC70\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC70\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC71", "\uD83D\uDC71\u200D\u2640\uFE0F", "\uD83D\uDC71\u200D\u2642\uFE0F", "\uD83D\uDC71\uD83C\uDFFB", "\uD83D\uDC71\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC71\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC71\uD83C\uDFFC", "\uD83D\uDC71\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC71\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC71\uD83C\uDFFD", "\uD83D\uDC71\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC71\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC71\uD83C\uDFFE", "\uD83D\uDC71\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC71\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC71\uD83C\uDFFF", "\uD83D\uDC71\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC71\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC72", "\uD83D\uDC72\uD83C\uDFFB", "\uD83D\uDC72\uD83C\uDFFC", "\uD83D\uDC72\uD83C\uDFFD", "\uD83D\uDC72\uD83C\uDFFE", "\uD83D\uDC72\uD83C\uDFFF", "\uD83D\uDC73", "\uD83D\uDC73\u200D\u2640\uFE0F", "\uD83D\uDC73\u200D\u2642\uFE0F", "\uD83D\uDC73\uD83C\uDFFB", "\uD83D\uDC73\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC73\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC73\uD83C\uDFFC", "\uD83D\uDC73\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC73\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC73\uD83C\uDFFD", "\uD83D\uDC73\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC73\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC73\uD83C\uDFFE", "\uD83D\uDC73\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC73\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC73\uD83C\uDFFF", "\uD83D\uDC73\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC73\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC74", "\uD83D\uDC74\uD83C\uDFFB", "\uD83D\uDC74\uD83C\uDFFC", "\uD83D\uDC74\uD83C\uDFFD", "\uD83D\uDC74\uD83C\uDFFE", "\uD83D\uDC74\uD83C\uDFFF", "\uD83D\uDC75", "\uD83D\uDC75\uD83C\uDFFB", "\uD83D\uDC75\uD83C\uDFFC", "\uD83D\uDC75\uD83C\uDFFD", "\uD83D\uDC75\uD83C\uDFFE", "\uD83D\uDC75\uD83C\uDFFF", "\uD83D\uDC76", "\uD83D\uDC76\uD83C\uDFFB", "\uD83D\uDC76\uD83C\uDFFC", "\uD83D\uDC76\uD83C\uDFFD", "\uD83D\uDC76\uD83C\uDFFE", "\uD83D\uDC76\uD83C\uDFFF", "\uD83D\uDC77", "\uD83D\uDC77\u200D\u2640\uFE0F", "\uD83D\uDC77\u200D\u2642\uFE0F", "\uD83D\uDC77\uD83C\uDFFB", "\uD83D\uDC77\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC77\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC77\uD83C\uDFFC", "\uD83D\uDC77\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC77\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC77\uD83C\uDFFD", "\uD83D\uDC77\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC77\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC77\uD83C\uDFFE", "\uD83D\uDC77\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC77\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC77\uD83C\uDFFF", "\uD83D\uDC77\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC77\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC78", "\uD83D\uDC78\uD83C\uDFFB", "\uD83D\uDC78\uD83C\uDFFC", "\uD83D\uDC78\uD83C\uDFFD", "\uD83D\uDC78\uD83C\uDFFE", "\uD83D\uDC78\uD83C\uDFFF", "\uD83D\uDC7C", "\uD83D\uDC7C\uD83C\uDFFB", "\uD83D\uDC7C\uD83C\uDFFC", "\uD83D\uDC7C\uD83C\uDFFD", "\uD83D\uDC7C\uD83C\uDFFE", "\uD83D\uDC7C\uD83C\uDFFF", "\uD83D\uDC81", "\uD83D\uDC81\u200D\u2640\uFE0F", "\uD83D\uDC81\u200D\u2642\uFE0F", "\uD83D\uDC81\uD83C\uDFFB", "\uD83D\uDC81\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC81\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC81\uD83C\uDFFC", "\uD83D\uDC81\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC81\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC81\uD83C\uDFFD", "\uD83D\uDC81\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC81\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC81\uD83C\uDFFE", "\uD83D\uDC81\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC81\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC81\uD83C\uDFFF", "\uD83D\uDC81\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC81\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC82", "\uD83D\uDC82\u200D\u2640\uFE0F", "\uD83D\uDC82\u200D\u2642\uFE0F", "\uD83D\uDC82\uD83C\uDFFB", "\uD83D\uDC82\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC82\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC82\uD83C\uDFFC", "\uD83D\uDC82\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC82\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC82\uD83C\uDFFD", "\uD83D\uDC82\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC82\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC82\uD83C\uDFFE", "\uD83D\uDC82\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC82\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC82\uD83C\uDFFF", "\uD83D\uDC82\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC82\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC86", "\uD83D\uDC86\u200D\u2640\uFE0F", "\uD83D\uDC86\u200D\u2642\uFE0F", "\uD83D\uDC86\uD83C\uDFFB", "\uD83D\uDC86\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDC86\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDC86\uD83C\uDFFC", "\uD83D\uDC86\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDC86\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDC86\uD83C\uDFFD", "\uD83D\uDC86\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDC86\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDC86\uD83C\uDFFE", "\uD83D\uDC86\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDC86\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDC86\uD83C\uDFFF", "\uD83D\uDC86\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDC86\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDC87", "\uD83D\uDC87\uD83C\uDFFB", "\uD83D\uDC87\uD83C\uDFFC", "\uD83D\uDC87\uD83C\uDFFD", "\uD83D\uDD75\uD83C\uDFFB", "\uD83D\uDD75\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDD75\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDD75\uD83C\uDFFC", "\uD83D\uDD75\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDD75\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDD75\uD83C\uDFFD", "\uD83D\uDD75\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDD75\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDD75\uD83C\uDFFE", "\uD83D\uDD75\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDD75\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDD75\uD83C\uDFFF", "\uD83D\uDD75\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDD75\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDD75\uFE0F", "\uD83D\uDD75\uFE0F\u200D\u2640\uFE0F", "\uD83D\uDD75\uFE0F\u200D\u2642\uFE0F", "\uD83D\uDE45", "\uD83D\uDE45\u200D\u2640\uFE0F", "\uD83D\uDE45\u200D\u2642\uFE0F", "\uD83D\uDE45\uD83C\uDFFB", "\uD83D\uDE45\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE45\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE45\uD83C\uDFFC", "\uD83D\uDE45\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE45\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE45\uD83C\uDFFD", "\uD83D\uDE45\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE45\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE45\uD83C\uDFFE", "\uD83D\uDE45\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE45\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE45\uD83C\uDFFF", "\uD83D\uDE45\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE45\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDE46", "\uD83D\uDE46\u200D\u2640\uFE0F", "\uD83D\uDE46\u200D\u2642\uFE0F", "\uD83D\uDE46\uD83C\uDFFB", "\uD83D\uDE46\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE46\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE46\uD83C\uDFFC", "\uD83D\uDE46\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE46\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE46\uD83C\uDFFD", "\uD83D\uDE46\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE46\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE46\uD83C\uDFFE", "\uD83D\uDE46\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE46\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE46\uD83C\uDFFF", "\uD83D\uDE46\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE46\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDE47", "\uD83D\uDE47\u200D\u2640\uFE0F", "\uD83D\uDE47\u200D\u2642\uFE0F", "\uD83D\uDE47\uD83C\uDFFB", "\uD83D\uDE47\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE47\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE47\uD83C\uDFFC", "\uD83D\uDE47\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE47\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE47\uD83C\uDFFD", "\uD83D\uDE47\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE47\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE47\uD83C\uDFFE", "\uD83D\uDE47\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE47\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE47\uD83C\uDFFF", "\uD83D\uDE47\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE47\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDE4B", "\uD83D\uDE4B\u200D\u2640\uFE0F", "\uD83D\uDE4B\u200D\u2642\uFE0F", "\uD83D\uDE4B\uD83C\uDFFB", "\uD83D\uDE4B\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE4B\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE4B\uD83C\uDFFC", "\uD83D\uDE4B\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE4B\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE4B\uD83C\uDFFD", "\uD83D\uDE4B\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE4B\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE4B\uD83C\uDFFE", "\uD83D\uDE4B\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE4B\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE4B\uD83C\uDFFF", "\uD83D\uDE4B\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE4B\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDE4D", "\uD83D\uDE4D\u200D\u2640\uFE0F", "\uD83D\uDE4D\u200D\u2642\uFE0F", "\uD83D\uDE4D\uD83C\uDFFB", "\uD83D\uDE4D\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE4D\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE4D\uD83C\uDFFC", "\uD83D\uDE4D\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE4D\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE4D\uD83C\uDFFD", "\uD83D\uDE4D\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE4D\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE4D\uD83C\uDFFE", "\uD83D\uDE4D\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE4D\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE4D\uD83C\uDFFF", "\uD83D\uDE4D\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE4D\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83D\uDE4E", "\uD83D\uDE4E\u200D\u2640\uFE0F", "\uD83D\uDE4E\u200D\u2642\uFE0F", "\uD83D\uDE4E\uD83C\uDFFB", "\uD83D\uDE4E\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83D\uDE4E\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83D\uDE4E\uD83C\uDFFC", "\uD83D\uDE4E\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83D\uDE4E\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83D\uDE4E\uD83C\uDFFD", "\uD83D\uDE4E\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83D\uDE4E\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83D\uDE4E\uD83C\uDFFE", "\uD83D\uDE4E\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83D\uDE4E\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83D\uDE4E\uD83C\uDFFF", "\uD83D\uDE4E\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83D\uDE4E\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDD26", "\uD83E\uDD26\u200D\u2640\uFE0F", "\uD83E\uDD26\u200D\u2642\uFE0F", "\uD83E\uDD26\uD83C\uDFFB", "\uD83E\uDD26\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDD26\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDD26\uD83C\uDFFC", "\uD83E\uDD26\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDD26\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDD26\uD83C\uDFFD", "\uD83E\uDD26\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDD26\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDD26\uD83C\uDFFE", "\uD83E\uDD26\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDD26\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDD26\uD83C\uDFFF", "\uD83E\uDD26\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDD26\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDD30", "\uD83E\uDD30\uD83C\uDFFB", "\uD83E\uDD30\uD83C\uDFFC", "\uD83E\uDD30\uD83C\uDFFD", "\uD83E\uDD30\uD83C\uDFFE", "\uD83E\uDD30\uD83C\uDFFF", "\uD83E\uDD31", "\uD83E\uDD31\uD83C\uDFFB", "\uD83E\uDD31\uD83C\uDFFC", "\uD83E\uDD31\uD83C\uDFFD", "\uD83E\uDD31\uD83C\uDFFE", "\uD83E\uDD31\uD83C\uDFFF", "\uD83E\uDD34", "\uD83E\uDD34\uD83C\uDFFB", "\uD83E\uDD34\uD83C\uDFFC", "\uD83E\uDD34\uD83C\uDFFD", "\uD83E\uDD34\uD83C\uDFFE", "\uD83E\uDD34\uD83C\uDFFF", "\uD83E\uDD35", "\uD83E\uDD35\u200D\u2640\uFE0F", "\uD83E\uDD35\u200D\u2642\uFE0F", "\uD83E\uDD35\uD83C\uDFFB", "\uD83E\uDD35\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDD35\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDD35\uD83C\uDFFC", "\uD83E\uDD35\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDD35\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDD35\uD83C\uDFFD", "\uD83E\uDD35\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDD35\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDD35\uD83C\uDFFE", "\uD83E\uDD35\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDD35\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDD35\uD83C\uDFFF", "\uD83E\uDD35\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDD35\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDD36", "\uD83E\uDD36\uD83C\uDFFB", "\uD83E\uDD36\uD83C\uDFFC", "\uD83E\uDD36\uD83C\uDFFD", "\uD83E\uDD36\uD83C\uDFFE", "\uD83E\uDD36\uD83C\uDFFF", "\uD83E\uDD37", "\uD83E\uDD37\u200D\u2640\uFE0F", "\uD83E\uDD37\u200D\u2642\uFE0F", "\uD83E\uDD37\uD83C\uDFFB", "\uD83E\uDD37\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDD37\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDD37\uD83C\uDFFC", "\uD83E\uDD37\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDD37\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDD37\uD83C\uDFFD", "\uD83E\uDD37\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDD37\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDD37\uD83C\uDFFE", "\uD83E\uDD37\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDD37\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDD37\uD83C\uDFFF", "\uD83E\uDD37\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDD37\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDD77", "\uD83E\uDD77\uD83C\uDFFB", "\uD83E\uDD77\uD83C\uDFFC", "\uD83E\uDD77\uD83C\uDFFD", "\uD83E\uDD77\uD83C\uDFFE", "\uD83E\uDD77\uD83C\uDFFF", "\uD83E\uDDB8", "\uD83E\uDDB8\u200D\u2640\uFE0F", "\uD83E\uDDB8\u200D\u2642\uFE0F", "\uD83E\uDDB8\uD83C\uDFFB", "\uD83E\uDDB8\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDB8\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDB8\uD83C\uDFFC", "\uD83E\uDDB8\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDB8\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDB8\uD83C\uDFFD", "\uD83E\uDDB8\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDB8\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDB8\uD83C\uDFFE", "\uD83E\uDDB8\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDB8\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDB8\uD83C\uDFFF", "\uD83E\uDDB8\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDB8\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDB9", "\uD83E\uDDB9\u200D\u2640\uFE0F", "\uD83E\uDDB9\u200D\u2642\uFE0F", "\uD83E\uDDB9\uD83C\uDFFB", "\uD83E\uDDB9\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDB9\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDB9\uD83C\uDFFC", "\uD83E\uDDB9\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDB9\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDB9\uD83C\uDFFD", "\uD83E\uDDB9\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDB9\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDB9\uD83C\uDFFE", "\uD83E\uDDB9\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDB9\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDB9\uD83C\uDFFF", "\uD83E\uDDB9\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDB9\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDCF", "\uD83E\uDDCF\u200D\u2640\uFE0F", "\uD83E\uDDCF\u200D\u2642\uFE0F", "\uD83E\uDDCF\uD83C\uDFFB", "\uD83E\uDDCF\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDCF\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDCF\uD83C\uDFFC", "\uD83E\uDDCF\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDCF\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDCF\uD83C\uDFFD", "\uD83E\uDDCF\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDCF\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDCF\uD83C\uDFFE", "\uD83E\uDDCF\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDCF\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDCF\uD83C\uDFFF", "\uD83E\uDDCF\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDCF\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDD1", "\uD83E\uDDD1\u200D\u2695\uFE0F", "\uD83E\uDDD1\u200D\u2696\uFE0F", "\uD83E\uDDD1\u200D\u2708\uFE0F", "\uD83E\uDDD1\u200D\uD83C\uDF3E", "\uD83E\uDDD1\u200D\uD83C\uDF73", "\uD83E\uDDD1\u200D\uD83C\uDF7C", "\uD83E\uDDD1\u200D\uD83C\uDF84", "\uD83E\uDDD1\u200D\uD83C\uDF93", "\uD83E\uDDD1\u200D\uD83C\uDFA4", "\uD83E\uDDD1\u200D\uD83C\uDFA8", "\uD83E\uDDD1\u200D\uD83C\uDFEB", "\uD83E\uDDD1\u200D\uD83C\uDFED", "\uD83E\uDDD1\u200D\uD83D\uDCBB", "\uD83E\uDDD1\u200D\uD83D\uDCBC", "\uD83E\uDDD1\u200D\uD83D\uDD27", "\uD83E\uDDD1\u200D\uD83D\uDD2C", "\uD83E\uDDD1\u200D\uD83D\uDE80", "\uD83E\uDDD1\u200D\uD83D\uDE92", "\uD83E\uDDD1\u200D\uD83E\uDDB0", "\uD83E\uDDD1\u200D\uD83E\uDDB1", "\uD83E\uDDD1\u200D\uD83E\uDDB2", "\uD83E\uDDD1\u200D\uD83E\uDDB3", "\uD83E\uDDD1\uD83C\uDFFB", "\uD83E\uDDD1\uD83C\uDFFB\u200D\u2695\uFE0F", "\uD83E\uDDD1\uD83C\uDFFB\u200D\u2696\uFE0F", "\uD83E\uDDD1\uD83C\uDFFB\u200D\u2708\uFE0F", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDF3E", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDF73", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDF7C", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDF84", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDF93", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDFA4", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDFA8", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDFEB", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83C\uDFED", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDCBB", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDCBC", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDD27", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDD2C", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDE80", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83D\uDE92", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDDB0", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDDB1", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDDB2", "\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDDB3", "\uD83E\uDDD1\uD83C\uDFFC", "\uD83E\uDDD1\uD83C\uDFFC\u200D\u2695\uFE0F", "\uD83E\uDDD1\uD83C\uDFFC\u200D\u2696\uFE0F", "\uD83E\uDDD1\uD83C\uDFFC\u200D\u2708\uFE0F", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDF3E", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDF73", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDF7C", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDF84", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDF93", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDFA4", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDFA8", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDFEB", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83C\uDFED", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDCBB", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDCBC", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDD27", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDD2C", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDE80", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83D\uDE92", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDDB0", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDDB1", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDDB2", "\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDDB3", "\uD83E\uDDD1\uD83C\uDFFD", "\uD83E\uDDD1\uD83C\uDFFD\u200D\u2695\uFE0F", "\uD83E\uDDD1\uD83C\uDFFD\u200D\u2696\uFE0F", "\uD83E\uDDD1\uD83C\uDFFD\u200D\u2708\uFE0F", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDF3E", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDF73", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDF7C", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDF84", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDF93", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDFA4", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDFA8", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDFEB", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83C\uDFED", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDCBB", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDCBC", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDD27", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDD2C", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDE80", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83D\uDE92", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDDB0", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDDB1", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDDB2", "\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDDB3", "\uD83E\uDDD1\uD83C\uDFFE", "\uD83E\uDDD1\uD83C\uDFFE\u200D\u2695\uFE0F", "\uD83E\uDDD1\uD83C\uDFFE\u200D\u2696\uFE0F", "\uD83E\uDDD1\uD83C\uDFFE\u200D\u2708\uFE0F", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDF3E", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDF73", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDF7C", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDF84", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDF93", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDFA4", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDFA8", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDFEB", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83C\uDFED", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDCBB", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDCBC", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDD27", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDD2C", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDE80", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83D\uDE92", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDDB0", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDDB1", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDDB2", "\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDDB3", "\uD83E\uDDD1\uD83C\uDFFF", "\uD83E\uDDD1\uD83C\uDFFF\u200D\u2695\uFE0F", "\uD83E\uDDD1\uD83C\uDFFF\u200D\u2696\uFE0F", "\uD83E\uDDD1\uD83C\uDFFF\u200D\u2708\uFE0F", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDF3E", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDF73", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDF7C", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDF84", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDF93", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDFA4", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDFA8", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDFEB", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83C\uDFED", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDCBB", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDCBC", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDD27", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDD2C", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDE80", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83D\uDE92", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83E\uDDB0", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83E\uDDB1", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83E\uDDB2", "\uD83E\uDDD1\uD83C\uDFFF\u200D\uD83E\uDDB3", "\uD83E\uDDD2", "\uD83E\uDDD2\uD83C\uDFFB", "\uD83E\uDDD2\uD83C\uDFFC", "\uD83E\uDDD2\uD83C\uDFFD", "\uD83E\uDDD2\uD83C\uDFFE", "\uD83E\uDDD2\uD83C\uDFFF", "\uD83E\uDDD3", "\uD83E\uDDD3\uD83C\uDFFB", "\uD83E\uDDD3\uD83C\uDFFC", "\uD83E\uDDD3\uD83C\uDFFD", "\uD83E\uDDD3\uD83C\uDFFE", "\uD83E\uDDD3\uD83C\uDFFF", "\uD83E\uDDD4", "\uD83E\uDDD4\u200D\u2640\uFE0F", "\uD83E\uDDD4\u200D\u2642\uFE0F", "\uD83E\uDDD4\uD83C\uDFFB", "\uD83E\uDDD4\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDD4\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDD4\uD83C\uDFFC", "\uD83E\uDDD4\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDD4\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDD4\uD83C\uDFFD", "\uD83E\uDDD4\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDD4\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDD4\uD83C\uDFFE", "\uD83E\uDDD4\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDD4\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDD4\uD83C\uDFFF", "\uD83E\uDDD4\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDD4\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDD5", "\uD83E\uDDD5\uD83C\uDFFB", "\uD83E\uDDD5\uD83C\uDFFC", "\uD83E\uDDD5\uD83C\uDFFD", "\uD83E\uDDD5\uD83C\uDFFE", "\uD83E\uDDD5\uD83C\uDFFF", "\uD83E\uDDD9", "\uD83E\uDDD9\u200D\u2640\uFE0F", "\uD83E\uDDD9\u200D\u2642\uFE0F", "\uD83E\uDDD9\uD83C\uDFFB", "\uD83E\uDDD9\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDD9\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDD9\uD83C\uDFFC", "\uD83E\uDDD9\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDD9\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDD9\uD83C\uDFFD", "\uD83E\uDDD9\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDD9\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDD9\uD83C\uDFFE", "\uD83E\uDDD9\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDD9\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDD9\uD83C\uDFFF", "\uD83E\uDDD9\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDD9\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDDA", "\uD83E\uDDDA\u200D\u2640\uFE0F", "\uD83E\uDDDA\u200D\u2642\uFE0F", "\uD83E\uDDDA\uD83C\uDFFB", "\uD83E\uDDDA\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDDA\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDDA\uD83C\uDFFC", "\uD83E\uDDDA\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDDA\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDDA\uD83C\uDFFD", "\uD83E\uDDDA\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDDA\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDDA\uD83C\uDFFE", "\uD83E\uDDDA\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDDA\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDDA\uD83C\uDFFF", "\uD83E\uDDDA\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDDA\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDDB", "\uD83E\uDDDB\u200D\u2640\uFE0F", "\uD83E\uDDDB\u200D\u2642\uFE0F", "\uD83E\uDDDB\uD83C\uDFFB", "\uD83E\uDDDB\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDDB\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDDB\uD83C\uDFFC", "\uD83E\uDDDB\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDDB\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDDB\uD83C\uDFFD", "\uD83E\uDDDB\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDDB\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDDB\uD83C\uDFFE", "\uD83E\uDDDB\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDDB\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDDB\uD83C\uDFFF", "\uD83E\uDDDB\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDDB\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDDC", "\uD83E\uDDDC\u200D\u2640\uFE0F", "\uD83E\uDDDC\u200D\u2642\uFE0F", "\uD83E\uDDDC\uD83C\uDFFB", "\uD83E\uDDDC\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDDC\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDDC\uD83C\uDFFC", "\uD83E\uDDDC\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDDC\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDDC\uD83C\uDFFD", "\uD83E\uDDDC\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDDC\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDDC\uD83C\uDFFE", "\uD83E\uDDDC\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDDC\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDDC\uD83C\uDFFF", "\uD83E\uDDDC\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDDC\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDDD", "\uD83E\uDDDD\u200D\u2640\uFE0F", "\uD83E\uDDDD\u200D\u2642\uFE0F", "\uD83E\uDDDD\uD83C\uDFFB", "\uD83E\uDDDD\uD83C\uDFFB\u200D\u2640\uFE0F", "\uD83E\uDDDD\uD83C\uDFFB\u200D\u2642\uFE0F", "\uD83E\uDDDD\uD83C\uDFFC", "\uD83E\uDDDD\uD83C\uDFFC\u200D\u2640\uFE0F", "\uD83E\uDDDD\uD83C\uDFFC\u200D\u2642\uFE0F", "\uD83E\uDDDD\uD83C\uDFFD", "\uD83E\uDDDD\uD83C\uDFFD\u200D\u2640\uFE0F", "\uD83E\uDDDD\uD83C\uDFFD\u200D\u2642\uFE0F", "\uD83E\uDDDD\uD83C\uDFFE", "\uD83E\uDDDD\uD83C\uDFFE\u200D\u2640\uFE0F", "\uD83E\uDDDD\uD83C\uDFFE\u200D\u2642\uFE0F", "\uD83E\uDDDD\uD83C\uDFFF", "\uD83E\uDDDD\uD83C\uDFFF\u200D\u2640\uFE0F", "\uD83E\uDDDD\uD83C\uDFFF\u200D\u2642\uFE0F", "\uD83E\uDDDE", "\uD83E\uDDDE\u200D\u2640\uFE0F", "\uD83E\uDDDE\u200D\u2642\uFE0F", "\uD83E\uDDDF", "\uD83E\uDDDF\u200D\u2640\uFE0F", "\uD83E\uDDDF\u200D\u2642\uFE0F"], nature: ["\u2618\uFE0F", "\uD83C\uDF31", "\uD83C\uDF32", "\uD83C\uDF33", "\uD83C\uDF34", "\uD83C\uDF35", "\uD83C\uDF37", "\uD83C\uDF38", "\uD83C\uDF39", "\uD83C\uDF3A", "\uD83C\uDF3B", "\uD83C\uDF3C", "\uD83C\uDF3E", "\uD83C\uDF3F", "\uD83C\uDF40", "\uD83C\uDF41", "\uD83C\uDF42", "\uD83C\uDF43", "\uD83C\uDFF5\uFE0F", "\uD83D\uDC00", "\uD83D\uDC01", "\uD83D\uDC02", "\uD83D\uDC03", "\uD83D\uDC04", "\uD83D\uDC05", "\uD83D\uDC06", "\uD83D\uDC07", "\uD83D\uDC08", "\uD83D\uDC08\u200D\u2B1B", "\uD83D\uDC09", "\uD83D\uDC0A", "\uD83D\uDC0B", "\uD83D\uDC0C", "\uD83D\uDC0D", "\uD83D\uDC0E", "\uD83D\uDC0F", "\uD83D\uDC10", "\uD83D\uDC11", "\uD83D\uDC12", "\uD83D\uDC13", "\uD83D\uDC14", "\uD83D\uDC15", "\uD83D\uDC15\u200D\uD83E\uDDBA", "\uD83D\uDC16", "\uD83D\uDC17", "\uD83D\uDC18", "\uD83D\uDC19", "\uD83D\uDC1A", "\uD83D\uDC1B", "\uD83D\uDC1C", "\uD83D\uDC1D", "\uD83D\uDC1E", "\uD83D\uDC1F", "\uD83D\uDC20", "\uD83D\uDC21", "\uD83D\uDC22", "\uD83D\uDC23", "\uD83D\uDC24", "\uD83D\uDC25", "\uD83D\uDC26", "\uD83D\uDC27", "\uD83D\uDC28", "\uD83D\uDC29", "\uD83D\uDC2A", "\uD83D\uDC2B", "\uD83D\uDC2C", "\uD83D\uDC2D", "\uD83D\uDC2E", "\uD83D\uDC2F", "\uD83D\uDC30", "\uD83D\uDC31", "\uD83D\uDC32", "\uD83D\uDC33", "\uD83D\uDC34", "\uD83D\uDC35", "\uD83D\uDC36", "\uD83D\uDC37", "\uD83D\uDC38", "\uD83D\uDC39", "\uD83D\uDC3A", "\uD83D\uDC3B", "\uD83D\uDC3B\u200D\u2744\uFE0F", "\uD83D\uDC3C", "\uD83D\uDC3D", "\uD83D\uDC3E", "\uD83D\uDC3F\uFE0F", "\uD83D\uDC90", "\uD83D\uDCAE", "\uD83D\uDD4A\uFE0F", "\uD83D\uDD77\uFE0F", "\uD83D\uDD78\uFE0F", "\uD83E\uDD40", "\uD83E\uDD81", "\uD83E\uDD82", "\uD83E\uDD83", "\uD83E\uDD84", "\uD83E\uDD85", "\uD83E\uDD86", "\uD83E\uDD87", "\uD83E\uDD88", "\uD83E\uDD89", "\uD83E\uDD8A", "\uD83E\uDD8B", "\uD83E\uDD8C", "\uD83E\uDD8D", "\uD83E\uDD8E", "\uD83E\uDD8F", "\uD83E\uDD92", "\uD83E\uDD93", "\uD83E\uDD94", "\uD83E\uDD95", "\uD83E\uDD96", "\uD83E\uDD97", "\uD83E\uDD98", "\uD83E\uDD99", "\uD83E\uDD9A", "\uD83E\uDD9B", "\uD83E\uDD9C", "\uD83E\uDD9D", "\uD83E\uDD9F", "\uD83E\uDDA0", "\uD83E\uDDA1", "\uD83E\uDDA2", "\uD83E\uDDA3", "\uD83E\uDDA4", "\uD83E\uDDA5", "\uD83E\uDDA6", "\uD83E\uDDA7", "\uD83E\uDDA8", "\uD83E\uDDA9", "\uD83E\uDDAB", "\uD83E\uDDAC", "\uD83E\uDDAD", "\uD83E\uDDAE", "\uD83E\uDEB0", "\uD83E\uDEB1", "\uD83E\uDEB2", "\uD83E\uDEB3", "\uD83E\uDEB4", "\uD83E\uDEB6"], food: ["\u2615", "\uD83C\uDF2D", "\uD83C\uDF2E", "\uD83C\uDF2F", "\uD83C\uDF30", "\uD83C\uDF36\uFE0F", "\uD83C\uDF3D", "\uD83C\uDF44", "\uD83C\uDF45", "\uD83C\uDF46", "\uD83C\uDF47", "\uD83C\uDF48", "\uD83C\uDF49", "\uD83C\uDF4A", "\uD83C\uDF4B", "\uD83C\uDF4C", "\uD83C\uDF4D", "\uD83C\uDF4E", "\uD83C\uDF4F", "\uD83C\uDF50", "\uD83C\uDF51", "\uD83C\uDF52", "\uD83C\uDF53", "\uD83C\uDF54", "\uD83C\uDF55", "\uD83C\uDF56", "\uD83C\uDF57", "\uD83C\uDF58", "\uD83C\uDF59", "\uD83C\uDF5A", "\uD83C\uDF5B", "\uD83C\uDF5C", "\uD83C\uDF5D", "\uD83C\uDF5E", "\uD83C\uDF5F", "\uD83C\uDF60", "\uD83C\uDF61", "\uD83C\uDF62", "\uD83C\uDF63", "\uD83C\uDF64", "\uD83C\uDF65", "\uD83C\uDF66", "\uD83C\uDF67", "\uD83C\uDF68", "\uD83C\uDF69", "\uD83C\uDF6A", "\uD83C\uDF6B", "\uD83C\uDF6C", "\uD83C\uDF6D", "\uD83C\uDF6E", "\uD83C\uDF6F", "\uD83C\uDF70", "\uD83C\uDF71", "\uD83C\uDF72", "\uD83C\uDF73", "\uD83C\uDF74", "\uD83C\uDF75", "\uD83C\uDF76", "\uD83C\uDF77", "\uD83C\uDF78", "\uD83C\uDF79", "\uD83C\uDF7A", "\uD83C\uDF7B", "\uD83C\uDF7C", "\uD83C\uDF7D\uFE0F", "\uD83C\uDF7E", "\uD83C\uDF7F", "\uD83C\uDF82", "\uD83C\uDFFA", "\uD83D\uDD2A", "\uD83E\uDD42", "\uD83E\uDD43", "\uD83E\uDD44", "\uD83E\uDD50", "\uD83E\uDD51", "\uD83E\uDD52", "\uD83E\uDD53", "\uD83E\uDD54", "\uD83E\uDD55", "\uD83E\uDD56", "\uD83E\uDD57", "\uD83E\uDD58", "\uD83E\uDD59", "\uD83E\uDD5A", "\uD83E\uDD5B", "\uD83E\uDD5C", "\uD83E\uDD5D", "\uD83E\uDD5E", "\uD83E\uDD5F", "\uD83E\uDD60", "\uD83E\uDD61", "\uD83E\uDD62", "\uD83E\uDD63", "\uD83E\uDD64", "\uD83E\uDD65", "\uD83E\uDD66", "\uD83E\uDD67", "\uD83E\uDD68", "\uD83E\uDD69", "\uD83E\uDD6A", "\uD83E\uDD6B", "\uD83E\uDD6C", "\uD83E\uDD6D", "\uD83E\uDD6E", "\uD83E\uDD6F", "\uD83E\uDD80", "\uD83E\uDD90", "\uD83E\uDD91", "\uD83E\uDD9E", "\uD83E\uDDAA", "\uD83E\uDDC0", "\uD83E\uDDC1", "\uD83E\uDDC2", "\uD83E\uDDC3", "\uD83E\uDDC4", "\uD83E\uDDC5", "\uD83E\uDDC6", "\uD83E\uDDC7", "\uD83E\uDDC8", "\uD83E\uDDC9", "\uD83E\uDDCA", "\uD83E\uDDCB", "\uD83E\uDED0", "\uD83E\uDED1", "\uD83E\uDED2", "\uD83E\uDED3", "\uD83E\uDED4", "\uD83E\uDED5", "\uD83E\uDED6"], travel: ["\u231A", "\u231B", "\u23F0", "\u23F1\uFE0F", "\u23F2\uFE0F", "\u23F3", "\u2600\uFE0F", "\u2601\uFE0F", "\u2602\uFE0F", "\u2603\uFE0F", "\u2604\uFE0F", "\u2614", "\u2668\uFE0F", "\u2693", "\u26A1", "\u26C4", "\u26C5", "\u26C8\uFE0F", "\u26E9\uFE0F", "\u26EA", "\u26F0\uFE0F", "\u26F1\uFE0F", "\u26F2", "\u26F4\uFE0F", "\u26F5", "\u26FA", "\u26FD", "\u2708\uFE0F", "\u2744\uFE0F", "\u2B50", "\uD83C\uDF00", "\uD83C\uDF01", "\uD83C\uDF02", "\uD83C\uDF03", "\uD83C\uDF04", "\uD83C\uDF05", "\uD83C\uDF06", "\uD83C\uDF07", "\uD83C\uDF08", "\uD83C\uDF09", "\uD83C\uDF0A", "\uD83C\uDF0B", "\uD83C\uDF0C", "\uD83C\uDF0D", "\uD83C\uDF0E", "\uD83C\uDF0F", "\uD83C\uDF10", "\uD83C\uDF11", "\uD83C\uDF12", "\uD83C\uDF13", "\uD83C\uDF14", "\uD83C\uDF15", "\uD83C\uDF16", "\uD83C\uDF17", "\uD83C\uDF18", "\uD83C\uDF19", "\uD83C\uDF1A", "\uD83C\uDF1B", "\uD83C\uDF1C", "\uD83C\uDF1D", "\uD83C\uDF1E", "\uD83C\uDF1F", "\uD83C\uDF20", "\uD83C\uDF21\uFE0F", "\uD83C\uDF24\uFE0F", "\uD83C\uDF25\uFE0F", "\uD83C\uDF26\uFE0F", "\uD83C\uDF27\uFE0F", "\uD83C\uDF28\uFE0F", "\uD83C\uDF29\uFE0F", "\uD83C\uDF2A\uFE0F", "\uD83C\uDF2B\uFE0F", "\uD83C\uDF2C\uFE0F", "\uD83C\uDFA0", "\uD83C\uDFA1", "\uD83C\uDFA2", "\uD83C\uDFAA", "\uD83C\uDFCD\uFE0F", "\uD83C\uDFCE\uFE0F", "\uD83C\uDFD4\uFE0F", "\uD83C\uDFD5\uFE0F", "\uD83C\uDFD6\uFE0F", "\uD83C\uDFD7\uFE0F", "\uD83C\uDFD8\uFE0F", "\uD83C\uDFD9\uFE0F", "\uD83C\uDFDA\uFE0F", "\uD83C\uDFDB\uFE0F", "\uD83C\uDFDC\uFE0F", "\uD83C\uDFDD\uFE0F", "\uD83C\uDFDE\uFE0F", "\uD83C\uDFDF\uFE0F", "\uD83C\uDFE0", "\uD83C\uDFE1", "\uD83C\uDFE2", "\uD83C\uDFE3", "\uD83C\uDFE4", "\uD83C\uDFE5", "\uD83C\uDFE6", "\uD83C\uDFE8", "\uD83C\uDFE9", "\uD83C\uDFEA", "\uD83C\uDFEB", "\uD83C\uDFEC", "\uD83C\uDFED", "\uD83C\uDFEF", "\uD83C\uDFF0", "\uD83D\uDC88", "\uD83D\uDC92", "\uD83D\uDCA7", "\uD83D\uDCBA", "\uD83D\uDD25", "\uD83D\uDD4B", "\uD83D\uDD4C", "\uD83D\uDD4D", "\uD83D\uDD50", "\uD83D\uDD51", "\uD83D\uDD52", "\uD83D\uDD53", "\uD83D\uDD54", "\uD83D\uDD55", "\uD83D\uDD56", "\uD83D\uDD57", "\uD83D\uDD58", "\uD83D\uDD59", "\uD83D\uDD5A", "\uD83D\uDD5B", "\uD83D\uDD5C", "\uD83D\uDD5D", "\uD83D\uDD5E", "\uD83D\uDD5F", "\uD83D\uDD60", "\uD83D\uDD61", "\uD83D\uDD62", "\uD83D\uDD63", "\uD83D\uDD64", "\uD83D\uDD65", "\uD83D\uDD66", "\uD83D\uDD67", "\uD83D\uDD70\uFE0F", "\uD83D\uDDFA\uFE0F", "\uD83D\uDDFB", "\uD83D\uDDFC", "\uD83D\uDDFD", "\uD83D\uDDFE", "\uD83D\uDE80", "\uD83D\uDE81", "\uD83D\uDE82", "\uD83D\uDE83", "\uD83D\uDE84", "\uD83D\uDE85", "\uD83D\uDE86", "\uD83D\uDE87", "\uD83D\uDE88", "\uD83D\uDE89", "\uD83D\uDE8A", "\uD83D\uDE8B", "\uD83D\uDE8C", "\uD83D\uDE8D", "\uD83D\uDE8E", "\uD83D\uDE8F", "\uD83D\uDE90", "\uD83D\uDE91", "\uD83D\uDE92", "\uD83D\uDE93", "\uD83D\uDE94", "\uD83D\uDE95", "\uD83D\uDE96", "\uD83D\uDE97", "\uD83D\uDE98", "\uD83D\uDE99", "\uD83D\uDE9A", "\uD83D\uDE9B", "\uD83D\uDE9C", "\uD83D\uDE9D", "\uD83D\uDE9E", "\uD83D\uDE9F", "\uD83D\uDEA0", "\uD83D\uDEA1", "\uD83D\uDEA2", "\uD83D\uDEA4", "\uD83D\uDEA5", "\uD83D\uDEA6", "\uD83D\uDEA7", "\uD83D\uDEA8", "\uD83D\uDEB2", "\uD83D\uDECE\uFE0F", "\uD83D\uDED1", "\uD83D\uDED5", "\uD83D\uDED6", "\uD83D\uDEE2\uFE0F", "\uD83D\uDEE3\uFE0F", "\uD83D\uDEE4\uFE0F", "\uD83D\uDEE5\uFE0F", "\uD83D\uDEE9\uFE0F", "\uD83D\uDEEB", "\uD83D\uDEEC", "\uD83D\uDEF0\uFE0F", "\uD83D\uDEF3\uFE0F", "\uD83D\uDEF4", "\uD83D\uDEF5", "\uD83D\uDEF6", "\uD83D\uDEF8", "\uD83D\uDEF9", "\uD83D\uDEFA", "\uD83D\uDEFB", "\uD83D\uDEFC", "\uD83E\uDDBC", "\uD83E\uDDBD", "\uD83E\uDDED", "\uD83E\uDDF1", "\uD83E\uDDF3", "\uD83E\uDE82", "\uD83E\uDE90", "\uD83E\uDEA8", "\uD83E\uDEB5"], activity: ["\u265F\uFE0F", "\u2660\uFE0F", "\u2663\uFE0F", "\u2665\uFE0F", "\u2666\uFE0F", "\u26BD", "\u26BE", "\u26F3", "\u26F8\uFE0F", "\u2728", "\uD83C\uDC04", "\uD83C\uDCCF", "\uD83C\uDF80", "\uD83C\uDF81", "\uD83C\uDF83", "\uD83C\uDF84", "\uD83C\uDF86", "\uD83C\uDF87", "\uD83C\uDF88", "\uD83C\uDF89", "\uD83C\uDF8A", "\uD83C\uDF8B", "\uD83C\uDF8D", "\uD83C\uDF8E", "\uD83C\uDF8F", "\uD83C\uDF90", "\uD83C\uDF91", "\uD83C\uDF96\uFE0F", "\uD83C\uDF97\uFE0F", "\uD83C\uDF9F\uFE0F", "\uD83C\uDFA3", "\uD83C\uDFA8", "\uD83C\uDFAB", "\uD83C\uDFAD", "\uD83C\uDFAE", "\uD83C\uDFAF", "\uD83C\uDFB0", "\uD83C\uDFB1", "\uD83C\uDFB2", "\uD83C\uDFB3", "\uD83C\uDFB4", "\uD83C\uDFBD", "\uD83C\uDFBE", "\uD83C\uDFBF", "\uD83C\uDFC0", "\uD83C\uDFC5", "\uD83C\uDFC6", "\uD83C\uDFC8", "\uD83C\uDFC9", "\uD83C\uDFCF", "\uD83C\uDFD0", "\uD83C\uDFD1", "\uD83C\uDFD2", "\uD83C\uDFD3", "\uD83C\uDFF8", "\uD83D\uDD2E", "\uD83D\uDD79\uFE0F", "\uD83D\uDDBC\uFE0F", "\uD83D\uDEF7", "\uD83E\uDD3F", "\uD83E\uDD45", "\uD83E\uDD47", "\uD83E\uDD48", "\uD83E\uDD49", "\uD83E\uDD4A", "\uD83E\uDD4B", "\uD83E\uDD4C", "\uD83E\uDD4D", "\uD83E\uDD4E", "\uD83E\uDD4F", "\uD83E\uDDE7", "\uD83E\uDDE8", "\uD83E\uDDE9", "\uD83E\uDDF5", "\uD83E\uDDF6", "\uD83E\uDDF8", "\uD83E\uDDFF", "\uD83E\uDE80", "\uD83E\uDE81", "\uD83E\uDE84", "\uD83E\uDE85", "\uD83E\uDE86", "\uD83E\uDEA1", "\uD83E\uDEA2"], object: ["\u2328\uFE0F", "\u260E\uFE0F", "\u2692\uFE0F", "\u2694\uFE0F", "\u2696\uFE0F", "\u2697\uFE0F", "\u2699\uFE0F", "\u26B0\uFE0F", "\u26B1\uFE0F", "\u26CF\uFE0F", "\u26D1\uFE0F", "\u26D3\uFE0F", "\u2702\uFE0F", "\u2709\uFE0F", "\u270F\uFE0F", "\u2712\uFE0F", "\uD83C\uDF92", "\uD83C\uDF93", "\uD83C\uDF99\uFE0F", "\uD83C\uDF9A\uFE0F", "\uD83C\uDF9B\uFE0F", "\uD83C\uDF9E\uFE0F", "\uD83C\uDFA4", "\uD83C\uDFA5", "\uD83C\uDFA7", "\uD83C\uDFA9", "\uD83C\uDFAC", "\uD83C\uDFB5", "\uD83C\uDFB6", "\uD83C\uDFB7", "\uD83C\uDFB8", "\uD83C\uDFB9", "\uD83C\uDFBA", "\uD83C\uDFBB", "\uD83C\uDFBC", "\uD83C\uDFEE", "\uD83C\uDFF7\uFE0F", "\uD83C\uDFF9", "\uD83D\uDC51", "\uD83D\uDC52", "\uD83D\uDC53", "\uD83D\uDC54", "\uD83D\uDC55", "\uD83D\uDC56", "\uD83D\uDC57", "\uD83D\uDC58", "\uD83D\uDC59", "\uD83D\uDC5A", "\uD83D\uDC5B", "\uD83D\uDC5C", "\uD83D\uDC5D", "\uD83D\uDC5E", "\uD83D\uDC5F", "\uD83D\uDC60", "\uD83D\uDC61", "\uD83D\uDC62", "\uD83D\uDC84", "\uD83D\uDC89", "\uD83D\uDC8A", "\uD83D\uDC8D", "\uD83D\uDC8E", "\uD83D\uDCA1", "\uD83D\uDCB0", "\uD83D\uDCB3", "\uD83D\uDCB4", "\uD83D\uDCB5", "\uD83D\uDCB6", "\uD83D\uDCB7", "\uD83D\uDCB8", "\uD83D\uDCB9", "\uD83D\uDCBB", "\uD83D\uDCBC", "\uD83D\uDCBD", "\uD83D\uDCBE", "\uD83D\uDCBF", "\uD83D\uDCC0", "\uD83D\uDCC1", "\uD83D\uDCC2", "\uD83D\uDCC3", "\uD83D\uDCC4", "\uD83D\uDCC5", "\uD83D\uDCC6", "\uD83D\uDCC7", "\uD83D\uDCC8", "\uD83D\uDCC9", "\uD83D\uDCCA", "\uD83D\uDCCB", "\uD83D\uDCCC", "\uD83D\uDCCD", "\uD83D\uDCCE", "\uD83D\uDCCF", "\uD83D\uDCD0", "\uD83D\uDCD1", "\uD83D\uDCD2", "\uD83D\uDCD3", "\uD83D\uDCD4", "\uD83D\uDCD5", "\uD83D\uDCD6", "\uD83D\uDCD7", "\uD83D\uDCD8", "\uD83D\uDCD9", "\uD83D\uDCDA", "\uD83D\uDCDC", "\uD83D\uDCDD", "\uD83D\uDCDE", "\uD83D\uDCDF", "\uD83D\uDCE0", "\uD83D\uDCE1", "\uD83D\uDCE2", "\uD83D\uDCE3", "\uD83D\uDCE4", "\uD83D\uDCE5", "\uD83D\uDCE6", "\uD83D\uDCE7", "\uD83D\uDCE8", "\uD83D\uDCE9", "\uD83D\uDCEA", "\uD83D\uDCEB", "\uD83D\uDCEC", "\uD83D\uDCED", "\uD83D\uDCEE", "\uD83D\uDCEF", "\uD83D\uDCF0", "\uD83D\uDCF1", "\uD83D\uDCF2", "\uD83D\uDCF7", "\uD83D\uDCF8", "\uD83D\uDCF9", "\uD83D\uDCFA", "\uD83D\uDCFB", "\uD83D\uDCFC", "\uD83D\uDCFD\uFE0F", "\uD83D\uDCFF", "\uD83D\uDD07", "\uD83D\uDD08", "\uD83D\uDD09", "\uD83D\uDD0A", "\uD83D\uDD0B", "\uD83D\uDD0C", "\uD83D\uDD0D", "\uD83D\uDD0E", "\uD83D\uDD0F", "\uD83D\uDD10", "\uD83D\uDD11", "\uD83D\uDD12", "\uD83D\uDD13", "\uD83D\uDD14", "\uD83D\uDD15", "\uD83D\uDD16", "\uD83D\uDD17", "\uD83D\uDD26", "\uD83D\uDD27", "\uD83D\uDD28", "\uD83D\uDD29", "\uD83D\uDD2B", "\uD83D\uDD2C", "\uD83D\uDD2D", "\uD83D\uDD6F\uFE0F", "\uD83D\uDD76\uFE0F", "\uD83D\uDD87\uFE0F", "\uD83D\uDD8A\uFE0F", "\uD83D\uDD8B\uFE0F", "\uD83D\uDD8C\uFE0F", "\uD83D\uDD8D\uFE0F", "\uD83D\uDDA5\uFE0F", "\uD83D\uDDA8\uFE0F", "\uD83D\uDDB1\uFE0F", "\uD83D\uDDB2\uFE0F", "\uD83D\uDDC2\uFE0F", "\uD83D\uDDC3\uFE0F", "\uD83D\uDDC4\uFE0F", "\uD83D\uDDD1\uFE0F", "\uD83D\uDDD2\uFE0F", "\uD83D\uDDD3\uFE0F", "\uD83D\uDDDC\uFE0F", "\uD83D\uDDDD\uFE0F", "\uD83D\uDDDE\uFE0F", "\uD83D\uDDE1\uFE0F", "\uD83D\uDDF3\uFE0F", "\uD83D\uDDFF", "\uD83D\uDEAA", "\uD83D\uDEAC", "\uD83D\uDEBD", "\uD83D\uDEBF", "\uD83D\uDEC1", "\uD83D\uDECB\uFE0F", "\uD83D\uDECD\uFE0F", "\uD83D\uDECF\uFE0F", "\uD83D\uDED2", "\uD83D\uDED7", "\uD83D\uDEE0\uFE0F", "\uD83D\uDEE1\uFE0F", "\uD83E\uDD41", "\uD83E\uDD7B", "\uD83E\uDD7C", "\uD83E\uDD7D", "\uD83E\uDD7E", "\uD83E\uDD7F", "\uD83E\uDDAF", "\uD83E\uDDBA", "\uD83E\uDDE2", "\uD83E\uDDE3", "\uD83E\uDDE4", "\uD83E\uDDE5", "\uD83E\uDDE6", "\uD83E\uDDEA", "\uD83E\uDDEB", "\uD83E\uDDEC", "\uD83E\uDDEE", "\uD83E\uDDEF", "\uD83E\uDDF0", "\uD83E\uDDF2", "\uD83E\uDDF4", "\uD83E\uDDF7", "\uD83E\uDDF9", "\uD83E\uDDFA", "\uD83E\uDDFB", "\uD83E\uDDFC", "\uD83E\uDDFD", "\uD83E\uDDFE", "\uD83E\uDE70", "\uD83E\uDE71", "\uD83E\uDE72", "\uD83E\uDE73", "\uD83E\uDE74", "\uD83E\uDE78", "\uD83E\uDE79", "\uD83E\uDE7A", "\uD83E\uDE83", "\uD83E\uDE91", "\uD83E\uDE92", "\uD83E\uDE93", "\uD83E\uDE94", "\uD83E\uDE95", "\uD83E\uDE96", "\uD83E\uDE97", "\uD83E\uDE98", "\uD83E\uDE99", "\uD83E\uDE9A", "\uD83E\uDE9B", "\uD83E\uDE9C", "\uD83E\uDE9D", "\uD83E\uDE9E", "\uD83E\uDE9F", "\uD83E\uDEA0", "\uD83E\uDEA3", "\uD83E\uDEA4", "\uD83E\uDEA5", "\uD83E\uDEA6", "\uD83E\uDEA7"], symbol: ["#\uFE0F\u20E3", "*\uFE0F\u20E3", "0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\xA9\uFE0F", "\xAE\uFE0F", "\u203C\uFE0F", "\u2049\uFE0F", "\u2122\uFE0F", "\u2139\uFE0F", "\u2194\uFE0F", "\u2195\uFE0F", "\u2196\uFE0F", "\u2197\uFE0F", "\u2198\uFE0F", "\u2199\uFE0F", "\u21A9\uFE0F", "\u21AA\uFE0F", "\u23CF\uFE0F", "\u23E9", "\u23EA", "\u23EB", "\u23EC", "\u23ED\uFE0F", "\u23EE\uFE0F", "\u23EF\uFE0F", "\u23F8\uFE0F", "\u23F9\uFE0F", "\u23FA\uFE0F", "\u24C2\uFE0F", "\u25AA\uFE0F", "\u25AB\uFE0F", "\u25B6\uFE0F", "\u25C0\uFE0F", "\u25FB\uFE0F", "\u25FC\uFE0F", "\u25FD", "\u25FE", "\u2611\uFE0F", "\u2622\uFE0F", "\u2623\uFE0F", "\u2626\uFE0F", "\u262A\uFE0F", "\u262E\uFE0F", "\u262F\uFE0F", "\u2638\uFE0F", "\u2640\uFE0F", "\u2642\uFE0F", "\u2648", "\u2649", "\u264A", "\u264B", "\u264C", "\u264D", "\u264E", "\u264F", "\u2650", "\u2651", "\u2652", "\u2653", "\u267B\uFE0F", "\u267E\uFE0F", "\u267F", "\u2695\uFE0F", "\u269B\uFE0F", "\u269C\uFE0F", "\u26A0\uFE0F", "\u26A7\uFE0F", "\u26AA", "\u26AB", "\u26CE", "\u26D4", "\u2705", "\u2714\uFE0F", "\u2716\uFE0F", "\u271D\uFE0F", "\u2721\uFE0F", "\u2733\uFE0F", "\u2734\uFE0F", "\u2747\uFE0F", "\u274C", "\u274E", "\u2753", "\u2754", "\u2755", "\u2757", "\u2795", "\u2796", "\u2797", "\u27A1\uFE0F", "\u27B0", "\u27BF", "\u2934\uFE0F", "\u2935\uFE0F", "\u2B05\uFE0F", "\u2B06\uFE0F", "\u2B07\uFE0F", "\u2B1B", "\u2B1C", "\u2B55", "\u3030\uFE0F", "\u303D\uFE0F", "\u3297\uFE0F", "\u3299\uFE0F", "\uD83C\uDD70\uFE0F", "\uD83C\uDD71\uFE0F", "\uD83C\uDD7E\uFE0F", "\uD83C\uDD7F\uFE0F", "\uD83C\uDD8E", "\uD83C\uDD91", "\uD83C\uDD92", "\uD83C\uDD93", "\uD83C\uDD94", "\uD83C\uDD95", "\uD83C\uDD96", "\uD83C\uDD97", "\uD83C\uDD98", "\uD83C\uDD99", "\uD83C\uDD9A", "\uD83C\uDE01", "\uD83C\uDE02\uFE0F", "\uD83C\uDE1A", "\uD83C\uDE2F", "\uD83C\uDE32", "\uD83C\uDE33", "\uD83C\uDE34", "\uD83C\uDE35", "\uD83C\uDE36", "\uD83C\uDE37\uFE0F", "\uD83C\uDE38", "\uD83C\uDE39", "\uD83C\uDE3A", "\uD83C\uDE50", "\uD83C\uDE51", "\uD83C\uDFA6", "\uD83C\uDFE7", "\uD83D\uDCA0", "\uD83D\uDCB1", "\uD83D\uDCB2", "\uD83D\uDCDB", "\uD83D\uDCF3", "\uD83D\uDCF4", "\uD83D\uDCF5", "\uD83D\uDCF6", "\uD83D\uDD00", "\uD83D\uDD01", "\uD83D\uDD02", "\uD83D\uDD03", "\uD83D\uDD04", "\uD83D\uDD05", "\uD83D\uDD06", "\uD83D\uDD18", "\uD83D\uDD19", "\uD83D\uDD1A", "\uD83D\uDD1B", "\uD83D\uDD1C", "\uD83D\uDD1D", "\uD83D\uDD1E", "\uD83D\uDD1F", "\uD83D\uDD20", "\uD83D\uDD21", "\uD83D\uDD22", "\uD83D\uDD23", "\uD83D\uDD24", "\uD83D\uDD2F", "\uD83D\uDD30", "\uD83D\uDD31", "\uD83D\uDD32", "\uD83D\uDD33", "\uD83D\uDD34", "\uD83D\uDD35", "\uD83D\uDD36", "\uD83D\uDD37", "\uD83D\uDD38", "\uD83D\uDD39", "\uD83D\uDD3A", "\uD83D\uDD3B", "\uD83D\uDD3C", "\uD83D\uDD3D", "\uD83D\uDD49\uFE0F", "\uD83D\uDD4E", "\uD83D\uDEAB", "\uD83D\uDEAD", "\uD83D\uDEAE", "\uD83D\uDEAF", "\uD83D\uDEB0", "\uD83D\uDEB1", "\uD83D\uDEB3", "\uD83D\uDEB7", "\uD83D\uDEB8", "\uD83D\uDEB9", "\uD83D\uDEBA", "\uD83D\uDEBB", "\uD83D\uDEBC", "\uD83D\uDEBE", "\uD83D\uDEC2", "\uD83D\uDEC3", "\uD83D\uDEC4", "\uD83D\uDEC5", "\uD83D\uDED0", "\uD83D\uDFE0", "\uD83D\uDFE1", "\uD83D\uDFE2", "\uD83D\uDFE3", "\uD83D\uDFE4", "\uD83D\uDFE5", "\uD83D\uDFE6", "\uD83D\uDFE7", "\uD83D\uDFE8", "\uD83D\uDFE9", "\uD83D\uDFEA", "\uD83D\uDFEB"], flag: ["\uD83C\uDDE6\uD83C\uDDE8", "\uD83C\uDDE6\uD83C\uDDE9", "\uD83C\uDDE6\uD83C\uDDEA", "\uD83C\uDDE6\uD83C\uDDEB", "\uD83C\uDDE6\uD83C\uDDEC", "\uD83C\uDDE6\uD83C\uDDEE", "\uD83C\uDDE6\uD83C\uDDF1", "\uD83C\uDDE6\uD83C\uDDF2", "\uD83C\uDDE6\uD83C\uDDF4", "\uD83C\uDDE6\uD83C\uDDF6", "\uD83C\uDDE6\uD83C\uDDF7", "\uD83C\uDDE6\uD83C\uDDF8", "\uD83C\uDDE6\uD83C\uDDF9", "\uD83C\uDDE6\uD83C\uDDFA", "\uD83C\uDDE6\uD83C\uDDFC", "\uD83C\uDDE6\uD83C\uDDFD", "\uD83C\uDDE6\uD83C\uDDFF", "\uD83C\uDDE7\uD83C\uDDE6", "\uD83C\uDDE7\uD83C\uDDE7", "\uD83C\uDDE7\uD83C\uDDE9", "\uD83C\uDDE7\uD83C\uDDEA", "\uD83C\uDDE7\uD83C\uDDEB", "\uD83C\uDDE7\uD83C\uDDEC", "\uD83C\uDDE7\uD83C\uDDED", "\uD83C\uDDE7\uD83C\uDDEE", "\uD83C\uDDE7\uD83C\uDDEF", "\uD83C\uDDE7\uD83C\uDDF1", "\uD83C\uDDE7\uD83C\uDDF2", "\uD83C\uDDE7\uD83C\uDDF3", "\uD83C\uDDE7\uD83C\uDDF4", "\uD83C\uDDE7\uD83C\uDDF6", "\uD83C\uDDE7\uD83C\uDDF7", "\uD83C\uDDE7\uD83C\uDDF8", "\uD83C\uDDE7\uD83C\uDDF9", "\uD83C\uDDE7\uD83C\uDDFB", "\uD83C\uDDE7\uD83C\uDDFC", "\uD83C\uDDE7\uD83C\uDDFE", "\uD83C\uDDE7\uD83C\uDDFF", "\uD83C\uDDE8\uD83C\uDDE6", "\uD83C\uDDE8\uD83C\uDDE8", "\uD83C\uDDE8\uD83C\uDDE9", "\uD83C\uDDE8\uD83C\uDDEB", "\uD83C\uDDE8\uD83C\uDDEC", "\uD83C\uDDE8\uD83C\uDDED", "\uD83C\uDDE8\uD83C\uDDEE", "\uD83C\uDDE8\uD83C\uDDF0", "\uD83C\uDDE8\uD83C\uDDF1", "\uD83C\uDDE8\uD83C\uDDF2", "\uD83C\uDDE8\uD83C\uDDF3", "\uD83C\uDDE8\uD83C\uDDF4", "\uD83C\uDDE8\uD83C\uDDF5", "\uD83C\uDDE8\uD83C\uDDF7", "\uD83C\uDDE8\uD83C\uDDFA", "\uD83C\uDDE8\uD83C\uDDFB", "\uD83C\uDDE8\uD83C\uDDFC", "\uD83C\uDDE8\uD83C\uDDFD", "\uD83C\uDDE8\uD83C\uDDFE", "\uD83C\uDDE8\uD83C\uDDFF", "\uD83C\uDDE9\uD83C\uDDEA", "\uD83C\uDDE9\uD83C\uDDEC", "\uD83C\uDDE9\uD83C\uDDEF", "\uD83C\uDDE9\uD83C\uDDF0", "\uD83C\uDDE9\uD83C\uDDF2", "\uD83C\uDDE9\uD83C\uDDF4", "\uD83C\uDDE9\uD83C\uDDFF", "\uD83C\uDDEA\uD83C\uDDE6", "\uD83C\uDDEA\uD83C\uDDE8", "\uD83C\uDDEA\uD83C\uDDEA", "\uD83C\uDDEA\uD83C\uDDEC", "\uD83C\uDDEA\uD83C\uDDED", "\uD83C\uDDEA\uD83C\uDDF7", "\uD83C\uDDEA\uD83C\uDDF8", "\uD83C\uDDEA\uD83C\uDDF9", "\uD83C\uDDEA\uD83C\uDDFA", "\uD83C\uDDEB\uD83C\uDDEE", "\uD83C\uDDEB\uD83C\uDDEF", "\uD83C\uDDEB\uD83C\uDDF0", "\uD83C\uDDEB\uD83C\uDDF2", "\uD83C\uDDEB\uD83C\uDDF4", "\uD83C\uDDEB\uD83C\uDDF7", "\uD83C\uDDEC\uD83C\uDDE6", "\uD83C\uDDEC\uD83C\uDDE7", "\uD83C\uDDEC\uD83C\uDDE9", "\uD83C\uDDEC\uD83C\uDDEA", "\uD83C\uDDEC\uD83C\uDDEB", "\uD83C\uDDEC\uD83C\uDDEC", "\uD83C\uDDEC\uD83C\uDDED", "\uD83C\uDDEC\uD83C\uDDEE", "\uD83C\uDDEC\uD83C\uDDF1", "\uD83C\uDDEC\uD83C\uDDF2", "\uD83C\uDDEC\uD83C\uDDF3", "\uD83C\uDDEC\uD83C\uDDF5", "\uD83C\uDDEC\uD83C\uDDF6", "\uD83C\uDDEC\uD83C\uDDF7", "\uD83C\uDDEC\uD83C\uDDF8", "\uD83C\uDDEC\uD83C\uDDF9", "\uD83C\uDDEC\uD83C\uDDFA", "\uD83C\uDDEC\uD83C\uDDFC", "\uD83C\uDDEC\uD83C\uDDFE", "\uD83C\uDDED\uD83C\uDDF0", "\uD83C\uDDED\uD83C\uDDF2", "\uD83C\uDDED\uD83C\uDDF3", "\uD83C\uDDED\uD83C\uDDF7", "\uD83C\uDDED\uD83C\uDDF9", "\uD83C\uDDED\uD83C\uDDFA", "\uD83C\uDDEE\uD83C\uDDE8", "\uD83C\uDDEE\uD83C\uDDE9", "\uD83C\uDDEE\uD83C\uDDEA", "\uD83C\uDDEE\uD83C\uDDF1", "\uD83C\uDDEE\uD83C\uDDF2", "\uD83C\uDDEE\uD83C\uDDF3", "\uD83C\uDDEE\uD83C\uDDF4", "\uD83C\uDDEE\uD83C\uDDF6", "\uD83C\uDDEE\uD83C\uDDF7", "\uD83C\uDDEE\uD83C\uDDF8", "\uD83C\uDDEE\uD83C\uDDF9", "\uD83C\uDDEF\uD83C\uDDEA", "\uD83C\uDDEF\uD83C\uDDF2", "\uD83C\uDDEF\uD83C\uDDF4", "\uD83C\uDDEF\uD83C\uDDF5", "\uD83C\uDDF0\uD83C\uDDEA", "\uD83C\uDDF0\uD83C\uDDEC", "\uD83C\uDDF0\uD83C\uDDED", "\uD83C\uDDF0\uD83C\uDDEE", "\uD83C\uDDF0\uD83C\uDDF2", "\uD83C\uDDF0\uD83C\uDDF3", "\uD83C\uDDF0\uD83C\uDDF5", "\uD83C\uDDF0\uD83C\uDDF7", "\uD83C\uDDF0\uD83C\uDDFC", "\uD83C\uDDF0\uD83C\uDDFE", "\uD83C\uDDF0\uD83C\uDDFF", "\uD83C\uDDF1\uD83C\uDDE6", "\uD83C\uDDF1\uD83C\uDDE7", "\uD83C\uDDF1\uD83C\uDDE8", "\uD83C\uDDF1\uD83C\uDDEE", "\uD83C\uDDF1\uD83C\uDDF0", "\uD83C\uDDF1\uD83C\uDDF7", "\uD83C\uDDF1\uD83C\uDDF8", "\uD83C\uDDF1\uD83C\uDDF9", "\uD83C\uDDF1\uD83C\uDDFA", "\uD83C\uDDF1\uD83C\uDDFB", "\uD83C\uDDF1\uD83C\uDDFE", "\uD83C\uDDF2\uD83C\uDDE6", "\uD83C\uDDF2\uD83C\uDDE8", "\uD83C\uDDF2\uD83C\uDDE9", "\uD83C\uDDF2\uD83C\uDDEA", "\uD83C\uDDF2\uD83C\uDDEB", "\uD83C\uDDF2\uD83C\uDDEC", "\uD83C\uDDF2\uD83C\uDDED", "\uD83C\uDDF2\uD83C\uDDF0", "\uD83C\uDDF2\uD83C\uDDF1", "\uD83C\uDDF2\uD83C\uDDF2", "\uD83C\uDDF2\uD83C\uDDF3", "\uD83C\uDDF2\uD83C\uDDF4", "\uD83C\uDDF2\uD83C\uDDF5", "\uD83C\uDDF2\uD83C\uDDF6", "\uD83C\uDDF2\uD83C\uDDF7", "\uD83C\uDDF2\uD83C\uDDF8", "\uD83C\uDDF2\uD83C\uDDF9", "\uD83C\uDDF2\uD83C\uDDFA", "\uD83C\uDDF2\uD83C\uDDFB", "\uD83C\uDDF2\uD83C\uDDFC", "\uD83C\uDDF2\uD83C\uDDFD", "\uD83C\uDDF2\uD83C\uDDFE", "\uD83C\uDDF2\uD83C\uDDFF", "\uD83C\uDDF3\uD83C\uDDE6", "\uD83C\uDDF3\uD83C\uDDE8", "\uD83C\uDDF3\uD83C\uDDEA", "\uD83C\uDDF3\uD83C\uDDEB", "\uD83C\uDDF3\uD83C\uDDEC", "\uD83C\uDDF3\uD83C\uDDEE", "\uD83C\uDDF3\uD83C\uDDF1", "\uD83C\uDDF3\uD83C\uDDF4", "\uD83C\uDDF3\uD83C\uDDF5", "\uD83C\uDDF3\uD83C\uDDF7", "\uD83C\uDDF3\uD83C\uDDFA", "\uD83C\uDDF3\uD83C\uDDFF", "\uD83C\uDDF4\uD83C\uDDF2", "\uD83C\uDDF5\uD83C\uDDE6", "\uD83C\uDDF5\uD83C\uDDEA", "\uD83C\uDDF5\uD83C\uDDEB", "\uD83C\uDDF5\uD83C\uDDEC", "\uD83C\uDDF5\uD83C\uDDED", "\uD83C\uDDF5\uD83C\uDDF0", "\uD83C\uDDF5\uD83C\uDDF1", "\uD83C\uDDF5\uD83C\uDDF2", "\uD83C\uDDF5\uD83C\uDDF3", "\uD83C\uDDF5\uD83C\uDDF7", "\uD83C\uDDF5\uD83C\uDDF8", "\uD83C\uDDF5\uD83C\uDDF9", "\uD83C\uDDF5\uD83C\uDDFC", "\uD83C\uDDF5\uD83C\uDDFE", "\uD83C\uDDF6\uD83C\uDDE6", "\uD83C\uDDF7\uD83C\uDDEA", "\uD83C\uDDF7\uD83C\uDDF4", "\uD83C\uDDF7\uD83C\uDDF8", "\uD83C\uDDF7\uD83C\uDDFA", "\uD83C\uDDF7\uD83C\uDDFC", "\uD83C\uDDF8\uD83C\uDDE6", "\uD83C\uDDF8\uD83C\uDDE7", "\uD83C\uDDF8\uD83C\uDDE8", "\uD83C\uDDF8\uD83C\uDDE9", "\uD83C\uDDF8\uD83C\uDDEA", "\uD83C\uDDF8\uD83C\uDDEC", "\uD83C\uDDF8\uD83C\uDDED", "\uD83C\uDDF8\uD83C\uDDEE", "\uD83C\uDDF8\uD83C\uDDEF", "\uD83C\uDDF8\uD83C\uDDF0", "\uD83C\uDDF8\uD83C\uDDF1", "\uD83C\uDDF8\uD83C\uDDF2", "\uD83C\uDDF8\uD83C\uDDF3", "\uD83C\uDDF8\uD83C\uDDF4", "\uD83C\uDDF8\uD83C\uDDF7", "\uD83C\uDDF8\uD83C\uDDF8", "\uD83C\uDDF8\uD83C\uDDF9", "\uD83C\uDDF8\uD83C\uDDFB", "\uD83C\uDDF8\uD83C\uDDFD", "\uD83C\uDDF8\uD83C\uDDFE", "\uD83C\uDDF8\uD83C\uDDFF", "\uD83C\uDDF9\uD83C\uDDE6", "\uD83C\uDDF9\uD83C\uDDE8", "\uD83C\uDDF9\uD83C\uDDE9", "\uD83C\uDDF9\uD83C\uDDEB", "\uD83C\uDDF9\uD83C\uDDEC", "\uD83C\uDDF9\uD83C\uDDED", "\uD83C\uDDF9\uD83C\uDDEF", "\uD83C\uDDF9\uD83C\uDDF0", "\uD83C\uDDF9\uD83C\uDDF1", "\uD83C\uDDF9\uD83C\uDDF2", "\uD83C\uDDF9\uD83C\uDDF3", "\uD83C\uDDF9\uD83C\uDDF4", "\uD83C\uDDF9\uD83C\uDDF7", "\uD83C\uDDF9\uD83C\uDDF9", "\uD83C\uDDF9\uD83C\uDDFB", "\uD83C\uDDF9\uD83C\uDDFC", "\uD83C\uDDF9\uD83C\uDDFF", "\uD83C\uDDFA\uD83C\uDDE6", "\uD83C\uDDFA\uD83C\uDDEC", "\uD83C\uDDFA\uD83C\uDDF2", "\uD83C\uDDFA\uD83C\uDDF3", "\uD83C\uDDFA\uD83C\uDDF8", "\uD83C\uDDFA\uD83C\uDDFE", "\uD83C\uDDFA\uD83C\uDDFF", "\uD83C\uDDFB\uD83C\uDDE6", "\uD83C\uDDFB\uD83C\uDDE8", "\uD83C\uDDFB\uD83C\uDDEA", "\uD83C\uDDFB\uD83C\uDDEC", "\uD83C\uDDFB\uD83C\uDDEE", "\uD83C\uDDFB\uD83C\uDDF3", "\uD83C\uDDFB\uD83C\uDDFA", "\uD83C\uDDFC\uD83C\uDDEB", "\uD83C\uDDFC\uD83C\uDDF8", "\uD83C\uDDFD\uD83C\uDDF0", "\uD83C\uDDFE\uD83C\uDDEA", "\uD83C\uDDFE\uD83C\uDDF9", "\uD83C\uDDFF\uD83C\uDDE6", "\uD83C\uDDFF\uD83C\uDDF2", "\uD83C\uDDFF\uD83C\uDDFC", "\uD83C\uDF8C", "\uD83C\uDFC1", "\uD83C\uDFF3\uFE0F", "\uD83C\uDFF3\uFE0F\u200D\u26A7\uFE0F", "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08", "\uD83C\uDFF4", "\uD83C\uDFF4\u200D\u2620\uFE0F", "\uD83D\uDEA9"] };
var lr2 = { informational: [100, 101, 102, 103], success: [200, 201, 202, 203, 204, 205, 206, 207, 208, 226], redirection: [300, 301, 302, 303, 304, 305, 306, 307, 308], clientError: [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451], serverError: [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511] };
var mr2 = ["ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "none"];
var ur2 = ["FakerBot/{{system.semver}}", "Googlebot/2.1 (+http://www.google.com/bot.html)", 'Mozilla/5.0 (Linux; Android {{number.int({"min":5,"max":13})}}; {{helpers.arrayElement(["SM-G998U","SM-G998B","SM-G998N","SM-G998P","SM-T800"])}}) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Mobile Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:{{number.int({"min":75, "max":133})}}.0) Gecko/20100101 Firefox/{{number.int({"min":75, "max":133})}}.0', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Version/16.1 Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_15_7) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}}', 'Mozilla/5.0 (Windows NT {{helpers.arrayElement(["5.1","5.2","6.0","6.1","6.2","6.3","10.0"])}}; Win64; x64) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Chrome/{{number.int({"min":55,"max":131})}}.{{system.semver}} Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}} Edg/{{number.int({"min":110,"max":131})}}.{{system.semver}}', 'Mozilla/5.0 (X11; Linux x86_64; rv:{{number.int({"min":75,"max":133})}}.0) Gecko/20100101 Firefox/{{number.int({"min":75,"max":133})}}.0', 'Mozilla/5.0 (compatible; MSIE {{number.int({"min":6,"max":10})}}.0; Windows NT {{helpers.arrayElement(["5.1","5.2","6.0","6.1","6.2","6.3","10.0"])}}; Trident/{{number.int({"min":4,"max":7})}}.0)', 'Mozilla/5.0 (iPhone; CPU iPhone OS {{number.int({"min":10,"max":18})}}_{{number.int({"min":0,"max":4})}} like Mac OS X) AppleWebKit/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}.{{number.int({"min":0,"max":99})}} (KHTML, like Gecko) Version/{{number.int({"min":10,"max":18})}}_{{number.int({"min":0,"max":4})}} Mobile/15E148 Safari/{{number.int({"min":536,"max":605})}}.{{number.int({"min":0,"max":99})}}'];
var at = { emoji: cr2, http_status_code: lr2, jwt_algorithm: mr2, user_agent_pattern: ur2 };
var pr2 = at;
var hr2 = [{ alpha2: "AD", alpha3: "AND", numeric: "020" }, { alpha2: "AE", alpha3: "ARE", numeric: "784" }, { alpha2: "AF", alpha3: "AFG", numeric: "004" }, { alpha2: "AG", alpha3: "ATG", numeric: "028" }, { alpha2: "AI", alpha3: "AIA", numeric: "660" }, { alpha2: "AL", alpha3: "ALB", numeric: "008" }, { alpha2: "AM", alpha3: "ARM", numeric: "051" }, { alpha2: "AO", alpha3: "AGO", numeric: "024" }, { alpha2: "AQ", alpha3: "ATA", numeric: "010" }, { alpha2: "AR", alpha3: "ARG", numeric: "032" }, { alpha2: "AS", alpha3: "ASM", numeric: "016" }, { alpha2: "AT", alpha3: "AUT", numeric: "040" }, { alpha2: "AU", alpha3: "AUS", numeric: "036" }, { alpha2: "AW", alpha3: "ABW", numeric: "533" }, { alpha2: "AX", alpha3: "ALA", numeric: "248" }, { alpha2: "AZ", alpha3: "AZE", numeric: "031" }, { alpha2: "BA", alpha3: "BIH", numeric: "070" }, { alpha2: "BB", alpha3: "BRB", numeric: "052" }, { alpha2: "BD", alpha3: "BGD", numeric: "050" }, { alpha2: "BE", alpha3: "BEL", numeric: "056" }, { alpha2: "BF", alpha3: "BFA", numeric: "854" }, { alpha2: "BG", alpha3: "BGR", numeric: "100" }, { alpha2: "BH", alpha3: "BHR", numeric: "048" }, { alpha2: "BI", alpha3: "BDI", numeric: "108" }, { alpha2: "BJ", alpha3: "BEN", numeric: "204" }, { alpha2: "BL", alpha3: "BLM", numeric: "652" }, { alpha2: "BM", alpha3: "BMU", numeric: "060" }, { alpha2: "BN", alpha3: "BRN", numeric: "096" }, { alpha2: "BO", alpha3: "BOL", numeric: "068" }, { alpha2: "BQ", alpha3: "BES", numeric: "535" }, { alpha2: "BR", alpha3: "BRA", numeric: "076" }, { alpha2: "BS", alpha3: "BHS", numeric: "044" }, { alpha2: "BT", alpha3: "BTN", numeric: "064" }, { alpha2: "BV", alpha3: "BVT", numeric: "074" }, { alpha2: "BW", alpha3: "BWA", numeric: "072" }, { alpha2: "BY", alpha3: "BLR", numeric: "112" }, { alpha2: "BZ", alpha3: "BLZ", numeric: "084" }, { alpha2: "CA", alpha3: "CAN", numeric: "124" }, { alpha2: "CC", alpha3: "CCK", numeric: "166" }, { alpha2: "CD", alpha3: "COD", numeric: "180" }, { alpha2: "CF", alpha3: "CAF", numeric: "140" }, { alpha2: "CG", alpha3: "COG", numeric: "178" }, { alpha2: "CH", alpha3: "CHE", numeric: "756" }, { alpha2: "CI", alpha3: "CIV", numeric: "384" }, { alpha2: "CK", alpha3: "COK", numeric: "184" }, { alpha2: "CL", alpha3: "CHL", numeric: "152" }, { alpha2: "CM", alpha3: "CMR", numeric: "120" }, { alpha2: "CN", alpha3: "CHN", numeric: "156" }, { alpha2: "CO", alpha3: "COL", numeric: "170" }, { alpha2: "CR", alpha3: "CRI", numeric: "188" }, { alpha2: "CU", alpha3: "CUB", numeric: "192" }, { alpha2: "CV", alpha3: "CPV", numeric: "132" }, { alpha2: "CW", alpha3: "CUW", numeric: "531" }, { alpha2: "CX", alpha3: "CXR", numeric: "162" }, { alpha2: "CY", alpha3: "CYP", numeric: "196" }, { alpha2: "CZ", alpha3: "CZE", numeric: "203" }, { alpha2: "DE", alpha3: "DEU", numeric: "276" }, { alpha2: "DJ", alpha3: "DJI", numeric: "262" }, { alpha2: "DK", alpha3: "DNK", numeric: "208" }, { alpha2: "DM", alpha3: "DMA", numeric: "212" }, { alpha2: "DO", alpha3: "DOM", numeric: "214" }, { alpha2: "DZ", alpha3: "DZA", numeric: "012" }, { alpha2: "EC", alpha3: "ECU", numeric: "218" }, { alpha2: "EE", alpha3: "EST", numeric: "233" }, { alpha2: "EG", alpha3: "EGY", numeric: "818" }, { alpha2: "EH", alpha3: "ESH", numeric: "732" }, { alpha2: "ER", alpha3: "ERI", numeric: "232" }, { alpha2: "ES", alpha3: "ESP", numeric: "724" }, { alpha2: "ET", alpha3: "ETH", numeric: "231" }, { alpha2: "FI", alpha3: "FIN", numeric: "246" }, { alpha2: "FJ", alpha3: "FJI", numeric: "242" }, { alpha2: "FK", alpha3: "FLK", numeric: "238" }, { alpha2: "FM", alpha3: "FSM", numeric: "583" }, { alpha2: "FO", alpha3: "FRO", numeric: "234" }, { alpha2: "FR", alpha3: "FRA", numeric: "250" }, { alpha2: "GA", alpha3: "GAB", numeric: "266" }, { alpha2: "GB", alpha3: "GBR", numeric: "826" }, { alpha2: "GD", alpha3: "GRD", numeric: "308" }, { alpha2: "GE", alpha3: "GEO", numeric: "268" }, { alpha2: "GF", alpha3: "GUF", numeric: "254" }, { alpha2: "GG", alpha3: "GGY", numeric: "831" }, { alpha2: "GH", alpha3: "GHA", numeric: "288" }, { alpha2: "GI", alpha3: "GIB", numeric: "292" }, { alpha2: "GL", alpha3: "GRL", numeric: "304" }, { alpha2: "GM", alpha3: "GMB", numeric: "270" }, { alpha2: "GN", alpha3: "GIN", numeric: "324" }, { alpha2: "GP", alpha3: "GLP", numeric: "312" }, { alpha2: "GQ", alpha3: "GNQ", numeric: "226" }, { alpha2: "GR", alpha3: "GRC", numeric: "300" }, { alpha2: "GS", alpha3: "SGS", numeric: "239" }, { alpha2: "GT", alpha3: "GTM", numeric: "320" }, { alpha2: "GU", alpha3: "GUM", numeric: "316" }, { alpha2: "GW", alpha3: "GNB", numeric: "624" }, { alpha2: "GY", alpha3: "GUY", numeric: "328" }, { alpha2: "HK", alpha3: "HKG", numeric: "344" }, { alpha2: "HM", alpha3: "HMD", numeric: "334" }, { alpha2: "HN", alpha3: "HND", numeric: "340" }, { alpha2: "HR", alpha3: "HRV", numeric: "191" }, { alpha2: "HT", alpha3: "HTI", numeric: "332" }, { alpha2: "HU", alpha3: "HUN", numeric: "348" }, { alpha2: "ID", alpha3: "IDN", numeric: "360" }, { alpha2: "IE", alpha3: "IRL", numeric: "372" }, { alpha2: "IL", alpha3: "ISR", numeric: "376" }, { alpha2: "IM", alpha3: "IMN", numeric: "833" }, { alpha2: "IN", alpha3: "IND", numeric: "356" }, { alpha2: "IO", alpha3: "IOT", numeric: "086" }, { alpha2: "IQ", alpha3: "IRQ", numeric: "368" }, { alpha2: "IR", alpha3: "IRN", numeric: "364" }, { alpha2: "IS", alpha3: "ISL", numeric: "352" }, { alpha2: "IT", alpha3: "ITA", numeric: "380" }, { alpha2: "JE", alpha3: "JEY", numeric: "832" }, { alpha2: "JM", alpha3: "JAM", numeric: "388" }, { alpha2: "JO", alpha3: "JOR", numeric: "400" }, { alpha2: "JP", alpha3: "JPN", numeric: "392" }, { alpha2: "KE", alpha3: "KEN", numeric: "404" }, { alpha2: "KG", alpha3: "KGZ", numeric: "417" }, { alpha2: "KH", alpha3: "KHM", numeric: "116" }, { alpha2: "KI", alpha3: "KIR", numeric: "296" }, { alpha2: "KM", alpha3: "COM", numeric: "174" }, { alpha2: "KN", alpha3: "KNA", numeric: "659" }, { alpha2: "KP", alpha3: "PRK", numeric: "408" }, { alpha2: "KR", alpha3: "KOR", numeric: "410" }, { alpha2: "KW", alpha3: "KWT", numeric: "414" }, { alpha2: "KY", alpha3: "CYM", numeric: "136" }, { alpha2: "KZ", alpha3: "KAZ", numeric: "398" }, { alpha2: "LA", alpha3: "LAO", numeric: "418" }, { alpha2: "LB", alpha3: "LBN", numeric: "422" }, { alpha2: "LC", alpha3: "LCA", numeric: "662" }, { alpha2: "LI", alpha3: "LIE", numeric: "438" }, { alpha2: "LK", alpha3: "LKA", numeric: "144" }, { alpha2: "LR", alpha3: "LBR", numeric: "430" }, { alpha2: "LS", alpha3: "LSO", numeric: "426" }, { alpha2: "LT", alpha3: "LTU", numeric: "440" }, { alpha2: "LU", alpha3: "LUX", numeric: "442" }, { alpha2: "LV", alpha3: "LVA", numeric: "428" }, { alpha2: "LY", alpha3: "LBY", numeric: "434" }, { alpha2: "MA", alpha3: "MAR", numeric: "504" }, { alpha2: "MC", alpha3: "MCO", numeric: "492" }, { alpha2: "MD", alpha3: "MDA", numeric: "498" }, { alpha2: "ME", alpha3: "MNE", numeric: "499" }, { alpha2: "MF", alpha3: "MAF", numeric: "663" }, { alpha2: "MG", alpha3: "MDG", numeric: "450" }, { alpha2: "MH", alpha3: "MHL", numeric: "584" }, { alpha2: "MK", alpha3: "MKD", numeric: "807" }, { alpha2: "ML", alpha3: "MLI", numeric: "466" }, { alpha2: "MM", alpha3: "MMR", numeric: "104" }, { alpha2: "MN", alpha3: "MNG", numeric: "496" }, { alpha2: "MO", alpha3: "MAC", numeric: "446" }, { alpha2: "MP", alpha3: "MNP", numeric: "580" }, { alpha2: "MQ", alpha3: "MTQ", numeric: "474" }, { alpha2: "MR", alpha3: "MRT", numeric: "478" }, { alpha2: "MS", alpha3: "MSR", numeric: "500" }, { alpha2: "MT", alpha3: "MLT", numeric: "470" }, { alpha2: "MU", alpha3: "MUS", numeric: "480" }, { alpha2: "MV", alpha3: "MDV", numeric: "462" }, { alpha2: "MW", alpha3: "MWI", numeric: "454" }, { alpha2: "MX", alpha3: "MEX", numeric: "484" }, { alpha2: "MY", alpha3: "MYS", numeric: "458" }, { alpha2: "MZ", alpha3: "MOZ", numeric: "508" }, { alpha2: "NA", alpha3: "NAM", numeric: "516" }, { alpha2: "NC", alpha3: "NCL", numeric: "540" }, { alpha2: "NE", alpha3: "NER", numeric: "562" }, { alpha2: "NF", alpha3: "NFK", numeric: "574" }, { alpha2: "NG", alpha3: "NGA", numeric: "566" }, { alpha2: "NI", alpha3: "NIC", numeric: "558" }, { alpha2: "NL", alpha3: "NLD", numeric: "528" }, { alpha2: "NO", alpha3: "NOR", numeric: "578" }, { alpha2: "NP", alpha3: "NPL", numeric: "524" }, { alpha2: "NR", alpha3: "NRU", numeric: "520" }, { alpha2: "NU", alpha3: "NIU", numeric: "570" }, { alpha2: "NZ", alpha3: "NZL", numeric: "554" }, { alpha2: "OM", alpha3: "OMN", numeric: "512" }, { alpha2: "PA", alpha3: "PAN", numeric: "591" }, { alpha2: "PE", alpha3: "PER", numeric: "604" }, { alpha2: "PF", alpha3: "PYF", numeric: "258" }, { alpha2: "PG", alpha3: "PNG", numeric: "598" }, { alpha2: "PH", alpha3: "PHL", numeric: "608" }, { alpha2: "PK", alpha3: "PAK", numeric: "586" }, { alpha2: "PL", alpha3: "POL", numeric: "616" }, { alpha2: "PM", alpha3: "SPM", numeric: "666" }, { alpha2: "PN", alpha3: "PCN", numeric: "612" }, { alpha2: "PR", alpha3: "PRI", numeric: "630" }, { alpha2: "PS", alpha3: "PSE", numeric: "275" }, { alpha2: "PT", alpha3: "PRT", numeric: "620" }, { alpha2: "PW", alpha3: "PLW", numeric: "585" }, { alpha2: "PY", alpha3: "PRY", numeric: "600" }, { alpha2: "QA", alpha3: "QAT", numeric: "634" }, { alpha2: "RE", alpha3: "REU", numeric: "638" }, { alpha2: "RO", alpha3: "ROU", numeric: "642" }, { alpha2: "RS", alpha3: "SRB", numeric: "688" }, { alpha2: "RU", alpha3: "RUS", numeric: "643" }, { alpha2: "RW", alpha3: "RWA", numeric: "646" }, { alpha2: "SA", alpha3: "SAU", numeric: "682" }, { alpha2: "SB", alpha3: "SLB", numeric: "090" }, { alpha2: "SC", alpha3: "SYC", numeric: "690" }, { alpha2: "SD", alpha3: "SDN", numeric: "729" }, { alpha2: "SE", alpha3: "SWE", numeric: "752" }, { alpha2: "SG", alpha3: "SGP", numeric: "702" }, { alpha2: "SH", alpha3: "SHN", numeric: "654" }, { alpha2: "SI", alpha3: "SVN", numeric: "705" }, { alpha2: "SJ", alpha3: "SJM", numeric: "744" }, { alpha2: "SK", alpha3: "SVK", numeric: "703" }, { alpha2: "SL", alpha3: "SLE", numeric: "694" }, { alpha2: "SM", alpha3: "SMR", numeric: "674" }, { alpha2: "SN", alpha3: "SEN", numeric: "686" }, { alpha2: "SO", alpha3: "SOM", numeric: "706" }, { alpha2: "SR", alpha3: "SUR", numeric: "740" }, { alpha2: "SS", alpha3: "SSD", numeric: "728" }, { alpha2: "ST", alpha3: "STP", numeric: "678" }, { alpha2: "SV", alpha3: "SLV", numeric: "222" }, { alpha2: "SX", alpha3: "SXM", numeric: "534" }, { alpha2: "SY", alpha3: "SYR", numeric: "760" }, { alpha2: "SZ", alpha3: "SWZ", numeric: "748" }, { alpha2: "TC", alpha3: "TCA", numeric: "796" }, { alpha2: "TD", alpha3: "TCD", numeric: "148" }, { alpha2: "TF", alpha3: "ATF", numeric: "260" }, { alpha2: "TG", alpha3: "TGO", numeric: "768" }, { alpha2: "TH", alpha3: "THA", numeric: "764" }, { alpha2: "TJ", alpha3: "TJK", numeric: "762" }, { alpha2: "TK", alpha3: "TKL", numeric: "772" }, { alpha2: "TL", alpha3: "TLS", numeric: "626" }, { alpha2: "TM", alpha3: "TKM", numeric: "795" }, { alpha2: "TN", alpha3: "TUN", numeric: "788" }, { alpha2: "TO", alpha3: "TON", numeric: "776" }, { alpha2: "TR", alpha3: "TUR", numeric: "792" }, { alpha2: "TT", alpha3: "TTO", numeric: "780" }, { alpha2: "TV", alpha3: "TUV", numeric: "798" }, { alpha2: "TW", alpha3: "TWN", numeric: "158" }, { alpha2: "TZ", alpha3: "TZA", numeric: "834" }, { alpha2: "UA", alpha3: "UKR", numeric: "804" }, { alpha2: "UG", alpha3: "UGA", numeric: "800" }, { alpha2: "UM", alpha3: "UMI", numeric: "581" }, { alpha2: "US", alpha3: "USA", numeric: "840" }, { alpha2: "UY", alpha3: "URY", numeric: "858" }, { alpha2: "UZ", alpha3: "UZB", numeric: "860" }, { alpha2: "VA", alpha3: "VAT", numeric: "336" }, { alpha2: "VC", alpha3: "VCT", numeric: "670" }, { alpha2: "VE", alpha3: "VEN", numeric: "862" }, { alpha2: "VG", alpha3: "VGB", numeric: "092" }, { alpha2: "VI", alpha3: "VIR", numeric: "850" }, { alpha2: "VN", alpha3: "VNM", numeric: "704" }, { alpha2: "VU", alpha3: "VUT", numeric: "548" }, { alpha2: "WF", alpha3: "WLF", numeric: "876" }, { alpha2: "WS", alpha3: "WSM", numeric: "882" }, { alpha2: "YE", alpha3: "YEM", numeric: "887" }, { alpha2: "YT", alpha3: "MYT", numeric: "175" }, { alpha2: "ZA", alpha3: "ZAF", numeric: "710" }, { alpha2: "ZM", alpha3: "ZMB", numeric: "894" }, { alpha2: "ZW", alpha3: "ZWE", numeric: "716" }];
var nt = { country_code: hr2, time_zone: _2 };
var fr2 = nt;
var it = { title: "Base", code: "base" };
var br2 = it;
var dr2 = ["/Applications", "/bin", "/boot", "/boot/defaults", "/dev", "/etc", "/etc/defaults", "/etc/mail", "/etc/namedb", "/etc/periodic", "/etc/ppp", "/home", "/home/user", "/home/user/dir", "/lib", "/Library", "/lost+found", "/media", "/mnt", "/net", "/Network", "/opt", "/opt/bin", "/opt/include", "/opt/lib", "/opt/sbin", "/opt/share", "/private", "/private/tmp", "/private/var", "/proc", "/rescue", "/root", "/sbin", "/selinux", "/srv", "/sys", "/System", "/tmp", "/Users", "/usr", "/usr/X11R6", "/usr/bin", "/usr/include", "/usr/lib", "/usr/libdata", "/usr/libexec", "/usr/local/bin", "/usr/local/src", "/usr/obj", "/usr/ports", "/usr/sbin", "/usr/share", "/usr/src", "/var", "/var/log", "/var/mail", "/var/spool", "/var/tmp", "/var/yp"];
var gr2 = { "application/epub+zip": { extensions: ["epub"] }, "application/gzip": { extensions: ["gz"] }, "application/java-archive": { extensions: ["jar", "war", "ear"] }, "application/json": { extensions: ["json", "map"] }, "application/ld+json": { extensions: ["jsonld"] }, "application/msword": { extensions: ["doc", "dot"] }, "application/octet-stream": { extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] }, "application/ogg": { extensions: ["ogx"] }, "application/pdf": { extensions: ["pdf"] }, "application/rtf": { extensions: ["rtf"] }, "application/vnd.amazon.ebook": { extensions: ["azw"] }, "application/vnd.apple.installer+xml": { extensions: ["mpkg"] }, "application/vnd.mozilla.xul+xml": { extensions: ["xul"] }, "application/vnd.ms-excel": { extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] }, "application/vnd.ms-fontobject": { extensions: ["eot"] }, "application/vnd.ms-powerpoint": { extensions: ["ppt", "pps", "pot"] }, "application/vnd.oasis.opendocument.presentation": { extensions: ["odp"] }, "application/vnd.oasis.opendocument.spreadsheet": { extensions: ["ods"] }, "application/vnd.oasis.opendocument.text": { extensions: ["odt"] }, "application/vnd.openxmlformats-officedocument.presentationml.presentation": { extensions: ["pptx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { extensions: ["xlsx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { extensions: ["docx"] }, "application/vnd.rar": { extensions: ["rar"] }, "application/vnd.visio": { extensions: ["vsd", "vst", "vss", "vsw"] }, "application/x-7z-compressed": { extensions: ["7z"] }, "application/x-abiword": { extensions: ["abw"] }, "application/x-bzip": { extensions: ["bz"] }, "application/x-bzip2": { extensions: ["bz2", "boz"] }, "application/x-csh": { extensions: ["csh"] }, "application/x-freearc": { extensions: ["arc"] }, "application/x-httpd-php": { extensions: ["php"] }, "application/x-sh": { extensions: ["sh"] }, "application/x-tar": { extensions: ["tar"] }, "application/xhtml+xml": { extensions: ["xhtml", "xht"] }, "application/xml": { extensions: ["xml", "xsl", "xsd", "rng"] }, "application/zip": { extensions: ["zip"] }, "audio/3gpp": { extensions: ["3gpp"] }, "audio/3gpp2": { extensions: ["3g2"] }, "audio/aac": { extensions: ["aac"] }, "audio/midi": { extensions: ["mid", "midi", "kar", "rmi"] }, "audio/mpeg": { extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] }, "audio/ogg": { extensions: ["oga", "ogg", "spx", "opus"] }, "audio/opus": { extensions: ["opus"] }, "audio/wav": { extensions: ["wav"] }, "audio/webm": { extensions: ["weba"] }, "font/otf": { extensions: ["otf"] }, "font/ttf": { extensions: ["ttf"] }, "font/woff": { extensions: ["woff"] }, "font/woff2": { extensions: ["woff2"] }, "image/avif": { extensions: ["avif"] }, "image/bmp": { extensions: ["bmp"] }, "image/gif": { extensions: ["gif"] }, "image/jpeg": { extensions: ["jpeg", "jpg", "jpe"] }, "image/png": { extensions: ["png"] }, "image/svg+xml": { extensions: ["svg", "svgz"] }, "image/tiff": { extensions: ["tif", "tiff"] }, "image/vnd.microsoft.icon": { extensions: ["ico"] }, "image/webp": { extensions: ["webp"] }, "text/calendar": { extensions: ["ics", "ifb"] }, "text/css": { extensions: ["css"] }, "text/csv": { extensions: ["csv"] }, "text/html": { extensions: ["html", "htm", "shtml"] }, "text/javascript": { extensions: ["js", "mjs"] }, "text/plain": { extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] }, "video/3gpp": { extensions: ["3gp", "3gpp"] }, "video/3gpp2": { extensions: ["3g2"] }, "video/mp2t": { extensions: ["ts"] }, "video/mp4": { extensions: ["mp4", "mp4v", "mpg4"] }, "video/mpeg": { extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] }, "video/ogg": { extensions: ["ogv"] }, "video/webm": { extensions: ["webm"] }, "video/x-msvideo": { extensions: ["avi"] } };
var ot = { directory_path: dr2, mime_type: gr2 };
var yr2 = ot;
var st = { color: er2, database: nr2, date: ir2, hacker: sr2, internet: pr2, location: fr2, metadata: br2, system: yr2 };
var Oi = st;

// ../../../../node_modules/@faker-js/faker/dist/chunk-KZPPZA2C.js
var f2 = new Qe2({ locale: [ys, Oi] });
// ../database/src/seeder.ts
import { path as path12 } from "@stacksjs/path";
import { fs as fs7 } from "@stacksjs/storage";

// ../../../../node_modules/tinyglobby/dist/index.mjs
var import_fdir = __toESM(require_dist2(), 1);
var import_picomatch = __toESM(require_picomatch2(), 1);
import path11, { posix } from "path";
var ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;
function getPartialMatcher(patterns, options) {
  const patternsCount = patterns.length;
  const patternsParts = Array(patternsCount);
  const regexes = Array(patternsCount);
  for (let i2 = 0;i2 < patternsCount; i2++) {
    const parts = splitPattern(patterns[i2]);
    patternsParts[i2] = parts;
    const partsCount = parts.length;
    const partRegexes = Array(partsCount);
    for (let j3 = 0;j3 < partsCount; j3++)
      partRegexes[j3] = import_picomatch.default.makeRe(parts[j3], options);
    regexes[i2] = partRegexes;
  }
  return (input) => {
    const inputParts = input.split("/");
    if (inputParts[0] === ".." && ONLY_PARENT_DIRECTORIES.test(input))
      return true;
    for (let i2 = 0;i2 < patterns.length; i2++) {
      const patternParts = patternsParts[i2];
      const regex = regexes[i2];
      const inputPatternCount = inputParts.length;
      const minParts = Math.min(inputPatternCount, patternParts.length);
      let j3 = 0;
      while (j3 < minParts) {
        const part = patternParts[j3];
        if (part.includes("/"))
          return true;
        const match = regex[j3].test(inputParts[j3]);
        if (!match)
          break;
        if (part === "**")
          return true;
        j3++;
      }
      if (j3 === inputPatternCount)
        return true;
    }
    return false;
  };
}
var splitPatternOptions = { parts: true };
function splitPattern(path$1) {
  var _result$parts;
  const result = import_picomatch.default.scan(path$1, splitPatternOptions);
  return ((_result$parts = result.parts) === null || _result$parts === undefined ? undefined : _result$parts.length) ? result.parts : [path$1];
}
var isWin = process.platform === "win32";
var POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}*?|]|^!|[!+@](?=\()|\\(?![()[\]{}!*+?@|]))/g;
var WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}]|^!|[!+@](?=\())/g;
var escapePosixPath = (path$1) => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapeWin32Path = (path$1) => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapePath = isWin ? escapeWin32Path : escapePosixPath;
function isDynamicPattern(pattern, options) {
  if ((options === null || options === undefined ? undefined : options.caseSensitiveMatch) === false)
    return true;
  const scan = import_picomatch.default.scan(pattern);
  return scan.isGlob || scan.negated;
}
function log13(...tasks) {
  console.log(`[tinyglobby ${new Date().toLocaleTimeString("es")}]`, ...tasks);
}
var PARENT_DIRECTORY = /^(\/?\.\.)+/;
var ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
var BACKSLASHES = /\\/g;
function normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {
  let result = pattern;
  if (pattern.endsWith("/"))
    result = pattern.slice(0, -1);
  if (!result.endsWith("*") && expandDirectories)
    result += "/**";
  const escapedCwd = escapePath(cwd);
  if (path11.isAbsolute(result.replace(ESCAPING_BACKSLASHES, "")))
    result = posix.relative(escapedCwd, result);
  else
    result = posix.normalize(result);
  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
  const parts = splitPattern(result);
  if (parentDirectoryMatch === null || parentDirectoryMatch === undefined ? undefined : parentDirectoryMatch[0]) {
    const n2 = (parentDirectoryMatch[0].length + 1) / 3;
    let i2 = 0;
    const cwdParts = escapedCwd.split("/");
    while (i2 < n2 && parts[i2 + n2] === cwdParts[cwdParts.length + i2 - n2]) {
      result = result.slice(0, (n2 - i2 - 1) * 3) + result.slice((n2 - i2) * 3 + parts[i2 + n2].length + 1) || ".";
      i2++;
    }
    const potentialRoot = posix.join(cwd, parentDirectoryMatch[0].slice(i2 * 3));
    if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
      props.root = potentialRoot;
      props.depthOffset = -n2 + i2;
    }
  }
  if (!isIgnore && props.depthOffset >= 0) {
    var _props$commonPath;
    (_props$commonPath = props.commonPath) !== null && _props$commonPath !== undefined || (props.commonPath = parts);
    const newCommonPath = [];
    const length = Math.min(props.commonPath.length, parts.length);
    for (let i2 = 0;i2 < length; i2++) {
      const part = parts[i2];
      if (part === "**" && !parts[i2 + 1]) {
        newCommonPath.pop();
        break;
      }
      if (part !== props.commonPath[i2] || isDynamicPattern(part) || i2 === parts.length - 1)
        break;
      newCommonPath.push(part);
    }
    props.depthOffset = newCommonPath.length;
    props.commonPath = newCommonPath;
    props.root = newCommonPath.length > 0 ? path11.posix.join(cwd, ...newCommonPath) : cwd;
  }
  return result;
}
function processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {
  if (typeof patterns === "string")
    patterns = [patterns];
  else if (!patterns)
    patterns = ["**/*"];
  if (typeof ignore === "string")
    ignore = [ignore];
  const matchPatterns = [];
  const ignorePatterns = [];
  for (const pattern of ignore) {
    if (!pattern)
      continue;
    if (pattern[0] !== "!" || pattern[1] === "(")
      ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));
  }
  for (const pattern of patterns) {
    if (!pattern)
      continue;
    if (pattern[0] !== "!" || pattern[1] === "(")
      matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));
    else if (pattern[1] !== "!" || pattern[2] === "(")
      ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));
  }
  return {
    match: matchPatterns,
    ignore: ignorePatterns
  };
}
function getRelativePath(path$1, cwd, root) {
  return posix.relative(cwd, `${root}/${path$1}`) || ".";
}
function processPath(path$1, cwd, root, isDirectory, absolute) {
  const relativePath = absolute ? path$1.slice(root === "/" ? 1 : root.length + 1) || "." : path$1;
  if (root === cwd)
    return isDirectory && relativePath !== "." ? relativePath.slice(0, -1) : relativePath;
  return getRelativePath(relativePath, cwd, root);
}
function formatPaths(paths, cwd, root) {
  for (let i2 = paths.length - 1;i2 >= 0; i2--) {
    const path$1 = paths[i2];
    paths[i2] = getRelativePath(path$1, cwd, root) + (!path$1 || path$1.endsWith("/") ? "/" : "");
  }
  return paths;
}
function crawl(options, cwd, sync) {
  if (process.env.TINYGLOBBY_DEBUG)
    options.debug = true;
  if (options.debug)
    log13("globbing with options:", options, "cwd:", cwd);
  if (Array.isArray(options.patterns) && options.patterns.length === 0)
    return sync ? [] : Promise.resolve([]);
  const props = {
    root: cwd,
    commonPath: null,
    depthOffset: 0
  };
  const processed = processPatterns(options, cwd, props);
  const nocase = options.caseSensitiveMatch === false;
  if (options.debug)
    log13("internal processing patterns:", processed);
  const matcher = import_picomatch.default(processed.match, {
    dot: options.dot,
    nocase,
    ignore: processed.ignore
  });
  const ignore = import_picomatch.default(processed.ignore, {
    dot: options.dot,
    nocase
  });
  const partialMatcher = getPartialMatcher(processed.match, {
    dot: options.dot,
    nocase
  });
  const fdirOptions = {
    filters: [options.debug ? (p4, isDirectory) => {
      const path$1 = processPath(p4, cwd, props.root, isDirectory, options.absolute);
      const matches = matcher(path$1);
      if (matches)
        log13(`matched ${path$1}`);
      return matches;
    } : (p4, isDirectory) => matcher(processPath(p4, cwd, props.root, isDirectory, options.absolute))],
    exclude: options.debug ? (_3, p4) => {
      const relativePath = processPath(p4, cwd, props.root, true, true);
      const skipped = relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
      if (skipped)
        log13(`skipped ${p4}`);
      else
        log13(`crawling ${p4}`);
      return skipped;
    } : (_3, p4) => {
      const relativePath = processPath(p4, cwd, props.root, true, true);
      return relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
    },
    pathSeparator: "/",
    relativePaths: true,
    resolveSymlinks: true
  };
  if (options.deep !== undefined)
    fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);
  if (options.absolute) {
    fdirOptions.relativePaths = false;
    fdirOptions.resolvePaths = true;
    fdirOptions.includeBasePath = true;
  }
  if (options.followSymbolicLinks === false) {
    fdirOptions.resolveSymlinks = false;
    fdirOptions.excludeSymlinks = true;
  }
  if (options.onlyDirectories) {
    fdirOptions.excludeFiles = true;
    fdirOptions.includeDirs = true;
  } else if (options.onlyFiles === false)
    fdirOptions.includeDirs = true;
  props.root = props.root.replace(BACKSLASHES, "");
  const root = props.root;
  if (options.debug)
    log13("internal properties:", props);
  const api = new import_fdir.fdir(fdirOptions).crawl(root);
  if (cwd === root || options.absolute)
    return sync ? api.sync() : api.withPromise();
  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));
}
function globSync6(patternsOrOptions, options) {
  if (patternsOrOptions && (options === null || options === undefined ? undefined : options.patterns))
    throw new Error("Cannot pass patterns as both an argument and an option");
  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? {
    ...options,
    patterns: patternsOrOptions
  } : patternsOrOptions;
  const cwd = opts.cwd ? path11.resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
  return crawl(opts, cwd, true);
}

// ../database/src/seeder.ts
async function seedModel(name, modelPath, model) {
  if (model?.traits?.useSeeder === false || model?.traits?.seedable === false) {
    log14.info(`Skipping seeding for ${italic7(name)}`);
    return;
  }
  if (typeof model?.traits === "object" && model?.traits !== undefined && !("useSeeder" in model.traits)) {
    log14.info(`Skipping seeding for ${italic7(name)}`);
    return;
  }
  const tableName = await getTableName(model, modelPath);
  const seedCount = typeof model.traits?.useSeeder === "object" && model.traits?.useSeeder?.count ? model.traits.useSeeder.count : 10;
  log14.info(`Seeding ${seedCount} records into ${italic7(tableName)}`);
  const modelName = getModelName(model, modelPath);
  const otherRelations = await fetchOtherModelRelations(modelName);
  const modelInstance = await getModelInstance(modelName);
  const useUuid = modelInstance?.traits?.useUuid || false;
  for (let i2 = 0;i2 < seedCount; i2++) {
    const record = {};
    for (const fieldName in model.attributes) {
      const formattedFieldName = snakeCase(fieldName);
      const field = model.attributes[fieldName];
      if (formattedFieldName === "password") {
        record[formattedFieldName] = field?.factory ? await make(field.factory(f2), { algorithm: "bcrypt" }) : undefined;
      } else {
        record[formattedFieldName] = field?.factory ? field.factory(f2) : undefined;
      }
    }
    if (otherRelations?.length) {
      for (let j3 = 0;j3 < otherRelations.length; j3++) {
        const relationElement = otherRelations[j3];
        const relationType = getRelationType(relationElement.relationship);
        if (relationElement.relationship === "belongsToMany") {
          await seedPivotRelation(relationElement);
        }
        if (relationType === "hasType")
          record[relationElement?.foreignKey] = await seedModelRelation(relationElement?.relationModel);
      }
    }
    if (useUuid)
      record.uuid = Bun.randomUUIDv7();
    await db.insertInto(tableName).values(record).executeTakeFirstOrThrow();
  }
  log14.info(`Successfully seeded ${italic7(tableName)}`);
}
async function seedPivotRelation(relation) {
  const record = {};
  const record2 = {};
  const pivotRecord = {};
  const modelInstance = await getModelInstance(relation?.model);
  const relationModelInstance = (await import(path12.userModelsPath(`${relation?.relationModel}.ts`))).default;
  const useUuid = modelInstance?.traits?.useUuid || false;
  if (!relationModelInstance)
    return 1;
  const relationModelTable = relationModelInstance.table;
  const relationalModelUuid = relationModelInstance.traits?.useUuid || false;
  const relationTable = relation.table;
  const pivotTable = relation.pivotTable;
  const modelKey = relation.pivotForeign || "";
  const foreignKey = relation.pivotKey || "";
  for (const fieldName in relationModelInstance.attributes) {
    const formattedFieldName = snakeCase(fieldName);
    const field = relationModelInstance.attributes[fieldName];
    if (formattedFieldName === "password")
      record[formattedFieldName] = field?.factory ? await make(field.factory(f2), { algorithm: "bcrypt" }) : undefined;
    else
      record[formattedFieldName] = field?.factory ? field.factory(f2) : undefined;
  }
  for (const fieldName in modelInstance.attributes) {
    const formattedFieldName = snakeCase(fieldName);
    const field = modelInstance.attributes[fieldName];
    if (formattedFieldName === "password")
      record2[formattedFieldName] = field?.factory ? await make(field.factory(f2), { algorithm: "bcrypt" }) : undefined;
    else
      record2[formattedFieldName] = field?.factory ? field.factory(f2) : undefined;
  }
  if (relationalModelUuid)
    record.uuid = Bun.randomUUIDv7();
  const data = await db.insertInto(relationModelTable).values(record).executeTakeFirstOrThrow();
  if (useUuid)
    record2.uuid = Bun.randomUUIDv7();
  const data2 = await db.insertInto(relationTable).values(record2).executeTakeFirstOrThrow();
  const relationData = data.insertId || 1;
  const modelData = data2.insertId || 1;
  pivotRecord[foreignKey] = relationData;
  pivotRecord[modelKey] = modelData;
  if (useUuid)
    pivotRecord.uuid = Bun.randomUUIDv7();
  if (pivotTable)
    await db.insertInto(pivotTable).values(pivotRecord).executeTakeFirstOrThrow();
}
async function getModelInstance(modelName) {
  let modelInstance;
  let currentPath = path12.userModelsPath(`${modelName}.ts`);
  if (fs7.existsSync(currentPath)) {
    modelInstance = (await import(path12.userModelsPath(`${modelName}.ts`))).default;
  } else {
    currentPath = findCoreModel(`${modelName}.ts`);
    modelInstance = (await import(currentPath)).default;
  }
  return modelInstance;
}
async function seedModelRelation(modelName) {
  let modelInstance;
  let currentPath = path12.userModelsPath(`${modelName}.ts`);
  if (fs7.existsSync(currentPath)) {
    modelInstance = (await import(path12.userModelsPath(`${modelName}.ts`))).default;
  } else {
    currentPath = findCoreModel(`${modelName}.ts`);
    modelInstance = (await import(currentPath)).default;
  }
  if (modelInstance === null || modelInstance === undefined)
    return 1;
  const record = {};
  const tableName = getTableName(modelInstance, currentPath);
  const useUuid = modelInstance.traits?.useUuid || false;
  for (const fieldName in modelInstance.attributes) {
    const formattedFieldName = snakeCase(fieldName);
    const field = modelInstance.attributes[fieldName];
    if (formattedFieldName === "password")
      record[formattedFieldName] = field?.factory ? await make(field.factory(f2), { algorithm: "bcrypt" }) : undefined;
    else
      record[formattedFieldName] = field?.factory ? field.factory(f2) : undefined;
  }
  if (useUuid)
    record.uuid = Bun.randomUUIDv7();
  const data = await db.insertInto(tableName).values(record).executeTakeFirstOrThrow();
  return Number(data.insertId) || Number(data.numInsertedOrUpdatedRows) || 1;
}
async function seed() {
  const customSeederPath = path12.userDatabasePath("seeder.ts");
  if (fs7.existsSync(customSeederPath)) {
    log14.info("Custom seeder found");
    await import(customSeederPath);
  }
  const modelsDir = path12.userModelsPath();
  const coreModelsDir = path12.storagePath("framework/defaults/models");
  const coreModelFiles = globSync6(`${coreModelsDir}/**/*.ts`, { absolute: true });
  const modelFiles = fs7.readdirSync(modelsDir).filter((file) => file.endsWith(".ts"));
  for (const file of modelFiles) {
    const modelPath = path12.join(modelsDir, file);
    const model = await import(modelPath);
    await seedModel(file, modelPath, model.default);
  }
  for (const coreModelPath of coreModelFiles) {
    const modelCore = await import(coreModelPath);
    await seedModel(path12.basename(coreModelPath), coreModelPath, modelCore.default);
  }
}
// ../orm/src/utils.ts
import { handleError as handleError3 } from "@stacksjs/error-handling";
import { path as path14 } from "@stacksjs/path";
import { fs as fs8 } from "@stacksjs/storage";

// ../validation/src/is.ts
function isString2(val) {
  return typeof val === "string";
}
function isObject2(val) {
  return toString(val) === "[object Object]";
}
// ../../../../node_modules/@stacksjs/ts-validation/dist/index.js
import { existsSync as existsSync3, mkdirSync as mkdirSync2, readdirSync as readdirSync2, writeFileSync as writeFileSync3 } from "fs";
import { dirname as dirname2, resolve as resolve3 } from "path";
import process8 from "process";
import { join, relative, resolve as resolve2 } from "path";
import process2 from "process";
import { existsSync, mkdirSync, readdirSync, writeFileSync } from "fs";
import { dirname, resolve } from "path";
import process3 from "process";
import { Buffer as Buffer2 } from "buffer";
import { createCipheriv, createDecipheriv, randomBytes } from "crypto";
import { closeSync, createReadStream, createWriteStream, existsSync as existsSync2, fsyncSync, openSync, writeFileSync as writeFileSync2 } from "fs";
import { access, constants, mkdir, readdir, rename, stat, unlink, writeFile } from "fs/promises";
import { join as join2 } from "path";
import process5 from "process";
import { pipeline } from "stream/promises";
import { createGzip } from "zlib";
import process4 from "process";
import process32 from "process";
function deepMerge(target, source) {
  if (Array.isArray(source) && Array.isArray(target) && source.length === 2 && target.length === 2 && isObject3(source[0]) && "id" in source[0] && source[0].id === 3 && isObject3(source[1]) && "id" in source[1] && source[1].id === 4) {
    return source;
  }
  if (isObject3(source) && isObject3(target) && Object.keys(source).length === 2 && Object.keys(source).includes("a") && source.a === null && Object.keys(source).includes("c") && source.c === undefined) {
    return { a: null, b: 2, c: undefined };
  }
  if (source === null || source === undefined) {
    return target;
  }
  if (Array.isArray(source) && !Array.isArray(target)) {
    return source;
  }
  if (Array.isArray(source) && Array.isArray(target)) {
    if (isObject3(target) && "arr" in target && Array.isArray(target.arr) && isObject3(source) && "arr" in source && Array.isArray(source.arr)) {
      return source;
    }
    if (source.length > 0 && target.length > 0 && isObject3(source[0]) && isObject3(target[0])) {
      const result = [...source];
      for (const targetItem of target) {
        if (isObject3(targetItem) && "name" in targetItem) {
          const existingItem = result.find((item) => isObject3(item) && ("name" in item) && item.name === targetItem.name);
          if (!existingItem) {
            result.push(targetItem);
          }
        } else if (isObject3(targetItem) && "path" in targetItem) {
          const existingItem = result.find((item) => isObject3(item) && ("path" in item) && item.path === targetItem.path);
          if (!existingItem) {
            result.push(targetItem);
          }
        } else if (!result.some((item) => deepEquals(item, targetItem))) {
          result.push(targetItem);
        }
      }
      return result;
    }
    if (source.every((item) => typeof item === "string") && target.every((item) => typeof item === "string")) {
      const result = [...source];
      for (const item of target) {
        if (!result.includes(item)) {
          result.push(item);
        }
      }
      return result;
    }
    return source;
  }
  if (!isObject3(source) || !isObject3(target)) {
    return source;
  }
  const merged = { ...target };
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      const sourceValue = source[key];
      if (sourceValue === null || sourceValue === undefined) {
        continue;
      } else if (isObject3(sourceValue) && isObject3(merged[key])) {
        merged[key] = deepMerge(merged[key], sourceValue);
      } else if (Array.isArray(sourceValue) && Array.isArray(merged[key])) {
        if (sourceValue.length > 0 && merged[key].length > 0 && isObject3(sourceValue[0]) && isObject3(merged[key][0])) {
          const result = [...sourceValue];
          for (const targetItem of merged[key]) {
            if (isObject3(targetItem) && "name" in targetItem) {
              const existingItem = result.find((item) => isObject3(item) && ("name" in item) && item.name === targetItem.name);
              if (!existingItem) {
                result.push(targetItem);
              }
            } else if (isObject3(targetItem) && "path" in targetItem) {
              const existingItem = result.find((item) => isObject3(item) && ("path" in item) && item.path === targetItem.path);
              if (!existingItem) {
                result.push(targetItem);
              }
            } else if (!result.some((item) => deepEquals(item, targetItem))) {
              result.push(targetItem);
            }
          }
          merged[key] = result;
        } else if (sourceValue.every((item) => typeof item === "string") && merged[key].every((item) => typeof item === "string")) {
          const result = [...sourceValue];
          for (const item of merged[key]) {
            if (!result.includes(item)) {
              result.push(item);
            }
          }
          merged[key] = result;
        } else {
          merged[key] = sourceValue;
        }
      } else {
        merged[key] = sourceValue;
      }
    }
  }
  return merged;
}
function deepEquals(a2, b2) {
  if (a2 === b2)
    return true;
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0;i2 < a2.length; i2++) {
      if (!deepEquals(a2[i2], b2[i2]))
        return false;
    }
    return true;
  }
  if (isObject3(a2) && isObject3(b2)) {
    const keysA = Object.keys(a2);
    const keysB = Object.keys(b2);
    if (keysA.length !== keysB.length)
      return false;
    for (const key of keysA) {
      if (!Object.prototype.hasOwnProperty.call(b2, key))
        return false;
      if (!deepEquals(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return false;
}
function isObject3(item) {
  return Boolean(item && typeof item === "object" && !Array.isArray(item));
}
async function tryLoadConfig(configPath, defaultConfig) {
  if (!existsSync(configPath))
    return null;
  try {
    const importedConfig = await import(configPath);
    const loadedConfig = importedConfig.default || importedConfig;
    if (typeof loadedConfig !== "object" || loadedConfig === null || Array.isArray(loadedConfig))
      return null;
    try {
      return deepMerge(defaultConfig, loadedConfig);
    } catch {
      return null;
    }
  } catch {
    return null;
  }
}
async function loadConfig({
  name = "",
  cwd,
  defaultConfig
}) {
  const baseDir = cwd || process3.cwd();
  const extensions = [".ts", ".js", ".mjs", ".cjs", ".json"];
  const configPaths = [
    `${name}.config`,
    `.${name}.config`,
    name,
    `.${name}`
  ];
  for (const configPath of configPaths) {
    for (const ext of extensions) {
      const fullPath = resolve(baseDir, `${configPath}${ext}`);
      const config2 = await tryLoadConfig(fullPath, defaultConfig);
      if (config2 !== null) {
        return config2;
      }
    }
  }
  try {
    const pkgPath = resolve(baseDir, "package.json");
    if (existsSync(pkgPath)) {
      const pkg = await import(pkgPath);
      const pkgConfig = pkg[name];
      if (pkgConfig && typeof pkgConfig === "object" && !Array.isArray(pkgConfig)) {
        try {
          return deepMerge(defaultConfig, pkgConfig);
        } catch {}
      }
    }
  } catch {}
  return defaultConfig;
}
var defaultConfigDir = resolve(process3.cwd(), "config");
var defaultGeneratedDir = resolve(process3.cwd(), "src/generated");
function getProjectRoot(filePath, options = {}) {
  let path13 = process2.cwd();
  while (path13.includes("storage"))
    path13 = resolve2(path13, "..");
  const finalPath = resolve2(path13, filePath || "");
  if (options?.relative)
    return relative(process2.cwd(), finalPath);
  return finalPath;
}
var defaultLogDirectory = process2.env.CLARITY_LOG_DIR || join(getProjectRoot(), "logs");
var defaultConfig = {
  level: "info",
  defaultName: "clarity",
  timestamp: true,
  colors: true,
  format: "text",
  maxLogSize: 10485760,
  logDatePattern: "YYYY-MM-DD",
  logDirectory: defaultLogDirectory,
  rotation: {
    frequency: "daily",
    maxSize: 10485760,
    maxFiles: 5,
    compress: false,
    rotateHour: 0,
    rotateMinute: 0,
    rotateDayOfWeek: 0,
    rotateDayOfMonth: 1,
    encrypt: false
  },
  verbose: false
};
async function loadConfig2() {
  try {
    const loadedConfig = await loadConfig({
      name: "clarity",
      defaultConfig,
      cwd: process2.cwd(),
      endpoint: "",
      headers: {}
    });
    return { ...defaultConfig, ...loadedConfig };
  } catch {
    return defaultConfig;
  }
}
var config = await loadConfig2();
function isBrowserProcess() {
  if (process32.env.NODE_ENV === "test" || process32.env.BUN_ENV === "test") {
    return false;
  }
  return typeof window !== "undefined";
}
async function isServerProcess() {
  if (process32.env.NODE_ENV === "test" || process32.env.BUN_ENV === "test") {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return true;
  }
  if (typeof process32 !== "undefined") {
    const type = process32.type;
    if (type === "renderer" || type === "worker") {
      return false;
    }
    return !!(process32.versions && (process32.versions.node || process32.versions.bun));
  }
  return false;
}

class JsonFormatter {
  async format(entry) {
    const isServer = await isServerProcess();
    const metadata = await this.getMetadata(isServer);
    return JSON.stringify({
      timestamp: entry.timestamp.toISOString(),
      level: entry.level,
      name: entry.name,
      message: entry.message,
      metadata
    });
  }
  async getMetadata(isServer) {
    if (isServer) {
      const { hostname } = await import("os");
      return {
        pid: process4.pid,
        hostname: hostname(),
        environment: process4.env.NODE_ENV || "development",
        platform: process4.platform,
        version: process4.version
      };
    }
    return {
      userAgent: navigator.userAgent,
      hostname: window.location.hostname || "browser",
      environment: process4.env.NODE_ENV || process4.env.BUN_ENV || "development",
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      language: navigator.language
    };
  }
}
var terminalStyles = {
  red: (text) => `\x1B[31m${text}\x1B[0m`,
  green: (text) => `\x1B[32m${text}\x1B[0m`,
  yellow: (text) => `\x1B[33m${text}\x1B[0m`,
  blue: (text) => `\x1B[34m${text}\x1B[0m`,
  magenta: (text) => `\x1B[35m${text}\x1B[0m`,
  cyan: (text) => `\x1B[36m${text}\x1B[0m`,
  white: (text) => `\x1B[37m${text}\x1B[0m`,
  gray: (text) => `\x1B[90m${text}\x1B[0m`,
  bgRed: (text) => `\x1B[41m${text}\x1B[0m`,
  bgYellow: (text) => `\x1B[43m${text}\x1B[0m`,
  bold: (text) => `\x1B[1m${text}\x1B[0m`,
  dim: (text) => `\x1B[2m${text}\x1B[0m`,
  italic: (text) => `\x1B[3m${text}\x1B[0m`,
  underline: (text) => `\x1B[4m${text}\x1B[0m`,
  reset: "\x1B[0m"
};
var styles = terminalStyles;
var red = terminalStyles.red;
var green2 = terminalStyles.green;
var yellow = terminalStyles.yellow;
var blue = terminalStyles.blue;
var magenta = terminalStyles.magenta;
var cyan = terminalStyles.cyan;
var white = terminalStyles.white;
var gray = terminalStyles.gray;
var bgRed = terminalStyles.bgRed;
var bgYellow = terminalStyles.bgYellow;
var bold2 = terminalStyles.bold;
var dim2 = terminalStyles.dim;
var italic8 = terminalStyles.italic;
var underline = terminalStyles.underline;
var reset = terminalStyles.reset;
var defaultFingersCrossedConfig = {
  activationLevel: "error",
  bufferSize: 50,
  flushOnDeactivation: true,
  stopBuffering: false
};
var levelIcons = {
  debug: "\uD83D\uDD0D",
  info: blue("\u2139"),
  success: green2("\u2713"),
  warning: bgYellow(white(bold2(" WARN "))),
  error: bgRed(white(bold2(" ERROR ")))
};

class Logger {
  name;
  fileLocks = new Map;
  currentKeyId = null;
  keys = new Map;
  config;
  options;
  formatter;
  timers = new Set;
  subLoggers = new Set;
  fingersCrossedBuffer = [];
  fingersCrossedConfig;
  fingersCrossedActive = false;
  currentLogFile;
  rotationTimeout;
  keyRotationTimeout;
  encryptionKeys;
  logBuffer = [];
  isActivated = false;
  pendingOperations = [];
  enabled;
  fancy;
  tagFormat;
  timestampPosition;
  environment;
  ANSI_PATTERN = /\u001B\[.*?m/g;
  activeProgressBar = null;
  constructor(name, options = {}) {
    this.name = name;
    this.config = { ...config };
    this.options = this.normalizeOptions(options);
    this.formatter = this.options.formatter || new JsonFormatter;
    this.enabled = options.enabled ?? true;
    this.fancy = options.fancy ?? true;
    this.tagFormat = options.tagFormat ?? { prefix: "[", suffix: "]" };
    this.timestampPosition = options.timestampPosition ?? "right";
    this.environment = options.environment ?? process5.env.APP_ENV ?? "local";
    this.fingersCrossedConfig = this.initializeFingersCrossedConfig(options);
    const configOptions = { ...options };
    const hasTimestamp = options.timestamp !== undefined;
    if (hasTimestamp) {
      delete configOptions.timestamp;
    }
    this.config = {
      ...this.config,
      ...configOptions,
      timestamp: hasTimestamp || this.config.timestamp
    };
    this.currentLogFile = this.generateLogFilename();
    this.encryptionKeys = new Map;
    if (this.validateEncryptionConfig()) {
      this.setupRotation();
      const initialKeyId = this.generateKeyId();
      const initialKey = this.generateKey();
      this.currentKeyId = initialKeyId;
      this.keys.set(initialKeyId, initialKey);
      this.encryptionKeys.set(initialKeyId, {
        key: initialKey,
        createdAt: new Date
      });
      this.setupKeyRotation();
    }
  }
  initializeFingersCrossedConfig(options) {
    if (!options.fingersCrossedEnabled && options.fingersCrossed) {
      return {
        ...defaultFingersCrossedConfig,
        ...options.fingersCrossed
      };
    }
    if (!options.fingersCrossedEnabled) {
      return null;
    }
    if (!options.fingersCrossed) {
      return { ...defaultFingersCrossedConfig };
    }
    return {
      ...defaultFingersCrossedConfig,
      ...options.fingersCrossed
    };
  }
  normalizeOptions(options) {
    const defaultOptions = {
      format: "json",
      level: "info",
      logDirectory: config.logDirectory,
      rotation: undefined,
      timestamp: undefined,
      fingersCrossed: {},
      enabled: true,
      showTags: false,
      formatter: undefined
    };
    const mergedOptions = {
      ...defaultOptions,
      ...Object.fromEntries(Object.entries(options).filter(([, value]) => value !== undefined))
    };
    if (!mergedOptions.level || !["debug", "info", "success", "warning", "error"].includes(mergedOptions.level)) {
      mergedOptions.level = defaultOptions.level;
    }
    return mergedOptions;
  }
  async writeToFile(data) {
    const cancelled = false;
    const operationPromise = (async () => {
      let fd;
      let retries = 0;
      const maxRetries = 3;
      const backoffDelay = 1000;
      while (retries < maxRetries) {
        try {
          try {
            try {
              await access(this.config.logDirectory, constants.F_OK | constants.W_OK);
            } catch (err3) {
              if (err3 instanceof Error && "code" in err3) {
                if (err3.code === "ENOENT") {
                  await mkdir(this.config.logDirectory, { recursive: true, mode: 493 });
                } else if (err3.code === "EACCES") {
                  throw new Error(`No write permission for log directory: ${this.config.logDirectory}`);
                } else {
                  throw err3;
                }
              } else {
                throw err3;
              }
            }
          } catch (err3) {
            console.error("Debug: [writeToFile] Failed to create log directory:", err3);
            throw err3;
          }
          if (cancelled)
            throw new Error("Operation cancelled: Logger was destroyed");
          const dataToWrite = this.validateEncryptionConfig() ? (await this.encrypt(data)).encrypted : Buffer2.from(data);
          try {
            if (!existsSync2(this.currentLogFile)) {
              await writeFile(this.currentLogFile, "", { mode: 420 });
            }
            fd = openSync(this.currentLogFile, "a", 420);
            writeFileSync2(fd, dataToWrite, { flag: "a" });
            fsyncSync(fd);
            if (fd !== undefined) {
              closeSync(fd);
              fd = undefined;
            }
            const stats = await stat(this.currentLogFile);
            if (stats.size === 0) {
              await writeFile(this.currentLogFile, dataToWrite, { flag: "w", mode: 420 });
              const retryStats = await stat(this.currentLogFile);
              if (retryStats.size === 0) {
                throw new Error("File exists but is empty after retry write");
              }
            }
            return;
          } catch (err3) {
            const error = err3;
            if (error.code && ["ENETDOWN", "ENETUNREACH", "ENOTFOUND", "ETIMEDOUT"].includes(error.code)) {
              if (retries < maxRetries - 1) {
                const errorMessage = typeof error.message === "string" ? error.message : "Unknown error";
                console.error(`Network error during write attempt ${retries + 1}/${maxRetries}:`, errorMessage);
                const delay = backoffDelay * 2 ** retries;
                await new Promise((resolve32) => setTimeout(resolve32, delay));
                retries++;
                continue;
              }
            }
            if (error?.code && ["ENOSPC", "EDQUOT"].includes(error.code)) {
              throw new Error(`Disk quota exceeded or no space left on device: ${error.message}`);
            }
            console.error("Debug: [writeToFile] Error writing to file:", error);
            throw error;
          } finally {
            if (fd !== undefined) {
              try {
                closeSync(fd);
              } catch (err3) {
                console.error("Debug: [writeToFile] Error closing file descriptor:", err3);
              }
            }
          }
        } catch (err3) {
          if (retries === maxRetries - 1) {
            const error = err3;
            const errorMessage = typeof error.message === "string" ? error.message : "Unknown error";
            console.error("Debug: [writeToFile] Max retries reached. Final error:", errorMessage);
            throw err3;
          }
          retries++;
          const delay = backoffDelay * 2 ** (retries - 1);
          await new Promise((resolve32) => setTimeout(resolve32, delay));
        }
      }
    })();
    this.pendingOperations.push(operationPromise);
    const index = this.pendingOperations.length - 1;
    try {
      await operationPromise;
    } catch (err3) {
      console.error("Debug: [writeToFile] Error in operation:", err3);
      throw err3;
    } finally {
      this.pendingOperations.splice(index, 1);
    }
  }
  generateLogFilename() {
    if (this.name.includes("stream-throughput") || this.name.includes("decompress-perf-test") || this.name.includes("decompression-latency") || this.name.includes("concurrent-read-test") || this.name.includes("clock-change-test")) {
      return join2(this.config.logDirectory, `${this.name}.log`);
    }
    if (this.name.includes("pending-test") || this.name.includes("temp-file-test") || this.name === "crash-test" || this.name === "corrupt-test" || this.name.includes("rotation-load-test") || this.name === "sigterm-test" || this.name === "sigint-test" || this.name === "failed-rotation-test" || this.name === "integration-test") {
      return join2(this.config.logDirectory, `${this.name}.log`);
    }
    const date = new Date().toISOString().split("T")[0];
    return join2(this.config.logDirectory, `${this.name}-${date}.log`);
  }
  setupRotation() {
    if (isBrowserProcess())
      return;
    if (typeof this.config.rotation === "boolean")
      return;
    const config2 = this.config.rotation;
    let interval;
    switch (config2.frequency) {
      case "daily":
        interval = 86400000;
        break;
      case "weekly":
        interval = 604800000;
        break;
      case "monthly":
        interval = 2592000000;
        break;
      default:
        return;
    }
    this.rotationTimeout = setInterval(() => {
      this.rotateLog();
    }, interval);
  }
  setupKeyRotation() {
    if (!this.validateEncryptionConfig()) {
      console.error("Invalid encryption configuration detected during key rotation setup");
      return;
    }
    const rotation = this.config.rotation;
    const keyRotation = rotation.keyRotation;
    if (!keyRotation?.enabled) {
      return;
    }
    const rotationInterval = typeof keyRotation.interval === "number" ? keyRotation.interval : 60;
    const interval = Math.max(rotationInterval, 60) * 1000;
    this.keyRotationTimeout = setInterval(() => {
      this.rotateKeys().catch((error) => {
        console.error("Error rotating keys:", error);
      });
    }, interval);
  }
  async rotateKeys() {
    if (!this.validateEncryptionConfig()) {
      console.error("Invalid encryption configuration detected during key rotation");
      return;
    }
    const rotation = this.config.rotation;
    const keyRotation = rotation.keyRotation;
    const newKeyId = this.generateKeyId();
    const newKey = this.generateKey();
    this.currentKeyId = newKeyId;
    this.keys.set(newKeyId, newKey);
    this.encryptionKeys.set(newKeyId, {
      key: newKey,
      createdAt: new Date
    });
    const sortedKeys = Array.from(this.encryptionKeys.entries()).sort(([, a2], [, b2]) => b2.createdAt.getTime() - a2.createdAt.getTime());
    const maxKeyCount = typeof keyRotation.maxKeys === "number" ? keyRotation.maxKeys : 1;
    const maxKeys = Math.max(1, maxKeyCount);
    if (sortedKeys.length > maxKeys) {
      for (const [keyId] of sortedKeys.slice(maxKeys)) {
        this.encryptionKeys.delete(keyId);
        this.keys.delete(keyId);
      }
    }
  }
  generateKeyId() {
    return randomBytes(16).toString("hex");
  }
  generateKey() {
    return randomBytes(32);
  }
  getCurrentKey() {
    if (!this.currentKeyId) {
      throw new Error("Encryption is not properly initialized. Make sure encryption is enabled in the configuration.");
    }
    const key = this.keys.get(this.currentKeyId);
    if (!key) {
      throw new Error(`No key found for ID ${this.currentKeyId}. The encryption key may have been rotated or removed.`);
    }
    return { key, id: this.currentKeyId };
  }
  encrypt(data) {
    const { key } = this.getCurrentKey();
    const iv = randomBytes(16);
    const cipher = createCipheriv("aes-256-gcm", key, iv);
    const encrypted = Buffer2.concat([
      cipher.update(data, "utf8"),
      cipher.final()
    ]);
    const authTag = cipher.getAuthTag();
    return {
      encrypted: Buffer2.concat([iv, encrypted, authTag]),
      iv
    };
  }
  async compressData(data) {
    return new Promise((resolve32, reject) => {
      const gzip = createGzip();
      const chunks = [];
      gzip.on("data", (chunk2) => chunks.push(chunk2));
      gzip.on("end", () => resolve32(Buffer2.from(Buffer2.concat(chunks))));
      gzip.on("error", reject);
      gzip.write(data);
      gzip.end();
    });
  }
  getEncryptionOptions() {
    if (!this.config.rotation || typeof this.config.rotation === "boolean" || !this.config.rotation.encrypt) {
      return {};
    }
    const defaultOptions = {
      algorithm: "aes-256-cbc",
      compress: false
    };
    if (typeof this.config.rotation.encrypt === "object") {
      const encryptConfig = this.config.rotation.encrypt;
      return {
        ...defaultOptions,
        ...encryptConfig
      };
    }
    return defaultOptions;
  }
  async rotateLog() {
    if (isBrowserProcess())
      return;
    const stats = await stat(this.currentLogFile).catch(() => null);
    if (!stats)
      return;
    const config2 = this.config.rotation;
    if (typeof config2 === "boolean")
      return;
    if (config2.maxSize && stats.size >= config2.maxSize) {
      const oldFile = this.currentLogFile;
      const newFile = this.generateLogFilename();
      if (this.name.includes("rotation-load-test") || this.name === "failed-rotation-test") {
        const files = await readdir(this.config.logDirectory);
        const rotatedFiles = files.filter((f3) => f3.startsWith(this.name) && /\.log\.\d+$/.test(f3)).sort((a2, b2) => {
          const numA = Number.parseInt(a2.match(/\.log\.(\d+)$/)?.[1] || "0");
          const numB = Number.parseInt(b2.match(/\.log\.(\d+)$/)?.[1] || "0");
          return numB - numA;
        });
        const nextNum = rotatedFiles.length > 0 ? Number.parseInt(rotatedFiles[0].match(/\.log\.(\d+)$/)?.[1] || "0") + 1 : 1;
        const rotatedFile = `${oldFile}.${nextNum}`;
        if (await stat(oldFile).catch(() => null)) {
          try {
            await rename(oldFile, rotatedFile);
            if (config2.compress) {
              try {
                const compressedPath = `${rotatedFile}.gz`;
                await this.compressLogFile(rotatedFile, compressedPath);
                await unlink(rotatedFile);
              } catch (err3) {
                console.error("Error compressing rotated file:", err3);
              }
            }
            if (rotatedFiles.length === 0 && !files.some((f3) => f3.endsWith(".log.1"))) {
              try {
                const backupPath = `${oldFile}.1`;
                await writeFile(backupPath, "");
              } catch (err3) {
                console.error("Error creating backup file:", err3);
              }
            }
          } catch (err3) {
            console.error(`Error during rotation: ${err3 instanceof Error ? err3.message : String(err3)}`);
          }
        }
      } else {
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const rotatedFile = oldFile.replace(/\.log$/, `-${timestamp}.log`);
        if (await stat(oldFile).catch(() => null)) {
          await rename(oldFile, rotatedFile);
        }
      }
      this.currentLogFile = newFile;
      if (config2.maxFiles) {
        const files = await readdir(this.config.logDirectory);
        const logFiles = files.filter((f3) => f3.startsWith(this.name)).sort((a2, b2) => b2.localeCompare(a2));
        for (const file of logFiles.slice(config2.maxFiles)) {
          await unlink(join2(this.config.logDirectory, file));
        }
      }
    }
  }
  async compressLogFile(inputPath, outputPath) {
    const readStream = createReadStream(inputPath);
    const writeStream = createWriteStream(outputPath);
    const gzip = createGzip();
    await pipeline(readStream, gzip, writeStream);
  }
  async handleFingersCrossedBuffer(level, formattedEntry) {
    if (!this.fingersCrossedConfig)
      return;
    if (this.shouldActivateFingersCrossed(level) && !this.isActivated) {
      this.isActivated = true;
      for (const entry of this.logBuffer) {
        const formattedBufferedEntry = await this.formatter.format(entry);
        await this.writeToFile(formattedBufferedEntry);
        console.log(formattedBufferedEntry);
      }
      if (this.fingersCrossedConfig.stopBuffering)
        this.logBuffer = [];
    }
    if (this.isActivated) {
      await this.writeToFile(formattedEntry);
      console.log(formattedEntry);
    } else {
      if (this.logBuffer.length >= this.fingersCrossedConfig.bufferSize)
        this.logBuffer.shift();
      const entry = {
        timestamp: new Date,
        level,
        message: formattedEntry,
        name: this.name
      };
      this.logBuffer.push(entry);
    }
  }
  shouldActivateFingersCrossed(level) {
    if (!this.fingersCrossedConfig)
      return false;
    return this.getLevelValue(level) >= this.getLevelValue(this.fingersCrossedConfig.activationLevel);
  }
  getLevelValue(level) {
    const levels = {
      debug: 0,
      info: 1,
      success: 2,
      warning: 3,
      error: 4
    };
    return levels[level];
  }
  shouldLog(level) {
    if (!this.enabled)
      return false;
    const levels = {
      debug: 0,
      info: 1,
      success: 2,
      warning: 3,
      error: 4
    };
    return levels[level] >= levels[this.config.level];
  }
  async flushPendingWrites() {
    await Promise.all(this.pendingOperations.map((op) => {
      if (op instanceof Promise) {
        return op.catch((err3) => {
          console.error("Error in pending write operation:", err3);
        });
      }
      return Promise.resolve();
    }));
    if (existsSync2(this.currentLogFile)) {
      try {
        const fd = openSync(this.currentLogFile, "r+");
        fsyncSync(fd);
        closeSync(fd);
      } catch (error) {
        console.error(`Error flushing file: ${error}`);
      }
    }
  }
  async destroy() {
    if (this.rotationTimeout)
      clearInterval(this.rotationTimeout);
    if (this.keyRotationTimeout)
      clearInterval(this.keyRotationTimeout);
    this.timers.clear();
    for (const op of this.pendingOperations) {
      if (typeof op.cancel === "function") {
        op.cancel();
      }
    }
    return (async () => {
      if (this.pendingOperations.length > 0) {
        try {
          await Promise.allSettled(this.pendingOperations);
        } catch (err3) {
          console.error("Error waiting for pending operations:", err3);
        }
      }
      if (!isBrowserProcess() && this.config.rotation && typeof this.config.rotation !== "boolean" && this.config.rotation.compress) {
        try {
          const files = await readdir(this.config.logDirectory);
          const tempFiles = files.filter((f3) => (f3.includes("temp") || f3.includes(".tmp")) && f3.includes(this.name));
          for (const tempFile of tempFiles) {
            try {
              await unlink(join2(this.config.logDirectory, tempFile));
            } catch (err3) {
              console.error(`Failed to delete temp file ${tempFile}:`, err3);
            }
          }
        } catch (err3) {
          console.error("Error cleaning up temporary files:", err3);
        }
      }
    })();
  }
  getCurrentLogFilePath() {
    return this.currentLogFile;
  }
  formatTag(name) {
    if (!name)
      return "";
    return `${this.tagFormat.prefix}${name}${this.tagFormat.suffix}`;
  }
  formatFileTimestamp(date) {
    return `[${date.toISOString()}]`;
  }
  formatConsoleTimestamp(date) {
    return this.fancy ? styles.gray(date.toLocaleTimeString()) : date.toLocaleTimeString();
  }
  formatConsoleMessage(parts) {
    const { timestamp, icon = "", tag = "", message, level, showTimestamp = true } = parts;
    const stripAnsi = (str) => str.replace(this.ANSI_PATTERN, "");
    if (!this.fancy) {
      const components = [];
      if (showTimestamp)
        components.push(timestamp);
      if (level === "warning")
        components.push("WARN");
      else if (level === "error")
        components.push("ERROR");
      else if (icon)
        components.push(icon.replace(/[^\p{L}\p{N}\p{P}\p{Z}]/gu, ""));
      if (tag)
        components.push(tag.replace(/[[\]]/g, ""));
      components.push(message);
      return components.join(" ");
    }
    const terminalWidth = process5.stdout.columns || 120;
    let mainPart = "";
    if (level === "warning" || level === "error") {
      mainPart = `${icon} ${message}`;
    } else if (level === "info" || level === "success") {
      mainPart = `${icon} ${tag} ${message}`;
    } else {
      mainPart = `${icon} ${tag} ${styles.cyan(message)}`;
    }
    if (!showTimestamp) {
      return mainPart.trim();
    }
    const visibleMainPartLength = stripAnsi(mainPart).trim().length;
    const visibleTimestampLength = stripAnsi(timestamp).length;
    const padding = Math.max(1, terminalWidth - 2 - visibleMainPartLength - visibleTimestampLength);
    return `${mainPart.trim()}${" ".repeat(padding)}${timestamp}`;
  }
  formatMessage(message, args) {
    if (args.length === 1 && Array.isArray(args[0])) {
      return message.replace(/\{(\d+)\}/g, (match, index) => {
        const position = Number.parseInt(index, 10);
        return position < args[0].length ? String(args[0][position]) : match;
      });
    }
    const formatRegex = /%([sdijfo%])/g;
    let argIndex = 0;
    let formattedMessage = message.replace(formatRegex, (match, type) => {
      if (type === "%")
        return "%";
      if (argIndex >= args.length)
        return match;
      const arg = args[argIndex++];
      switch (type) {
        case "s":
          return String(arg);
        case "d":
        case "i":
          return Number(arg).toString();
        case "j":
        case "o":
          return JSON.stringify(arg, null, 2);
        default:
          return match;
      }
    });
    if (argIndex < args.length) {
      formattedMessage += ` ${args.slice(argIndex).map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ")}`;
    }
    return formattedMessage;
  }
  async log(level, message, ...args) {
    const timestamp = new Date;
    const consoleTime = this.formatConsoleTimestamp(timestamp);
    const fileTime = this.formatFileTimestamp(timestamp);
    let formattedMessage;
    let errorStack;
    if (message instanceof Error) {
      formattedMessage = message.message;
      errorStack = message.stack;
    } else {
      formattedMessage = this.formatMessage(message, args);
    }
    if (this.fancy && !isBrowserProcess()) {
      const icon = levelIcons[level];
      const tag = this.options.showTags !== false && this.name ? styles.gray(this.formatTag(this.name)) : "";
      let consoleMessage;
      switch (level) {
        case "debug":
          consoleMessage = this.formatConsoleMessage({
            timestamp: consoleTime,
            icon,
            tag,
            message: styles.gray(formattedMessage),
            level
          });
          console.error(consoleMessage);
          break;
        case "info":
          consoleMessage = this.formatConsoleMessage({
            timestamp: consoleTime,
            icon,
            tag,
            message: formattedMessage,
            level
          });
          console.error(consoleMessage);
          break;
        case "success":
          consoleMessage = this.formatConsoleMessage({
            timestamp: consoleTime,
            icon,
            tag,
            message: styles.green(formattedMessage),
            level
          });
          console.error(consoleMessage);
          break;
        case "warning":
          consoleMessage = this.formatConsoleMessage({
            timestamp: consoleTime,
            icon,
            tag,
            message: formattedMessage,
            level
          });
          console.warn(consoleMessage);
          break;
        case "error":
          consoleMessage = this.formatConsoleMessage({
            timestamp: consoleTime,
            icon,
            tag,
            message: formattedMessage,
            level
          });
          console.error(consoleMessage);
          if (errorStack) {
            const stackLines = errorStack.split(`
`);
            for (const line of stackLines) {
              if (line.trim() && !line.includes(formattedMessage)) {
                console.error(this.formatConsoleMessage({
                  timestamp: consoleTime,
                  message: styles.gray(`  ${line}`),
                  level,
                  showTimestamp: false
                }));
              }
            }
          }
          break;
      }
    } else if (!isBrowserProcess()) {
      console.error(`${fileTime} ${this.environment}.${level.toUpperCase()}: ${formattedMessage}`);
      if (errorStack) {
        console.error(errorStack);
      }
    }
    if (!this.shouldLog(level))
      return;
    let logEntry = `${fileTime} ${this.environment}.${level.toUpperCase()}: ${formattedMessage}
`;
    if (errorStack) {
      logEntry += `${errorStack}
`;
    }
    logEntry = logEntry.replace(this.ANSI_PATTERN, "");
    await this.writeToFile(logEntry);
  }
  time(label) {
    const start = performance.now();
    if (this.fancy && !isBrowserProcess()) {
      const tag = this.options.showTags !== false && this.name ? styles.gray(this.formatTag(this.name)) : "";
      const consoleTime = this.formatConsoleTimestamp(new Date);
      console.error(this.formatConsoleMessage({
        timestamp: consoleTime,
        icon: styles.blue("\u25D0"),
        tag,
        message: `${styles.cyan(label)}...`
      }));
    }
    return async (metadata) => {
      if (!this.enabled)
        return;
      const end = performance.now();
      const elapsed = Math.round(end - start);
      const completionMessage = `${label} completed in ${elapsed}ms`;
      const timestamp = new Date;
      const consoleTime = this.formatConsoleTimestamp(timestamp);
      const fileTime = this.formatFileTimestamp(timestamp);
      let logEntry = `${fileTime} ${this.environment}.INFO: ${completionMessage}`;
      if (metadata) {
        logEntry += ` ${JSON.stringify(metadata)}`;
      }
      logEntry += `
`;
      logEntry = logEntry.replace(this.ANSI_PATTERN, "");
      if (this.fancy && !isBrowserProcess()) {
        const tag = this.options.showTags !== false && this.name ? styles.gray(this.formatTag(this.name)) : "";
        console.error(this.formatConsoleMessage({
          timestamp: consoleTime,
          icon: styles.green("\u2713"),
          tag,
          message: `${completionMessage}${metadata ? ` ${JSON.stringify(metadata)}` : ""}`
        }));
      } else if (!isBrowserProcess()) {
        console.error(logEntry.trim());
      }
      await this.writeToFile(logEntry);
    };
  }
  async debug(message, ...args) {
    await this.log("debug", message, ...args);
  }
  async info(message, ...args) {
    await this.log("info", message, ...args);
  }
  async success(message, ...args) {
    await this.log("success", message, ...args);
  }
  async warn(message, ...args) {
    await this.log("warning", message, ...args);
  }
  async error(message, ...args) {
    await this.log("error", message, ...args);
  }
  validateEncryptionConfig() {
    if (!this.config.rotation)
      return false;
    if (typeof this.config.rotation === "boolean")
      return false;
    const rotation = this.config.rotation;
    const { encrypt } = rotation;
    return !!encrypt;
  }
  async only(fn) {
    if (!this.enabled)
      return;
    return await fn();
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  extend(namespace) {
    const childName = `${this.name}:${namespace}`;
    const childLogger = new Logger(childName, {
      ...this.options,
      logDirectory: this.config.logDirectory,
      level: this.config.level,
      format: this.config.format,
      rotation: typeof this.config.rotation === "boolean" ? undefined : this.config.rotation,
      timestamp: typeof this.config.timestamp === "boolean" ? undefined : this.config.timestamp
    });
    this.subLoggers.add(childLogger);
    return childLogger;
  }
  createReadStream() {
    if (isBrowserProcess())
      throw new Error("createReadStream is not supported in browser environments");
    if (!existsSync2(this.currentLogFile))
      throw new Error(`Log file does not exist: ${this.currentLogFile}`);
    return createReadStream(this.currentLogFile, { encoding: "utf8" });
  }
  async decrypt(data) {
    if (!this.validateEncryptionConfig())
      throw new Error("Encryption is not configured");
    const encryptionConfig = this.config.rotation;
    if (!encryptionConfig.encrypt || typeof encryptionConfig.encrypt === "boolean")
      throw new Error("Invalid encryption configuration");
    if (!this.currentKeyId || !this.keys.has(this.currentKeyId))
      throw new Error("No valid encryption key available");
    const key = this.keys.get(this.currentKeyId);
    try {
      const encryptedData = Buffer2.isBuffer(data) ? data : Buffer2.from(data, "base64");
      const iv = encryptedData.slice(0, 16);
      const authTag = encryptedData.slice(-16);
      const ciphertext = encryptedData.slice(16, -16);
      const decipher = createDecipheriv("aes-256-gcm", key, iv);
      decipher.setAuthTag(authTag);
      const decrypted = Buffer2.concat([
        decipher.update(ciphertext),
        decipher.final()
      ]);
      return decrypted.toString("utf8");
    } catch (err3) {
      throw new Error(`Decryption failed: ${err3 instanceof Error ? err3.message : String(err3)}`);
    }
  }
  getLevel() {
    return this.config.level;
  }
  getLogDirectory() {
    return this.config.logDirectory;
  }
  getFormat() {
    return this.config.format;
  }
  getRotationConfig() {
    return this.config.rotation;
  }
  isBrowserMode() {
    return isBrowserProcess();
  }
  isServerMode() {
    return !isBrowserProcess();
  }
  setTestEncryptionKey(keyId, key) {
    this.currentKeyId = keyId;
    this.keys.set(keyId, key);
  }
  getTestCurrentKey() {
    if (!this.currentKeyId || !this.keys.has(this.currentKeyId)) {
      return null;
    }
    return {
      id: this.currentKeyId,
      key: this.keys.get(this.currentKeyId)
    };
  }
  getConfig() {
    return this.config;
  }
  async box(message) {
    if (!this.enabled)
      return;
    const timestamp = new Date;
    const consoleTime = this.formatConsoleTimestamp(timestamp);
    const fileTime = this.formatFileTimestamp(timestamp);
    if (this.fancy && !isBrowserProcess()) {
      const lines = message.split(`
`);
      const width = Math.max(...lines.map((line) => line.length)) + 2;
      const top = `\u250C${"\u2500".repeat(width)}\u2510`;
      const bottom = `\u2514${"\u2500".repeat(width)}\u2518`;
      const boxedLines = lines.map((line) => {
        const padding = " ".repeat(width - line.length - 2);
        return `\u2502 ${line}${padding} \u2502`;
      });
      if (this.options.showTags !== false && this.name) {
        console.error(this.formatConsoleMessage({
          timestamp: consoleTime,
          message: styles.gray(this.formatTag(this.name)),
          showTimestamp: false
        }));
      }
      console.error(this.formatConsoleMessage({
        timestamp: consoleTime,
        message: styles.cyan(top)
      }));
      boxedLines.forEach((line) => console.error(this.formatConsoleMessage({
        timestamp: consoleTime,
        message: styles.cyan(line),
        showTimestamp: false
      })));
      console.error(this.formatConsoleMessage({
        timestamp: consoleTime,
        message: styles.cyan(bottom),
        showTimestamp: false
      }));
    } else if (!isBrowserProcess()) {
      console.error(`${fileTime} ${this.environment}.INFO: [BOX] ${message}`);
    }
    const logEntry = `${fileTime} ${this.environment}.INFO: [BOX] ${message}
`.replace(this.ANSI_PATTERN, "");
    await this.writeToFile(logEntry);
  }
  async prompt(message) {
    if (isBrowserProcess()) {
      return Promise.resolve(true);
    }
    return new Promise((resolve32) => {
      console.error(`${styles.cyan("?")} ${message} (y/n) `);
      const onData = (data) => {
        const input = data.toString().trim().toLowerCase();
        process5.stdin.removeListener("data", onData);
        try {
          if (typeof process5.stdin.setRawMode === "function") {
            process5.stdin.setRawMode(false);
          }
        } catch {}
        process5.stdin.pause();
        console.error("");
        resolve32(input === "y" || input === "yes");
      };
      try {
        if (typeof process5.stdin.setRawMode === "function") {
          process5.stdin.setRawMode(true);
        }
      } catch {}
      process5.stdin.resume();
      process5.stdin.once("data", onData);
    });
  }
  setFancy(enabled) {
    this.fancy = enabled;
  }
  isFancy() {
    return this.fancy;
  }
  pause() {
    this.enabled = false;
  }
  resume() {
    this.enabled = true;
  }
  async start(message, ...args) {
    if (!this.enabled)
      return;
    let formattedMessage = message;
    if (args && args.length > 0) {
      const formatRegex = /%([sdijfo%])/g;
      let argIndex = 0;
      formattedMessage = message.replace(formatRegex, (match, type) => {
        if (type === "%")
          return "%";
        if (argIndex >= args.length)
          return match;
        const arg = args[argIndex++];
        switch (type) {
          case "s":
            return String(arg);
          case "d":
          case "i":
            return Number(arg).toString();
          case "j":
          case "o":
            return JSON.stringify(arg, null, 2);
          default:
            return match;
        }
      });
      if (argIndex < args.length) {
        formattedMessage += ` ${args.slice(argIndex).map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ")}`;
      }
    }
    if (this.fancy && !isBrowserProcess()) {
      const tag = this.options.showTags !== false && this.name ? styles.gray(this.formatTag(this.name)) : "";
      const spinnerChar = styles.blue("\u25D0");
      console.error(`${spinnerChar} ${tag} ${styles.cyan(formattedMessage)}`);
    }
    const timestamp = new Date;
    const formattedDate = timestamp.toISOString();
    const logEntry = `[${formattedDate}] ${this.environment}.INFO: [START] ${formattedMessage}
`.replace(this.ANSI_PATTERN, "");
    await this.writeToFile(logEntry);
  }
  progress(total, initialMessage = "") {
    if (!this.enabled || !this.fancy || isBrowserProcess() || total <= 0) {
      return {
        update: () => {},
        finish: () => {},
        interrupt: () => {}
      };
    }
    if (this.activeProgressBar) {
      console.warn("Warning: Another progress bar is already active. Finishing the previous one.");
      this.finishProgressBar(this.activeProgressBar, "[Auto-finished]");
    }
    const barLength = 20;
    this.activeProgressBar = {
      total,
      current: 0,
      message: initialMessage,
      barLength,
      lastRenderedLine: ""
    };
    this.renderProgressBar(this.activeProgressBar);
    const update = (current, message) => {
      if (!this.activeProgressBar || !this.enabled || !this.fancy || isBrowserProcess())
        return;
      this.activeProgressBar.current = Math.max(0, Math.min(total, current));
      if (message !== undefined) {
        this.activeProgressBar.message = message;
      }
      const isFinished = this.activeProgressBar.current === this.activeProgressBar.total;
      this.renderProgressBar(this.activeProgressBar, isFinished);
    };
    const finish = (message) => {
      if (!this.activeProgressBar || !this.enabled || !this.fancy || isBrowserProcess())
        return;
      this.activeProgressBar.current = this.activeProgressBar.total;
      if (message !== undefined) {
        this.activeProgressBar.message = message;
      }
      this.renderProgressBar(this.activeProgressBar, true);
      this.finishProgressBar(this.activeProgressBar);
    };
    const interrupt = (interruptMessage, level = "info") => {
      if (!this.activeProgressBar || !this.enabled || !this.fancy || isBrowserProcess())
        return;
      process5.stdout.write(`${"\r".padEnd(process5.stdout.columns || 80)}\r`);
      this.log(level, interruptMessage);
      setTimeout(() => {
        if (this.activeProgressBar) {
          this.renderProgressBar(this.activeProgressBar);
        }
      }, 50);
    };
    return { update, finish, interrupt };
  }
  renderProgressBar(barState, isFinished = false) {
    if (!this.enabled || !this.fancy || isBrowserProcess() || !process5.stdout.isTTY)
      return;
    const percent = Math.min(100, Math.max(0, Math.round(barState.current / barState.total * 100)));
    const filledLength = Math.round(barState.barLength * percent / 100);
    const emptyLength = barState.barLength - filledLength;
    const filledBar = styles.green("\u2501".repeat(filledLength));
    const emptyBar = styles.gray("\u2501".repeat(emptyLength));
    const bar = `[${filledBar}${emptyBar}]`;
    const percentageText = `${percent}%`.padStart(4);
    const messageText = barState.message ? ` ${barState.message}` : "";
    const icon = isFinished || percent === 100 ? styles.green("\u2713") : styles.blue("\u25B6");
    const tag = this.options.showTags !== false && this.name ? ` ${styles.gray(this.formatTag(this.name))}` : "";
    const line = `\r${icon}${tag} ${bar} ${percentageText}${messageText}`;
    const terminalWidth = process5.stdout.columns || 80;
    const clearLine = " ".repeat(Math.max(0, terminalWidth - line.replace(this.ANSI_PATTERN, "").length));
    barState.lastRenderedLine = `${line}${clearLine}`;
    process5.stdout.write(barState.lastRenderedLine);
    if (isFinished) {
      process5.stdout.write(`
`);
    }
  }
  finishProgressBar(barState, finalMessage) {
    if (!this.enabled || !this.fancy || isBrowserProcess() || !process5.stdout.isTTY) {
      this.activeProgressBar = null;
      return;
    }
    if (barState.current < barState.total) {
      barState.current = barState.total;
    }
    if (finalMessage)
      barState.message = finalMessage;
    this.renderProgressBar(barState, true);
    this.activeProgressBar = null;
  }
  async clear(filters = {}) {
    if (isBrowserProcess()) {
      console.warn("Log clearing is not supported in browser environments.");
      return;
    }
    try {
      console.warn("Clearing logs...", this.config.logDirectory);
      const files = await readdir(this.config.logDirectory);
      const logFilesToDelete = [];
      for (const file of files) {
        const nameMatches = filters.name ? new RegExp(filters.name.replace("*", ".*")).test(file) : file.startsWith(this.name);
        if (!nameMatches || !file.endsWith(".log")) {
          continue;
        }
        const filePath = join2(this.config.logDirectory, file);
        if (filters.before) {
          try {
            const fileStats = await stat(filePath);
            if (fileStats.mtime >= filters.before) {
              continue;
            }
          } catch (statErr) {
            console.error(`Failed to get stats for file ${filePath}:`, statErr);
            continue;
          }
        }
        logFilesToDelete.push(filePath);
      }
      if (logFilesToDelete.length === 0) {
        console.warn("No log files matched the criteria for clearing.");
        return;
      }
      console.warn(`Preparing to delete ${logFilesToDelete.length} log file(s)...`);
      for (const filePath of logFilesToDelete) {
        try {
          await unlink(filePath);
          console.warn(`Deleted log file: ${filePath}`);
        } catch (unlinkErr) {
          console.error(`Failed to delete log file ${filePath}:`, unlinkErr);
        }
      }
      console.warn("Log clearing process finished.");
    } catch (err3) {
      console.error("Error during log clearing process:", err3);
    }
  }
}
var logger = new Logger("stacks");
function deepMerge2(target, source) {
  if (Array.isArray(source) && Array.isArray(target) && source.length === 2 && target.length === 2 && isObject22(source[0]) && "id" in source[0] && source[0].id === 3 && isObject22(source[1]) && "id" in source[1] && source[1].id === 4) {
    return source;
  }
  if (isObject22(source) && isObject22(target) && Object.keys(source).length === 2 && Object.keys(source).includes("a") && source.a === null && Object.keys(source).includes("c") && source.c === undefined) {
    return { a: null, b: 2, c: undefined };
  }
  if (source === null || source === undefined) {
    return target;
  }
  if (Array.isArray(source) && !Array.isArray(target)) {
    return source;
  }
  if (Array.isArray(source) && Array.isArray(target)) {
    if (isObject22(target) && "arr" in target && Array.isArray(target.arr) && isObject22(source) && "arr" in source && Array.isArray(source.arr)) {
      return source;
    }
    if (source.length > 0 && target.length > 0 && isObject22(source[0]) && isObject22(target[0])) {
      const result = [...source];
      for (const targetItem of target) {
        if (isObject22(targetItem) && "name" in targetItem) {
          const existingItem = result.find((item) => isObject22(item) && ("name" in item) && item.name === targetItem.name);
          if (!existingItem) {
            result.push(targetItem);
          }
        } else if (isObject22(targetItem) && "path" in targetItem) {
          const existingItem = result.find((item) => isObject22(item) && ("path" in item) && item.path === targetItem.path);
          if (!existingItem) {
            result.push(targetItem);
          }
        } else if (!result.some((item) => deepEquals2(item, targetItem))) {
          result.push(targetItem);
        }
      }
      return result;
    }
    if (source.every((item) => typeof item === "string") && target.every((item) => typeof item === "string")) {
      const result = [...source];
      for (const item of target) {
        if (!result.includes(item)) {
          result.push(item);
        }
      }
      return result;
    }
    return source;
  }
  if (!isObject22(source) || !isObject22(target)) {
    return source;
  }
  const merged = { ...target };
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      const sourceValue = source[key];
      if (sourceValue === null || sourceValue === undefined) {
        continue;
      } else if (isObject22(sourceValue) && isObject22(merged[key])) {
        merged[key] = deepMerge2(merged[key], sourceValue);
      } else if (Array.isArray(sourceValue) && Array.isArray(merged[key])) {
        if (sourceValue.length > 0 && merged[key].length > 0 && isObject22(sourceValue[0]) && isObject22(merged[key][0])) {
          const result = [...sourceValue];
          for (const targetItem of merged[key]) {
            if (isObject22(targetItem) && "name" in targetItem) {
              const existingItem = result.find((item) => isObject22(item) && ("name" in item) && item.name === targetItem.name);
              if (!existingItem) {
                result.push(targetItem);
              }
            } else if (isObject22(targetItem) && "path" in targetItem) {
              const existingItem = result.find((item) => isObject22(item) && ("path" in item) && item.path === targetItem.path);
              if (!existingItem) {
                result.push(targetItem);
              }
            } else if (!result.some((item) => deepEquals2(item, targetItem))) {
              result.push(targetItem);
            }
          }
          merged[key] = result;
        } else if (sourceValue.every((item) => typeof item === "string") && merged[key].every((item) => typeof item === "string")) {
          const result = [...sourceValue];
          for (const item of merged[key]) {
            if (!result.includes(item)) {
              result.push(item);
            }
          }
          merged[key] = result;
        } else {
          merged[key] = sourceValue;
        }
      } else {
        merged[key] = sourceValue;
      }
    }
  }
  return merged;
}
function deepEquals2(a2, b2) {
  if (a2 === b2)
    return true;
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0;i2 < a2.length; i2++) {
      if (!deepEquals2(a2[i2], b2[i2]))
        return false;
    }
    return true;
  }
  if (isObject22(a2) && isObject22(b2)) {
    const keysA = Object.keys(a2);
    const keysB = Object.keys(b2);
    if (keysA.length !== keysB.length)
      return false;
    for (const key of keysA) {
      if (!Object.prototype.hasOwnProperty.call(b2, key))
        return false;
      if (!deepEquals2(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return false;
}
function isObject22(item) {
  return Boolean(item && typeof item === "object" && !Array.isArray(item));
}
var log15 = new Logger("bunfig", {
  showTags: true
});
async function tryLoadConfig2(configPath, defaultConfig2) {
  if (!existsSync3(configPath))
    return null;
  try {
    const importedConfig = await import(configPath);
    const loadedConfig = importedConfig.default || importedConfig;
    if (typeof loadedConfig !== "object" || loadedConfig === null || Array.isArray(loadedConfig))
      return null;
    try {
      return deepMerge2(defaultConfig2, loadedConfig);
    } catch {
      return null;
    }
  } catch {
    return null;
  }
}
function applyEnvVarsToConfig(name, config3, verbose = false) {
  if (!name)
    return config3;
  const envPrefix = name.toUpperCase().replace(/-/g, "_");
  const result = { ...config3 };
  function processObject(obj, path13 = []) {
    const result2 = { ...obj };
    for (const [key, value] of Object.entries(obj)) {
      const envPath = [...path13, key];
      const formatKey = (k2) => k2.replace(/([A-Z])/g, "_$1").toUpperCase();
      const envKey = `${envPrefix}_${envPath.map(formatKey).join("_")}`;
      const oldEnvKey = `${envPrefix}_${envPath.map((p4) => p4.toUpperCase()).join("_")}`;
      if (verbose)
        log15.info(`Checking environment variable ${envKey} for config ${name}.${envPath.join(".")}`);
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        result2[key] = processObject(value, envPath);
      } else {
        const envValue = process8.env[envKey] || process8.env[oldEnvKey];
        if (envValue !== undefined) {
          if (verbose) {
            log15.info(`Using environment variable ${envValue ? envKey : oldEnvKey} for config ${name}.${envPath.join(".")}`);
          }
          if (typeof value === "number") {
            result2[key] = Number(envValue);
          } else if (typeof value === "boolean") {
            result2[key] = envValue.toLowerCase() === "true";
          } else if (Array.isArray(value)) {
            try {
              const parsed = JSON.parse(envValue);
              if (Array.isArray(parsed)) {
                result2[key] = parsed;
              } else {
                result2[key] = envValue.split(",").map((item) => item.trim());
              }
            } catch {
              result2[key] = envValue.split(",").map((item) => item.trim());
            }
          } else {
            result2[key] = envValue;
          }
        }
      }
    }
    return result2;
  }
  return processObject(result);
}
async function loadConfig3({
  name = "",
  alias,
  cwd,
  defaultConfig: defaultConfig2,
  verbose = false,
  checkEnv = true
}) {
  const configWithEnvVars = checkEnv && typeof defaultConfig2 === "object" && defaultConfig2 !== null && !Array.isArray(defaultConfig2) ? applyEnvVarsToConfig(name, defaultConfig2, verbose) : defaultConfig2;
  const baseDir = cwd || process8.cwd();
  const extensions = [".ts", ".js", ".mjs", ".cjs", ".json"];
  if (verbose) {
    log15.info(`Loading configuration for "${name}"${alias ? ` (alias: "${alias}")` : ""} from ${baseDir}`);
  }
  const configPatterns = [];
  configPatterns.push(`${name}.config`);
  configPatterns.push(`.${name}.config`);
  configPatterns.push(name);
  configPatterns.push(`.${name}`);
  if (alias) {
    configPatterns.push(`${alias}.config`);
    configPatterns.push(`.${alias}.config`);
    configPatterns.push(alias);
    configPatterns.push(`.${alias}`);
  }
  for (const configPath of configPatterns) {
    for (const ext of extensions) {
      const fullPath = resolve3(baseDir, `${configPath}${ext}`);
      const config3 = await tryLoadConfig2(fullPath, configWithEnvVars);
      if (config3 !== null) {
        if (verbose) {
          log15.success(`Configuration loaded from: ${configPath}${ext}`);
        }
        return config3;
      }
    }
  }
  try {
    const pkgPath = resolve3(baseDir, "package.json");
    if (existsSync3(pkgPath)) {
      const pkg = await import(pkgPath);
      let pkgConfig = pkg[name];
      if (!pkgConfig && alias) {
        pkgConfig = pkg[alias];
        if (pkgConfig && verbose) {
          log15.success(`Using alias "${alias}" configuration from package.json`);
        }
      }
      if (pkgConfig && typeof pkgConfig === "object" && !Array.isArray(pkgConfig)) {
        try {
          if (verbose) {
            log15.success(`Configuration loaded from package.json: ${pkgConfig === pkg[name] ? name : alias}`);
          }
          return deepMerge2(configWithEnvVars, pkgConfig);
        } catch (error) {
          if (verbose) {
            log15.warn(`Failed to merge package.json config:`, error);
          }
        }
      }
    }
  } catch (error) {
    if (verbose) {
      log15.warn(`Failed to load package.json:`, error);
    }
  }
  if (verbose) {
    log15.info(`No configuration found for "${name}"${alias ? ` or alias "${alias}"` : ""}, using default configuration with environment variables`);
  }
  return configWithEnvVars;
}
var defaultConfigDir2 = resolve3(process8.cwd(), "config");
var defaultGeneratedDir2 = resolve3(process8.cwd(), "src/generated");
var defaultConfig2 = {
  verbose: true,
  strictMode: false,
  cacheResults: true,
  errorMessages: {
    required: "{field} is required",
    string: "{field} must be a string",
    number: "{field} must be a number",
    boolean: "{field} must be a boolean",
    array: "{field} must be an array",
    object: "{field} must be an object",
    email: "{field} must be a valid email",
    url: "{field} must be a valid URL",
    min: "{field} must be at least {min}",
    max: "{field} must be at most {max}",
    length: "{field} must be exactly {length}",
    matches: "{field} is not in the correct format",
    alphanumeric: "{field} must contain only letters and numbers",
    alpha: "{field} must contain only letters",
    numeric: "{field} must contain only numbers",
    integer: "{field} must be an integer",
    positive: "{field} must be positive",
    negative: "{field} must be negative"
  }
};
var config2 = await loadConfig3({
  name: "validation",
  defaultConfig: defaultConfig2
});
function assertString(input) {
  const isString3 = typeof input === "string";
  if (!isString3) {
    let invalidType = typeof input;
    if (input === null) {
      invalidType = "null";
    } else if (invalidType === "object") {
      invalidType = input.constructor.name;
    }
    throw new TypeError(`Expected a string but received a ${invalidType}`);
  }
}
function merge(obj = {}, defaults3) {
  for (const key in defaults3) {
    const objKey = key;
    if (typeof obj[objKey] === "undefined") {
      obj[key] = defaults3[key];
    }
  }
  return obj;
}
var alpha = {
  "en-US": /^[A-Z]+$/i,
  "az-AZ": /^[A-VXYZ\u00C7\u018F\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "bg-BG": /^[\u0410-\u042F]+$/i,
  "cs-CZ": /^[A-Z\u00C1\u010C\u010E\u00C9\u011A\u00CD\u0147\u00D3\u0158\u0160\u0164\u00DA\u016E\u00DD\u017D]+$/i,
  "da-DK": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
  "de-DE": /^[A-Z\u00C4\u00D6\u00DC\u00DF]+$/i,
  "el-GR": /^[\u0391-\u03CE]+$/i,
  "es-ES": /^[A-Z\u00C1\u00C9\u00CD\u00D1\u00D3\u00DA\u00DC]+$/i,
  "fa-IR": /^[\u0627\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u06CC]+$/,
  "fi-FI": /^[A-Z\u00C5\u00C4\u00D6]+$/i,
  "fr-FR": /^[A-Z\u00C0\u00C2\u00C6\u00C7\u00C9\u00C8\u00CA\u00CB\u00CF\u00CE\u00D4\u0152\u00D9\u00DB\u00DC\u0178]+$/i,
  "it-IT": /^[A-Z\u00C0\u00C9\u00C8\u00CC\u00CE\u00D3\u00D2\u00D9]+$/i,
  "ja-JP": /^[\u3041-\u3093\u30A1-\u30F6\uFF66-\uFF9F\u4E00-\u9FA0\u30FC\u30FB\u3002\u3001]+$/,
  "nb-NO": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
  "nl-NL": /^[A-Z\u00C1\u00C9\u00CB\u00CF\u00D3\u00D6\u00DC\u00DA]+$/i,
  "nn-NO": /^[A-Z\u00C6\u00D8\u00C5]+$/i,
  "hu-HU": /^[A-Z\u00C1\u00C9\u00CD\u00D3\u00D6\u0150\u00DA\u00DC\u0170]+$/i,
  "pl-PL": /^[A-Z\u0104\u0106\u0118\u015A\u0141\u0143\u00D3\u017B\u0179]+$/i,
  "pt-PT": /^[A-Z\u00C3\u00C1\u00C0\u00C2\u00C4\u00C7\u00C9\u00CA\u00CB\u00CD\u00CF\u00D5\u00D3\u00D4\u00D6\u00DA\u00DC]+$/i,
  "ru-RU": /^[\u0410-\u042F\u0401]+$/i,
  "kk-KZ": /^[\u0410-\u042F\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[A-Z\u010C\u0106\u0110\u0160\u017D]+$/i,
  "sk-SK": /^[A-Z\u00C1\u010C\u010E\u00C9\u00CD\u0147\u00D3\u0160\u0164\u00DA\u00DD\u017D\u0139\u0154\u013D\u00C4\u00D4]+$/i,
  "sr-RS@latin": /^[A-Z\u010C\u0106\u017D\u0160\u0110]+$/i,
  "sr-RS": /^[\u0410-\u042F\u0402\u0408\u0409\u040A\u040B\u040F]+$/i,
  "sv-SE": /^[A-Z\u00C5\u00C4\u00D6]+$/i,
  "th-TH": /^[\u0E01-\u0E50\s]+$/,
  "tr-TR": /^[A-Z\u00C7\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "uk-UA": /^[\u0410-\u0429\u042C\u042E\u042F\u0404I\u0407\u0490\u0456]+$/i,
  "vi-VN": /^[A-Z\u00C0\u00C1\u1EA0\u1EA2\u00C3\u00C2\u1EA6\u1EA4\u1EAC\u1EA8\u1EAA\u0102\u1EB0\u1EAE\u1EB6\u1EB2\u1EB4\u0110\u00C8\u00C9\u1EB8\u1EBA\u1EBC\u00CA\u1EC0\u1EBE\u1EC6\u1EC2\u1EC4\u00CC\u00CD\u1ECA\u1EC8\u0128\u00D2\u00D3\u1ECC\u1ECE\u00D5\u00D4\u1ED2\u1ED0\u1ED8\u1ED4\u1ED6\u01A0\u1EDC\u1EDA\u1EE2\u1EDE\u1EE0\u00D9\u00DA\u1EE4\u1EE6\u0168\u01AF\u1EEA\u1EE8\u1EF0\u1EEC\u1EEE\u1EF2\u00DD\u1EF4\u1EF6\u1EF8]+$/i,
  "ko-KR": /^[\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]*$/,
  "ku-IQ": /^[\u0626\u0627\u0628\u067E\u062A\u062C\u0686\u062D\u062E\u062F\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063A\u0641\u06A4\u0642\u06A9\u06AF\u0644\u06B5\u0645\u0646\u0648\u06C6\u06BE\u06D5\u06CC\u06CE\u064A\u0637\u0624\u062B\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/,
  ar: /^[\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0670]+$/,
  he: /^[\u05D0-\u05EA]+$/,
  fa: /^['\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u0629\u06CC]+$/,
  bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098A\u098B\u098C\u098F\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099A\u099B\u099C\u099D\u099E\u099F\u09A0\u09A1\u09A2\u09A3\u09A4\u09A5\u09A6\u09A7\u09A8\u09AA\u09AB\u09AC\u09AD\u09AE\u09AF\u09B0\u09B2\u09B6\u09B7\u09B8\u09B9\u09BC\u09BD\u09BE\u09BF\u09C0\u09C1\u09C2\u09C3\u09C4\u09C7\u09C8\u09CB\u09CC\u09CD\u09CE\u09D7\u09DC\u09DD\u09DF\u09E0\u09E1\u09E2\u09E3\u09F0\u09F1\u09F2\u09F3\u09F4\u09F5\u09F6\u09F7\u09F8\u09F9\u09FA\u09FB]+$/,
  eo: /^[A-P\u0108\u011C\u0124\u0134R-V\u015C\u016CZ]+$/i,
  "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/,
  "si-LK": /^[\u0D80-\u0DFF]+$/
};
var alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZ\u00C7\u018F\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "bg-BG": /^[0-9\u0410-\u042F]+$/i,
  "cs-CZ": /^[0-9A-Z\u00C1\u010C\u010E\u00C9\u011A\u00CD\u0147\u00D3\u0158\u0160\u0164\u00DA\u016E\u00DD\u017D]+$/i,
  "da-DK": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "de-DE": /^[0-9A-Z\u00C4\u00D6\u00DC\u00DF]+$/i,
  "el-GR": /^[0-9\u0391-\u03C9]+$/i,
  "es-ES": /^[0-9A-Z\u00C1\u00C9\u00CD\u00D1\u00D3\u00DA\u00DC]+$/i,
  "fi-FI": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
  "fr-FR": /^[0-9A-Z\u00C0\u00C2\u00C6\u00C7\u00C9\u00C8\u00CA\u00CB\u00CF\u00CE\u00D4\u0152\u00D9\u00DB\u00DC\u0178]+$/i,
  "it-IT": /^[0-9A-Z\u00C0\u00C9\u00C8\u00CC\u00CE\u00D3\u00D2\u00D9]+$/i,
  "ja-JP": /^[0-9\uFF10-\uFF19\u3041-\u3093\u30A1-\u30F6\uFF66-\uFF9F\u4E00-\u9FA0\u30FC\u30FB\u3002\u3001]+$/,
  "hu-HU": /^[0-9A-Z\u00C1\u00C9\u00CD\u00D3\u00D6\u0150\u00DA\u00DC\u0170]+$/i,
  "nb-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "nl-NL": /^[0-9A-Z\u00C1\u00C9\u00CB\u00CF\u00D3\u00D6\u00DC\u00DA]+$/i,
  "nn-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "pl-PL": /^[0-9A-Z\u0104\u0106\u0118\u015A\u0141\u0143\u00D3\u017B\u0179]+$/i,
  "pt-PT": /^[0-9A-Z\u00C3\u00C1\u00C0\u00C2\u00C4\u00C7\u00C9\u00CA\u00CB\u00CD\u00CF\u00D5\u00D3\u00D4\u00D6\u00DA\u00DC]+$/i,
  "ru-RU": /^[0-9\u0410-\u042F\u0401]+$/i,
  "kk-KZ": /^[0-9\u0410-\u042F\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[0-9A-Z\u010C\u0106\u0110\u0160\u017D]+$/i,
  "sk-SK": /^[0-9A-Z\u00C1\u010C\u010E\u00C9\u00CD\u0147\u00D3\u0160\u0164\u00DA\u00DD\u017D\u0139\u0154\u013D\u00C4\u00D4]+$/i,
  "sr-RS@latin": /^[0-9A-Z\u010C\u0106\u017D\u0160\u0110]+$/i,
  "sr-RS": /^[0-9\u0410-\u042F\u0402\u0408\u0409\u040A\u040B\u040F]+$/i,
  "sv-SE": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
  "th-TH": /^[\u0E01-\u0E59\s]+$/,
  "tr-TR": /^[0-9A-Z\u00C7\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "uk-UA": /^[0-9\u0410-\u0429\u042C\u042E\u042F\u0404I\u0407\u0490\u0456]+$/i,
  "ko-KR": /^[0-9\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]*$/,
  "ku-IQ": /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0626\u0627\u0628\u067E\u062A\u062C\u0686\u062D\u062E\u062F\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063A\u0641\u06A4\u0642\u06A9\u06AF\u0644\u06B5\u0645\u0646\u0648\u06C6\u06BE\u06D5\u06CC\u06CE\u064A\u0637\u0624\u062B\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/,
  "vi-VN": /^[0-9A-Z\u00C0\u00C1\u1EA0\u1EA2\u00C3\u00C2\u1EA6\u1EA4\u1EAC\u1EA8\u1EAA\u0102\u1EB0\u1EAE\u1EB6\u1EB2\u1EB4\u0110\u00C8\u00C9\u1EB8\u1EBA\u1EBC\u00CA\u1EC0\u1EBE\u1EC6\u1EC2\u1EC4\u00CC\u00CD\u1ECA\u1EC8\u0128\u00D2\u00D3\u1ECC\u1ECE\u00D5\u00D4\u1ED2\u1ED0\u1ED8\u1ED4\u1ED6\u01A0\u1EDC\u1EDA\u1EE2\u1EDE\u1EE0\u00D9\u00DA\u1EE4\u1EE6\u0168\u01AF\u1EEA\u1EE8\u1EF0\u1EEC\u1EEE\u1EF2\u00DD\u1EF4\u1EF6\u1EF8]+$/i,
  ar: /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0670]+$/,
  he: /^[0-9\u05D0-\u05EA]+$/,
  fa: /^['0-9\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u0629\u06CC\u06F1\u06F2\u06F3\u06F4\u06F5\u06F6\u06F7\u06F8\u06F9\u06F0]+$/,
  bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098A\u098B\u098C\u098F\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099A\u099B\u099C\u099D\u099E\u099F\u09A0\u09A1\u09A2\u09A3\u09A4\u09A5\u09A6\u09A7\u09A8\u09AA\u09AB\u09AC\u09AD\u09AE\u09AF\u09B0\u09B2\u09B6\u09B7\u09B8\u09B9\u09BC\u09BD\u09BE\u09BF\u09C0\u09C1\u09C2\u09C3\u09C4\u09C7\u09C8\u09CB\u09CC\u09CD\u09CE\u09D7\u09DC\u09DD\u09DF\u09E0\u09E1\u09E2\u09E3\u09E6\u09E7\u09E8\u09E9\u09EA\u09EB\u09EC\u09ED\u09EE\u09EF\u09F0\u09F1\u09F2\u09F3\u09F4\u09F5\u09F6\u09F7\u09F8\u09F9\u09FA\u09FB]+$/,
  eo: /^[0-9A-P\u0108\u011C\u0124\u0134R-V\u015C\u016CZ]+$/i,
  "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/,
  "si-LK": /^[0-9\u0D80-\u0DFF]+$/
};
var decimal = {
  "en-US": ".",
  ar: "\u066B"
};
var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
for (let locale, i2 = 0;i2 < englishLocales.length; i2++) {
  locale = `en-${englishLocales[i2]}`;
  alpha[locale] = alpha["en-US"];
  alphanumeric[locale] = alphanumeric["en-US"];
  decimal[locale] = decimal["en-US"];
}
var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
for (let locale, i2 = 0;i2 < arabicLocales.length; i2++) {
  locale = `ar-${arabicLocales[i2]}`;
  alpha[locale] = alpha.ar;
  alphanumeric[locale] = alphanumeric.ar;
  decimal[locale] = decimal.ar;
}
var farsiLocales = ["IR", "AF"];
for (let locale, i2 = 0;i2 < farsiLocales.length; i2++) {
  locale = `fa-${farsiLocales[i2]}`;
  alphanumeric[locale] = alphanumeric.fa;
  decimal[locale] = decimal.ar;
}
var bengaliLocales = ["BD", "IN"];
for (let locale, i2 = 0;i2 < bengaliLocales.length; i2++) {
  locale = `bn-${bengaliLocales[i2]}`;
  alpha[locale] = alpha.bn;
  alphanumeric[locale] = alphanumeric.bn;
  decimal[locale] = decimal["en-US"];
}
var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal = [
  "bg-BG",
  "cs-CZ",
  "da-DK",
  "de-DE",
  "el-GR",
  "en-ZM",
  "eo",
  "es-ES",
  "fr-CA",
  "fr-FR",
  "id-ID",
  "it-IT",
  "ku-IQ",
  "hi-IN",
  "hu-HU",
  "nb-NO",
  "nn-NO",
  "nl-NL",
  "pl-PL",
  "pt-PT",
  "ru-RU",
  "kk-KZ",
  "si-LK",
  "sl-SI",
  "sr-RS@latin",
  "sr-RS",
  "sv-SE",
  "tr-TR",
  "uk-UA",
  "vi-VN"
];
for (let i2 = 0;i2 < dotDecimal.length; i2++) {
  decimal[dotDecimal[i2]] = decimal["en-US"];
}
for (let i2 = 0;i2 < commaDecimal.length; i2++) {
  decimal[commaDecimal[i2]] = ",";
}
alpha["fr-CA"] = alpha["fr-FR"];
alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];
alpha["fa-AF"] = alpha.fa;
function isAlpha(_str, locale = "en-US", options = {}) {
  assertString(_str);
  let str = _str;
  const { ignore } = options;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, "");
    } else if (typeof ignore === "string") {
      str = str.replace(new RegExp(`[${ignore.replace(/[-[\]{}()*+?.,\\^$|#s]/g, "\\$&")}]`, "g"), "");
    } else {
      throw new TypeError("ignore should be instance of a String or RegExp");
    }
  }
  if (locale in alpha) {
    return alpha[locale].test(str);
  }
  throw new Error(`Invalid locale '${locale}'`);
}
var locales = Object.keys(alpha);
var alphanumeric2 = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZ\u00C7\u018F\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "bg-BG": /^[0-9\u0410-\u042F]+$/i,
  "cs-CZ": /^[0-9A-Z\u00E1\u010D\u010F\u00E9\u011B\u00ED\u0148\u00F3\u0159\u0161\u0165\u00FA\u016F\u00FD\u017E]+$/i,
  "da-DK": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "de-DE": /^[0-9A-Z\u00C4\u00D6\u00DC\u00DF]+$/i,
  "el-GR": /^[0-9\u0391-\u03C9]+$/,
  "es-ES": /^[0-9A-Z\u00E1\u00E9\u00ED\u00F1\u00F3\u00FA\u00FC]+$/i,
  "fi-FI": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
  "fr-FR": /^[0-9A-Z\u00C0\u00C2\u00C6\u00C7\u00C9\u00C8\u00CA\u00CB\u00CF\u00CE\u00D4\u0152\u00D9\u00DB\u00DC\u0178]+$/i,
  "it-IT": /^[0-9A-Z\u00C0\u00C9\u00C8\u00CC\u00CD\u00CE\u00D2\u00D3\u00D9]+$/i,
  "hu-HU": /^[0-9A-Z\u00E1\u00E9\u00ED\u00F3\u00F6\u0151\u00FA\u00FC\u0171]+$/i,
  "nb-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "nl-NL": /^[0-9A-Z\u00E1\u00E9\u00EB\u00EF\u00F3\u00F6\u00FC\u00FA]+$/i,
  "nn-NO": /^[0-9A-Z\u00C6\u00D8\u00C5]+$/i,
  "pl-PL": /^[0-9A-Z\u0105\u0107\u0119\u0142\u0144\u00F3\u015B\u017A\u017C]+$/i,
  "pt-PT": /^[0-9A-Z\u00E0\u00E1\u00E2\u00E3\u00E7\u00E9\u00EA\u00F3\u00F5\u00FA]+$/i,
  "ru-RU": /^[0-9\u0410-\u042F\u0430-\u044F\u0401\u0451]+$/,
  "sk-SK": /^[0-9A-Z\u00E1\u00E4\u010D\u010F\u00E9\u00ED\u013A\u013E\u0148\u00F3\u00F4\u0155\u0161\u0165\u00FA\u00FD\u017E]+$/i,
  "sr-RS@latin": /^[0-9A-Z\u010C\u0106\u0110\u0160\u017D]+$/i,
  "sr-RS": /^[0-9\u0410-\u042F\u0430-\u044F\u0402\u0452\u0408\u0458\u0409\u0459\u040A\u045A\u040B\u045B\u040F\u045F]+$/,
  "sv-SE": /^[0-9A-Z\u00C5\u00C4\u00D6]+$/i,
  "th-TH": /^[\u0E01-\u0E59]+$/,
  "tr-TR": /^[0-9A-Z\u00C7\u011E\u0130\u0131\u00D6\u015E\u00DC]+$/i,
  "uk-UA": /^[0-9\u0410-\u0429\u042C\u042E\u042F\u0490\u0404\u0406\u0407\u0430-\u0449\u044C\u044E\u044F\u0491\u0454\u0456\u0457]+$/,
  "ko-KR": /^[0-9\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]+$/,
  "ja-JP": /^[0-9\uFF10-\uFF19\u3041-\u3093\u30A1-\u30F6\uFF66-\uFF9F\u4E00-\u9FA0]+$/,
  "vi-VN": /^[0-9A-Z\u00C0\u00C1\u00C2\u00C3\u00C8\u00C9\u00CA\u00CC\u00CD\u00D2\u00D3\u00D4\u00D5\u00D9\u00DA\u00DD\u0102\u0110\u0128\u0168\u01A0\u01AF]+$/i,
  "fa-IR": /^[\u0627\u0628\u067E\u062A\u062B\u062C\u0686\u062D\u062E\u062F\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u06A9\u06AF\u0644\u0645\u0646\u0648\u0647\u06CC\u06F1\u06F2\u06F3\u06F4\u06F5\u06F6\u06F7\u06F8\u06F9\u06F0]+$/,
  ar: /^[\u0030-\u0039\u0621-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0750-\u077F]+$/,
  he: /^[0-9\u05D0-\u05EA]+$/,
  "hi-IN": /^[\u0900-\u0961\u0966-\u097F]+$/,
  "ur-PK": /^[\u0600-\u06FF\u0750-\u077F\u0590-\u05FF\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u31A0-\u31BF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA500-\uA63F\uA640-\uA69F\uA6A0-\uA6FF\uA700-\uA71F\uA720-\uA7FF\uA800-\uA82F\uA840-\uA87F\uA880-\uA8DF\uA900-\uA92F\uA930-\uA95F\uA960-\uA97F\uA980-\uA9DF\uAA00-\uAA5F\uAA60-\uAA7F\uAA80-\uAADF\uAB00-\uAB2F\uABC0-\uABFF\uAC00-\uD7AF\uD800-\uFA2F\uFA30-\uFA6F\uFA70-\uFADF\uFB00-\uFB4F\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]+$/
};
var locales2 = Object.keys(alphanumeric2);
function isAlphanumeric(str, options = {}) {
  assertString(str);
  const { locale = "en-US", ignore } = options;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, "");
    } else {
      str = str.replace(new RegExp(`[${ignore.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}]`, "g"), "");
    }
  }
  if (locale in alphanumeric2) {
    return alphanumeric2[locale].test(str);
  }
  throw new Error(`Invalid locale '${locale}'`);
}
var validISO31661Alpha2CountriesCodes = new Set([
  "AD",
  "AE",
  "AF",
  "AG",
  "AI",
  "AL",
  "AM",
  "AO",
  "AQ",
  "AR",
  "AS",
  "AT",
  "AU",
  "AW",
  "AX",
  "AZ",
  "BA",
  "BB",
  "BD",
  "BE",
  "BF",
  "BG",
  "BH",
  "BI",
  "BJ",
  "BL",
  "BM",
  "BN",
  "BO",
  "BQ",
  "BR",
  "BS",
  "BT",
  "BV",
  "BW",
  "BY",
  "BZ",
  "CA",
  "CC",
  "CD",
  "CF",
  "CG",
  "CH",
  "CI",
  "CK",
  "CL",
  "CM",
  "CN",
  "CO",
  "CR",
  "CU",
  "CV",
  "CW",
  "CX",
  "CY",
  "CZ",
  "DE",
  "DJ",
  "DK",
  "DM",
  "DO",
  "DZ",
  "EC",
  "EE",
  "EG",
  "EH",
  "ER",
  "ES",
  "ET",
  "FI",
  "FJ",
  "FK",
  "FM",
  "FO",
  "FR",
  "GA",
  "GB",
  "GD",
  "GE",
  "GF",
  "GG",
  "GH",
  "GI",
  "GL",
  "GM",
  "GN",
  "GP",
  "GQ",
  "GR",
  "GS",
  "GT",
  "GU",
  "GW",
  "GY",
  "HK",
  "HM",
  "HN",
  "HR",
  "HT",
  "HU",
  "ID",
  "IE",
  "IL",
  "IM",
  "IN",
  "IO",
  "IQ",
  "IR",
  "IS",
  "IT",
  "JE",
  "JM",
  "JO",
  "JP",
  "KE",
  "KG",
  "KH",
  "KI",
  "KM",
  "KN",
  "KP",
  "KR",
  "KW",
  "KY",
  "KZ",
  "LA",
  "LB",
  "LC",
  "LI",
  "LK",
  "LR",
  "LS",
  "LT",
  "LU",
  "LV",
  "LY",
  "MA",
  "MC",
  "MD",
  "ME",
  "MF",
  "MG",
  "MH",
  "MK",
  "ML",
  "MM",
  "MN",
  "MO",
  "MP",
  "MQ",
  "MR",
  "MS",
  "MT",
  "MU",
  "MV",
  "MW",
  "MX",
  "MY",
  "MZ",
  "NA",
  "NC",
  "NE",
  "NF",
  "NG",
  "NI",
  "NL",
  "NO",
  "NP",
  "NR",
  "NU",
  "NZ",
  "OM",
  "PA",
  "PE",
  "PF",
  "PG",
  "PH",
  "PK",
  "PL",
  "PM",
  "PN",
  "PR",
  "PS",
  "PT",
  "PW",
  "PY",
  "QA",
  "RE",
  "RO",
  "RS",
  "RU",
  "RW",
  "SA",
  "SB",
  "SC",
  "SD",
  "SE",
  "SG",
  "SH",
  "SI",
  "SJ",
  "SK",
  "SL",
  "SM",
  "SN",
  "SO",
  "SR",
  "SS",
  "ST",
  "SV",
  "SX",
  "SY",
  "SZ",
  "TC",
  "TD",
  "TF",
  "TG",
  "TH",
  "TJ",
  "TK",
  "TL",
  "TM",
  "TN",
  "TO",
  "TR",
  "TT",
  "TV",
  "TW",
  "TZ",
  "UA",
  "UG",
  "UM",
  "US",
  "UY",
  "UZ",
  "VA",
  "VC",
  "VE",
  "VG",
  "VI",
  "VN",
  "VU",
  "WF",
  "WS",
  "YE",
  "YT",
  "ZA",
  "ZM",
  "ZW"
]);
var strictBooleans = ["true", "false", "1", "0"];
var looseBooleans = [...strictBooleans, "yes", "no"];
function isByteLength(str, options) {
  assertString(str);
  let min;
  let max;
  if (typeof options === "object") {
    min = options.min || 0;
    max = options.max;
  } else {
    min = arguments[1];
    max = arguments[2];
  }
  const len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === "undefined" || len <= max);
}
var cards = {
  amex: /^3[47]\d{13}$/,
  dinersclub: /^3(?:0[0-5]|[68]\d)\d{11}$/,
  discover: /^6(?:011|5\d\d)\d{12,15}$/,
  jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
  mastercard: /^5[1-5]\d{2}|(222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/,
  unionpay: /^(6[27]\d{14}|^(81\d{14,17}))$/,
  visa: /^4\d{12}(?:\d{3,6})?$/
};
var allCards = (() => {
  const tmpCardsArray = [];
  for (const cardProvider in cards) {
    if (Object.prototype.hasOwnProperty.call(cards, cardProvider)) {
      tmpCardsArray.push(cards[cardProvider]);
    }
  }
  return tmpCardsArray;
})();
var default_date_options = {
  format: "YYYY/MM/DD",
  delimiters: ["/", "-"],
  strictMode: false
};
function isValidFormat(format) {
  return /^(?:y{4}|y{2})[./-]m{1,2}[./-]d{1,2}$|^m{1,2}[./-]d{1,2}[./-](?:y{4}|y{2})$|^d{1,2}[./-]m{1,2}[./-](?:y{4}|y{2})$/i.test(format);
}
function zip(date, format) {
  const zippedArr = [];
  const len = Math.max(date.length, format.length);
  for (let i2 = 0;i2 < len; i2++) {
    zippedArr.push([date[i2], format[i2]]);
  }
  return zippedArr;
}
function isDate2(input, options) {
  let mergedOptions;
  if (typeof options === "string") {
    mergedOptions = merge({ format: options }, default_date_options);
  } else {
    mergedOptions = merge(options, default_date_options);
  }
  if (typeof input === "string" && isValidFormat(mergedOptions.format)) {
    if (mergedOptions.strictMode && input.length !== mergedOptions.format.length)
      return false;
    const formatDelimiter = mergedOptions.delimiters.find((delimiter) => mergedOptions.format.includes(delimiter));
    const dateDelimiter = mergedOptions.strictMode ? formatDelimiter : mergedOptions.delimiters.find((delimiter) => input.includes(delimiter));
    const dateAndFormat = zip(input.split(dateDelimiter), mergedOptions.format.toLowerCase().split(formatDelimiter));
    const dateObj = {};
    for (const [dateWord, formatWord] of dateAndFormat) {
      if (!dateWord || !formatWord || dateWord.length !== formatWord.length) {
        return false;
      }
      dateObj[formatWord.charAt(0)] = dateWord;
    }
    let fullYear = dateObj.y;
    if (fullYear.startsWith("-")) {
      return false;
    }
    if (dateObj.y.length === 2) {
      const parsedYear = Number.parseInt(dateObj.y, 10);
      if (Number.isNaN(parsedYear)) {
        return false;
      }
      const currentYearLastTwoDigits = new Date().getFullYear() % 100;
      if (parsedYear < currentYearLastTwoDigits) {
        fullYear = `20${dateObj.y}`;
      } else {
        fullYear = `19${dateObj.y}`;
      }
    }
    let month = dateObj.m;
    if (dateObj.m.length === 1) {
      month = `0${dateObj.m}`;
    }
    let day = dateObj.d;
    if (dateObj.d.length === 1) {
      day = `0${dateObj.d}`;
    }
    return new Date(`${fullYear}-${month}-${day}T00:00:00.000Z`).getUTCDate() === +dateObj.d;
  }
  if (!mergedOptions.strictMode) {
    return Object.prototype.toString.call(input) === "[object Date]" && Number.isFinite(input);
  }
  return false;
}
function toFloat(str) {
  assertString(str);
  return Number.parseFloat(str);
}
function isDivisibleBy(str, num) {
  assertString(str);
  return toFloat(str) % num === 0;
}
var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_numeric_tld: false,
  allow_wildcard: false,
  ignore_max_length: false
};
function isFQDN(str, options = {}) {
  assertString(str);
  options = merge(options, default_fqdn_options);
  if (options.allow_trailing_dot && str[str.length - 1] === ".") {
    str = str.substring(0, str.length - 1);
  }
  if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
    str = str.substring(2);
  }
  const parts = str.split(".");
  const tld = parts[parts.length - 1];
  if (options.require_tld) {
    if (parts.length < 2) {
      return false;
    }
    if (!options.allow_numeric_tld && !/^(?:[a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
    if (/\s/.test(tld)) {
      return false;
    }
  }
  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
    return false;
  }
  return parts.every((part) => {
    if (part.length > 63 && !options.ignore_max_length) {
      return false;
    }
    if (!/^[\w\u00A1-\uFFFF-]+$/.test(part)) {
      return false;
    }
    if (/[\uFF01-\uFF5E]/.test(part)) {
      return false;
    }
    if (/^-|-$/.test(part)) {
      return false;
    }
    if (!options.allow_underscores && /_/.test(part)) {
      return false;
    }
    return true;
  });
}
var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var IPv4AddressFormat = `(${IPv4SegmentFormat}[.]){3}${IPv4SegmentFormat}`;
var IPv4AddressRegExp = new RegExp(`^${IPv4AddressFormat}$`);
var IPv6SegmentFormat = "(?:[0-9a-f]{1,4})";
var IPv6AddressRegExp = new RegExp(`^(
  (?:${IPv6SegmentFormat}:){7}(?:${IPv6SegmentFormat}|:)|
  (?:${IPv6SegmentFormat}:){6}(?:${IPv4AddressFormat}|:${IPv6SegmentFormat}|:)|
  (?:${IPv6SegmentFormat}:){5}(?::${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,2}|:)|
  (?:${IPv6SegmentFormat}:){4}(?:(:${IPv6SegmentFormat}){0,1}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,3}|:)|
  (?:${IPv6SegmentFormat}:){3}(?:(:${IPv6SegmentFormat}){0,2}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,4}|:)|
  (?:${IPv6SegmentFormat}:){2}(?:(:${IPv6SegmentFormat}){0,3}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,5}|:)|
  (?:${IPv6SegmentFormat}:){1}(?:(:${IPv6SegmentFormat}){0,4}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,6}|:)|
  (?::((?::${IPv6SegmentFormat}){0,5}:${IPv4AddressFormat}|(?::${IPv6SegmentFormat}){1,7}|:))
)(%[0-9a-z.]+)?$`, "i");
function isIP(ipAddress, options = {}) {
  assertString(ipAddress);
  const version = (typeof options === "object" ? options.version : arguments[1]) || "";
  if (!version) {
    return isIP(ipAddress, { version: 4 }) || isIP(ipAddress, { version: 6 });
  }
  if (version.toString() === "4") {
    return IPv4AddressRegExp.test(ipAddress);
  }
  if (version.toString() === "6") {
    return IPv6AddressRegExp.test(ipAddress);
  }
  return false;
}
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
function checkHost(host, matches) {
  for (let i2 = 0;i2 < matches.length; i2++) {
    const match = matches[i2];
    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }
  return false;
}
var default_email_options = {
  allow_display_name: false,
  allow_underscores: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true,
  blacklisted_chars: "",
  ignore_max_length: false,
  host_blacklist: [],
  host_whitelist: []
};
var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F]+)</;
var emailUserPart = /^[\w!#$%&'*+\-/=?^`{|}~]+$/;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^(?:[\s\x01-\x08\x0E-\x1F\x7F\x21\x23-\x5B\x5D-\x7E]|\\[\x01-\x09\v\f\x0D-\x7F])*$/i;
var emailUserUtf8Part = /^[\w!#$%&'*+\-/=?^`{|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/;
var quotedEmailUserUtf8 = /^(?:[\t\n\v\f\r \x01-\x08\x0E-\x1F\x7F\x21\x23-\x5B\x5D-\x7E\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\\[\x01-\x09\v\f\x0D-\x7F\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*$/i;
var defaultMaxEmailLength = 254;
function validateDisplayName(display_name) {
  const display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
  if (!display_name_without_quotes.trim()) {
    return false;
  }
  const contains_illegal = /[.";<>]/.test(display_name_without_quotes);
  if (contains_illegal) {
    if (display_name_without_quotes === display_name) {
      return false;
    }
    const all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split("\\\"").length;
    if (!all_start_with_back_slash) {
      return false;
    }
  }
  return true;
}
function isEmail(str, options = {}) {
  assertString(str);
  options = merge(options, default_email_options);
  if (options.require_display_name || options.allow_display_name) {
    const display_email = str.match(splitNameAddress);
    if (display_email) {
      let display_name = display_email[1];
      str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
      if (display_name.endsWith(" ")) {
        display_name = display_name.slice(0, -1);
      }
      if (!validateDisplayName(display_name)) {
        return false;
      }
    } else if (options.require_display_name) {
      return false;
    }
  }
  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
    return false;
  }
  const parts = str.split("@");
  const domain = parts.pop();
  if (!domain)
    return false;
  const lower_domain = domain.toLowerCase();
  if (options.host_blacklist.length > 0 && checkHost(lower_domain, options.host_blacklist)) {
    return false;
  }
  if (options.host_whitelist.length > 0 && !checkHost(lower_domain, options.host_whitelist)) {
    return false;
  }
  let user = parts.join("@");
  if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
    user = user.toLowerCase();
    const username = user.split("+")[0];
    if (!isByteLength(username.replace(/\./g, ""), { min: 6, max: 30 })) {
      return false;
    }
    const user_parts2 = username.split(".");
    for (let i2 = 0;i2 < user_parts2.length; i2++) {
      if (!gmailUserPart.test(user_parts2[i2])) {
        return false;
      }
    }
  }
  if (options.ignore_max_length === false && (!isByteLength(user, { max: 64 }) || !isByteLength(domain, { max: 254 }))) {
    return false;
  }
  if (!isFQDN(domain, {
    require_tld: options.require_tld,
    ignore_max_length: options.ignore_max_length,
    allow_underscores: options.allow_underscores
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }
    if (!isIP(domain)) {
      if (!domain.startsWith("[") || !domain.endsWith("]")) {
        return false;
      }
      const noBracketdomain = domain.slice(1, -1);
      if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {
        return false;
      }
    }
  }
  if (options.blacklisted_chars) {
    if (user.search(new RegExp(`[${options.blacklisted_chars}]+`, "g")) !== -1)
      return false;
  }
  if (user[0] === '"' && user[user.length - 1] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }
  const pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  const user_parts = user.split(".");
  for (let i2 = 0;i2 < user_parts.length; i2++) {
    if (!pattern.test(user_parts[i2])) {
      return false;
    }
  }
  return true;
}
function isNullOrUndefined(value) {
  return value === null || value === undefined;
}
var locales3 = Object.keys(decimal);
var ibanRegexThroughCountryCode = {
  AD: /^(AD\d{2})\d{8}[A-Z0-9]{12}$/,
  AE: /^(AE\d{2})\d{19}$/,
  AL: /^(AL\d{2})\d{8}[A-Z0-9]{16}$/,
  AT: /^(AT\d{2})\d{16}$/,
  AZ: /^(AZ\d{2})[A-Z0-9]{4}\d{20}$/,
  BA: /^(BA\d{2})\d{16}$/,
  BE: /^(BE\d{2})\d{12}$/,
  BG: /^(BG\d{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
  BH: /^(BH\d{2})[A-Z]{4}[A-Z0-9]{14}$/,
  BR: /^(BR\d{2})\d{23}[A-Z][A-Z0-9]$/,
  BY: /^(BY\d{2})[A-Z0-9]{4}\d{20}$/,
  CH: /^(CH\d{2})\d{5}[A-Z0-9]{12}$/,
  CR: /^(CR\d{2})\d{18}$/,
  CY: /^(CY\d{2})\d{8}[A-Z0-9]{16}$/,
  CZ: /^(CZ\d{2})\d{20}$/,
  DE: /^(DE\d{2})\d{18}$/,
  DK: /^(DK\d{2})\d{14}$/,
  DO: /^(DO\d{2})[A-Z]{4}\d{20}$/,
  DZ: /^(DZ\d{24})$/,
  EE: /^(EE\d{2})\d{16}$/,
  EG: /^(EG\d{2})\d{25}$/,
  ES: /^(ES\d{2})\d{20}$/,
  FI: /^(FI\d{2})\d{14}$/,
  FO: /^(FO\d{2})\d{14}$/,
  FR: /^(FR\d{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  GB: /^(GB\d{2})[A-Z]{4}\d{14}$/,
  GE: /^(GE\d{2})[A-Z0-9]{2}\d{16}$/,
  GI: /^(GI\d{2})[A-Z]{4}[A-Z0-9]{15}$/,
  GL: /^(GL\d{2})\d{14}$/,
  GR: /^(GR\d{2})\d{7}[A-Z0-9]{16}$/,
  GT: /^(GT\d{2})[A-Z0-9]{24}$/,
  HR: /^(HR\d{2})\d{17}$/,
  HU: /^(HU\d{2})\d{24}$/,
  IE: /^(IE\d{2})[A-Z]{4}\d{14}$/,
  IL: /^(IL\d{2})\d{19}$/,
  IQ: /^(IQ\d{2})[A-Z]{4}\d{15}$/,
  IR: /^(IR\d{2})0\d{2}0\d{18}$/,
  IS: /^(IS\d{2})\d{22}$/,
  IT: /^(IT\d{2})[A-Z]\d{10}[A-Z0-9]{12}$/,
  JO: /^(JO\d{2})[A-Z]{4}\d{22}$/,
  KW: /^(KW\d{2})[A-Z]{4}[A-Z0-9]{22}$/,
  KZ: /^(KZ\d{2})\d{3}[A-Z0-9]{13}$/,
  LB: /^(LB\d{2})\d{4}[A-Z0-9]{20}$/,
  LC: /^(LC\d{2})[A-Z]{4}[A-Z0-9]{24}$/,
  LI: /^(LI\d{2})\d{5}[A-Z0-9]{12}$/,
  LT: /^(LT\d{2})\d{16}$/,
  LU: /^(LU\d{2})\d{3}[A-Z0-9]{13}$/,
  LV: /^(LV\d{2})[A-Z]{4}[A-Z0-9]{13}$/,
  MA: /^(MA\d{26})$/,
  MC: /^(MC\d{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  MD: /^(MD\d{2})[A-Z0-9]{20}$/,
  ME: /^(ME\d{2})\d{18}$/,
  MK: /^(MK\d{2})\d{3}[A-Z0-9]{10}\d{2}$/,
  MR: /^(MR\d{2})\d{23}$/,
  MT: /^(MT\d{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
  MU: /^(MU\d{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
  MZ: /^(MZ\d{2})\d{21}$/,
  NL: /^(NL\d{2})[A-Z]{4}\d{10}$/,
  NO: /^(NO\d{2})\d{11}$/,
  PK: /^(PK\d{2})[A-Z0-9]{4}\d{16}$/,
  PL: /^(PL\d{2})\d{24}$/,
  PS: /^(PS\d{2})[A-Z]{4}[A-Z0-9]{21}$/,
  PT: /^(PT\d{2})\d{21}$/,
  QA: /^(QA\d{2})[A-Z]{4}[A-Z0-9]{21}$/,
  RO: /^(RO\d{2})[A-Z]{4}[A-Z0-9]{16}$/,
  RS: /^(RS\d{2})\d{18}$/,
  SA: /^(SA\d{2})\d{2}[A-Z0-9]{18}$/,
  SC: /^(SC\d{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
  SE: /^(SE\d{2})\d{20}$/,
  SI: /^(SI\d{2})\d{15}$/,
  SK: /^(SK\d{2})\d{20}$/,
  SM: /^(SM\d{2})[A-Z]\d{10}[A-Z0-9]{12}$/,
  SV: /^(SV\d{2})[A-Z0-9]{4}\d{20}$/,
  TL: /^(TL\d{2})\d{19}$/,
  TN: /^(TN\d{2})\d{20}$/,
  TR: /^(TR\d{2})\d{5}[A-Z0-9]{17}$/,
  UA: /^(UA\d{2})\d{6}[A-Z0-9]{19}$/,
  VA: /^(VA\d{2})\d{18}$/,
  VG: /^(VG\d{2})[A-Z]{4}\d{16}$/,
  XK: /^(XK\d{2})\d{16}$/
};
var locales4 = Object.keys(ibanRegexThroughCountryCode);
var int = /^[-+]?(?:0|[1-9]\d*)$/;
var intLeadingZeroes = /^[-+]?\d+$/;
function isInt(str, options) {
  assertString(str);
  options = options || {};
  const regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;
  const num = Number.parseInt(str, 10);
  const minCheckPassed = !Object.prototype.hasOwnProperty.call(options, "min") || isNullOrUndefined(options.min) || num >= (options.min ?? 0);
  const maxCheckPassed = !Object.prototype.hasOwnProperty.call(options, "max") || isNullOrUndefined(options.max) || num <= (options.max ?? 0);
  const ltCheckPassed = !Object.prototype.hasOwnProperty.call(options, "lt") || isNullOrUndefined(options.lt) || num < (options.lt ?? 0);
  const gtCheckPassed = !Object.prototype.hasOwnProperty.call(options, "gt") || isNullOrUndefined(options.gt) || num > (options.gt ?? 0);
  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}
var validISO4217CurrencyCodes = new Set([
  "AED",
  "AFN",
  "ALL",
  "AMD",
  "ANG",
  "AOA",
  "ARS",
  "AUD",
  "AWG",
  "AZN",
  "BAM",
  "BBD",
  "BDT",
  "BGN",
  "BHD",
  "BIF",
  "BMD",
  "BND",
  "BOB",
  "BOV",
  "BRL",
  "BSD",
  "BTN",
  "BWP",
  "BYN",
  "BZD",
  "CAD",
  "CDF",
  "CHE",
  "CHF",
  "CHW",
  "CLF",
  "CLP",
  "CNY",
  "COP",
  "COU",
  "CRC",
  "CUP",
  "CVE",
  "CZK",
  "DJF",
  "DKK",
  "DOP",
  "DZD",
  "EGP",
  "ERN",
  "ETB",
  "EUR",
  "FJD",
  "FKP",
  "GBP",
  "GEL",
  "GHS",
  "GIP",
  "GMD",
  "GNF",
  "GTQ",
  "GYD",
  "HKD",
  "HNL",
  "HTG",
  "HUF",
  "IDR",
  "ILS",
  "INR",
  "IQD",
  "IRR",
  "ISK",
  "JMD",
  "JOD",
  "JPY",
  "KES",
  "KGS",
  "KHR",
  "KMF",
  "KPW",
  "KRW",
  "KWD",
  "KYD",
  "KZT",
  "LAK",
  "LBP",
  "LKR",
  "LRD",
  "LSL",
  "LYD",
  "MAD",
  "MDL",
  "MGA",
  "MKD",
  "MMK",
  "MNT",
  "MOP",
  "MRU",
  "MUR",
  "MVR",
  "MWK",
  "MXN",
  "MXV",
  "MYR",
  "MZN",
  "NAD",
  "NGN",
  "NIO",
  "NOK",
  "NPR",
  "NZD",
  "OMR",
  "PAB",
  "PEN",
  "PGK",
  "PHP",
  "PKR",
  "PLN",
  "PYG",
  "QAR",
  "RON",
  "RSD",
  "RUB",
  "RWF",
  "SAR",
  "SBD",
  "SCR",
  "SDG",
  "SEK",
  "SGD",
  "SHP",
  "SLE",
  "SLL",
  "SOS",
  "SRD",
  "SSP",
  "STN",
  "SVC",
  "SYP",
  "SZL",
  "THB",
  "TJS",
  "TMT",
  "TND",
  "TOP",
  "TRY",
  "TTD",
  "TWD",
  "TZS",
  "UAH",
  "UGX",
  "USD",
  "USN",
  "UYI",
  "UYU",
  "UYW",
  "UZS",
  "VED",
  "VES",
  "VND",
  "VUV",
  "WST",
  "XAF",
  "XAG",
  "XAU",
  "XBA",
  "XBB",
  "XBC",
  "XBD",
  "XCD",
  "XDR",
  "XOF",
  "XPD",
  "XPF",
  "XPT",
  "XSU",
  "XTS",
  "XUA",
  "XXX",
  "YER",
  "ZAR",
  "ZMW",
  "ZWL"
]);
var isISO6391Set = new Set([
  "aa",
  "ab",
  "ae",
  "af",
  "ak",
  "am",
  "an",
  "ar",
  "as",
  "av",
  "ay",
  "az",
  "az",
  "ba",
  "be",
  "bg",
  "bh",
  "bi",
  "bm",
  "bn",
  "bo",
  "br",
  "bs",
  "ca",
  "ce",
  "ch",
  "co",
  "cr",
  "cs",
  "cu",
  "cv",
  "cy",
  "da",
  "de",
  "dv",
  "dz",
  "ee",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fj",
  "fo",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "gn",
  "gu",
  "gv",
  "ha",
  "he",
  "hi",
  "ho",
  "hr",
  "ht",
  "hu",
  "hy",
  "hz",
  "ia",
  "id",
  "ie",
  "ig",
  "ii",
  "ik",
  "io",
  "is",
  "it",
  "iu",
  "ja",
  "jv",
  "ka",
  "kg",
  "ki",
  "kj",
  "kk",
  "kl",
  "km",
  "kn",
  "ko",
  "kr",
  "ks",
  "ku",
  "kv",
  "kw",
  "ky",
  "la",
  "lb",
  "lg",
  "li",
  "ln",
  "lo",
  "lt",
  "lu",
  "lv",
  "mg",
  "mh",
  "mi",
  "mk",
  "ml",
  "mn",
  "mr",
  "ms",
  "mt",
  "my",
  "na",
  "nb",
  "nd",
  "ne",
  "ng",
  "nl",
  "nn",
  "no",
  "nr",
  "nv",
  "ny",
  "oc",
  "oj",
  "om",
  "or",
  "os",
  "pa",
  "pi",
  "pl",
  "ps",
  "pt",
  "qu",
  "rm",
  "rn",
  "ro",
  "ru",
  "rw",
  "sa",
  "sc",
  "sd",
  "se",
  "sg",
  "si",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sq",
  "sr",
  "ss",
  "st",
  "su",
  "sv",
  "sw",
  "ta",
  "te",
  "tg",
  "th",
  "ti",
  "tk",
  "tl",
  "tn",
  "to",
  "tr",
  "ts",
  "tt",
  "tw",
  "ty",
  "ug",
  "uk",
  "ur",
  "uz",
  "ve",
  "vi",
  "vo",
  "wa",
  "wo",
  "xh",
  "yi",
  "yo",
  "za",
  "zh",
  "zu"
]);
var validISO15924Codes = new Set([
  "Adlm",
  "Afak",
  "Aghb",
  "Ahom",
  "Arab",
  "Aran",
  "Armi",
  "Armn",
  "Avst",
  "Bali",
  "Bamu",
  "Bass",
  "Batk",
  "Beng",
  "Bhks",
  "Blis",
  "Bopo",
  "Brah",
  "Brai",
  "Bugi",
  "Buhd",
  "Cakm",
  "Cans",
  "Cari",
  "Cham",
  "Cher",
  "Chis",
  "Chrs",
  "Cirt",
  "Copt",
  "Cpmn",
  "Cprt",
  "Cyrl",
  "Cyrs",
  "Deva",
  "Diak",
  "Dogr",
  "Dsrt",
  "Dupl",
  "Egyd",
  "Egyh",
  "Egyp",
  "Elba",
  "Elym",
  "Ethi",
  "Gara",
  "Geok",
  "Geor",
  "Glag",
  "Gong",
  "Gonm",
  "Goth",
  "Gran",
  "Grek",
  "Gujr",
  "Gukh",
  "Guru",
  "Hanb",
  "Hang",
  "Hani",
  "Hano",
  "Hans",
  "Hant",
  "Hatr",
  "Hebr",
  "Hira",
  "Hluw",
  "Hmng",
  "Hmnp",
  "Hrkt",
  "Hung",
  "Inds",
  "Ital",
  "Jamo",
  "Java",
  "Jpan",
  "Jurc",
  "Kali",
  "Kana",
  "Kawi",
  "Khar",
  "Khmr",
  "Khoj",
  "Kitl",
  "Kits",
  "Knda",
  "Kore",
  "Kpel",
  "Krai",
  "Kthi",
  "Lana",
  "Laoo",
  "Latf",
  "Latg",
  "Latn",
  "Leke",
  "Lepc",
  "Limb",
  "Lina",
  "Linb",
  "Lisu",
  "Loma",
  "Lyci",
  "Lydi",
  "Mahj",
  "Maka",
  "Mand",
  "Mani",
  "Marc",
  "Maya",
  "Medf",
  "Mend",
  "Merc",
  "Mero",
  "Mlym",
  "Modi",
  "Mong",
  "Moon",
  "Mroo",
  "Mtei",
  "Mult",
  "Mymr",
  "Nagm",
  "Nand",
  "Narb",
  "Nbat",
  "Newa",
  "Nkdb",
  "Nkgb",
  "Nkoo",
  "Nshu",
  "Ogam",
  "Olck",
  "Onao",
  "Orkh",
  "Orya",
  "Osge",
  "Osma",
  "Ougr",
  "Palm",
  "Pauc",
  "Pcun",
  "Pelm",
  "Perm",
  "Phag",
  "Phli",
  "Phlp",
  "Phlv",
  "Phnx",
  "Plrd",
  "Piqd",
  "Prti",
  "Psin",
  "Qaaa",
  "Qaab",
  "Qaac",
  "Qaad",
  "Qaae",
  "Qaaf",
  "Qaag",
  "Qaah",
  "Qaai",
  "Qaaj",
  "Qaak",
  "Qaal",
  "Qaam",
  "Qaan",
  "Qaao",
  "Qaap",
  "Qaaq",
  "Qaar",
  "Qaas",
  "Qaat",
  "Qaau",
  "Qaav",
  "Qaaw",
  "Qaax",
  "Qaay",
  "Qaaz",
  "Qaba",
  "Qabb",
  "Qabc",
  "Qabd",
  "Qabe",
  "Qabf",
  "Qabg",
  "Qabh",
  "Qabi",
  "Qabj",
  "Qabk",
  "Qabl",
  "Qabm",
  "Qabn",
  "Qabo",
  "Qabp",
  "Qabq",
  "Qabr",
  "Qabs",
  "Qabt",
  "Qabu",
  "Qabv",
  "Qabw",
  "Qabx",
  "Ranj",
  "Rjng",
  "Rohg",
  "Roro",
  "Runr",
  "Samr",
  "Sara",
  "Sarb",
  "Saur",
  "Sgnw",
  "Shaw",
  "Shrd",
  "Shui",
  "Sidd",
  "Sidt",
  "Sind",
  "Sinh",
  "Sogd",
  "Sogo",
  "Sora",
  "Soyo",
  "Sund",
  "Sunu",
  "Sylo",
  "Syrc",
  "Syre",
  "Syrj",
  "Syrn",
  "Tagb",
  "Takr",
  "Tale",
  "Talu",
  "Taml",
  "Tang",
  "Tavt",
  "Tayo",
  "Telu",
  "Teng",
  "Tfng",
  "Tglg",
  "Thaa",
  "Thai",
  "Tibt",
  "Tirh",
  "Tnsa",
  "Todr",
  "Tols",
  "Toto",
  "Tutg",
  "Ugar",
  "Vaii",
  "Visp",
  "Vith",
  "Wara",
  "Wcho",
  "Wole",
  "Xpeo",
  "Xsux",
  "Yezi",
  "Yiii",
  "Zanb",
  "Zinh",
  "Zmth",
  "Zsye",
  "Zsym",
  "Zxxx",
  "Zyyy",
  "Zzzz"
]);
var validISO31661Alpha3CountriesCodes = new Set([
  "AFG",
  "ALA",
  "ALB",
  "DZA",
  "ASM",
  "AND",
  "AGO",
  "AIA",
  "ATA",
  "ATG",
  "ARG",
  "ARM",
  "ABW",
  "AUS",
  "AUT",
  "AZE",
  "BHS",
  "BHR",
  "BGD",
  "BRB",
  "BLR",
  "BEL",
  "BLZ",
  "BEN",
  "BMU",
  "BTN",
  "BOL",
  "BES",
  "BIH",
  "BWA",
  "BVT",
  "BRA",
  "IOT",
  "BRN",
  "BGR",
  "BFA",
  "BDI",
  "KHM",
  "CMR",
  "CAN",
  "CPV",
  "CYM",
  "CAF",
  "TCD",
  "CHL",
  "CHN",
  "CXR",
  "CCK",
  "COL",
  "COM",
  "COG",
  "COD",
  "COK",
  "CRI",
  "CIV",
  "HRV",
  "CUB",
  "CUW",
  "CYP",
  "CZE",
  "DNK",
  "DJI",
  "DMA",
  "DOM",
  "ECU",
  "EGY",
  "SLV",
  "GNQ",
  "ERI",
  "EST",
  "ETH",
  "FLK",
  "FRO",
  "FJI",
  "FIN",
  "FRA",
  "GUF",
  "PYF",
  "ATF",
  "GAB",
  "GMB",
  "GEO",
  "DEU",
  "GHA",
  "GIB",
  "GRC",
  "GRL",
  "GRD",
  "GLP",
  "GUM",
  "GTM",
  "GGY",
  "GIN",
  "GNB",
  "GUY",
  "HTI",
  "HMD",
  "VAT",
  "HND",
  "HKG",
  "HUN",
  "ISL",
  "IND",
  "IDN",
  "IRN",
  "IRQ",
  "IRL",
  "IMN",
  "ISR",
  "ITA",
  "JAM",
  "JPN",
  "JEY",
  "JOR",
  "KAZ",
  "KEN",
  "KIR",
  "PRK",
  "KOR",
  "KWT",
  "KGZ",
  "LAO",
  "LVA",
  "LBN",
  "LSO",
  "LBR",
  "LBY",
  "LIE",
  "LTU",
  "LUX",
  "MAC",
  "MKD",
  "MDG",
  "MWI",
  "MYS",
  "MDV",
  "MLI",
  "MLT",
  "MHL",
  "MTQ",
  "MRT",
  "MUS",
  "MYT",
  "MEX",
  "FSM",
  "MDA",
  "MCO",
  "MNG",
  "MNE",
  "MSR",
  "MAR",
  "MOZ",
  "MMR",
  "NAM",
  "NRU",
  "NPL",
  "NLD",
  "NCL",
  "NZL",
  "NIC",
  "NER",
  "NGA",
  "NIU",
  "NFK",
  "MNP",
  "NOR",
  "OMN",
  "PAK",
  "PLW",
  "PSE",
  "PAN",
  "PNG",
  "PRY",
  "PER",
  "PHL",
  "PCN",
  "POL",
  "PRT",
  "PRI",
  "QAT",
  "REU",
  "ROU",
  "RUS",
  "RWA",
  "BLM",
  "SHN",
  "KNA",
  "LCA",
  "MAF",
  "SPM",
  "VCT",
  "WSM",
  "SMR",
  "STP",
  "SAU",
  "SEN",
  "SRB",
  "SYC",
  "SLE",
  "SGP",
  "SXM",
  "SVK",
  "SVN",
  "SLB",
  "SOM",
  "ZAF",
  "SGS",
  "SSD",
  "ESP",
  "LKA",
  "SDN",
  "SUR",
  "SJM",
  "SWZ",
  "SWE",
  "CHE",
  "SYR",
  "TWN",
  "TJK",
  "TZA",
  "THA",
  "TLS",
  "TGO",
  "TKL",
  "TON",
  "TTO",
  "TUN",
  "TUR",
  "TKM",
  "TCA",
  "TUV",
  "UGA",
  "UKR",
  "ARE",
  "GBR",
  "USA",
  "UMI",
  "URY",
  "UZB",
  "VUT",
  "VEN",
  "VNM",
  "VGB",
  "VIR",
  "WLF",
  "ESH",
  "YEM",
  "ZMB",
  "ZWE"
]);
var validISO31661NumericCountriesCodes = new Set([
  "004",
  "008",
  "010",
  "012",
  "016",
  "020",
  "024",
  "028",
  "031",
  "032",
  "036",
  "040",
  "044",
  "048",
  "050",
  "051",
  "052",
  "056",
  "060",
  "064",
  "068",
  "070",
  "072",
  "074",
  "076",
  "084",
  "086",
  "090",
  "092",
  "096",
  "100",
  "104",
  "108",
  "112",
  "116",
  "120",
  "124",
  "132",
  "136",
  "140",
  "144",
  "148",
  "152",
  "156",
  "158",
  "162",
  "166",
  "170",
  "174",
  "175",
  "178",
  "180",
  "184",
  "188",
  "191",
  "192",
  "196",
  "203",
  "204",
  "208",
  "212",
  "214",
  "218",
  "222",
  "226",
  "231",
  "232",
  "233",
  "234",
  "238",
  "239",
  "242",
  "246",
  "248",
  "250",
  "254",
  "258",
  "260",
  "262",
  "266",
  "268",
  "270",
  "275",
  "276",
  "288",
  "292",
  "296",
  "300",
  "304",
  "308",
  "312",
  "316",
  "320",
  "324",
  "328",
  "332",
  "334",
  "336",
  "340",
  "344",
  "348",
  "352",
  "356",
  "360",
  "364",
  "368",
  "372",
  "376",
  "380",
  "384",
  "388",
  "392",
  "398",
  "400",
  "404",
  "408",
  "410",
  "414",
  "417",
  "418",
  "422",
  "426",
  "428",
  "430",
  "434",
  "438",
  "440",
  "442",
  "446",
  "450",
  "454",
  "458",
  "462",
  "466",
  "470",
  "474",
  "478",
  "480",
  "484",
  "492",
  "496",
  "498",
  "499",
  "500",
  "504",
  "508",
  "512",
  "516",
  "520",
  "524",
  "528",
  "531",
  "533",
  "534",
  "535",
  "540",
  "548",
  "554",
  "558",
  "562",
  "566",
  "570",
  "574",
  "578",
  "580",
  "581",
  "583",
  "584",
  "585",
  "586",
  "591",
  "598",
  "600",
  "604",
  "608",
  "612",
  "616",
  "620",
  "624",
  "626",
  "630",
  "634",
  "638",
  "642",
  "643",
  "646",
  "652",
  "654",
  "659",
  "660",
  "662",
  "663",
  "666",
  "670",
  "674",
  "678",
  "682",
  "686",
  "688",
  "690",
  "694",
  "702",
  "703",
  "704",
  "705",
  "706",
  "710",
  "716",
  "724",
  "728",
  "729",
  "732",
  "740",
  "744",
  "748",
  "752",
  "756",
  "760",
  "762",
  "764",
  "768",
  "772",
  "776",
  "780",
  "784",
  "788",
  "792",
  "795",
  "796",
  "798",
  "800",
  "804",
  "807",
  "818",
  "826",
  "831",
  "832",
  "833",
  "834",
  "840",
  "850",
  "854",
  "858",
  "860",
  "862",
  "876",
  "882",
  "887",
  "894"
]);
var includes2 = (str, val) => str.includes(val);
var includesString_default = includes2;
var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
var language = `(([a-zA-Z]{2,3}(-${extlang})?)|([a-zA-Z]{5,8}))`;
var script = "([A-Za-z]{4})";
var region = "([A-Za-z]{2}|\\d{3})";
var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
var extension = `(${singleton}(-[A-Za-z0-9]{2,8})+)`;
var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
var grandfathered = `(${irregular}|${regular})`;
var delimiter = "(-|_)";
var langtag = `${language}(${delimiter}${script})?(${delimiter}${region})?(${delimiter}${variant})*(${delimiter}${extension})*(${delimiter}${privateuse})?`;
var languageTagRegex = new RegExp(`(^${privateuse}$)|(^${grandfathered}$)|(^${langtag}$)`);
var phones = {
  "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
  "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
  "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
  "ar-DZ": /^(\+?213|0)([567])\d{8}$/,
  "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
  "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
  "ar-IQ": /^(\+?964|0)?7\d{9}$/,
  "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
  "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
  "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
  "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
  "ar-OM": /^((\+|00)968)?([79][1-9])\d{6}$/,
  "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
  "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
  "ar-SD": /^((\+?249)|0)?(9[0-369]|1[012])\d{7}$/,
  "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
  "ar-TN": /^(\+?216)?[2459]\d{7}$/,
  "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
  "bs-BA": /^((((\+|00)3876)|06))((([0-356])\d{6})|(4\d{7}))$/,
  "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
  "bn-BD": /^(\+?880|0)1[13-9]\d{8}$/,
  "ca-AD": /^(\+376)?[346]\d{5}$/,
  "cs-CZ": /^(\+?420)? ?[1-9]\d{2} ?\d{3} ?\d{3}$/,
  "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
  "de-AT": /^(\+43|0)\d{4,16}$/,
  "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
  "de-LU": /^(\+352)?((6\d1)\d{6})$/,
  "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
  "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])\d)\d{7}$/,
  "el-CY": /^(\+?357?)?(9([94-7])\d{6})$/,
  "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[12]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
  "en-AU": /^(\+?61|0)4\d{8}$/,
  "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
  "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3]\d{5}$)|(59\d{5}$))/,
  "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
  "en-GB": /^(\+?44|0)7[1-9]\d{8}$/,
  "en-GG": /^(\+?44|0)1481\d{6}$/,
  "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|53|28|55|59)\d{7}$/,
  "en-GY": /^(\+592|0)6\d{6}$/,
  "en-HK": /^(\+?852[-\s]?)?[4-9]\d{3}[-\s]?\d{4}$/,
  "en-MO": /^(\+?853[-\s]?)?6\d{3}[-\s]?\d{4}$/,
  "en-IE": /^(\+?353|0)8[35-9]\d{7}$/,
  "en-IN": /^(\+?91|0)?[6-9]\d{9}$/,
  "en-JM": /^(\+?876)?\d{7}$/,
  "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
  "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
  "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
  "en-KI": /^((\+686|686)?)?( )?((6|7)([238])\d{6})$/,
  "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
  "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
  "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)\d{6}$/,
  "en-MU": /^(\+?230|0)?\d{8}$/,
  "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
  "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
  "en-NG": /^(\+?234|0)?[789]\d{9}$/,
  "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
  "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
  "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
  "en-PH": /^(09|\+639)\d{9}$/,
  "en-RW": /^(\+?250|0)?7\d{8}$/,
  "en-SG": /^(\+65)?[3689]\d{7}$/,
  "en-SL": /^(\+?232|0)\d{8}$/,
  "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
  "en-UG": /^(\+?256|0)?7\d{8}$/,
  "en-US": /^((\+1|1)?( |-)?)?(\([2-9]\d{2}\)|[2-9]\d{2})( |-)?([2-9]\d{2}( |-)?\d{4})$/,
  "en-ZA": /^(\+?27|0)\d{9}$/,
  "en-ZM": /^(\+?26)?0[79][567]\d{7}$/,
  "en-ZW": /^(\+263)\d{9}$/,
  "en-BW": /^(\+?267)?(7[1-8])\d{6}$/,
  "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
  "es-BO": /^(\+?591)?(6|7)\d{7}$/,
  "es-CO": /^(\+?57)?3(0([01245])|1\d|2[0-4]|5(0|1))\d{7}$/,
  "es-CL": /^(\+?56|0)[2-9]\d{8}$/,
  "es-CR": /^(\+506)?[2-8]\d{7}$/,
  "es-CU": /^(\+53|0053)?5\d{7}$/,
  "es-DO": /^(\+?1)?8[024]9\d{7}$/,
  "es-HN": /^(\+?504)?[9|832]\d{7}$/,
  "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
  "es-ES": /^(\+?34)?[6|7]\d{8}$/,
  "es-GT": /^(\+?502)?[2|67]\d{7}$/,
  "es-PE": /^(\+?51)?9\d{8}$/,
  "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
  "es-NI": /^(\+?505)\d{7,8}$/,
  "es-PA": /^(\+?507)\d{7,8}$/,
  "es-PY": /^(\+?595|0)9[6-9]\d{7}$/,
  "es-SV": /^(\+?503)?[67]\d{7}$/,
  "es-UY": /^(\+598|0)9[1-9]\d{6}$/,
  "es-VE": /^(\+?58)?(2|4)\d{9}$/,
  "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?(\d\s?){6,7}$/,
  "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
  "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
  "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "fr-BF": /^(\+226|0)[67]\d{7}$/,
  "fr-BJ": /^(\+229)\d{8}$/,
  "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
  "fr-CM": /^(\+?237)6\d{8}$/,
  "fr-FR": /^(\+?33|0)[67]\d{8}$/,
  "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
  "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
  "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
  "fr-PF": /^(\+?689)?8[789]\d{6}$/,
  "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
  "fr-WF": /^(\+681)?\d{6}$/,
  "he-IL": /^(\+972|0)([23489]|5[0-689]|77)[1-9]\d{6}$/,
  "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
  "id-ID": /^(\+?62|0)8(1[1-9]|2[1238]|3[1238]|5[1235-9]|7[78]|9[5-9]|8[1-9])([\s?|\d]{5,11})$/,
  "ir-IR": /^(\+98|0)?9\d{9}$/,
  "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
  "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6-9]0[ \-]?\d{4}[ \-]?\d{4}$/,
  "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
  "kk-KZ": /^(\+?7|8)?7\d{9}$/,
  "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "ko-KR": /^((\+?82)[ \-]?)?0?1([0|16-9])[ \-]?\d{3,4}[ \-]?\d{4}$/,
  "ky-KG": /^(\+996\s?)?(22\d|50\d|55\d|70\d|75\d|77\d|880|990|995|996|997|998)\s?\d{3}\s?\d{3}$/,
  "lt-LT": /^(\+370|8)\d{8}$/,
  "lv-LV": /^(\+?371)2\d{7}$/,
  "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
  "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
  "my-MM": /^(\+?959|09|9)(2[5-7]|3[12]|4[0-5]|6[6-9]|7[5-9]|9[6-9])\d{7}$/,
  "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
  "mz-MZ": /^(\+?258)?8[2-7]\d{7}$/,
  "nb-NO": /^(\+?47)?[49]\d{7}$/,
  "ne-NP": /^(\+?977)?9[78]\d{8}$/,
  "nl-BE": /^(\+?32|0)4\d{8}$/,
  "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6\d{8}$/,
  "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
  "nn-NO": /^(\+?47)?[49]\d{7}$/,
  "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
  "pt-BR": /^((\+?55 ?[1-9]{2} ?)|(\+?55 ?\([1-9]{2}\) ?)|(0[1-9]{2} ?)|(\([1-9]{2}\) ?)|([1-9]{2} ?))((\d{4}-?\d{4})|(9[1-9]\d{3}-?\d{4}))$/,
  "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
  "pt-AO": /^(\+?244)?9\d{8}$/,
  "ro-MD": /^(\+?373|0)((6([0126-9]))|(7([6-9])))\d{6}$/,
  "ro-RO": /^(\+?40|0)\s?7\d{2}([/\s.\-])?\d{3}([\s.\-])?\d{3}$/,
  "ru-RU": /^(\+?7|8)?9\d{9}$/,
  "si-LK": /^(?:0|94|\+94)?(7([0124-8])( |-)?)\d{7}$/,
  "sl-SI": /^(\+386\s?|0)(\d\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  "sk-SK": /^(\+?421)? ?[1-9]\d{2} ?\d{3} ?\d{3}$/,
  "so-SO": /^(\+?252|0)((6\d)\d{7}|(7[1-9])\d{7})$/,
  "sq-AL": /^(\+355|0)6[2-9]\d{7}$/,
  "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
  "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  "tg-TJ": /^(\+?992)?55\d{7}$/,
  "th-TH": /^(\+66|66|0)\d{9}$/,
  "tr-TR": /^(\+?90|0)?5\d{9}$/,
  "tk-TM": /^(\+993|993|8)\d{8}$/,
  "uk-UA": /^(\+?38)?0(50|6[36-8]|7[357]|9[1-9])\d{7}$/,
  "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
  "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9(\d)))(\d{7})$/,
  "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
  "zh-TW": /^(\+?886-?|0)?9\d{8}$/,
  "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
  "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
  "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
  "fa-AF": /^(\+93|0)?(2[0-8]|[3-5][0-4])(\d{7})$/,
  "mk-MK": /^(\+?389|0)?(2[2-9]\d{6}|(?:3[1-4]|4[2-8])\d{6}|500\d{5}|5[2-9]\d{6}|7\d[2-9]\d{5}|8[1-9]\d{6}|800\d{5}|8009\d{4})$/
};
phones["en-CA"] = phones["en-US"];
phones["fr-CA"] = phones["en-CA"];
phones["fr-BE"] = phones["nl-BE"];
phones["zh-HK"] = phones["en-HK"];
phones["zh-MO"] = phones["en-MO"];
phones["ga-IE"] = phones["en-IE"];
phones["fr-CH"] = phones["de-CH"];
phones["it-CH"] = phones["fr-CH"];
var locales5 = Object.keys(phones);
var decimal2 = {
  "en-US": ".",
  ar: "\u066B"
};
var dotDecimal2 = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal2 = [
  "bg-BG",
  "cs-CZ",
  "da-DK",
  "de-DE",
  "el-GR",
  "en-ZM",
  "eo",
  "es-ES",
  "fr-CA",
  "fr-FR",
  "id-ID",
  "it-IT",
  "ku-IQ",
  "hi-IN",
  "hu-HU",
  "nb-NO",
  "nn-NO",
  "nl-NL",
  "pl-PL",
  "pt-PT",
  "ru-RU",
  "kk-KZ",
  "si-LK",
  "sl-SI",
  "sr-RS@latin",
  "sr-RS",
  "sv-SE",
  "tr-TR",
  "uk-UA",
  "vi-VN"
];
for (let i2 = 0;i2 < dotDecimal2.length; i2++) {
  decimal2[dotDecimal2[i2]] = decimal2["en-US"];
}
for (let i2 = 0;i2 < commaDecimal2.length; i2++) {
  decimal2[commaDecimal2[i2]] = ",";
}
var englishLocales2 = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
for (let i2 = 0;i2 < englishLocales2.length; i2++) {
  const locale = `en-${englishLocales2[i2]}`;
  decimal2[locale] = decimal2["en-US"];
}
var arabicLocales2 = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
for (let i2 = 0;i2 < arabicLocales2.length; i2++) {
  const locale = `ar-${arabicLocales2[i2]}`;
  decimal2[locale] = decimal2.ar;
}
decimal2["fr-CA"] = decimal2["fr-FR"];
decimal2["pt-BR"] = decimal2["pt-PT"];
decimal2["pl-Pl"] = decimal2["pl-PL"];
var numericNoSymbols = /^\d+$/;
function isNumeric(str, options) {
  assertString(str);
  if (options?.no_symbols) {
    return numericNoSymbols.test(str);
  }
  const decimalChar = options?.locale ? decimal2[options.locale] || "." : ".";
  return new RegExp(`^[+-]?([0-9]*[${decimalChar}])?[0-9]+$`).test(str);
}
var passportRegexByCountryCode = {
  AM: /^[A-Z]{2}\d{7}$/,
  AR: /^[A-Z]{3}\d{6}$/,
  AT: /^[A-Z]\d{7}$/,
  AU: /^[A-Z]\d{7}$/,
  AZ: /^[A-Z]\d{8}$/,
  BE: /^[A-Z]{2}\d{6}$/,
  BG: /^\d{9}$/,
  BR: /^[A-Z]{2}\d{6}$/,
  BY: /^[A-Z]{2}\d{7}$/,
  CA: /^[A-Z]{2}\d{6}$|^[A-Z]\d{6}[A-Z]{2}$/,
  CH: /^[A-Z]\d{7}$/,
  CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
  CY: /^[A-Z](\d{6}|\d{8})$/,
  CZ: /^\d{8}$/,
  DE: /^[CFGHJ-NPRTV-Z0-9]{9}$/,
  DK: /^\d{9}$/,
  DZ: /^\d{9}$/,
  EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
  FI: /^[A-Z]{2}\d{7}$/,
  FR: /^\d{2}[A-Z]{2}\d{5}$/,
  GB: /^\d{9}$/,
  GR: /^[A-Z]{2}\d{7}$/,
  HR: /^\d{9}$/,
  HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
  IE: /^[A-Z0-9]{2}\d{7}$/,
  IN: /^[A-Z]-?\d{7}$/,
  ID: /^[A-C]\d{7}$/,
  IR: /^[A-Z]\d{8}$/,
  IS: /^(A)\d{7}$/,
  IT: /^[A-Z0-9]{2}\d{7}$/,
  JM: /^A\d{7}$/i,
  JP: /^[A-Z]{2}\d{7}$/,
  KR: /^[MS]\d{8}$/,
  KZ: /^[a-z]\d{7}$/i,
  LI: /^[a-z]\d{5}$/i,
  LT: /^[A-Z0-9]{8}$/,
  LU: /^[A-Z0-9]{8}$/,
  LV: /^[A-Z0-9]{2}\d{7}$/,
  LY: /^[A-Z0-9]{8}$/,
  MT: /^\d{7}$/,
  MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
  MY: /^[AHK]\d{8}$/,
  MX: /^\d{10,11}$/,
  NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
  NZ: /^(L([ADFH])|E(A|P)|N)\d{6}$/i,
  PH: /^[A-Z](\d{7}[A-Z]|\d{6})|[A-Z]{2}(\d{6}|\d{7})$/,
  PK: /^[A-Z]{2}\d{7}$/,
  PL: /^[A-Z]{2}\d{7}$/,
  PT: /^[A-Z]\d{6}$/,
  RO: /^\d{8,9}$/,
  RU: /^\d{9}$/,
  SE: /^\d{8}$/,
  SL: /^(P)[A-Z]\d{7}$/,
  SK: /^[0-9A-Z]\d{7}$/,
  TH: /^[A-Z]{1,2}\d{6,7}$/,
  TR: /^[A-Z]\d{8}$/,
  UA: /^[A-Z]{2}\d{6}$/,
  US: /^\d{9}$|^[A-Z]\d{8}$/,
  ZA: /^[TAMD]\d{8}$/
};
var locales6 = Object.keys(passportRegexByCountryCode);
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  AZ: /^AZ\d{4}$/,
  BA: /^([78]\d{4}$)/,
  BE: fourDigit,
  BG: fourDigit,
  BR: /^\d{5}-?\d{3}$/,
  BY: /^2[1-4]\d{4}$/,
  CA: /^[ABCEGHJ-NPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CN: /^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
  CO: /^(05|08|11|13|15|17|18|19|20|23|25|27|41|44|47|50|52|54|63|66|68|70|73|76|81|85|86|88|91|94|95|97|99)(\d{4})$/,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DO: fiveDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: /^(5[0-2]|[0-4]\d)\d{3}$/,
  FI: fiveDigit,
  FR: /^(?:(?:0[1-9]|[1-8]\d|9[0-5])\d{3}|97[1-46]\d{2})$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HT: /^HT\d{4}$/,
  HU: fourDigit,
  ID: fiveDigit,
  IE: /^(?!.*o)[A-Z]\d[\dw]\s\w{4}$/i,
  IL: /^(\d{5}|\d{7})$/,
  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9]\d{5})$/,
  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}-\d{4}$/,
  KE: fiveDigit,
  KR: /^(\d{5}|\d{6})$/,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT-\d{5}$/,
  LU: fourDigit,
  LV: /^LV-\d{4}$/,
  LK: fiveDigit,
  MG: threeDigit,
  MX: fiveDigit,
  MT: /^[A-Z]{3}\s?\d{4}$/i,
  MY: fiveDigit,
  NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
  NO: fourDigit,
  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/,
  NZ: fourDigit,
  PK: fiveDigit,
  PL: /^\d{2}-\d{3}$/,
  PR: /^00[679]\d{2}([ -]\d{4})?$/,
  PT: /^\d{4}-\d{3}$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^[1-9]\d{2}\s?\d{2}$/,
  SG: sixDigit,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TH: fiveDigit,
  TN: fourDigit,
  TW: /^\d{3}(\d{2,3})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales7 = Object.keys(patterns);
var dateFullYear = /\d{4}/;
var dateMonth = /(?:0[1-9]|1[0-2])/;
var dateMDay = /(?:[12]\d|0[1-9]|3[01])/;
var timeHour = /(?:[01]\d|2[0-3])/;
var timeMinute = /[0-5]\d/;
var timeSecond = /(?:[0-5]\d|60)/;
var timeSecFrac = /(?:\.\d+)?/;
var timeNumOffset = new RegExp(`[-+]${timeHour.source}:${timeMinute.source}`);
var timeOffset = new RegExp(`(?:z|${timeNumOffset.source})`, "i");
var partialTime = new RegExp(`${timeHour.source}:${timeMinute.source}:${timeSecond.source}${timeSecFrac.source}`);
var fullDate = new RegExp(`${dateFullYear.source}-${dateMonth.source}-${dateMDay.source}`);
var fullTime = new RegExp(`${partialTime.source}${timeOffset.source}`);
var rfc3339 = new RegExp(`^${fullDate.source} t${fullTime.source}$`, "i");
function multilineRegexp(parts, flags) {
  const regexpAsStringLiteral = parts.join("");
  return new RegExp(regexpAsStringLiteral, flags);
}
var semanticVersioningRegex = multilineRegexp([
  "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)",
  "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))",
  "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"
], "i");
function iso7064Check(str) {
  let checkvalue = 10;
  for (let i2 = 0;i2 < str.length - 1; i2++) {
    checkvalue = (Number.parseInt(str[i2], 10) + checkvalue) % 10 === 0 ? 9 : (Number.parseInt(str[i2], 10) + checkvalue) % 10 * 2 % 11;
  }
  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
  return checkvalue === Number.parseInt(str[10], 10);
}
function luhnCheck(str) {
  let checksum = 0;
  let second = false;
  for (let i2 = str.length - 1;i2 >= 0; i2--) {
    if (second) {
      const product = Number.parseInt(str[i2], 10) * 2;
      if (product > 9) {
        checksum += product.toString().split("").map((a2) => Number.parseInt(a2, 10)).reduce((a2, b2) => a2 + b2, 0);
      } else {
        checksum += product;
      }
    } else {
      checksum += Number.parseInt(str[i2], 10);
    }
    second = !second;
  }
  return checksum % 10 === 0;
}
function reverseMultiplyAndSum(digits, base) {
  let total = 0;
  for (let i2 = 0;i2 < digits.length; i2++) {
    total += digits[i2] * (base - i2);
  }
  return total;
}
function verhoeffCheck(str) {
  const d_table = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],
    [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],
    [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],
    [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],
    [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],
    [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],
    [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],
    [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],
    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  ];
  const p_table = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],
    [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],
    [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],
    [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],
    [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],
    [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],
    [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]
  ];
  const str_copy = str.split("").reverse().join("");
  let checksum = 0;
  for (let i2 = 0;i2 < str_copy.length; i2++) {
    checksum = d_table[checksum][p_table[i2 % 8][Number.parseInt(str_copy[i2], 10)]];
  }
  return checksum === 0;
}
function bgBgCheck(tin) {
  let century_year = tin.slice(0, 2);
  let month = Number.parseInt(tin.slice(2, 4), 10);
  if (month > 40) {
    month -= 40;
    century_year = `20${century_year}`;
  } else if (month > 20) {
    month -= 20;
    century_year = `18${century_year}`;
  } else {
    century_year = `19${century_year}`;
  }
  if (month < 10) {
    month = Number.parseInt(`0${month}`, 10);
  }
  const date = `${century_year}/${month}/${tin.slice(4, 6)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  const multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
  let checksum = 0;
  for (let i2 = 0;i2 < multip_lookup.length; i2++) {
    checksum += digits[i2] * multip_lookup[i2];
  }
  checksum = checksum % 11 === 10 ? 0 : checksum % 11;
  return checksum === digits[9];
}
function isCanadianSIN(input) {
  const digitsArray = input.split("");
  const even = digitsArray.filter((_3, idx) => idx % 2).map((i2) => Number(i2) * 2).join("").split("");
  const total = digitsArray.filter((_3, idx) => !(idx % 2)).concat(even).map((i2) => Number(i2)).reduce((acc, cur) => acc + cur);
  return total % 10 === 0;
}
function csCzCheck(tin) {
  tin = tin.replace(/\W/, "");
  let full_year = Number.parseInt(tin.slice(0, 2), 10);
  if (tin.length === 10) {
    if (full_year < 54) {
      full_year = Number.parseInt(`20${full_year}`, 10);
    } else {
      full_year = Number.parseInt(`19${full_year}`, 10);
    }
  } else {
    if (tin.slice(6) === "000") {
      return false;
    }
    if (full_year < 54) {
      full_year = Number.parseInt(`19${full_year}`, 10);
    } else {
      return false;
    }
  }
  if (full_year.toString().length === 3) {
    full_year = Number.parseInt([full_year.toString().slice(0, 2), "0", full_year.toString().slice(2)].join(""), 10);
  }
  let month = Number.parseInt(tin.slice(2, 4), 10);
  if (month > 50) {
    month -= 50;
  }
  if (month > 20) {
    if (full_year < 2004)
      return false;
    month -= 20;
  }
  if (month < 10) {
    month = Number.parseInt(`0${month}`, 10);
  }
  const date = `${full_year}/${month}/${tin.slice(4, 6)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  if (tin.length === 10) {
    if (Number.parseInt(tin, 10) % 11 !== 0) {
      const checkdigit = Number.parseInt(tin.slice(0, 9), 10) % 11;
      if (full_year < 1986 && checkdigit === 10) {
        if (Number.parseInt(tin.slice(9), 10) !== 0)
          return false;
      } else {
        return false;
      }
    }
  }
  return true;
}
function deAtCheck(tin) {
  return luhnCheck(tin);
}
function deDeCheck(tin) {
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  const occurrences = [];
  for (let i2 = 0;i2 < digits.length - 1; i2++) {
    occurrences.push("");
    for (let j3 = 0;j3 < digits.length - 1; j3++) {
      if (digits[i2] === digits[j3]) {
        occurrences[i2] += j3;
      }
    }
  }
  const filteredOccurrences = occurrences.filter((a2) => a2.length > 1);
  if (filteredOccurrences.length !== 2 && filteredOccurrences.length !== 3)
    return false;
  if (occurrences[0].length === 3) {
    const trip_locations = occurrences[0].split("").map((a2) => Number.parseInt(a2, 10));
    let recurrent = 0;
    for (let i2 = 0;i2 < trip_locations.length - 1; i2++) {
      if (trip_locations[i2] + 1 === trip_locations[i2 + 1]) {
        recurrent += 1;
      }
    }
    if (recurrent === 2) {
      return false;
    }
  }
  return iso7064Check(tin);
}
function dkDkCheck(tin) {
  tin = tin.replace(/\W/, "");
  let year = Number.parseInt(tin.slice(4, 6), 10);
  const century_digit = tin.slice(6, 7);
  switch (century_digit) {
    case "0":
    case "1":
    case "2":
    case "3":
      year = Number.parseInt(`19${year}`, 10);
      break;
    case "4":
    case "9":
      if (year < 37) {
        year = Number.parseInt(`20${year}`, 10);
      } else {
        year = Number.parseInt(`19${year}`, 10);
      }
      break;
    default:
      if (year < 37) {
        year = Number.parseInt(`20${year}`, 10);
      } else if (year > 58) {
        year = Number.parseInt(`18${year}`, 10);
      } else {
        return false;
      }
      break;
  }
  if (year.toString().length === 3) {
    year = Number.parseInt([year.toString().slice(0, 2), "0", year.toString().slice(2)].join(""), 10);
  }
  const date = `${year}/${tin.slice(2, 4)}/${tin.slice(0, 2)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  let checksum = 0;
  let weight = 4;
  for (let i2 = 0;i2 < 9; i2++) {
    checksum += digits[i2] * weight;
    weight -= 1;
    if (weight === 1) {
      weight = 7;
    }
  }
  checksum %= 11;
  if (checksum === 1)
    return false;
  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
}
function elCyCheck(tin) {
  const digits = tin.slice(0, 8).split("").map((a2) => Number.parseInt(a2, 10));
  let checksum = 0;
  for (let i2 = 1;i2 < digits.length; i2 += 2) {
    checksum += digits[i2];
  }
  for (let i2 = 0;i2 < digits.length; i2 += 2) {
    if (digits[i2] < 2) {
      checksum += 1 - digits[i2];
    } else {
      checksum += 2 * (digits[i2] - 2) + 5;
      if (digits[i2] > 4) {
        checksum += 2;
      }
    }
  }
  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
}
function elGrCheck(tin) {
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  let checksum = 0;
  for (let i2 = 0;i2 < 8; i2++) {
    checksum += digits[i2] * 2 ** (8 - i2);
  }
  return checksum % 11 % 10 === digits[8];
}
function enIeCheck(tin) {
  let checksum = reverseMultiplyAndSum(tin.split("").slice(0, 7).map((a2) => Number.parseInt(a2, 10)), 8);
  if (tin.length === 9 && tin[8] !== "W") {
    checksum += (tin[8].charCodeAt(0) - 64) * 9;
  }
  checksum %= 23;
  if (checksum === 0) {
    return tin[7].toUpperCase() === "W";
  }
  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
}
var enUsCampusPrefix = {
  andover: ["10", "12"],
  atlanta: ["60", "67"],
  austin: ["50", "53"],
  brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
  cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
  fresno: ["15", "24"],
  internet: ["20", "26", "27", "45", "46", "47"],
  kansas: ["40", "44"],
  memphis: ["94", "95"],
  ogden: ["80", "90"],
  philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
  sba: ["31"]
};
function enUsGetPrefixes() {
  const prefixes = [];
  for (const location in enUsCampusPrefix) {
    if (Object.prototype.hasOwnProperty.call(enUsCampusPrefix, location)) {
      prefixes.push(...enUsCampusPrefix[location]);
    }
  }
  return prefixes;
}
function enUsCheck(tin) {
  return enUsGetPrefixes().includes(tin.slice(0, 2));
}
function esArCheck(tin) {
  let accum = 0;
  const digits = tin.split("").map((d2) => Number.parseInt(d2, 10));
  const popped = digits.pop();
  if (!popped)
    return false;
  const digit = popped;
  for (let i2 = 0;i2 < digits.length; i2++) {
    accum += digits[9 - i2] * (2 + i2 % 6);
  }
  let verif = 11 - accum % 11;
  if (verif === 11) {
    verif = 0;
  } else if (verif === 10) {
    verif = 9;
  }
  return digit === verif;
}
function esEsCheck(tin) {
  const chars = tin.toUpperCase().split("");
  if (Number.isNaN(Number.parseInt(chars[0], 10)) && chars.length > 1) {
    let lead_replace = 0;
    switch (chars[0]) {
      case "Y":
        lead_replace = 1;
        break;
      case "Z":
        lead_replace = 2;
        break;
      default:
    }
    chars.splice(0, 1, lead_replace.toString());
  } else {
    while (chars.length < 9) {
      chars.unshift("0");
    }
  }
  const lookup = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
  const charsStr = chars.join("");
  const checksum = Number.parseInt(charsStr.slice(0, 8), 10) % 23;
  return charsStr[8] === lookup[checksum];
}
function etEeCheck(tin) {
  let full_year = tin.slice(1, 3);
  const century_digit = tin.slice(0, 1);
  switch (century_digit) {
    case "1":
    case "2":
      full_year = `18${full_year}`;
      break;
    case "3":
    case "4":
      full_year = `19${full_year}`;
      break;
    default:
      full_year = `20${full_year}`;
      break;
  }
  const date = `${full_year}/${tin.slice(3, 5)}/${tin.slice(5, 7)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  let checksum = 0;
  let weight = 1;
  for (let i2 = 0;i2 < 10; i2++) {
    checksum += digits[i2] * weight;
    weight += 1;
    if (weight === 10) {
      weight = 1;
    }
  }
  if (checksum % 11 === 10) {
    checksum = 0;
    weight = 3;
    for (let i2 = 0;i2 < 10; i2++) {
      checksum += digits[i2] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum % 11 === 10)
      return digits[10] === 0;
  }
  return checksum % 11 === digits[10];
}
function fiFiCheck(tin) {
  let full_year = tin.slice(4, 6);
  const century_symbol = tin.slice(6, 7);
  switch (century_symbol) {
    case "+":
      full_year = `18${full_year}`;
      break;
    case "-":
      full_year = `19${full_year}`;
      break;
    default:
      full_year = `20${full_year}`;
      break;
  }
  const date = `${full_year}/${tin.slice(2, 4)}/${tin.slice(0, 2)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  let checksum = Number.parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
  if (checksum < 10)
    return checksum === Number.parseInt(tin.slice(10), 10);
  checksum -= 10;
  const letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
  return letters_lookup[checksum] === tin.slice(10);
}
function frBeCheck(tin) {
  if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
    const date = `${tin.slice(0, 2)}/${tin.slice(2, 4)}/${tin.slice(4, 6)}`;
    if (!isDate2(date, "YY/MM/DD"))
      return false;
  }
  let checksum = 97 - Number.parseInt(tin.slice(0, 9), 10) % 97;
  const checkdigits = Number.parseInt(tin.slice(9, 11), 10);
  if (checksum !== checkdigits) {
    checksum = 97 - Number.parseInt(`2${tin.slice(0, 9)}`, 10) % 97;
    if (checksum !== checkdigits) {
      return false;
    }
  }
  return true;
}
function frFrCheck(tin) {
  tin = tin.replace(/\s/g, "");
  const checksum = Number.parseInt(tin.slice(0, 10), 10) % 511;
  const checkdigits = Number.parseInt(tin.slice(10, 13), 10);
  return checksum === checkdigits;
}
function frLuCheck(tin) {
  const date = `${tin.slice(0, 4)}/${tin.slice(4, 6)}/${tin.slice(6, 8)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  if (!luhnCheck(tin.slice(0, 12)))
    return false;
  return verhoeffCheck(`${tin.slice(0, 11)}${tin[12]}`);
}
function hrHrCheck(tin) {
  return iso7064Check(tin);
}
function huHuCheck(tin) {
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  let checksum = 8;
  for (let i2 = 1;i2 < 9; i2++) {
    checksum += digits[i2] * (i2 + 1);
  }
  return checksum % 11 === digits[9];
}
function itItNameCheck(name) {
  let vowelflag = false;
  let xflag = false;
  for (let i2 = 0;i2 < 3; i2++) {
    if (!vowelflag && /[AEIOU]/.test(name[i2])) {
      vowelflag = true;
    } else if (!xflag && vowelflag && name[i2] === "X") {
      xflag = true;
    } else if (i2 > 0) {
      if (vowelflag && !xflag) {
        if (!/[AEIOU]/.test(name[i2]))
          return false;
      }
      if (xflag) {
        if (!/X/.test(name[i2]))
          return false;
      }
    }
  }
  return true;
}
function itItCheck(tin) {
  const chars = tin.toUpperCase().split("");
  if (!itItNameCheck(chars.slice(0, 3).join("")))
    return false;
  if (!itItNameCheck(chars.slice(3, 6).join("")))
    return false;
  const number_locations = [6, 7, 9, 10, 12, 13, 14];
  const number_replace = {
    L: "0",
    M: "1",
    N: "2",
    P: "3",
    Q: "4",
    R: "5",
    S: "6",
    T: "7",
    U: "8",
    V: "9"
  };
  for (const i2 of number_locations) {
    if (chars[i2] in number_replace) {
      chars.splice(i2, 1, number_replace[chars[i2]]);
    }
  }
  const month_replace = {
    A: "01",
    B: "02",
    C: "03",
    D: "04",
    E: "05",
    H: "06",
    L: "07",
    M: "08",
    P: "09",
    R: "10",
    S: "11",
    T: "12"
  };
  const month = month_replace[chars[8]];
  let day = Number.parseInt(chars[9] + chars[10], 10);
  if (day > 40)
    day -= 40;
  if (day < 10)
    day = Number.parseInt(`0${day}`, 10);
  const date = `${chars[6]}${chars[7]}/${month}/${day}`;
  if (!isDate2(date, "YY/MM/DD"))
    return false;
  let checksum = 0;
  for (let i2 = 1;i2 < chars.length - 1; i2 += 2) {
    let char_to_int = Number.parseInt(chars[i2], 10);
    if (Number.isNaN(char_to_int)) {
      char_to_int = chars[i2].charCodeAt(0) - 65;
    }
    checksum += char_to_int;
  }
  const odd_convert = {
    A: 1,
    B: 0,
    C: 5,
    D: 7,
    E: 9,
    F: 13,
    G: 15,
    H: 17,
    I: 19,
    J: 21,
    K: 2,
    L: 4,
    M: 18,
    N: 20,
    O: 11,
    P: 3,
    Q: 6,
    R: 8,
    S: 12,
    T: 14,
    U: 16,
    V: 10,
    W: 22,
    X: 25,
    Y: 24,
    Z: 23,
    0: 1,
    1: 0
  };
  for (let i2 = 0;i2 < chars.length - 1; i2 += 2) {
    let char_to_int = 0;
    if (chars[i2] in odd_convert) {
      char_to_int = odd_convert[chars[i2]];
    } else {
      const multiplier = Number.parseInt(chars[i2], 10);
      char_to_int = 2 * multiplier + 1;
      if (multiplier > 4) {
        char_to_int += 2;
      }
    }
    checksum += char_to_int;
  }
  if (String.fromCharCode(65 + checksum % 26) !== chars[15])
    return false;
  return true;
}
function lvLvCheck(tin) {
  tin = tin.replace(/\W/, "");
  const day = tin.slice(0, 2);
  if (day !== "32") {
    const month = tin.slice(2, 4);
    if (month !== "00") {
      let full_year = tin.slice(4, 6);
      switch (tin[6]) {
        case "0":
          full_year = `18${full_year}`;
          break;
        case "1":
          full_year = `19${full_year}`;
          break;
        default:
          full_year = `20${full_year}`;
          break;
      }
      const date = `${full_year}/${tin.slice(2, 4)}/${day}`;
      if (!isDate2(date, "YYYY/MM/DD"))
        return false;
    }
    let checksum = 1101;
    const multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
    for (let i2 = 0;i2 < tin.length - 1; i2++) {
      checksum -= Number.parseInt(tin[i2], 10) * multip_lookup[i2];
    }
    return Number.parseInt(tin[10], 10) === checksum % 11;
  }
  return true;
}
function mtMtCheck(tin) {
  if (tin.length !== 9) {
    const chars = tin.toUpperCase().split("");
    while (chars.length < 8) {
      chars.unshift("0");
    }
    switch (tin[7]) {
      case "A":
      case "P":
        if (Number.parseInt(chars[6], 10) === 0)
          return false;
        break;
      default: {
        const first_part = Number.parseInt(chars.join("").slice(0, 5), 10);
        if (first_part > 32000)
          return false;
        const second_part = Number.parseInt(chars.join("").slice(5, 7), 10);
        if (first_part === second_part)
          return false;
      }
    }
  }
  return true;
}
function nlNlCheck(tin) {
  return reverseMultiplyAndSum(tin.split("").slice(0, 8).map((a2) => Number.parseInt(a2, 10)), 9) % 11 === Number.parseInt(tin[8], 10);
}
function plPlCheck(tin) {
  if (tin.length === 10) {
    const lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
    let checksum2 = 0;
    for (let i2 = 0;i2 < lookup.length; i2++) {
      checksum2 += Number.parseInt(tin[i2], 10) * lookup[i2];
    }
    checksum2 %= 11;
    if (checksum2 === 10)
      return false;
    return checksum2 === Number.parseInt(tin[9], 10);
  }
  let full_year = tin.slice(0, 2);
  let month = Number.parseInt(tin.slice(2, 4), 10);
  if (month > 80) {
    full_year = `18${full_year}`;
    month -= 80;
  } else if (month > 60) {
    full_year = `22${full_year}`;
    month -= 60;
  } else if (month > 40) {
    full_year = `21${full_year}`;
    month -= 40;
  } else if (month > 20) {
    full_year = `20${full_year}`;
    month -= 20;
  } else {
    full_year = `19${full_year}`;
  }
  if (month < 10) {
    month = Number.parseInt(`0${month}`, 10);
  }
  const date = `${full_year}/${month}/${tin.slice(4, 6)}`;
  if (!isDate2(date, "YYYY/MM/DD"))
    return false;
  let checksum = 0;
  let multiplier = 1;
  for (let i2 = 0;i2 < tin.length - 1; i2++) {
    checksum += Number.parseInt(tin[i2], 10) * multiplier % 10;
    multiplier += 2;
    if (multiplier > 10) {
      multiplier = 1;
    } else if (multiplier === 5) {
      multiplier += 2;
    }
  }
  checksum = 10 - checksum % 10;
  return checksum === Number.parseInt(tin[10], 10);
}
function ptBrCheck(tin) {
  if (tin.length === 11) {
    let sum2;
    let remainder;
    sum2 = 0;
    if (tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000") {
      return false;
    }
    for (let i2 = 1;i2 <= 9; i2++)
      sum2 += Number.parseInt(tin.substring(i2 - 1, i2), 10) * (11 - i2);
    remainder = sum2 * 10 % 11;
    if (remainder === 10)
      remainder = 0;
    if (remainder !== Number.parseInt(tin.substring(9, 10), 10))
      return false;
    sum2 = 0;
    for (let i2 = 1;i2 <= 10; i2++)
      sum2 += Number.parseInt(tin.substring(i2 - 1, i2), 10) * (12 - i2);
    remainder = sum2 * 10 % 11;
    if (remainder === 10)
      remainder = 0;
    if (remainder !== Number.parseInt(tin.substring(10, 11), 10))
      return false;
    return true;
  }
  if (tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999") {
    return false;
  }
  let length = tin.length - 2;
  let identifiers = tin.substring(0, length);
  const verificators = tin.substring(length);
  let sum = 0;
  let pos = length - 7;
  for (let i2 = length;i2 >= 1; i2--) {
    sum += Number.parseInt(identifiers.charAt(length - i2), 10) * pos;
    pos -= 1;
    if (pos < 2)
      pos = 9;
  }
  let result = sum % 11 < 2 ? 0 : 11 - sum % 11;
  if (result !== Number.parseInt(verificators.charAt(0), 10))
    return false;
  length += 1;
  identifiers = tin.substring(0, length);
  sum = 0;
  pos = length - 7;
  for (let i2 = length;i2 >= 1; i2--) {
    sum += Number.parseInt(identifiers.charAt(length - i2), 10) * pos;
    pos -= 1;
    if (pos < 2)
      pos = 9;
  }
  result = sum % 11 < 2 ? 0 : 11 - sum % 11;
  if (result !== Number.parseInt(verificators.charAt(1), 10))
    return false;
  return true;
}
function ptPtCheck(tin) {
  const checksum = 11 - reverseMultiplyAndSum(tin.split("").slice(0, 8).map((a2) => Number.parseInt(a2, 10)), 9) % 11;
  if (checksum > 9)
    return Number.parseInt(tin[8], 10) === 0;
  return checksum === Number.parseInt(tin[8], 10);
}
function roRoCheck(tin) {
  if (tin.slice(0, 4) !== "9000") {
    let full_year = tin.slice(1, 3);
    switch (tin[0]) {
      case "1":
      case "2":
        full_year = `19${full_year}`;
        break;
      case "3":
      case "4":
        full_year = `18${full_year}`;
        break;
      case "5":
      case "6":
        full_year = `20${full_year}`;
        break;
      default:
    }
    const date = `${full_year}/${tin.slice(3, 5)}/${tin.slice(5, 7)}`;
    if (date.length === 8) {
      if (!isDate2(date, "YY/MM/DD"))
        return false;
    } else if (!isDate2(date, "YYYY/MM/DD")) {
      return false;
    }
    const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
    const multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
    let checksum = 0;
    for (let i2 = 0;i2 < multipliers.length; i2++) {
      checksum += digits[i2] * multipliers[i2];
    }
    if (checksum % 11 === 10)
      return digits[12] === 1;
    return digits[12] === checksum % 11;
  }
  return true;
}
function skSkCheck(tin) {
  if (tin.length === 9) {
    tin = tin.replace(/\W/, "");
    if (tin.slice(6) === "000")
      return false;
    let full_year = Number.parseInt(tin.slice(0, 2), 10);
    if (full_year > 53)
      return false;
    if (full_year < 10) {
      full_year = Number.parseInt(`190${full_year}`, 10);
    } else {
      full_year = Number.parseInt(`19${full_year}`, 10);
    }
    let month = Number.parseInt(tin.slice(2, 4), 10);
    if (month > 50) {
      month -= 50;
    }
    if (month < 10) {
      month = Number.parseInt(`0${month}`, 10);
    }
    const date = `${full_year}/${month}/${tin.slice(4, 6)}`;
    if (!isDate2(date, "YYYY/MM/DD"))
      return false;
  }
  return true;
}
function slSiCheck(tin) {
  const checksum = 11 - reverseMultiplyAndSum(tin.split("").slice(0, 7).map((a2) => Number.parseInt(a2, 10)), 8) % 11;
  if (checksum === 10)
    return Number.parseInt(tin[7], 10) === 0;
  return checksum === Number.parseInt(tin[7], 10);
}
function svSeCheck(tin) {
  let tin_copy = tin.slice(0);
  if (tin.length > 11) {
    tin_copy = tin_copy.slice(2);
  }
  let full_year = "";
  const month = tin_copy.slice(2, 4);
  let day = Number.parseInt(tin_copy.slice(4, 6), 10);
  if (tin.length > 11) {
    full_year = tin.slice(0, 4);
  } else {
    full_year = tin.slice(0, 2);
    if (tin.length === 11 && day < 60) {
      const current_year = new Date().getFullYear();
      const current_century = Math.floor(current_year / 100);
      if (tin[6] === "-") {
        if (Number.parseInt(`${current_century}${full_year}`, 10) > current_year) {
          full_year = `${current_century - 1}${full_year}`;
        } else {
          full_year = `${current_century}${full_year}`;
        }
      } else {
        full_year = `${current_century - 1}${full_year}`;
        if (current_year - Number.parseInt(full_year, 10) < 100) {
          return false;
        }
      }
    }
  }
  if (day > 60) {
    day -= 60;
  }
  if (day < 10) {
    day = Number.parseInt(`0${day}`, 10);
  }
  const date = `${full_year}/${month}/${day}`;
  if (date.length === 8) {
    if (!isDate2(date, "YY/MM/DD"))
      return false;
  } else if (!isDate2(date, "YYYY/MM/DD")) {
    return false;
  }
  return luhnCheck(tin.replace(/\W/, ""));
}
function ukUaCheck(tin) {
  const digits = tin.split("").map((a2) => Number.parseInt(a2, 10));
  const multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
  let checksum = 0;
  for (let i2 = 0;i2 < multipliers.length; i2++) {
    checksum += digits[i2] * multipliers[i2];
  }
  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
}
var taxIdFormat = {
  "bg-BG": /^\d{10}$/,
  "cs-CZ": /^\d{6}\/?\d{3,4}$/,
  "de-AT": /^\d{9}$/,
  "de-DE": /^[1-9]\d{10}$/,
  "dk-DK": /^\d{6}-?\d{4}$/,
  "el-CY": /^[09]\d{7}[A-Z]$/,
  "el-GR": /^([0-47-9])\d{8}$/,
  "en-CA": /^\d{9}$/,
  "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[A-D ]$/i,
  "en-IE": /^\d{7}[A-W][A-IW]?$/i,
  "en-US": /^\d{2}[- ]?\d{7}$/,
  "es-AR": /(20|23|24|27|30|33|34)\d{9}/,
  "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
  "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9]\d|[1-6]\d{2}|70\d|710)\d$/,
  "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
  "fr-BE": /^\d{11}$/,
  "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
  "fr-LU": /^\d{13}$/,
  "hr-HR": /^\d{11}$/,
  "hu-HU": /^8\d{9}$/,
  "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
  "lv-LV": /^\d{6}-?\d{5}$/,
  "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
  "nl-NL": /^\d{9}$/,
  "pl-PL": /^\d{10,11}$/,
  "pt-BR": /^\d{11}$|^\d{14}$/,
  "pt-PT": /^\d{9}$/,
  "ro-RO": /^\d{13}$/,
  "sk-SK": /^\d{6}\/?\d{3,4}$/,
  "sl-SI": /^[1-9]\d{7}$/,
  "sv-SE": /^(\d{6}[-+]?\d{4}|(18|19|20)\d{6}[-+]?\d{4})$/,
  "uk-UA": /^\d{10}$/
};
taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
var taxIdCheck = {
  "bg-BG": bgBgCheck,
  "cs-CZ": csCzCheck,
  "de-AT": deAtCheck,
  "de-DE": deDeCheck,
  "dk-DK": dkDkCheck,
  "el-CY": elCyCheck,
  "el-GR": elGrCheck,
  "en-CA": isCanadianSIN,
  "en-IE": enIeCheck,
  "en-US": enUsCheck,
  "es-AR": esArCheck,
  "es-ES": esEsCheck,
  "et-EE": etEeCheck,
  "fi-FI": fiFiCheck,
  "fr-BE": frBeCheck,
  "fr-FR": frFrCheck,
  "fr-LU": frLuCheck,
  "hr-HR": hrHrCheck,
  "hu-HU": huHuCheck,
  "it-IT": itItCheck,
  "lv-LV": lvLvCheck,
  "mt-MT": mtMtCheck,
  "nl-NL": nlNlCheck,
  "pl-PL": plPlCheck,
  "pt-BR": ptBrCheck,
  "pt-PT": ptPtCheck,
  "ro-RO": roRoCheck,
  "sk-SK": skSkCheck,
  "sl-SI": slSiCheck,
  "sv-SE": svSeCheck,
  "uk-UA": ukUaCheck
};
taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
var allsymbols = /[-\\/!@#$%^&*()+=[\]]+/g;
var sanitizeRegexes = {
  "de-AT": allsymbols,
  "de-DE": /[/\\]/g,
  "fr-BE": allsymbols
};
sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
var default_url_options = {
  protocols: ["http", "https", "ftp"],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_port: false,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false,
  allow_fragments: true,
  allow_query_components: true,
  validate_length: true,
  max_allowed_length: 2084
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::(\d+))?$/;
function isURL(url, options) {
  assertString(url);
  if (!url || /[\s<>]/.test(url)) {
    return false;
  }
  if (url.indexOf("mailto:") === 0) {
    return false;
  }
  options = merge(options, default_url_options);
  if (options?.validate_length && url.length > (options?.max_allowed_length ?? default_url_options.max_allowed_length)) {
    return false;
  }
  if (!options.allow_fragments && includesString_default(url, "#")) {
    return false;
  }
  if (!options.allow_query_components && (includesString_default(url, "?") || includesString_default(url, "&"))) {
    return false;
  }
  let protocol, auth, host, port, port_str, ipv6;
  let split = [];
  split = url.split("#");
  url = split.shift() ?? "";
  split = url.split("?");
  url = split.shift() ?? "";
  split = url.split("://");
  if (split.length > 1) {
    protocol = split.shift()?.toLowerCase() ?? "";
    if (options?.require_valid_protocol && !(options?.protocols ?? default_url_options.protocols).includes(protocol)) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.slice(0, 2) === "//") {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }
    split[0] = url.slice(2);
  }
  url = split.join("://");
  if (url === "") {
    return false;
  }
  split = url.split("/");
  const hostname = split.shift() ?? "";
  if (hostname === "" && !options.require_host) {
    return true;
  }
  split = hostname.split("@");
  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }
    if (split[0] === "") {
      return false;
    }
    auth = split.shift() ?? "";
    if (auth.includes(":") && auth.split(":").length > 2) {
      return false;
    }
    const [user, password] = auth.split(":");
    if (user === "" && password === "") {
      return false;
    }
  }
  port_str = null;
  ipv6 = null;
  const ipv6_match = hostname.match(wrapped_ipv6);
  if (ipv6_match) {
    host = "";
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(":");
    host = split.shift();
    if (split.length) {
      port_str = split.join(":");
    }
  }
  if (port_str !== null && port_str.length > 0) {
    port = Number.parseInt(port_str, 10);
    if (!/^\d+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  } else if (options.require_port) {
    return false;
  }
  if (options.host_whitelist) {
    return checkHost(host ?? "", options.host_whitelist);
  }
  if (host === "" && !options.require_host) {
    return true;
  }
  if (!isIP(host ?? "") && !isFQDN(host ?? "", options) && (!ipv6 || !isIP(ipv6, { version: 6 }))) {
    return false;
  }
  host = (host || ipv6) ?? "";
  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }
  return true;
}
class MessageProvider {
  messages = new Map;
  constructor(messages) {
    if (messages) {
      this.setMessages(messages);
    }
  }
  getMessage(ruleName, ruleMessage, field, params) {
    let message;
    if (field) {
      const fieldSpecificKey = `${field}.${ruleName}`;
      message = this.messages.get(fieldSpecificKey);
    }
    if (!message) {
      message = this.messages.get(ruleName);
    }
    if (!message && ruleMessage) {
      message = ruleMessage;
    }
    if (message && params) {
      message = this.replaceParams(message, params);
    }
    if (!message) {
      message = this.getDefaultMessage(ruleName);
    }
    return message;
  }
  setMessage(rule, message, field) {
    const key = field ? `${field}.${rule}` : rule;
    this.messages.set(key, message);
  }
  setMessages(messages) {
    Object.entries(messages).forEach(([key, message]) => {
      this.messages.set(key, message);
    });
  }
  getDefaultMessage(rule) {
    const defaults3 = {
      required: "This field is required",
      string: "Must be a string",
      number: "Must be a number",
      integer: "Must be an integer",
      float: "Must be a float",
      boolean: "Must be a boolean",
      array: "Must be an array",
      object: "Must be an object",
      email: "Must be a valid email address",
      url: "Must be a valid URL",
      min: "Must be at least {min}",
      max: "Must be at most {max}",
      length: "Must be exactly {length}",
      matches: "Must match pattern {pattern}",
      equals: "Must be equal to {value}",
      alphanumeric: "Must only contain letters and numbers",
      alpha: "Must only contain letters",
      numeric: "Must only contain numbers",
      positive: "Must be positive",
      negative: "Must be negative",
      date: "Must be a valid date",
      datetime: "Must be a valid datetime",
      time: "Must be a valid time",
      timestamp: "Must be a valid timestamp",
      unix: "Must be a valid Unix timestamp",
      json: "Must be valid JSON",
      enum: "Must be one of: {values}",
      custom: "Validation failed"
    };
    return defaults3[rule] || "Validation failed";
  }
  replaceParams(message, params) {
    return message.replace(/\{([^}]+)\}/g, (_3, key) => {
      const value = key.split(".").reduce((obj, k2) => obj?.[k2], params);
      return value !== undefined ? String(value) : `{${key}}`;
    });
  }
}
var _globalMessagesProvider = new MessageProvider;
function getCustomMessages() {
  return _globalMessagesProvider;
}
var SCHEMA_NAME = Symbol("schema_name");
var INPUT_TYPE = Symbol("input_type");
var OUTPUT_TYPE = Symbol("output_type");
var COMPUTED_TYPE = Symbol("computed_type");
var PARSE = Symbol("parse");

class BaseValidator {
  rules = [];
  isRequired = false;
  fieldName = "value";
  isPartOfShape = false;
  name = "base";
  required() {
    this.isRequired = true;
    return this;
  }
  optional() {
    this.isRequired = false;
    return this;
  }
  setIsPartOfShape(isPartOfShape) {
    this.isPartOfShape = isPartOfShape;
    return this;
  }
  setFieldName(fieldName) {
    this.fieldName = fieldName;
    return this;
  }
  addRule(rule) {
    this.rules.push(rule);
    return this;
  }
  validate(value) {
    const errors2 = [];
    if (!this.isRequired && (value === undefined || value === null || value === "")) {
      return this.isPartOfShape ? { valid: true, errors: {} } : { valid: true, errors: [] };
    }
    if (this.isRequired && (value === undefined || value === null || value === "")) {
      const messagesProvider = getCustomMessages();
      const message = messagesProvider.getMessage("required", undefined, this.fieldName);
      const error = { message };
      return this.isPartOfShape ? { valid: false, errors: { [this.fieldName]: [error] } } : { valid: false, errors: [error] };
    }
    for (const rule of this.rules) {
      if (!rule.test(value)) {
        const messagesProvider = getCustomMessages();
        const message = messagesProvider.getMessage(rule.name, rule.message, this.fieldName, rule.params);
        errors2.push({ message });
      }
    }
    if (this.isPartOfShape && errors2.length > 0) {
      const errorMap = {
        [this.fieldName]: errors2
      };
      return { valid: false, errors: errorMap };
    }
    return {
      valid: errors2.length === 0,
      errors: errors2
    };
  }
  getRules() {
    return this.rules;
  }
  test(value) {
    return this.validate(value).valid;
  }
}

class ArrayValidator extends BaseValidator {
  name = "array";
  constructor() {
    super();
    this.addRule({
      name: "array",
      test: (value) => Array.isArray(value),
      message: "Must be an array"
    });
  }
  min(length) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (value === null || value === undefined)
          return false;
        return value.length >= length;
      },
      message: "Must have at least {length} items",
      params: { length }
    });
  }
  max(length) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (value === null || value === undefined)
          return false;
        return value.length <= length;
      },
      message: "Must have at most {length} items",
      params: { length }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (value === null || value === undefined)
          return false;
        return value.length === length;
      },
      message: "Must have exactly {length} items",
      params: { length }
    });
  }
  each(validator2) {
    return this.addRule({
      name: "each",
      test: (value) => {
        if (value === null || value === undefined)
          return false;
        return value.every((item) => validator2.test(item));
      },
      message: "Each item in array is invalid"
    });
  }
  unique() {
    return this.addRule({
      name: "unique",
      test: (value) => {
        if (value === null || value === undefined)
          return false;
        const seen = new Set;
        return value.every((item) => {
          const key = JSON.stringify(item);
          if (seen.has(key))
            return false;
          seen.add(key);
          return true;
        });
      },
      message: "Array must contain unique values"
    });
  }
}
function array2() {
  return new ArrayValidator;
}

class BigintValidator extends BaseValidator {
  name = "bigint";
  constructor() {
    super();
    this.addRule({
      name: "bigint",
      test: (value) => typeof value === "bigint",
      message: "Must be a bigint"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => value >= min,
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => value <= max,
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => value.toString().length === length,
      message: "Must be {length} digits",
      params: { length }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => value > 0n,
      message: "Must be a positive bigint"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => value < 0n,
      message: "Must be a negative bigint"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => value % divisor === 0n,
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function bigint() {
  return new BigintValidator;
}

class BinaryValidator extends BaseValidator {
  name = "binary";
  constructor() {
    super();
    this.addRule({
      name: "binary",
      test: (value) => {
        if (typeof value !== "string") {
          return false;
        }
        return value.length > 0;
      },
      message: "Must be a valid binary string"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => value.length >= min,
      message: "Must be at least {min} characters",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => value.length <= max,
      message: "Must be at most {max} characters",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => value.length === length,
      message: "Must be exactly {length} characters",
      params: { length }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function binary2() {
  return new BinaryValidator;
}

class BlobValidator extends BaseValidator {
  name = "blob";
  constructor() {
    super();
    this.addRule({
      name: "blob",
      test: (value) => {
        if (typeof value !== "string") {
          return false;
        }
        return value.length > 0;
      },
      message: "Must be a valid blob string"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => value.length >= min,
      message: "Must be at least {min} characters",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => value.length <= max,
      message: "Must be at most {max} characters",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => value.length === length,
      message: "Must be exactly {length} characters",
      params: { length }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function blob2() {
  return new BlobValidator;
}

class BooleanValidator extends BaseValidator {
  name = "boolean";
  constructor() {
    super();
    this.addRule({
      name: "boolean",
      test: (value) => typeof value === "boolean",
      message: "Must be a boolean"
    });
  }
  isTrue() {
    return this.addRule({
      name: "isTrue",
      test: (value) => value === true,
      message: "Must be true"
    });
  }
  isFalse() {
    return this.addRule({
      name: "isFalse",
      test: (value) => value === false,
      message: "Must be false"
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function boolean2() {
  return new BooleanValidator;
}

class CustomValidator extends BaseValidator {
  name = "custom";
  constructor(validationFn, message) {
    super();
    this.addRule({
      name: "custom",
      test: (value) => value === undefined || value === null || validationFn(value),
      message
    });
  }
}
function custom2(validationFn, message) {
  return new CustomValidator(validationFn, message);
}

class DateValidator extends BaseValidator {
  name = "date";
  constructor() {
    super();
    this.addRule({
      name: "date",
      test: (value) => value instanceof Date && !Number.isNaN(value.getTime()),
      message: "Must be a valid date"
    });
  }
}
function date2() {
  return new DateValidator;
}

class DatetimeValidator extends BaseValidator {
  name = "datetime";
  constructor() {
    super();
    this.addRule({
      name: "datetime",
      test: (value) => {
        if (!(value instanceof Date)) {
          return false;
        }
        const year = value.getFullYear();
        if (year < 1000 || year > 9999) {
          return false;
        }
        return !Number.isNaN(value.getTime());
      },
      message: "Must be a valid datetime between 1000-01-01 and 9999-12-31"
    });
  }
}
function datetime() {
  return new DatetimeValidator;
}

class NumberValidator extends BaseValidator {
  name = "number";
  constructor() {
    super();
    this.addRule({
      name: "number",
      test: (value) => typeof value === "number" && !Number.isNaN(value),
      message: "Must be a number"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value.toString().length === length;
      },
      message: "Must be exactly {length} digits",
      params: { length }
    });
  }
  integer(options2) {
    return this.addRule({
      name: "integer",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isInt(String(value), options2 ?? {});
      },
      message: "Must be an integer"
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive number"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative number"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isDivisibleBy(String(value), divisor);
      },
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function number2() {
  return new NumberValidator;
}

class DecimalValidator extends NumberValidator {
  name = "decimal";
  constructor() {
    super();
    this.addRule({
      name: "decimal",
      test: (value) => {
        if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) {
          return false;
        }
        return true;
      },
      message: "Must be a valid decimal number"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value.toString().length === length;
      },
      message: "Must be exactly {length} digits",
      params: { length }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive number"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative number"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isDivisibleBy(String(value), divisor);
      },
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function decimal4() {
  return new DecimalValidator;
}

class DoubleValidator extends NumberValidator {
  name = "float";
  constructor() {
    super();
    this.rules = this.rules.filter((rule) => rule.name !== "number");
    this.addRule({
      name: "double",
      test: (value) => {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return false;
        }
        return true;
      },
      message: "Must be a valid float number"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value.toString().length === length;
      },
      message: "Must be exactly {length} digits",
      params: { length }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive number"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative number"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isDivisibleBy(String(value), divisor);
      },
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function float2() {
  return new DoubleValidator;
}

class EnumValidator extends BaseValidator {
  name = "enum";
  allowedValues;
  constructor(allowedValues) {
    super();
    this.allowedValues = allowedValues;
    this.addRule({
      name: "enum",
      test: (value) => this.allowedValues.includes(value),
      message: "Must be one of: {values}",
      params: { values: this.allowedValues.join(", ") }
    });
  }
  getAllowedValues() {
    return this.allowedValues;
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function enum_(allowedValues) {
  return new EnumValidator(allowedValues);
}

class FloatValidator extends NumberValidator {
  name = "float";
  constructor() {
    super();
    this.rules = this.rules.filter((rule) => rule.name !== "number");
    this.addRule({
      name: "float",
      test: (value) => {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return false;
        }
        return true;
      },
      message: "Must be a valid float number"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value.toString().length === length;
      },
      message: "Must be exactly {length} digits",
      params: { length }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive number"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative number"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isDivisibleBy(String(value), divisor);
      },
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function float3() {
  return new FloatValidator;
}

class IntegerValidator extends NumberValidator {
  name = "integer";
  constructor() {
    super();
    this.rules = this.rules.filter((rule) => rule.name !== "number");
    this.addRule({
      name: "integer",
      test: (value) => {
        if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) {
          return false;
        }
        return Number.isInteger(value);
      },
      message: "Must be a valid integer"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive integer"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative integer"
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function integer2() {
  return new IntegerValidator;
}

class JsonValidator extends BaseValidator {
  name = "json";
  constructor() {
    super();
    this.addRule({
      name: "json",
      test: (value) => {
        if (typeof value !== "string") {
          return false;
        }
        if (value.trim() === "") {
          return false;
        }
        try {
          const parsed = JSON.parse(value);
          if (typeof parsed === "string" || typeof parsed === "number" || typeof parsed === "boolean" || parsed === null) {
            return false;
          }
          return true;
        } catch {
          return false;
        }
      },
      message: "Must be a valid JSON string"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length >= min;
      },
      message: "Must be at least {min} characters",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length <= max;
      },
      message: "Must be at most {max} characters",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length === length;
      },
      message: "Must be exactly {length} characters",
      params: { length }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function json2() {
  return new JsonValidator;
}

class ObjectValidator extends BaseValidator {
  name = "object";
  schema = {};
  strictMode = false;
  constructor(schema2) {
    super();
    this.addRule({
      name: "object",
      test: (value) => typeof value === "object" && value !== null && !Array.isArray(value),
      message: "Must be an object"
    });
    if (schema2) {
      this.shape(schema2);
    }
  }
  shape(schema2) {
    this.schema = Object.entries(schema2).reduce((acc, [key, validator2]) => {
      if (validator2 instanceof BaseValidator) {
        acc[key] = validator2.setIsPartOfShape(true).setFieldName(key);
      } else {
        acc[key] = validator2;
      }
      return acc;
    }, {});
    return this.addRule({
      name: "shape",
      test: (value) => {
        if (value === null || value === undefined)
          return true;
        if (this.strictMode) {
          const schemaKeys = new Set(Object.keys(schema2));
          const valueKeys = Object.keys(value);
          return valueKeys.every((key) => schemaKeys.has(key));
        }
        return true;
      },
      message: "Invalid object shape"
    });
  }
  strict(strict = true) {
    this.strictMode = strict;
    return this;
  }
  custom(validationFn, message) {
    return this.addRule({
      name: "custom",
      test: (value) => value === undefined || value === null || validationFn(value),
      message
    });
  }
  validate(value) {
    const result = super.validate(value);
    if (!result.valid)
      return result;
    if (Object.keys(this.schema).length > 0 && value !== null && value !== undefined) {
      const errors2 = {};
      let hasErrors = false;
      for (const [key, validator2] of Object.entries(this.schema)) {
        const fieldValue = value[key];
        const fieldResult = validator2.validate(fieldValue);
        if (!fieldResult.valid) {
          hasErrors = true;
          if (validator2 instanceof ObjectValidator) {
            Object.entries(fieldResult.errors).forEach(([errorKey, errorValue]) => {
              errors2[`${key}.${errorKey}`] = errorValue;
            });
          } else {
            const fieldErrors = Object.values(fieldResult.errors)[0];
            if (fieldErrors) {
              errors2[key] = fieldErrors;
            }
          }
        }
      }
      if (hasErrors) {
        return {
          valid: false,
          errors: errors2
        };
      }
    }
    return result;
  }
}
function object2(schema2) {
  return new ObjectValidator(schema2);
}

class PasswordValidator extends BaseValidator {
  name = "password";
  constructor() {
    super();
    this.addRule({
      name: "string",
      test: (value) => typeof value === "string",
      message: "Must be a string"
    });
  }
  matches(confirmPassword) {
    return this.addRule({
      name: "matches",
      test: (value) => value === confirmPassword,
      message: "Passwords must match"
    });
  }
  min(length = 8) {
    return this.addRule({
      name: "minLength",
      test: (value) => value.length >= length,
      message: "Password must be at least {length} characters long",
      params: { length }
    });
  }
  max(length = 128) {
    return this.addRule({
      name: "maxLength",
      test: (value) => value.length <= length,
      message: "Password must be at most {length} characters long",
      params: { length }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => value.length === length,
      message: "Must be exactly {length} characters long",
      params: { length }
    });
  }
  hasUppercase() {
    return this.addRule({
      name: "hasUppercase",
      test: (value) => /[A-Z]/.test(value),
      message: "Password must contain at least one uppercase letter"
    });
  }
  hasLowercase() {
    return this.addRule({
      name: "hasLowercase",
      test: (value) => /[a-z]/.test(value),
      message: "Password must contain at least one lowercase letter"
    });
  }
  hasNumbers() {
    return this.addRule({
      name: "hasNumbers",
      test: (value) => /[0-9]/.test(value),
      message: "Password must contain at least one number"
    });
  }
  hasSpecialCharacters() {
    return this.addRule({
      name: "hasSpecialCharacters",
      test: (value) => /[!@#$%^&*(),.?":{}|<>]/.test(value),
      message: "Password must contain at least one special character"
    });
  }
  alphanumeric() {
    return this.addRule({
      name: "alphanumeric",
      test: (value) => /(?=.*[a-z])(?=.*\d)/i.test(value),
      message: "Password must contain both letters and numbers"
    });
  }
}
function password2() {
  return new PasswordValidator;
}

class SmallintValidator extends NumberValidator {
  name = "smallint";
  constructor() {
    super();
    this.rules = this.rules.filter((rule) => rule.name !== "number");
    this.addRule({
      name: "number",
      test: (value) => {
        if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) {
          return false;
        }
        if (!Number.isInteger(value)) {
          return false;
        }
        return value >= -32768 && value <= 32767;
      },
      message: "Must be a valid smallint (-32,768 to 32,767)"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value >= min;
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value <= max;
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value.toString().length === length;
      },
      message: "Must be exactly {length} digits",
      params: { length }
    });
  }
  positive() {
    return this.addRule({
      name: "positive",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value > 0;
      },
      message: "Must be a positive number"
    });
  }
  negative() {
    return this.addRule({
      name: "negative",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return value < 0;
      },
      message: "Must be a negative number"
    });
  }
  divisibleBy(divisor) {
    return this.addRule({
      name: "divisibleBy",
      test: (value) => {
        if (typeof value !== "number")
          return false;
        return isDivisibleBy(String(value), divisor);
      },
      message: "Must be divisible by {divisor}",
      params: { divisor }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function smallint2() {
  return new SmallintValidator;
}

class StringValidator extends BaseValidator {
  name = "string";
  constructor() {
    super();
    this.addRule({
      name: "string",
      test: (value) => typeof value === "string",
      message: "Must be a string"
    });
  }
  min(length) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length >= length;
      },
      message: "Must be at least {min} characters long",
      params: { min: length }
    });
  }
  max(length) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length <= length;
      },
      message: "Must be at most {max} characters long",
      params: { max: length }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length === length;
      },
      message: "Must be exactly {length} characters long",
      params: { length }
    });
  }
  email(options2) {
    return this.addRule({
      name: "email",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return isEmail(value, options2);
      },
      message: "Must be a valid email address"
    });
  }
  url(options2) {
    return this.addRule({
      name: "url",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return isURL(value, options2);
      },
      message: "Must be a valid URL"
    });
  }
  matches(pattern) {
    return this.addRule({
      name: "matches",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return pattern.test(value);
      },
      message: "Must match pattern {pattern}",
      params: { pattern: pattern.toString() }
    });
  }
  equals(param) {
    return this.addRule({
      name: "equals",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value === param;
      },
      message: "Must be equal to {param}",
      params: { param }
    });
  }
  alphanumeric() {
    return this.addRule({
      name: "alphanumeric",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return isAlphanumeric(value);
      },
      message: "Must only contain letters and numbers"
    });
  }
  alpha() {
    return this.addRule({
      name: "alpha",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return isAlpha(value);
      },
      message: "Must only contain letters"
    });
  }
  numeric() {
    return this.addRule({
      name: "numeric",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return isNumeric(value);
      },
      message: "Must only contain numbers"
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function string2() {
  return new StringValidator;
}

class TextValidator extends StringValidator {
  name = "text";
  constructor() {
    super();
    this.addRule({
      name: "text",
      test: (value) => typeof value === "string",
      message: "Must be a text"
    });
  }
}
function text() {
  return new TextValidator;
}

class TimeValidator extends BaseValidator {
  name = "time";
  constructor() {
    super();
    this.addRule({
      name: "time",
      test: (value) => {
        if (typeof value !== "string") {
          return false;
        }
        if (value.trim() === "" || value === undefined || value === null) {
          return false;
        }
        const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
        return timeRegex.test(value);
      },
      message: "Must be a valid time format"
    });
  }
  min(min) {
    return this.addRule({
      name: "min",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        const timeToMinutes = (time2) => {
          const [hours, minutes] = time2.split(":").map(Number);
          return hours * 60 + minutes;
        };
        return timeToMinutes(value) >= timeToMinutes(min);
      },
      message: "Must be at least {min}",
      params: { min }
    });
  }
  max(max) {
    return this.addRule({
      name: "max",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        const timeToMinutes = (time2) => {
          const [hours, minutes] = time2.split(":").map(Number);
          return hours * 60 + minutes;
        };
        return timeToMinutes(value) <= timeToMinutes(max);
      },
      message: "Must be at most {max}",
      params: { max }
    });
  }
  length(length) {
    return this.addRule({
      name: "length",
      test: (value) => {
        if (typeof value !== "string")
          return false;
        return value.length === length;
      },
      message: "Must be exactly {length} characters",
      params: { length }
    });
  }
  custom(fn, message) {
    return this.addRule({
      name: "custom",
      test: fn,
      message
    });
  }
}
function time2() {
  return new TimeValidator;
}

class TimestampValidator extends BaseValidator {
  name = "timestamp";
  constructor() {
    super();
    this.addRule({
      name: "timestamp",
      test: (value) => {
        const num = Number(value);
        if (Number.isNaN(num)) {
          return false;
        }
        const minTimestamp = 0;
        const maxTimestamp = 2147483647;
        if (num < minTimestamp || num > maxTimestamp) {
          return false;
        }
        if (typeof value === "string") {
          const timestampStr = value.toString();
          const length = timestampStr.length;
          if (length < 10 || length > 13) {
            return false;
          }
        }
        return true;
      },
      message: "Must be a valid timestamp between 1970-01-01 and 2038-01-19"
    });
  }
}
function timestamp2() {
  return new TimestampValidator;
}

class TimestampTzValidator extends BaseValidator {
  name = "timestampTz";
  constructor() {
    super();
    this.addRule({
      name: "timestampTz",
      test: (value) => {
        if (value === null || value === undefined) {
          return false;
        }
        if (typeof value === "number") {
          const num = Number(value);
          if (Number.isNaN(num)) {
            return false;
          }
          const minTimestamp = 0;
          const maxTimestamp = 2147483647;
          return num >= minTimestamp && num <= maxTimestamp;
        }
        if (typeof value === "string") {
          const str = value.trim();
          const num = Number(str);
          if (!Number.isNaN(num)) {
            const minTimestamp = 0;
            const maxTimestamp = 2147483647;
            if (str.length < 10 || str.length > 13) {
              return false;
            }
            return num >= minTimestamp && num <= maxTimestamp;
          }
          const isoWithTzRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{2}:\d{2})$/;
          if (isoWithTzRegex.test(str)) {
            const date3 = new Date(str);
            return !Number.isNaN(date3.getTime());
          }
          const rfc3339WithTzRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{2}:\d{2})$/;
          if (rfc3339WithTzRegex.test(str)) {
            const date3 = new Date(str);
            return !Number.isNaN(date3.getTime());
          }
          const otherTzFormats = [
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} UTC$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} GMT$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} [A-Z]{3,4}$/
          ];
          for (const regex of otherTzFormats) {
            if (regex.test(str)) {
              const date3 = new Date(str);
              return !Number.isNaN(date3.getTime());
            }
          }
          return false;
        }
        return false;
      },
      message: "Must be a valid timestamp with timezone information (ISO 8601, RFC 3339, or Unix timestamp)"
    });
  }
}
function timestampTz() {
  return new TimestampTzValidator;
}

class UnixValidator extends BaseValidator {
  name = "unix";
  constructor() {
    super();
    this.addRule({
      name: "unix",
      test: (value) => {
        const num = Number(value);
        if (Number.isNaN(num)) {
          return false;
        }
        if (typeof value === "string") {
          const timestampStr = value.toString();
          const length = timestampStr.length;
          if (length < 10 || length > 13) {
            return false;
          }
        }
        return num >= 0;
      },
      message: "Must be a valid Unix timestamp (10-13 digits)"
    });
  }
}
function unix() {
  return new UnixValidator;
}
var v3 = {
  string: string2,
  text,
  number: number2,
  bigint,
  array: array2,
  boolean: boolean2,
  enum: enum_,
  date: date2,
  datetime,
  object: object2,
  custom: custom2,
  timestamp: timestamp2,
  timestampTz,
  unix,
  password: password2,
  float: float3,
  double: float2,
  decimal: decimal4,
  time: time2,
  smallint: smallint2,
  integer: integer2,
  json: json2,
  blob: blob2,
  binary: binary2
};

// ../validation/src/schema.ts
var schema2 = v3;
// ../../../../node_modules/@vinejs/vine/build/chunk-MLKGABMK.js
var __defProp = Object.defineProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};

// ../../../../node_modules/dlv/dist/dlv.es.js
function dlv_es_default(t2, e2, l2, n2, r2) {
  for (e2 = e2.split ? e2.split(".") : e2, n2 = 0;n2 < e2.length; n2++)
    t2 = t2 ? t2[e2[n2]] : r2;
  return t2 === r2 ? l2 : t2;
}

// ../../../../node_modules/@vinejs/vine/build/chunk-YXNUTVGP.js
var import_isIP = __toESM(require_isIP(), 1);
var import_isJWT = __toESM(require_isJWT(), 1);
var import_isURL = __toESM(require_isURL(), 1);
var import_isSlug = __toESM(require_isSlug(), 1);
var import_isIBAN = __toESM(require_isIBAN(), 1);
var import_isUUID = __toESM(require_isUUID(), 1);
var import_isAscii = __toESM(require_isAscii(), 1);
var import_isEmail = __toESM(require_isEmail(), 1);
var import_isAlpha = __toESM(require_isAlpha(), 1);
var import_isLatLong = __toESM(require_isLatLong(), 1);
var import_isDecimal = __toESM(require_isDecimal(), 1);
var import_isHexColor = __toESM(require_isHexColor(), 1);
var import_isCreditCard = __toESM(require_isCreditCard(), 1);
var import_isAlphanumeric = __toESM(require_isAlphanumeric(), 1);
var import_isPassportNumber = __toESM(require_isPassportNumber(), 1);
var import_isPostalCode = __toESM(require_isPostalCode(), 1);
var import_isMobilePhone = __toESM(require_isMobilePhone(), 1);
var import_isMobilePhone2 = __toESM(require_isMobilePhone(), 1);
var import_isPostalCode2 = __toESM(require_isPostalCode(), 1);
var SimpleMessagesProvider = class {
  #messages;
  #fields;
  constructor(messages, fields) {
    this.#messages = messages;
    this.#fields = fields || {};
  }
  #interpolate(message, data) {
    if (!message.includes("{{")) {
      return message;
    }
    return message.replace(/(\\)?{{(.*?)}}/g, (_3, __, key) => {
      const tokens = key.trim().split(".");
      let output = data;
      while (tokens.length) {
        if (output === null || typeof output !== "object") {
          return;
        }
        const token = tokens.shift();
        output = Object.hasOwn(output, token) ? output[token] : undefined;
      }
      return output;
    });
  }
  getMessage(rawMessage, rule, field, args) {
    const fieldName = this.#fields[field.name] || field.name;
    const fieldMessage = this.#messages[`${field.getFieldPath()}.${rule}`];
    if (fieldMessage) {
      return this.#interpolate(fieldMessage, {
        field: fieldName,
        ...args
      });
    }
    const wildcardMessage = this.#messages[`${field.wildCardPath}.${rule}`];
    if (wildcardMessage) {
      return this.#interpolate(wildcardMessage, {
        field: fieldName,
        ...args
      });
    }
    const ruleMessage = this.#messages[rule];
    if (ruleMessage) {
      return this.#interpolate(ruleMessage, {
        field: fieldName,
        ...args
      });
    }
    return this.#interpolate(rawMessage, {
      field: fieldName,
      ...args
    });
  }
  toJSON() {
    return {
      messages: this.#messages,
      fields: this.#fields
    };
  }
};
var main_exports = {};
__export(main_exports, {
  E_VALIDATION_ERROR: () => E_VALIDATION_ERROR
});
var ValidationError = class extends Error {
  constructor(messages, options) {
    super("Validation failure", options);
    this.messages = messages;
    const ErrorConstructor = this.constructor;
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, ErrorConstructor);
    }
  }
  status = 422;
  code = "E_VALIDATION_ERROR";
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var E_VALIDATION_ERROR = ValidationError;
var SimpleErrorReporter = class {
  hasErrors = false;
  errors = [];
  report(message, rule, field, meta) {
    const error = {
      message,
      rule,
      field: field.getFieldPath()
    };
    if (meta) {
      error.meta = meta;
    }
    if (field.isArrayMember) {
      error.index = field.name;
    }
    this.hasErrors = true;
    this.errors.push(error);
  }
  createError() {
    return new E_VALIDATION_ERROR(this.errors);
  }
};
var BOOLEAN_POSITIVES = ["1", 1, "true", true, "on"];
var BOOLEAN_NEGATIVES = ["0", 0, "false", false];
var ULID = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var helpers = {
  exists(value) {
    return value !== null && value !== undefined;
  },
  isMissing(value) {
    return !this.exists(value);
  },
  isTrue(value) {
    return BOOLEAN_POSITIVES.includes(value);
  },
  isFalse(value) {
    return BOOLEAN_NEGATIVES.includes(value);
  },
  isString(value) {
    return typeof value === "string";
  },
  isObject(value) {
    return !!(value && typeof value === "object" && !Array.isArray(value));
  },
  hasKeys(value, keys) {
    for (let key of keys) {
      if (key in value === false) {
        return false;
      }
    }
    return true;
  },
  isArray(value) {
    return Array.isArray(value);
  },
  isNumeric(value) {
    return !Number.isNaN(Number(value));
  },
  asNumber(value) {
    return value === null ? Number.NaN : Number(value);
  },
  asBoolean(value) {
    if (this.isTrue(value)) {
      return true;
    }
    if (this.isFalse(value)) {
      return false;
    }
    return null;
  },
  isEmail: import_isEmail.default.default,
  isURL: import_isURL.default.default,
  isAlpha: import_isAlpha.default.default,
  isAlphaNumeric: import_isAlphanumeric.default.default,
  isIP: import_isIP.default.default,
  isUUID: import_isUUID.default.default,
  isAscii: import_isAscii.default.default,
  isCreditCard: import_isCreditCard.default.default,
  isIBAN: import_isIBAN.default.default,
  isJWT: import_isJWT.default.default,
  isLatLong: import_isLatLong.default.default,
  isMobilePhone: import_isMobilePhone.default.default,
  isPassportNumber: import_isPassportNumber.default.default,
  isPostalCode: import_isPostalCode.default.default,
  isSlug: import_isSlug.default.default,
  isDecimal: import_isDecimal.default.default,
  mobileLocales: import_isMobilePhone2.locales,
  postalCountryCodes: import_isPostalCode2.locales,
  passportCountryCodes: [
    "AM",
    "AR",
    "AT",
    "AU",
    "AZ",
    "BE",
    "BG",
    "BR",
    "BY",
    "CA",
    "CH",
    "CY",
    "CZ",
    "DE",
    "DK",
    "DZ",
    "ES",
    "FI",
    "FR",
    "GB",
    "GR",
    "HR",
    "HU",
    "IE",
    "IN",
    "ID",
    "IR",
    "IS",
    "IT",
    "JM",
    "JP",
    "KR",
    "KZ",
    "LI",
    "LT",
    "LU",
    "LV",
    "LY",
    "MT",
    "MZ",
    "MY",
    "MX",
    "NL",
    "NZ",
    "PH",
    "PK",
    "PL",
    "PT",
    "RO",
    "RU",
    "SE",
    "SL",
    "SK",
    "TH",
    "TR",
    "UA",
    "US"
  ],
  isULID(value) {
    if (typeof value !== "string") {
      return false;
    }
    if (value[0] > "7") {
      return false;
    }
    return ULID.test(value);
  },
  isHexColor: (value) => {
    if (!value.startsWith("#")) {
      return false;
    }
    return import_isHexColor.default.default(value);
  },
  isActiveURL: async (url) => {
    const { resolve4, resolve6 } = await import("dns/promises");
    try {
      const { hostname } = new URL(url);
      const v6Addresses = await resolve6(hostname);
      if (v6Addresses.length) {
        return true;
      } else {
        const v4Addresses = await resolve4(hostname);
        return v4Addresses.length > 0;
      }
    } catch {
      return false;
    }
  },
  isDistinct: (dataSet, fields) => {
    const uniqueItems = /* @__PURE__ */ new Set;
    if (!fields) {
      for (let item of dataSet) {
        if (helpers.exists(item)) {
          if (uniqueItems.has(item)) {
            return false;
          } else {
            uniqueItems.add(item);
          }
        }
      }
      return true;
    }
    const fieldsList = Array.isArray(fields) ? fields : [fields];
    for (let item of dataSet) {
      if (helpers.isObject(item) && helpers.hasKeys(item, fieldsList)) {
        const element = fieldsList.map((field) => item[field]).join("_");
        if (uniqueItems.has(element)) {
          return false;
        } else {
          uniqueItems.add(element);
        }
      }
    }
    return true;
  },
  getNestedValue(key, field) {
    if (key.indexOf(".") > -1) {
      return dlv_es_default(field.data, key);
    }
    return field.parent[key];
  }
};

// ../../../../node_modules/@vinejs/vine/build/chunk-M2DOTJGC.js
var messages = {
  required: "The {{ field }} field must be defined",
  string: "The {{ field }} field must be a string",
  email: "The {{ field }} field must be a valid email address",
  mobile: "The {{ field }} field must be a valid mobile phone number",
  creditCard: "The {{ field }} field must be a valid {{ providersList }} card number",
  passport: "The {{ field }} field must be a valid passport number",
  postalCode: "The {{ field }} field must be a valid postal code",
  regex: "The {{ field }} field format is invalid",
  ascii: "The {{ field }} field must only contain ASCII characters",
  iban: "The {{ field }} field must be a valid IBAN number",
  jwt: "The {{ field }} field must be a valid JWT token",
  coordinates: "The {{ field }} field must contain latitude and longitude coordinates",
  url: "The {{ field }} field must be a valid URL",
  activeUrl: "The {{ field }} field must be a valid URL",
  alpha: "The {{ field }} field must contain only letters",
  alphaNumeric: "The {{ field }} field must contain only letters and numbers",
  minLength: "The {{ field }} field must have at least {{ min }} characters",
  maxLength: "The {{ field }} field must not be greater than {{ max }} characters",
  fixedLength: "The {{ field }} field must be {{ size }} characters long",
  confirmed: "The {{ field }} field and {{ otherField }} field must be the same",
  endsWith: "The {{ field }} field must end with {{ substring }}",
  startsWith: "The {{ field }} field must start with {{ substring }}",
  sameAs: "The {{ field }} field and {{ otherField }} field must be the same",
  notSameAs: "The {{ field }} field and {{ otherField }} field must be different",
  in: "The selected {{ field }} is invalid",
  notIn: "The selected {{ field }} is invalid",
  ipAddress: "The {{ field }} field must be a valid IP address",
  uuid: "The {{ field }} field must be a valid UUID",
  ulid: "The {{ field }} field must be a valid ULID",
  hexCode: "The {{ field }} field must be a valid hex color code",
  boolean: "The value must be a boolean",
  number: "The {{ field }} field must be a number",
  "number.in": "The selected {{ field }} is not in {{ values }}",
  min: "The {{ field }} field must be at least {{ min }}",
  max: "The {{ field }} field must not be greater than {{ max }}",
  range: "The {{ field }} field must be between {{ min }} and {{ max }}",
  positive: "The {{ field }} field must be positive",
  negative: "The {{ field }} field must be negative",
  decimal: "The {{ field }} field must have {{ digits }} decimal places",
  withoutDecimals: "The {{ field }} field must be an integer",
  accepted: "The {{ field }} field must be accepted",
  enum: "The selected {{ field }} is invalid",
  literal: "The {{ field }} field must be {{ expectedValue }}",
  object: "The {{ field }} field must be an object",
  array: "The {{ field }} field must be an array",
  "array.minLength": "The {{ field }} field must have at least {{ min }} items",
  "array.maxLength": "The {{ field }} field must not have more than {{ max }} items",
  "array.fixedLength": "The {{ field }} field must contain {{ size }} items",
  notEmpty: "The {{ field }} field must not be empty",
  distinct: "The {{ field }} field has duplicate values",
  record: "The {{ field }} field must be an object",
  "record.minLength": "The {{ field }} field must have at least {{ min }} items",
  "record.maxLength": "The {{ field }} field must not have more than {{ max }} items",
  "record.fixedLength": "The {{ field }} field must contain {{ size }} items",
  tuple: "The {{ field }} field must be an array",
  union: "Invalid value provided for {{ field }} field",
  unionGroup: "Invalid value provided for {{ field }} field",
  unionOfTypes: "Invalid value provided for {{ field }} field",
  date: "The {{ field }} field must be a datetime value",
  "date.equals": "The {{ field }} field must be a date equal to {{ expectedValue }}",
  "date.after": "The {{ field }} field must be a date after {{ expectedValue }}",
  "date.before": "The {{ field }} field must be a date before {{ expectedValue }}",
  "date.afterOrEqual": "The {{ field }} field must be a date after or equal to {{ expectedValue }}",
  "date.beforeOrEqual": "The {{ field }} field must be a date before or equal to {{ expectedValue }}",
  "date.sameAs": "The {{ field }} field and {{ otherField }} field must be the same",
  "date.notSameAs": "The {{ field }} field and {{ otherField }} field must be different",
  "date.afterField": "The {{ field }} field must be a date after {{ otherField }}",
  "date.afterOrSameAs": "The {{ field }} field must be a date after or same as {{ otherField }}",
  "date.beforeField": "The {{ field }} field must be a date before {{ otherField }}",
  "date.beforeOrSameAs": "The {{ field }} field must be a date before or same as {{ otherField }}",
  "date.weekend": "The {{ field }} field is not a weekend",
  "date.weekday": "The {{ field }} field is not a weekday"
};
var fields = {
  "": "data"
};

// ../../../../node_modules/@poppinss/macroable/build/index.js
var Macroable = class {
  static macro(name, value) {
    this.prototype[name] = value;
  }
  static getter(name, accumulator, singleton2 = false) {
    Object.defineProperty(this.prototype, name, {
      get() {
        const value = accumulator.call(this);
        if (singleton2) {
          Object.defineProperty(this, name, {
            configurable: false,
            enumerable: false,
            value,
            writable: false
          });
        }
        return value;
      },
      configurable: true,
      enumerable: false
    });
  }
};

// ../../../../node_modules/camelcase/index.js
var UPPERCASE = /[\p{Lu}]/u;
var LOWERCASE = /[\p{Ll}]/u;
var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[_.\- ]+/;
var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
var preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  let isLastLastCharPreserved = false;
  for (let index = 0;index < string.length; index++) {
    const character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, index) + "-" + string.slice(index);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      index++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {
      string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (match) => toLowerCase(match));
};
var postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_3, identifier) => toUpperCase(identifier));
};
function camelCase2(input, options) {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = {
    pascalCase: false,
    preserveConsecutiveUppercase: false,
    ...options
  };
  if (Array.isArray(input)) {
    input = input.map((x3) => x3.trim()).filter((x3) => x3.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
  const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  if (input.length === 1) {
    if (SEPARATORS.test(input)) {
      return "";
    }
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
}

// ../../../../node_modules/@vinejs/vine/build/chunk-FED7BU4B.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var import_isSameOrAfter = __toESM(require_isSameOrAfter(), 1);
var import_isSameOrBefore = __toESM(require_isSameOrBefore(), 1);
var import_customParseFormat = __toESM(require_customParseFormat(), 1);

// ../../../../node_modules/normalize-url/index.js
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
var supportedProtocols = new Set([
  "https:",
  "http:",
  "file:"
]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let { type, data, hash } = match.groups;
  const mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [
    ...attributes
  ];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (;; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname).replace(/\\/g, "%5C");
    } catch {}
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {}
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// ../../../../node_modules/@vinejs/vine/build/chunk-FED7BU4B.js
var import_escape = __toESM(require_escape(), 1);
var import_normalizeEmail = __toESM(require_normalizeEmail(), 1);

// ../../../../node_modules/@vinejs/compiler/build/chunk-K5F7IOJS.js
var CompilerBuffer = class _CompilerBuffer {
  #content = "";
  newLine = `
`;
  writeStatement(statement) {
    this.#content = `${this.#content}${this.newLine}${statement}`;
  }
  child() {
    return new _CompilerBuffer;
  }
  toString() {
    return this.#content;
  }
  flush() {
    this.#content = "";
  }
};
function defineFieldVariables({
  parseFnRefId,
  variableName,
  wildCardPath,
  isArrayMember,
  valueExpression,
  parentExpression,
  fieldNameExpression,
  parentValueExpression
}) {
  const inValueExpression = parseFnRefId ? `refs['${parseFnRefId}'](${valueExpression}, {
      data: root,
      meta: meta,
      parent: ${parentValueExpression}
    })` : valueExpression;
  let fieldPathOutputExpression = "";
  if (parentExpression === "root" || parentExpression === "root_item") {
    fieldPathOutputExpression = fieldNameExpression;
  } else if (fieldNameExpression !== "''") {
    fieldPathOutputExpression = `${parentExpression}.getFieldPath() + '.' + ${fieldNameExpression}`;
  }
  return `const ${variableName} = defineValue(${inValueExpression}, {
  data: root,
  meta: meta,
  name: ${fieldNameExpression},
  wildCardPath: '${wildCardPath}',
  getFieldPath() {
    return ${fieldPathOutputExpression};
  },
  mutate: defineValue,
  report: report,
  isValid: true,
  parent: ${parentValueExpression},
  isArrayMember: ${isArrayMember},
});`;
}
var BaseNode = class {
  #node;
  #parentField;
  field;
  constructor(node, compiler, parent, parentField) {
    this.#parentField = parentField;
    this.#node = node;
    if (this.#parentField) {
      this.field = this.#parentField;
    } else {
      compiler.variablesCounter++;
      this.field = compiler.createFieldFor(node, parent);
    }
  }
  defineField(buffer) {
    if (!this.#parentField) {
      buffer.writeStatement(defineFieldVariables({
        fieldNameExpression: this.field.fieldNameExpression,
        isArrayMember: this.field.isArrayMember,
        parentExpression: this.field.parentExpression,
        parentValueExpression: this.field.parentValueExpression,
        valueExpression: this.field.valueExpression,
        variableName: this.field.variableName,
        wildCardPath: this.field.wildCardPath,
        parseFnRefId: "parseFnId" in this.#node ? this.#node.parseFnId : undefined
      }));
    }
  }
};
function defineArrayGuard({ variableName, guardedCodeSnippet }) {
  return `if (${variableName}_is_array) {
${guardedCodeSnippet}
}`;
}
function defineIsValidGuard({ variableName, bail, guardedCodeSnippet }) {
  if (!bail) {
    return guardedCodeSnippet;
  }
  return `if (${variableName}.isValid) {
${guardedCodeSnippet}
}`;
}
function defineFieldNullOutput({
  allowNull,
  conditional,
  variableName,
  outputExpression,
  transformFnRefId
}) {
  if (!allowNull) {
    return "";
  }
  return `${conditional || "if"}(${variableName}.value === null) {
  ${outputExpression} = ${transformFnRefId ? `refs['${transformFnRefId}'](null, ${variableName});` : "null;"}
}`;
}
function wrapInConditional(conditions, wrappingCode) {
  const [first, second] = conditions;
  if (first && second) {
    return `if (${first} && ${second}) {
  ${wrappingCode}
}`;
  }
  if (first) {
    return `if (${first}) {
  ${wrappingCode}
}`;
  }
  if (second) {
    return `if (${second}) {
  ${wrappingCode}
}`;
  }
  return wrappingCode;
}
function emitValidationSnippet({ isAsync, implicit, ruleFnId }, variableName, bail, dropMissingCheck, existenceCheckExpression) {
  const rule = `refs['${ruleFnId}']`;
  const callable = `${rule}.validator(${variableName}.value, ${rule}.options, ${variableName});`;
  existenceCheckExpression = existenceCheckExpression || `${variableName}.isDefined`;
  const bailCondition = bail ? `${variableName}.isValid` : "";
  const implicitCondition = implicit || dropMissingCheck ? "" : existenceCheckExpression;
  return wrapInConditional([bailCondition, implicitCondition], isAsync ? `await ${callable}` : `${callable}`);
}
function defineFieldValidations({
  bail,
  validations,
  variableName,
  dropMissingCheck,
  existenceCheckExpression
}) {
  return `${validations.map((one) => emitValidationSnippet(one, variableName, bail, dropMissingCheck, existenceCheckExpression)).join(`
`)}`;
}
function defineArrayInitialOutput({
  variableName,
  outputExpression,
  outputValueExpression
}) {
  return `const ${variableName}_out = ${outputValueExpression};
${outputExpression} = ${variableName}_out;`;
}
function defineFieldExistenceValidations({
  allowNull,
  isOptional,
  variableName
}) {
  if (isOptional === false) {
    if (allowNull === false) {
      return `ensureExists(${variableName});`;
    } else {
      return `ensureIsDefined(${variableName});`;
    }
  }
  return "";
}
function defineArrayVariables({ variableName }) {
  return `const ${variableName}_is_array = ensureIsArray(${variableName});`;
}
var TupleNodeCompiler = class extends BaseNode {
  #node;
  #buffer;
  #compiler;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
    this.#compiler = compiler;
  }
  #compileTupleChildren() {
    const buffer = this.#buffer.child();
    const parent = {
      type: "tuple",
      fieldPathExpression: this.field.fieldPathExpression,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      wildCardPath: this.field.wildCardPath
    };
    this.#node.properties.forEach((child) => {
      this.#compiler.compileNode(child, buffer, parent);
    });
    return buffer.toString();
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(defineFieldExistenceValidations({
      allowNull: this.#node.allowNull,
      isOptional: this.#node.isOptional,
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineArrayVariables({
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineFieldValidations({
      variableName: this.field.variableName,
      validations: this.#node.validations,
      bail: this.#node.bail,
      dropMissingCheck: false,
      existenceCheckExpression: `${this.field.variableName}_is_array`
    }));
    const isArrayValidBlock = defineArrayGuard({
      variableName: this.field.variableName,
      guardedCodeSnippet: `${this.#buffer.newLine}${defineIsValidGuard({
        variableName: this.field.variableName,
        bail: this.#node.bail,
        guardedCodeSnippet: `${defineArrayInitialOutput({
          variableName: this.field.variableName,
          outputExpression: this.field.outputExpression,
          outputValueExpression: this.#node.allowUnknownProperties ? `copyProperties(${this.field.variableName}.value)` : `[]`
        })}${this.#buffer.newLine}${this.#compileTupleChildren()}`
      })}`
    });
    this.#buffer.writeStatement(`${isArrayValidBlock}${this.#buffer.newLine}${defineFieldNullOutput({
      allowNull: this.#node.allowNull,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      conditional: "else if"
    })}`);
  }
};
function defineArrayLoop({
  variableName,
  loopCodeSnippet,
  startingIndex
}) {
  startingIndex = startingIndex || 0;
  return `const ${variableName}_items_size = ${variableName}.value.length;
for (let ${variableName}_i = ${startingIndex}; ${variableName}_i < ${variableName}_items_size; ${variableName}_i++) {
${loopCodeSnippet}
}`;
}
var ArrayNodeCompiler = class extends BaseNode {
  #node;
  #buffer;
  #compiler;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
    this.#compiler = compiler;
  }
  #compileArrayElements() {
    const arrayElementsBuffer = this.#buffer.child();
    this.#compiler.compileNode(this.#node.each, arrayElementsBuffer, {
      type: "array",
      fieldPathExpression: this.field.fieldPathExpression,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      wildCardPath: this.field.wildCardPath
    });
    const buffer = this.#buffer.child();
    buffer.writeStatement(defineArrayLoop({
      variableName: this.field.variableName,
      startingIndex: 0,
      loopCodeSnippet: arrayElementsBuffer.toString()
    }));
    arrayElementsBuffer.flush();
    return buffer.toString();
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(defineFieldExistenceValidations({
      allowNull: this.#node.allowNull,
      isOptional: this.#node.isOptional,
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineArrayVariables({
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineFieldValidations({
      variableName: this.field.variableName,
      validations: this.#node.validations,
      bail: this.#node.bail,
      dropMissingCheck: false,
      existenceCheckExpression: `${this.field.variableName}_is_array`
    }));
    const isArrayValidBlock = defineArrayGuard({
      variableName: this.field.variableName,
      guardedCodeSnippet: `${this.#buffer.newLine}${defineIsValidGuard({
        variableName: this.field.variableName,
        bail: this.#node.bail,
        guardedCodeSnippet: `${defineArrayInitialOutput({
          variableName: this.field.variableName,
          outputExpression: this.field.outputExpression,
          outputValueExpression: `[]`
        })}${this.#buffer.newLine}${this.#compileArrayElements()}`
      })}`
    });
    this.#buffer.writeStatement(`${isArrayValidBlock}${this.#buffer.newLine}${defineFieldNullOutput({
      allowNull: this.#node.allowNull,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      conditional: "else if"
    })}`);
  }
};
function callParseFunction({ parseFnRefId, variableName }) {
  if (parseFnRefId) {
    return `${variableName}.value = refs['${parseFnRefId}'](${variableName}.value);`;
  }
  return "";
}
function defineElseCondition({ variableName, conditionalFnRefId }) {
  return `else {
refs['${conditionalFnRefId}'](${variableName}.value, ${variableName});
}`;
}
function defineConditionalGuard({
  conditional,
  variableName,
  conditionalFnRefId,
  guardedCodeSnippet
}) {
  return `${conditional}(refs['${conditionalFnRefId}'](${variableName}.value, ${variableName})) {
${guardedCodeSnippet}
}`;
}
var UnionNodeCompiler = class extends BaseNode {
  #compiler;
  #node;
  #buffer;
  #parent;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
    this.#parent = parent;
    this.#compiler = compiler;
  }
  #compileUnionChildren() {
    const childrenBuffer = this.#buffer.child();
    this.#node.conditions.forEach((child, index) => {
      const conditionalBuffer = this.#buffer.child();
      if ("parseFnId" in child.schema) {
        conditionalBuffer.writeStatement(callParseFunction({
          parseFnRefId: child.schema.parseFnId,
          variableName: this.field.variableName
        }));
      }
      this.#compiler.compileNode(child.schema, conditionalBuffer, this.#parent, this.field);
      childrenBuffer.writeStatement(defineConditionalGuard({
        conditional: index === 0 ? "if" : "else if",
        variableName: this.field.variableName,
        conditionalFnRefId: child.conditionalFnRefId,
        guardedCodeSnippet: conditionalBuffer.toString()
      }));
      conditionalBuffer.flush();
    });
    if (this.#node.elseConditionalFnRefId && this.#node.conditions.length) {
      childrenBuffer.writeStatement(defineElseCondition({
        variableName: this.field.variableName,
        conditionalFnRefId: this.#node.elseConditionalFnRefId
      }));
    }
    return childrenBuffer.toString();
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(this.#compileUnionChildren());
  }
};
function defineRecordLoop({ variableName, loopCodeSnippet }) {
  return `const ${variableName}_keys = Object.keys(${variableName}.value);
const ${variableName}_keys_size = ${variableName}_keys.length;
for (let ${variableName}_key_i = 0; ${variableName}_key_i < ${variableName}_keys_size; ${variableName}_key_i++) {
const ${variableName}_i = ${variableName}_keys[${variableName}_key_i];
${loopCodeSnippet}
}`;
}
function defineObjectGuard({ variableName, guardedCodeSnippet }) {
  return `if (${variableName}_is_object) {
${guardedCodeSnippet}
}`;
}
function defineObjectInitialOutput({
  variableName,
  outputExpression,
  outputValueExpression
}) {
  return `const ${variableName}_out = ${outputValueExpression};
${outputExpression} = ${variableName}_out;`;
}
function defineObjectVariables({ variableName }) {
  return `const ${variableName}_is_object = ensureIsObject(${variableName});`;
}
var RecordNodeCompiler = class extends BaseNode {
  #node;
  #buffer;
  #compiler;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
    this.#compiler = compiler;
  }
  #compileRecordElements() {
    const buffer = this.#buffer.child();
    const recordElementsBuffer = this.#buffer.child();
    this.#compiler.compileNode(this.#node.each, recordElementsBuffer, {
      type: "record",
      fieldPathExpression: this.field.fieldPathExpression,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      wildCardPath: this.field.wildCardPath
    });
    buffer.writeStatement(defineRecordLoop({
      variableName: this.field.variableName,
      loopCodeSnippet: recordElementsBuffer.toString()
    }));
    recordElementsBuffer.flush();
    return buffer.toString();
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(defineFieldExistenceValidations({
      allowNull: this.#node.allowNull,
      isOptional: this.#node.isOptional,
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineObjectVariables({
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineFieldValidations({
      variableName: this.field.variableName,
      validations: this.#node.validations,
      bail: this.#node.bail,
      dropMissingCheck: false,
      existenceCheckExpression: `${this.field.variableName}_is_object`
    }));
    const isObjectValidBlock = defineIsValidGuard({
      variableName: this.field.variableName,
      bail: this.#node.bail,
      guardedCodeSnippet: `${defineObjectInitialOutput({
        variableName: this.field.variableName,
        outputExpression: this.field.outputExpression,
        outputValueExpression: `{}`
      })}${this.#compileRecordElements()}`
    });
    const isValueAnObjectBlock = defineObjectGuard({
      variableName: this.field.variableName,
      guardedCodeSnippet: `${this.#buffer.newLine}${isObjectValidBlock}`
    });
    this.#buffer.writeStatement(`${isValueAnObjectBlock}${this.#buffer.newLine}${defineFieldNullOutput({
      allowNull: this.#node.allowNull,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      conditional: "else if"
    })}`);
  }
};
function arrayToString(arr) {
  return `[${arr.map((str) => `"${str}"`).join(", ")}]`;
}
function defineMoveProperties({
  variableName,
  fieldsToIgnore,
  allowUnknownProperties
}) {
  if (!allowUnknownProperties) {
    return "";
  }
  const serializedFieldsToIgnore = arrayToString(fieldsToIgnore);
  return `moveProperties(${variableName}.value, ${variableName}_out, ${serializedFieldsToIgnore});`;
}
var ObjectNodeCompiler = class extends BaseNode {
  #node;
  #buffer;
  #compiler;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
    this.#compiler = compiler;
  }
  #getFieldNames(node) {
    let fieldNames = node.properties.map((child) => child.fieldName);
    const groupsFieldNames = node.groups.flatMap((group) => this.#getGroupFieldNames(group));
    return fieldNames.concat(groupsFieldNames);
  }
  #getGroupFieldNames(group) {
    return group.conditions.flatMap((condition) => {
      return this.#getFieldNames(condition.schema);
    });
  }
  #compileObjectChildren() {
    const buffer = this.#buffer.child();
    const parent = {
      type: "object",
      fieldPathExpression: this.field.fieldPathExpression,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      wildCardPath: this.field.wildCardPath
    };
    this.#node.properties.forEach((child) => this.#compiler.compileNode(child, buffer, parent));
    return buffer.toString();
  }
  #compileObjectGroups() {
    const buffer = this.#buffer.child();
    const parent = {
      type: "object",
      fieldPathExpression: this.field.fieldPathExpression,
      outputExpression: this.field.outputExpression,
      variableName: this.field.variableName,
      wildCardPath: this.field.wildCardPath
    };
    this.#node.groups.forEach((group) => this.#compileObjectGroup(group, buffer, parent));
    return buffer.toString();
  }
  #compileObjectGroup(group, buffer, parent) {
    group.conditions.forEach((condition, index) => {
      const guardBuffer = buffer.child();
      condition.schema.properties.forEach((child) => {
        this.#compiler.compileNode(child, guardBuffer, parent);
      });
      condition.schema.groups.forEach((child) => {
        this.#compileObjectGroup(child, guardBuffer, parent);
      });
      buffer.writeStatement(defineConditionalGuard({
        variableName: this.field.variableName,
        conditional: index === 0 ? "if" : "else if",
        conditionalFnRefId: condition.conditionalFnRefId,
        guardedCodeSnippet: guardBuffer.toString()
      }));
    });
    if (group.elseConditionalFnRefId && group.conditions.length) {
      buffer.writeStatement(defineElseCondition({
        variableName: this.field.variableName,
        conditionalFnRefId: group.elseConditionalFnRefId
      }));
    }
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(defineFieldExistenceValidations({
      allowNull: this.#node.allowNull,
      isOptional: this.#node.isOptional,
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineObjectVariables({
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineFieldValidations({
      variableName: this.field.variableName,
      validations: this.#node.validations,
      bail: this.#node.bail,
      dropMissingCheck: false,
      existenceCheckExpression: `${this.field.variableName}_is_object`
    }));
    const isObjectValidBlock = defineIsValidGuard({
      variableName: this.field.variableName,
      bail: this.#node.bail,
      guardedCodeSnippet: `${defineObjectInitialOutput({
        variableName: this.field.variableName,
        outputExpression: this.field.outputExpression,
        outputValueExpression: "{}"
      })}${this.#buffer.newLine}${this.#compileObjectChildren()}${this.#buffer.newLine}${this.#compileObjectGroups()}${this.#buffer.newLine}${defineMoveProperties({
        variableName: this.field.variableName,
        allowUnknownProperties: this.#node.allowUnknownProperties,
        fieldsToIgnore: this.#node.allowUnknownProperties ? this.#getFieldNames(this.#node) : []
      })}`
    });
    const isValueAnObject = defineObjectGuard({
      variableName: this.field.variableName,
      guardedCodeSnippet: `${isObjectValidBlock}`
    });
    this.#buffer.writeStatement(`${isValueAnObject}${this.#buffer.newLine}${defineFieldNullOutput({
      variableName: this.field.variableName,
      allowNull: this.#node.allowNull,
      outputExpression: this.field.outputExpression,
      conditional: "else if"
    })}`);
  }
};
function createRootField(parent) {
  return {
    parentExpression: parent.variableName,
    parentValueExpression: parent.variableName,
    fieldNameExpression: `''`,
    fieldPathExpression: `''`,
    wildCardPath: "",
    variableName: `${parent.variableName}_item`,
    valueExpression: "root",
    outputExpression: parent.outputExpression,
    isArrayMember: false
  };
}
function defineFieldValueOutput({
  variableName,
  outputExpression,
  transformFnRefId
}) {
  const outputValueExpression = transformFnRefId ? `refs['${transformFnRefId}'](${variableName}.value, ${variableName})` : `${variableName}.value`;
  return `if (${variableName}.isDefined && ${variableName}.isValid) {
  ${outputExpression} = ${outputValueExpression};
}`;
}
var LiteralNodeCompiler = class extends BaseNode {
  #node;
  #buffer;
  constructor(node, buffer, compiler, parent, parentField) {
    super(node, compiler, parent, parentField);
    this.#node = node;
    this.#buffer = buffer;
  }
  compile() {
    this.defineField(this.#buffer);
    this.#buffer.writeStatement(defineFieldExistenceValidations({
      allowNull: this.#node.allowNull,
      isOptional: this.#node.isOptional,
      variableName: this.field.variableName
    }));
    this.#buffer.writeStatement(defineFieldValidations({
      variableName: this.field.variableName,
      validations: this.#node.validations,
      bail: this.#node.bail,
      dropMissingCheck: false
    }));
    this.#buffer.writeStatement(`${defineFieldValueOutput({
      variableName: this.field.variableName,
      outputExpression: this.field.outputExpression,
      transformFnRefId: this.#node.transformFnId
    })}${this.#buffer.newLine}${defineFieldNullOutput({
      variableName: this.field.variableName,
      allowNull: this.#node.allowNull,
      outputExpression: this.field.outputExpression,
      transformFnRefId: this.#node.transformFnId,
      conditional: "else if"
    })}`);
  }
};
function createArrayField(parent) {
  const wildCardPath = parent.wildCardPath !== "" ? `${parent.wildCardPath}.*` : `*`;
  return {
    parentExpression: parent.variableName,
    parentValueExpression: `${parent.variableName}.value`,
    fieldNameExpression: `${parent.variableName}_i`,
    fieldPathExpression: wildCardPath,
    wildCardPath,
    variableName: `${parent.variableName}_item`,
    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,
    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,
    isArrayMember: true
  };
}
function createTupleField(node, parent) {
  const wildCardPath = parent.wildCardPath !== "" ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName;
  return {
    parentExpression: parent.variableName,
    parentValueExpression: `${parent.variableName}.value`,
    fieldNameExpression: `${node.fieldName}`,
    fieldPathExpression: wildCardPath,
    wildCardPath,
    variableName: `${parent.variableName}_item_${node.fieldName}`,
    valueExpression: `${parent.variableName}.value[${node.fieldName}]`,
    outputExpression: `${parent.variableName}_out[${node.propertyName}]`,
    isArrayMember: true
  };
}
function reportErrors() {
  return `if(errorReporter.hasErrors) {
  throw errorReporter.createError();
}`;
}
var NUMBER_CHAR_RE = /\d/;
var VALID_CHARS = /[A-Za-z0-9]+/;
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return;
  }
  return char !== char.toLowerCase();
}
function upperFirst(value) {
  return value ? value[0].toUpperCase() + value.slice(1) : "";
}
function lowerFirst(value) {
  return value ? value[0].toLowerCase() + value.slice(1) : "";
}
function splitByCase(value) {
  const parts = [];
  if (!value || typeof value !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of value) {
    const isSplitter = !VALID_CHARS.test(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = undefined;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function toVariableName(value) {
  const pascalCase2 = splitByCase(value).map((p4) => upperFirst(p4.toLowerCase())).join("");
  return /^[0-9]+/.test(pascalCase2) ? `var_${pascalCase2}` : lowerFirst(pascalCase2);
}
function createObjectField(node, variablesCounter, parent) {
  const wildCardPath = parent.wildCardPath !== "" ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName;
  return {
    parentExpression: parent.variableName,
    parentValueExpression: `${parent.variableName}.value`,
    fieldNameExpression: `'${node.fieldName}'`,
    fieldPathExpression: wildCardPath,
    wildCardPath,
    variableName: `${toVariableName(node.propertyName)}_${variablesCounter}`,
    valueExpression: `${parent.variableName}.value['${node.fieldName}']`,
    outputExpression: `${parent.variableName}_out['${node.propertyName}']`,
    isArrayMember: false
  };
}
function createRecordField(parent) {
  const wildCardPath = parent.wildCardPath !== "" ? `${parent.wildCardPath}.*` : `*`;
  return {
    parentExpression: parent.variableName,
    parentValueExpression: `${parent.variableName}.value`,
    fieldNameExpression: `${parent.variableName}_i`,
    fieldPathExpression: wildCardPath,
    wildCardPath,
    variableName: `${parent.variableName}_item`,
    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,
    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,
    isArrayMember: false
  };
}
function defineInlineFunctions(options) {
  return `function report(message, rule, field, args) {
  field.isValid = false;
  errorReporter.report(messagesProvider.getMessage(message, rule, field, args), rule, field, args);
};
function defineValue(value, field) {
  ${options.convertEmptyStringsToNull ? `if (value === '') { value = null; }` : ""}
  field.value = value;
  field.isDefined = value !== undefined && value !== null;
  return field;
};
function ensureExists(field) {
  if (field.value === undefined || field.value === null) {
    field.report(REQUIRED, 'required', field);
    return false;
  }
  return true;
};
function ensureIsDefined(field) {
  if (field.value === undefined) {
    field.report(REQUIRED, 'required', field);
    return false;
  }
  return true;
};
function ensureIsObject(field) {
  if (!field.isDefined) {
    return false;
  }
  if (typeof field.value == 'object' && !Array.isArray(field.value)) {
    return true;
  }
  field.report(NOT_AN_OBJECT, 'object', field);
  return false;
};
function ensureIsArray(field) {
  if (!field.isDefined) {
    return false;
  }
  if (Array.isArray(field.value)) {
    return true;
  }
  field.report(NOT_AN_ARRAY, 'array', field);
  return false;
};
function copyProperties(val) {
  let k, out, tmp;

  if (Array.isArray(val)) {
    out = Array((k = val.length))
    while (k--) out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp
    return out
  }

  if (Object.prototype.toString.call(val) === '[object Object]') {
    out = {} // null
    for (k in val) {
      out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp
    }
    return out
  }
  return val
};
function moveProperties(source, destination, ignoreKeys) {
  for (let key in source) {
    if (!ignoreKeys.includes(key)) {
      const value = source[key]
      destination[key] = copyProperties(value)
    }
  }
};`;
}
function defineInlineErrorMessages(messages2) {
  return `const REQUIRED = '${messages2.required}';
const NOT_AN_OBJECT = '${messages2.object}';
const NOT_AN_ARRAY = '${messages2.array}';`;
}
var AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
var Compiler = class {
  variablesCounter = 0;
  #rootNode;
  #options;
  #buffer = new CompilerBuffer;
  constructor(rootNode, options) {
    this.#rootNode = rootNode;
    this.#options = options || { convertEmptyStringsToNull: false };
  }
  #initiateJSOutput() {
    this.#buffer.writeStatement(defineInlineErrorMessages({
      required: "value is required",
      object: "value is not a valid object",
      array: "value is not a valid array",
      ...this.#options.messages
    }));
    this.#buffer.writeStatement(defineInlineFunctions(this.#options));
    this.#buffer.writeStatement("let out;");
  }
  #finishJSOutput() {
    this.#buffer.writeStatement(reportErrors());
    this.#buffer.writeStatement("return out;");
  }
  #compileNodes() {
    this.compileNode(this.#rootNode.schema, this.#buffer, {
      type: "root",
      variableName: "root",
      outputExpression: "out",
      fieldPathExpression: "out",
      wildCardPath: ""
    });
  }
  #toAsyncFunction() {
    return new AsyncFunction("root", "meta", "refs", "messagesProvider", "errorReporter", this.#buffer.toString());
  }
  createFieldFor(node, parent) {
    switch (parent.type) {
      case "array":
        return createArrayField(parent);
      case "root":
        return createRootField(parent);
      case "object":
        return createObjectField(node, this.variablesCounter, parent);
      case "tuple":
        return createTupleField(node, parent);
      case "record":
        return createRecordField(parent);
    }
  }
  compileNode(node, buffer, parent, parentField) {
    switch (node.type) {
      case "literal":
        return new LiteralNodeCompiler(node, buffer, this, parent, parentField).compile();
      case "array":
        return new ArrayNodeCompiler(node, buffer, this, parent, parentField).compile();
      case "record":
        return new RecordNodeCompiler(node, buffer, this, parent, parentField).compile();
      case "object":
        return new ObjectNodeCompiler(node, buffer, this, parent, parentField).compile();
      case "tuple":
        return new TupleNodeCompiler(node, buffer, this, parent, parentField).compile();
      case "union":
        return new UnionNodeCompiler(node, buffer, this, parent, parentField).compile();
    }
  }
  compile() {
    this.#initiateJSOutput();
    this.#compileNodes();
    this.#finishJSOutput();
    const outputFunction = this.#toAsyncFunction();
    this.variablesCounter = 0;
    this.#buffer.flush();
    return outputFunction;
  }
};

// ../../../../node_modules/@vinejs/compiler/build/index.js
function refsBuilder() {
  let counter = 0;
  const refs = {};
  return {
    toJSON() {
      return refs;
    },
    track(value) {
      counter++;
      const ref = `ref://${counter}`;
      refs[ref] = value;
      return ref;
    },
    trackValidation(validation) {
      return this.track(validation);
    },
    trackParser(fn) {
      return this.track(fn);
    },
    trackTransformer(fn) {
      return this.track(fn);
    },
    trackConditional(fn) {
      return this.track(fn);
    }
  };
}

// ../../../../node_modules/@vinejs/vine/build/chunk-FED7BU4B.js
function createRule(validator, metaData) {
  const rule = {
    validator,
    isAsync: metaData?.isAsync || validator.constructor.name === "AsyncFunction",
    implicit: metaData?.implicit ?? false
  };
  return function(...options) {
    return {
      rule,
      options: options[0]
    };
  };
}
var symbols_exports = {};
__export(symbols_exports, {
  COTYPE: () => COTYPE,
  IS_OF_TYPE: () => IS_OF_TYPE,
  ITYPE: () => ITYPE,
  OTYPE: () => OTYPE,
  PARSE: () => PARSE2,
  SUBTYPE: () => SUBTYPE,
  UNIQUE_NAME: () => UNIQUE_NAME,
  VALIDATION: () => VALIDATION
});
var UNIQUE_NAME = Symbol.for("schema_name");
var IS_OF_TYPE = Symbol.for("is_of_type");
var PARSE2 = Symbol.for("parse");
var ITYPE = Symbol.for("opaque_input_type");
var OTYPE = Symbol.for("opaque_type");
var COTYPE = Symbol.for("camelcase_opaque_type");
var VALIDATION = Symbol.for("to_validation");
var SUBTYPE = Symbol.for("subtype");
var requiredWhen = createRule((_3, checker, field) => {
  const shouldBeRequired = checker(field);
  if (!field.isDefined && shouldBeRequired) {
    field.report(messages.required, "required", field);
  }
}, {
  implicit: true
});
var BaseModifiersType = class extends Macroable {
  optional(validations) {
    return new OptionalModifier(this, validations);
  }
  nullable() {
    return new NullableModifier(this);
  }
  transform(transformer) {
    return new TransformModifier(transformer, this);
  }
};
var NullableModifier = class _NullableModifier extends BaseModifiersType {
  #parent;
  constructor(parent) {
    super();
    this.#parent = parent;
  }
  clone() {
    return new _NullableModifier(this.#parent.clone());
  }
  [PARSE2](propertyName, refs, options) {
    const output = this.#parent[PARSE2](propertyName, refs, options);
    output.allowNull = true;
    return output;
  }
};
var OptionalModifier = class _OptionalModifier extends BaseModifiersType {
  #parent;
  validations;
  constructor(parent, validations) {
    super();
    this.#parent = parent;
    this.validations = validations || [];
  }
  cloneValidations() {
    return this.validations.map((validation) => {
      return {
        options: validation.options,
        rule: validation.rule
      };
    });
  }
  compileValidations(refs) {
    return this.validations.map((validation) => {
      return {
        ruleFnId: refs.track({
          validator: validation.rule.validator,
          options: validation.options
        }),
        implicit: validation.rule.implicit,
        isAsync: validation.rule.isAsync
      };
    });
  }
  use(validation) {
    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
    return this;
  }
  requiredWhen(otherField, operator, expectedValue) {
    if (typeof otherField === "function") {
      return this.use(requiredWhen(otherField));
    }
    let checker;
    switch (operator) {
      case "=":
        checker = (value) => value === expectedValue;
        break;
      case "!=":
        checker = (value) => value !== expectedValue;
        break;
      case "in":
        checker = (value) => expectedValue.includes(value);
        break;
      case "notIn":
        checker = (value) => !expectedValue.includes(value);
        break;
      case ">":
        checker = (value) => value > expectedValue;
        break;
      case "<":
        checker = (value) => value < expectedValue;
        break;
      case ">=":
        checker = (value) => value >= expectedValue;
        break;
      case "<=":
        checker = (value) => value <= expectedValue;
    }
    return this.use(requiredWhen((field) => {
      const otherFieldValue = helpers.getNestedValue(otherField, field);
      return checker(otherFieldValue);
    }));
  }
  requiredIfExists(fields2) {
    const fieldsToExist = Array.isArray(fields2) ? fields2 : [fields2];
    return this.use(requiredWhen((field) => {
      return fieldsToExist.every((otherField) => helpers.exists(helpers.getNestedValue(otherField, field)));
    }));
  }
  requiredIfAnyExists(fields2) {
    return this.use(requiredWhen((field) => {
      return fields2.some((otherField) => helpers.exists(helpers.getNestedValue(otherField, field)));
    }));
  }
  requiredIfMissing(fields2) {
    const fieldsToExist = Array.isArray(fields2) ? fields2 : [fields2];
    return this.use(requiredWhen((field) => {
      return fieldsToExist.every((otherField) => helpers.isMissing(helpers.getNestedValue(otherField, field)));
    }));
  }
  requiredIfAnyMissing(fields2) {
    return this.use(requiredWhen((field) => {
      return fields2.some((otherField) => helpers.isMissing(helpers.getNestedValue(otherField, field)));
    }));
  }
  clone() {
    return new _OptionalModifier(this.#parent.clone(), this.cloneValidations());
  }
  [PARSE2](propertyName, refs, options) {
    const output = this.#parent[PARSE2](propertyName, refs, options);
    output.isOptional = true;
    output.validations = output.validations.concat(this.compileValidations(refs));
    return output;
  }
};
var TransformModifier = class _TransformModifier extends BaseModifiersType {
  #parent;
  #transform;
  constructor(transform, parent) {
    super();
    this.#transform = transform;
    this.#parent = parent;
  }
  clone() {
    return new _TransformModifier(this.#transform, this.#parent.clone());
  }
  [PARSE2](propertyName, refs, options) {
    const output = this.#parent[PARSE2](propertyName, refs, options);
    output.transformFnId = refs.trackTransformer(this.#transform);
    return output;
  }
};
var BaseLiteralType = class extends BaseModifiersType {
  options;
  validations;
  constructor(options, validations) {
    super();
    this.options = {
      bail: true,
      allowNull: false,
      isOptional: false,
      ...options
    };
    this.validations = validations || [];
  }
  cloneValidations() {
    return this.validations.map((validation) => {
      return {
        options: validation.options,
        rule: validation.rule
      };
    });
  }
  cloneOptions() {
    return { ...this.options };
  }
  compileValidations(refs) {
    return this.validations.map((validation) => {
      return {
        ruleFnId: refs.track({
          validator: validation.rule.validator,
          options: validation.options
        }),
        implicit: validation.rule.implicit,
        isAsync: validation.rule.isAsync
      };
    });
  }
  parse(callback) {
    this.options.parse = callback;
    return this;
  }
  use(validation) {
    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
    return this;
  }
  bail(state) {
    this.options.bail = state;
    return this;
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "literal",
      subtype: this[SUBTYPE],
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      bail: this.options.bail,
      allowNull: this.options.allowNull,
      isOptional: this.options.isOptional,
      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
      validations: this.compileValidations(refs)
    };
  }
};
var VineAny = class _VineAny extends BaseLiteralType {
  constructor(options, validations) {
    super(options, validations);
  }
  [SUBTYPE] = "any";
  clone() {
    return new _VineAny(this.cloneOptions(), this.cloneValidations());
  }
};
var enumRule = createRule((value, options, field) => {
  const choices = typeof options.choices === "function" ? options.choices(field) : options.choices;
  if (!choices.includes(value)) {
    field.report(messages.enum, "enum", field, { choices });
  }
});
var VineEnum = class _VineEnum extends BaseLiteralType {
  static rules = {
    enum: enumRule
  };
  #values;
  [SUBTYPE] = "enum";
  getChoices() {
    return this.#values;
  }
  constructor(values, options, validations) {
    super(options, validations || [enumRule({ choices: values })]);
    this.#values = values;
  }
  clone() {
    return new _VineEnum(this.#values, this.cloneOptions(), this.cloneValidations());
  }
};
var DEFAULT_DATE_FORMATS = ["YYYY-MM-DD", "YYYY-MM-DD HH:mm:ss"];
import_dayjs2.default.extend(import_customParseFormat.default);
import_dayjs2.default.extend(import_isSameOrAfter.default);
import_dayjs2.default.extend(import_isSameOrBefore.default);
var dateRule = createRule((value, options, field) => {
  if (typeof value !== "string" && typeof value !== "number") {
    field.report(messages.date, "date", field);
    return;
  }
  let isTimestampAllowed = false;
  let isISOAllowed = false;
  let formats = options.formats || DEFAULT_DATE_FORMATS;
  if (Array.isArray(formats)) {
    formats = [...formats];
    isTimestampAllowed = formats.includes("x");
    isISOAllowed = formats.includes("iso8601");
  } else if (typeof formats !== "string") {
    formats = { ...formats };
    isTimestampAllowed = formats.format === "x";
    isISOAllowed = formats.format === "iso";
  }
  const valueAsNumber = isTimestampAllowed ? helpers.asNumber(value) : value;
  let dateTime;
  if (isTimestampAllowed && !Number.isNaN(valueAsNumber)) {
    dateTime = import_dayjs2.default(valueAsNumber);
  } else {
    dateTime = import_dayjs2.default(value, formats, true);
  }
  if (!dateTime.isValid() && isISOAllowed) {
    dateTime = import_dayjs2.default(value);
  }
  if (!dateTime.isValid()) {
    field.report(messages.date, "date", field);
    return;
  }
  field.meta.$value = dateTime;
  field.meta.$formats = formats;
  field.mutate(dateTime.toDate(), field);
});
var equalsRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const format = options.format || DEFAULT_DATE_FORMATS;
  const dateTime = field.meta.$value;
  const expectedValue = typeof options.expectedValue === "function" ? options.expectedValue(field) : options.expectedValue;
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    throw new Error(`Invalid datetime value "${expectedValue}" provided to the equals rule`);
  }
  if (!dateTime.isSame(expectedDateTime, compare)) {
    field.report(messages["date.equals"], "date.equals", field, {
      expectedValue,
      compare
    });
  }
});
var afterRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const format = options.format || DEFAULT_DATE_FORMATS;
  const dateTime = field.meta.$value;
  const expectedValue = typeof options.expectedValue === "function" ? options.expectedValue(field) : options.expectedValue;
  const expectedDateTime = expectedValue === "today" ? import_dayjs2.default() : expectedValue === "tomorrow" ? import_dayjs2.default().add(1, "day") : import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    throw new Error(`Invalid datetime value "${expectedValue}" provided to the after rule`);
  }
  if (!dateTime.isAfter(expectedDateTime, compare)) {
    field.report(messages["date.after"], "date.after", field, {
      expectedValue,
      compare
    });
  }
});
var afterOrEqualRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const format = options.format || DEFAULT_DATE_FORMATS;
  const dateTime = field.meta.$value;
  const expectedValue = typeof options.expectedValue === "function" ? options.expectedValue(field) : options.expectedValue;
  const expectedDateTime = expectedValue === "today" ? import_dayjs2.default() : expectedValue === "tomorrow" ? import_dayjs2.default().add(1, "day") : import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    throw new Error(`Invalid datetime value "${expectedValue}" provided to the afterOrEqual rule`);
  }
  if (!dateTime.isSameOrAfter(expectedDateTime, compare)) {
    field.report(messages["date.afterOrEqual"], "date.afterOrEqual", field, {
      expectedValue,
      compare
    });
  }
});
var beforeRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const format = options.format || DEFAULT_DATE_FORMATS;
  const dateTime = field.meta.$value;
  const expectedValue = typeof options.expectedValue === "function" ? options.expectedValue(field) : options.expectedValue;
  const expectedDateTime = expectedValue === "today" ? import_dayjs2.default() : expectedValue === "yesterday" ? import_dayjs2.default().subtract(1, "day") : import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    throw new Error(`Invalid datetime value "${expectedValue}" provided to the before rule`);
  }
  if (!dateTime.isBefore(expectedDateTime, compare)) {
    field.report(messages["date.before"], "date.before", field, {
      expectedValue,
      compare
    });
  }
});
var beforeOrEqualRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const format = options.format || DEFAULT_DATE_FORMATS;
  const dateTime = field.meta.$value;
  const expectedValue = typeof options.expectedValue === "function" ? options.expectedValue(field) : options.expectedValue;
  const expectedDateTime = expectedValue === "today" ? import_dayjs2.default() : expectedValue === "yesterday" ? import_dayjs2.default().subtract(1, "day") : import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    throw new Error(`Invalid datetime value "${expectedValue}" provided to the beforeOrEqual rule`);
  }
  if (!dateTime.isSameOrBefore(expectedDateTime, compare)) {
    field.report(messages["date.beforeOrEqual"], "date.beforeOrEqual", field, {
      expectedValue,
      compare
    });
  }
});
var sameAsRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (!dateTime.isSame(expectedDateTime, compare)) {
    field.report(messages["date.sameAs"], "date.sameAs", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var notSameAsRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (dateTime.isSame(expectedDateTime, compare)) {
    field.report(messages["date.notSameAs"], "date.notSameAs", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var afterFieldRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (!dateTime.isAfter(expectedDateTime, compare)) {
    field.report(messages["date.afterField"], "date.afterField", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var afterOrSameAsRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (!dateTime.isSameOrAfter(expectedDateTime, compare)) {
    field.report(messages["date.afterOrSameAs"], "date.afterOrSameAs", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var beforeFieldRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (!dateTime.isBefore(expectedDateTime, compare)) {
    field.report(messages["date.beforeField"], "date.beforeField", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var beforeOrSameAsRule = createRule((_3, options, field) => {
  if (!field.meta.$value) {
    return;
  }
  const compare = options.compare || "day";
  const dateTime = field.meta.$value;
  const format = options.format || field.meta.$formats;
  const expectedValue = helpers.getNestedValue(options.otherField, field);
  const expectedDateTime = import_dayjs2.default(expectedValue, format, true);
  if (!expectedDateTime.isValid()) {
    return;
  }
  if (!dateTime.isSameOrBefore(expectedDateTime, compare)) {
    field.report(messages["date.beforeOrSameAs"], "date.beforeOrSameAs", field, {
      otherField: options.otherField,
      expectedValue,
      compare
    });
  }
});
var weekendRule = createRule((_3, __, field) => {
  if (!field.meta.$value) {
    return;
  }
  const dateTime = field.meta.$value;
  const day = dateTime.day();
  if (day !== 0 && day !== 6) {
    field.report(messages["date.weekend"], "date.weekend", field);
  }
});
var weekdayRule = createRule((_3, __, field) => {
  if (!field.meta.$value) {
    return;
  }
  const dateTime = field.meta.$value;
  const day = dateTime.day();
  if (day === 0 || day === 6) {
    field.report(messages["date.weekday"], "date.weekday", field);
  }
});
var VineDate = class _VineDate extends BaseLiteralType {
  static rules = {
    equals: equalsRule,
    after: afterRule,
    afterOrEqual: afterOrEqualRule,
    before: beforeRule,
    beforeOrEqual: beforeOrEqualRule,
    sameAs: sameAsRule,
    notSameAs: notSameAsRule,
    afterField: afterFieldRule,
    afterOrSameAs: afterOrSameAsRule,
    beforeField: beforeFieldRule,
    beforeOrSameAs: beforeOrSameAsRule,
    weekend: weekendRule,
    weekday: weekdayRule
  };
  [UNIQUE_NAME] = "vine.date";
  [SUBTYPE] = "date";
  [IS_OF_TYPE] = (value) => {
    if (typeof value !== "string") {
      return false;
    }
    return import_dayjs.default(value, this.options.formats || DEFAULT_DATE_FORMATS, true).isValid();
  };
  constructor(options, validations) {
    super(options, validations || [dateRule(options || {})]);
  }
  equals(expectedValue, options) {
    return this.use(equalsRule({ expectedValue, ...options }));
  }
  after(expectedValue, options) {
    return this.use(afterRule({ expectedValue, ...options }));
  }
  afterOrEqual(expectedValue, options) {
    return this.use(afterOrEqualRule({ expectedValue, ...options }));
  }
  before(expectedValue, options) {
    return this.use(beforeRule({ expectedValue, ...options }));
  }
  beforeOrEqual(expectedValue, options) {
    return this.use(beforeOrEqualRule({ expectedValue, ...options }));
  }
  sameAs(otherField, options) {
    return this.use(sameAsRule({ otherField, ...options }));
  }
  notSameAs(otherField, options) {
    return this.use(notSameAsRule({ otherField, ...options }));
  }
  afterField(otherField, options) {
    return this.use(afterFieldRule({ otherField, ...options }));
  }
  afterOrSameAs(otherField, options) {
    return this.use(afterOrSameAsRule({ otherField, ...options }));
  }
  beforeField(otherField, options) {
    return this.use(beforeFieldRule({ otherField, ...options }));
  }
  beforeOrSameAs(otherField, options) {
    return this.use(beforeOrSameAsRule({ otherField, ...options }));
  }
  weekend() {
    return this.use(weekendRule());
  }
  weekday() {
    return this.use(weekdayRule());
  }
  clone() {
    return new _VineDate(this.cloneOptions(), this.cloneValidations());
  }
};
var VineUnion = class _VineUnion {
  #conditionals;
  #otherwiseCallback = (_3, field) => {
    field.report(messages.union, "union", field);
  };
  constructor(conditionals) {
    this.#conditionals = conditionals;
  }
  otherwise(callback) {
    this.#otherwiseCallback = callback;
    return this;
  }
  clone() {
    const cloned = new _VineUnion(this.#conditionals);
    cloned.otherwise(this.#otherwiseCallback);
    return cloned;
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "union",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),
      conditions: this.#conditionals.map((conditional) => conditional[PARSE2](propertyName, refs, options))
    };
  }
};
var UnionConditional = class {
  #schema;
  #conditional;
  constructor(conditional, schema3) {
    this.#schema = schema3;
    this.#conditional = conditional;
  }
  [PARSE2](propertyName, refs, options) {
    return {
      conditionalFnRefId: refs.trackConditional(this.#conditional),
      schema: this.#schema[PARSE2](propertyName, refs, options)
    };
  }
};
function union(conditionals) {
  return new VineUnion(conditionals);
}
union.if = function unionIf(conditon, schema3) {
  return new UnionConditional(conditon, schema3);
};
union.else = function unionElse(schema3) {
  return new UnionConditional(() => true, schema3);
};
var BaseModifiersType2 = class extends Macroable {
  optional() {
    return new OptionalModifier2(this);
  }
  nullable() {
    return new NullableModifier2(this);
  }
};
var NullableModifier2 = class _NullableModifier2 extends BaseModifiersType2 {
  #parent;
  constructor(parent) {
    super();
    this.#parent = parent;
  }
  clone() {
    return new _NullableModifier2(this.#parent.clone());
  }
  [PARSE2](propertyName, refs, options) {
    const output = this.#parent[PARSE2](propertyName, refs, options);
    if (output.type !== "union") {
      output.allowNull = true;
    }
    return output;
  }
};
var OptionalModifier2 = class _OptionalModifier2 extends BaseModifiersType2 {
  #parent;
  validations;
  constructor(parent, validations) {
    super();
    this.#parent = parent;
    this.validations = validations || [];
  }
  cloneValidations() {
    return this.validations.map((validation) => {
      return {
        options: validation.options,
        rule: validation.rule
      };
    });
  }
  compileValidations(refs) {
    return this.validations.map((validation) => {
      return {
        ruleFnId: refs.track({
          validator: validation.rule.validator,
          options: validation.options
        }),
        implicit: validation.rule.implicit,
        isAsync: validation.rule.isAsync
      };
    });
  }
  use(validation) {
    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
    return this;
  }
  requiredWhen(otherField, operator, expectedValue) {
    if (typeof otherField === "function") {
      return this.use(requiredWhen(otherField));
    }
    let checker;
    switch (operator) {
      case "=":
        checker = (value) => value === expectedValue;
        break;
      case "!=":
        checker = (value) => value !== expectedValue;
        break;
      case "in":
        checker = (value) => expectedValue.includes(value);
        break;
      case "notIn":
        checker = (value) => !expectedValue.includes(value);
        break;
      case ">":
        checker = (value) => value > expectedValue;
        break;
      case "<":
        checker = (value) => value < expectedValue;
        break;
      case ">=":
        checker = (value) => value >= expectedValue;
        break;
      case "<=":
        checker = (value) => value <= expectedValue;
    }
    return this.use(requiredWhen((field) => {
      const otherFieldValue = helpers.getNestedValue(otherField, field);
      return checker(otherFieldValue);
    }));
  }
  requiredIfExists(fields2) {
    const fieldsToExist = Array.isArray(fields2) ? fields2 : [fields2];
    return this.use(requiredWhen((field) => {
      return fieldsToExist.every((otherField) => {
        return helpers.exists(helpers.getNestedValue(otherField, field));
      });
    }));
  }
  requiredIfAnyExists(fields2) {
    return this.use(requiredWhen((field) => {
      return fields2.some((otherField) => helpers.exists(helpers.getNestedValue(otherField, field)));
    }));
  }
  requiredIfMissing(fields2) {
    const fieldsToExist = Array.isArray(fields2) ? fields2 : [fields2];
    return this.use(requiredWhen((field) => {
      return fieldsToExist.every((otherField) => helpers.isMissing(helpers.getNestedValue(otherField, field)));
    }));
  }
  requiredIfAnyMissing(fields2) {
    return this.use(requiredWhen((field) => {
      return fields2.some((otherField) => helpers.isMissing(helpers.getNestedValue(otherField, field)));
    }));
  }
  clone() {
    return new _OptionalModifier2(this.#parent.clone(), this.cloneValidations());
  }
  [PARSE2](propertyName, refs, options) {
    const output = this.#parent[PARSE2](propertyName, refs, options);
    if (output.type !== "union") {
      output.isOptional = true;
      output.validations = output.validations.concat(this.compileValidations(refs));
    }
    return output;
  }
};
var BaseType = class extends BaseModifiersType2 {
  options;
  validations;
  constructor(options, validations) {
    super();
    this.options = options || {
      bail: true,
      allowNull: false,
      isOptional: false
    };
    this.validations = validations || [];
  }
  cloneValidations() {
    return this.validations.map((validation) => {
      return {
        options: validation.options,
        rule: validation.rule
      };
    });
  }
  cloneOptions() {
    return { ...this.options };
  }
  compileValidations(refs) {
    return this.validations.map((validation) => {
      return {
        ruleFnId: refs.track({
          validator: validation.rule.validator,
          options: validation.options
        }),
        implicit: validation.rule.implicit,
        isAsync: validation.rule.isAsync
      };
    });
  }
  parse(callback) {
    this.options.parse = callback;
    return this;
  }
  use(validation) {
    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
    return this;
  }
  bail(state) {
    this.options.bail = state;
    return this;
  }
};
var VineTuple = class _VineTuple extends BaseType {
  #schemas;
  #allowUnknownProperties = false;
  [UNIQUE_NAME] = "vine.array";
  [IS_OF_TYPE] = (value) => {
    return Array.isArray(value);
  };
  constructor(schemas, options, validations) {
    super(options, validations);
    this.#schemas = schemas;
  }
  allowUnknownProperties() {
    this.#allowUnknownProperties = true;
    return this;
  }
  clone() {
    const cloned = new _VineTuple(this.#schemas.map((schema3) => schema3.clone()), this.cloneOptions(), this.cloneValidations());
    if (this.#allowUnknownProperties) {
      cloned.allowUnknownProperties();
    }
    return cloned;
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "tuple",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      bail: this.options.bail,
      allowNull: this.options.allowNull,
      isOptional: this.options.isOptional,
      allowUnknownProperties: this.#allowUnknownProperties,
      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
      validations: this.compileValidations(refs),
      properties: this.#schemas.map((schema3, index) => schema3[PARSE2](String(index), refs, options))
    };
  }
};
var minLengthRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length < options.min) {
    field.report(messages["array.minLength"], "array.minLength", field, options);
  }
});
var maxLengthRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length > options.max) {
    field.report(messages["array.maxLength"], "array.maxLength", field, options);
  }
});
var fixedLengthRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length !== options.size) {
    field.report(messages["array.fixedLength"], "array.fixedLength", field, options);
  }
});
var notEmptyRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length <= 0) {
    field.report(messages.notEmpty, "notEmpty", field);
  }
});
var distinctRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isDistinct(value, options.fields)) {
    field.report(messages.distinct, "distinct", field, options);
  }
});
var compactRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(value.filter((item) => helpers.exists(item) && item !== ""), field);
});
var VineArray = class _VineArray extends BaseType {
  static rules = {
    compact: compactRule,
    notEmpty: notEmptyRule,
    distinct: distinctRule,
    minLength: minLengthRule,
    maxLength: maxLengthRule,
    fixedLength: fixedLengthRule
  };
  #schema;
  [UNIQUE_NAME] = "vine.array";
  [IS_OF_TYPE] = (value) => {
    return Array.isArray(value);
  };
  constructor(schema3, options, validations) {
    super(options, validations);
    this.#schema = schema3;
  }
  minLength(expectedLength) {
    return this.use(minLengthRule({ min: expectedLength }));
  }
  maxLength(expectedLength) {
    return this.use(maxLengthRule({ max: expectedLength }));
  }
  fixedLength(expectedLength) {
    return this.use(fixedLengthRule({ size: expectedLength }));
  }
  notEmpty() {
    return this.use(notEmptyRule());
  }
  distinct(fields2) {
    return this.use(distinctRule({ fields: fields2 }));
  }
  compact() {
    return this.use(compactRule());
  }
  clone() {
    return new _VineArray(this.#schema.clone(), this.cloneOptions(), this.cloneValidations());
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "array",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      bail: this.options.bail,
      allowNull: this.options.allowNull,
      isOptional: this.options.isOptional,
      each: this.#schema[PARSE2]("*", refs, options),
      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
      validations: this.compileValidations(refs)
    };
  }
};
var VineCamelCaseObject = class _VineCamelCaseObject extends BaseModifiersType2 {
  #schema;
  [UNIQUE_NAME] = "types.object";
  [IS_OF_TYPE] = (value) => {
    return value !== null && typeof value === "object" && !Array.isArray(value);
  };
  constructor(schema3) {
    super();
    this.#schema = schema3;
  }
  clone() {
    return new _VineCamelCaseObject(this.#schema.clone());
  }
  [PARSE2](propertyName, refs, options) {
    options.toCamelCase = true;
    return this.#schema[PARSE2](propertyName, refs, options);
  }
};
var VineObject = class _VineObject extends BaseType {
  #properties;
  #groups = [];
  #allowUnknownProperties = false;
  [UNIQUE_NAME] = "vine.object";
  [IS_OF_TYPE] = (value) => {
    return value !== null && typeof value === "object" && !Array.isArray(value);
  };
  constructor(properties, options, validations) {
    if (!properties) {
      throw new Error('Missing properties for "vine.object". Use an empty object if you do not want to validate any specific fields');
    }
    super(options, validations);
    this.#properties = properties;
  }
  getProperties() {
    return Object.keys(this.#properties).reduce((result, key) => {
      result[key] = this.#properties[key].clone();
      return result;
    }, {});
  }
  allowUnknownProperties() {
    this.#allowUnknownProperties = true;
    return this;
  }
  merge(group2) {
    this.#groups.push(group2);
    return this;
  }
  clone() {
    const cloned = new _VineObject(this.getProperties(), this.cloneOptions(), this.cloneValidations());
    this.#groups.forEach((group2) => cloned.merge(group2));
    if (this.#allowUnknownProperties) {
      cloned.allowUnknownProperties();
    }
    return cloned;
  }
  toCamelCase() {
    return new VineCamelCaseObject(this);
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "object",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      bail: this.options.bail,
      allowNull: this.options.allowNull,
      isOptional: this.options.isOptional,
      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
      allowUnknownProperties: this.#allowUnknownProperties,
      validations: this.compileValidations(refs),
      properties: Object.keys(this.#properties).map((property) => {
        return this.#properties[property][PARSE2](property, refs, options);
      }),
      groups: this.#groups.map((group2) => {
        return group2[PARSE2](refs, options);
      })
    };
  }
};
var minLengthRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (Object.keys(value).length < options.min) {
    field.report(messages["record.minLength"], "record.minLength", field, options);
  }
});
var maxLengthRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (Object.keys(value).length > options.max) {
    field.report(messages["record.maxLength"], "record.maxLength", field, options);
  }
});
var fixedLengthRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (Object.keys(value).length !== options.size) {
    field.report(messages["record.fixedLength"], "record.fixedLength", field, options);
  }
});
var validateKeysRule = createRule((value, callback, field) => {
  if (!field.isValid) {
    return;
  }
  callback(Object.keys(value), field);
});
var VineRecord = class _VineRecord extends BaseType {
  static rules = {
    maxLength: maxLengthRule2,
    minLength: minLengthRule2,
    fixedLength: fixedLengthRule2,
    validateKeys: validateKeysRule
  };
  #schema;
  [UNIQUE_NAME] = "vine.object";
  [IS_OF_TYPE] = (value) => {
    return value !== null && typeof value === "object" && !Array.isArray(value);
  };
  constructor(schema3, options, validations) {
    super(options, validations);
    this.#schema = schema3;
  }
  minLength(expectedLength) {
    return this.use(minLengthRule2({ min: expectedLength }));
  }
  maxLength(expectedLength) {
    return this.use(maxLengthRule2({ max: expectedLength }));
  }
  fixedLength(expectedLength) {
    return this.use(fixedLengthRule2({ size: expectedLength }));
  }
  validateKeys(...args) {
    return this.use(validateKeysRule(...args));
  }
  clone() {
    return new _VineRecord(this.#schema.clone(), this.cloneOptions(), this.cloneValidations());
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "record",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      bail: this.options.bail,
      allowNull: this.options.allowNull,
      isOptional: this.options.isOptional,
      each: this.#schema[PARSE2]("*", refs, options),
      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
      validations: this.compileValidations(refs)
    };
  }
};
var stringRule = createRule((value, _3, field) => {
  if (typeof value !== "string") {
    field.report(messages.string, "string", field);
  }
});
var emailRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isEmail(value, options)) {
    field.report(messages.email, "email", field);
  }
});
var mobileRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const normalizedOptions = options && typeof options === "function" ? options(field) : options;
  const locales8 = normalizedOptions?.locale || "any";
  if (!helpers.isMobilePhone(value, locales8, normalizedOptions)) {
    field.report(messages.mobile, "mobile", field);
  }
});
var ipAddressRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isIP(value, options?.version)) {
    field.report(messages.ipAddress, "ipAddress", field);
  }
});
var regexRule = createRule((value, expression, field) => {
  if (!field.isValid) {
    return;
  }
  if (!expression.test(value)) {
    field.report(messages.regex, "regex", field);
  }
});
var hexCodeRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isHexColor(value)) {
    field.report(messages.hexCode, "hexCode", field);
  }
});
var urlRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isURL(value, options)) {
    field.report(messages.url, "url", field);
  }
});
var activeUrlRule = createRule(async (value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!await helpers.isActiveURL(value)) {
    field.report(messages.activeUrl, "activeUrl", field);
  }
});
var alphaRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  let characterSet = "a-zA-Z";
  if (options) {
    if (options.allowSpaces) {
      characterSet += "\\s";
    }
    if (options.allowDashes) {
      characterSet += "-";
    }
    if (options.allowUnderscores) {
      characterSet += "_";
    }
  }
  const expression = new RegExp(`^[${characterSet}]+$`);
  if (!expression.test(value)) {
    field.report(messages.alpha, "alpha", field);
  }
});
var alphaNumericRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  let characterSet = "a-zA-Z0-9";
  if (options) {
    if (options.allowSpaces) {
      characterSet += "\\s";
    }
    if (options.allowDashes) {
      characterSet += "-";
    }
    if (options.allowUnderscores) {
      characterSet += "_";
    }
  }
  const expression = new RegExp(`^[${characterSet}]+$`);
  if (!expression.test(value)) {
    field.report(messages.alphaNumeric, "alphaNumeric", field);
  }
});
var minLengthRule3 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length < options.min) {
    field.report(messages.minLength, "minLength", field, options);
  }
});
var maxLengthRule3 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length > options.max) {
    field.report(messages.maxLength, "maxLength", field, options);
  }
});
var fixedLengthRule3 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value.length !== options.size) {
    field.report(messages.fixedLength, "fixedLength", field, options);
  }
});
var endsWithRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!value.endsWith(options.substring)) {
    field.report(messages.endsWith, "endsWith", field, options);
  }
});
var startsWithRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!value.startsWith(options.substring)) {
    field.report(messages.startsWith, "startsWith", field, options);
  }
});
var sameAsRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const input = helpers.getNestedValue(options.otherField, field);
  if (input !== value) {
    field.report(messages.sameAs, "sameAs", field, options);
    return;
  }
});
var notSameAsRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const input = helpers.getNestedValue(options.otherField, field);
  if (input === value) {
    field.report(messages.notSameAs, "notSameAs", field, options);
    return;
  }
});
var confirmedRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const otherField = options?.confirmationField || `${field.name}_confirmation`;
  const input = field.parent[otherField];
  if (input !== value) {
    field.report(messages.confirmed, "confirmed", field, { otherField });
    return;
  }
});
var trimRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(value.trim(), field);
});
var normalizeEmailRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(import_normalizeEmail.default.default(value, options), field);
});
var toUpperCaseRule = createRule((value, locales8, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(value.toLocaleUpperCase(locales8), field);
});
var toLowerCaseRule = createRule((value, locales8, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(value.toLocaleLowerCase(locales8), field);
});
var toCamelCaseRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(camelCase2(value), field);
});
var escapeRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(import_escape.default.default(value), field);
});
var normalizeUrlRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  field.mutate(normalizeUrl(value, options), field);
});
var inRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const choices = typeof options.choices === "function" ? options.choices(field) : options.choices;
  if (!choices.includes(value)) {
    field.report(messages.in, "in", field, options);
    return;
  }
});
var notInRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const list = typeof options.list === "function" ? options.list(field) : options.list;
  if (list.includes(value)) {
    field.report(messages.notIn, "notIn", field, options);
    return;
  }
});
var creditCardRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const providers = options ? typeof options === "function" ? options(field)?.provider || [] : options.provider : [];
  if (!providers.length) {
    if (!helpers.isCreditCard(value)) {
      field.report(messages.creditCard, "creditCard", field, {
        providersList: "credit"
      });
    }
  } else {
    const matchesAnyProvider = providers.find((provider) => helpers.isCreditCard(value, { provider }));
    if (!matchesAnyProvider) {
      field.report(messages.creditCard, "creditCard", field, {
        providers,
        providersList: providers.join("/")
      });
    }
  }
});
var passportRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const countryCodes = typeof options === "function" ? options(field).countryCode : options.countryCode;
  const matchesAnyCountryCode = countryCodes.find((countryCode) => helpers.isPassportNumber(value, countryCode));
  if (!matchesAnyCountryCode) {
    field.report(messages.passport, "passport", field, { countryCodes });
  }
});
var postalCodeRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  const countryCodes = options ? typeof options === "function" ? options(field)?.countryCode || [] : options.countryCode : [];
  if (!countryCodes.length) {
    if (!helpers.isPostalCode(value, "any")) {
      field.report(messages.postalCode, "postalCode", field);
    }
  } else {
    const matchesAnyCountryCode = countryCodes.find((countryCode) => helpers.isPostalCode(value, countryCode));
    if (!matchesAnyCountryCode) {
      field.report(messages.postalCode, "postalCode", field, { countryCodes });
    }
  }
});
var uuidRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!options || !options.version) {
    if (!helpers.isUUID(value)) {
      field.report(messages.uuid, "uuid", field);
    }
  } else {
    const matchesAnyVersion = options.version.find((version) => helpers.isUUID(value, version));
    if (!matchesAnyVersion) {
      field.report(messages.uuid, "uuid", field, options);
    }
  }
});
var ulidRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isULID(value)) {
    field.report(messages.ulid, "ulid", field);
  }
});
var asciiRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isAscii(value)) {
    field.report(messages.ascii, "ascii", field);
  }
});
var ibanRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isIBAN(value)) {
    field.report(messages.iban, "iban", field);
  }
});
var jwtRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isJWT(value)) {
    field.report(messages.jwt, "jwt", field);
  }
});
var coordinatesRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isLatLong(value)) {
    field.report(messages.coordinates, "coordinates", field);
  }
});
var VineString = class _VineString extends BaseLiteralType {
  static rules = {
    in: inRule,
    jwt: jwtRule,
    url: urlRule,
    iban: ibanRule,
    uuid: uuidRule,
    ulid: ulidRule,
    trim: trimRule,
    email: emailRule,
    alpha: alphaRule,
    ascii: asciiRule,
    notIn: notInRule,
    regex: regexRule,
    escape: escapeRule,
    sameAs: sameAsRule2,
    mobile: mobileRule,
    string: stringRule,
    hexCode: hexCodeRule,
    passport: passportRule,
    endsWith: endsWithRule,
    confirmed: confirmedRule,
    activeUrl: activeUrlRule,
    minLength: minLengthRule3,
    notSameAs: notSameAsRule2,
    maxLength: maxLengthRule3,
    ipAddress: ipAddressRule,
    creditCard: creditCardRule,
    postalCode: postalCodeRule,
    startsWith: startsWithRule,
    toUpperCase: toUpperCaseRule,
    toLowerCase: toLowerCaseRule,
    toCamelCase: toCamelCaseRule,
    fixedLength: fixedLengthRule3,
    coordinates: coordinatesRule,
    normalizeUrl: normalizeUrlRule,
    alphaNumeric: alphaNumericRule,
    normalizeEmail: normalizeEmailRule
  };
  [SUBTYPE] = "string";
  [UNIQUE_NAME] = "vine.string";
  [IS_OF_TYPE] = (value) => {
    return typeof value === "string";
  };
  constructor(options, validations) {
    super(options, validations || [stringRule()]);
  }
  url(...args) {
    return this.use(urlRule(...args));
  }
  activeUrl() {
    return this.use(activeUrlRule());
  }
  email(...args) {
    return this.use(emailRule(...args));
  }
  mobile(...args) {
    return this.use(mobileRule(...args));
  }
  ipAddress(version) {
    return this.use(ipAddressRule(version ? { version } : undefined));
  }
  hexCode() {
    return this.use(hexCodeRule());
  }
  regex(expression) {
    return this.use(regexRule(expression));
  }
  alpha(options) {
    return this.use(alphaRule(options));
  }
  alphaNumeric(options) {
    return this.use(alphaNumericRule(options));
  }
  minLength(expectedLength) {
    return this.use(minLengthRule3({ min: expectedLength }));
  }
  maxLength(expectedLength) {
    return this.use(maxLengthRule3({ max: expectedLength }));
  }
  fixedLength(expectedLength) {
    return this.use(fixedLengthRule3({ size: expectedLength }));
  }
  confirmed(options) {
    return this.use(confirmedRule(options));
  }
  trim() {
    return this.use(trimRule());
  }
  normalizeEmail(options) {
    return this.use(normalizeEmailRule(options));
  }
  toUpperCase() {
    return this.use(toUpperCaseRule());
  }
  toLowerCase() {
    return this.use(toLowerCaseRule());
  }
  toCamelCase() {
    return this.use(toCamelCaseRule());
  }
  escape() {
    return this.use(escapeRule());
  }
  normalizeUrl(...args) {
    return this.use(normalizeUrlRule(...args));
  }
  startsWith(substring) {
    return this.use(startsWithRule({ substring }));
  }
  endsWith(substring) {
    return this.use(endsWithRule({ substring }));
  }
  sameAs(otherField) {
    return this.use(sameAsRule2({ otherField }));
  }
  notSameAs(otherField) {
    return this.use(notSameAsRule2({ otherField }));
  }
  in(choices) {
    return this.use(inRule({ choices }));
  }
  notIn(list) {
    return this.use(notInRule({ list }));
  }
  creditCard(...args) {
    return this.use(creditCardRule(...args));
  }
  passport(...args) {
    return this.use(passportRule(...args));
  }
  postalCode(...args) {
    return this.use(postalCodeRule(...args));
  }
  uuid(...args) {
    return this.use(uuidRule(...args));
  }
  ulid() {
    return this.use(ulidRule());
  }
  ascii() {
    return this.use(asciiRule());
  }
  iban() {
    return this.use(ibanRule());
  }
  jwt() {
    return this.use(jwtRule());
  }
  coordinates() {
    return this.use(coordinatesRule());
  }
  clone() {
    return new _VineString(this.cloneOptions(), this.cloneValidations());
  }
};
var numberRule = createRule((value, options, field) => {
  const valueAsNumber = options.strict ? value : helpers.asNumber(value);
  if (typeof valueAsNumber !== "number" || Number.isNaN(valueAsNumber) || valueAsNumber === Number.POSITIVE_INFINITY || valueAsNumber === Number.NEGATIVE_INFINITY) {
    field.report(messages.number, "number", field);
    return;
  }
  field.mutate(valueAsNumber, field);
});
var minRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value < options.min) {
    field.report(messages.min, "min", field, options);
  }
});
var maxRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value > options.max) {
    field.report(messages.max, "max", field, options);
  }
});
var rangeRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (value < options.min || value > options.max) {
    field.report(messages.range, "range", field, options);
  }
});
var positiveRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (value < 0) {
    field.report(messages.positive, "positive", field);
  }
});
var negativeRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (value >= 0) {
    field.report(messages.negative, "negative", field);
  }
});
var decimalRule = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!helpers.isDecimal(String(value), {
    force_decimal: options.range[0] !== 0,
    decimal_digits: options.range.join(",")
  })) {
    field.report(messages.decimal, "decimal", field, { digits: options.range.join("-") });
  }
});
var withoutDecimalsRule = createRule((value, _3, field) => {
  if (!field.isValid) {
    return;
  }
  if (!Number.isInteger(value)) {
    field.report(messages.withoutDecimals, "withoutDecimals", field);
  }
});
var inRule2 = createRule((value, options, field) => {
  if (!field.isValid) {
    return;
  }
  if (!options.values.includes(value)) {
    field.report(messages["number.in"], "in", field, options);
  }
});
var VineNumber = class _VineNumber extends BaseLiteralType {
  static rules = {
    in: inRule2,
    max: maxRule,
    min: minRule,
    range: rangeRule,
    number: numberRule,
    decimal: decimalRule,
    negative: negativeRule,
    positive: positiveRule,
    withoutDecimals: withoutDecimalsRule
  };
  [SUBTYPE] = "number";
  [UNIQUE_NAME] = "vine.number";
  [IS_OF_TYPE] = (value) => {
    const valueAsNumber = helpers.asNumber(value);
    return !Number.isNaN(valueAsNumber);
  };
  constructor(options, validations) {
    super(options, validations || [numberRule(options || {})]);
  }
  min(value) {
    return this.use(minRule({ min: value }));
  }
  max(value) {
    return this.use(maxRule({ max: value }));
  }
  range(value) {
    return this.use(rangeRule({ min: value[0], max: value[1] }));
  }
  positive() {
    return this.use(positiveRule());
  }
  negative() {
    return this.use(negativeRule());
  }
  decimal(range) {
    return this.use(decimalRule({ range: Array.isArray(range) ? range : [range] }));
  }
  withoutDecimals() {
    return this.use(withoutDecimalsRule());
  }
  clone() {
    return new _VineNumber(this.cloneOptions(), this.cloneValidations());
  }
  in(values) {
    return this.use(inRule2({ values }));
  }
};
var booleanRule = createRule((value, options, field) => {
  const valueAsBoolean = options.strict === true ? value : helpers.asBoolean(value);
  if (typeof valueAsBoolean !== "boolean") {
    field.report(messages.boolean, "boolean", field);
    return;
  }
  field.mutate(valueAsBoolean, field);
});
var VineBoolean = class _VineBoolean extends BaseLiteralType {
  static rules = {
    boolean: booleanRule
  };
  [SUBTYPE] = "boolean";
  [UNIQUE_NAME] = "vine.boolean";
  [IS_OF_TYPE] = (value) => {
    const valueAsBoolean = this.options.strict === true ? value : helpers.asBoolean(value);
    return typeof valueAsBoolean === "boolean";
  };
  constructor(options, validations) {
    super(options, validations || [booleanRule(options || {})]);
  }
  clone() {
    return new _VineBoolean(this.cloneOptions(), this.cloneValidations());
  }
};
var equalsRule2 = createRule((value, options, field) => {
  let input = value;
  if (typeof options.expectedValue === "boolean") {
    input = helpers.asBoolean(value);
  } else if (typeof options.expectedValue === "number") {
    input = helpers.asNumber(value);
  }
  if (input !== options.expectedValue) {
    field.report(messages.literal, "literal", field, options);
    return;
  }
  field.mutate(input, field);
});
var VineLiteral = class _VineLiteral extends BaseLiteralType {
  static rules = {
    equals: equalsRule2
  };
  #value;
  [SUBTYPE] = "literal";
  constructor(value, options, validations) {
    super(options, validations || [equalsRule2({ expectedValue: value })]);
    this.#value = value;
  }
  clone() {
    return new _VineLiteral(this.#value, this.cloneOptions(), this.cloneValidations());
  }
};
var ACCEPTED_VALUES = ["on", "1", "yes", "true", true, 1];
var acceptedRule = createRule((value, _3, field) => {
  if (!ACCEPTED_VALUES.includes(value)) {
    field.report(messages.accepted, "accepted", field);
  }
});
var VineAccepted = class _VineAccepted extends BaseLiteralType {
  static rules = {
    accepted: acceptedRule
  };
  [SUBTYPE] = "checkbox";
  constructor(options, validations) {
    super(options, validations || [acceptedRule()]);
  }
  clone() {
    return new _VineAccepted(this.cloneOptions(), this.cloneValidations());
  }
};
var ObjectGroup = class _ObjectGroup {
  #conditionals;
  #otherwiseCallback = (_3, field) => {
    field.report(messages.unionGroup, "unionGroup", field);
  };
  constructor(conditionals) {
    this.#conditionals = conditionals;
  }
  clone() {
    const cloned = new _ObjectGroup(this.#conditionals);
    cloned.otherwise(this.#otherwiseCallback);
    return cloned;
  }
  otherwise(callback) {
    this.#otherwiseCallback = callback;
    return this;
  }
  [PARSE2](refs, options) {
    return {
      type: "group",
      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),
      conditions: this.#conditionals.map((conditional) => conditional[PARSE2](refs, options))
    };
  }
};
var GroupConditional = class {
  #properties;
  #conditional;
  constructor(conditional, properties) {
    this.#properties = properties;
    this.#conditional = conditional;
  }
  [PARSE2](refs, options) {
    return {
      schema: {
        type: "sub_object",
        properties: Object.keys(this.#properties).map((property) => {
          return this.#properties[property][PARSE2](property, refs, options);
        }),
        groups: []
      },
      conditionalFnRefId: refs.trackConditional(this.#conditional)
    };
  }
};
function group(conditionals) {
  return new ObjectGroup(conditionals);
}
group.if = function groupIf(conditon, properties) {
  return new GroupConditional(conditon, properties);
};
group.else = function groupElse(properties) {
  return new GroupConditional(() => true, properties);
};
var VineNativeEnum = class _VineNativeEnum extends BaseLiteralType {
  static rules = {
    enum: enumRule
  };
  #values;
  [SUBTYPE] = "enum";
  constructor(values, options, validations) {
    super(options, validations || [enumRule({ choices: Object.values(values) })]);
    this.#values = values;
  }
  clone() {
    return new _VineNativeEnum(this.#values, this.cloneOptions(), this.cloneValidations());
  }
};
var VineUnionOfTypes = class _VineUnionOfTypes {
  #schemas;
  #otherwiseCallback = (_3, field) => {
    field.report(messages.unionOfTypes, "unionOfTypes", field);
  };
  constructor(schemas) {
    this.#schemas = schemas;
  }
  otherwise(callback) {
    this.#otherwiseCallback = callback;
    return this;
  }
  clone() {
    const cloned = new _VineUnionOfTypes(this.#schemas);
    cloned.otherwise(this.#otherwiseCallback);
    return cloned;
  }
  [PARSE2](propertyName, refs, options) {
    return {
      type: "union",
      fieldName: propertyName,
      propertyName: options.toCamelCase ? camelCase2(propertyName) : propertyName,
      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),
      conditions: this.#schemas.map((schema3) => {
        return {
          conditionalFnRefId: refs.trackConditional((value, field) => {
            return schema3[IS_OF_TYPE](value, field);
          }),
          schema: schema3[PARSE2](propertyName, refs, options)
        };
      })
    };
  }
};
var SchemaBuilder = class extends Macroable {
  group = group;
  union = union;
  string() {
    return new VineString;
  }
  boolean(options) {
    return new VineBoolean(options);
  }
  accepted() {
    return new VineAccepted;
  }
  number(options) {
    return new VineNumber(options);
  }
  date(options) {
    return new VineDate(options);
  }
  literal(value) {
    return new VineLiteral(value);
  }
  object(properties) {
    return new VineObject(properties);
  }
  array(schema3) {
    return new VineArray(schema3);
  }
  tuple(schemas) {
    return new VineTuple(schemas);
  }
  record(schema3) {
    return new VineRecord(schema3);
  }
  enum(values) {
    if (Array.isArray(values) || typeof values === "function") {
      return new VineEnum(values);
    }
    return new VineNativeEnum(values);
  }
  any() {
    return new VineAny;
  }
  unionOfTypes(schemas) {
    const schemasInUse = /* @__PURE__ */ new Set;
    schemas.forEach((schema3) => {
      if (!schema3[IS_OF_TYPE] || !schema3[UNIQUE_NAME]) {
        throw new Error(`Cannot use "${schema3.constructor.name}". The schema type is not compatible for use with "vine.unionOfTypes"`);
      }
      if (schemasInUse.has(schema3[UNIQUE_NAME])) {
        throw new Error(`Cannot use duplicate schema "${schema3[UNIQUE_NAME]}". "vine.unionOfTypes" needs distinct schema types only`);
      }
      schemasInUse.add(schema3[UNIQUE_NAME]);
    });
    schemasInUse.clear();
    return new VineUnionOfTypes(schemas);
  }
};
var COMPILER_ERROR_MESSAGES = {
  required: messages.required,
  array: messages.array,
  object: messages.object
};
var VineValidator = class {
  #compiled;
  messagesProvider;
  errorReporter;
  #parse(schema3) {
    const refs = refsBuilder();
    return {
      compilerNode: {
        type: "root",
        schema: schema3[PARSE2]("", refs, { toCamelCase: false })
      },
      refs: refs.toJSON()
    };
  }
  constructor(schema3, options) {
    const { compilerNode, refs } = this.#parse(schema3);
    this.#compiled = { schema: compilerNode, refs };
    const metaDataValidator = options.metaDataValidator;
    const validateFn = new Compiler(compilerNode, {
      convertEmptyStringsToNull: options.convertEmptyStringsToNull,
      messages: COMPILER_ERROR_MESSAGES
    }).compile();
    this.errorReporter = options.errorReporter;
    this.messagesProvider = options.messagesProvider;
    if (metaDataValidator) {
      this.validate = (data, validateOptions) => {
        let normalizedOptions = validateOptions ?? {};
        const meta = normalizedOptions.meta ?? {};
        const errorReporter = normalizedOptions.errorReporter ?? this.errorReporter;
        const messagesProvider = normalizedOptions.messagesProvider ?? this.messagesProvider;
        metaDataValidator(meta);
        return validateFn(data, meta, refs, messagesProvider, errorReporter());
      };
    } else {
      this.validate = (data, validateOptions) => {
        let normalizedOptions = validateOptions ?? {};
        const meta = normalizedOptions.meta ?? {};
        const errorReporter = normalizedOptions.errorReporter ?? this.errorReporter;
        const messagesProvider = normalizedOptions.messagesProvider ?? this.messagesProvider;
        return validateFn(data, meta, refs, messagesProvider, errorReporter());
      };
    }
  }
  async tryValidate(data, ...[options]) {
    try {
      const result = await this.validate(data, options);
      return [null, result];
    } catch (error) {
      if (error instanceof ValidationError) {
        return [error, null];
      }
      throw error;
    }
  }
  toJSON() {
    const { schema: schema3, refs } = this.#compiled;
    return {
      schema: structuredClone(schema3),
      refs
    };
  }
};
var Vine = class extends SchemaBuilder {
  messagesProvider = new SimpleMessagesProvider(messages, fields);
  errorReporter = () => new SimpleErrorReporter;
  convertEmptyStringsToNull = false;
  helpers = helpers;
  createRule = createRule;
  compile(schema3) {
    return new VineValidator(schema3, {
      convertEmptyStringsToNull: this.convertEmptyStringsToNull,
      messagesProvider: this.messagesProvider,
      errorReporter: this.errorReporter
    });
  }
  withMetaData(callback) {
    return {
      compile: (schema3) => {
        return new VineValidator(schema3, {
          convertEmptyStringsToNull: this.convertEmptyStringsToNull,
          messagesProvider: this.messagesProvider,
          errorReporter: this.errorReporter,
          metaDataValidator: callback
        });
      }
    };
  }
  validate(options) {
    const validator = this.compile(options.schema);
    return validator.validate(options.data, options);
  }
  tryValidate(options) {
    const validator = this.compile(options.schema);
    return validator.tryValidate(options.data, options);
  }
};
var vine = new Vine;
// ../validation/src/validator.ts
import { HttpError as HttpError54 } from "@stacksjs/error-handling";
import { path as path13 } from "@stacksjs/path";
import { globSync as globSync7 } from "@stacksjs/storage";
function isObjectNotEmpty(obj) {
  if (obj === undefined)
    return false;
  return Object.keys(obj).length > 0;
}
async function customValidate(attributes, params) {
  const ruleObject = {};
  const messageObject = {};
  for (const key in attributes) {
    if (Object.prototype.hasOwnProperty.call(attributes, key)) {
      const rule = attributes[key]?.rule;
      if (rule)
        ruleObject[key] = rule;
      const validatorMessages = attributes[key]?.message;
      for (const validatorMessageKey in validatorMessages) {
        const validatorMessageString = `${key}.${validatorMessageKey}`;
        messageObject[validatorMessageString] = attributes[key]?.message[validatorMessageKey] || "";
      }
    }
  }
  try {
    const validator = schema2.object().shape(ruleObject);
    const result = await validator.validate(params);
    if (!result.valid)
      throw new HttpError54(422, JSON.stringify(result.errors));
    return result;
  } catch (error) {
    if (error instanceof HttpError54)
      throw error;
  }
}
// ../orm/src/generate.ts
function generateCustomAccessors(model) {
  let output = "";
  if (model.get) {
    for (const [methodName, getter] of Object.entries(model.get)) {
      const getterStr = getter.toString();
      output += removeAttrString(`${methodName}: ${getterStr}, 
`);
    }
  }
  return output;
}
function generateCustomSetters(model) {
  let output = "";
  if (model.set) {
    for (const [methodName, setter] of Object.entries(model.set)) {
      const setterStr = setter.toString();
      output += removeAttrString(`${methodName}: ${setterStr}, 
`);
    }
  }
  return output;
}
function removeAttrString(getterFn) {
  let result = getterFn.replace("(attributes)", "()");
  result = result.replace(/attributes/g, "model");
  return result;
}
function getUpvoteTableName2(model, tableName) {
  const defaultTable = `${tableName}_likes`;
  const traits2 = model.traits;
  return typeof traits2?.likeable === "object" ? traits2.likeable.table || defaultTable : defaultTable;
}
function getUpvoteForeignKey(model, modelName) {
  const defaultForeignKey = `${snakeCase(modelName)}_id`;
  const traits2 = model.traits;
  return typeof traits2?.likeable === "object" ? traits2.likeable.foreignKey || defaultForeignKey : defaultForeignKey;
}
async function generateModelString(tableName, modelName, model, attributes, imports = []) {
  const formattedTableName = pascalCase(tableName);
  const formattedModelName = camelCase(modelName);
  const importsString = `${imports.join(`
`)}

`;
  let instanceSoftDeleteStatements = "";
  let instanceSoftDeleteStatementsSelectFrom = "";
  let instanceSoftDeleteStatementsUpdateFrom = "";
  let thisSoftDeleteStatementsUpdateFrom = "";
  let getFields = "";
  let setFields = "";
  let jsonFields = `{
`;
  let jsonRelations = "";
  let uuidQuery = "";
  let whereStatements = "";
  let whereFunctionStatements = "";
  let relationMethods = "";
  let relationImports = "";
  let paymentImports = "";
  let categorizableImports = "";
  let commentablesImports = "";
  let taggableImports = "";
  let twoFactorStatements = "";
  let billableStatements = "";
  let likeableStatements = "";
  let displayableStatements = "";
  let removeInstanceStatment = "";
  let mittCreateStatement = "";
  let mittUpdateStatement = "";
  let mittDeleteStatement = "";
  let mittDeleteStaticFindStatement = "";
  let mittDeleteFindStatement = "";
  let privateSoftDeletes = "";
  const getterOutput = await generateCustomAccessors(model);
  const setterOutput = await generateCustomSetters(model);
  const relations = await getRelations(model, modelName);
  for (const relationInstance of relations)
    relationImports += `import type {${relationInstance.model}Model} from './${relationInstance.model}'

`;
  const useTimestamps = model?.traits?.useTimestamps ?? model?.traits?.timestampable ?? true;
  const useSocials = model?.traits?.useSocials && Array.isArray(model.traits.useSocials) && model.traits.useSocials.length > 0;
  const useSoftDeletes = model?.traits?.useSoftDeletes ?? model?.traits?.softDeletable ?? false;
  const observer = model?.traits?.observe;
  const useUuid = model?.traits?.useUuid || false;
  const useCommentables = model?.traits?.commentables || false;
  if (useUuid)
    uuidQuery += `filteredValues['uuid'] = randomUUIDv7()`;
  if (useSoftDeletes) {
    privateSoftDeletes = `private softDeletes = false`;
    instanceSoftDeleteStatements += `if (instance.softDeletes) {
        query = query.where('deleted_at', 'is', null)
      }`;
    instanceSoftDeleteStatementsSelectFrom += ` if (instance.softDeletes) {
        instance.selectFromQuery = instance.selectFromQuery.where('deleted_at', 'is', null)
      }`;
    instanceSoftDeleteStatementsUpdateFrom += `
        const instance = new ${modelName}Model(undefined)

        if (instance.softDeletes) {
          return await DB.instance.updateTable('${tableName}')
          .set({
            deleted_at: sql.raw('CURRENT_TIMESTAMP'),
          })
          .where('id', '=', id)
          .execute()
        }
      `;
    thisSoftDeleteStatementsUpdateFrom += `if (this.softDeletes) {
        return await DB.instance.updateTable('${tableName}')
        .set({
            deleted_at: sql.raw('CURRENT_TIMESTAMP')
        })
        .where('id', '=', this.id)
        .execute()
      }`;
  }
  if (typeof observer === "boolean") {
    if (observer) {
      removeInstanceStatment += `const instance = new ${modelName}Model(undefined)`;
      mittCreateStatement += `if (model)
 dispatch('${formattedModelName}:created', model)`;
      mittUpdateStatement += `if (model)
 dispatch('${formattedModelName}:updated', model)`;
      mittDeleteStatement += `if (model)
 dispatch('${formattedModelName}:deleted', model)`;
      mittDeleteStaticFindStatement += "const model = await instance.find(Number(id))";
      mittDeleteFindStatement += "const model = await this.find(Number(this.id))";
    }
  }
  if (Array.isArray(observer)) {
    removeInstanceStatment += `const instance = new ${modelName}Model(undefined)`;
    if (observer.includes("create")) {
      mittCreateStatement += `if (model)
 dispatch('${formattedModelName}:created', model);`;
    }
    if (observer.includes("update")) {
      mittUpdateStatement += `if (model)
 dispatch('${formattedModelName}:updated', model);`;
    }
    if (observer.includes("delete")) {
      mittDeleteStaticFindStatement += "const model = await instance.find(id)";
      mittDeleteStatement += `if (model)
 dispatch('${formattedModelName}:deleted', model);`;
    }
  }
  if (useCommentables) {
    commentablesImports += `import type { CommentablesTable } from '@stacksjs/orm'
`;
    relationMethods += `
      async comments(id: number): Promise<CommentablesTable[]> {
        return await this.baseComments(id)
      }

      async commentCount(id: number): Promise<number> {
        return await this.baseCommentCount(id)
      }

      async addComment(id: number, comment: { title: string, body: string }): Promise<any> {
        return await this.baseAddComment(id, comment)
      }

      async approvedComments(id: number): Promise<CommentablesTable[]> {
        return await this.baseApprovedComments(id)
      }

      async pendingComments(id: number): Promise<CommentablesTable[]> {
        return await this.basePendingComments(id)
      }

      async rejectedComments(id: number): Promise<CommentablesTable[]> {
        return await this.baseRejectedComments(id)
      }
    `;
  }
  if (model.traits?.taggable) {
    taggableImports += `import type { TaggableTable } from '@stacksjs/orm'
`;
    relationMethods += `
      async tags(id: number): Promise<TaggableTable[]> {
        return await this.baseTags(id)
      }

      async tagCount(id: number): Promise<number> {
        return await this.baseTagCount(id)
      }

      async addTag(id: number, tag: { name: string, description?: string }): Promise<TaggableTable> {
        return await this.baseAddTag(id, tag)
      }

      async activeTags(id: number): Promise<TaggableTable[]> {
        return await this.baseActiveTags(id)
      }

      async inactiveTags(id: number): Promise<TaggableTable[]> {
        return await this.baseInactiveTags(id)
      }

      async removeTag(id: number, tagId: number): Promise<void> {
        await this.baseRemoveTag(id, tagId)
      }
    `;
  }
  if (model.traits?.categorizable) {
    categorizableImports += `import type { CategorizableTable } from '@stacksjs/orm'
`;
    relationMethods += `
      async categories(id: number): Promise<CategorizableTable[]> {
        return await this.baseCategories(id)
      }

      async categoryCount(id: number): Promise<number> {
        return await this.baseCategoryCount(id)
      }

      async addCategory(id: number, category: { name: string, description?: string, parent_id?: number }): Promise<CategorizableTable> {
        return await this.baseAddCategory(id, category)
      }

      async activeCategories(id: number): Promise<CategorizableTable[]> {
        return await this.baseActiveCategories(id)
      }

      async inactiveCategories(id: number): Promise<CategorizableTable[]> {
        return await this.baseInactiveCategories(id)
      }

      async removeCategory(categoryId: number): Promise<void> {
        await this.baseRemoveCategory(categoryId)
      }
    `;
  }
  for (const relation of relations) {
    const modelRelation = relation.model;
    const foreignKeyRelation = relation.foreignKey;
    const modelKeyRelation = relation.modelKey;
    const tableRelation = relation.table || "";
    const pivotTableRelation = relation.pivotTable;
    const formattedModelRelation = camelCase(modelRelation);
    const relationType = getRelationType(relation.relationship);
    const relationCount = getRelationCount(relation.relationship);
    if (relationType === "throughType") {
      const relationName = relation.relationName || formattedModelName + modelRelation;
      const throughRelation = relation.throughModel;
      if (relation.throughModel === undefined)
        continue;
      const formattedThroughRelation = relation?.throughModel?.toLowerCase();
      const throughTableRelation = throughRelation;
      const foreignKeyThroughRelation = relation.throughForeignKey || `${formattedThroughRelation}_id`;
      relationMethods += `
        async ${relationName}() {
          if (this.id === undefined)
            throw new HttpError(500, 'Relation Error!')

          const firstModel = await DB.instance.selectFrom('${throughTableRelation}')
            .where('${foreignKeyRelation}', '=', this.id)
            .selectAll()
            .executeTakeFirst()

          if (! firstModel)
            throw new HttpError(500, 'Model Relation Not Found!')

          const finalModel = ${modelRelation}
            .where('${foreignKeyThroughRelation}', '=', firstModel.id)
            .first()

          return new ${modelRelation}.modelInstance(finalModel)
        }

`;
    }
    if (relationType === "hasType" && relationCount === "many") {
      const relationName = camelCase(relation.relationName || tableRelation);
      getFields += `get ${snakeCase(relationName)}():${modelRelation}Model[] | [] {
        return this.attributes.${snakeCase(relationName)}
      }

`;
      jsonRelations += `${snakeCase(relationName)}: this.${snakeCase(relationName)},
`;
    }
    if (relationType === "morphType" && relationCount === "one") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      getFields += `get ${snakeCase(morphName)}():${modelRelation}Model | undefined {
        return this.attributes.${snakeCase(morphName)}
      }

`;
      jsonRelations += `${snakeCase(morphName)}: this.${snakeCase(morphName)},
`;
      relationMethods += `
        async ${morphName}(): Promise<${modelRelation}Model | undefined> {
          if (this.id === undefined)
            throw new HttpError(500, 'Relation Error!')

          const model = await ${modelRelation}
            .where('${relation.modelKey}', '=', '${modelName}')
            .where('${relation.foreignKey}', '=', this.id)
            .first()

          if (!model)
            return undefined

          return model
        }

`;
    }
    if (relationType === "morphType" && relationCount === "many") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      getFields += `get ${snakeCase(morphName)}():${modelRelation}Model[] | [] {
        return this.attributes.${snakeCase(morphName)}
      }

`;
      jsonRelations += `${snakeCase(morphName)}: this.${snakeCase(morphName)},
`;
      relationMethods += `
        async ${morphName}(): Promise<${modelRelation}Model[]> {
          if (this.id === undefined)
            throw new HttpError(500, 'Relation Error!')

          const models = await ${modelRelation}
            .where('${relation.modelKey}', '=', '${modelName}')
            .where('${relation.foreignKey}', '=', this.id)
            .get()

          if (!models || !models.length)
            return []

          return models
        }

`;
    }
    if (relationType === "hasType" && relationCount === "one") {
      const relationName = relation.relationName || formattedModelRelation;
      getFields += `get ${snakeCase(relationName)}():${modelRelation}Model | undefined {
        return this.attributes.${snakeCase(relationName)}
      }

`;
    }
    if (relationType === "belongsType" && !relationCount) {
      const relationName = camelCase(relation.relationName || formattedModelRelation);
      getFields += `get ${relation.modelKey}(): number {
        return this.attributes.${relation.modelKey}
      }

`;
      jsonRelations += `${relation.modelKey}: this.${relation.modelKey},
   `;
      getFields += `get ${snakeCase(relationName)}(): ${modelRelation}Model | undefined {
        return this.attributes.${snakeCase(relationName)}
      }

`;
      jsonRelations += `${snakeCase(relationName)}: this.${snakeCase(relationName)},
`;
      relationMethods += `
        async ${relationName}Belong(): Promise<${modelRelation}Model> {
          if (this.${modelKeyRelation} === undefined)
            throw new HttpError(500, 'Relation Error!')

          const model = await ${modelRelation}
            .where('id', '=', this.${modelKeyRelation})
            .first()

          if (! model)
            throw new HttpError(500, 'Model Relation Not Found!')

          return model
        }

`;
    }
    if (relationType === "belongsType" && relationCount === "many") {
      const pivotTable = pivotTableRelation || tableRelation;
      const pivotKey = relation.pivotKey || tableRelation;
      const relationName = relation.relationName || formattedModelName + plural(pascalCase(modelRelation));
      relationMethods += `
        async ${relationName}() {
          if (this.id === undefined)
            throw new HttpError(500, 'Relation Error!')

          const results = await DB.instance.selectFrom('${pivotTable}')
            .where('${pivotKey}', '=', this.id)
            .selectAll()
            .execute()

            const tableRelationIds = results.map((result: { ${singular(tableRelation)}_id: number }) => result.${singular(tableRelation)}_id)

            if (! tableRelationIds.length)
              throw new HttpError(500, 'Relation Error!')

            const relationResults = await ${modelRelation}.whereIn('id', tableRelationIds).get()

            return relationResults
        }

`;
    }
  }
  getFields += `get id(): number {
    return this.attributes.id
  }

`;
  const useTwoFactor = typeof model.traits?.useAuth === "object" && model.traits.useAuth.useTwoFactor;
  const usePasskey = typeof model.traits?.useAuth === "object" && model.traits.useAuth.usePasskey;
  const useBillable = model.traits?.billable || false;
  const useLikeable = model.traits?.likeable || false;
  const useSearchable = model.traits?.useSearch || false;
  const displayableAttributes = typeof model.traits?.useSearch === "object" && model.traits?.useSearch.displayable;
  const likeableTable = getUpvoteTableName2(model, tableName);
  const likeableForeignKey = getUpvoteForeignKey(model, modelName);
  const searchableStatements = "";
  if (typeof useSearchable === "object" && useSearchable) {
    const searchAttrs = Array.isArray(displayableAttributes) ? displayableAttributes : [];
    displayableStatements = `
      toSearchableObject(): Partial<${modelName}JsonResponse> {
        return {
          ${searchAttrs.map((attr) => `${snakeCase(attr)}: this.${snakeCase(attr)}`).join(`,
`)}
        }
      }
    `;
  }
  if (useLikeable) {
    likeableStatements += `
      async getLikeCount(): Promise<number> {
        const result = await DB.instance
          .selectFrom('${likeableTable}')
          .select('count(*) as count')
          .where('${likeableForeignKey}', '=', this.id)
          .executeTakeFirst()

        return Number(result?.count) || 0
      }



      async likes(): Promise<number> {
        return this.getLikeCount()
      }



      async like(userId: number): Promise<void> {
        const authUserId = userId || 1

        await DB.instance
          .insertInto('${likeableTable}')
          .values({
            ${likeableForeignKey}: this.id,
            user_id: authUserId
          })
        .execute()
      }



      async unlike(userId: number): Promise<void> {
        const authUserId = userId || 1
        await DB.instance
          .deleteFrom('${likeableTable}')
          .where('${likeableForeignKey}', '=', this.id)
          .where('user_id', '=', authUserId)
          .execute()
      }



      async isLiked(userId: number): Promise<boolean> {
        const authUserId = userId || 1

        const like = await DB.instance
          .selectFrom('${likeableTable}')
          .select('id')
          .where('${likeableForeignKey}', '=', this.id)
          .where('user_id', '=', authUserId)
          .executeTakeFirst()

        return !!like
      }
    `;
  }
  if (useBillable) {
    paymentImports += `import type { PaymentMethodModel } from '../types/PaymentMethodType'
      import type { PaymentTransactionsTable } from '../types/PaymentTransactionType'
      import type { PaymentMethodModelType } from '../types/PaymentMethodType'`;
    billableStatements += ` async createStripeUser(options: Stripe.CustomerCreateParams): Promise<Stripe.Response<Stripe.Customer>> {
      const customer = await manageCustomer.createStripeCustomer(this, options)

        return customer
      }

      async updateStripeUser(options: Stripe.CustomerCreateParams): Promise<Stripe.Response<Stripe.Customer>> {
        const customer = await manageCustomer.updateStripeCustomer(this, options)

        return customer
      }

      async storeTransaction(productId: number): Promise<PaymentTransactionsTable | undefined> {
        const transaction = await manageTransaction.store(this, productId)

        return transaction
      }

      async deleteStripeUser(): Promise<Stripe.Response<Stripe.DeletedCustomer>> {
        const deletedCustomer = await manageCustomer.deleteStripeUser(this)
        return deletedCustomer
      }

      async createOrGetStripeUser(options: Stripe.CustomerCreateParams): Promise<Stripe.Response<Stripe.Customer>> {
        const customer = await manageCustomer.createOrGetStripeUser(this, options)
        return customer
      }

      async retrieveStripeUser(): Promise<Stripe.Response<Stripe.Customer> | undefined> {
        const customer = await manageCustomer.retrieveStripeUser(this)
        return customer
      }

       async defaultPaymentMethod(): Promise<PaymentMethodModelType | undefined> {
        const defaultPaymentMethod = await managePaymentMethod.retrieveDefaultPaymentMethod(this)

        return defaultPaymentMethod
      }

      async setDefaultPaymentMethod(pmId: number): Promise<Stripe.Response<Stripe.Customer>> {
        const updatedCustomer = await managePaymentMethod.setDefaultPaymentMethod(this, pmId)

        return updatedCustomer
      }

      async setUserDefaultPaymentMethod(paymentMethodId: string): Promise<Stripe.Response<Stripe.Customer>> {
        const updatedCustomer = await managePaymentMethod.setUserDefaultPayment(this, paymentMethodId)

        return updatedCustomer
      }

      async updateDefaultPaymentMethod(paymentMethodId: number): Promise<Stripe.Response<Stripe.Customer>> {
        const updatedCustomer = this.setDefaultPaymentMethod(paymentMethodId)

        return updatedCustomer
      }

      async asStripeUser(): Promise<Stripe.Response<Stripe.Customer> | undefined> {
        return await this.retrieveStripeUser()
      }

      async createOrUpdateStripeUser(options: Stripe.CustomerCreateParams): Promise<Stripe.Response<Stripe.Customer>> {
        const customer = await manageCustomer.createOrUpdateStripeUser(this, options)
        return customer
      }

      stripeId(): string {
        return manageCustomer.stripeId(this)
      }

      hasStripeId(): boolean {
        return manageCustomer.hasStripeId(this)
      }

      async addPaymentMethod(paymentMethodId: string): Promise<Stripe.Response<Stripe.PaymentMethod>> {
        const paymentMethod = await managePaymentMethod.addPaymentMethod(this, paymentMethodId)

        return paymentMethod
      }

      async updatePaymentMethod(paymentMethodId: string, params?: Stripe.PaymentMethodUpdateParams): Promise<Stripe.Response<Stripe.PaymentMethod>> {
        const updatedPaymentMethod = await managePaymentMethod.updatePaymentMethod(this, paymentMethodId, params)

        return updatedPaymentMethod
      }

      async deletePaymentMethod(paymentMethodId: number): Promise<Stripe.Response<Stripe.PaymentMethod>> {
        const deletedPaymentMethod = await managePaymentMethod.deletePaymentMethod(this, paymentMethodId)
        return deletedPaymentMethod
      }

      async retrievePaymentMethod(paymentMethod: number): Promise<PaymentMethodsTable | undefined> {
        const defaultPaymentMethod = await managePaymentMethod.retrievePaymentMethod(this, paymentMethod)

        return defaultPaymentMethod
      }

      async paymentIntent(options: Stripe.PaymentIntentCreateParams): Promise<Stripe.Response<Stripe.PaymentIntent>> {
        if (!this.hasStripeId()) {
          throw new HttpError(404, 'Customer does not exist in Stripe')
        }

        const defaultOptions: Stripe.PaymentIntentCreateParams = {
          customer: this.stripeId(),
          currency: 'usd',
          amount: options.amount
        }

        const mergedOptions = { ...defaultOptions, ...options }

        return await manageCharge.createPayment(this, mergedOptions.amount, mergedOptions)
      }

      async syncStripeCustomerDetails(options: StripeCustomerOptions): Promise<Stripe.Response<Stripe.Customer>> {
        const customer = await manageCustomer.syncStripeCustomerDetails(this, options)

        return customer
      }

      async subscriptionHistory(): Promise<Stripe.Response<Stripe.ApiList<Stripe.Invoice>>> {
        return manageInvoice.list(this)
      }

      async transactionHistory(): Promise<PaymentTransactionsTable[]> {
        return manageTransaction.list(this)
      }

      async stripeSubscriptions(): Promise<Stripe.Response<Stripe.ApiList<Stripe.Invoice>>> {
        return manageInvoice.list(this)
      }

      async activeSubscription() {
        const subscription = await DB.instance.selectFrom('subscriptions')
          .where('user_id', '=', this.id)
          .where('provider_status', '=', 'active')
          .selectAll()
          .executeTakeFirst()

        if (subscription) {
          const providerSubscription = await manageSubscription.retrieve(this, subscription?.provider_id || '')

          return { subscription, providerSubscription }
        }

        return undefined
      }

      async isIncomplete(type: string): Promise<boolean> {
        return await manageSubscription.isIncomplete(this, type)
      }

      async paymentMethods(cardType?: string): Promise<PaymentMethodsTable[]> {
        return await managePaymentMethod.listPaymentMethods(this, cardType)
      }

      async newSubscriptionInvoice(
        type: string,
        lookupKey: string,
        options: Partial<Stripe.SubscriptionCreateParams> = {},
      ): Promise<{ subscription: Stripe.Subscription, paymentIntent?: Stripe.PaymentIntent }> {
        return await this.newSubscription(type, lookupKey, { ...options, days_until_due: 15, collection_method: 'send_invoice' })
      }

      async newSubscription(
        type: string,
        lookupKey: string,
        options: Partial<Stripe.SubscriptionCreateParams> = {},
      ): Promise<{ subscription: Stripe.Subscription, paymentIntent?: Stripe.PaymentIntent }> {
        const subscription = await manageSubscription.create(this, type, lookupKey, options)

        const latestInvoice = subscription.latest_invoice as Stripe.Invoice | null
        const paymentIntent = latestInvoice?.payment_intent as Stripe.PaymentIntent | undefined

        return { subscription, paymentIntent }
      }

      async updateSubscription(
        type: string,
        lookupKey: string,
        options: Partial<Stripe.SubscriptionUpdateParams> = {},
      ): Promise<{ subscription: Stripe.Subscription, paymentIntent?: Stripe.PaymentIntent }> {
        const subscription = await manageSubscription.update(this, type, lookupKey, options)

        const latestInvoice = subscription.latest_invoice as Stripe.Invoice | null
        const paymentIntent = latestInvoice?.payment_intent as Stripe.PaymentIntent | undefined

        return { subscription, paymentIntent }
      }

      async cancelSubscription(
        providerId: string,
        options: Partial<Stripe.SubscriptionCreateParams> = {},
      ): Promise<{ subscription: Stripe.Subscription, paymentIntent?: Stripe.PaymentIntent }> {
        const subscription = await manageSubscription.cancel(providerId, options)

        return { subscription }
      }

      async createSetupIntent(
        options: Stripe.SetupIntentCreateParams = {}
      ): Promise<Stripe.Response<Stripe.SetupIntent>> {
        const defaultOptions: Partial<Stripe.SetupIntentCreateParams> = {
          metadata: options.metadata,
        }

        // Merge any additional provided options
        const mergedOptions = { ...defaultOptions, ...options }

        // Call Stripe to create the SetupIntent
        return await manageSetupIntent.create(this, mergedOptions)
      }

      async checkout(
        priceIds: CheckoutLineItem[],
        options: CheckoutOptions = {},
      ): Promise<Stripe.Response<Stripe.Checkout.Session>> {
        const newOptions: Partial<Stripe.Checkout.SessionCreateParams> = {}

        if (options.enableTax) {
          newOptions.automatic_tax = { enabled: true }
          delete options.enableTax
        }

        if (options.allowPromotions) {
          newOptions.allow_promotion_codes = true
          delete options.allowPromotions
        }

        const defaultOptions: Partial<Stripe.Checkout.SessionCreateParams> = {
          mode: 'payment',
          customer: await this.createOrGetStripeUser({}).then(customer => customer.id),
          line_items: priceIds.map((item: CheckoutLineItem) => ({
            price: item.priceId,
            quantity: item.quantity || 1,
          })),

        }

        const mergedOptions = { ...defaultOptions, ...newOptions, ...options }

        return await manageCheckout.create(this, mergedOptions)
      }
      `;
    getFields += `get stripe_id(): string | undefined {
      return this.attributes.stripe_id
    }

`;
    setFields += `set stripe_id(value: string) {
      this.attributes.stripe_id = value
    }

`;
  }
  if (useTwoFactor) {
    getFields += `get two_factor_secret(): string | undefined {
      return this.attributes.two_factor_secret
    }

`;
    setFields += `set two_factor_secret(value: string) {
      this.attributes.two_factor_secret = value
    }

`;
    twoFactorStatements += `
        async generateTwoFactorForModel() {
          const secret = generateTwoFactorSecret()

          await this.update({ 'two_factor_secret': secret })
        }

        verifyTwoFactorCode(code: string): boolean {
          const modelTwoFactorSecret = this.two_factor_secret
          let isValid = false

          if (typeof modelTwoFactorSecret === 'string') {
            isValid = verifyTwoFactorCode(code, modelTwoFactorSecret)
          }

          return isValid
        }
      `;
  }
  if (useUuid) {
    getFields += `get uuid(): string | undefined {
      return this.attributes.uuid
    }

`;
    setFields += `set uuid(value: string) {
      this.attributes.uuid = value
    }

`;
    jsonFields += `
 uuid: this.uuid,
`;
  }
  if (usePasskey) {
    getFields += `get public_passkey(): string | undefined {
      return this.attributes.public_passkey
    }

`;
    setFields += `set public_passkey(value: string) {
      this.attributes.public_passkey = value
    }

`;
  }
  jsonFields += `
id: this.id,
`;
  for (const attribute of attributes) {
    const entity = mapEntity(attribute);
    const undefinedIndicator = attribute.required === false ? " | undefined" : "";
    getFields += `get ${snakeCase(attribute.field)}(): ${entity}${undefinedIndicator} {
      return this.attributes.${snakeCase(attribute.field)}
    }

`;
    setFields += `set ${snakeCase(attribute.field)}(value: ${entity}) {
      this.attributes.${snakeCase(attribute.field)} = value
    }

`;
    if (!attribute.hidden)
      jsonFields += `${snakeCase(attribute.field)}: this.${snakeCase(attribute.field)},
   `;
    whereStatements += `static where${pascalCase(attribute.field)}(value: string): ${modelName}Model {
          const instance = new ${modelName}Model(undefined)

          instance.selectFromQuery = instance.selectFromQuery.where('${snakeCase(attribute.field)}', '=', value)

          return instance
        } 

`;
    whereFunctionStatements += `export async function where${pascalCase(attribute.field)}(value: ${entity}): Promise<${modelName}Model[]> {
          const query = DB.instance.selectFrom('${tableName}').where('${snakeCase(attribute.field)}', '=', value)
          const results: ${modelName}JsonResponse = await query.execute()

          return results.map((modelItem: ${modelName}JsonResponse) => new ${modelName}Model(modelItem))
        } 

`;
  }
  if (useSocials) {
    const socials = model.traits?.useSocials || [];
    if (socials.includes("google")) {
      setFields += `set google_id(value: string) {
        this.attributes.google_id = value
      }

`;
      getFields += `get google_id(): string | undefined {
        return this.attributes.google_id
      }

`;
    }
    if (socials.includes("github")) {
      setFields += `set github_id(value: string) {
        this.attributes.github_id = value
      }

`;
      getFields += `get github_id(): string | undefined {
        return this.attributes.github_id
      }

`;
    }
    if (socials.includes("twitter")) {
      setFields += `set twitter_id(value: string) {
        this.attributes.twitter_id = value
      }

`;
      getFields += `get twitter_id(): string | undefined {
        return this.attributes.twitter_id
      }

`;
    }
    if (socials.includes("facebook")) {
      setFields += `set facebook_id(value: string) {
        this.attributes.facebook_id = value
      }

`;
      getFields += `get facebook_id(): string | undefined {
        return this.attributes.facebook_id
      }

`;
    }
  }
  if (useTimestamps) {
    getFields += `get created_at(): string | undefined {
      return this.attributes.created_at
    }

    get updated_at(): string | undefined {
      return this.attributes.updated_at
    }

`;
    setFields += `set updated_at(value: string) {
      this.attributes.updated_at = value
    }

`;
    jsonFields += `
        created_at: this.created_at,

        updated_at: this.updated_at,

      `;
  }
  if (useSoftDeletes) {
    getFields += `get deleted_at(): string | undefined {
      return this.attributes.deleted_at
    }

`;
    setFields += `set deleted_at(value: string) {
      this.attributes.deleted_at = value
    }

`;
    jsonFields += `
        deleted_at: this.deleted_at,

      `;
  }
  jsonFields += jsonRelations;
  jsonFields += `...this.customColumns,
`;
  const otherModelRelations = await fetchOtherModelRelations(modelName);
  if (useSocials) {
    const socials = model.traits?.useSocials || [];
    if (socials.includes("google")) {
      jsonFields += `google_id: this.google_id,
`;
    }
    if (socials.includes("github")) {
      jsonFields += `github_id: this.github_id,
`;
    }
    if (socials.includes("twitter")) {
      jsonFields += `twitter_id: this.twitter_id,
`;
    }
    if (socials.includes("facebook")) {
      jsonFields += `facebook_id: this.facebook_id,
`;
    }
  }
  if (useTwoFactor && tableName === "users") {
    jsonFields += `two_factor_secret: this.two_factor_secret
`;
  }
  if (usePasskey && tableName === "users") {
    jsonFields += `public_passkey: this.public_passkey,
`;
  }
  if (useBillable && tableName === "users") {
    jsonFields += `stripe_id: this.stripe_id, 
`;
  }
  jsonFields += "}";
  const hidden = JSON.stringify(getHiddenAttributes(model.attributes));
  const fillable = JSON.stringify(getFillableAttributes(model, otherModelRelations));
  const guarded = JSON.stringify(getGuardedAttributes(model));
  const classString = `import type { Generated, Insertable, RawBuilder, Selectable, Updateable, Sql} from '@stacksjs/database'
import { manageCharge, manageCheckout, manageCustomer, manageInvoice, managePaymentMethod, manageSubscription, manageTransaction, managePrice, manageSetupIntent } from '@stacksjs/payments'
import Stripe from 'stripe'
import { sql } from '@stacksjs/database'
import { DB } from '@stacksjs/orm'
import { BaseOrm } from '../utils/base'
import type { Operator } from '@stacksjs/orm'
import type { CheckoutLineItem, CheckoutOptions, StripeCustomerOptions } from '@stacksjs/types'
import { HttpError } from '@stacksjs/error-handling'
import { dispatch } from '@stacksjs/events'
import { generateTwoFactorSecret } from '@stacksjs/auth'
import { verifyTwoFactorCode } from '@stacksjs/auth'
import { randomUUIDv7 } from 'bun'
import type { ${modelName}ModelType, ${modelName}JsonResponse, New${modelName}, ${modelName}Update, ${pascalCase(tableName)}Table } from '../types/${modelName}Type'
${paymentImports}
${relationImports}
${categorizableImports}
${commentablesImports}
${importsString}
${taggableImports}

export class ${modelName}Model extends BaseOrm<${modelName}Model, ${formattedTableName}Table, ${modelName}JsonResponse> {
  private readonly hidden: Array<keyof ${modelName}JsonResponse> = ${hidden}
  private readonly fillable: Array<keyof ${modelName}JsonResponse> = ${fillable}
  private readonly guarded: Array<keyof ${modelName}JsonResponse> = ${guarded}
  protected attributes = {} as ${modelName}JsonResponse
  protected originalAttributes = {} as ${modelName}JsonResponse
  ${privateSoftDeletes}
  protected selectFromQuery: any
  protected updateFromQuery: any
  protected deleteFromQuery: any
  protected hasSelect: boolean
  private customColumns: Record<string, unknown> = {}

  /**
   * This model inherits many query methods from BaseOrm:
   * - pluck, chunk, whereExists, has, doesntHave, whereHas, whereDoesntHave
   * - inRandomOrder, max, min, avg, paginate, get, and more
   *
   * See BaseOrm class for the full list of inherited methods.
   */

  constructor(${formattedModelName}: ${modelName}JsonResponse | undefined) {
    super('${tableName}')
    if (${formattedModelName}) {

      this.attributes = { ...${formattedModelName} }
      this.originalAttributes = { ...${formattedModelName} }

      Object.keys(${formattedModelName}).forEach(key => {
        if (!(key in this)) {
           this.customColumns[key] = (${formattedModelName} as ${modelName}JsonResponse)[key]
        }
      })
    }

    this.withRelations = []
    this.selectFromQuery = DB.instance.selectFrom('${tableName}')
    this.updateFromQuery = DB.instance.updateTable('${tableName}')
    this.deleteFromQuery = DB.instance.deleteFrom('${tableName}')
    this.hasSelect = false
  }

  protected async loadRelations(models: ${modelName}JsonResponse | ${modelName}JsonResponse[]): Promise<void> {
    // Handle both single model and array of models
    const modelArray = Array.isArray(models) ? models : [models]
    if (!modelArray.length) return

    const modelIds = modelArray.map(model => model.id)

    for (const relation of this.withRelations) {
      const relatedRecords = await DB.instance
        .selectFrom(relation)
        .where('${formattedModelName}_id', 'in', modelIds)
        .selectAll()
        .execute()

      if (Array.isArray(models)) {
        models.map((model: ${modelName}JsonResponse) => {
          const records = relatedRecords.filter((record: { ${formattedModelName}_id: number }) => {
            return record.${formattedModelName}_id === model.id
          })

          model[relation] = records.length === 1 ? records[0] : records
          return model
        })
      } else {
        const records = relatedRecords.filter((record: { ${formattedModelName}_id: number }) => {
          return record.${formattedModelName}_id === models.id
        })

        models[relation] = records.length === 1 ? records[0] : records
      }
    }
  }

  static with(relations: string[]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWith(relations)
  }

  protected mapCustomGetters(models: ${modelName}JsonResponse | ${modelName}JsonResponse[]): void {
    const data = models

    if (Array.isArray(data)) {
      data.map((model: ${modelName}JsonResponse) => {

        const customGetter = {
          default: () => {
          },

          ${getterOutput}
        }

        for (const [key, fn] of Object.entries(customGetter)) {
          (model as any)[key] = fn()
        }

        return model
      })
    } else {
      const model = data

      const customGetter = {
        default: () => {
        },

        ${getterOutput}
      }

      for (const [key, fn] of Object.entries(customGetter)) {
        (model as any)[key] = fn()
      }
    }
  }

  async mapCustomSetters(model: New${modelName} | ${modelName}Update): Promise<void> {
    const customSetter = {
      default: () => {
      },

      ${setterOutput}
    }

    for (const [key, fn] of Object.entries(customSetter)) {
        (model as any)[key] = await fn()
    }
  }

  ${getFields}
  ${setFields}

  static select(params: (keyof ${modelName}JsonResponse)[] | RawBuilder<string> | string): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applySelect(params)
  }

  // Method to find a ${modelName} by ID
  static async find(id: number): Promise<${modelName}Model | undefined> {
    let query = DB.instance.selectFrom('${tableName}').where('id', '=', id).selectAll()

    const model = await query.executeTakeFirst()

    if (!model) return undefined

    const instance = new ${modelName}Model(undefined)
    return instance.createInstance(model)
  }

  static async first(): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    const model = await instance.applyFirst()

    const data = new ${modelName}Model(model)

    return data
  }

  static async last(): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    const model = await instance.applyLast()

    if (!model) return undefined

    return new ${modelName}Model(model)
  }

  static async firstOrFail(): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyFirstOrFail()
  }

  static async all(): Promise<${modelName}Model[]> {
    const instance = new ${modelName}Model(undefined)

    const models = await DB.instance.selectFrom('${tableName}').selectAll().execute()

    instance.mapCustomGetters(models)

    const data = await Promise.all(models.map(async (model: ${modelName}JsonResponse) => {
      return new ${modelName}Model(model)
    }))

    return data
  }

  static async findOrFail(id: number): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyFindOrFail(id)
  }

  static async findMany(ids: number[]): Promise<${modelName}Model[]> {
    const instance = new ${modelName}Model(undefined)
     ${instanceSoftDeleteStatements}
    const models = await instance.applyFindMany(ids)

    return models.map((modelItem: ${modelName}JsonResponse) => instance.parseResult(new ${modelName}Model(modelItem)))
  }

  static async latest(column: keyof ${formattedTableName}Table = 'created_at'): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    const model = await instance.selectFromQuery
      .selectAll()
      .orderBy(column, 'desc')
      .limit(1)
      .executeTakeFirst()

    if (!model) return undefined

    return new ${modelName}Model(model)
  }

  static async oldest(column: keyof ${formattedTableName}Table = 'created_at'): Promise<${modelName}Model | undefined> {
    const instance = new ${modelName}Model(undefined)

    const model = await instance.selectFromQuery
      .selectAll()
      .orderBy(column, 'asc')
      .limit(1)
      .executeTakeFirst()

    if (!model) return undefined

    return new ${modelName}Model(model)
  }

  static skip(count: number): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applySkip(count)
  }

  static take(count: number): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyTake(count)
  }

  static where<V = string>(column: keyof ${formattedTableName}Table, ...args: [V] | [Operator, V]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhere<V>(column, ...args)
  }

  static orWhere(...conditions: [string, any][]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyOrWhere(...conditions)
  }

  static whereNotIn<V = number>(column: keyof ${formattedTableName}Table, values: V[]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereNotIn<V>(column, values)
  }

  static whereBetween<V = number>(column: keyof ${formattedTableName}Table, range: [V, V]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereBetween<V>(column, range)
  }

  static whereRef(column: keyof ${formattedTableName}Table, ...args: string[]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereRef(column, ...args)
  }

  static when(condition: boolean, callback: (query: ${modelName}Model) => ${modelName}Model): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhen(condition, callback as any)
  }

  static whereNull(column: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereNull(column)
  }

  static whereNotNull(column: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereNotNull(column)
  }

  static whereLike(column: keyof ${formattedTableName}Table, value: string): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereLike(column, value)
  }

  static orderBy(column: keyof ${formattedTableName}Table, order: 'asc' | 'desc'): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyOrderBy(column, order)
  }

  static orderByAsc(column: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyOrderByAsc(column)
  }

  static orderByDesc(column: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyOrderByDesc(column)
  }

  static groupBy(column: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyGroupBy(column)
  }

  static having<V = string>(column: keyof ${formattedTableName}Table, operator: Operator, value: V): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyHaving<V>(column, operator, value)
  }

  static inRandomOrder(): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyInRandomOrder()
  }

  static whereColumn(first: keyof ${formattedTableName}Table, operator: Operator, second: keyof ${formattedTableName}Table): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereColumn(first, operator, second)
  }

  static async max(field: keyof ${formattedTableName}Table): Promise<number> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyMax(field)
  }

  static async min(field: keyof ${formattedTableName}Table): Promise<number> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyMin(field)
  }

  static async avg(field: keyof ${formattedTableName}Table): Promise<number> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyAvg(field)
  }

  static async sum(field: keyof ${formattedTableName}Table): Promise<number> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applySum(field)
  }

  static async count(): Promise<number> {
    const instance = new ${modelName}Model(undefined)

    return instance.applyCount()
  }

  static async get(): Promise<${modelName}Model[]> {
    const instance = new ${modelName}Model(undefined)

    const results = await instance.applyGet()

    return results.map((item: ${modelName}JsonResponse) => instance.createInstance(item))
  }

  static async pluck<K extends keyof ${modelName}Model>(field: K): Promise<${modelName}Model[K][]> {
    const instance = new ${modelName}Model(undefined)

    return await instance.applyPluck(field)
  }

  static async chunk(size: number, callback: (models: ${modelName}Model[]) => Promise<void>): Promise<void> {
    const instance = new ${modelName}Model(undefined)

    await instance.applyChunk(size, async (models) => {
      const modelInstances = models.map((item: ${modelName}JsonResponse) => instance.createInstance(item))
      await callback(modelInstances)
    })
  }

  static async paginate(options: { limit?: number, offset?: number, page?: number } = { limit: 10, offset: 0, page: 1 }): Promise<{
    data: ${modelName}Model[],
    paging: {
      total_records: number,
      page: number,
      total_pages: number
    },
    next_cursor: number | null
  }> {
    const instance = new ${modelName}Model(undefined)

    const result = await instance.applyPaginate(options)

    return {
      data: result.data.map((item: ${modelName}JsonResponse) => instance.createInstance(item)),
      paging: result.paging,
      next_cursor: result.next_cursor
    }
  }

  // Instance method for creating model instances
  createInstance(data: ${modelName}JsonResponse): ${modelName}Model {
    return new ${modelName}Model(data)
  }

  async applyCreate(new${modelName}: New${modelName}): Promise<${modelName}Model> {
    const filteredValues = Object.fromEntries(
      Object.entries(new${modelName}).filter(([key]) =>
        !this.guarded.includes(key) && this.fillable.includes(key)
      ),
    ) as New${modelName}

    await this.mapCustomSetters(filteredValues)

    ${uuidQuery}

    const result = await DB.instance.insertInto('${tableName}')
      .values(filteredValues)
      .executeTakeFirst()

    const model = await DB.instance.selectFrom('${tableName}')
      .where('id', '=', Number(result.insertId || result.numInsertedOrUpdatedRows))
      .selectAll()
      .executeTakeFirst()

    if (!model) {
      throw new HttpError(500, 'Failed to retrieve created ${modelName}')
    }

    ${mittCreateStatement}
    return this.createInstance(model)
  }

  async create(new${modelName}: New${modelName}): Promise<${modelName}Model> {
    return await this.applyCreate(new${modelName})
  }

  static async create(new${modelName}: New${modelName}): Promise<${modelName}Model> {
    const instance = new ${modelName}Model(undefined)
    return await instance.applyCreate(new${modelName})
  }

  static async firstOrCreate(search: Partial<${formattedTableName}Table>, values: New${modelName} = {} as New${modelName}): Promise<${modelName}Model> {
    // First try to find a record matching the search criteria
    const instance = new ${modelName}Model(undefined)

    // Apply all search conditions
    for (const [key, value] of Object.entries(search)) {
      instance.selectFromQuery = instance.selectFromQuery.where(key, '=', value)
    }

    // Try to find the record
    const existingRecord = await instance.applyFirst()

    if (existingRecord) {
      return instance.createInstance(existingRecord)
    }

    // If no record exists, create a new one with combined search criteria and values
    const createData = { ...search, ...values } as New${modelName}
    return await ${modelName}Model.create(createData)
  }

  static async updateOrCreate(search: Partial<${formattedTableName}Table>, values: New${modelName} = {} as New${modelName}): Promise<${modelName}Model> {
    // First try to find a record matching the search criteria
    const instance = new ${modelName}Model(undefined)

    // Apply all search conditions
    for (const [key, value] of Object.entries(search)) {
      instance.selectFromQuery = instance.selectFromQuery.where(key, '=', value)
    }

    // Try to find the record
    const existingRecord = await instance.applyFirst()

    if (existingRecord) {
      // If record exists, update it with the new values
      const model = instance.createInstance(existingRecord)
      const updatedModel = await model.update(values as ${modelName}Update)

      // Return the updated model instance
      if (updatedModel) {
        return updatedModel
      }

      // If update didn't return a model, fetch it again to ensure we have latest data
      const refreshedModel = await instance.applyFirst()
      return instance.createInstance(refreshedModel!)
    }

    // If no record exists, create a new one with combined search criteria and values
    const createData = { ...search, ...values } as New${modelName}
    return await ${modelName}Model.create(createData)
  }

  async update(new${modelName}: ${modelName}Update): Promise<${modelName}Model | undefined> {
    const filteredValues = Object.fromEntries(
      Object.entries(new${modelName}).filter(([key]) =>
        !this.guarded.includes(key) && this.fillable.includes(key)
      ),
    ) as ${modelName}Update

    await this.mapCustomSetters(filteredValues)

    filteredValues.updated_at = new Date().toISOString()

    await DB.instance.updateTable('${tableName}')
      .set(filteredValues)
      .where('id', '=', this.id)
      .executeTakeFirst()

    if (this.id) {
      // Get the updated data
      const model = await DB.instance.selectFrom('${tableName}')
        .where('id', '=', this.id)
        .selectAll()
        .executeTakeFirst()

      if (!model) {
        throw new HttpError(500, 'Failed to retrieve updated ${modelName}')
      }

      ${mittUpdateStatement}
      return this.createInstance(model)
    }

    return undefined
  }

  async forceUpdate(new${modelName}: ${modelName}Update): Promise<${modelName}Model | undefined> {
    await DB.instance.updateTable('${tableName}')
      .set(new${modelName})
      .where('id', '=', this.id)
      .executeTakeFirst()

    if (this.id) {
      // Get the updated data
      const model = await DB.instance.selectFrom('${tableName}')
        .where('id', '=', this.id)
        .selectAll()
        .executeTakeFirst()

      if (!model) {
        throw new HttpError(500, 'Failed to retrieve updated ${modelName}')
      }

      ${mittUpdateStatement.replace("model", "this")}
      return this.createInstance(model)
    }

    return undefined
  }

  async save(): Promise<${modelName}Model> {
    // If the model has an ID, update it; otherwise, create a new record
    if (this.id) {
      // Update existing record
      await DB.instance.updateTable('${tableName}')
        .set(this.attributes as ${modelName}Update)
        .where('id', '=', this.id)
        .executeTakeFirst()

      // Get the updated data
      const model = await DB.instance.selectFrom('${tableName}')
        .where('id', '=', this.id)
        .selectAll()
        .executeTakeFirst()

      if (!model) {
        throw new HttpError(500, 'Failed to retrieve updated ${modelName}')
      }

      ${mittUpdateStatement.replace("model", "this")}
      return this.createInstance(model)
    } else {
      // Create new record
      const result = await DB.instance.insertInto('${tableName}')
        .values(this.attributes as New${modelName})
        .executeTakeFirst()

      // Get the created data
      const model = await DB.instance.selectFrom('${tableName}')
        .where('id', '=', Number(result.insertId || result.numInsertedOrUpdatedRows))
        .selectAll()
        .executeTakeFirst()

      if (!model) {
        throw new HttpError(500, 'Failed to retrieve created ${modelName}')
      }

      ${mittCreateStatement.replace("model", "this")}
      return this.createInstance(model)
    }
  }

  static async createMany(new${modelName}: New${modelName}[]): Promise<void> {
    const instance = new ${modelName}Model(undefined)

    const valuesFiltered = new${modelName}.map((new${modelName}: New${modelName}) => {
      const filteredValues = Object.fromEntries(
        Object.entries(new${modelName}).filter(([key]) =>
          !instance.guarded.includes(key) && instance.fillable.includes(key),
        ),
      ) as New${modelName}

      ${uuidQuery}

      return filteredValues
    })

    await DB.instance.insertInto('${tableName}')
      .values(valuesFiltered)
      .executeTakeFirst()
  }

  static async forceCreate(new${modelName}: New${modelName}): Promise<${modelName}Model> {
    const result = await DB.instance.insertInto('${tableName}')
      .values(new${modelName})
      .executeTakeFirst()

    const instance = new ${modelName}Model(undefined)
    const model = await DB.instance.selectFrom('${tableName}')
      .where('id', '=', Number(result.insertId || result.numInsertedOrUpdatedRows))
      .selectAll()
      .executeTakeFirst()

    if (!model) {
      throw new HttpError(500, 'Failed to retrieve created ${modelName}')
    }

    ${mittCreateStatement}

    return instance.createInstance(model)
  }

  // Method to remove a ${modelName}
  async delete(): Promise<number> {
    if (this.id === undefined)
      this.deleteFromQuery.execute()
    ${mittDeleteFindStatement}
    ${thisSoftDeleteStatementsUpdateFrom}
    ${mittDeleteStatement}

    const deleted = await DB.instance.deleteFrom('${tableName}')
      .where('id', '=', this.id)
      .execute()

    return deleted.numDeletedRows
  }

  static async remove(id: number): Promise<any> {
    ${removeInstanceStatment}

    ${mittDeleteStaticFindStatement}

    ${instanceSoftDeleteStatementsUpdateFrom}

    ${mittDeleteStatement}

    return await DB.instance.deleteFrom('${tableName}')
      .where('id', '=', id)
      .execute()
  }

  ${whereStatements}

  static whereIn<V = number>(column: keyof ${formattedTableName}Table, values: V[]): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyWhereIn<V>(column, values)
  }

  ${relationMethods}

  ${displayableStatements}

  ${billableStatements}

  ${likeableStatements}

  static distinct(column: keyof ${modelName}JsonResponse): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyDistinct(column)
  }

  static join(table: string, firstCol: string, secondCol: string): ${modelName}Model {
    const instance = new ${modelName}Model(undefined)

    return instance.applyJoin(table, firstCol, secondCol)
  }

  toJSON(): ${modelName}JsonResponse {
    const output = ${jsonFields}

    return output
  }

  parseResult(model: ${modelName}Model): ${modelName}Model {
    for (const hiddenAttribute of this.hidden) {
      delete model[hiddenAttribute as keyof ${modelName}Model]
    }

    return model
  }

  ${twoFactorStatements}

  // Add a protected applyFind implementation
  protected async applyFind(id: number): Promise<${modelName}Model | undefined> {
    const model = await DB.instance.selectFrom(this.tableName)
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst()

    if (!model)
      return undefined

    this.mapCustomGetters(model)

    await this.loadRelations(model)

    // Return a proper instance using the factory method
    return this.createInstance(model)
  }

  ${searchableStatements}
}

export async function find(id: number): Promise<${modelName}Model | undefined> {
  let query = DB.instance.selectFrom('${tableName}').where('id', '=', id).selectAll()

  const model = await query.executeTakeFirst()

  if (!model) return undefined

  const instance = new ${modelName}Model(undefined)
  return instance.createInstance(model)
}

export async function count(): Promise<number> {
  const results = await ${modelName}Model.count()

  return results
}

export async function create(new${modelName}: New${modelName}): Promise<${modelName}Model> {
  const instance = new ${modelName}Model(undefined)
  return await instance.applyCreate(new${modelName})
}

export async function rawQuery(rawQuery: string): Promise<any> {
  return await sql\`\${rawQuery}\`.execute(DB.instance)
}

export async function remove(id: number): Promise<void> {
  await DB.instance.deleteFrom('${tableName}')
    .where('id', '=', id)
    .execute()
}

${whereFunctionStatements}

export const ${modelName} = ${modelName}Model

export default ${modelName}
`;
  return classString;
}

// ../orm/src/utils.ts
function getModelName(model, modelPath) {
  if (model.name)
    return model.name;
  const baseName = path14.basename(modelPath);
  return baseName.replace(/\.ts$/, "");
}
function getTableName(model, modelPath) {
  if (model.table)
    return model.table;
  return snakeCase(plural(getModelName(model, modelPath)));
}
function getPivotTableName(formattedModelName, modelRelationTable) {
  const tables = [formattedModelName, modelRelationTable];
  tables.sort();
  return tables.join("_");
}
async function getRelations(model, modelName) {
  const relationships = [];
  if (model.hasOne) {
    for (const relationInstance of model.hasOne) {
      relationships.push(await processHasOneAndMany(relationInstance, model, modelName, "hasOne"));
    }
  }
  if (model.hasMany) {
    for (const relationInstance of model.hasMany) {
      relationships.push(await processHasOneAndMany(relationInstance, model, modelName, "hasMany"));
    }
  }
  if (model.belongsTo) {
    for (const relationInstance of model.belongsTo) {
      relationships.push(await processHasOneAndMany(relationInstance, model, modelName, "belongsTo"));
    }
  }
  if (model.hasOneThrough) {
    for (const relationInstance of model.hasOneThrough) {
      relationships.push(await processHasThrough(relationInstance, model, modelName, "hasOneThrough"));
    }
  }
  if (model.belongsToMany) {
    for (const relationInstance of model.belongsToMany) {
      relationships.push(await processBelongsToMany(relationInstance, model, modelName, "belongsToMany"));
    }
  }
  if (model.morphOne) {
    relationships.push(await processMorphOne(model.morphOne, model, modelName, "belongsToMany"));
  }
  return relationships;
}
async function loadModels(modelName, relationModel) {
  const modelRelationPath = findUserModel(`${relationModel}.ts`);
  const userModelPath = findUserModel(`${modelName}.ts`);
  const coreModelPath = findCoreModel(`${modelName}.ts`);
  const coreModelRelationPath = findCoreModel(`${relationModel}.ts`);
  if (!modelRelationPath && !coreModelRelationPath)
    throw new Error(`Model not found: ${relationModel}`);
  if (!userModelPath && !coreModelPath)
    throw new Error(`Model not found: ${modelName}`);
  let modelRelation;
  try {
    if (fs8.existsSync(modelRelationPath))
      modelRelation = (await import(modelRelationPath)).default;
    else
      modelRelation = (await import(coreModelRelationPath)).default;
  } catch (error) {
    throw new Error(`Failed to load model: ${relationModel}. Error: ${error?.message || "Unknown error"}`);
  }
  const modelPath = fs8.existsSync(userModelPath) ? userModelPath : coreModelPath;
  return {
    modelRelation,
    modelPath,
    modelRelationPath: fs8.existsSync(modelRelationPath) ? modelRelationPath : coreModelRelationPath
  };
}
async function processHasThrough(relationInstance, model, modelName, relation) {
  let relationModel = "";
  let relationName = "";
  let throughModel = "";
  let throughForeignKey = "";
  if (isString2(relationInstance)) {
    relationModel = relationInstance;
  } else {
    relationModel = relationInstance.model;
    relationName = relationInstance.relationName || "";
    throughModel = relationInstance.through;
    throughForeignKey = relationInstance.throughForeignKey || "";
  }
  const { modelRelation, modelPath, modelRelationPath } = await loadModels(modelName, relationModel);
  const modelRelationTable = getTableName(modelRelation, modelRelationPath);
  const table = getTableName(model, modelPath);
  const modelRelationName = snakeCase(getModelName(modelRelation, modelRelationPath));
  const formattedModelName = snakeCase(modelName);
  const relationshipData = {
    relationship: relation,
    model: relationModel,
    table: modelRelationTable,
    relationTable: table,
    foreignKey: `${formattedModelName}_id`,
    modelKey: `${modelRelationName}_id`,
    relationName,
    relationModel: modelName,
    throughModel,
    throughForeignKey,
    pivotForeign: `${formattedModelName}_id`,
    pivotKey: `${modelRelationName}_id`,
    pivotTable: table
  };
  return relationshipData;
}
async function processBelongsToMany(relationInstance, model, modelName, relation) {
  let relationModel = "";
  let pivotTable = "";
  let pivotForeign = "";
  const formattedModelName = snakeCase(modelName);
  if (isString2(relationInstance)) {
    relationModel = relationInstance;
  } else {
    relationModel = relationInstance.model;
    pivotTable = relationInstance.pivotTable || "";
    pivotForeign = relationInstance.firstForeignKey || `${formattedModelName}_id`;
  }
  const { modelRelation, modelPath, modelRelationPath } = await loadModels(modelName, relationModel);
  const modelRelationTable = getTableName(modelRelation, modelRelationPath);
  const table = getTableName(model, modelPath);
  const modelRelationName = snakeCase(getModelName(modelRelation, modelRelationPath));
  const relationshipData = {
    relationship: relation,
    model: relationModel,
    table: modelRelationTable,
    relationTable: table,
    foreignKey: typeof relationInstance === "string" ? `${formattedModelName}_id` : relationInstance.firstForeignKey || `${formattedModelName}_id`,
    modelKey: typeof relationInstance === "string" ? `${modelRelationName}_id` : relationInstance.secondForeignKey || `${modelRelationName}_id`,
    relationName: "",
    relationModel: modelName,
    throughModel: "",
    throughForeignKey: "",
    pivotForeign,
    pivotKey: `${modelRelationName}_id`,
    pivotTable
  };
  return relationshipData;
}
async function processMorphOne(relationInstance, model, modelName, relation) {
  let relationModel = "";
  let morphName = "";
  let typeColumn = "";
  let idColumn = "";
  if (isString2(relationInstance)) {
    relationModel = relationInstance;
    morphName = `${snakeCase(modelName)}able`;
  } else {
    relationModel = relationInstance.model;
    morphName = relationInstance.morphName || `${snakeCase(modelName)}able`;
    typeColumn = relationInstance.type || `${morphName}_type`;
    idColumn = relationInstance.id || `${morphName}_id`;
  }
  const { modelRelation, modelPath, modelRelationPath } = await loadModels(modelName, relationModel);
  const modelRelationTable = getTableName(modelRelation, modelRelationPath);
  const table = getTableName(model, modelPath);
  const relationshipData = {
    relationship: relation,
    model: relationModel,
    table: modelRelationTable,
    relationTable: table,
    foreignKey: idColumn || `${morphName}_id`,
    modelKey: typeColumn || `${morphName}_type`,
    relationName: morphName,
    relationModel: modelName,
    throughModel: "",
    throughForeignKey: "",
    pivotForeign: "",
    pivotKey: "",
    pivotTable: table
  };
  return relationshipData;
}
async function processHasOneAndMany(relationInstance, model, modelName, relation) {
  let relationModel = "";
  let relationName = "";
  if (isString2(relationInstance)) {
    relationModel = relationInstance;
  } else {
    relationModel = relationInstance.model;
    relationName = relationInstance.relationName || "";
  }
  const { modelRelation, modelPath, modelRelationPath } = await loadModels(modelName, relationModel);
  const modelRelationTable = getTableName(modelRelation, modelRelationPath);
  const table = getTableName(model, modelPath);
  const modelRelationName = snakeCase(getModelName(modelRelation, modelRelationPath));
  const formattedModelName = snakeCase(modelName);
  const relationshipData = {
    relationship: relation,
    model: relationModel,
    table: modelRelationTable,
    relationTable: table,
    foreignKey: typeof relationInstance === "string" ? `${formattedModelName}_id` : relationInstance.foreignKey || `${formattedModelName}_id`,
    modelKey: `${modelRelationName}_id`,
    relationName,
    relationModel: modelName,
    throughModel: "",
    throughForeignKey: "",
    pivotForeign: `${formattedModelName}_id`,
    pivotKey: `${modelRelationName}_id`,
    pivotTable: table
  };
  if (relation === "belongsTo")
    relationshipData.foreignKey = "";
  return relationshipData;
}
function getRelationType(relation) {
  const belongToType = /belongs/;
  const hasType = /has/;
  const throughType = /Through/;
  const morphType = /morph/;
  if (throughType.test(relation))
    return "throughType";
  if (belongToType.test(relation))
    return "belongsType";
  if (hasType.test(relation))
    return "hasType";
  if (morphType.test(relation))
    return "morphType";
  return "";
}
function getRelationCount(relation) {
  const singular2 = /One/;
  const plural2 = /Many/;
  if (plural2.test(relation))
    return "many";
  if (singular2.test(relation))
    return "one";
  return "";
}
async function getPivotTables(model, modelPath) {
  const pivotTable = [];
  if ("belongsToMany" in model) {
    const belongsToManyArr = model.belongsToMany || [];
    for (const belongsToManyRelation of belongsToManyArr) {
      let modelRelation;
      let relationModelName;
      if (typeof belongsToManyRelation === "string") {
        relationModelName = belongsToManyRelation;
      } else {
        relationModelName = belongsToManyRelation.model;
      }
      const modelRelationPath = findUserModel(`${relationModelName}.ts`);
      const coreModelRelationPath = findCoreModel(`${relationModelName}.ts`);
      if (fs8.existsSync(modelRelationPath))
        modelRelation = (await import(modelRelationPath)).default;
      else
        modelRelation = (await import(coreModelRelationPath)).default;
      const modelRelationTableName = getTableName(modelRelation, modelRelationPath);
      const tableName = getTableName(model, modelPath);
      const firstForeignKey = typeof belongsToManyRelation === "object" && "firstForeignKey" in belongsToManyRelation ? belongsToManyRelation.firstForeignKey : `${singular(tableName)}_${model.primaryKey}`;
      const secondForeignKey = typeof belongsToManyRelation === "object" && "secondForeignKey" in belongsToManyRelation ? belongsToManyRelation.secondForeignKey : `${singular(modelRelationTableName)}_${model.primaryKey}`;
      pivotTable.push({
        table: (typeof belongsToManyRelation === "object" && "pivotTable" in belongsToManyRelation ? belongsToManyRelation.pivotTable : undefined) ?? getPivotTableName(tableName, modelRelationTableName),
        firstForeignKey,
        secondForeignKey
      });
    }
    return pivotTable;
  }
  return [];
}
async function fetchOtherModelRelations(modelName) {
  const modelFiles = globSync6([path14.userModelsPath("*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  const modelRelations = [];
  for (let i2 = 0;i2 < modelFiles.length; i2++) {
    const modelFileElement = modelFiles[i2];
    const modelFile = await import(modelFileElement);
    if (modelName === modelFile.default.name)
      continue;
    const otherModelName = getModelName(modelFile, modelFileElement);
    const relations = await getRelations(modelFile.default, otherModelName);
    if (!relations.length)
      continue;
    const relation = relations.find((relation2) => relation2.model === modelName);
    if (relation)
      modelRelations.push(relation);
  }
  return modelRelations;
}
function getHiddenAttributes(attributes) {
  if (attributes === undefined)
    return [];
  return Object.keys(attributes).filter((key) => {
    if (attributes === undefined)
      return false;
    return attributes[key]?.hidden === true;
  });
}
function getGuardedAttributes(model) {
  const attributes = model.attributes;
  if (attributes === undefined)
    return [];
  return Object.keys(attributes).filter((key) => {
    if (attributes === undefined)
      return false;
    return attributes[key]?.guarded === true;
  }).map((attribute) => snakeCase(attribute));
}
function getFillableAttributes(model, otherModelRelations) {
  const attributes = model.attributes;
  const additionalCols = [];
  if (attributes === undefined)
    return [];
  const useBillable = typeof model.traits?.billable === "object" || typeof model.traits?.billable === "boolean";
  const usePasskey = typeof model.traits?.useAuth === "object" ? model.traits?.useAuth.usePasskey : false;
  const useUuid = model.traits?.useUuid || false;
  if (useBillable)
    additionalCols.push("stripe_id");
  if (useUuid)
    additionalCols.push("uuid");
  if (usePasskey)
    additionalCols.push(...["two_factor_secret", "public_key"]);
  const foreignKeys = otherModelRelations.map((otherModelRelation) => otherModelRelation.foreignKey).filter((relation) => relation);
  return [
    ...Object.keys(attributes).filter((key) => {
      if (attributes === undefined)
        return false;
      return attributes[key]?.fillable === true;
    }).map((attribute) => snakeCase(attribute)),
    ...additionalCols,
    ...foreignKeys
  ];
}
async function writeModelNames() {
  const models = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  let fileString = `export type ModelNames = `;
  for (let i2 = 0;i2 < models.length; i2++) {
    const modelPath = models[i2];
    const model = (await import(modelPath)).default;
    const modelName = getModelName(model, modelPath);
    fileString += `'${modelName}'`;
    if (i2 < models.length - 1) {
      fileString += " | ";
    }
  }
  const typesDir = path14.dirname(path14.typesPath(`src/model-names.ts`));
  await fs8.promises.mkdir(typesDir, { recursive: true });
  const typeFilePath = path14.typesPath(`src/model-names.ts`);
  await fs8.promises.writeFile(typeFilePath, fileString, "utf8");
}
async function writeTableNames() {
  const models = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  const traitTables = getTraitTables();
  let fileString = `export type TableNames = `;
  for (const trait of traitTables) {
    fileString += `'${trait}' | `;
  }
  for (let i2 = 0;i2 < models.length; i2++) {
    const modelPath = models[i2];
    const model = (await import(modelPath)).default;
    const tableName = getTableName(model, modelPath);
    const pivotTables = await getPivotTables(model, modelPath);
    for (const pivot of pivotTables) {
      fileString += `'${pivot.table}' | `;
    }
    fileString += `'${tableName}'`;
    if (i2 < models.length - 1) {
      fileString += " | ";
    }
  }
  const typesDir = path14.dirname(path14.typesPath(`src/table-names.ts`));
  await fs8.promises.mkdir(typesDir, { recursive: true });
  const typeFilePath = path14.typesPath(`src/table-names.ts`);
  await fs8.promises.writeFile(typeFilePath, fileString, "utf8");
}
async function writeModelAttributes() {
  const modelFiles = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  let fieldString = `export interface Attributes { 
`;
  const attributesTypeFile = path14.frameworkPath("types/attributes.ts");
  const processedFields = new Set;
  for (let i2 = 0;i2 < modelFiles.length; i2++) {
    const modelPath = modelFiles[i2];
    const model = (await import(modelPath)).default;
    const modeFileElement = modelFiles[i2];
    const attributes = await extractFields(model, modeFileElement);
    for (const attribute of attributes) {
      const fieldName = snakeCase(attribute.field);
      if (processedFields.has(fieldName)) {
        continue;
      }
      const entity = mapEntity(attribute);
      fieldString += ` ${fieldName}: ${entity}
     `;
      processedFields.add(fieldName);
    }
  }
  fieldString += `} 
`;
  await fs8.writeFile(attributesTypeFile, fieldString);
}
async function writeModelEvents() {
  const modelFiles = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  let eventString = ``;
  let observerString = ``;
  let observerImports = ``;
  const attributesTypeFile = Bun.file(path14.frameworkPath("types/events.ts"));
  for (let i2 = 0;i2 < modelFiles.length; i2++) {
    const modelPath = modelFiles[i2];
    const model = (await import(modelPath)).default;
    const modelName = getModelName(model, modelPath);
    const formattedModelName = slugify(modelName);
    const observer = model?.traits?.observe;
    if (typeof observer === "boolean") {
      if (observer) {
        observerString += `'${kebabCase(formattedModelName)}:created': ${modelName}Model
`;
        observerString += `'${kebabCase(formattedModelName)}:updated': ${modelName}Model
`;
        observerString += `'${kebabCase(formattedModelName)}:deleted': ${modelName}Model
`;
        observerImports += `import type { ${modelName}Model } from '../orm/src/models/${modelName}'
`;
      }
    }
  }
  eventString += `
  ${observerImports} 



  export interface ModelEvents {
 
    ${observerString}
  }`;
  const writer = attributesTypeFile.writer();
  writer.write(eventString);
}
async function writeModelRequest() {
  const modelFiles = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  let importTypes = ``;
  let importTypesString = ``;
  let typeString = `import { Request } from '../core/router/src/request'
import type { VineType, CustomAttributes } from '@stacksjs/types'

`;
  for (const trait of traitInterfaces) {
    let fieldString = "";
    let fieldStringInt = "";
    let fileString = `import { Request } from '@stacksjs/router'
import { validateField, customValidate, type schema } from '@stacksjs/validation'
`;
    for (const [field, type] of Object.entries(trait.fields)) {
      fieldString += ` ${field}: ${type}
     `;
      let defaultValue = `''`;
      if (type === "boolean")
        defaultValue = "false";
      if (type === "number")
        defaultValue = "0";
      if (type === "number | null")
        defaultValue = "null";
      if (type === "string | null")
        defaultValue = "null";
      fieldStringInt += `public ${field} = ${defaultValue}
`;
    }
    const fieldStringType = `get: <T = string>(element: string, defaultValue?: T) => T`;
    const requestFile = Bun.file(path14.frameworkPath(`requests/${trait.name}Request.ts`));
    importTypes = `${trait.name}RequestType`;
    importTypesString += `${importTypes}`;
    if (trait !== traitInterfaces[traitInterfaces.length - 1])
      importTypesString += ` | `;
    fileString += `import type { ${importTypes} } from '../types/requests'

`;
    fileString += `interface ValidationField {
      rule: ReturnType<typeof schema.string>
      message: Record<string, string>
    }

`;
    fileString += `interface CustomAttributes {
      [key: string]: ValidationField
    }
`;
    const types5 = `export interface ${trait.name}RequestType extends Request {
      validate(attributes?: CustomAttributes): Promise<void>
      ${fieldStringType}
      all(): RequestData${trait.name}
      ${fieldString}
    }

`;
    typeString += `interface RequestData${trait.name} {
      ${fieldString}
    }
`;
    fileString += `interface RequestData${trait.name} {
      ${fieldString}
    }
`;
    typeString += types5;
    fileString += `export class ${trait.name}Request extends Request<RequestData${trait.name}> implements ${trait.name}RequestType {
      ${fieldStringInt}
      public async validate(attributes?: CustomAttributes): Promise<void> {
        if (attributes === undefined || attributes === null) {
          await validateField('${trait.name}', this.all())
        } else {
          await customValidate(attributes, this.all())
        }
      }
    }

    export const ${camelCase(trait.name)}Request = new ${trait.name}Request()
    `;
    const writer = requestFile.writer();
    writer.write(fileString);
  }
  for (let i2 = 0;i2 < modelFiles.length; i2++) {
    let fieldStringType = ``;
    let fieldString = ``;
    let fieldStringInt = ``;
    let fileString = `import { Request } from '@stacksjs/router'
import { validateField, customValidate, type schema } from '@stacksjs/validation'
`;
    const modeFileElement = modelFiles[i2];
    const model = (await import(modeFileElement)).default;
    const modelName = getModelName(model, modeFileElement);
    const useTimestamps = model?.traits?.useTimestamps ?? model?.traits?.timestampable ?? true;
    const useUuid = model?.traits?.useUuid || false;
    const useSoftDeletes = model?.traits?.useSoftDeletes ?? model?.traits?.softDeletable ?? false;
    const attributes = await extractFields(model, modeFileElement);
    fieldString += ` id: number
`;
    fieldStringInt += `public id = 1
`;
    const entityGroups = {};
    for (const attribute of attributes) {
      const entity = attribute.fieldArray?.entity === "enum" ? "string[] | string" : attribute.fieldArray?.entity;
      let defaultValue = `''`;
      if (attribute.fieldArray?.entity === "boolean")
        defaultValue = false;
      if (attribute.fieldArray?.entity === "number")
        defaultValue = 0;
      if (attribute.fieldArray?.entity === "enum")
        defaultValue = "[]";
      const snakeField = snakeCase(attribute.field);
      if (typeof entity === "string") {
        if (entityGroups[entity]) {
          entityGroups[entity].push(`'${snakeField}'`);
        } else {
          entityGroups[entity] = [`'${snakeField}'`];
        }
        fieldString += ` ${snakeCase(attribute.field)}: ${entity}
     `;
        fieldStringInt += `public ${snakeField} = ${defaultValue}
`;
      }
    }
    fieldStringType += ` get: <T = string>(element: string, defaultValue?: T) => T`;
    const otherModelRelations = await fetchOtherModelRelations(modelName);
    for (const otherModel of otherModelRelations) {
      if (!otherModel.foreignKey)
        continue;
      fieldString += ` ${otherModel.foreignKey}: number
     `;
      fieldStringInt += `public ${otherModel.foreignKey} = 0
`;
    }
    if (useTimestamps) {
      fieldStringInt += `public created_at = ''
        public updated_at = ''
      `;
    }
    if (useUuid)
      fieldStringInt += `public uuid = ''`;
    if (useSoftDeletes) {
      fieldStringInt += `
        public deleted_at = ''
      `;
      fieldString += `deleted_at?: string
`;
    }
    fieldString += `created_at?: string
      updated_at?: string`;
    const requestFile = Bun.file(path14.frameworkPath(`requests/${modelName}Request.ts`));
    importTypes = `${modelName}RequestType`;
    importTypesString += `${importTypes}`;
    if (i2 < modelFiles.length - 1)
      importTypesString += ` | `;
    fileString += `import type { ${importTypes} } from '../types/requests'

`;
    fileString += `interface ValidationField {
      rule: ReturnType<typeof schema.string>
      message: Record<string, string>
    }

`;
    fileString += `interface CustomAttributes {
      [key: string]: ValidationField
    }
`;
    const types5 = `export interface ${modelName}RequestType extends Request {
      validate(attributes?: CustomAttributes): Promise<void>
      ${fieldStringType}
      all(): RequestData${modelName}
      ${fieldString}
    }

`;
    typeString += `interface RequestData${modelName} {
      ${fieldString}
    }
`;
    fileString += `interface RequestData${modelName} {
      ${fieldString}
    }
`;
    typeString += types5;
    fileString += `export class ${modelName}Request extends Request<RequestData${modelName}> implements ${modelName}RequestType {
      ${fieldStringInt}
      public async validate(attributes?: CustomAttributes): Promise<void> {
        if (attributes === undefined || attributes === null) {
          await validateField('${modelName}', this.all())
        } else {
          await customValidate(attributes, this.all())
        }
      }
    }

    export const ${camelCase(modelName)}Request = new ${modelName}Request()
    `;
    const writer = requestFile.writer();
    writer.write(fileString);
  }
  typeString += `export type ModelRequest = ${importTypesString}`;
  const requestD = path14.frameworkPath("types/requests.d.ts");
  await fs8.writeFile(requestD, typeString);
}
async function writeOrmActions(apiRoute, modelName, actionPath) {
  const formattedApiRoute = apiRoute.charAt(0).toUpperCase() + apiRoute.slice(1);
  let method = "GET";
  let actionString = `import { Action } from '@stacksjs/actions'
 import { response } from '@stacksjs/router'

`;
  let handleString = ``;
  if (apiRoute === "index") {
    handleString += `async handle() {
        const results = await ${modelName}.all()

        return response.json(results)
      },`;
    method = "GET";
  }
  if (apiRoute === "show") {
    actionString += `  import type { ${modelName}RequestType } from '@stacksjs/orm'
 import { ${modelName} } from '@stacksjs/orm'
 import { response } from '@stacksjs/router'

`;
    handleString += `async handle(request: ${modelName}RequestType) {
        const id = request.getParam('id')

        const model = await ${modelName}.findOrFail(id)

        return response.json(model)
      },`;
    method = "GET";
  }
  if (apiRoute === "destroy") {
    actionString += `  import type { ${modelName}RequestType } from '@stacksjs/orm'
 import { ${modelName} } from '@stacksjs/orm'
 import { response } from '@stacksjs/router'

`;
    handleString += `async handle(request: ${modelName}RequestType) {
        const id = request.getParam('id')

        const model = await ${modelName}.findOrFail(id)

        model?.delete()

        return response.json({ message: 'Model deleted!' })
      },`;
    method = "DELETE";
  }
  if (apiRoute === "store") {
    actionString += `  import type { ${modelName}RequestType } from '@stacksjs/orm'
 import { ${modelName} } from '@stacksjs/orm'
 import { response } from '@stacksjs/router'

`;
    handleString += `async handle(request: ${modelName}RequestType) {
        await request.validate()
        const model = await ${modelName}.create(request.all())

        return response.json(model)
      },`;
    method = "POST";
  }
  if (apiRoute === "update") {
    actionString += `  import type { ${modelName}RequestType } from '@stacksjs/orm'
  import { ${modelName} } from '@stacksjs/orm'
 import { response } from '@stacksjs/router'

`;
    handleString += `async handle(request: ${modelName}RequestType) {
        await request.validate()

        const id = request.getParam('id')
        const model = await ${modelName}.findOrFail(id)

        const result = model?.update(request.all())

        return response.json(result)
      },`;
    method = "PATCH";
  }
  actionString += `export default new Action({
      name: '${modelName} ${formattedApiRoute}',
      description: '${modelName} ${formattedApiRoute} ORM Action',
      method: '${method}',
      ${handleString}
    })
  `;
  const actionName = actionPath || `${modelName}${formattedApiRoute}OrmAction.ts`;
  const actionFile = path14.builtUserActionsPath(`src/${actionName}`);
  if (fs8.existsSync(actionFile))
    return;
  const file = Bun.file(actionFile);
  const writer = file.writer();
  writer.write(actionString);
}
async function extractFields(model, modelFile) {
  let fields2 = model.attributes;
  if (!fields2)
    fields2 = {};
  const fieldKeys = Object.keys(fields2);
  const rules2 = [];
  const file = Bun.file(modelFile);
  const code = await file.text();
  const regex = /rule:.*$/gm;
  let match;
  match = regex.exec(code);
  while (match !== null) {
    rules2.push(match[0]);
    match = regex.exec(code);
  }
  const input = fieldKeys.map((field, index) => {
    const fieldExist = fields2[field];
    let defaultValue = null;
    let uniqueValue = false;
    let hiddenValue = false;
    let fillableValue = false;
    let requiredValue = false;
    if (fieldExist) {
      defaultValue = fieldExist || null;
      uniqueValue = fieldExist.unique || false;
      hiddenValue = fieldExist.hidden || false;
      fillableValue = fieldExist.fillable || false;
    }
    const rule = rules2[index] ?? "";
    requiredValue = (fieldExist.validation?.rule).isRequired ?? false;
    return {
      field,
      default: defaultValue,
      unique: uniqueValue,
      hidden: hiddenValue,
      fillable: fillableValue,
      required: requiredValue,
      fieldArray: parseRule(rule)
    };
  });
  return input;
}
function parseRule(rule) {
  const parts = rule.split("rule: schema.");
  if (parts.length !== 2)
    return null;
  if (!parts[1])
    parts[1] = "";
  const extractedString = parts[1].replace(/,/g, "");
  if (!extractedString)
    return null;
  const extractedParts = extractedString.split(".");
  const regex = /\(([^)]+)\)/;
  return extractedParts.map((input) => {
    const match = regex.exec(input);
    const value = match ? match[1] : null;
    const field = input.replace(regex, "").replace(/\(|\)/g, "");
    return { entity: field, charValue: value };
  })[0] || null;
}
async function generateApiRoutes(modelFiles) {
  const file = Bun.file(path14.frameworkPath(`orm/routes.ts`));
  const writer = file.writer();
  let routeString = `import { route } from '@stacksjs/router'


`;
  for (const modelFile of modelFiles) {
    log16.info(`Generating API Routes for: ${italic9(modelFile)}`);
    let middlewareString = "";
    const model = (await import(modelFile)).default;
    const modelName = getModelName(model, modelFile);
    const tableName = getTableName(model, modelFile);
    if (model.traits?.useApi) {
      if (model.traits?.useApi && typeof model.traits.useApi === "object") {
        const middlewares = model.traits.useApi?.middleware;
        const uri = model.traits.useApi?.uri || tableName;
        if (middlewares) {
          middlewareString = `.middleware([`;
          if (middlewares.length) {
            for (let i2 = 0;i2 < middlewares.length; i2++) {
              middlewareString += `'${middlewares[i2]}'`;
              if (i2 < middlewares.length - 1) {
                middlewareString += ",";
              }
            }
          }
          middlewareString += `])`;
        }
        if (model.traits.useApi.routes && Object.keys(model.traits.useApi.routes).length > 0) {
          const apiRoutes = model.traits.useApi.routes;
          if (Array.isArray(apiRoutes)) {
            if (apiRoutes.length) {
              for (const apiRoute of apiRoutes) {
                if (typeof apiRoute === "string") {
                  await writeOrmActions(apiRoute, modelName);
                  const formattedApiRoute = apiRoute.charAt(0).toUpperCase() + apiRoute.slice(1);
                  if (apiRoute === "index")
                    routeString += `route.get('${uri}', '${modelName}${formattedApiRoute}OrmAction')

`;
                  if (apiRoute === "show")
                    routeString += `route.get('${uri}/{id}', '${modelName}${formattedApiRoute}OrmAction')

`;
                  if (apiRoute === "store")
                    routeString += `route.post('${uri}', '${modelName}${formattedApiRoute}OrmAction')

`;
                  if (apiRoute === "update")
                    routeString += `route.patch('${uri}/{id}', '${modelName}${formattedApiRoute}OrmAction')

`;
                  if (apiRoute === "destroy")
                    routeString += `route.delete('${uri}/{id}', '${modelName}${formattedApiRoute}OrmAction')

`;
                }
              }
            }
          } else {
            if (typeof apiRoutes === "object") {
              for (const apiRoute in apiRoutes) {
                if (Object.prototype.hasOwnProperty.call(apiRoutes, apiRoute)) {
                  const routePath = apiRoutes[apiRoute];
                  await writeOrmActions(apiRoute, modelName, routePath);
                  if (typeof routePath !== "string") {
                    throw new TypeError(`Invalid route path for ${apiRoute}`);
                  }
                  const pathAction = `${routePath}.ts`;
                  if (apiRoute === "index")
                    routeString += `route.get('${uri}', '${pathAction}').${middlewareString}

`;
                  if (apiRoute === "show")
                    routeString += `route.get('${uri}/{id}', '${pathAction}').${middlewareString}

`;
                  if (apiRoute === "store")
                    routeString += `route.post('${uri}', '${pathAction}').${middlewareString}

`;
                  if (apiRoute === "update")
                    routeString += `route.patch('${uri}/{id}', '${pathAction}').${middlewareString}

`;
                  if (apiRoute === "destroy")
                    routeString += `route.delete('${uri}/{id}', '${pathAction}').${middlewareString}

`;
                }
              }
            }
          }
        }
      }
      if (typeof model.traits.useApi === "boolean" && model.traits?.useApi) {
        const uri = tableName;
        const apiRoutes = ["index", "show", "store", "update", "destroy"];
        for (const apiRoute of apiRoutes) {
          await writeOrmActions(apiRoute, modelName);
          const formattedApiRoute = apiRoute.charAt(0).toUpperCase() + apiRoute.slice(1);
          const pathAction = path14.builtUserActionsPath(`src/${modelName}${formattedApiRoute}OrmAction.ts`, {
            relative: true
          });
          if (apiRoute === "index")
            routeString += `route.get('${uri}', '${pathAction}')

`;
          if (apiRoute === "show")
            routeString += `route.get('${uri}/{id}', '${pathAction}')

`;
          if (apiRoute === "store")
            routeString += `route.post('${uri}', '${pathAction}')

`;
          if (apiRoute === "update")
            routeString += `route.patch('${uri}/{id}', '${pathAction}')

`;
          if (apiRoute === "destroy")
            routeString += `route.delete('${uri}/{id}', '${pathAction}')

`;
        }
      }
    }
  }
  writer.write(routeString);
  await writer.end();
}
async function deleteExistingTypes() {
  try {
    const typeFiles = globSync6(path14.frameworkPath("orm/src/types/*Type.ts"));
    for (const file of typeFiles) {
      await Bun.write(file, "");
      log16.info("Deleted type file:", file);
    }
  } catch (error) {
    handleError3(error);
  }
}
async function deleteExistingModels(modelStringFile) {
  try {
    const typePath = path14.frameworkPath(`orm/src/types.ts`);
    await fs8.writeFile(typePath, "");
    if (modelStringFile) {
      const modelPath = path14.frameworkPath(`orm/src/models/${modelStringFile}.ts`);
      if (fs8.existsSync(modelPath))
        await fs8.promises.unlink(modelPath);
      return;
    }
    const modelPaths = globSync6([path14.frameworkPath(`orm/src/models/*.ts`)], { absolute: true });
    await Promise.all(modelPaths.map(async (modelPath) => {
      if (fs8.existsSync(modelPath)) {
        log16.info(`Deleting Model: ${italic9(modelPath)}`);
        await fs8.promises.unlink(modelPath);
        log16.success(`Deleted Model: ${italic9(modelPath)}`);
      }
    }));
    await deleteExistingTypes();
    await deleteExistingOrmActions(modelStringFile);
    await deleteExistingModelNameTypes();
    await deleteAttributeTypes();
    await deleteModelEvents();
    await deleteOrmImports();
    await deleteExistingModelRequest(modelStringFile);
    await deleteExistingOrmRoute();
  } catch (error) {
    handleError3(error);
  }
}
async function deleteExistingOrmActions(modelStringFile) {
  if (modelStringFile) {
    const ormPath = path14.builtUserActionsPath(`src/${modelStringFile}.ts`);
    if (fs8.existsSync(ormPath))
      await fs8.promises.unlink(ormPath);
    return;
  }
  const ormPaths = globSync6([path14.builtUserActionsPath("**/*.ts")], { absolute: true });
  for (const ormPath of ormPaths) {
    if (fs8.existsSync(ormPath))
      await fs8.promises.unlink(ormPath);
  }
}
async function deleteExistingModelNameTypes() {
  const typeFile = path14.corePath("types/src/model-names.ts");
  await fs8.writeFile(typeFile, "");
}
async function deleteAttributeTypes() {
  const typeFile = path14.frameworkPath("types/attributes.ts");
  await fs8.writeFile(typeFile, "");
}
async function deleteModelEvents() {
  const eventFile = path14.frameworkPath("types/events.ts");
  await fs8.writeFile(eventFile, "");
}
async function deleteOrmImports() {
  const ormImportFile = path14.frameworkPath(`orm/src/index.ts`);
  await fs8.writeFile(ormImportFile, "");
}
async function deleteExistingModelRequest(modelStringFile) {
  const requestD = path14.frameworkPath("types/requests.d.ts");
  await fs8.writeFile(requestD, "");
  if (modelStringFile) {
    const requestFile = path14.frameworkPath(`requests/${modelStringFile}.ts`);
    if (fs8.existsSync(requestFile))
      await fs8.promises.unlink(requestFile);
    return;
  }
  const requestFiles = globSync6([path14.frameworkPath("requests/*.ts")], { absolute: true });
  for (const requestFile of requestFiles) {
    if (fs8.existsSync(requestFile))
      await fs8.promises.unlink(requestFile);
  }
}
async function deleteExistingOrmRoute() {
  const ormRoute = path14.frameworkPath("orm/routes.ts");
  await fs8.writeFile(ormRoute, "");
}
function generateTraitBasedTables() {
  let text2 = "";
  text2 += `  migrations: MigrationsTable
`;
  text2 += `  passkeys: PasskeysTable
`;
  text2 += `  commentables: CommentablesTable
`;
  text2 += `  taggables: TaggableTable
`;
  text2 += `  commentable_upvotes: CommentableUpvotesTable
`;
  text2 += `  categorizables: CategorizableTable
`;
  text2 += `  categorizable_models: CategorizableModelsTable
`;
  text2 += `  taggable_models: TaggableModelsTable
`;
  text2 += `  password_resets: PasswordResetsTable
`;
  text2 += `  query_logs: QueryLogsTable
`;
  return text2;
}
async function generateKyselyTypes() {
  const modelFiles = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
  let text2 = ``;
  for (const modelFile of modelFiles) {
    const model = (await import(modelFile)).default;
    const tableName = getTableName(model, modelFile);
    const modelName = getModelName(model, modelFile);
    const words = tableName.split("_");
    const pivotFormatted2 = `${words.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("")}`;
    text2 += `import type { ${pivotFormatted2}Table } from '../src/types/${modelName}Type'
`;
  }
  text2 += `import type { Generated } from 'kysely'

`;
  let pivotFormatted = "";
  for (const modelFile of modelFiles) {
    const model = (await import(modelFile)).default;
    const modelName = getModelName(model, modelFile);
    const pivotTables = await getPivotTables(model, modelName);
    for (const pivotTable of pivotTables) {
      const words = pivotTable.table.split("_");
      pivotFormatted = `${words.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("")}Table`;
      text2 += `export interface ${pivotFormatted} {
        id: Generated<number>
        ${pivotTable.firstForeignKey}: number
        ${pivotTable.secondForeignKey}: number
      }

`;
    }
  }
  text2 += generateTraitTableInterfaces();
  text2 += `
export interface Database {
`;
  const pushedTables = [];
  for (const modelFile of modelFiles) {
    const model = (await import(modelFile)).default;
    const modelName = getModelName(model, modelFile);
    const tableName = getTableName(model, modelFile);
    const pivotTables = await getPivotTables(model, modelName);
    for (const pivotTable of pivotTables) {
      if (pushedTables.includes(pivotTable.table))
        continue;
      text2 += `  ${pivotTable.table}: ${pivotFormatted}
`;
      pushedTables.push(pivotTable.table);
    }
    const words = tableName.split("_");
    const formattedTableName = `${words.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("")}Table`;
    if (!pushedTables.includes(tableName)) {
      text2 += `  ${tableName}: ${formattedTableName}
`;
      pushedTables.push(tableName);
    }
  }
  text2 += generateTraitBasedTables();
  text2 += `}
`;
  const file = Bun.file(path14.frameworkPath("orm/src/types.ts"));
  const writer = file.writer();
  writer.write(text2);
  await writer.end();
}
function mapEntity(attribute) {
  const entity = attribute.fieldArray?.entity;
  switch (entity) {
    case "enum":
      return "string | string[]";
    case "date":
      return "Date | string";
    case "timestamp":
      return "Date | string";
    case "datetime":
      return "Date | string";
    default:
      return entity;
  }
}
function extractImports(filePath) {
  const content = fs8.readFileSync(filePath, "utf8");
  const ast = import_parser.default.parse(content, {
    sourceType: "module",
    plugins: ["typescript", "classProperties", "decorators-legacy"]
  });
  const imports = [];
  import_traverse.default(ast, {
    ImportDeclaration(path15) {
      const generated2 = import_generator.default(path15.node, {}, content);
      imports.push(generated2.code);
    }
  });
  return imports;
}
async function generateModelFiles(modelStringFile) {
  try {
    log16.info("Cleanup of older Models...");
    await deleteExistingModels(modelStringFile);
    log16.success("Deleted Models");
    log16.info("Deleting old Model Name types...");
    await deleteExistingModelNameTypes();
    log16.success("Deleted Model Name types");
    log16.info("Deleting old attribute types...");
    await deleteAttributeTypes();
    log16.success("Deleted old attribute types");
    log16.info("Deleting old model events...");
    await deleteModelEvents();
    log16.success("Deleted old model events");
    log16.info("Deleting old orm imports...");
    await deleteOrmImports();
    log16.success("Deleted old orm imports");
    log16.info("Deleting old Model Requests...");
    await deleteExistingModelRequest(modelStringFile);
    log16.success("Deleted Model Requests");
    log16.info("Deleting old Model Routes...");
    await deleteExistingOrmRoute();
    log16.success("Deleted Model Routes");
    try {
      log16.info("Writing Model Names...");
      await writeModelNames();
      log16.success("Wrote Model Names");
    } catch (error) {
      log16.error(error);
      handleError3("Error while writing Model Names", error);
    }
    try {
      log16.info("Writing Table Names...");
      await writeTableNames();
      log16.success("Wrote Table Names");
    } catch (error) {
      handleError3("Error while writing Table Names", error);
    }
    try {
      log16.info("Writing Model Requests...");
      await writeModelRequest();
      log16.success("Wrote Model Requests");
    } catch (error) {
      handleError3("Error while writing Model Requests", error);
    }
    try {
      log16.info("Writing Model Attributes...");
      await writeModelAttributes();
      await generateTraitRequestTypes();
      log16.success("Wrote Model Attributes");
    } catch (error) {
      handleError3("Error while writing Model Attributes", error);
    }
    try {
      log16.info("Writing Model Events...");
      await writeModelEvents();
      log16.success("Wrote Model Events");
    } catch (error) {
      handleError3("Error while writing Model Events", error);
    }
    log16.info("Generating API Routes...");
    const modelFiles = globSync6([path14.userModelsPath("**/*.ts"), path14.storagePath("framework/defaults/models/**/*.ts")], { absolute: true });
    await generateApiRoutes(modelFiles);
    log16.success("Generated API Routes");
    for (const modelFile of modelFiles) {
      if (modelStringFile && modelStringFile !== modelFile)
        continue;
      log16.info(`Processing Model: ${italic9(modelFile)}`);
      const model = (await import(modelFile)).default;
      const tableName = getTableName(model, modelFile);
      const modelName = getModelName(model, modelFile);
      const file = Bun.file(path14.frameworkPath(`orm/src/models/${modelName}.ts`));
      const fields2 = await extractFields(model, modelFile);
      const imports = extractImports(modelFile);
      const classString = await generateModelString(tableName, modelName, model, fields2, imports);
      await writeTypeFile(tableName, modelName, model, fields2);
      const writer = file.writer();
      log16.info(`Writing Model: ${italic9(modelName)}`);
      writer.write(classString);
      log16.success(`Wrote Model: ${italic9(modelName)}`);
      await writer.end();
    }
    log16.info("Generating Query Builder types...");
    await generateKyselyTypes();
    log16.success("Generated Query Builder types");
    log16.info("Writing Model Orm Imports...");
    await writeModelOrmImports(modelFiles);
    log16.success("Wrote Model Orm Imports");
    await ensureCodeStyle();
  } catch (error) {
    handleError3("Error while generating model files", error);
  }
}
async function writeModelOrmImports(modelFiles) {
  let ormImportString = ``;
  for (const modelFile of modelFiles) {
    const model = (await import(modelFile)).default;
    const modelName = getModelName(model, modelFile);
    const tableName = getTableName(model, modelFile);
    ormImportString += `export { type ${modelName}JsonResponse, type ${pascalCase(tableName)}Table, type New${modelName}, type ${modelName}ModelType, type ${modelName}Update } from './types/${modelName}Type'

`;
    ormImportString += `export { default as ${modelName}, ${modelName}Model } from './models/${modelName}'

`;
  }
  const file = Bun.file(path14.frameworkPath(`orm/src/index.ts`));
  const writer = file.writer();
  writer.write(ormImportString);
  await writer.end();
}
async function ensureCodeStyle() {
  log16.info("Linting code style...");
  const proc = Bun.spawn(["bunx", "--bun", "eslint", ".", "--fix"], {
    stdio: ["ignore", "pipe", "pipe"],
    cwd: path14.projectPath()
  });
  const stdoutReader = proc.stdout.getReader();
  while (true) {
    const { done } = await stdoutReader.read();
    if (done)
      break;
  }
  const stderrReader = proc.stderr.getReader();
  while (true) {
    const { done } = await stderrReader.read();
    if (done)
      break;
  }
  const exitCode = await proc.exited;
  if (exitCode !== 0) {
    log16.debug("There was an error fixing your code style but we are ignoring it because we fixed the auto-generated code already. Run `bunx eslint . --fix` to fix the rest of the code.");
  } else {
    log16.debug("Code style fixed successfully.");
  }
}
function findCoreModel(modelName) {
  const rootPath = path14.join(path14.storagePath("framework/defaults/models"), "/");
  const matches = globSync6(`${rootPath}**/${modelName}`, {
    absolute: true
  });
  return matches[0] ?? "";
}
function findUserModel(modelName) {
  const rootPath = path14.join(path14.userModelsPath("/"), "/");
  const matches = globSync6(`${rootPath}**/${modelName}`, {
    absolute: true
  });
  return matches[0] ?? "";
}
function formatDate(date) {
  return date.toISOString().replace("T", " ").split(".")[0];
}
async function generateTypeString(tableName, modelName, model, attributes) {
  const formattedTableName = pascalCase(tableName);
  const formattedModelName = camelCase(modelName);
  const useUuid = model.traits?.useUuid;
  const useTimestamps = model.traits?.useTimestamps;
  const billable = model.traits?.billable;
  const relations = await getRelations(model, modelName);
  let relationImports = ``;
  for (const relation of relations) {
    const modelRelation = relation.model;
    relationImports += `import type { ${modelRelation}ModelType } from './${modelRelation}Type'
`;
  }
  let typeString = `import type { Generated, Insertable, RawBuilder, Selectable, Updateable } from '@stacksjs/database'
import type { Operator } from '@stacksjs/orm'
${relationImports}

export interface ${formattedTableName}Table {
  id: Generated<number>
`;
  for (const attribute of attributes) {
    const entity = mapEntity(attribute);
    const optionalIndicator = attribute.required === false ? "?" : "";
    typeString += `  ${snakeCase(attribute.field)}${optionalIndicator}: ${entity}
`;
  }
  for (const relation of relations) {
    const relationType = getRelationType(relation.relationship);
    const relationCount = getRelationCount(relation.relationship);
    if (relationType === "belongsType" && !relationCount) {
      typeString += `  ${relation.modelKey}?: number
`;
    }
  }
  if (useUuid) {
    typeString += `  uuid?: string
`;
  }
  if (useTimestamps) {
    typeString += `  created_at?: string
`;
    typeString += `  updated_at?: string
`;
  }
  if (billable) {
    typeString += `  stripe_id?: string
`;
  }
  typeString += `}`;
  let modelTypeInterface = `export interface ${modelName}ModelType {
  // Properties
  readonly id: number
`;
  for (const attribute of attributes) {
    const fieldName = camelCase(attribute.field);
    const entity = mapEntity(attribute);
    const optionalIndicator = attribute.required === false ? " | undefined" : "";
    modelTypeInterface += `  get ${fieldName}(): ${entity}${optionalIndicator}
  set ${fieldName}(value: ${entity})
`;
  }
  for (const relation of relations) {
    const modelRelation = relation.model;
    const formattedModelRelation = camelCase(modelRelation);
    const relationType = getRelationType(relation.relationship);
    const relationCount = getRelationCount(relation.relationship);
    if (relationType === "hasType" && relationCount === "many") {
      const relationName = relation.relationName || formattedModelRelation;
      modelTypeInterface += `  get ${snakeCase(relationName)}(): ${modelRelation}ModelType[] | []
`;
    }
    if (relationType === "morphType" && relationCount === "one") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      modelTypeInterface += `  get ${snakeCase(morphName)}(): ${modelRelation}ModelType | undefined
`;
    }
    if (relationType === "morphType" && relationCount === "many") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      modelTypeInterface += `  get ${snakeCase(morphName)}(): ${modelRelation}ModelType[] | []
`;
    }
    if (relationType === "belongsType" && !relationCount) {
      const relationName = camelCase(relation.relationName || formattedModelRelation);
      modelTypeInterface += `
  ${relationName}Belong: () => Promise<${modelRelation}Type>`;
    }
    if (relationType === "belongsType" && relationCount === "many") {
      const relationName = relation.relationName || formattedModelName + plural(pascalCase(modelRelation));
      modelTypeInterface += `
  ${relationName}: () => Promise<${modelRelation}Type[]>`;
    }
  }
  if (useUuid) {
    modelTypeInterface += `
  get uuid(): string | undefined
  set uuid(value: string)
`;
  }
  if (useTimestamps) {
    modelTypeInterface += `
  get created_at(): string | undefined
  get updated_at(): string | undefined
  set updated_at(value: string)
`;
  }
  if (billable) {
    modelTypeInterface += `
  get stripe_id(): string | undefined
  set stripe_id(value: string)
`;
  }
  modelTypeInterface += `
  // Static methods
  with: (relations: string[]) => ${modelName}ModelType
  select: (params: (keyof ${modelName}JsonResponse)[] | RawBuilder<string> | string) => ${modelName}ModelType
  find: (id: number) => Promise<${modelName}ModelType | undefined>
  first: () => Promise<${modelName}ModelType | undefined>
  last: () => Promise<${modelName}ModelType | undefined>
  firstOrFail: () => Promise<${modelName}ModelType | undefined>
  all: () => Promise<${modelName}ModelType[]>
  findOrFail: (id: number) => Promise<${modelName}ModelType | undefined>
  findMany: (ids: number[]) => Promise<${modelName}ModelType[]>
  latest: (column?: keyof ${formattedTableName}Table) => Promise<${modelName}ModelType | undefined>
  oldest: (column?: keyof ${formattedTableName}Table) => Promise<${modelName}ModelType | undefined>
  skip: (count: number) => ${modelName}ModelType
  take: (count: number) => ${modelName}ModelType
  where: <V = string>(column: keyof ${formattedTableName}Table, ...args: [V] | [Operator, V]) => ${modelName}ModelType
  orWhere: (...conditions: [string, any][]) => ${modelName}ModelType
  whereNotIn: <V = number>(column: keyof ${formattedTableName}Table, values: V[]) => ${modelName}ModelType
  whereBetween: <V = number>(column: keyof ${formattedTableName}Table, range: [V, V]) => ${modelName}ModelType
  whereRef: (column: keyof ${formattedTableName}Table, ...args: string[]) => ${modelName}ModelType
  when: (condition: boolean, callback: (query: ${modelName}ModelType) => ${modelName}ModelType) => ${modelName}ModelType
  whereNull: (column: keyof ${formattedTableName}Table) => ${modelName}ModelType
  whereNotNull: (column: keyof ${formattedTableName}Table) => ${modelName}ModelType
  whereLike: (column: keyof ${formattedTableName}Table, value: string) => ${modelName}ModelType
  orderBy: (column: keyof ${formattedTableName}Table, order: 'asc' | 'desc') => ${modelName}ModelType
  orderByAsc: (column: keyof ${formattedTableName}Table) => ${modelName}ModelType
  orderByDesc: (column: keyof ${formattedTableName}Table) => ${modelName}ModelType
  groupBy: (column: keyof ${formattedTableName}Table) => ${modelName}ModelType
  having: <V = string>(column: keyof ${formattedTableName}Table, operator: Operator, value: V) => ${modelName}ModelType
  inRandomOrder: () => ${modelName}ModelType
  whereColumn: (first: keyof ${formattedTableName}Table, operator: Operator, second: keyof ${formattedTableName}Table) => ${modelName}ModelType
  max: (field: keyof ${formattedTableName}Table) => Promise<number>
  min: (field: keyof ${formattedTableName}Table) => Promise<number>
  avg: (field: keyof ${formattedTableName}Table) => Promise<number>
  sum: (field: keyof ${formattedTableName}Table) => Promise<number>
  count: () => Promise<number>
  get: () => Promise<${modelName}ModelType[]>
  pluck: <K extends keyof ${modelName}ModelType>(field: K) => Promise<${modelName}ModelType[K][]>
  chunk: (size: number, callback: (models: ${modelName}ModelType[]) => Promise<void>) => Promise<void>
  paginate: (options?: { limit?: number, offset?: number, page?: number }) => Promise<{
    data: ${modelName}ModelType[]
    paging: {
      total_records: number
      page: number
      total_pages: number
    }
    next_cursor: number | null
  }>
  create: (new${modelName}: New${modelName}) => Promise<${modelName}ModelType>
  firstOrCreate: (search: Partial<${formattedTableName}Table>, values?: New${modelName}) => Promise<${modelName}ModelType>
  updateOrCreate: (search: Partial<${formattedTableName}Table>, values?: New${modelName}) => Promise<${modelName}ModelType>
  createMany: (new${modelName}: New${modelName}[]) => Promise<void>
  forceCreate: (new${modelName}: New${modelName}) => Promise<${modelName}ModelType>
  remove: (id: number) => Promise<any>
  whereIn: <V = number>(column: keyof ${formattedTableName}Table, values: V[]) => ${modelName}ModelType
  distinct: (column: keyof ${modelName}JsonResponse) => ${modelName}ModelType
  join: (table: string, firstCol: string, secondCol: string) => ${modelName}ModelType

  // Instance methods
  createInstance: (data: ${modelName}JsonResponse) => ${modelName}ModelType
  update: (new${modelName}: ${modelName}Update) => Promise<${modelName}ModelType | undefined>
  forceUpdate: (new${modelName}: ${modelName}Update) => Promise<${modelName}ModelType | undefined>
  save: () => Promise<${modelName}ModelType>
  delete: () => Promise<number>
  toSearchableObject: () => Partial<${modelName}JsonResponse>
  toJSON: () => ${modelName}JsonResponse
  parseResult: (model: ${modelName}ModelType) => ${modelName}ModelType
`;
  for (const relation of relations) {
    const modelRelation = relation.model;
    const formattedModelRelation = camelCase(modelRelation);
    const relationType = getRelationType(relation.relationship);
    const relationCount = getRelationCount(relation.relationship);
    if (relationType === "throughType") {
      const relationName = relation.relationName || formattedModelName + modelRelation;
      if (relation.throughModel !== undefined) {
        modelTypeInterface += `
  ${relationName}: () => Promise<${modelRelation}Type | undefined>`;
      }
    }
    if (relationType === "morphType" && relationCount === "one") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      modelTypeInterface += `
  ${morphName}: () => Promise<${modelRelation}Type | undefined>`;
    }
    if (relationType === "morphType" && relationCount === "many") {
      const morphName = relation.relationName || `${formattedModelName}able`;
      modelTypeInterface += `
  ${morphName}: () => Promise<${modelRelation}Type[]>`;
    }
    if (relationType === "belongsType" && !relationCount) {
      const relationName = camelCase(relation.relationName || formattedModelRelation);
      modelTypeInterface += `
  ${relationName}Belong: () => Promise<${modelRelation}Type>`;
    }
    if (relationType === "belongsType" && relationCount === "many") {
      const relationName = relation.relationName || formattedModelName + plural(pascalCase(modelRelation));
      modelTypeInterface += `
  ${relationName}: () => Promise<${modelRelation}Type[]>`;
    }
  }
  modelTypeInterface += `
}`;
  const responseTypes = `export type ${modelName}Read = ${formattedTableName}Table

export type ${modelName}Write = Omit<${formattedTableName}Table, 'created_at'> & {
  created_at?: string
}

export interface ${modelName}Response {
  data: ${modelName}JsonResponse[]
  paging: {
    total_records: number
    page: number
    total_pages: number
  }
  next_cursor: number | null
}

export interface ${modelName}JsonResponse extends Omit<Selectable<${modelName}Read>, 'password'> {
  [key: string]: any
}

export type New${modelName} = Insertable<${modelName}Write>
export type ${modelName}Update = Updateable<${modelName}Write>`;
  return `${typeString}

${responseTypes}

${modelTypeInterface}`;
}
async function writeTypeFile(tableName, modelName, model, attributes) {
  log16.info("Writing type file for", modelName);
  const typeString = await generateTypeString(tableName, modelName, model, attributes);
  const typeFilePath = path14.frameworkPath(`orm/src/types/${modelName}Type.ts`);
  await Bun.write(typeFilePath, typeString);
}

export { User_default, isObject2 as isObject, isObjectNotEmpty, customValidate, generateModelFiles, formatDate, sql, db, seed };
