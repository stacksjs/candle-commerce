import {
  exports_vue,
  require_vue_cjs
} from "./chunk-h3h7cvw1.js";
import {
  DEFAULT_RETRY_MODE,
  EndpointCache,
  Hash,
  NODE_APP_ID_CONFIG_OPTIONS,
  NODE_MAX_ATTEMPT_CONFIG_OPTIONS,
  NODE_REGION_CONFIG_FILE_OPTIONS,
  NODE_REGION_CONFIG_OPTIONS,
  NODE_RETRY_MODE_CONFIG_OPTIONS,
  NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
  NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS,
  awsEndpointFunctions,
  calculateBodyLength,
  createDefaultUserAgentProvider,
  customEndpointFunctions,
  fromBase64,
  fromUtf8,
  getAwsRegionExtensionConfiguration,
  getContentLengthPlugin,
  getEndpointPlugin,
  getHostHeaderPlugin,
  getLoggerPlugin,
  getRecursionDetectionPlugin,
  getRetryPlugin,
  getSerdePlugin,
  getSmithyContext,
  getUserAgentPlugin,
  normalizeProvider,
  resolveAwsRegionExtensionConfiguration,
  resolveDefaultsModeConfig,
  resolveEndpoint,
  resolveEndpointConfig,
  resolveHostHeaderConfig,
  resolveRegionConfig,
  resolveRetryConfig,
  resolveUserAgentConfig,
  toBase64,
  toUtf8
} from "./chunk-2jnxjtkb.js";
import {
  loadConfig,
  parseUrl
} from "./chunk-1rm3adsy.js";
import {
  Client,
  Command,
  HttpRequest,
  NoOpLogger,
  NodeHttpHandler,
  ServiceException,
  createAggregatedClient,
  decorateServiceException,
  emitWarningIfUnsupportedVersion,
  exports_dist_es,
  getArrayIfSingleItem,
  getDefaultExtensionConfiguration,
  getHttpHandlerExtensionConfiguration,
  import_protocols,
  import_protocols1 as import_protocols2,
  loadConfigsForDefaultMode,
  resolveDefaultRuntimeConfig,
  resolveHttpHandlerRuntimeConfig,
  serializeDateTime,
  streamCollector,
  withBaseException
} from "./chunk-jc3evtjg.js";
import {
  ENV_PROFILE
} from "./chunk-0be2fzx4.js";
import {
  ENV_KEY,
  ENV_SECRET,
  fromEnv
} from "./chunk-55w3c74x.js";
import {
  require_dist_cjs1 as require_dist_cjs,
  require_dist_cjs3,
  require_tslib
} from "./chunk-3bna256j.js";
import {
  require_dist_cjs as require_dist_cjs2
} from "./chunk-v4rn7sgz.js";
import {
  require_compiler_dom_cjs,
  require_shared_cjs
} from "./chunk-rea8cd7n.js";
import {
  User_default,
  customValidate,
  db,
  formatDate,
  isObject,
  isObjectNotEmpty,
  sql
} from "./chunk-vt4r9y87.js";
import {
  exports_supports_color,
  init_supports_color,
  require_ms
} from "./chunk-kxsrvkd8.js";
import {
  decrypt,
  encrypt,
  make,
  verify
} from "./chunk-389b9wtx.js";
import {
  camelCase,
  kebabCase,
  pascalCase
} from "./chunk-jycndeyj.js";
import {
  __commonJS,
  __export,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-1j66gxht.js";

// ../../../../node_modules/@otplib/plugin-crypto/index.js
var require_plugin_crypto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var crypto = _interopDefault(__require("crypto"));
  var createDigest = (algorithm, hmacKey, counter) => {
    const hmac = crypto.createHmac(algorithm, Buffer.from(hmacKey, "hex"));
    const digest = hmac.update(Buffer.from(counter, "hex")).digest();
    return digest.toString("hex");
  };
  var createRandomBytes = (size, encoding) => {
    return crypto.randomBytes(size).toString(encoding);
  };
  exports.createDigest = createDigest;
  exports.createRandomBytes = createRandomBytes;
});

// ../../../../node_modules/thirty-two/lib/thirty-two/thirty-two.js
var require_thirty_two = __commonJS((exports) => {
  var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  var byteTable = [
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255
  ];
  function quintetCount(buff) {
    var quintets = Math.floor(buff.length / 5);
    return buff.length % 5 === 0 ? quintets : quintets + 1;
  }
  exports.encode = function(plain) {
    if (!Buffer.isBuffer(plain)) {
      plain = new Buffer(plain);
    }
    var i = 0;
    var j = 0;
    var shiftIndex = 0;
    var digit = 0;
    var encoded = new Buffer(quintetCount(plain) * 8);
    while (i < plain.length) {
      var current = plain[i];
      if (shiftIndex > 3) {
        digit = current & 255 >> shiftIndex;
        shiftIndex = (shiftIndex + 5) % 8;
        digit = digit << shiftIndex | (i + 1 < plain.length ? plain[i + 1] : 0) >> 8 - shiftIndex;
        i++;
      } else {
        digit = current >> 8 - (shiftIndex + 5) & 31;
        shiftIndex = (shiftIndex + 5) % 8;
        if (shiftIndex === 0)
          i++;
      }
      encoded[j] = charTable.charCodeAt(digit);
      j++;
    }
    for (i = j;i < encoded.length; i++) {
      encoded[i] = 61;
    }
    return encoded;
  };
  exports.decode = function(encoded) {
    var shiftIndex = 0;
    var plainDigit = 0;
    var plainChar;
    var plainPos = 0;
    if (!Buffer.isBuffer(encoded)) {
      encoded = new Buffer(encoded);
    }
    var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
    for (var i = 0;i < encoded.length; i++) {
      if (encoded[i] === 61) {
        break;
      }
      var encodedByte = encoded[i] - 48;
      if (encodedByte < byteTable.length) {
        plainDigit = byteTable[encodedByte];
        if (shiftIndex <= 3) {
          shiftIndex = (shiftIndex + 5) % 8;
          if (shiftIndex === 0) {
            plainChar |= plainDigit;
            decoded[plainPos] = plainChar;
            plainPos++;
            plainChar = 0;
          } else {
            plainChar |= 255 & plainDigit << 8 - shiftIndex;
          }
        } else {
          shiftIndex = (shiftIndex + 5) % 8;
          plainChar |= 255 & plainDigit >>> shiftIndex;
          decoded[plainPos] = plainChar;
          plainPos++;
          plainChar = 255 & plainDigit << 8 - shiftIndex;
        }
      } else {
        throw new Error("Invalid input - it is not base32 encoded string");
      }
    }
    return decoded.slice(0, plainPos);
  };
});

// ../../../../node_modules/thirty-two/lib/thirty-two/index.js
var require_thirty_two2 = __commonJS((exports) => {
  var base32 = require_thirty_two();
  exports.encode = base32.encode;
  exports.decode = base32.decode;
});

// ../../../../node_modules/@otplib/plugin-thirty-two/index.js
var require_plugin_thirty_two = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var thirtyTwo = _interopDefault(require_thirty_two2());
  var keyDecoder = (encodedSecret, encoding) => {
    return thirtyTwo.decode(encodedSecret).toString(encoding);
  };
  var keyEncoder = (secret, encoding) => {
    return thirtyTwo.encode(Buffer.from(secret, encoding).toString("ascii")).toString().replace(/=/g, "");
  };
  exports.keyDecoder = keyDecoder;
  exports.keyEncoder = keyEncoder;
});

// ../../../../node_modules/@otplib/core/index.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function objectValues(value) {
    return Object.keys(value).map((key) => value[key]);
  }
  (function(HashAlgorithms) {
    HashAlgorithms["SHA1"] = "sha1";
    HashAlgorithms["SHA256"] = "sha256";
    HashAlgorithms["SHA512"] = "sha512";
  })(exports.HashAlgorithms || (exports.HashAlgorithms = {}));
  var HASH_ALGORITHMS = objectValues(exports.HashAlgorithms);
  (function(KeyEncodings) {
    KeyEncodings["ASCII"] = "ascii";
    KeyEncodings["BASE64"] = "base64";
    KeyEncodings["HEX"] = "hex";
    KeyEncodings["LATIN1"] = "latin1";
    KeyEncodings["UTF8"] = "utf8";
  })(exports.KeyEncodings || (exports.KeyEncodings = {}));
  var KEY_ENCODINGS = objectValues(exports.KeyEncodings);
  (function(Strategy) {
    Strategy["HOTP"] = "hotp";
    Strategy["TOTP"] = "totp";
  })(exports.Strategy || (exports.Strategy = {}));
  var STRATEGY = objectValues(exports.Strategy);
  var createDigestPlaceholder = () => {
    throw new Error("Please provide an options.createDigest implementation.");
  };
  function isTokenValid(value) {
    return /^(\d+)$/.test(value);
  }
  function padStart(value, maxLength, fillString) {
    if (value.length >= maxLength) {
      return value;
    }
    const padding = Array(maxLength + 1).join(fillString);
    return `${padding}${value}`.slice(-1 * maxLength);
  }
  function keyuri(options) {
    const tmpl = `otpauth://${options.type}/{labelPrefix}:{accountName}?secret={secret}{query}`;
    const params = [];
    if (STRATEGY.indexOf(options.type) < 0) {
      throw new Error(`Expecting options.type to be one of ${STRATEGY.join(", ")}. Received ${options.type}.`);
    }
    if (options.type === "hotp") {
      if (options.counter == null || typeof options.counter !== "number") {
        throw new Error('Expecting options.counter to be a number when options.type is "hotp".');
      }
      params.push(`&counter=${options.counter}`);
    }
    if (options.type === "totp" && options.step) {
      params.push(`&period=${options.step}`);
    }
    if (options.digits) {
      params.push(`&digits=${options.digits}`);
    }
    if (options.algorithm) {
      params.push(`&algorithm=${options.algorithm.toUpperCase()}`);
    }
    if (options.issuer) {
      params.push(`&issuer=${encodeURIComponent(options.issuer)}`);
    }
    return tmpl.replace("{labelPrefix}", encodeURIComponent(options.issuer || options.accountName)).replace("{accountName}", encodeURIComponent(options.accountName)).replace("{secret}", options.secret).replace("{query}", params.join(""));
  }

  class OTP {
    constructor(defaultOptions = {}) {
      this._defaultOptions = Object.freeze({
        ...defaultOptions
      });
      this._options = Object.freeze({});
    }
    create(defaultOptions = {}) {
      return new OTP(defaultOptions);
    }
    clone(defaultOptions = {}) {
      const instance = this.create({
        ...this._defaultOptions,
        ...defaultOptions
      });
      instance.options = this._options;
      return instance;
    }
    get options() {
      return Object.freeze({
        ...this._defaultOptions,
        ...this._options
      });
    }
    set options(options) {
      this._options = Object.freeze({
        ...this._options,
        ...options
      });
    }
    allOptions() {
      return this.options;
    }
    resetOptions() {
      this._options = Object.freeze({});
    }
  }
  function hotpOptionsValidator(options) {
    if (typeof options.createDigest !== "function") {
      throw new Error("Expecting options.createDigest to be a function.");
    }
    if (typeof options.createHmacKey !== "function") {
      throw new Error("Expecting options.createHmacKey to be a function.");
    }
    if (typeof options.digits !== "number") {
      throw new Error("Expecting options.digits to be a number.");
    }
    if (!options.algorithm || HASH_ALGORITHMS.indexOf(options.algorithm) < 0) {
      throw new Error(`Expecting options.algorithm to be one of ${HASH_ALGORITHMS.join(", ")}. Received ${options.algorithm}.`);
    }
    if (!options.encoding || KEY_ENCODINGS.indexOf(options.encoding) < 0) {
      throw new Error(`Expecting options.encoding to be one of ${KEY_ENCODINGS.join(", ")}. Received ${options.encoding}.`);
    }
  }
  var hotpCreateHmacKey = (algorithm, secret, encoding) => {
    return Buffer.from(secret, encoding).toString("hex");
  };
  function hotpDefaultOptions() {
    const options = {
      algorithm: exports.HashAlgorithms.SHA1,
      createHmacKey: hotpCreateHmacKey,
      createDigest: createDigestPlaceholder,
      digits: 6,
      encoding: exports.KeyEncodings.ASCII
    };
    return options;
  }
  function hotpOptions(opt) {
    const options = {
      ...hotpDefaultOptions(),
      ...opt
    };
    hotpOptionsValidator(options);
    return Object.freeze(options);
  }
  function hotpCounter(counter) {
    const hexCounter = counter.toString(16);
    return padStart(hexCounter, 16, "0");
  }
  function hotpDigestToToken(hexDigest, digits) {
    const digest = Buffer.from(hexDigest, "hex");
    const offset = digest[digest.length - 1] & 15;
    const binary = (digest[offset] & 127) << 24 | (digest[offset + 1] & 255) << 16 | (digest[offset + 2] & 255) << 8 | digest[offset + 3] & 255;
    const token = binary % Math.pow(10, digits);
    return padStart(String(token), digits, "0");
  }
  function hotpDigest(secret, counter, options) {
    const hexCounter = hotpCounter(counter);
    const hmacKey = options.createHmacKey(options.algorithm, secret, options.encoding);
    return options.createDigest(options.algorithm, hmacKey, hexCounter);
  }
  function hotpToken(secret, counter, options) {
    const hexDigest = options.digest || hotpDigest(secret, counter, options);
    return hotpDigestToToken(hexDigest, options.digits);
  }
  function hotpCheck(token, secret, counter, options) {
    if (!isTokenValid(token)) {
      return false;
    }
    const systemToken = hotpToken(secret, counter, options);
    return token === systemToken;
  }
  function hotpKeyuri(accountName, issuer, secret, counter, options) {
    return keyuri({
      algorithm: options.algorithm,
      digits: options.digits,
      type: exports.Strategy.HOTP,
      accountName,
      counter,
      issuer,
      secret
    });
  }

  class HOTP extends OTP {
    create(defaultOptions = {}) {
      return new HOTP(defaultOptions);
    }
    allOptions() {
      return hotpOptions(this.options);
    }
    generate(secret, counter) {
      return hotpToken(secret, counter, this.allOptions());
    }
    check(token, secret, counter) {
      return hotpCheck(token, secret, counter, this.allOptions());
    }
    verify(opts) {
      if (typeof opts !== "object") {
        throw new Error("Expecting argument 0 of verify to be an object");
      }
      return this.check(opts.token, opts.secret, opts.counter);
    }
    keyuri(accountName, issuer, secret, counter) {
      return hotpKeyuri(accountName, issuer, secret, counter, this.allOptions());
    }
  }
  function parseWindowBounds(win) {
    if (typeof win === "number") {
      return [Math.abs(win), Math.abs(win)];
    }
    if (Array.isArray(win)) {
      const [past, future] = win;
      if (typeof past === "number" && typeof future === "number") {
        return [Math.abs(past), Math.abs(future)];
      }
    }
    throw new Error("Expecting options.window to be an number or [number, number].");
  }
  function totpOptionsValidator(options) {
    hotpOptionsValidator(options);
    parseWindowBounds(options.window);
    if (typeof options.epoch !== "number") {
      throw new Error("Expecting options.epoch to be a number.");
    }
    if (typeof options.step !== "number") {
      throw new Error("Expecting options.step to be a number.");
    }
  }
  var totpPadSecret = (secret, encoding, minLength) => {
    const currentLength = secret.length;
    const hexSecret = Buffer.from(secret, encoding).toString("hex");
    if (currentLength < minLength) {
      const newSecret = new Array(minLength - currentLength + 1).join(hexSecret);
      return Buffer.from(newSecret, "hex").slice(0, minLength).toString("hex");
    }
    return hexSecret;
  };
  var totpCreateHmacKey = (algorithm, secret, encoding) => {
    switch (algorithm) {
      case exports.HashAlgorithms.SHA1:
        return totpPadSecret(secret, encoding, 20);
      case exports.HashAlgorithms.SHA256:
        return totpPadSecret(secret, encoding, 32);
      case exports.HashAlgorithms.SHA512:
        return totpPadSecret(secret, encoding, 64);
      default:
        throw new Error(`Expecting algorithm to be one of ${HASH_ALGORITHMS.join(", ")}. Received ${algorithm}.`);
    }
  };
  function totpDefaultOptions() {
    const options = {
      algorithm: exports.HashAlgorithms.SHA1,
      createDigest: createDigestPlaceholder,
      createHmacKey: totpCreateHmacKey,
      digits: 6,
      encoding: exports.KeyEncodings.ASCII,
      epoch: Date.now(),
      step: 30,
      window: 0
    };
    return options;
  }
  function totpOptions(opt) {
    const options = {
      ...totpDefaultOptions(),
      ...opt
    };
    totpOptionsValidator(options);
    return Object.freeze(options);
  }
  function totpCounter(epoch, step) {
    return Math.floor(epoch / step / 1000);
  }
  function totpToken(secret, options) {
    const counter = totpCounter(options.epoch, options.step);
    return hotpToken(secret, counter, options);
  }
  function totpEpochsInWindow(epoch, direction, deltaPerEpoch, numOfEpoches) {
    const result = [];
    if (numOfEpoches === 0) {
      return result;
    }
    for (let i = 1;i <= numOfEpoches; i++) {
      const delta = direction * i * deltaPerEpoch;
      result.push(epoch + delta);
    }
    return result;
  }
  function totpEpochAvailable(epoch, step, win) {
    const bounds = parseWindowBounds(win);
    const delta = step * 1000;
    return {
      current: epoch,
      past: totpEpochsInWindow(epoch, -1, delta, bounds[0]),
      future: totpEpochsInWindow(epoch, 1, delta, bounds[1])
    };
  }
  function totpCheck(token, secret, options) {
    if (!isTokenValid(token)) {
      return false;
    }
    const systemToken = totpToken(secret, options);
    return token === systemToken;
  }
  function totpCheckByEpoch(epochs, token, secret, options) {
    let position = null;
    epochs.some((epoch, idx) => {
      if (totpCheck(token, secret, {
        ...options,
        epoch
      })) {
        position = idx + 1;
        return true;
      }
      return false;
    });
    return position;
  }
  function totpCheckWithWindow(token, secret, options) {
    if (totpCheck(token, secret, options)) {
      return 0;
    }
    const epochs = totpEpochAvailable(options.epoch, options.step, options.window);
    const backward = totpCheckByEpoch(epochs.past, token, secret, options);
    if (backward !== null) {
      return backward * -1;
    }
    return totpCheckByEpoch(epochs.future, token, secret, options);
  }
  function totpTimeUsed(epoch, step) {
    return Math.floor(epoch / 1000) % step;
  }
  function totpTimeRemaining(epoch, step) {
    return step - totpTimeUsed(epoch, step);
  }
  function totpKeyuri(accountName, issuer, secret, options) {
    return keyuri({
      algorithm: options.algorithm,
      digits: options.digits,
      step: options.step,
      type: exports.Strategy.TOTP,
      accountName,
      issuer,
      secret
    });
  }

  class TOTP extends HOTP {
    create(defaultOptions = {}) {
      return new TOTP(defaultOptions);
    }
    allOptions() {
      return totpOptions(this.options);
    }
    generate(secret) {
      return totpToken(secret, this.allOptions());
    }
    checkDelta(token, secret) {
      return totpCheckWithWindow(token, secret, this.allOptions());
    }
    check(token, secret) {
      const delta = this.checkDelta(token, secret);
      return typeof delta === "number";
    }
    verify(opts) {
      if (typeof opts !== "object") {
        throw new Error("Expecting argument 0 of verify to be an object");
      }
      return this.check(opts.token, opts.secret);
    }
    timeRemaining() {
      const options = this.allOptions();
      return totpTimeRemaining(options.epoch, options.step);
    }
    timeUsed() {
      const options = this.allOptions();
      return totpTimeUsed(options.epoch, options.step);
    }
    keyuri(accountName, issuer, secret) {
      return totpKeyuri(accountName, issuer, secret, this.allOptions());
    }
  }
  function authenticatorOptionValidator(options) {
    totpOptionsValidator(options);
    if (typeof options.keyDecoder !== "function") {
      throw new Error("Expecting options.keyDecoder to be a function.");
    }
    if (options.keyEncoder && typeof options.keyEncoder !== "function") {
      throw new Error("Expecting options.keyEncoder to be a function.");
    }
  }
  function authenticatorDefaultOptions() {
    const options = {
      algorithm: exports.HashAlgorithms.SHA1,
      createDigest: createDigestPlaceholder,
      createHmacKey: totpCreateHmacKey,
      digits: 6,
      encoding: exports.KeyEncodings.HEX,
      epoch: Date.now(),
      step: 30,
      window: 0
    };
    return options;
  }
  function authenticatorOptions(opt) {
    const options = {
      ...authenticatorDefaultOptions(),
      ...opt
    };
    authenticatorOptionValidator(options);
    return Object.freeze(options);
  }
  function authenticatorEncoder(secret, options) {
    return options.keyEncoder(secret, options.encoding);
  }
  function authenticatorDecoder(secret, options) {
    return options.keyDecoder(secret, options.encoding);
  }
  function authenticatorGenerateSecret(numberOfBytes, options) {
    const key = options.createRandomBytes(numberOfBytes, options.encoding);
    return authenticatorEncoder(key, options);
  }
  function authenticatorToken(secret, options) {
    return totpToken(authenticatorDecoder(secret, options), options);
  }
  function authenticatorCheckWithWindow(token, secret, options) {
    return totpCheckWithWindow(token, authenticatorDecoder(secret, options), options);
  }

  class Authenticator extends TOTP {
    create(defaultOptions = {}) {
      return new Authenticator(defaultOptions);
    }
    allOptions() {
      return authenticatorOptions(this.options);
    }
    generate(secret) {
      return authenticatorToken(secret, this.allOptions());
    }
    checkDelta(token, secret) {
      return authenticatorCheckWithWindow(token, secret, this.allOptions());
    }
    encode(secret) {
      return authenticatorEncoder(secret, this.allOptions());
    }
    decode(secret) {
      return authenticatorDecoder(secret, this.allOptions());
    }
    generateSecret(numberOfBytes = 10) {
      return authenticatorGenerateSecret(numberOfBytes, this.allOptions());
    }
  }
  exports.Authenticator = Authenticator;
  exports.HASH_ALGORITHMS = HASH_ALGORITHMS;
  exports.HOTP = HOTP;
  exports.KEY_ENCODINGS = KEY_ENCODINGS;
  exports.OTP = OTP;
  exports.STRATEGY = STRATEGY;
  exports.TOTP = TOTP;
  exports.authenticatorCheckWithWindow = authenticatorCheckWithWindow;
  exports.authenticatorDecoder = authenticatorDecoder;
  exports.authenticatorDefaultOptions = authenticatorDefaultOptions;
  exports.authenticatorEncoder = authenticatorEncoder;
  exports.authenticatorGenerateSecret = authenticatorGenerateSecret;
  exports.authenticatorOptionValidator = authenticatorOptionValidator;
  exports.authenticatorOptions = authenticatorOptions;
  exports.authenticatorToken = authenticatorToken;
  exports.createDigestPlaceholder = createDigestPlaceholder;
  exports.hotpCheck = hotpCheck;
  exports.hotpCounter = hotpCounter;
  exports.hotpCreateHmacKey = hotpCreateHmacKey;
  exports.hotpDefaultOptions = hotpDefaultOptions;
  exports.hotpDigestToToken = hotpDigestToToken;
  exports.hotpKeyuri = hotpKeyuri;
  exports.hotpOptions = hotpOptions;
  exports.hotpOptionsValidator = hotpOptionsValidator;
  exports.hotpToken = hotpToken;
  exports.isTokenValid = isTokenValid;
  exports.keyuri = keyuri;
  exports.objectValues = objectValues;
  exports.padStart = padStart;
  exports.totpCheck = totpCheck;
  exports.totpCheckByEpoch = totpCheckByEpoch;
  exports.totpCheckWithWindow = totpCheckWithWindow;
  exports.totpCounter = totpCounter;
  exports.totpCreateHmacKey = totpCreateHmacKey;
  exports.totpDefaultOptions = totpDefaultOptions;
  exports.totpEpochAvailable = totpEpochAvailable;
  exports.totpKeyuri = totpKeyuri;
  exports.totpOptions = totpOptions;
  exports.totpOptionsValidator = totpOptionsValidator;
  exports.totpPadSecret = totpPadSecret;
  exports.totpTimeRemaining = totpTimeRemaining;
  exports.totpTimeUsed = totpTimeUsed;
  exports.totpToken = totpToken;
});

// ../../../../node_modules/@otplib/preset-default/index.js
var require_preset_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var pluginCrypto = require_plugin_crypto();
  var pluginThirtyTwo = require_plugin_thirty_two();
  var core = require_core();
  var hotp = new core.HOTP({
    createDigest: pluginCrypto.createDigest
  });
  var totp = new core.TOTP({
    createDigest: pluginCrypto.createDigest
  });
  var authenticator = new core.Authenticator({
    createDigest: pluginCrypto.createDigest,
    createRandomBytes: pluginCrypto.createRandomBytes,
    keyDecoder: pluginThirtyTwo.keyDecoder,
    keyEncoder: pluginThirtyTwo.keyEncoder
  });
  exports.authenticator = authenticator;
  exports.hotp = hotp;
  exports.totp = totp;
});

// ../../../../node_modules/otplib/index.js
var require_otplib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var presetDefault = require_preset_default();
  Object.keys(presetDefault).forEach(function(k) {
    if (k !== "default")
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return presetDefault[k];
        }
      });
  });
});

// ../../../../node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS((exports, module) => {
  module.exports = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
});

// ../../../../node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS((exports) => {
  var toSJISFunction;
  var CODEWORDS_COUNT = [
    0,
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  exports.getSymbolSize = function getSymbolSize(version) {
    if (!version)
      throw new Error('"version" cannot be null or undefined');
    if (version < 1 || version > 40)
      throw new Error('"version" should be in range from 1 to 40');
    return version * 4 + 17;
  };
  exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
    return CODEWORDS_COUNT[version];
  };
  exports.getBCHDigit = function(data) {
    let digit = 0;
    while (data !== 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  };
  exports.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f;
  };
  exports.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  exports.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
});

// ../../../../node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS((exports) => {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString(string) {
    if (typeof string !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string);
    }
  }
  exports.isValid = function isValid(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e) {
      return defaultValue;
    }
  };
});

// ../../../../node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS((exports, module) => {
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index) {
      const bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
    },
    put: function(num, length) {
      for (let i = 0;i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  module.exports = BitBuffer;
});

// ../../../../node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS((exports, module) => {
  function BitMatrix(size) {
    if (!size || size < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size;
    this.data = new Uint8Array(size * size);
    this.reservedBit = new Uint8Array(size * size);
  }
  BitMatrix.prototype.set = function(row, col, value, reserved) {
    const index = row * this.size + col;
    this.data[index] = value;
    if (reserved)
      this.reservedBit[index] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  module.exports = BitMatrix;
});

// ../../../../node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS((exports) => {
  var getSymbolSize = require_utils().getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version) {
    if (version === 1)
      return [];
    const posCount = Math.floor(version / 7) + 2;
    const size = getSymbolSize(version);
    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
    const positions = [size - 7];
    for (let i = 1;i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions(version) {
    const coords = [];
    const pos = exports.getRowColCoords(version);
    const posLength = pos.length;
    for (let i = 0;i < posLength; i++) {
      for (let j = 0;j < posLength; j++) {
        if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {
          continue;
        }
        coords.push([pos[i], pos[j]]);
      }
    }
    return coords;
  };
});

// ../../../../node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS((exports) => {
  var getSymbolSize = require_utils().getSymbolSize;
  var FINDER_PATTERN_SIZE = 7;
  exports.getPositions = function getPositions(version) {
    const size = getSymbolSize(version);
    return [
      [0, 0],
      [size - FINDER_PATTERN_SIZE, 0],
      [0, size - FINDER_PATTERN_SIZE]
    ];
  };
});

// ../../../../node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS((exports) => {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports.from = function from(value) {
    return exports.isValid(value) ? parseInt(value, 10) : undefined;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data) {
    const size = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0;row < size; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0;col < size; col++) {
        let module2 = data.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data) {
    const size = data.size;
    let points = 0;
    for (let row = 0;row < size - 1; row++) {
      for (let col = 0;col < size - 1; col++) {
        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data) {
    const size = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0;row < size; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0;col < size; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0;i < modulesCount; i++)
      darkCount += data.data[i];
    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern, i, j) {
    switch (maskPattern) {
      case exports.Patterns.PATTERN000:
        return (i + j) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i + j) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i * j % 2 + i * j % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i * j % 2 + i * j % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i * j % 3 + (i + j) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  }
  exports.applyMask = function applyMask(pattern, data) {
    const size = data.size;
    for (let col = 0;col < size; col++) {
      for (let row = 0;row < size; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p = 0;p < numPatterns; p++) {
      setupFormatFunc(p);
      exports.applyMask(p, data);
      const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
      exports.applyMask(p, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p;
      }
    }
    return bestPattern;
  };
});

// ../../../../node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS((exports) => {
  var ECLevel = require_error_correction_level();
  var EC_BLOCKS_TABLE = [
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  var EC_CODEWORDS_TABLE = [
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
      default:
        return;
    }
  };
  exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
      default:
        return;
    }
  };
});

// ../../../../node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS((exports) => {
  var EXP_TABLE = new Uint8Array(512);
  var LOG_TABLE = new Uint8Array(256);
  (function initTables() {
    let x = 1;
    for (let i = 0;i < 255; i++) {
      EXP_TABLE[i] = x;
      LOG_TABLE[x] = i;
      x <<= 1;
      if (x & 256) {
        x ^= 285;
      }
    }
    for (let i = 255;i < 512; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 255];
    }
  })();
  exports.log = function log(n) {
    if (n < 1)
      throw new Error("log(" + n + ")");
    return LOG_TABLE[n];
  };
  exports.exp = function exp(n) {
    return EXP_TABLE[n];
  };
  exports.mul = function mul(x, y) {
    if (x === 0 || y === 0)
      return 0;
    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
  };
});

// ../../../../node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS((exports) => {
  var GF = require_galois_field();
  exports.mul = function mul(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0;i < p1.length; i++) {
      for (let j = 0;j < p2.length; j++) {
        coeff[i + j] ^= GF.mul(p1[i], p2[j]);
      }
    }
    return coeff;
  };
  exports.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0;i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0;i < degree; i++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
});

// ../../../../node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS((exports, module) => {
  var Polynomial = require_polynomial();
  function ReedSolomonEncoder(degree) {
    this.genPoly = undefined;
    this.degree = degree;
    if (this.degree)
      this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode(data) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    const paddedData = new Uint8Array(data.length + this.degree);
    paddedData.set(data);
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    const start = this.degree - remainder.length;
    if (start > 0) {
      const buff = new Uint8Array(this.degree);
      buff.set(remainder, start);
      return buff;
    }
    return remainder;
  };
  module.exports = ReedSolomonEncoder;
});

// ../../../../node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS((exports) => {
  exports.isValid = function isValid(version) {
    return !isNaN(version) && version >= 1 && version <= 40;
  };
});

// ../../../../node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS((exports) => {
  var numeric = "[0-9]+";
  var alphanumeric = "[A-Z $%*+\\-./:]+";
  var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|" + "[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|" + "[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|" + "[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
  exports.KANJI = new RegExp(kanji, "g");
  exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  exports.BYTE = new RegExp(byte, "g");
  exports.NUMERIC = new RegExp(numeric, "g");
  exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
  var TEST_KANJI = new RegExp("^" + kanji + "$");
  var TEST_NUMERIC = new RegExp("^" + numeric + "$");
  var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  exports.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  exports.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  exports.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
});

// ../../../../node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS((exports) => {
  var VersionCheck = require_version_check();
  var Regex = require_regex();
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
    if (!mode.ccBits)
      throw new Error("Invalid mode: " + mode);
    if (!VersionCheck.isValid(version)) {
      throw new Error("Invalid version: " + version);
    }
    if (version >= 1 && version < 10)
      return mode.ccBits[0];
    else if (version < 27)
      return mode.ccBits[1];
    return mode.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString(mode) {
    if (mode && mode.id)
      return mode.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid(mode) {
    return mode && mode.bit && mode.ccBits;
  };
  function fromString(string) {
    if (typeof string !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string);
    }
  }
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e) {
      return defaultValue;
    }
  };
});

// ../../../../node_modules/qrcode/lib/core/version.js
var require_version = __commonJS((exports) => {
  var Utils = require_utils();
  var ECCode = require_error_correction_code();
  var ECLevel = require_error_correction_level();
  var Mode = require_mode();
  var VersionCheck = require_version_check();
  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  var G18_BCH = Utils.getBCHDigit(G18);
  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
    for (let currentVersion = 1;currentVersion <= 40; currentVersion++) {
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
        return currentVersion;
      }
    }
    return;
  }
  function getReservedBitsCount(mode, version) {
    return Mode.getCharCountIndicator(mode, version) + 4;
  }
  function getTotalBitsFromDataArray(segments, version) {
    let totalBits = 0;
    segments.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments, errorCorrectionLevel) {
    for (let currentVersion = 1;currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments, currentVersion);
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
        return currentVersion;
      }
    }
    return;
  }
  exports.from = function from(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
    if (!VersionCheck.isValid(version)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode === "undefined")
      mode = Mode.BYTE;
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode === Mode.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
    switch (mode) {
      case Mode.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode.KANJI:
        return Math.floor(usableBits / 13);
      case Mode.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
    let seg;
    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits(version) {
    if (!VersionCheck.isValid(version) || version < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d = version << 12;
    while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
      d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
    }
    return version << 12 | d;
  };
});

// ../../../../node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS((exports) => {
  var Utils = require_utils();
  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  var G15_BCH = Utils.getBCHDigit(G15);
  exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
    const data = errorCorrectionLevel.bit << 3 | mask;
    let d = data << 10;
    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
    }
    return (data << 10 | d) ^ G15_MASK;
  };
});

// ../../../../node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  function NumericData(data) {
    this.mode = Mode.NUMERIC;
    this.data = data.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write(bitBuffer) {
    let i, group, value;
    for (i = 0;i + 3 <= this.data.length; i += 3) {
      group = this.data.substr(i, 3);
      value = parseInt(group, 10);
      bitBuffer.put(value, 10);
    }
    const remainingNum = this.data.length - i;
    if (remainingNum > 0) {
      group = this.data.substr(i);
      value = parseInt(group, 10);
      bitBuffer.put(value, remainingNum * 3 + 1);
    }
  };
  module.exports = NumericData;
});

// ../../../../node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  var ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write(bitBuffer) {
    let i;
    for (i = 0;i + 2 <= this.data.length; i += 2) {
      let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
      bitBuffer.put(value, 11);
    }
    if (this.data.length % 2) {
      bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
    }
  };
  module.exports = AlphanumericData;
});

// ../../../../node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  function ByteData(data) {
    this.mode = Mode.BYTE;
    if (typeof data === "string") {
      this.data = new TextEncoder().encode(data);
    } else {
      this.data = new Uint8Array(data);
    }
  }
  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer) {
    for (let i = 0, l = this.data.length;i < l; i++) {
      bitBuffer.put(this.data[i], 8);
    }
  };
  module.exports = ByteData;
});

// ../../../../node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  var Utils = require_utils();
  function KanjiData(data) {
    this.mode = Mode.KANJI;
    this.data = data;
  }
  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer) {
    let i;
    for (i = 0;i < this.data.length; i++) {
      let value = Utils.toSJIS(this.data[i]);
      if (value >= 33088 && value <= 40956) {
        value -= 33088;
      } else if (value >= 57408 && value <= 60351) {
        value -= 49472;
      } else {
        throw new Error("Invalid SJIS character: " + this.data[i] + `
` + "Make sure your charset is UTF-8");
      }
      value = (value >>> 8 & 255) * 192 + (value & 255);
      bitBuffer.put(value, 13);
    }
  };
  module.exports = KanjiData;
});

// ../../../../node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS((exports, module) => {
  var dijkstra = {
    single_source_shortest_paths: function(graph, s, d) {
      var predecessors = {};
      var costs = {};
      costs[s] = 0;
      var open = dijkstra.PriorityQueue.make();
      open.push(s, 0);
      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u] || {};
        for (v in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v)) {
            cost_of_e = adjacent_nodes[v];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v];
            first_visit = typeof costs[v] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v] = u;
            }
          }
        }
      }
      if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
        var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
      var nodes = [];
      var u = d;
      var predecessor;
      while (u) {
        nodes.push(u);
        predecessor = predecessors[u];
        u = predecessors[u];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s, d) {
      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
    },
    PriorityQueue: {
      make: function(opts) {
        var T = dijkstra.PriorityQueue, t = {}, key;
        opts = opts || {};
        for (key in T) {
          if (T.hasOwnProperty(key)) {
            t[key] = T[key];
          }
        }
        t.queue = [];
        t.sorter = opts.sorter || T.default_sorter;
        return t;
      },
      default_sorter: function(a, b) {
        return a.cost - b.cost;
      },
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  if (typeof module !== "undefined") {
    module.exports = dijkstra;
  }
});

// ../../../../node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS((exports) => {
  var Mode = require_mode();
  var NumericData = require_numeric_data();
  var AlphanumericData = require_alphanumeric_data();
  var ByteData = require_byte_data();
  var KanjiData = require_kanji_data();
  var Regex = require_regex();
  var Utils = require_utils();
  var dijkstra = require_dijkstra();
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex, mode, str) {
    const segments = [];
    let result;
    while ((result = regex.exec(str)) !== null) {
      segments.push({
        data: result[0],
        index: result.index,
        mode,
        length: result[0].length
      });
    }
    return segments;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode) {
    switch (mode) {
      case Mode.NUMERIC:
        return NumericData.getBitsLength(length);
      case Mode.ALPHANUMERIC:
        return AlphanumericData.getBitsLength(length);
      case Mode.KANJI:
        return KanjiData.getBitsLength(length);
      case Mode.BYTE:
        return ByteData.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0;i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode.BYTE, length: seg.length }
          ]);
          break;
        case Mode.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.BYTE, length: seg.length }
          ]);
          break;
        case Mode.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i = 0;i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j = 0;j < nodeGroup.length; j++) {
        const node = nodeGroup[j];
        const key = "" + i + j;
        currentNodeIds.push(key);
        table[key] = { node, lastCount: 0 };
        graph[key] = {};
        for (let n = 0;n < prevNodeIds.length; n++) {
          const prevNodeId = prevNodeIds[n];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n = 0;n < prevNodeIds.length; n++) {
      graph[prevNodeIds[n]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data, modesHint) {
    let mode;
    const bestMode = Mode.getBestModeForData(data);
    mode = Mode.from(modesHint, bestMode);
    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
      throw new Error('"' + data + '"' + " cannot be encoded with mode " + Mode.toString(mode) + `.
 Suggested mode is: ` + Mode.toString(bestMode));
    }
    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
      mode = Mode.BYTE;
    }
    switch (mode) {
      case Mode.NUMERIC:
        return new NumericData(data);
      case Mode.ALPHANUMERIC:
        return new AlphanumericData(data);
      case Mode.KANJI:
        return new KanjiData(data);
      case Mode.BYTE:
        return new ByteData(data);
    }
  }
  exports.fromArray = function fromArray(array) {
    return array.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString(data, version) {
    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version);
    const path = dijkstra.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1;i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data) {
    return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
  };
});

// ../../../../node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS((exports) => {
  var Utils = require_utils();
  var ECLevel = require_error_correction_level();
  var BitBuffer = require_bit_buffer();
  var BitMatrix = require_bit_matrix();
  var AlignmentPattern = require_alignment_pattern();
  var FinderPattern = require_finder_pattern();
  var MaskPattern = require_mask_pattern();
  var ECCode = require_error_correction_code();
  var ReedSolomonEncoder = require_reed_solomon_encoder();
  var Version = require_version();
  var FormatInfo = require_format_info();
  var Mode = require_mode();
  var Segments = require_segments();
  function setupFinderPattern(matrix, version) {
    const size = matrix.size;
    const pos = FinderPattern.getPositions(version);
    for (let i = 0;i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -1;r <= 7; r++) {
        if (row + r <= -1 || size <= row + r)
          continue;
        for (let c = -1;c <= 7; c++) {
          if (col + c <= -1 || size <= col + c)
            continue;
          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    const size = matrix.size;
    for (let r = 8;r < size - 8; r++) {
      const value = r % 2 === 0;
      matrix.set(r, 6, value, true);
      matrix.set(6, r, value, true);
    }
  }
  function setupAlignmentPattern(matrix, version) {
    const pos = AlignmentPattern.getPositions(version);
    for (let i = 0;i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -2;r <= 2; r++) {
        for (let c = -2;c <= 2; c++) {
          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version) {
    const size = matrix.size;
    const bits = Version.getEncodedBits(version);
    let row, col, mod;
    for (let i = 0;i < 18; i++) {
      row = Math.floor(i / 3);
      col = i % 3 + size - 8 - 3;
      mod = (bits >> i & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
    const size = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
    let i, mod;
    for (i = 0;i < 15; i++) {
      mod = (bits >> i & 1) === 1;
      if (i < 6) {
        matrix.set(i, 8, mod, true);
      } else if (i < 8) {
        matrix.set(i + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i, 8, mod, true);
      }
      if (i < 8) {
        matrix.set(8, size - i - 1, mod, true);
      } else if (i < 9) {
        matrix.set(8, 15 - i - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i - 1, mod, true);
      }
    }
    matrix.set(size - 8, 8, 1, true);
  }
  function setupData(matrix, data) {
    const size = matrix.size;
    let inc = -1;
    let row = size - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = size - 1;col > 0; col -= 2) {
      if (col === 6)
        col--;
      while (true) {
        for (let c = 0;c < 2; c++) {
          if (!matrix.isReserved(row, col - c)) {
            let dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c, dark);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version, errorCorrectionLevel, segments) {
    const buffer = new BitBuffer;
    segments.forEach(function(data) {
      buffer.put(data.mode.bit, 4);
      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
      data.write(buffer);
    });
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(0);
    }
    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
    for (let i = 0;i < remainingByte; i++) {
      buffer.put(i % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer, version, errorCorrectionLevel);
  }
  function createCodewords(bitBuffer, version, errorCorrectionLevel) {
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    const rs = new ReedSolomonEncoder(ecCount);
    let offset = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer = new Uint8Array(bitBuffer.buffer);
    for (let b = 0;b < ecTotalBlocks; b++) {
      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b] = buffer.slice(offset, offset + dataSize);
      ecData[b] = rs.encode(dcData[b]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    const data = new Uint8Array(totalCodewords);
    let index = 0;
    let i, r;
    for (i = 0;i < maxDataSize; i++) {
      for (r = 0;r < ecTotalBlocks; r++) {
        if (i < dcData[r].length) {
          data[index++] = dcData[r][i];
        }
      }
    }
    for (i = 0;i < ecCount; i++) {
      for (r = 0;r < ecTotalBlocks; r++) {
        data[index++] = ecData[r][i];
      }
    }
    return data;
  }
  function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
    let segments;
    if (Array.isArray(data)) {
      segments = Segments.fromArray(data);
    } else if (typeof data === "string") {
      let estimatedVersion = version;
      if (!estimatedVersion) {
        const rawSegments = Segments.rawSplit(data);
        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
      }
      segments = Segments.fromString(data, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version) {
      version = bestVersion;
    } else if (version < bestVersion) {
      throw new Error(`
` + `The chosen QR Code version cannot contain this amount of data.
` + "Minimum version required to store current data is: " + bestVersion + `.
`);
    }
    const dataBits = createData(version, errorCorrectionLevel, segments);
    const moduleCount = Utils.getSymbolSize(version);
    const modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version);
    setupFormatInfo(modules, errorCorrectionLevel, 0);
    if (version >= 7) {
      setupVersionInfo(modules, version);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern)) {
      maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
    }
    MaskPattern.applyMask(maskPattern, modules);
    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
    return {
      modules,
      version,
      errorCorrectionLevel,
      maskPattern,
      segments
    };
  }
  exports.create = function create(data, options) {
    if (typeof data === "undefined" || data === "") {
      throw new Error("No input text");
    }
    let errorCorrectionLevel = ECLevel.M;
    let version;
    let mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data, version, errorCorrectionLevel, mask);
  };
});

// ../../../../node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream");
  var ChunkStream = module.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(function() {
      this._process();
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }.bind(this));
  };
  ChunkStream.prototype.write = function(data, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = Buffer.from(data, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding) {
    if (data) {
      this.write(data, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count = 0;
    let data = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
});

// ../../../../node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS((exports) => {
  var imagePasses = [
    {
      x: [0],
      y: [0]
    },
    {
      x: [4],
      y: [0]
    },
    {
      x: [0, 4],
      y: [4]
    },
    {
      x: [2, 6],
      y: [0, 4]
    },
    {
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  exports.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i = 0;i < imagePasses.length; i++) {
      let pass = imagePasses[i];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0;j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0;j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  exports.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
});

// ../../../../node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS((exports, module) => {
  module.exports = function paethPredictor(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
});

// ../../../../node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS((exports, module) => {
  var interlaceUtils = require_interlace();
  var paethPredictor = require_paeth_predictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  var Filter = module.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i = 0;i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
});

// ../../../../node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS((exports, module) => {
  var util = __require("util");
  var ChunkStream = require_chunkstream();
  var Filter = require_filter_parse();
  var FilterAsync = module.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util.inherits(FilterAsync, ChunkStream);
});

// ../../../../node_modules/pngjs/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
});

// ../../../../node_modules/pngjs/lib/crc.js
var require_crc = __commonJS((exports, module) => {
  var crcTable = [];
  (function() {
    for (let i = 0;i < 256; i++) {
      let currentCrc = i;
      for (let j = 0;j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  var CrcCalculator = module.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (let i = 0;i < data.length; i++) {
      this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc = -1;
    for (let i = 0;i < buf.length; i++) {
      crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// ../../../../node_modules/pngjs/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var constants = require_constants();
  var CrcCalculator = require_crc();
  var Parser = module.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {};
  };
  Parser.prototype.start = function() {
    this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data) {
    let signature = constants.PNG_SIGNATURE;
    for (let i = 0;i < signature.length; i++) {
      if (data[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data) {
    let length = data.readUInt32BE(0);
    let type = data.readUInt32BE(4);
    let name = "";
    for (let i = 4;i < 8; i++) {
      name += String.fromCharCode(data[i]);
    }
    let ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator;
    this._crc.write(Buffer.from(name));
    if (this._chunks[type]) {
      return this._chunks[type](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data) {
    let fileCrc = data.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    let width = data.readUInt32BE(0);
    let height = data.readUInt32BE(4);
    let depth = data[8];
    let colorType = data[9];
    let compr = data[10];
    let filter = data[11];
    let interlace = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace !== 0 && interlace !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace),
      palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    let entries = Math.floor(data.length / 3);
    for (let i = 0;i < entries; i++) {
      this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i = 0;i < data.length; i++) {
        this._palette[i][3] = data[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants.COLORTYPE_COLOR) {
      this.transColor([
        data.readUInt16BE(0),
        data.readUInt16BE(2),
        data.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    let leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
});

// ../../../../node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS((exports) => {
  var interlaceUtils = require_interlace();
  var pixelBppMapper = [
    function() {},
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    function() {},
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    let leftOver = [];
    let i = 0;
    function split() {
      if (i === data.length) {
        throw new Error("Ran out of data");
      }
      let byte = data[i];
      i++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        let returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i !== data.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  exports.dataToBitMap = function(data, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (let imageIndex = 0;imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
});

// ../../../../node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS((exports, module) => {
  function dePalette(indata, outdata, width, height, palette) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i = 0;i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i = 0;i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        for (let i = 0;i < 4; i++) {
          outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  }
  module.exports = function(indata, imageData) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
});

// ../../../../node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS((exports, module) => {
  var util = __require("util");
  var zlib = __require("zlib");
  var ChunkStream = require_chunkstream();
  var FilterAsync = require_filter_parse_async();
  var Parser = require_parser();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  var ParserAsync = module.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {});
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
});

// ../../../../node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS((exports, module) => {
  var constants = require_constants();
  module.exports = function(dataIn, width, height, options) {
    let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      let bigEndian = function() {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(0, 256, true);
        return new Int16Array(buffer)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options.bgColor || {};
    if (bgColor.red === undefined) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === undefined) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === undefined) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options.inputColorType) {
        case constants.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_COLOR:
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        case constants.COLORTYPE_GRAYSCALE:
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
        }
      }
      return { red, green, blue, alpha };
    }
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let rgba = getRGBA(data, inIndex);
        switch (options.colorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
          case constants.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants.COLORTYPE_ALPHA:
          case constants.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
});

// ../../../../node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS((exports, module) => {
  var paethPredictor = require_paeth_predictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i = pxPos;i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos;x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  module.exports = function(pxData, width, height, options, bpp) {
    let filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0;y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i = 0;i < filterTypes.length; i++) {
          let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
});

// ../../../../node_modules/pngjs/lib/packer.js
var require_packer = __commonJS((exports, module) => {
  var constants = require_constants();
  var CrcStream = require_crc();
  var bitPacker = require_bitpacker();
  var filter = require_filter_pack();
  var zlib = __require("zlib");
  var Packer = module.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    let packedData = bitPacker(data, width, height, this._options);
    let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type, data) {
    let len = data ? data.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
    return this._packChunk(constants.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants.TYPE_IEND, null);
  };
});

// ../../../../node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream");
  var constants = require_constants();
  var Packer = require_packer();
  var PackerAsync = module.exports = function(opt) {
    Stream.call(this);
    let options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this));
    this._deflate.on("end", function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this));
    this._deflate.end(filteredData);
  };
});

// ../../../../node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS((exports, module) => {
  var assert = __require("assert").ok;
  var zlib = __require("zlib");
  var util = __require("util");
  var kMaxLength = __require("buffer").kMaxLength;
  function Inflate(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
      opts.chunkSize = zlib.Z_MIN_CHUNK;
    }
    zlib.Inflate.call(this, opts);
    this._offset = this._offset === undefined ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  }
  function createInflate(opts) {
    return new Inflate(opts);
  }
  function _close(engine, callback) {
    if (callback) {
      process.nextTick(callback);
    }
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  }
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    let self2 = this;
    let availInBefore = chunk && chunk.length;
    let availOutBefore = this._chunkSize - this._offset;
    let leftToInflate = this._maxLength;
    let inOff = 0;
    let buffers = [];
    let nread = 0;
    let error;
    this.on("error", function(err) {
      error = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      let have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        let out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    let res;
    do {
      res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
    }
    let buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util.inherits(Inflate, zlib.Inflate);
  function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    let flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  }
  function inflateSync(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  }
  module.exports = exports = inflateSync;
  exports.Inflate = Inflate;
  exports.createInflate = createInflate;
  exports.inflateSync = inflateSync;
});

// ../../../../node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS((exports, module) => {
  var SyncReader = module.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      return new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      return new Error("unrecognised content at end of stream");
    }
  };
});

// ../../../../node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS((exports) => {
  var SyncReader = require_sync_reader();
  var Filter = require_filter_parse();
  exports.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {}
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
});

// ../../../../node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  var inflateSync = require_sync_inflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = require_sync_reader();
  var FilterSync = require_filter_parse_sync();
  var Parser = require_parser();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  module.exports = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    let reader = new SyncReader(buffer);
    let parser = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
});

// ../../../../node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants = require_constants();
  var Packer = require_packer();
  module.exports = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let options = opt || {};
    let packer = new Packer(options);
    let chunks = [];
    chunks.push(Buffer.from(constants.PNG_SIGNATURE));
    chunks.push(packer.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer.packGAMA(metaData.gamma));
    }
    let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
    let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer.packIDAT(compressedData));
    chunks.push(packer.packIEND());
    return Buffer.concat(chunks);
  };
});

// ../../../../node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS((exports) => {
  var parse = require_parser_sync();
  var pack = require_packer_sync();
  exports.read = function(buffer, options) {
    return parse(buffer, options || {});
  };
  exports.write = function(png, options) {
    return pack(png, options);
  };
});

// ../../../../node_modules/pngjs/lib/png.js
var require_png = __commonJS((exports) => {
  var util = __require("util");
  var Stream = __require("stream");
  var Parser = require_parser_async();
  var Packer = require_packer_async();
  var PNGSync = require_png_sync();
  var PNG = exports.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", function(data) {
      this.data = data;
      this.emit("parsed", data);
    }.bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this));
    return this;
  };
  PNG.prototype.parse = function(data, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0;y < height; y++) {
      src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (let y = 0;y < src.height; y++) {
        for (let x = 0;x < src.width; x++) {
          let idx = src.width * y + x << 2;
          for (let i = 0;i < 3; i++) {
            let sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
});

// ../../../../node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS((exports) => {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
        return [c, c];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : undefined;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports.getScale(size, opts);
    const symbolSize = Math.floor((size + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0;i < symbolSize; i++) {
      for (let j = 0;j < symbolSize; j++) {
        let posDst = (i * symbolSize + j) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
});

// ../../../../node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS((exports) => {
  var fs = __require("fs");
  var PNG = require_png().PNG;
  var Utils = require_utils2();
  exports.render = function render(qrData, options) {
    const opts = Utils.getOptions(options);
    const pngOpts = opts.rendererOpts;
    const size = Utils.getImageWidth(qrData.modules.size, opts);
    pngOpts.width = size;
    pngOpts.height = size;
    const pngImage = new PNG(pngOpts);
    Utils.qrToImageData(pngImage.data, qrData, opts);
    return pngImage;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    exports.renderToBuffer(qrData, options, function(err, output) {
      if (err)
        cb(err);
      let url = "data:image/png;base64,";
      url += output.toString("base64");
      cb(null, url);
    });
  };
  exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const png = exports.render(qrData, options);
    const buffer = [];
    png.on("error", cb);
    png.on("data", function(data) {
      buffer.push(data);
    });
    png.on("end", function() {
      cb(null, Buffer.concat(buffer));
    });
    png.pack();
  };
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    let called = false;
    const done = (...args) => {
      if (called)
        return;
      called = true;
      cb.apply(null, args);
    };
    const stream = fs.createWriteStream(path);
    stream.on("error", done);
    stream.on("close", done);
    exports.renderToFileStream(stream, qrData, options);
  };
  exports.renderToFileStream = function renderToFileStream(stream, qrData, options) {
    const png = exports.render(qrData, options);
    png.pack().pipe(stream);
  };
});

// ../../../../node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = __commonJS((exports) => {
  var Utils = require_utils2();
  var BLOCK_CHAR = {
    WW: " ",
    WB: "\u2584",
    BB: "\u2588",
    BW: "\u2580"
  };
  var INVERTED_BLOCK_CHAR = {
    BB: " ",
    BW: "\u2584",
    WW: "\u2588",
    WB: "\u2580"
  };
  function getBlockChar(top, bottom, blocks) {
    if (top && bottom)
      return blocks.BB;
    if (top && !bottom)
      return blocks.BW;
    if (!top && bottom)
      return blocks.WB;
    return blocks.WW;
  }
  exports.render = function(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    let blocks = BLOCK_CHAR;
    if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
      blocks = INVERTED_BLOCK_CHAR;
    }
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    let output = "";
    let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
    hMargin = Array(opts.margin / 2 + 1).join(hMargin + `
`);
    const vMargin = Array(opts.margin + 1).join(blocks.WW);
    output += hMargin;
    for (let i = 0;i < size; i += 2) {
      output += vMargin;
      for (let j = 0;j < size; j++) {
        const topModule = data[i * size + j];
        const bottomModule = data[(i + 1) * size + j];
        output += getBlockChar(topModule, bottomModule, blocks);
      }
      output += vMargin + `
`;
    }
    output += hMargin.slice(0, -1);
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const fs = __require("fs");
    const utf8 = exports.render(qrData, options);
    fs.writeFile(path, utf8, cb);
  };
});

// ../../../../node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal = __commonJS((exports) => {
  exports.render = function(qrData, options, cb) {
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const black = "\x1B[40m  \x1B[0m";
    const white = "\x1B[47m  \x1B[0m";
    let output = "";
    const hMargin = Array(size + 3).join(white);
    const vMargin = Array(2).join(white);
    output += hMargin + `
`;
    for (let i = 0;i < size; ++i) {
      output += white;
      for (let j = 0;j < size; j++) {
        output += data[i * size + j] ? black : white;
      }
      output += vMargin + `
`;
    }
    output += hMargin + `
`;
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
});

// ../../../../node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = __commonJS((exports) => {
  var backgroundWhite = "\x1B[47m";
  var backgroundBlack = "\x1B[40m";
  var foregroundWhite = "\x1B[37m";
  var foregroundBlack = "\x1B[30m";
  var reset = "\x1B[0m";
  var lineSetupNormal = backgroundWhite + foregroundBlack;
  var lineSetupInverse = backgroundBlack + foregroundWhite;
  var createPalette = function(lineSetup, foregroundWhite2, foregroundBlack2) {
    return {
      "00": reset + " " + lineSetup,
      "01": reset + foregroundWhite2 + "\u2584" + lineSetup,
      "02": reset + foregroundBlack2 + "\u2584" + lineSetup,
      10: reset + foregroundWhite2 + "\u2580" + lineSetup,
      11: " ",
      12: "\u2584",
      20: reset + foregroundBlack2 + "\u2580" + lineSetup,
      21: "\u2580",
      22: "\u2588"
    };
  };
  var mkCodePixel = function(modules, size, x, y) {
    const sizePlus = size + 1;
    if (x >= sizePlus || y >= sizePlus || y < -1 || x < -1)
      return "0";
    if (x >= size || y >= size || y < 0 || x < 0)
      return "1";
    const idx = y * size + x;
    return modules[idx] ? "2" : "1";
  };
  var mkCode = function(modules, size, x, y) {
    return mkCodePixel(modules, size, x, y) + mkCodePixel(modules, size, x, y + 1);
  };
  exports.render = function(qrData, options, cb) {
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const inverse = !!(options && options.inverse);
    const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
    const white = inverse ? foregroundBlack : foregroundWhite;
    const black = inverse ? foregroundWhite : foregroundBlack;
    const palette = createPalette(lineSetup, white, black);
    const newLine = reset + `
` + lineSetup;
    let output = lineSetup;
    for (let y = -1;y < size + 1; y += 2) {
      for (let x = -1;x < size; x++) {
        output += palette[mkCode(data, size, x, y)];
      }
      output += palette[mkCode(data, size, size, y)] + newLine;
    }
    output += reset;
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
});

// ../../../../node_modules/qrcode/lib/renderer/terminal.js
var require_terminal2 = __commonJS((exports) => {
  var big = require_terminal();
  var small = require_terminal_small();
  exports.render = function(qrData, options, cb) {
    if (options && options.small) {
      return small.render(qrData, options, cb);
    }
    return big.render(qrData, options, cb);
  };
});

// ../../../../node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS((exports) => {
  var Utils = require_utils2();
  function getColorAttrib(color, attrib) {
    const alpha = color.a / 255;
    const str = attrib + '="' + color.hex + '"';
    return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x, y) {
    let str = cmd + x;
    if (typeof y !== "undefined")
      str += " " + y;
    return str;
  }
  function qrToPath(data, size, margin) {
    let path = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for (let i = 0;i < data.length; i++) {
      const col = Math.floor(i % size);
      const row = Math.floor(i / size);
      if (!col && !newRow)
        newRow = true;
      if (data[i]) {
        lineLength++;
        if (!(i > 0 && col > 0 && data[i - 1])) {
          path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size && data[i + 1])) {
          path += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path;
  }
  exports.render = function render(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const qrcodesize = size + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    const viewBox = 'viewBox="' + "0 0 " + qrcodesize + " " + qrcodesize + '"';
    const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + `</svg>
`;
    if (typeof cb === "function") {
      cb(null, svgTag);
    }
    return svgTag;
  };
});

// ../../../../node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS((exports) => {
  var svgTagRenderer = require_svg_tag();
  exports.render = svgTagRenderer.render;
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const fs = __require("fs");
    const svgTag = exports.render(qrData, options);
    const xmlStr = '<?xml version="1.0" encoding="utf-8"?>' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
    fs.writeFile(path, xmlStr, cb);
  };
});

// ../../../../node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS((exports) => {
  var Utils = require_utils2();
  function clearCanvas(ctx, canvas, size) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!canvas.style)
      canvas.style = {};
    canvas.height = size;
    canvas.width = size;
    canvas.style.height = size + "px";
    canvas.style.width = size + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render(qrData, canvas, options) {
    let opts = options;
    let canvasEl = canvas;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
      opts = canvas;
      canvas = undefined;
    }
    if (!canvas) {
      canvasEl = getCanvasElement();
    }
    opts = Utils.getOptions(opts);
    const size = Utils.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size, size);
    Utils.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
      opts = canvas;
      canvas = undefined;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports.render(qrData, canvas, opts);
    const type = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
});

// ../../../../node_modules/qrcode/lib/browser.js
var require_browser = __commonJS((exports) => {
  var canPromise = require_can_promise();
  var QRCode = require_qrcode();
  var CanvasRenderer = require_canvas();
  var SvgRenderer = require_svg_tag();
  function renderCanvas(renderFunc, canvas, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 3) {
        if (canvas.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = undefined;
        } else {
          cb = opts;
          opts = text;
          text = canvas;
          canvas = undefined;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 2 && !canvas.getContext) {
        opts = text;
        text = canvas;
        canvas = undefined;
      }
      return new Promise(function(resolve, reject) {
        try {
          const data = QRCode.create(text, opts);
          resolve(renderFunc(data, canvas, opts));
        } catch (e) {
          reject(e);
        }
      });
    }
    try {
      const data = QRCode.create(text, opts);
      cb(null, renderFunc(data, canvas, opts));
    } catch (e) {
      cb(e);
    }
  }
  exports.create = QRCode.create;
  exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  exports.toString = renderCanvas.bind(null, function(data, _, opts) {
    return SvgRenderer.render(data, opts);
  });
});

// ../../../../node_modules/qrcode/lib/server.js
var require_server = __commonJS((exports) => {
  var canPromise = require_can_promise();
  var QRCode = require_qrcode();
  var PngRenderer = require_png2();
  var Utf8Renderer = require_utf8();
  var TerminalRenderer = require_terminal2();
  var SvgRenderer = require_svg();
  function checkParams(text, opts, cb) {
    if (typeof text === "undefined") {
      throw new Error("String required as first argument");
    }
    if (typeof cb === "undefined") {
      cb = opts;
      opts = {};
    }
    if (typeof cb !== "function") {
      if (!canPromise()) {
        throw new Error("Callback required as last argument");
      } else {
        opts = cb || {};
        cb = null;
      }
    }
    return {
      opts,
      cb
    };
  }
  function getTypeFromFilename(path) {
    return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
  }
  function getRendererFromType(type) {
    switch (type) {
      case "svg":
        return SvgRenderer;
      case "txt":
      case "utf8":
        return Utf8Renderer;
      case "png":
      case "image/png":
      default:
        return PngRenderer;
    }
  }
  function getStringRendererFromType(type) {
    switch (type) {
      case "svg":
        return SvgRenderer;
      case "terminal":
        return TerminalRenderer;
      case "utf8":
      default:
        return Utf8Renderer;
    }
  }
  function render(renderFunc, text, params) {
    if (!params.cb) {
      return new Promise(function(resolve, reject) {
        try {
          const data = QRCode.create(text, params.opts);
          return renderFunc(data, params.opts, function(err, data2) {
            return err ? reject(err) : resolve(data2);
          });
        } catch (e) {
          reject(e);
        }
      });
    }
    try {
      const data = QRCode.create(text, params.opts);
      return renderFunc(data, params.opts, params.cb);
    } catch (e) {
      params.cb(e);
    }
  }
  exports.create = QRCode.create;
  exports.toCanvas = require_browser().toCanvas;
  exports.toString = function toString(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const type = params.opts ? params.opts.type : undefined;
    const renderer = getStringRendererFromType(type);
    return render(renderer.render, text, params);
  };
  exports.toDataURL = function toDataURL(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const renderer = getRendererFromType(params.opts.type);
    return render(renderer.renderToDataURL, text, params);
  };
  exports.toBuffer = function toBuffer(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const renderer = getRendererFromType(params.opts.type);
    return render(renderer.renderToBuffer, text, params);
  };
  exports.toFile = function toFile(path, text, opts, cb) {
    if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
      throw new Error("Invalid argument");
    }
    if (arguments.length < 3 && !canPromise()) {
      throw new Error("Too few arguments provided");
    }
    const params = checkParams(text, opts, cb);
    const type = params.opts.type || getTypeFromFilename(path);
    const renderer = getRendererFromType(type);
    const renderToFile = renderer.renderToFile.bind(null, path);
    return render(renderToFile, text, params);
  };
  exports.toFileStream = function toFileStream(stream, text, opts) {
    if (arguments.length < 2) {
      throw new Error("Too few arguments provided");
    }
    const params = checkParams(text, opts, stream.emit.bind(stream, "error"));
    const renderer = getRendererFromType("png");
    const renderToFileStream = renderer.renderToFileStream.bind(null, stream);
    render(renderToFileStream, text, params);
  };
});

// ../../../../node_modules/@vue/compiler-ssr/dist/compiler-ssr.cjs.js
var require_compiler_ssr_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var compilerDom = require_compiler_dom_cjs();
  var shared = require_shared_cjs();
  var SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
  var SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
  var SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
  var SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
  var SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);
  var SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
  var SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
  var SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
  var SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
  var SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
  var SSR_RENDER_LIST = Symbol(`ssrRenderList`);
  var SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);
  var SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
  var SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
  var SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
  var SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
  var SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
  var SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
  var SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);
  var ssrHelpers = {
    [SSR_INTERPOLATE]: `ssrInterpolate`,
    [SSR_RENDER_VNODE]: `ssrRenderVNode`,
    [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
    [SSR_RENDER_SLOT]: `ssrRenderSlot`,
    [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,
    [SSR_RENDER_CLASS]: `ssrRenderClass`,
    [SSR_RENDER_STYLE]: `ssrRenderStyle`,
    [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
    [SSR_RENDER_ATTR]: `ssrRenderAttr`,
    [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
    [SSR_RENDER_LIST]: `ssrRenderList`,
    [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,
    [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
    [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
    [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
    [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
    [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
    [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,
    [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`
  };
  compilerDom.registerRuntimeHelpers(ssrHelpers);
  var ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);
  function ssrProcessIf(node, context, disableNestedFragments = false, disableComment = false) {
    const [rootBranch] = node.branches;
    const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));
    context.pushStatement(ifStatement);
    let currentIf = ifStatement;
    for (let i = 1;i < node.branches.length; i++) {
      const branch = node.branches[i];
      const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);
      if (branch.condition) {
        currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);
      } else {
        currentIf.alternate = branchBlockStatement;
      }
    }
    if (!currentIf.alternate && !disableComment) {
      currentIf.alternate = compilerDom.createBlockStatement([
        compilerDom.createCallExpression(`_push`, ["`<!---->`"])
      ]);
    }
  }
  function processIfBranch(branch, context, disableNestedFragments = false) {
    const { children } = branch;
    const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && !(children.length === 1 && children[0].type === 11);
    return processChildrenAsStatement(branch, context, needFragmentWrapper);
  }
  var ssrTransformFor = compilerDom.createStructuralDirectiveTransform("for", compilerDom.processFor);
  function ssrProcessFor(node, context, disableNestedFragments = false) {
    const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);
    const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));
    renderLoop.body = processChildrenAsStatement(node, context, needFragmentWrapper);
    if (!disableNestedFragments) {
      context.pushStringPart(`<!--[-->`);
    }
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [
      node.source,
      renderLoop
    ]));
    if (!disableNestedFragments) {
      context.pushStringPart(`<!--]-->`);
    }
  }
  var ssrTransformSlotOutlet = (node, context) => {
    if (compilerDom.isSlotOutlet(node)) {
      const { slotName, slotProps } = compilerDom.processSlotOutlet(node, context);
      const args = [
        `_ctx.$slots`,
        slotName,
        slotProps || `{}`,
        `null`,
        `_push`,
        `_parent`
      ];
      if (context.scopeId && context.slotted !== false) {
        args.push(`"${context.scopeId}-s"`);
      }
      let method = SSR_RENDER_SLOT;
      let parent = context.parent;
      if (parent) {
        const children = parent.children;
        if (parent.type === 10) {
          parent = context.grandParent;
        }
        let componentType;
        if (parent.type === 1 && parent.tagType === 1 && ((componentType = compilerDom.resolveComponentType(parent, context, true)) === compilerDom.TRANSITION || componentType === compilerDom.TRANSITION_GROUP) && children.filter((c) => c.type === 1).length === 1) {
          method = SSR_RENDER_SLOT_INNER;
          if (!(context.scopeId && context.slotted !== false)) {
            args.push("null");
          }
          args.push("true");
        }
      }
      node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(method), args);
    }
  };
  function ssrProcessSlotOutlet(node, context) {
    const renderCall = node.ssrCodegenNode;
    if (node.children.length) {
      const fallbackRenderFn = compilerDom.createFunctionExpression([]);
      fallbackRenderFn.body = processChildrenAsStatement(node, context);
      renderCall.arguments[3] = fallbackRenderFn;
    }
    if (context.withSlotScopeId) {
      const slotScopeId = renderCall.arguments[6];
      renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
    }
    context.pushStatement(node.ssrCodegenNode);
  }
  function createSSRCompilerError(code, loc) {
    return compilerDom.createCompilerError(code, loc, SSRErrorMessages);
  }
  var SSRErrorMessages = {
    [65]: `Unsafe attribute name for SSR.`,
    [66]: `Missing the 'to' prop on teleport element.`,
    [67]: `Invalid AST node during SSR transform.`
  };
  function ssrProcessTeleport(node, context) {
    const targetProp = compilerDom.findProp(node, "to");
    if (!targetProp) {
      context.onError(createSSRCompilerError(66, node.loc));
      return;
    }
    let target;
    if (targetProp.type === 6) {
      target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);
    } else {
      target = targetProp.exp;
    }
    if (!target) {
      context.onError(createSSRCompilerError(66, targetProp.loc));
      return;
    }
    const disabledProp = compilerDom.findProp(node, "disabled", false, true);
    const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
    const contentRenderFn = compilerDom.createFunctionExpression([`_push`], undefined, true, false, node.loc);
    contentRenderFn.body = processChildrenAsStatement(node, context);
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
      `_push`,
      contentRenderFn,
      target,
      disabled,
      `_parent`
    ]));
  }
  var wipMap$3 = /* @__PURE__ */ new WeakMap;
  function ssrTransformSuspense(node, context) {
    return () => {
      if (node.children.length) {
        const wipEntry = {
          slotsExp: null,
          wipSlots: []
        };
        wipMap$3.set(node, wipEntry);
        wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, _vForExp, children, loc) => {
          const fn = compilerDom.createFunctionExpression([], undefined, true, false, loc);
          wipEntry.wipSlots.push({
            fn,
            children
          });
          return fn;
        }).slots;
      }
    };
  }
  function ssrProcessSuspense(node, context) {
    const wipEntry = wipMap$3.get(node);
    if (!wipEntry) {
      return;
    }
    const { slotsExp, wipSlots } = wipEntry;
    for (let i = 0;i < wipSlots.length; i++) {
      const slot = wipSlots[i];
      slot.fn.body = processChildrenAsStatement(slot, context);
    }
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
      `_push`,
      slotsExp
    ]));
  }
  var rawChildrenMap = /* @__PURE__ */ new WeakMap;
  var ssrTransformElement = (node, context) => {
    if (node.type !== 1 || node.tagType !== 0) {
      return;
    }
    return function ssrPostTransformElement() {
      const openTag = [`<${node.tag}`];
      const needTagForRuntime = node.tag === "textarea" || node.tag.indexOf("-") > 0;
      const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);
      const hasCustomDir = node.props.some((p) => p.type === 7 && !shared.isBuiltInDirective(p.name));
      const needMergeProps = hasDynamicVBind || hasCustomDir;
      if (needMergeProps) {
        const { props, directives } = compilerDom.buildProps(node, context, node.props, false, false, true);
        if (props || directives.length) {
          const mergedProps = buildSSRProps(props, directives, context);
          const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [mergedProps]);
          if (node.tag === "textarea") {
            const existingText = node.children[0];
            if (!existingText || existingText.type !== 5) {
              const tempId = `_temp${context.temps++}`;
              propsExp.arguments = [
                compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)
              ];
              rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
                compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`"value" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)
              ]));
            }
          } else if (node.tag === "input") {
            const vModel = findVModel(node);
            if (vModel) {
              const tempId = `_temp${context.temps++}`;
              const tempExp = compilerDom.createSimpleExpression(tempId, false);
              propsExp.arguments = [
                compilerDom.createSequenceExpression([
                  compilerDom.createAssignmentExpression(tempExp, mergedProps),
                  compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [
                    tempExp,
                    compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                      tempExp,
                      vModel.exp
                    ])
                  ])
                ])
              ];
            }
          } else if (directives.length && !node.children.length) {
            const vText = compilerDom.findDir(node, "text");
            if (!vText) {
              const tempId = `_temp${context.temps++}`;
              propsExp.arguments = [
                compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)
              ];
              rawChildrenMap.set(node, compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`"textContent" in ${tempId}`, false), compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
                compilerDom.createSimpleExpression(`${tempId}.textContent`, false)
              ]), compilerDom.createSimpleExpression(`${tempId}.innerHTML ?? ''`, false), false));
            }
          }
          if (needTagForRuntime) {
            propsExp.arguments.push(`"${node.tag}"`);
          }
          openTag.push(propsExp);
        }
      }
      let dynamicClassBinding = undefined;
      let staticClassBinding = undefined;
      let dynamicStyleBinding = undefined;
      for (let i = 0;i < node.props.length; i++) {
        const prop = node.props[i];
        if (node.tag === "input" && isTrueFalseValue(prop)) {
          continue;
        }
        if (prop.type === 7) {
          if (prop.name === "html" && prop.exp) {
            rawChildrenMap.set(node, compilerDom.createCompoundExpression([`(`, prop.exp, `) ?? ''`]));
          } else if (prop.name === "text" && prop.exp) {
            node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
          } else if (prop.name === "slot") {
            context.onError(compilerDom.createCompilerError(40, prop.loc));
          } else if (isTextareaWithValue(node, prop) && prop.exp) {
            if (!needMergeProps) {
              node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
            }
          } else if (!needMergeProps && prop.name !== "on") {
            const directiveTransform = context.directiveTransforms[prop.name];
            if (directiveTransform) {
              const { props, ssrTagParts } = directiveTransform(prop, node, context);
              if (ssrTagParts) {
                openTag.push(...ssrTagParts);
              }
              for (let j = 0;j < props.length; j++) {
                const { key, value } = props[j];
                if (compilerDom.isStaticExp(key)) {
                  let attrName = key.content;
                  if (attrName === "key" || attrName === "ref") {
                    continue;
                  }
                  if (attrName === "class") {
                    openTag.push(` class="`, dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `"`);
                  } else if (attrName === "style") {
                    if (dynamicStyleBinding) {
                      mergeCall(dynamicStyleBinding, value);
                    } else {
                      openTag.push(` style="`, dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `"`);
                    }
                  } else {
                    attrName = node.tag.indexOf("-") > 0 ? attrName : shared.propsToAttrMap[attrName] || attrName.toLowerCase();
                    if (shared.isBooleanAttr(attrName)) {
                      openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(" " + attrName, true), compilerDom.createSimpleExpression("", true), false));
                    } else if (shared.isSSRSafeAttrName(attrName)) {
                      openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [
                        key,
                        value
                      ]));
                    } else {
                      context.onError(createSSRCompilerError(65, key.loc));
                    }
                  }
                } else {
                  const args = [key, value];
                  if (needTagForRuntime) {
                    args.push(`"${node.tag}"`);
                  }
                  openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
                }
              }
            }
          }
        } else {
          const name2 = prop.name;
          if (node.tag === "textarea" && name2 === "value" && prop.value) {
            rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));
          } else if (!needMergeProps) {
            if (name2 === "key" || name2 === "ref") {
              continue;
            }
            if (name2 === "class" && prop.value) {
              staticClassBinding = JSON.stringify(prop.value.content);
            }
            openTag.push(` ${prop.name}` + (prop.value ? `="${shared.escapeHtml(prop.value.content)}"` : ``));
          }
        }
      }
      if (dynamicClassBinding && staticClassBinding) {
        mergeCall(dynamicClassBinding, staticClassBinding);
        removeStaticBinding(openTag, "class");
      }
      if (context.scopeId) {
        openTag.push(` ${context.scopeId}`);
      }
      node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);
    };
  };
  function buildSSRProps(props, directives, context) {
    let mergePropsArgs = [];
    if (props) {
      if (props.type === 14) {
        mergePropsArgs = props.arguments;
      } else {
        mergePropsArgs.push(props);
      }
    }
    if (directives.length) {
      for (const dir of directives) {
        mergePropsArgs.push(compilerDom.createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [
          `_ctx`,
          ...compilerDom.buildDirectiveArgs(dir, context).elements
        ]));
      }
    }
    return mergePropsArgs.length > 1 ? compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), mergePropsArgs) : mergePropsArgs[0];
  }
  function isTrueFalseValue(prop) {
    if (prop.type === 7) {
      return prop.name === "bind" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
    } else {
      return prop.name === "true-value" || prop.name === "false-value";
    }
  }
  function isTextareaWithValue(node, prop) {
    return !!(node.tag === "textarea" && prop.name === "bind" && compilerDom.isStaticArgOf(prop.arg, "value"));
  }
  function mergeCall(call, arg) {
    const existing = call.arguments[0];
    if (existing.type === 17) {
      existing.elements.push(arg);
    } else {
      call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);
    }
  }
  function removeStaticBinding(tag, binding) {
    const regExp = new RegExp(`^ ${binding}=".+"$`);
    const i = tag.findIndex((e) => typeof e === "string" && regExp.test(e));
    if (i > -1) {
      tag.splice(i, 1);
    }
  }
  function findVModel(node) {
    return node.props.find((p) => p.type === 7 && p.name === "model" && p.exp);
  }
  function ssrProcessElement(node, context) {
    const isVoidTag = context.options.isVoidTag || shared.NO;
    const elementsToAdd = node.ssrCodegenNode.elements;
    for (let j = 0;j < elementsToAdd.length; j++) {
      context.pushStringPart(elementsToAdd[j]);
    }
    if (context.withSlotScopeId) {
      context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));
    }
    context.pushStringPart(`>`);
    const rawChildren = rawChildrenMap.get(node);
    if (rawChildren) {
      context.pushStringPart(rawChildren);
    } else if (node.children.length) {
      processChildren(node, context);
    }
    if (!isVoidTag(node.tag)) {
      context.pushStringPart(`</${node.tag}>`);
    }
  }
  var wipMap$2 = /* @__PURE__ */ new WeakMap;
  function ssrTransformTransitionGroup(node, context) {
    return () => {
      const tag = compilerDom.findProp(node, "tag");
      if (tag) {
        const otherProps = node.props.filter((p) => p !== tag);
        const { props, directives } = compilerDom.buildProps(node, context, otherProps, true, false, true);
        let propsExp = null;
        if (props || directives.length) {
          propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [
            buildSSRProps(props, directives, context)
          ]);
        }
        wipMap$2.set(node, {
          tag,
          propsExp,
          scopeId: context.scopeId || null
        });
      }
    };
  }
  function ssrProcessTransitionGroup(node, context) {
    const entry = wipMap$2.get(node);
    if (entry) {
      const { tag, propsExp, scopeId } = entry;
      if (tag.type === 7) {
        context.pushStringPart(`<`);
        context.pushStringPart(tag.exp);
        if (propsExp) {
          context.pushStringPart(propsExp);
        }
        if (scopeId) {
          context.pushStringPart(` ${scopeId}`);
        }
        context.pushStringPart(`>`);
        processChildren(node, context, false, true, true);
        context.pushStringPart(`</`);
        context.pushStringPart(tag.exp);
        context.pushStringPart(`>`);
      } else {
        context.pushStringPart(`<${tag.value.content}`);
        if (propsExp) {
          context.pushStringPart(propsExp);
        }
        if (scopeId) {
          context.pushStringPart(` ${scopeId}`);
        }
        context.pushStringPart(`>`);
        processChildren(node, context, false, true, true);
        context.pushStringPart(`</${tag.value.content}>`);
      }
    } else {
      processChildren(node, context, true, true, true);
    }
  }
  var wipMap$1 = /* @__PURE__ */ new WeakMap;
  function ssrTransformTransition(node, context) {
    return () => {
      const appear = compilerDom.findProp(node, "appear", false, true);
      wipMap$1.set(node, !!appear);
    };
  }
  function ssrProcessTransition(node, context) {
    node.children = node.children.filter((c) => c.type !== 3);
    const appear = wipMap$1.get(node);
    if (appear) {
      context.pushStringPart(`<template>`);
      processChildren(node, context, false, true);
      context.pushStringPart(`</template>`);
    } else {
      processChildren(node, context, false, true);
    }
  }
  var wipMap = /* @__PURE__ */ new WeakMap;
  var WIP_SLOT = Symbol();
  var componentTypeMap = /* @__PURE__ */ new WeakMap;
  var ssrTransformComponent = (node, context) => {
    if (node.type !== 1 || node.tagType !== 1) {
      return;
    }
    const component = compilerDom.resolveComponentType(node, context, true);
    const isDynamicComponent = shared.isObject(component) && component.callee === compilerDom.RESOLVE_DYNAMIC_COMPONENT;
    componentTypeMap.set(node, component);
    if (shared.isSymbol(component)) {
      if (component === compilerDom.SUSPENSE) {
        return ssrTransformSuspense(node, context);
      } else if (component === compilerDom.TRANSITION_GROUP) {
        return ssrTransformTransitionGroup(node, context);
      } else if (component === compilerDom.TRANSITION) {
        return ssrTransformTransition(node);
      }
      return;
    }
    const vnodeBranches = [];
    const clonedNode = clone(node);
    return function ssrPostTransformComponent() {
      if (clonedNode.children.length) {
        compilerDom.buildSlots(clonedNode, context, (props, vFor, children) => {
          vnodeBranches.push(createVNodeSlotBranch(props, vFor, children, context));
          return compilerDom.createFunctionExpression(undefined);
        });
      }
      let propsExp = `null`;
      if (node.props.length) {
        const { props, directives } = compilerDom.buildProps(node, context, undefined, true, isDynamicComponent);
        if (props || directives.length) {
          propsExp = buildSSRProps(props, directives, context);
        }
      }
      const wipEntries = [];
      wipMap.set(node, wipEntries);
      const buildSSRSlotFn = (props, _vForExp, children, loc) => {
        const param0 = props && compilerDom.stringifyExpression(props) || `_`;
        const fn = compilerDom.createFunctionExpression([param0, `_push`, `_parent`, `_scopeId`], undefined, true, true, loc);
        wipEntries.push({
          type: WIP_SLOT,
          fn,
          children,
          vnodeBranch: vnodeBranches[wipEntries.length]
        });
        return fn;
      };
      const slots = node.children.length ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots : `null`;
      if (typeof component !== "string") {
        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [
          `_push`,
          compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [
            component,
            propsExp,
            slots
          ]),
          `_parent`
        ]);
      } else {
        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, propsExp, slots, `_parent`]);
      }
    };
  };
  function ssrProcessComponent(node, context, parent) {
    const component = componentTypeMap.get(node);
    if (!node.ssrCodegenNode) {
      if (component === compilerDom.TELEPORT) {
        return ssrProcessTeleport(node, context);
      } else if (component === compilerDom.SUSPENSE) {
        return ssrProcessSuspense(node, context);
      } else if (component === compilerDom.TRANSITION_GROUP) {
        return ssrProcessTransitionGroup(node, context);
      } else {
        if (parent.type === WIP_SLOT) {
          context.pushStringPart(``);
        }
        if (component === compilerDom.TRANSITION) {
          return ssrProcessTransition(node, context);
        }
        processChildren(node, context);
      }
    } else {
      const wipEntries = wipMap.get(node) || [];
      for (let i = 0;i < wipEntries.length; i++) {
        const { fn, vnodeBranch } = wipEntries[i];
        fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(wipEntries[i], context, false, true), vnodeBranch);
      }
      if (context.withSlotScopeId) {
        node.ssrCodegenNode.arguments.push(`_scopeId`);
      }
      if (typeof component === "string") {
        context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));
      } else {
        context.pushStatement(node.ssrCodegenNode);
      }
    }
  }
  var rawOptionsMap = /* @__PURE__ */ new WeakMap;
  var [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);
  var vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];
  var vnodeDirectiveTransforms = {
    ...baseDirectiveTransforms,
    ...compilerDom.DOMDirectiveTransforms
  };
  function createVNodeSlotBranch(slotProps, vFor, children, parentContext) {
    const rawOptions = rawOptionsMap.get(parentContext.root);
    const subOptions = {
      ...rawOptions,
      nodeTransforms: [
        ...vnodeNodeTransforms,
        ...rawOptions.nodeTransforms || []
      ],
      directiveTransforms: {
        ...vnodeDirectiveTransforms,
        ...rawOptions.directiveTransforms || {}
      }
    };
    const wrapperProps = [];
    if (slotProps) {
      wrapperProps.push({
        type: 7,
        name: "slot",
        exp: slotProps,
        arg: undefined,
        modifiers: [],
        loc: compilerDom.locStub
      });
    }
    if (vFor) {
      wrapperProps.push(shared.extend({}, vFor));
    }
    const wrapperNode = {
      type: 1,
      ns: 0,
      tag: "template",
      tagType: 3,
      props: wrapperProps,
      children,
      loc: compilerDom.locStub,
      codegenNode: undefined
    };
    subTransform(wrapperNode, subOptions, parentContext);
    return compilerDom.createReturnStatement(children);
  }
  function subTransform(node, options, parentContext) {
    const childRoot = compilerDom.createRoot([node]);
    const childContext = compilerDom.createTransformContext(childRoot, options);
    childContext.ssr = false;
    childContext.scopes = { ...parentContext.scopes };
    childContext.identifiers = { ...parentContext.identifiers };
    childContext.imports = parentContext.imports;
    compilerDom.traverseNode(childRoot, childContext);
    ["helpers", "components", "directives"].forEach((key) => {
      childContext[key].forEach((value, helperKey) => {
        if (key === "helpers") {
          const parentCount = parentContext.helpers.get(helperKey);
          if (parentCount === undefined) {
            parentContext.helpers.set(helperKey, value);
          } else {
            parentContext.helpers.set(helperKey, value + parentCount);
          }
        } else {
          parentContext[key].add(value);
        }
      });
    });
  }
  function clone(v) {
    if (shared.isArray(v)) {
      return v.map(clone);
    } else if (shared.isPlainObject(v)) {
      const res = {};
      for (const key in v) {
        res[key] = clone(v[key]);
      }
      return res;
    } else {
      return v;
    }
  }
  function ssrCodegenTransform(ast, options) {
    const context = createSSRTransformContext(ast, options);
    if (options.ssrCssVars) {
      const cssContext = compilerDom.createTransformContext(compilerDom.createRoot([]), options);
      const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), cssContext);
      context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));
      Array.from(cssContext.helpers.keys()).forEach((helper) => {
        ast.helpers.add(helper);
      });
    }
    const isFragment = ast.children.length > 1 && ast.children.some((c) => !compilerDom.isText(c));
    processChildren(ast, context, isFragment);
    ast.codegenNode = compilerDom.createBlockStatement(context.body);
    ast.ssrHelpers = Array.from(/* @__PURE__ */ new Set([
      ...Array.from(ast.helpers).filter((h) => (h in ssrHelpers)),
      ...context.helpers
    ]));
    ast.helpers = new Set(Array.from(ast.helpers).filter((h) => !(h in ssrHelpers)));
  }
  function createSSRTransformContext(root, options, helpers = /* @__PURE__ */ new Set, withSlotScopeId = false) {
    const body = [];
    let currentString = null;
    return {
      root,
      options,
      body,
      helpers,
      withSlotScopeId,
      onError: options.onError || ((e) => {
        throw e;
      }),
      helper(name2) {
        helpers.add(name2);
        return name2;
      },
      pushStringPart(part) {
        if (!currentString) {
          const currentCall = compilerDom.createCallExpression(`_push`);
          body.push(currentCall);
          currentString = compilerDom.createTemplateLiteral([]);
          currentCall.arguments.push(currentString);
        }
        const bufferedElements = currentString.elements;
        const lastItem = bufferedElements[bufferedElements.length - 1];
        if (shared.isString(part) && shared.isString(lastItem)) {
          bufferedElements[bufferedElements.length - 1] += part;
        } else {
          bufferedElements.push(part);
        }
      },
      pushStatement(statement) {
        currentString = null;
        body.push(statement);
      }
    };
  }
  function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
    return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
  }
  function processChildren(parent, context, asFragment = false, disableNestedFragments = false, disableComment = false) {
    if (asFragment) {
      context.pushStringPart(`<!--[-->`);
    }
    const { children } = parent;
    for (let i = 0;i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          switch (child.tagType) {
            case 0:
              ssrProcessElement(child, context);
              break;
            case 1:
              ssrProcessComponent(child, context, parent);
              break;
            case 2:
              ssrProcessSlotOutlet(child, context);
              break;
            case 3:
              break;
            default:
              context.onError(createSSRCompilerError(67, child.loc));
              const exhaustiveCheck2 = child;
              return exhaustiveCheck2;
          }
          break;
        case 2:
          context.pushStringPart(shared.escapeHtml(child.content));
          break;
        case 3:
          if (!disableComment) {
            context.pushStringPart(`<!--${child.content}-->`);
          }
          break;
        case 5:
          context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
            child.content
          ]));
          break;
        case 9:
          ssrProcessIf(child, context, disableNestedFragments, disableComment);
          break;
        case 11:
          ssrProcessFor(child, context, disableNestedFragments);
          break;
        case 10:
          break;
        case 12:
        case 8:
          break;
        default:
          context.onError(createSSRCompilerError(67, child.loc));
          const exhaustiveCheck = child;
          return exhaustiveCheck;
      }
    }
    if (asFragment) {
      context.pushStringPart(`<!--]-->`);
    }
  }
  function processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
    const childContext = createChildContext(parentContext, withSlotScopeId);
    processChildren(parent, childContext, asFragment);
    return compilerDom.createBlockStatement(childContext.body);
  }
  var ssrTransformModel = (dir, node, context) => {
    const model = dir.exp;
    function checkDuplicatedValue() {
      const value = compilerDom.findProp(node, "value");
      if (value) {
        context.onError(compilerDom.createDOMCompilerError(60, value.loc));
      }
    }
    const processSelectChildren = (children) => {
      children.forEach((child) => {
        if (child.type === 1) {
          processOption(child);
        } else if (child.type === 11) {
          processSelectChildren(child.children);
        } else if (child.type === 9) {
          child.branches.forEach((b) => processSelectChildren(b.children));
        }
      });
    };
    function processOption(plainNode) {
      if (plainNode.tag === "option") {
        if (plainNode.props.findIndex((p) => p.name === "selected") === -1) {
          const value = findValueBinding(plainNode);
          plainNode.ssrCodegenNode.elements.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [
            compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
              model,
              value
            ]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
              model,
              value
            ]))
          ]), compilerDom.createSimpleExpression(" selected", true), compilerDom.createSimpleExpression("", true), false));
        }
      } else if (plainNode.tag === "optgroup") {
        processSelectChildren(plainNode.children);
      }
    }
    if (node.tagType === 0) {
      const res = { props: [] };
      const defaultProps = [
        compilerDom.createObjectProperty(`value`, model)
      ];
      if (node.tag === "input") {
        const type = compilerDom.findProp(node, "type");
        if (type) {
          const value = findValueBinding(node);
          if (type.type === 7) {
            res.ssrTagParts = [
              compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
                type.exp,
                model,
                value
              ])
            ];
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                res.props = [
                  compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                    model,
                    value
                  ]))
                ];
                break;
              case "checkbox":
                const trueValueBinding = compilerDom.findProp(node, "true-value");
                if (trueValueBinding) {
                  const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                  res.props = [
                    compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                      model,
                      trueValue
                    ]))
                  ];
                } else {
                  res.props = [
                    compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                      model,
                      value
                    ]), model))
                  ];
                }
                break;
              case "file":
                context.onError(compilerDom.createDOMCompilerError(59, dir.loc));
                break;
              default:
                checkDuplicatedValue();
                res.props = defaultProps;
                break;
            }
          }
        } else if (compilerDom.hasDynamicKeyVBind(node))
          ;
        else {
          checkDuplicatedValue();
          res.props = defaultProps;
        }
      } else if (node.tag === "textarea") {
        checkDuplicatedValue();
        node.children = [compilerDom.createInterpolation(model, model.loc)];
      } else if (node.tag === "select") {
        processSelectChildren(node.children);
      } else {
        context.onError(compilerDom.createDOMCompilerError(57, dir.loc));
      }
      return res;
    } else {
      return compilerDom.transformModel(dir, node, context);
    }
  };
  function findValueBinding(node) {
    const valueBinding = compilerDom.findProp(node, "value");
    return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);
  }
  var ssrTransformShow = (dir, node, context) => {
    if (!dir.exp) {
      context.onError(compilerDom.createDOMCompilerError(61));
    }
    return {
      props: [
        compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([
          compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))
        ]), false))
      ]
    };
  };
  var filterChild = (node) => node.children.filter((n) => n.type !== 3);
  var hasSingleChild = (node) => filterChild(node).length === 1;
  var ssrInjectFallthroughAttrs = (node, context) => {
    if (node.type === 0) {
      context.identifiers._attrs = 1;
    }
    if (node.type === 1 && node.tagType === 1 && (node.tag === "transition" || node.tag === "Transition" || node.tag === "KeepAlive" || node.tag === "keep-alive")) {
      const rootChildren = filterChild(context.root);
      if (rootChildren.length === 1 && rootChildren[0] === node) {
        if (hasSingleChild(node)) {
          injectFallthroughAttrs(node.children[0]);
        }
        return;
      }
    }
    const parent = context.parent;
    if (!parent || parent.type !== 0) {
      return;
    }
    if (node.type === 10 && hasSingleChild(node)) {
      let hasEncounteredIf = false;
      for (const c of filterChild(parent)) {
        if (c.type === 9 || c.type === 1 && compilerDom.findDir(c, "if")) {
          if (hasEncounteredIf)
            return;
          hasEncounteredIf = true;
        } else if (!hasEncounteredIf || !(c.type === 1 && compilerDom.findDir(c, /else/, true))) {
          return;
        }
      }
      injectFallthroughAttrs(node.children[0]);
    } else if (hasSingleChild(parent)) {
      injectFallthroughAttrs(node);
    }
  };
  function injectFallthroughAttrs(node) {
    if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
      node.props.push({
        type: 7,
        name: "bind",
        arg: undefined,
        exp: compilerDom.createSimpleExpression(`_attrs`, false),
        modifiers: [],
        loc: compilerDom.locStub
      });
    }
  }
  var ssrInjectCssVars = (node, context) => {
    if (!context.ssrCssVars) {
      return;
    }
    if (node.type === 0) {
      context.identifiers._cssVars = 1;
    }
    const parent = context.parent;
    if (!parent || parent.type !== 0) {
      return;
    }
    if (node.type === 10) {
      for (const child of node.children) {
        injectCssVars(child);
      }
    } else {
      injectCssVars(node);
    }
  };
  function injectCssVars(node) {
    if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
      if (node.tag === "suspense" || node.tag === "Suspense") {
        for (const child of node.children) {
          if (child.type === 1 && child.tagType === 3) {
            child.children.forEach(injectCssVars);
          } else {
            injectCssVars(child);
          }
        }
      } else {
        node.props.push({
          type: 7,
          name: "bind",
          arg: undefined,
          exp: compilerDom.createSimpleExpression(`_cssVars`, false),
          modifiers: [],
          loc: compilerDom.locStub
        });
      }
    }
  }
  function compile(source, options = {}) {
    options = {
      ...options,
      ...compilerDom.parserOptions,
      ssr: true,
      inSSR: true,
      scopeId: options.mode === "function" ? null : options.scopeId,
      prefixIdentifiers: true,
      cacheHandlers: false,
      hoistStatic: false
    };
    const ast = typeof source === "string" ? compilerDom.baseParse(source, options) : source;
    rawOptionsMap.set(ast, options);
    compilerDom.transform(ast, {
      ...options,
      hoistStatic: false,
      nodeTransforms: [
        ssrTransformIf,
        ssrTransformFor,
        compilerDom.trackVForSlotScopes,
        compilerDom.transformExpression,
        ssrTransformSlotOutlet,
        ssrInjectFallthroughAttrs,
        ssrInjectCssVars,
        ssrTransformElement,
        ssrTransformComponent,
        compilerDom.trackSlotScopes,
        compilerDom.transformStyle,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: {
        bind: compilerDom.transformBind,
        on: compilerDom.transformOn,
        model: ssrTransformModel,
        show: ssrTransformShow,
        cloak: compilerDom.noopDirectiveTransform,
        once: compilerDom.noopDirectiveTransform,
        memo: compilerDom.noopDirectiveTransform,
        ...options.directiveTransforms || {}
      }
    });
    ssrCodegenTransform(ast, options);
    return compilerDom.generate(ast, options);
  }
  exports.compile = compile;
});

// ../../../../node_modules/@vue/server-renderer/dist/server-renderer.cjs.js
var require_server_renderer_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Vue = require_vue_cjs();
  var shared = require_shared_cjs();
  var compilerSsr = require_compiler_ssr_cjs();
  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      for (var k in e) {
        n[k] = e[k];
      }
    }
    n.default = e;
    return Object.freeze(n);
  }
  var Vue__namespace = /* @__PURE__ */ _interopNamespaceDefault(Vue);
  var shouldIgnoreProp = /* @__PURE__ */ shared.makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);
  function ssrRenderAttrs(props, tag) {
    let ret = "";
    for (const key in props) {
      if (shouldIgnoreProp(key) || shared.isOn(key) || tag === "textarea" && key === "value") {
        continue;
      }
      const value = props[key];
      if (key === "class") {
        ret += ` class="${ssrRenderClass(value)}"`;
      } else if (key === "style") {
        ret += ` style="${ssrRenderStyle(value)}"`;
      } else if (key === "className") {
        ret += ` class="${String(value)}"`;
      } else {
        ret += ssrRenderDynamicAttr(key, value, tag);
      }
    }
    return ret;
  }
  function ssrRenderDynamicAttr(key, value, tag) {
    if (!shared.isRenderableAttrValue(value)) {
      return ``;
    }
    const attrKey = tag && (tag.indexOf("-") > 0 || shared.isSVGTag(tag)) ? key : shared.propsToAttrMap[key] || key.toLowerCase();
    if (shared.isBooleanAttr(attrKey)) {
      return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;
    } else if (shared.isSSRSafeAttrName(attrKey)) {
      return value === "" ? ` ${attrKey}` : ` ${attrKey}="${shared.escapeHtml(value)}"`;
    } else {
      console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);
      return ``;
    }
  }
  function ssrRenderAttr(key, value) {
    if (!shared.isRenderableAttrValue(value)) {
      return ``;
    }
    return ` ${key}="${shared.escapeHtml(value)}"`;
  }
  function ssrRenderClass(raw) {
    return shared.escapeHtml(shared.normalizeClass(raw));
  }
  function ssrRenderStyle(raw) {
    if (!raw) {
      return "";
    }
    if (shared.isString(raw)) {
      return shared.escapeHtml(raw);
    }
    const styles = shared.normalizeStyle(raw);
    return shared.escapeHtml(shared.stringifyStyle(styles));
  }
  function ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {
    return renderComponentVNode(Vue.createVNode(comp, props, children), parentComponent, slotScopeId);
  }
  var { ensureValidVNode } = Vue.ssrUtils;
  function ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {
    push(`<!--[-->`);
    ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);
    push(`<!--]-->`);
  }
  function ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {
    const slotFn = slots[slotName];
    if (slotFn) {
      const slotBuffer = [];
      const bufferedPush = (item) => {
        slotBuffer.push(item);
      };
      const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? " " + slotScopeId : "");
      if (shared.isArray(ret)) {
        const validSlotContent = ensureValidVNode(ret);
        if (validSlotContent) {
          renderVNodeChildren(push, validSlotContent, parentComponent, slotScopeId);
        } else if (fallbackRenderFn) {
          fallbackRenderFn();
        }
      } else {
        let isEmptySlot = true;
        if (transition) {
          isEmptySlot = false;
        } else {
          for (let i = 0;i < slotBuffer.length; i++) {
            if (!isComment(slotBuffer[i])) {
              isEmptySlot = false;
              break;
            }
          }
        }
        if (isEmptySlot) {
          if (fallbackRenderFn) {
            fallbackRenderFn();
          }
        } else {
          let start = 0;
          let end = slotBuffer.length;
          if (transition && slotBuffer[0] === "<!--[-->" && slotBuffer[end - 1] === "<!--]-->") {
            start++;
            end--;
          }
          for (let i = start;i < end; i++) {
            push(slotBuffer[i]);
          }
        }
      }
    } else if (fallbackRenderFn) {
      fallbackRenderFn();
    }
  }
  var commentTestRE = /^<!--[\s\S]*-->$/;
  var commentRE = /<!--[^]*?-->/gm;
  function isComment(item) {
    if (typeof item !== "string" || !commentTestRE.test(item))
      return false;
    if (item.length <= 8)
      return true;
    return !item.replace(commentRE, "").trim();
  }
  function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
    parentPush("<!--teleport start-->");
    const context = parentComponent.appContext.provides[Vue.ssrContextKey];
    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
    const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
    const bufferIndex = targetBuffer.length;
    let teleportContent;
    if (disabled) {
      contentRenderFn(parentPush);
      teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;
    } else {
      const { getBuffer, push } = createBuffer();
      push(`<!--teleport start anchor-->`);
      contentRenderFn(push);
      push(`<!--teleport anchor-->`);
      teleportContent = getBuffer();
    }
    targetBuffer.splice(bufferIndex, 0, teleportContent);
    parentPush("<!--teleport end-->");
  }
  function ssrInterpolate(value) {
    return shared.escapeHtml(shared.toDisplayString(value));
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function isRef(r2) {
    return r2 ? r2["__v_isRef"] === true : false;
  }
  var stack = [];
  function pushWarningContext$1(vnode) {
    stack.push(vnode);
  }
  function popWarningContext$1() {
    stack.pop();
  }
  var isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning)
      return;
    isWarning = true;
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.map((a) => {
          var _a2, _b;
          return (_b = (_a2 = a.toString) == null ? undefined : _a2.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join(`
`),
        trace
      ]);
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (shared.isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (shared.isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  var ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError2(err, instance, type);
    }
  }
  function handleError2(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || shared.EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings[type];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0;i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    {
      const info = ErrorTypeStrings[type];
      if (contextVNode) {
        pushWarningContext$1(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext$1();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  {
    const g = shared.getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key]))
        setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1)
          setters.forEach((set) => set(v));
        else
          setters[0](v);
      };
    };
    registerGlobalSetter(`__VUE_INSTANCE_SETTERS__`, (v) => v);
    registerGlobalSetter(`__VUE_SSR_SETTERS__`, (v) => v);
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name2 = getComponentName(Component);
    if (!name2 && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name2 = match[1];
      }
    }
    if (!name2 && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name2 = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
  }
  var warn = warn$1;
  function ssrRenderList(source, renderItem) {
    if (shared.isArray(source) || shared.isString(source)) {
      for (let i = 0, l = source.length;i < l; i++) {
        renderItem(source[i], i);
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn(`The v-for range expect an integer value but got ${source}.`);
        return;
      }
      for (let i = 0;i < source; i++) {
        renderItem(i + 1, i);
      }
    } else if (shared.isObject(source)) {
      if (source[Symbol.iterator]) {
        const arr = Array.from(source);
        for (let i = 0, l = arr.length;i < l; i++) {
          renderItem(arr[i], i);
        }
      } else {
        const keys = Object.keys(source);
        for (let i = 0, l = keys.length;i < l; i++) {
          const key = keys[i];
          renderItem(source[key], key, i);
        }
      }
    }
  }
  async function ssrRenderSuspense(push, { default: renderContent }) {
    if (renderContent) {
      renderContent();
    } else {
      push(`<!---->`);
    }
  }
  function ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {
    if (typeof dir !== "function" && dir.getSSRProps) {
      return dir.getSSRProps({
        dir,
        instance: Vue.ssrUtils.getComponentPublicInstance(instance.$),
        value,
        oldValue: undefined,
        arg,
        modifiers
      }, null) || {};
    }
    return {};
  }
  var ssrLooseEqual = shared.looseEqual;
  function ssrLooseContain(arr, value) {
    return shared.looseIndexOf(arr, value) > -1;
  }
  function ssrRenderDynamicModel(type, model, value) {
    switch (type) {
      case "radio":
        return shared.looseEqual(model, value) ? " checked" : "";
      case "checkbox":
        return (shared.isArray(model) ? ssrLooseContain(model, value) : model) ? " checked" : "";
      default:
        return ssrRenderAttr("value", model);
    }
  }
  function ssrGetDynamicModelProps(existingProps = {}, model) {
    const { type, value } = existingProps;
    switch (type) {
      case "radio":
        return shared.looseEqual(model, value) ? { checked: true } : null;
      case "checkbox":
        return (shared.isArray(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;
      default:
        return { value: model };
    }
  }
  var helpers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ssrGetDirectiveProps,
    ssrGetDynamicModelProps,
    ssrIncludeBooleanAttr: shared.includeBooleanAttr,
    ssrInterpolate,
    ssrLooseContain,
    ssrLooseEqual,
    ssrRenderAttr,
    ssrRenderAttrs,
    ssrRenderClass,
    ssrRenderComponent,
    ssrRenderDynamicAttr,
    ssrRenderDynamicModel,
    ssrRenderList,
    ssrRenderSlot,
    ssrRenderSlotInner,
    ssrRenderStyle,
    ssrRenderSuspense,
    ssrRenderTeleport,
    ssrRenderVNode: renderVNode
  });
  var compileCache = /* @__PURE__ */ Object.create(null);
  function ssrCompile(template, instance) {
    const Component = instance.type;
    const { isCustomElement, compilerOptions } = instance.appContext.config;
    const { delimiters, compilerOptions: componentCompilerOptions } = Component;
    const finalCompilerOptions = shared.extend(shared.extend({
      isCustomElement,
      delimiters
    }, compilerOptions), componentCompilerOptions);
    finalCompilerOptions.isCustomElement = finalCompilerOptions.isCustomElement || shared.NO;
    finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;
    const cacheKey = JSON.stringify({
      template,
      compilerOptions: finalCompilerOptions
    }, (key, value) => {
      return shared.isFunction(value) ? value.toString() : value;
    });
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    finalCompilerOptions.onError = (err) => {
      {
        const message = `[@vue/server-renderer] Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
        Vue.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
    };
    const { code } = compilerSsr.compile(template, finalCompilerOptions);
    const requireMap = {
      vue: Vue__namespace,
      "vue/server-renderer": helpers
    };
    const fakeRequire = (id) => requireMap[id];
    return compileCache[cacheKey] = Function("require", code)(fakeRequire);
  }
  var {
    createComponentInstance,
    setCurrentRenderingInstance,
    setupComponent,
    renderComponentRoot,
    normalizeVNode,
    pushWarningContext,
    popWarningContext
  } = Vue.ssrUtils;
  function createBuffer() {
    let appendable = false;
    const buffer = [];
    return {
      getBuffer() {
        return buffer;
      },
      push(item) {
        const isStringItem = shared.isString(item);
        if (appendable && isStringItem) {
          buffer[buffer.length - 1] += item;
          return;
        }
        buffer.push(item);
        appendable = isStringItem;
        if (shared.isPromise(item) || shared.isArray(item) && item.hasAsync) {
          buffer.hasAsync = true;
        }
      }
    };
  }
  function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
    const instance = vnode.component = createComponentInstance(vnode, parentComponent, null);
    pushWarningContext(vnode);
    const res = setupComponent(instance, true);
    popWarningContext();
    const hasAsyncSetup = shared.isPromise(res);
    let prefetches = instance.sp;
    if (hasAsyncSetup || prefetches) {
      const p = Promise.resolve(res).then(() => {
        if (hasAsyncSetup)
          prefetches = instance.sp;
        if (prefetches) {
          return Promise.all(prefetches.map((prefetch) => prefetch.call(instance.proxy)));
        }
      }).catch(shared.NOOP);
      return p.then(() => renderComponentSubTree(instance, slotScopeId));
    } else {
      return renderComponentSubTree(instance, slotScopeId);
    }
  }
  function renderComponentSubTree(instance, slotScopeId) {
    pushWarningContext(instance.vnode);
    const comp = instance.type;
    const { getBuffer, push } = createBuffer();
    if (shared.isFunction(comp)) {
      let root = renderComponentRoot(instance);
      if (!comp.props) {
        for (const key in instance.attrs) {
          if (key.startsWith(`data-v-`)) {
            (root.props || (root.props = {}))[key] = ``;
          }
        }
      }
      renderVNode(push, instance.subTree = root, instance, slotScopeId);
    } else {
      if ((!instance.render || instance.render === shared.NOOP) && !instance.ssrRender && !comp.ssrRender && shared.isString(comp.template)) {
        comp.ssrRender = ssrCompile(comp.template, instance);
      }
      const ssrRender = instance.ssrRender || comp.ssrRender;
      if (ssrRender) {
        let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;
        let hasCloned = false;
        let cur = instance;
        while (true) {
          const scopeId = cur.vnode.scopeId;
          if (scopeId) {
            if (!hasCloned) {
              attrs = { ...attrs };
              hasCloned = true;
            }
            attrs[scopeId] = "";
          }
          const parent = cur.parent;
          if (parent && parent.subTree && parent.subTree === cur.vnode) {
            cur = parent;
          } else {
            break;
          }
        }
        if (slotScopeId) {
          if (!hasCloned)
            attrs = { ...attrs };
          const slotScopeIdList = slotScopeId.trim().split(" ");
          for (let i = 0;i < slotScopeIdList.length; i++) {
            attrs[slotScopeIdList[i]] = "";
          }
        }
        const prev = setCurrentRenderingInstance(instance);
        try {
          ssrRender(instance.proxy, push, instance, attrs, instance.props, instance.setupState, instance.data, instance.ctx);
        } finally {
          setCurrentRenderingInstance(prev);
        }
      } else if (instance.render && instance.render !== shared.NOOP) {
        renderVNode(push, instance.subTree = renderComponentRoot(instance), instance, slotScopeId);
      } else {
        const componentName = comp.name || comp.__file || `<Anonymous>`;
        Vue.warn(`Component ${componentName} is missing template or render function.`);
        push(`<!---->`);
      }
    }
    popWarningContext();
    return getBuffer();
  }
  function renderVNode(push, vnode, parentComponent, slotScopeId) {
    const { type, shapeFlag, children, dirs, props } = vnode;
    if (dirs) {
      vnode.props = applySSRDirectives(vnode, props, dirs);
    }
    switch (type) {
      case Vue.Text:
        push(shared.escapeHtml(children));
        break;
      case Vue.Comment:
        push(children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`);
        break;
      case Vue.Static:
        push(children);
        break;
      case Vue.Fragment:
        if (vnode.slotScopeIds) {
          slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
        }
        push(`<!--[-->`);
        renderVNodeChildren(push, children, parentComponent, slotScopeId);
        push(`<!--]-->`);
        break;
      default:
        if (shapeFlag & 1) {
          renderElementVNode(push, vnode, parentComponent, slotScopeId);
        } else if (shapeFlag & 6) {
          push(renderComponentVNode(vnode, parentComponent, slotScopeId));
        } else if (shapeFlag & 64) {
          renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
        } else if (shapeFlag & 128) {
          renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
        } else {
          Vue.warn("[@vue/server-renderer] Invalid VNode type:", type, `(${typeof type})`);
        }
    }
  }
  function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
    for (let i = 0;i < children.length; i++) {
      renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
    }
  }
  function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
    const tag = vnode.type;
    let { props, children, shapeFlag, scopeId } = vnode;
    let openTag = `<${tag}`;
    if (props) {
      openTag += ssrRenderAttrs(props, tag);
    }
    if (scopeId) {
      openTag += ` ${scopeId}`;
    }
    let curParent = parentComponent;
    let curVnode = vnode;
    while (curParent && curVnode === curParent.subTree) {
      curVnode = curParent.vnode;
      if (curVnode.scopeId) {
        openTag += ` ${curVnode.scopeId}`;
      }
      curParent = curParent.parent;
    }
    if (slotScopeId) {
      openTag += ` ${slotScopeId}`;
    }
    push(openTag + `>`);
    if (!shared.isVoidTag(tag)) {
      let hasChildrenOverride = false;
      if (props) {
        if (props.innerHTML) {
          hasChildrenOverride = true;
          push(props.innerHTML);
        } else if (props.textContent) {
          hasChildrenOverride = true;
          push(shared.escapeHtml(props.textContent));
        } else if (tag === "textarea" && props.value) {
          hasChildrenOverride = true;
          push(shared.escapeHtml(props.value));
        }
      }
      if (!hasChildrenOverride) {
        if (shapeFlag & 8) {
          push(shared.escapeHtml(children));
        } else if (shapeFlag & 16) {
          renderVNodeChildren(push, children, parentComponent, slotScopeId);
        }
      }
      push(`</${tag}>`);
    }
  }
  function applySSRDirectives(vnode, rawProps, dirs) {
    const toMerge = [];
    for (let i = 0;i < dirs.length; i++) {
      const binding = dirs[i];
      const {
        dir: { getSSRProps }
      } = binding;
      if (getSSRProps) {
        const props = getSSRProps(binding, vnode);
        if (props)
          toMerge.push(props);
      }
    }
    return Vue.mergeProps(rawProps || {}, ...toMerge);
  }
  function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
    const target = vnode.props && vnode.props.to;
    const disabled = vnode.props && vnode.props.disabled;
    if (!target) {
      if (!disabled) {
        Vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);
      }
      return [];
    }
    if (!shared.isString(target)) {
      Vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);
      return [];
    }
    ssrRenderTeleport(push, (push2) => {
      renderVNodeChildren(push2, vnode.children, parentComponent, slotScopeId);
    }, target, disabled || disabled === "", parentComponent);
  }
  var { isVNode: isVNode$1 } = Vue.ssrUtils;
  function nestedUnrollBuffer(buffer, parentRet, startIndex) {
    if (!buffer.hasAsync) {
      return parentRet + unrollBufferSync$1(buffer);
    }
    let ret = parentRet;
    for (let i = startIndex;i < buffer.length; i += 1) {
      const item = buffer[i];
      if (shared.isString(item)) {
        ret += item;
        continue;
      }
      if (shared.isPromise(item)) {
        return item.then((nestedItem) => {
          buffer[i] = nestedItem;
          return nestedUnrollBuffer(buffer, ret, i);
        });
      }
      const result = nestedUnrollBuffer(item, ret, 0);
      if (shared.isPromise(result)) {
        return result.then((nestedItem) => {
          buffer[i] = nestedItem;
          return nestedUnrollBuffer(buffer, "", i);
        });
      }
      ret = result;
    }
    return ret;
  }
  function unrollBuffer$1(buffer) {
    return nestedUnrollBuffer(buffer, "", 0);
  }
  function unrollBufferSync$1(buffer) {
    let ret = "";
    for (let i = 0;i < buffer.length; i++) {
      let item = buffer[i];
      if (shared.isString(item)) {
        ret += item;
      } else {
        ret += unrollBufferSync$1(item);
      }
    }
    return ret;
  }
  async function renderToString(input, context = {}) {
    if (isVNode$1(input)) {
      return renderToString(Vue.createApp({ render: () => input }), context);
    }
    const vnode = Vue.createVNode(input._component, input._props);
    vnode.appContext = input._context;
    input.provide(Vue.ssrContextKey, context);
    const buffer = await renderComponentVNode(vnode);
    const result = await unrollBuffer$1(buffer);
    await resolveTeleports(context);
    if (context.__watcherHandles) {
      for (const unwatch of context.__watcherHandles) {
        unwatch();
      }
    }
    return result;
  }
  async function resolveTeleports(context) {
    if (context.__teleportBuffers) {
      context.teleports = context.teleports || {};
      for (const key in context.__teleportBuffers) {
        context.teleports[key] = await unrollBuffer$1(await Promise.all([context.__teleportBuffers[key]]));
      }
    }
  }
  var { isVNode } = Vue.ssrUtils;
  async function unrollBuffer(buffer, stream) {
    if (buffer.hasAsync) {
      for (let i = 0;i < buffer.length; i++) {
        let item = buffer[i];
        if (shared.isPromise(item)) {
          item = await item;
        }
        if (shared.isString(item)) {
          stream.push(item);
        } else {
          await unrollBuffer(item, stream);
        }
      }
    } else {
      unrollBufferSync(buffer, stream);
    }
  }
  function unrollBufferSync(buffer, stream) {
    for (let i = 0;i < buffer.length; i++) {
      let item = buffer[i];
      if (shared.isString(item)) {
        stream.push(item);
      } else {
        unrollBufferSync(item, stream);
      }
    }
  }
  function renderToSimpleStream(input, context, stream) {
    if (isVNode(input)) {
      return renderToSimpleStream(Vue.createApp({ render: () => input }), context, stream);
    }
    const vnode = Vue.createVNode(input._component, input._props);
    vnode.appContext = input._context;
    input.provide(Vue.ssrContextKey, context);
    Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {
      if (context.__watcherHandles) {
        for (const unwatch of context.__watcherHandles) {
          unwatch();
        }
      }
    }).then(() => stream.push(null)).catch((error) => {
      stream.destroy(error);
    });
    return stream;
  }
  function renderToStream(input, context = {}) {
    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);
    return renderToNodeStream(input, context);
  }
  function renderToNodeStream(input, context = {}) {
    const stream = new (__require("stream")).Readable({ read() {} });
    if (!stream) {
      throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.`);
    }
    return renderToSimpleStream(input, context, stream);
  }
  function pipeToNodeWritable(input, context = {}, writable) {
    renderToSimpleStream(input, context, {
      push(content) {
        if (content != null) {
          writable.write(content);
        } else {
          writable.end();
        }
      },
      destroy(err) {
        writable.destroy(err);
      }
    });
  }
  function renderToWebStream(input, context = {}) {
    if (typeof ReadableStream !== "function") {
      throw new Error(`ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.`);
    }
    const encoder = new TextEncoder;
    let cancelled = false;
    return new ReadableStream({
      start(controller) {
        renderToSimpleStream(input, context, {
          push(content) {
            if (cancelled)
              return;
            if (content != null) {
              controller.enqueue(encoder.encode(content));
            } else {
              controller.close();
            }
          },
          destroy(err) {
            controller.error(err);
          }
        });
      },
      cancel() {
        cancelled = true;
      }
    });
  }
  function pipeToWebWritable(input, context = {}, writable) {
    const writer = writable.getWriter();
    const encoder = new TextEncoder;
    let hasReady = false;
    try {
      hasReady = shared.isPromise(writer.ready);
    } catch (e) {}
    renderToSimpleStream(input, context, {
      async push(content) {
        if (hasReady) {
          await writer.ready;
        }
        if (content != null) {
          return writer.write(encoder.encode(content));
        } else {
          return writer.close();
        }
      },
      destroy(err) {
        console.log(err);
        writer.close();
      }
    });
  }
  Vue.initDirectivesForSSR();
  exports.ssrIncludeBooleanAttr = shared.includeBooleanAttr;
  exports.pipeToNodeWritable = pipeToNodeWritable;
  exports.pipeToWebWritable = pipeToWebWritable;
  exports.renderToNodeStream = renderToNodeStream;
  exports.renderToSimpleStream = renderToSimpleStream;
  exports.renderToStream = renderToStream;
  exports.renderToString = renderToString;
  exports.renderToWebStream = renderToWebStream;
  exports.ssrGetDirectiveProps = ssrGetDirectiveProps;
  exports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;
  exports.ssrInterpolate = ssrInterpolate;
  exports.ssrLooseContain = ssrLooseContain;
  exports.ssrLooseEqual = ssrLooseEqual;
  exports.ssrRenderAttr = ssrRenderAttr;
  exports.ssrRenderAttrs = ssrRenderAttrs;
  exports.ssrRenderClass = ssrRenderClass;
  exports.ssrRenderComponent = ssrRenderComponent;
  exports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;
  exports.ssrRenderDynamicModel = ssrRenderDynamicModel;
  exports.ssrRenderList = ssrRenderList;
  exports.ssrRenderSlot = ssrRenderSlot;
  exports.ssrRenderSlotInner = ssrRenderSlotInner;
  exports.ssrRenderStyle = ssrRenderStyle;
  exports.ssrRenderSuspense = ssrRenderSuspense;
  exports.ssrRenderTeleport = ssrRenderTeleport;
  exports.ssrRenderVNode = renderVNode;
});

// ../../../../node_modules/module-from-string/node_modules/esbuild/lib/main.js
var require_main = __commonJS((exports, module) => {
  var __dirname = "/Users/glennmichaeltorregosa/Documents/Projects/stacks/node_modules/module-from-string/node_modules/esbuild/lib", __filename = "/Users/glennmichaeltorregosa/Documents/Projects/stacks/node_modules/module-from-string/node_modules/esbuild/lib/main.js";
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export2 = (target, all2) => {
    for (var name3 in all2)
      __defProp(target, name3, { get: all2[name3], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var node_exports = {};
  __export2(node_exports, {
    analyzeMetafile: () => analyzeMetafile,
    analyzeMetafileSync: () => analyzeMetafileSync,
    build: () => build,
    buildSync: () => buildSync,
    context: () => context,
    default: () => node_default,
    formatMessages: () => formatMessages,
    formatMessagesSync: () => formatMessagesSync,
    initialize: () => initialize,
    stop: () => stop,
    transform: () => transform,
    transformSync: () => transformSync,
    version: () => version
  });
  module.exports = __toCommonJS2(node_exports);
  function encodePacket(packet) {
    let visit = (value) => {
      if (value === null) {
        bb2.write8(0);
      } else if (typeof value === "boolean") {
        bb2.write8(1);
        bb2.write8(+value);
      } else if (typeof value === "number") {
        bb2.write8(2);
        bb2.write32(value | 0);
      } else if (typeof value === "string") {
        bb2.write8(3);
        bb2.write(encodeUTF8(value));
      } else if (value instanceof Uint8Array) {
        bb2.write8(4);
        bb2.write(value);
      } else if (value instanceof Array) {
        bb2.write8(5);
        bb2.write32(value.length);
        for (let item of value) {
          visit(item);
        }
      } else {
        let keys = Object.keys(value);
        bb2.write8(6);
        bb2.write32(keys.length);
        for (let key of keys) {
          bb2.write(encodeUTF8(key));
          visit(value[key]);
        }
      }
    };
    let bb2 = new ByteBuffer;
    bb2.write32(0);
    bb2.write32(packet.id << 1 | +!packet.isRequest);
    visit(packet.value);
    writeUInt32LE(bb2.buf, bb2.len - 4, 0);
    return bb2.buf.subarray(0, bb2.len);
  }
  function decodePacket(bytes) {
    let visit = () => {
      switch (bb2.read8()) {
        case 0:
          return null;
        case 1:
          return !!bb2.read8();
        case 2:
          return bb2.read32();
        case 3:
          return decodeUTF8(bb2.read());
        case 4:
          return bb2.read();
        case 5: {
          let count = bb2.read32();
          let value2 = [];
          for (let i = 0;i < count; i++) {
            value2.push(visit());
          }
          return value2;
        }
        case 6: {
          let count = bb2.read32();
          let value2 = {};
          for (let i = 0;i < count; i++) {
            value2[decodeUTF8(bb2.read())] = visit();
          }
          return value2;
        }
        default:
          throw new Error("Invalid packet");
      }
    };
    let bb2 = new ByteBuffer(bytes);
    let id = bb2.read32();
    let isRequest = (id & 1) === 0;
    id >>>= 1;
    let value = visit();
    if (bb2.ptr !== bytes.length) {
      throw new Error("Invalid packet");
    }
    return { id, isRequest, value };
  }
  var ByteBuffer = class {
    constructor(buf = new Uint8Array(1024)) {
      this.buf = buf;
      this.len = 0;
      this.ptr = 0;
    }
    _write(delta) {
      if (this.len + delta > this.buf.length) {
        let clone = new Uint8Array((this.len + delta) * 2);
        clone.set(this.buf);
        this.buf = clone;
      }
      this.len += delta;
      return this.len - delta;
    }
    write8(value) {
      let offset = this._write(1);
      this.buf[offset] = value;
    }
    write32(value) {
      let offset = this._write(4);
      writeUInt32LE(this.buf, value, offset);
    }
    write(bytes) {
      let offset = this._write(4 + bytes.length);
      writeUInt32LE(this.buf, bytes.length, offset);
      this.buf.set(bytes, offset + 4);
    }
    _read(delta) {
      if (this.ptr + delta > this.buf.length) {
        throw new Error("Invalid packet");
      }
      this.ptr += delta;
      return this.ptr - delta;
    }
    read8() {
      return this.buf[this._read(1)];
    }
    read32() {
      return readUInt32LE(this.buf, this._read(4));
    }
    read() {
      let length = this.read32();
      let bytes = new Uint8Array(length);
      let ptr = this._read(bytes.length);
      bytes.set(this.buf.subarray(ptr, ptr + length));
      return bytes;
    }
  };
  var encodeUTF8;
  var decodeUTF8;
  var encodeInvariant;
  if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
    let encoder = new TextEncoder;
    let decoder = new TextDecoder;
    encodeUTF8 = (text) => encoder.encode(text);
    decodeUTF8 = (bytes) => decoder.decode(bytes);
    encodeInvariant = 'new TextEncoder().encode("")';
  } else if (typeof Buffer !== "undefined") {
    encodeUTF8 = (text) => Buffer.from(text);
    decodeUTF8 = (bytes) => {
      let { buffer, byteOffset, byteLength } = bytes;
      return Buffer.from(buffer, byteOffset, byteLength).toString();
    };
    encodeInvariant = 'Buffer.from("")';
  } else {
    throw new Error("No UTF-8 codec found");
  }
  if (!(encodeUTF8("") instanceof Uint8Array))
    throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
  function readUInt32LE(buffer, offset) {
    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
  }
  function writeUInt32LE(buffer, value, offset) {
    buffer[offset++] = value;
    buffer[offset++] = value >> 8;
    buffer[offset++] = value >> 16;
    buffer[offset++] = value >> 24;
  }
  var quote = JSON.stringify;
  var buildLogLevelDefault = "warning";
  var transformLogLevelDefault = "silent";
  function validateTarget(target) {
    validateStringValue(target, "target");
    if (target.indexOf(",") >= 0)
      throw new Error(`Invalid target: ${target}`);
    return target;
  }
  var canBeAnything = () => null;
  var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
  var mustBeString = (value) => typeof value === "string" ? null : "a string";
  var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
  var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
  var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
  var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
  var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
  var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
  var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
  var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
  var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
  var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
  var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
  var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
  var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
  function getFlag(object, keys, key, mustBeFn) {
    let value = object[key];
    keys[key + ""] = true;
    if (value === undefined)
      return;
    let mustBe = mustBeFn(value);
    if (mustBe !== null)
      throw new Error(`${quote(key)} must be ${mustBe}`);
    return value;
  }
  function checkForInvalidFlags(object, keys, where) {
    for (let key in object) {
      if (!(key in keys)) {
        throw new Error(`Invalid option ${where}: ${quote(key)}`);
      }
    }
  }
  function validateInitializeOptions(options3) {
    let keys = /* @__PURE__ */ Object.create(null);
    let wasmURL = getFlag(options3, keys, "wasmURL", mustBeStringOrURL);
    let wasmModule = getFlag(options3, keys, "wasmModule", mustBeWebAssemblyModule);
    let worker = getFlag(options3, keys, "worker", mustBeBoolean);
    checkForInvalidFlags(options3, keys, "in initialize() call");
    return {
      wasmURL,
      wasmModule,
      worker
    };
  }
  function validateMangleCache(mangleCache) {
    let validated;
    if (mangleCache !== undefined) {
      validated = /* @__PURE__ */ Object.create(null);
      for (let key in mangleCache) {
        let value = mangleCache[key];
        if (typeof value === "string" || value === false) {
          validated[key] = value;
        } else {
          throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
        }
      }
    }
    return validated;
  }
  function pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault) {
    let color = getFlag(options3, keys, "color", mustBeBoolean);
    let logLevel = getFlag(options3, keys, "logLevel", mustBeString);
    let logLimit = getFlag(options3, keys, "logLimit", mustBeInteger);
    if (color !== undefined)
      flags.push(`--color=${color}`);
    else if (isTTY2)
      flags.push(`--color=true`);
    flags.push(`--log-level=${logLevel || logLevelDefault}`);
    flags.push(`--log-limit=${logLimit || 0}`);
  }
  function validateStringValue(value, what, key) {
    if (typeof value !== "string") {
      throw new Error(`Expected value for ${what}${key !== undefined ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
    }
    return value;
  }
  function pushCommonFlags(flags, options3, keys) {
    let legalComments = getFlag(options3, keys, "legalComments", mustBeString);
    let sourceRoot = getFlag(options3, keys, "sourceRoot", mustBeString);
    let sourcesContent = getFlag(options3, keys, "sourcesContent", mustBeBoolean);
    let target = getFlag(options3, keys, "target", mustBeStringOrArray);
    let format = getFlag(options3, keys, "format", mustBeString);
    let globalName = getFlag(options3, keys, "globalName", mustBeString);
    let mangleProps = getFlag(options3, keys, "mangleProps", mustBeRegExp);
    let reserveProps = getFlag(options3, keys, "reserveProps", mustBeRegExp);
    let mangleQuoted = getFlag(options3, keys, "mangleQuoted", mustBeBoolean);
    let minify = getFlag(options3, keys, "minify", mustBeBoolean);
    let minifySyntax = getFlag(options3, keys, "minifySyntax", mustBeBoolean);
    let minifyWhitespace = getFlag(options3, keys, "minifyWhitespace", mustBeBoolean);
    let minifyIdentifiers = getFlag(options3, keys, "minifyIdentifiers", mustBeBoolean);
    let lineLimit = getFlag(options3, keys, "lineLimit", mustBeInteger);
    let drop = getFlag(options3, keys, "drop", mustBeArray);
    let dropLabels = getFlag(options3, keys, "dropLabels", mustBeArray);
    let charset = getFlag(options3, keys, "charset", mustBeString);
    let treeShaking = getFlag(options3, keys, "treeShaking", mustBeBoolean);
    let ignoreAnnotations = getFlag(options3, keys, "ignoreAnnotations", mustBeBoolean);
    let jsx = getFlag(options3, keys, "jsx", mustBeString);
    let jsxFactory = getFlag(options3, keys, "jsxFactory", mustBeString);
    let jsxFragment = getFlag(options3, keys, "jsxFragment", mustBeString);
    let jsxImportSource = getFlag(options3, keys, "jsxImportSource", mustBeString);
    let jsxDev = getFlag(options3, keys, "jsxDev", mustBeBoolean);
    let jsxSideEffects = getFlag(options3, keys, "jsxSideEffects", mustBeBoolean);
    let define2 = getFlag(options3, keys, "define", mustBeObject);
    let logOverride = getFlag(options3, keys, "logOverride", mustBeObject);
    let supported = getFlag(options3, keys, "supported", mustBeObject);
    let pure = getFlag(options3, keys, "pure", mustBeArray);
    let keepNames = getFlag(options3, keys, "keepNames", mustBeBoolean);
    let platform = getFlag(options3, keys, "platform", mustBeString);
    let tsconfigRaw = getFlag(options3, keys, "tsconfigRaw", mustBeStringOrObject);
    if (legalComments)
      flags.push(`--legal-comments=${legalComments}`);
    if (sourceRoot !== undefined)
      flags.push(`--source-root=${sourceRoot}`);
    if (sourcesContent !== undefined)
      flags.push(`--sources-content=${sourcesContent}`);
    if (target) {
      if (Array.isArray(target))
        flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
      else
        flags.push(`--target=${validateTarget(target)}`);
    }
    if (format)
      flags.push(`--format=${format}`);
    if (globalName)
      flags.push(`--global-name=${globalName}`);
    if (platform)
      flags.push(`--platform=${platform}`);
    if (tsconfigRaw)
      flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
    if (minify)
      flags.push("--minify");
    if (minifySyntax)
      flags.push("--minify-syntax");
    if (minifyWhitespace)
      flags.push("--minify-whitespace");
    if (minifyIdentifiers)
      flags.push("--minify-identifiers");
    if (lineLimit)
      flags.push(`--line-limit=${lineLimit}`);
    if (charset)
      flags.push(`--charset=${charset}`);
    if (treeShaking !== undefined)
      flags.push(`--tree-shaking=${treeShaking}`);
    if (ignoreAnnotations)
      flags.push(`--ignore-annotations`);
    if (drop)
      for (let what of drop)
        flags.push(`--drop:${validateStringValue(what, "drop")}`);
    if (dropLabels)
      flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
    if (mangleProps)
      flags.push(`--mangle-props=${mangleProps.source}`);
    if (reserveProps)
      flags.push(`--reserve-props=${reserveProps.source}`);
    if (mangleQuoted !== undefined)
      flags.push(`--mangle-quoted=${mangleQuoted}`);
    if (jsx)
      flags.push(`--jsx=${jsx}`);
    if (jsxFactory)
      flags.push(`--jsx-factory=${jsxFactory}`);
    if (jsxFragment)
      flags.push(`--jsx-fragment=${jsxFragment}`);
    if (jsxImportSource)
      flags.push(`--jsx-import-source=${jsxImportSource}`);
    if (jsxDev)
      flags.push(`--jsx-dev`);
    if (jsxSideEffects)
      flags.push(`--jsx-side-effects`);
    if (define2) {
      for (let key in define2) {
        if (key.indexOf("=") >= 0)
          throw new Error(`Invalid define: ${key}`);
        flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
      }
    }
    if (logOverride) {
      for (let key in logOverride) {
        if (key.indexOf("=") >= 0)
          throw new Error(`Invalid log override: ${key}`);
        flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
      }
    }
    if (supported) {
      for (let key in supported) {
        if (key.indexOf("=") >= 0)
          throw new Error(`Invalid supported: ${key}`);
        const value = supported[key];
        if (typeof value !== "boolean")
          throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
        flags.push(`--supported:${key}=${value}`);
      }
    }
    if (pure)
      for (let fn2 of pure)
        flags.push(`--pure:${validateStringValue(fn2, "pure")}`);
    if (keepNames)
      flags.push(`--keep-names`);
  }
  function flagsForBuildOptions(callName, options3, isTTY2, logLevelDefault, writeDefault) {
    var _a22;
    let flags = [];
    let entries = [];
    let keys = /* @__PURE__ */ Object.create(null);
    let stdinContents = null;
    let stdinResolveDir = null;
    pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
    pushCommonFlags(flags, options3, keys);
    let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
    let bundle = getFlag(options3, keys, "bundle", mustBeBoolean);
    let splitting = getFlag(options3, keys, "splitting", mustBeBoolean);
    let preserveSymlinks = getFlag(options3, keys, "preserveSymlinks", mustBeBoolean);
    let metafile = getFlag(options3, keys, "metafile", mustBeBoolean);
    let outfile = getFlag(options3, keys, "outfile", mustBeString);
    let outdir = getFlag(options3, keys, "outdir", mustBeString);
    let outbase = getFlag(options3, keys, "outbase", mustBeString);
    let tsconfig = getFlag(options3, keys, "tsconfig", mustBeString);
    let resolveExtensions = getFlag(options3, keys, "resolveExtensions", mustBeArray);
    let nodePathsInput = getFlag(options3, keys, "nodePaths", mustBeArray);
    let mainFields = getFlag(options3, keys, "mainFields", mustBeArray);
    let conditions = getFlag(options3, keys, "conditions", mustBeArray);
    let external = getFlag(options3, keys, "external", mustBeArray);
    let packages = getFlag(options3, keys, "packages", mustBeString);
    let alias = getFlag(options3, keys, "alias", mustBeObject);
    let loader = getFlag(options3, keys, "loader", mustBeObject);
    let outExtension = getFlag(options3, keys, "outExtension", mustBeObject);
    let publicPath = getFlag(options3, keys, "publicPath", mustBeString);
    let entryNames = getFlag(options3, keys, "entryNames", mustBeString);
    let chunkNames = getFlag(options3, keys, "chunkNames", mustBeString);
    let assetNames = getFlag(options3, keys, "assetNames", mustBeString);
    let inject = getFlag(options3, keys, "inject", mustBeArray);
    let banner = getFlag(options3, keys, "banner", mustBeObject);
    let footer = getFlag(options3, keys, "footer", mustBeObject);
    let entryPoints = getFlag(options3, keys, "entryPoints", mustBeEntryPoints);
    let absWorkingDir = getFlag(options3, keys, "absWorkingDir", mustBeString);
    let stdin = getFlag(options3, keys, "stdin", mustBeObject);
    let write = (_a22 = getFlag(options3, keys, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
    let allowOverwrite = getFlag(options3, keys, "allowOverwrite", mustBeBoolean);
    let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
    keys.plugins = true;
    checkForInvalidFlags(options3, keys, `in ${callName}() call`);
    if (sourcemap)
      flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
    if (bundle)
      flags.push("--bundle");
    if (allowOverwrite)
      flags.push("--allow-overwrite");
    if (splitting)
      flags.push("--splitting");
    if (preserveSymlinks)
      flags.push("--preserve-symlinks");
    if (metafile)
      flags.push(`--metafile`);
    if (outfile)
      flags.push(`--outfile=${outfile}`);
    if (outdir)
      flags.push(`--outdir=${outdir}`);
    if (outbase)
      flags.push(`--outbase=${outbase}`);
    if (tsconfig)
      flags.push(`--tsconfig=${tsconfig}`);
    if (packages)
      flags.push(`--packages=${packages}`);
    if (resolveExtensions) {
      let values = [];
      for (let value of resolveExtensions) {
        validateStringValue(value, "resolve extension");
        if (value.indexOf(",") >= 0)
          throw new Error(`Invalid resolve extension: ${value}`);
        values.push(value);
      }
      flags.push(`--resolve-extensions=${values.join(",")}`);
    }
    if (publicPath)
      flags.push(`--public-path=${publicPath}`);
    if (entryNames)
      flags.push(`--entry-names=${entryNames}`);
    if (chunkNames)
      flags.push(`--chunk-names=${chunkNames}`);
    if (assetNames)
      flags.push(`--asset-names=${assetNames}`);
    if (mainFields) {
      let values = [];
      for (let value of mainFields) {
        validateStringValue(value, "main field");
        if (value.indexOf(",") >= 0)
          throw new Error(`Invalid main field: ${value}`);
        values.push(value);
      }
      flags.push(`--main-fields=${values.join(",")}`);
    }
    if (conditions) {
      let values = [];
      for (let value of conditions) {
        validateStringValue(value, "condition");
        if (value.indexOf(",") >= 0)
          throw new Error(`Invalid condition: ${value}`);
        values.push(value);
      }
      flags.push(`--conditions=${values.join(",")}`);
    }
    if (external)
      for (let name3 of external)
        flags.push(`--external:${validateStringValue(name3, "external")}`);
    if (alias) {
      for (let old in alias) {
        if (old.indexOf("=") >= 0)
          throw new Error(`Invalid package name in alias: ${old}`);
        flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
      }
    }
    if (banner) {
      for (let type in banner) {
        if (type.indexOf("=") >= 0)
          throw new Error(`Invalid banner file type: ${type}`);
        flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
      }
    }
    if (footer) {
      for (let type in footer) {
        if (type.indexOf("=") >= 0)
          throw new Error(`Invalid footer file type: ${type}`);
        flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
      }
    }
    if (inject)
      for (let path3 of inject)
        flags.push(`--inject:${validateStringValue(path3, "inject")}`);
    if (loader) {
      for (let ext in loader) {
        if (ext.indexOf("=") >= 0)
          throw new Error(`Invalid loader extension: ${ext}`);
        flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
      }
    }
    if (outExtension) {
      for (let ext in outExtension) {
        if (ext.indexOf("=") >= 0)
          throw new Error(`Invalid out extension: ${ext}`);
        flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
      }
    }
    if (entryPoints) {
      if (Array.isArray(entryPoints)) {
        for (let i = 0, n2 = entryPoints.length;i < n2; i++) {
          let entryPoint = entryPoints[i];
          if (typeof entryPoint === "object" && entryPoint !== null) {
            let entryPointKeys = /* @__PURE__ */ Object.create(null);
            let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
            let output2 = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
            checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
            if (input === undefined)
              throw new Error('Missing property "in" for entry point at index ' + i);
            if (output2 === undefined)
              throw new Error('Missing property "out" for entry point at index ' + i);
            entries.push([output2, input]);
          } else {
            entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
          }
        }
      } else {
        for (let key in entryPoints) {
          entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
        }
      }
    }
    if (stdin) {
      let stdinKeys = /* @__PURE__ */ Object.create(null);
      let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
      let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
      let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
      let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
      checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader2)
        flags.push(`--loader=${loader2}`);
      if (resolveDir)
        stdinResolveDir = resolveDir;
      if (typeof contents === "string")
        stdinContents = encodeUTF8(contents);
      else if (contents instanceof Uint8Array)
        stdinContents = contents;
    }
    let nodePaths = [];
    if (nodePathsInput) {
      for (let value of nodePathsInput) {
        value += "";
        nodePaths.push(value);
      }
    }
    return {
      entries,
      flags,
      write,
      stdinContents,
      stdinResolveDir,
      absWorkingDir,
      nodePaths,
      mangleCache: validateMangleCache(mangleCache)
    };
  }
  function flagsForTransformOptions(callName, options3, isTTY2, logLevelDefault) {
    let flags = [];
    let keys = /* @__PURE__ */ Object.create(null);
    pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
    pushCommonFlags(flags, options3, keys);
    let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
    let sourcefile = getFlag(options3, keys, "sourcefile", mustBeString);
    let loader = getFlag(options3, keys, "loader", mustBeString);
    let banner = getFlag(options3, keys, "banner", mustBeString);
    let footer = getFlag(options3, keys, "footer", mustBeString);
    let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
    checkForInvalidFlags(options3, keys, `in ${callName}() call`);
    if (sourcemap)
      flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
    if (sourcefile)
      flags.push(`--sourcefile=${sourcefile}`);
    if (loader)
      flags.push(`--loader=${loader}`);
    if (banner)
      flags.push(`--banner=${banner}`);
    if (footer)
      flags.push(`--footer=${footer}`);
    return {
      flags,
      mangleCache: validateMangleCache(mangleCache)
    };
  }
  function createChannel(streamIn) {
    const requestCallbacksByKey = {};
    const closeData = { didClose: false, reason: "" };
    let responseCallbacks = {};
    let nextRequestID = 0;
    let nextBuildKey = 0;
    let stdout = new Uint8Array(16 * 1024);
    let stdoutUsed = 0;
    let readFromStdout = (chunk) => {
      let limit = stdoutUsed + chunk.length;
      if (limit > stdout.length) {
        let swap = new Uint8Array(limit * 2);
        swap.set(stdout);
        stdout = swap;
      }
      stdout.set(chunk, stdoutUsed);
      stdoutUsed += chunk.length;
      let offset = 0;
      while (offset + 4 <= stdoutUsed) {
        let length = readUInt32LE(stdout, offset);
        if (offset + 4 + length > stdoutUsed) {
          break;
        }
        offset += 4;
        handleIncomingPacket(stdout.subarray(offset, offset + length));
        offset += length;
      }
      if (offset > 0) {
        stdout.copyWithin(0, offset, stdoutUsed);
        stdoutUsed -= offset;
      }
    };
    let afterClose = (error) => {
      closeData.didClose = true;
      if (error)
        closeData.reason = ": " + (error.message || error);
      const text = "The service was stopped" + closeData.reason;
      for (let id in responseCallbacks) {
        responseCallbacks[id](text, null);
      }
      responseCallbacks = {};
    };
    let sendRequest = (refs, value, callback) => {
      if (closeData.didClose)
        return callback("The service is no longer running" + closeData.reason, null);
      let id = nextRequestID++;
      responseCallbacks[id] = (error, response) => {
        try {
          callback(error, response);
        } finally {
          if (refs)
            refs.unref();
        }
      };
      if (refs)
        refs.ref();
      streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
    };
    let sendResponse = (id, value) => {
      if (closeData.didClose)
        throw new Error("The service is no longer running" + closeData.reason);
      streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
    };
    let handleRequest = async (id, request2) => {
      try {
        if (request2.command === "ping") {
          sendResponse(id, {});
          return;
        }
        if (typeof request2.key === "number") {
          const requestCallbacks = requestCallbacksByKey[request2.key];
          if (!requestCallbacks) {
            return;
          }
          const callback = requestCallbacks[request2.command];
          if (callback) {
            await callback(id, request2);
            return;
          }
        }
        throw new Error(`Invalid command: ` + request2.command);
      } catch (e2) {
        const errors2 = [extractErrorMessageV8(e2, streamIn, null, undefined, "")];
        try {
          sendResponse(id, { errors: errors2 });
        } catch {}
      }
    };
    let isFirstPacket = true;
    let handleIncomingPacket = (bytes) => {
      if (isFirstPacket) {
        isFirstPacket = false;
        let binaryVersion = String.fromCharCode(...bytes);
        if (binaryVersion !== "0.23.1") {
          throw new Error(`Cannot start service: Host version "${"0.23.1"}" does not match binary version ${quote(binaryVersion)}`);
        }
        return;
      }
      let packet = decodePacket(bytes);
      if (packet.isRequest) {
        handleRequest(packet.id, packet.value);
      } else {
        let callback = responseCallbacks[packet.id];
        delete responseCallbacks[packet.id];
        if (packet.value.error)
          callback(packet.value.error, {});
        else
          callback(null, packet.value);
      }
    };
    let buildOrContext = ({ callName, refs, options: options3, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
      let refCount = 0;
      const buildKey = nextBuildKey++;
      const requestCallbacks = {};
      const buildRefs = {
        ref() {
          if (++refCount === 1) {
            if (refs)
              refs.ref();
          }
        },
        unref() {
          if (--refCount === 0) {
            delete requestCallbacksByKey[buildKey];
            if (refs)
              refs.unref();
          }
        }
      };
      requestCallbacksByKey[buildKey] = requestCallbacks;
      buildRefs.ref();
      buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, buildRefs, streamIn, requestCallbacks, options3, isTTY2, defaultWD2, (err, res) => {
        try {
          callback(err, res);
        } finally {
          buildRefs.unref();
        }
      });
    };
    let transform2 = ({ callName, refs, input, options: options3, isTTY: isTTY2, fs: fs3, callback }) => {
      const details = createObjectStash();
      let start = (inputPath) => {
        try {
          if (typeof input !== "string" && !(input instanceof Uint8Array))
            throw new Error('The input to "transform" must be a string or a Uint8Array');
          let {
            flags,
            mangleCache
          } = flagsForTransformOptions(callName, options3, isTTY2, transformLogLevelDefault);
          let request2 = {
            command: "transform",
            flags,
            inputFS: inputPath !== null,
            input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
          };
          if (mangleCache)
            request2.mangleCache = mangleCache;
          sendRequest(refs, request2, (error, response) => {
            if (error)
              return callback(new Error(error), null);
            let errors2 = replaceDetailsInMessages(response.errors, details);
            let warnings = replaceDetailsInMessages(response.warnings, details);
            let outstanding = 1;
            let next = () => {
              if (--outstanding === 0) {
                let result = {
                  warnings,
                  code: response.code,
                  map: response.map,
                  mangleCache: undefined,
                  legalComments: undefined
                };
                if ("legalComments" in response)
                  result.legalComments = response == null ? undefined : response.legalComments;
                if (response.mangleCache)
                  result.mangleCache = response == null ? undefined : response.mangleCache;
                callback(null, result);
              }
            };
            if (errors2.length > 0)
              return callback(failureErrorWithLog("Transform failed", errors2, warnings), null);
            if (response.codeFS) {
              outstanding++;
              fs3.readFile(response.code, (err, contents) => {
                if (err !== null) {
                  callback(err, null);
                } else {
                  response.code = contents;
                  next();
                }
              });
            }
            if (response.mapFS) {
              outstanding++;
              fs3.readFile(response.map, (err, contents) => {
                if (err !== null) {
                  callback(err, null);
                } else {
                  response.map = contents;
                  next();
                }
              });
            }
            next();
          });
        } catch (e2) {
          let flags = [];
          try {
            pushLogFlags(flags, options3, {}, isTTY2, transformLogLevelDefault);
          } catch {}
          const error = extractErrorMessageV8(e2, streamIn, details, undefined, "");
          sendRequest(refs, { command: "error", flags, error }, () => {
            error.detail = details.load(error.detail);
            callback(failureErrorWithLog("Transform failed", [error], []), null);
          });
        }
      };
      if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
        let next = start;
        start = () => fs3.writeFile(input, next);
      }
      start(null);
    };
    let formatMessages2 = ({ callName, refs, messages, options: options3, callback }) => {
      if (!options3)
        throw new Error(`Missing second argument in ${callName}() call`);
      let keys = {};
      let kind = getFlag(options3, keys, "kind", mustBeString);
      let color = getFlag(options3, keys, "color", mustBeBoolean);
      let terminalWidth = getFlag(options3, keys, "terminalWidth", mustBeInteger);
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      if (kind === undefined)
        throw new Error(`Missing "kind" in ${callName}() call`);
      if (kind !== "error" && kind !== "warning")
        throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
      let request2 = {
        command: "format-msgs",
        messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
        isWarning: kind === "warning"
      };
      if (color !== undefined)
        request2.color = color;
      if (terminalWidth !== undefined)
        request2.terminalWidth = terminalWidth;
      sendRequest(refs, request2, (error, response) => {
        if (error)
          return callback(new Error(error), null);
        callback(null, response.messages);
      });
    };
    let analyzeMetafile2 = ({ callName, refs, metafile, options: options3, callback }) => {
      if (options3 === undefined)
        options3 = {};
      let keys = {};
      let color = getFlag(options3, keys, "color", mustBeBoolean);
      let verbose = getFlag(options3, keys, "verbose", mustBeBoolean);
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      let request2 = {
        command: "analyze-metafile",
        metafile
      };
      if (color !== undefined)
        request2.color = color;
      if (verbose !== undefined)
        request2.verbose = verbose;
      sendRequest(refs, request2, (error, response) => {
        if (error)
          return callback(new Error(error), null);
        callback(null, response.result);
      });
    };
    return {
      readFromStdout,
      afterClose,
      service: {
        buildOrContext,
        transform: transform2,
        formatMessages: formatMessages2,
        analyzeMetafile: analyzeMetafile2
      }
    };
  }
  function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options3, isTTY2, defaultWD2, callback) {
    const details = createObjectStash();
    const isContext = callName === "context";
    const handleError2 = (e2, pluginName) => {
      const flags = [];
      try {
        pushLogFlags(flags, options3, {}, isTTY2, buildLogLevelDefault);
      } catch {}
      const message = extractErrorMessageV8(e2, streamIn, details, undefined, pluginName);
      sendRequest(refs, { command: "error", flags, error: message }, () => {
        message.detail = details.load(message.detail);
        callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
      });
    };
    let plugins;
    if (typeof options3 === "object") {
      const value = options3.plugins;
      if (value !== undefined) {
        if (!Array.isArray(value))
          return handleError2(new Error(`"plugins" must be an array`), "");
        plugins = value;
      }
    }
    if (plugins && plugins.length > 0) {
      if (streamIn.isSync)
        return handleError2(new Error("Cannot use plugins in synchronous API calls"), "");
      handlePlugins(buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options3, plugins, details).then((result) => {
        if (!result.ok)
          return handleError2(result.error, result.pluginName);
        try {
          buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
        } catch (e2) {
          handleError2(e2, "");
        }
      }, (e2) => handleError2(e2, ""));
      return;
    }
    try {
      buildOrContextContinue(null, (result, done) => done([], []), () => {});
    } catch (e2) {
      handleError2(e2, "");
    }
    function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
      const writeDefault = streamIn.hasFS;
      const {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache
      } = flagsForBuildOptions(callName, options3, isTTY2, buildLogLevelDefault, writeDefault);
      if (write && !streamIn.hasFS)
        throw new Error(`The "write" option is unavailable in this environment`);
      const request2 = {
        command: "build",
        key: buildKey,
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir: absWorkingDir || defaultWD2,
        nodePaths,
        context: isContext
      };
      if (requestPlugins)
        request2.plugins = requestPlugins;
      if (mangleCache)
        request2.mangleCache = mangleCache;
      const buildResponseToResult = (response, callback2) => {
        const result = {
          errors: replaceDetailsInMessages(response.errors, details),
          warnings: replaceDetailsInMessages(response.warnings, details),
          outputFiles: undefined,
          metafile: undefined,
          mangleCache: undefined
        };
        const originalErrors = result.errors.slice();
        const originalWarnings = result.warnings.slice();
        if (response.outputFiles)
          result.outputFiles = response.outputFiles.map(convertOutputFiles);
        if (response.metafile)
          result.metafile = JSON.parse(response.metafile);
        if (response.mangleCache)
          result.mangleCache = response.mangleCache;
        if (response.writeToStdout !== undefined)
          console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
        runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
          if (originalErrors.length > 0 || onEndErrors.length > 0) {
            const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
            return callback2(error, null, onEndErrors, onEndWarnings);
          }
          callback2(null, result, onEndErrors, onEndWarnings);
        });
      };
      let latestResultPromise;
      let provideLatestResult;
      if (isContext)
        requestCallbacks["on-end"] = (id, request22) => new Promise((resolve) => {
          buildResponseToResult(request22, (err, result, onEndErrors, onEndWarnings) => {
            const response = {
              errors: onEndErrors,
              warnings: onEndWarnings
            };
            if (provideLatestResult)
              provideLatestResult(err, result);
            latestResultPromise = undefined;
            provideLatestResult = undefined;
            sendResponse(id, response);
            resolve();
          });
        });
      sendRequest(refs, request2, (error, response) => {
        if (error)
          return callback(new Error(error), null);
        if (!isContext) {
          return buildResponseToResult(response, (err, res) => {
            scheduleOnDisposeCallbacks();
            return callback(err, res);
          });
        }
        if (response.errors.length > 0) {
          return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
        }
        let didDispose = false;
        const result = {
          rebuild: () => {
            if (!latestResultPromise)
              latestResultPromise = new Promise((resolve, reject) => {
                let settlePromise;
                provideLatestResult = (err, result2) => {
                  if (!settlePromise)
                    settlePromise = () => err ? reject(err) : resolve(result2);
                };
                const triggerAnotherBuild = () => {
                  const request22 = {
                    command: "rebuild",
                    key: buildKey
                  };
                  sendRequest(refs, request22, (error2, response2) => {
                    if (error2) {
                      reject(new Error(error2));
                    } else if (settlePromise) {
                      settlePromise();
                    } else {
                      triggerAnotherBuild();
                    }
                  });
                };
                triggerAnotherBuild();
              });
            return latestResultPromise;
          },
          watch: (options22 = {}) => new Promise((resolve, reject) => {
            if (!streamIn.hasFS)
              throw new Error(`Cannot use the "watch" API in this environment`);
            const keys = {};
            checkForInvalidFlags(options22, keys, `in watch() call`);
            const request22 = {
              command: "watch",
              key: buildKey
            };
            sendRequest(refs, request22, (error2) => {
              if (error2)
                reject(new Error(error2));
              else
                resolve(undefined);
            });
          }),
          serve: (options22 = {}) => new Promise((resolve, reject) => {
            if (!streamIn.hasFS)
              throw new Error(`Cannot use the "serve" API in this environment`);
            const keys = {};
            const port = getFlag(options22, keys, "port", mustBeInteger);
            const host = getFlag(options22, keys, "host", mustBeString);
            const servedir = getFlag(options22, keys, "servedir", mustBeString);
            const keyfile = getFlag(options22, keys, "keyfile", mustBeString);
            const certfile = getFlag(options22, keys, "certfile", mustBeString);
            const fallback = getFlag(options22, keys, "fallback", mustBeString);
            const onRequest = getFlag(options22, keys, "onRequest", mustBeFunction);
            checkForInvalidFlags(options22, keys, `in serve() call`);
            const request22 = {
              command: "serve",
              key: buildKey,
              onRequest: !!onRequest
            };
            if (port !== undefined)
              request22.port = port;
            if (host !== undefined)
              request22.host = host;
            if (servedir !== undefined)
              request22.servedir = servedir;
            if (keyfile !== undefined)
              request22.keyfile = keyfile;
            if (certfile !== undefined)
              request22.certfile = certfile;
            if (fallback !== undefined)
              request22.fallback = fallback;
            sendRequest(refs, request22, (error2, response2) => {
              if (error2)
                return reject(new Error(error2));
              if (onRequest) {
                requestCallbacks["serve-request"] = (id, request3) => {
                  onRequest(request3.args);
                  sendResponse(id, {});
                };
              }
              resolve(response2);
            });
          }),
          cancel: () => new Promise((resolve) => {
            if (didDispose)
              return resolve();
            const request22 = {
              command: "cancel",
              key: buildKey
            };
            sendRequest(refs, request22, () => {
              resolve();
            });
          }),
          dispose: () => new Promise((resolve) => {
            if (didDispose)
              return resolve();
            didDispose = true;
            const request22 = {
              command: "dispose",
              key: buildKey
            };
            sendRequest(refs, request22, () => {
              resolve();
              scheduleOnDisposeCallbacks();
              refs.unref();
            });
          })
        };
        refs.ref();
        callback(null, result);
      });
    }
  }
  var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
    let onStartCallbacks = [];
    let onEndCallbacks = [];
    let onResolveCallbacks = {};
    let onLoadCallbacks = {};
    let onDisposeCallbacks = [];
    let nextCallbackID = 0;
    let i = 0;
    let requestPlugins = [];
    let isSetupDone = false;
    plugins = [...plugins];
    for (let item of plugins) {
      let keys = {};
      if (typeof item !== "object")
        throw new Error(`Plugin at index ${i} must be an object`);
      const name3 = getFlag(item, keys, "name", mustBeString);
      if (typeof name3 !== "string" || name3 === "")
        throw new Error(`Plugin at index ${i} is missing a name`);
      try {
        let setup = getFlag(item, keys, "setup", mustBeFunction);
        if (typeof setup !== "function")
          throw new Error(`Plugin is missing a setup function`);
        checkForInvalidFlags(item, keys, `on plugin ${quote(name3)}`);
        let plugin = {
          name: name3,
          onStart: false,
          onEnd: false,
          onResolve: [],
          onLoad: []
        };
        i++;
        let resolve = (path3, options3 = {}) => {
          if (!isSetupDone)
            throw new Error('Cannot call "resolve" before plugin setup has completed');
          if (typeof path3 !== "string")
            throw new Error(`The path to resolve must be a string`);
          let keys2 = /* @__PURE__ */ Object.create(null);
          let pluginName = getFlag(options3, keys2, "pluginName", mustBeString);
          let importer = getFlag(options3, keys2, "importer", mustBeString);
          let namespace = getFlag(options3, keys2, "namespace", mustBeString);
          let resolveDir = getFlag(options3, keys2, "resolveDir", mustBeString);
          let kind = getFlag(options3, keys2, "kind", mustBeString);
          let pluginData = getFlag(options3, keys2, "pluginData", canBeAnything);
          let importAttributes = getFlag(options3, keys2, "with", mustBeObject);
          checkForInvalidFlags(options3, keys2, "in resolve() call");
          return new Promise((resolve2, reject) => {
            const request2 = {
              command: "resolve",
              path: path3,
              key: buildKey,
              pluginName: name3
            };
            if (pluginName != null)
              request2.pluginName = pluginName;
            if (importer != null)
              request2.importer = importer;
            if (namespace != null)
              request2.namespace = namespace;
            if (resolveDir != null)
              request2.resolveDir = resolveDir;
            if (kind != null)
              request2.kind = kind;
            else
              throw new Error(`Must specify "kind" when calling "resolve"`);
            if (pluginData != null)
              request2.pluginData = details.store(pluginData);
            if (importAttributes != null)
              request2.with = sanitizeStringMap(importAttributes, "with");
            sendRequest(refs, request2, (error, response) => {
              if (error !== null)
                reject(new Error(error));
              else
                resolve2({
                  errors: replaceDetailsInMessages(response.errors, details),
                  warnings: replaceDetailsInMessages(response.warnings, details),
                  path: response.path,
                  external: response.external,
                  sideEffects: response.sideEffects,
                  namespace: response.namespace,
                  suffix: response.suffix,
                  pluginData: details.load(response.pluginData)
                });
            });
          });
        };
        let promise = setup({
          initialOptions,
          resolve,
          onStart(callback) {
            let registeredText = `This error came from the "onStart" callback registered here:`;
            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
            onStartCallbacks.push({ name: name3, callback, note: registeredNote });
            plugin.onStart = true;
          },
          onEnd(callback) {
            let registeredText = `This error came from the "onEnd" callback registered here:`;
            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
            onEndCallbacks.push({ name: name3, callback, note: registeredNote });
            plugin.onEnd = true;
          },
          onResolve(options3, callback) {
            let registeredText = `This error came from the "onResolve" callback registered here:`;
            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
            let keys2 = {};
            let filter = getFlag(options3, keys2, "filter", mustBeRegExp);
            let namespace = getFlag(options3, keys2, "namespace", mustBeString);
            checkForInvalidFlags(options3, keys2, `in onResolve() call for plugin ${quote(name3)}`);
            if (filter == null)
              throw new Error(`onResolve() call is missing a filter`);
            let id = nextCallbackID++;
            onResolveCallbacks[id] = { name: name3, callback, note: registeredNote };
            plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || "" });
          },
          onLoad(options3, callback) {
            let registeredText = `This error came from the "onLoad" callback registered here:`;
            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
            let keys2 = {};
            let filter = getFlag(options3, keys2, "filter", mustBeRegExp);
            let namespace = getFlag(options3, keys2, "namespace", mustBeString);
            checkForInvalidFlags(options3, keys2, `in onLoad() call for plugin ${quote(name3)}`);
            if (filter == null)
              throw new Error(`onLoad() call is missing a filter`);
            let id = nextCallbackID++;
            onLoadCallbacks[id] = { name: name3, callback, note: registeredNote };
            plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || "" });
          },
          onDispose(callback) {
            onDisposeCallbacks.push(callback);
          },
          esbuild: streamIn.esbuild
        });
        if (promise)
          await promise;
        requestPlugins.push(plugin);
      } catch (e2) {
        return { ok: false, error: e2, pluginName: name3 };
      }
    }
    requestCallbacks["on-start"] = async (id, request2) => {
      details.clear();
      let response = { errors: [], warnings: [] };
      await Promise.all(onStartCallbacks.map(async ({ name: name3, callback, note }) => {
        try {
          let result = await callback();
          if (result != null) {
            if (typeof result !== "object")
              throw new Error(`Expected onStart() callback in plugin ${quote(name3)} to return an object`);
            let keys = {};
            let errors2 = getFlag(result, keys, "errors", mustBeArray);
            let warnings = getFlag(result, keys, "warnings", mustBeArray);
            checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name3)}`);
            if (errors2 != null)
              response.errors.push(...sanitizeMessages(errors2, "errors", details, name3, undefined));
            if (warnings != null)
              response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name3, undefined));
          }
        } catch (e2) {
          response.errors.push(extractErrorMessageV8(e2, streamIn, details, note && note(), name3));
        }
      }));
      sendResponse(id, response);
    };
    requestCallbacks["on-resolve"] = async (id, request2) => {
      let response = {}, name3 = "", callback, note;
      for (let id2 of request2.ids) {
        try {
          ({ name: name3, callback, note } = onResolveCallbacks[id2]);
          let result = await callback({
            path: request2.path,
            importer: request2.importer,
            namespace: request2.namespace,
            resolveDir: request2.resolveDir,
            kind: request2.kind,
            pluginData: details.load(request2.pluginData),
            with: request2.with
          });
          if (result != null) {
            if (typeof result !== "object")
              throw new Error(`Expected onResolve() callback in plugin ${quote(name3)} to return an object`);
            let keys = {};
            let pluginName = getFlag(result, keys, "pluginName", mustBeString);
            let path3 = getFlag(result, keys, "path", mustBeString);
            let namespace = getFlag(result, keys, "namespace", mustBeString);
            let suffix = getFlag(result, keys, "suffix", mustBeString);
            let external = getFlag(result, keys, "external", mustBeBoolean);
            let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
            let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
            let errors2 = getFlag(result, keys, "errors", mustBeArray);
            let warnings = getFlag(result, keys, "warnings", mustBeArray);
            let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
            let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
            checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name3)}`);
            response.id = id2;
            if (pluginName != null)
              response.pluginName = pluginName;
            if (path3 != null)
              response.path = path3;
            if (namespace != null)
              response.namespace = namespace;
            if (suffix != null)
              response.suffix = suffix;
            if (external != null)
              response.external = external;
            if (sideEffects != null)
              response.sideEffects = sideEffects;
            if (pluginData != null)
              response.pluginData = details.store(pluginData);
            if (errors2 != null)
              response.errors = sanitizeMessages(errors2, "errors", details, name3, undefined);
            if (warnings != null)
              response.warnings = sanitizeMessages(warnings, "warnings", details, name3, undefined);
            if (watchFiles != null)
              response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
            if (watchDirs != null)
              response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
            break;
          }
        } catch (e2) {
          response = { id: id2, errors: [extractErrorMessageV8(e2, streamIn, details, note && note(), name3)] };
          break;
        }
      }
      sendResponse(id, response);
    };
    requestCallbacks["on-load"] = async (id, request2) => {
      let response = {}, name3 = "", callback, note;
      for (let id2 of request2.ids) {
        try {
          ({ name: name3, callback, note } = onLoadCallbacks[id2]);
          let result = await callback({
            path: request2.path,
            namespace: request2.namespace,
            suffix: request2.suffix,
            pluginData: details.load(request2.pluginData),
            with: request2.with
          });
          if (result != null) {
            if (typeof result !== "object")
              throw new Error(`Expected onLoad() callback in plugin ${quote(name3)} to return an object`);
            let keys = {};
            let pluginName = getFlag(result, keys, "pluginName", mustBeString);
            let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
            let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
            let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
            let loader = getFlag(result, keys, "loader", mustBeString);
            let errors2 = getFlag(result, keys, "errors", mustBeArray);
            let warnings = getFlag(result, keys, "warnings", mustBeArray);
            let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
            let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
            checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name3)}`);
            response.id = id2;
            if (pluginName != null)
              response.pluginName = pluginName;
            if (contents instanceof Uint8Array)
              response.contents = contents;
            else if (contents != null)
              response.contents = encodeUTF8(contents);
            if (resolveDir != null)
              response.resolveDir = resolveDir;
            if (pluginData != null)
              response.pluginData = details.store(pluginData);
            if (loader != null)
              response.loader = loader;
            if (errors2 != null)
              response.errors = sanitizeMessages(errors2, "errors", details, name3, undefined);
            if (warnings != null)
              response.warnings = sanitizeMessages(warnings, "warnings", details, name3, undefined);
            if (watchFiles != null)
              response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
            if (watchDirs != null)
              response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
            break;
          }
        } catch (e2) {
          response = { id: id2, errors: [extractErrorMessageV8(e2, streamIn, details, note && note(), name3)] };
          break;
        }
      }
      sendResponse(id, response);
    };
    let runOnEndCallbacks = (result, done) => done([], []);
    if (onEndCallbacks.length > 0) {
      runOnEndCallbacks = (result, done) => {
        (async () => {
          const onEndErrors = [];
          const onEndWarnings = [];
          for (const { name: name3, callback, note } of onEndCallbacks) {
            let newErrors;
            let newWarnings;
            try {
              const value = await callback(result);
              if (value != null) {
                if (typeof value !== "object")
                  throw new Error(`Expected onEnd() callback in plugin ${quote(name3)} to return an object`);
                let keys = {};
                let errors2 = getFlag(value, keys, "errors", mustBeArray);
                let warnings = getFlag(value, keys, "warnings", mustBeArray);
                checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name3)}`);
                if (errors2 != null)
                  newErrors = sanitizeMessages(errors2, "errors", details, name3, undefined);
                if (warnings != null)
                  newWarnings = sanitizeMessages(warnings, "warnings", details, name3, undefined);
              }
            } catch (e2) {
              newErrors = [extractErrorMessageV8(e2, streamIn, details, note && note(), name3)];
            }
            if (newErrors) {
              onEndErrors.push(...newErrors);
              try {
                result.errors.push(...newErrors);
              } catch {}
            }
            if (newWarnings) {
              onEndWarnings.push(...newWarnings);
              try {
                result.warnings.push(...newWarnings);
              } catch {}
            }
          }
          done(onEndErrors, onEndWarnings);
        })();
      };
    }
    let scheduleOnDisposeCallbacks = () => {
      for (const cb of onDisposeCallbacks) {
        setTimeout(() => cb(), 0);
      }
    };
    isSetupDone = true;
    return {
      ok: true,
      requestPlugins,
      runOnEndCallbacks,
      scheduleOnDisposeCallbacks
    };
  };
  function createObjectStash() {
    const map2 = /* @__PURE__ */ new Map;
    let nextID = 0;
    return {
      clear() {
        map2.clear();
      },
      load(id) {
        return map2.get(id);
      },
      store(value) {
        if (value === undefined)
          return -1;
        const id = nextID++;
        map2.set(id, value);
        return id;
      }
    };
  }
  function extractCallerV8(e2, streamIn, ident2) {
    let note;
    let tried = false;
    return () => {
      if (tried)
        return note;
      tried = true;
      try {
        let lines = (e2.stack + "").split(`
`);
        lines.splice(1, 1);
        let location = parseStackLinesV8(streamIn, lines, ident2);
        if (location) {
          note = { text: e2.message, location };
          return note;
        }
      } catch {}
    };
  }
  function extractErrorMessageV8(e2, streamIn, stash, note, pluginName) {
    let text = "Internal error";
    let location = null;
    try {
      text = (e2 && e2.message || e2) + "";
    } catch {}
    try {
      location = parseStackLinesV8(streamIn, (e2.stack + "").split(`
`), "");
    } catch {}
    return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e2) : -1 };
  }
  function parseStackLinesV8(streamIn, lines, ident2) {
    let at2 = "    at ";
    if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
      for (let i = 1;i < lines.length; i++) {
        let line = lines[i];
        if (!line.startsWith(at2))
          continue;
        line = line.slice(at2.length);
        while (true) {
          let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
          if (match) {
            line = match[1];
            continue;
          }
          match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
          if (match) {
            line = match[1];
            continue;
          }
          match = /^(\S+):(\d+):(\d+)$/.exec(line);
          if (match) {
            let contents;
            try {
              contents = streamIn.readFileSync(match[1], "utf8");
            } catch {
              break;
            }
            let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
            let column = +match[3] - 1;
            let length = lineText.slice(column, column + ident2.length) === ident2 ? ident2.length : 0;
            return {
              file: match[1],
              namespace: "file",
              line: +match[2],
              column: encodeUTF8(lineText.slice(0, column)).length,
              length: encodeUTF8(lineText.slice(column, column + length)).length,
              lineText: lineText + `
` + lines.slice(1).join(`
`),
              suggestion: ""
            };
          }
          break;
        }
      }
    }
    return null;
  }
  function failureErrorWithLog(text, errors2, warnings) {
    let limit = 5;
    text += errors2.length < 1 ? "" : ` with ${errors2.length} error${errors2.length < 2 ? "" : "s"}:` + errors2.slice(0, limit + 1).map((e2, i) => {
      if (i === limit)
        return `
...`;
      if (!e2.location)
        return `
error: ${e2.text}`;
      let { file, line, column } = e2.location;
      let pluginText = e2.pluginName ? `[plugin: ${e2.pluginName}] ` : "";
      return `
${file}:${line}:${column}: ERROR: ${pluginText}${e2.text}`;
    }).join("");
    let error = new Error(text);
    for (const [key, value] of [["errors", errors2], ["warnings", warnings]]) {
      Object.defineProperty(error, key, {
        configurable: true,
        enumerable: true,
        get: () => value,
        set: (value2) => Object.defineProperty(error, key, {
          configurable: true,
          enumerable: true,
          value: value2
        })
      });
    }
    return error;
  }
  function replaceDetailsInMessages(messages, stash) {
    for (const message of messages) {
      message.detail = stash.load(message.detail);
    }
    return messages;
  }
  function sanitizeLocation(location, where, terminalWidth) {
    if (location == null)
      return null;
    let keys = {};
    let file = getFlag(location, keys, "file", mustBeString);
    let namespace = getFlag(location, keys, "namespace", mustBeString);
    let line = getFlag(location, keys, "line", mustBeInteger);
    let column = getFlag(location, keys, "column", mustBeInteger);
    let length = getFlag(location, keys, "length", mustBeInteger);
    let lineText = getFlag(location, keys, "lineText", mustBeString);
    let suggestion = getFlag(location, keys, "suggestion", mustBeString);
    checkForInvalidFlags(location, keys, where);
    if (lineText) {
      const relevantASCII = lineText.slice(0, (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80));
      if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
        lineText = relevantASCII;
      }
    }
    return {
      file: file || "",
      namespace: namespace || "",
      line: line || 0,
      column: column || 0,
      length: length || 0,
      lineText: lineText || "",
      suggestion: suggestion || ""
    };
  }
  function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
    let messagesClone = [];
    let index = 0;
    for (const message of messages) {
      let keys = {};
      let id = getFlag(message, keys, "id", mustBeString);
      let pluginName = getFlag(message, keys, "pluginName", mustBeString);
      let text = getFlag(message, keys, "text", mustBeString);
      let location = getFlag(message, keys, "location", mustBeObjectOrNull);
      let notes = getFlag(message, keys, "notes", mustBeArray);
      let detail = getFlag(message, keys, "detail", canBeAnything);
      let where = `in element ${index} of "${property}"`;
      checkForInvalidFlags(message, keys, where);
      let notesClone = [];
      if (notes) {
        for (const note of notes) {
          let noteKeys = {};
          let noteText = getFlag(note, noteKeys, "text", mustBeString);
          let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
          checkForInvalidFlags(note, noteKeys, where);
          notesClone.push({
            text: noteText || "",
            location: sanitizeLocation(noteLocation, where, terminalWidth)
          });
        }
      }
      messagesClone.push({
        id: id || "",
        pluginName: pluginName || fallbackPluginName,
        text: text || "",
        location: sanitizeLocation(location, where, terminalWidth),
        notes: notesClone,
        detail: stash ? stash.store(detail) : -1
      });
      index++;
    }
    return messagesClone;
  }
  function sanitizeStringArray(values, property) {
    const result = [];
    for (const value of values) {
      if (typeof value !== "string")
        throw new Error(`${quote(property)} must be an array of strings`);
      result.push(value);
    }
    return result;
  }
  function sanitizeStringMap(map2, property) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key in map2) {
      const value = map2[key];
      if (typeof value !== "string")
        throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
      result[key] = value;
    }
    return result;
  }
  function convertOutputFiles({ path: path3, contents, hash }) {
    let text = null;
    return {
      path: path3,
      contents,
      hash,
      get text() {
        const binary = this.contents;
        if (text === null || binary !== contents) {
          contents = binary;
          text = decodeUTF8(binary);
        }
        return text;
      }
    };
  }
  var fs = __require("fs");
  var os = __require("os");
  var path = __require("path");
  var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
  var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
  var packageDarwin_arm64 = "@esbuild/darwin-arm64";
  var packageDarwin_x64 = "@esbuild/darwin-x64";
  var knownWindowsPackages = {
    "win32 arm64 LE": "@esbuild/win32-arm64",
    "win32 ia32 LE": "@esbuild/win32-ia32",
    "win32 x64 LE": "@esbuild/win32-x64"
  };
  var knownUnixlikePackages = {
    "aix ppc64 BE": "@esbuild/aix-ppc64",
    "android arm64 LE": "@esbuild/android-arm64",
    "darwin arm64 LE": "@esbuild/darwin-arm64",
    "darwin x64 LE": "@esbuild/darwin-x64",
    "freebsd arm64 LE": "@esbuild/freebsd-arm64",
    "freebsd x64 LE": "@esbuild/freebsd-x64",
    "linux arm LE": "@esbuild/linux-arm",
    "linux arm64 LE": "@esbuild/linux-arm64",
    "linux ia32 LE": "@esbuild/linux-ia32",
    "linux mips64el LE": "@esbuild/linux-mips64el",
    "linux ppc64 LE": "@esbuild/linux-ppc64",
    "linux riscv64 LE": "@esbuild/linux-riscv64",
    "linux s390x BE": "@esbuild/linux-s390x",
    "linux x64 LE": "@esbuild/linux-x64",
    "linux loong64 LE": "@esbuild/linux-loong64",
    "netbsd x64 LE": "@esbuild/netbsd-x64",
    "openbsd arm64 LE": "@esbuild/openbsd-arm64",
    "openbsd x64 LE": "@esbuild/openbsd-x64",
    "sunos x64 LE": "@esbuild/sunos-x64"
  };
  var knownWebAssemblyFallbackPackages = {
    "android arm LE": "@esbuild/android-arm",
    "android x64 LE": "@esbuild/android-x64"
  };
  function pkgAndSubpathForCurrentPlatform() {
    let pkg;
    let subpath;
    let isWASM = false;
    let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
    if (platformKey in knownWindowsPackages) {
      pkg = knownWindowsPackages[platformKey];
      subpath = "esbuild.exe";
    } else if (platformKey in knownUnixlikePackages) {
      pkg = knownUnixlikePackages[platformKey];
      subpath = "bin/esbuild";
    } else if (platformKey in knownWebAssemblyFallbackPackages) {
      pkg = knownWebAssemblyFallbackPackages[platformKey];
      subpath = "bin/esbuild";
      isWASM = true;
    } else {
      throw new Error(`Unsupported platform: ${platformKey}`);
    }
    return { pkg, subpath, isWASM };
  }
  function pkgForSomeOtherPlatform() {
    const libMainJS = __require.resolve("esbuild");
    const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
    if (path.basename(nodeModulesDirectory) === "node_modules") {
      for (const unixKey in knownUnixlikePackages) {
        try {
          const pkg = knownUnixlikePackages[unixKey];
          if (fs.existsSync(path.join(nodeModulesDirectory, pkg)))
            return pkg;
        } catch {}
      }
      for (const windowsKey in knownWindowsPackages) {
        try {
          const pkg = knownWindowsPackages[windowsKey];
          if (fs.existsSync(path.join(nodeModulesDirectory, pkg)))
            return pkg;
        } catch {}
      }
    }
    return null;
  }
  function downloadedBinPath(pkg, subpath) {
    const esbuildLibDir = path.dirname(__require.resolve("esbuild"));
    return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
  }
  function generateBinPath() {
    if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
      if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
        console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
      } else {
        return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
      }
    }
    const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
    let binPath;
    try {
      binPath = __require.resolve(`${pkg}/${subpath}`);
    } catch (e2) {
      binPath = downloadedBinPath(pkg, subpath);
      if (!fs.existsSync(binPath)) {
        try {
          __require.resolve(pkg);
        } catch {
          const otherPkg = pkgForSomeOtherPlatform();
          if (otherPkg) {
            let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
            if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
              suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
            }
            throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
          }
          throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
        }
        throw e2;
      }
    }
    if (/\.zip\//.test(binPath)) {
      let pnpapi;
      try {
        pnpapi = (()=>{throw new Error("Cannot require module "+"pnpapi");})();
      } catch (e2) {}
      if (pnpapi) {
        const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
        const binTargetPath = path.join(root, "node_modules", ".cache", "esbuild", `pnpapi-${pkg.replace("/", "-")}-${"0.23.1"}-${path.basename(subpath)}`);
        if (!fs.existsSync(binTargetPath)) {
          fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
          fs.copyFileSync(binPath, binTargetPath);
          fs.chmodSync(binTargetPath, 493);
        }
        return { binPath: binTargetPath, isWASM };
      }
    }
    return { binPath, isWASM };
  }
  var child_process = __require("child_process");
  var crypto2 = __require("crypto");
  var path2 = __require("path");
  var fs2 = __require("fs");
  var os2 = __require("os");
  var tty = __require("tty");
  var worker_threads;
  if (process.env.ESBUILD_WORKER_THREADS !== "0") {
    try {
      worker_threads = __require("worker_threads");
    } catch {}
    let [major, minor] = process.versions.node.split(".");
    if (+major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
      worker_threads = undefined;
    }
  }
  var _a3;
  var isInternalWorkerThread = ((_a3 = worker_threads == null ? undefined : worker_threads.workerData) == null ? undefined : _a3.esbuildVersion) === "0.23.1";
  var esbuildCommandAndArgs = () => {
    if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
      throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`);
    }
    if (false) {} else {
      const { binPath, isWASM } = generateBinPath();
      if (isWASM) {
        return ["node", [binPath]];
      } else {
        return [binPath, []];
      }
    }
  };
  var isTTY = () => tty.isatty(2);
  var fsSync = {
    readFile(tempFile, callback) {
      try {
        let contents = fs2.readFileSync(tempFile, "utf8");
        try {
          fs2.unlinkSync(tempFile);
        } catch {}
        callback(null, contents);
      } catch (err) {
        callback(err, null);
      }
    },
    writeFile(contents, callback) {
      try {
        let tempFile = randomFileName();
        fs2.writeFileSync(tempFile, contents);
        callback(tempFile);
      } catch {
        callback(null);
      }
    }
  };
  var fsAsync = {
    readFile(tempFile, callback) {
      try {
        fs2.readFile(tempFile, "utf8", (err, contents) => {
          try {
            fs2.unlink(tempFile, () => callback(err, contents));
          } catch {
            callback(err, contents);
          }
        });
      } catch (err) {
        callback(err, null);
      }
    },
    writeFile(contents, callback) {
      try {
        let tempFile = randomFileName();
        fs2.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
      } catch {
        callback(null);
      }
    }
  };
  var version = "0.23.1";
  var build = (options3) => ensureServiceIsRunning().build(options3);
  var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
  var transform = (input, options3) => ensureServiceIsRunning().transform(input, options3);
  var formatMessages = (messages, options3) => ensureServiceIsRunning().formatMessages(messages, options3);
  var analyzeMetafile = (messages, options3) => ensureServiceIsRunning().analyzeMetafile(messages, options3);
  var buildSync = (options3) => {
    if (worker_threads && !isInternalWorkerThread) {
      if (!workerThreadService)
        workerThreadService = startWorkerThreadService(worker_threads);
      return workerThreadService.buildSync(options3);
    }
    let result;
    runServiceSync((service) => service.buildOrContext({
      callName: "buildSync",
      refs: null,
      options: options3,
      isTTY: isTTY(),
      defaultWD,
      callback: (err, res) => {
        if (err)
          throw err;
        result = res;
      }
    }));
    return result;
  };
  var transformSync = (input, options3) => {
    if (worker_threads && !isInternalWorkerThread) {
      if (!workerThreadService)
        workerThreadService = startWorkerThreadService(worker_threads);
      return workerThreadService.transformSync(input, options3);
    }
    let result;
    runServiceSync((service) => service.transform({
      callName: "transformSync",
      refs: null,
      input,
      options: options3 || {},
      isTTY: isTTY(),
      fs: fsSync,
      callback: (err, res) => {
        if (err)
          throw err;
        result = res;
      }
    }));
    return result;
  };
  var formatMessagesSync = (messages, options3) => {
    if (worker_threads && !isInternalWorkerThread) {
      if (!workerThreadService)
        workerThreadService = startWorkerThreadService(worker_threads);
      return workerThreadService.formatMessagesSync(messages, options3);
    }
    let result;
    runServiceSync((service) => service.formatMessages({
      callName: "formatMessagesSync",
      refs: null,
      messages,
      options: options3,
      callback: (err, res) => {
        if (err)
          throw err;
        result = res;
      }
    }));
    return result;
  };
  var analyzeMetafileSync = (metafile, options3) => {
    if (worker_threads && !isInternalWorkerThread) {
      if (!workerThreadService)
        workerThreadService = startWorkerThreadService(worker_threads);
      return workerThreadService.analyzeMetafileSync(metafile, options3);
    }
    let result;
    runServiceSync((service) => service.analyzeMetafile({
      callName: "analyzeMetafileSync",
      refs: null,
      metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
      options: options3,
      callback: (err, res) => {
        if (err)
          throw err;
        result = res;
      }
    }));
    return result;
  };
  var stop = () => {
    if (stopService)
      stopService();
    if (workerThreadService)
      workerThreadService.stop();
    return Promise.resolve();
  };
  var initializeWasCalled = false;
  var initialize = (options3) => {
    options3 = validateInitializeOptions(options3 || {});
    if (options3.wasmURL)
      throw new Error(`The "wasmURL" option only works in the browser`);
    if (options3.wasmModule)
      throw new Error(`The "wasmModule" option only works in the browser`);
    if (options3.worker)
      throw new Error(`The "worker" option only works in the browser`);
    if (initializeWasCalled)
      throw new Error('Cannot call "initialize" more than once');
    ensureServiceIsRunning();
    initializeWasCalled = true;
    return Promise.resolve();
  };
  var defaultWD = process.cwd();
  var longLivedService;
  var stopService;
  var ensureServiceIsRunning = () => {
    if (longLivedService)
      return longLivedService;
    let [command, args] = esbuildCommandAndArgs();
    let child = child_process.spawn(command, args.concat(`--service=${"0.23.1"}`, "--ping"), {
      windowsHide: true,
      stdio: ["pipe", "pipe", "inherit"],
      cwd: defaultWD
    });
    let { readFromStdout, afterClose, service } = createChannel({
      writeToStdin(bytes) {
        child.stdin.write(bytes, (err) => {
          if (err)
            afterClose(err);
        });
      },
      readFileSync: fs2.readFileSync,
      isSync: false,
      hasFS: true,
      esbuild: node_exports
    });
    child.stdin.on("error", afterClose);
    child.on("error", afterClose);
    const stdin = child.stdin;
    const stdout = child.stdout;
    stdout.on("data", readFromStdout);
    stdout.on("end", afterClose);
    stopService = () => {
      stdin.destroy();
      stdout.destroy();
      child.kill();
      initializeWasCalled = false;
      longLivedService = undefined;
      stopService = undefined;
    };
    let refCount = 0;
    child.unref();
    if (stdin.unref) {
      stdin.unref();
    }
    if (stdout.unref) {
      stdout.unref();
    }
    const refs = {
      ref() {
        if (++refCount === 1)
          child.ref();
      },
      unref() {
        if (--refCount === 0)
          child.unref();
      }
    };
    longLivedService = {
      build: (options3) => new Promise((resolve, reject) => {
        service.buildOrContext({
          callName: "build",
          refs,
          options: options3,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve(res)
        });
      }),
      context: (options3) => new Promise((resolve, reject) => service.buildOrContext({
        callName: "context",
        refs,
        options: options3,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => err ? reject(err) : resolve(res)
      })),
      transform: (input, options3) => new Promise((resolve, reject) => service.transform({
        callName: "transform",
        refs,
        input,
        options: options3 || {},
        isTTY: isTTY(),
        fs: fsAsync,
        callback: (err, res) => err ? reject(err) : resolve(res)
      })),
      formatMessages: (messages, options3) => new Promise((resolve, reject) => service.formatMessages({
        callName: "formatMessages",
        refs,
        messages,
        options: options3,
        callback: (err, res) => err ? reject(err) : resolve(res)
      })),
      analyzeMetafile: (metafile, options3) => new Promise((resolve, reject) => service.analyzeMetafile({
        callName: "analyzeMetafile",
        refs,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options3,
        callback: (err, res) => err ? reject(err) : resolve(res)
      }))
    };
    return longLivedService;
  };
  var runServiceSync = (callback) => {
    let [command, args] = esbuildCommandAndArgs();
    let stdin = new Uint8Array;
    let { readFromStdout, afterClose, service } = createChannel({
      writeToStdin(bytes) {
        if (stdin.length !== 0)
          throw new Error("Must run at most one command");
        stdin = bytes;
      },
      isSync: true,
      hasFS: true,
      esbuild: node_exports
    });
    callback(service);
    let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.23.1"}`), {
      cwd: defaultWD,
      windowsHide: true,
      input: stdin,
      maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
    });
    readFromStdout(stdout);
    afterClose(null);
  };
  var randomFileName = () => {
    return path2.join(os2.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
  };
  var workerThreadService = null;
  var startWorkerThreadService = (worker_threads2) => {
    let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel;
    let worker = new worker_threads2.Worker(__filename, {
      workerData: { workerPort, defaultWD, esbuildVersion: "0.23.1" },
      transferList: [workerPort],
      execArgv: []
    });
    let nextID = 0;
    let fakeBuildError = (text) => {
      let error = new Error(`Build failed with 1 error:
error: ${text}`);
      let errors2 = [{ id: "", pluginName: "", text, location: null, notes: [], detail: undefined }];
      error.errors = errors2;
      error.warnings = [];
      return error;
    };
    let validateBuildSyncOptions = (options3) => {
      if (!options3)
        return;
      let plugins = options3.plugins;
      if (plugins && plugins.length > 0)
        throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
    };
    let applyProperties = (object, properties) => {
      for (let key in properties) {
        object[key] = properties[key];
      }
    };
    let runCallSync = (command, args) => {
      let id = nextID++;
      let sharedBuffer = new SharedArrayBuffer(8);
      let sharedBufferView = new Int32Array(sharedBuffer);
      let msg = { sharedBuffer, id, command, args };
      worker.postMessage(msg);
      let status = Atomics.wait(sharedBufferView, 0, 0);
      if (status !== "ok" && status !== "not-equal")
        throw new Error("Internal error: Atomics.wait() failed: " + status);
      let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
      if (id !== id2)
        throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
      if (reject) {
        applyProperties(reject, properties);
        throw reject;
      }
      return resolve;
    };
    worker.unref();
    return {
      buildSync(options3) {
        validateBuildSyncOptions(options3);
        return runCallSync("build", [options3]);
      },
      transformSync(input, options3) {
        return runCallSync("transform", [input, options3]);
      },
      formatMessagesSync(messages, options3) {
        return runCallSync("formatMessages", [messages, options3]);
      },
      analyzeMetafileSync(metafile, options3) {
        return runCallSync("analyzeMetafile", [metafile, options3]);
      },
      stop() {
        worker.terminate();
        workerThreadService = null;
      }
    };
  };
  var startSyncServiceWorker = () => {
    let workerPort = worker_threads.workerData.workerPort;
    let parentPort = worker_threads.parentPort;
    let extractProperties = (object) => {
      let properties = {};
      if (object && typeof object === "object") {
        for (let key in object) {
          properties[key] = object[key];
        }
      }
      return properties;
    };
    try {
      let service = ensureServiceIsRunning();
      defaultWD = worker_threads.workerData.defaultWD;
      parentPort.on("message", (msg) => {
        (async () => {
          let { sharedBuffer, id, command, args } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          try {
            switch (command) {
              case "build":
                workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                break;
              case "transform":
                workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                break;
              case "formatMessages":
                workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                break;
              case "analyzeMetafile":
                workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                break;
              default:
                throw new Error(`Invalid command: ${command}`);
            }
          } catch (reject) {
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          }
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        })();
      });
    } catch (reject) {
      parentPort.on("message", (msg) => {
        let { sharedBuffer, id } = msg;
        let sharedBufferView = new Int32Array(sharedBuffer);
        workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
        Atomics.add(sharedBufferView, 0, 1);
        Atomics.notify(sharedBufferView, 0, Infinity);
      });
    }
  };
  if (isInternalWorkerThread) {
    startSyncServiceWorker();
  }
  var node_default = node_exports;
});

// ../../../../node_modules/pusher/lib/util.js
var require_util = __commonJS((exports) => {
  var crypto2 = __require("crypto");
  function toOrderedArray(map3) {
    return Object.keys(map3).map(function(key) {
      return [key, map3[key]];
    }).sort(function(a2, b2) {
      if (a2[0] < b2[0]) {
        return -1;
      }
      if (a2[0] > b2[0]) {
        return 1;
      }
      return 0;
    }).map(function(pair) {
      return pair[0] + "=" + pair[1];
    });
  }
  function getMD5(body) {
    return crypto2.createHash("md5").update(body, "utf8").digest("hex");
  }
  function secureCompare(a2, b2) {
    if (a2.length !== b2.length) {
      return false;
    }
    let result2 = 0;
    for (const i2 in a2) {
      result2 |= a2.charCodeAt(i2) ^ b2.charCodeAt(i2);
    }
    return result2 === 0;
  }
  function isEncryptedChannel(channel) {
    return channel.startsWith("private-encrypted-");
  }
  exports.toOrderedArray = toOrderedArray;
  exports.getMD5 = getMD5;
  exports.secureCompare = secureCompare;
  exports.isEncryptedChannel = isEncryptedChannel;
});

// ../../../../node_modules/pusher/lib/auth.js
var require_auth = __commonJS((exports) => {
  var util2 = require_util();
  function getSocketSignatureForUser(token2, socketId, userData) {
    const serializedUserData = JSON.stringify(userData);
    const signature = token2.sign(`${socketId}::user::${serializedUserData}`);
    return {
      auth: `${token2.key}:${signature}`,
      user_data: serializedUserData
    };
  }
  function getSocketSignature(pusher, token2, channel, socketID, data) {
    const result2 = {};
    const signatureData = [socketID, channel];
    if (data) {
      const serializedData = JSON.stringify(data);
      signatureData.push(serializedData);
      result2.channel_data = serializedData;
    }
    result2.auth = token2.key + ":" + token2.sign(signatureData.join(":"));
    if (util2.isEncryptedChannel(channel)) {
      if (pusher.config.encryptionMasterKey === undefined) {
        throw new Error("Cannot generate shared_secret because encryptionMasterKey is not set");
      }
      result2.shared_secret = Buffer.from(pusher.channelSharedSecret(channel)).toString("base64");
    }
    return result2;
  }
  exports.getSocketSignatureForUser = getSocketSignatureForUser;
  exports.getSocketSignature = getSocketSignature;
});

// ../../../../node_modules/pusher/lib/errors.js
var require_errors = __commonJS((exports) => {
  function RequestError(message, url, error2, status, body) {
    this.name = "PusherRequestError";
    this.stack = new Error().stack;
    this.message = message;
    this.url = url;
    this.error = error2;
    this.status = status;
    this.body = body;
  }
  RequestError.prototype = new Error;
  function WebHookError(message, contentType, body, signature) {
    this.name = "PusherWebHookError";
    this.stack = new Error().stack;
    this.message = message;
    this.contentType = contentType;
    this.body = body;
    this.signature = signature;
  }
  WebHookError.prototype = new Error;
  exports.RequestError = RequestError;
  exports.WebHookError = WebHookError;
});

// ../../../../node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports, module) => {
  (function(nacl) {
    var gf = function(init2) {
      var i2, r4 = new Float64Array(16);
      if (init2)
        for (i2 = 0;i2 < init2.length; i2++)
          r4[i2] = init2[i2];
      return r4;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i2, h8, l3) {
      x2[i2] = h8 >> 24 & 255;
      x2[i2 + 1] = h8 >> 16 & 255;
      x2[i2 + 2] = h8 >> 8 & 255;
      x2[i2 + 3] = h8 & 255;
      x2[i2 + 4] = l3 >> 24 & 255;
      x2[i2 + 5] = l3 >> 16 & 255;
      x2[i2 + 6] = l3 >> 8 & 255;
      x2[i2 + 7] = l3 & 255;
    }
    function vn2(x2, xi2, y, yi, n4) {
      var i2, d2 = 0;
      for (i2 = 0;i2 < n4; i2++)
        d2 |= x2[xi2 + i2] ^ y[yi + i2];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi2, y, yi) {
      return vn2(x2, xi2, y, yi, 16);
    }
    function crypto_verify_32(x2, xi2, y, yi) {
      return vn2(x2, xi2, y, yi, 32);
    }
    function core_salsa20(o3, p3, k3, c4) {
      var j02 = c4[0] & 255 | (c4[1] & 255) << 8 | (c4[2] & 255) << 16 | (c4[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j2 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c4[4] & 255 | (c4[5] & 255) << 8 | (c4[6] & 255) << 16 | (c4[7] & 255) << 24, j6 = p3[0] & 255 | (p3[1] & 255) << 8 | (p3[2] & 255) << 16 | (p3[3] & 255) << 24, j7 = p3[4] & 255 | (p3[5] & 255) << 8 | (p3[6] & 255) << 16 | (p3[7] & 255) << 24, j8 = p3[8] & 255 | (p3[9] & 255) << 8 | (p3[10] & 255) << 16 | (p3[11] & 255) << 24, j9 = p3[12] & 255 | (p3[13] & 255) << 8 | (p3[14] & 255) << 16 | (p3[15] & 255) << 24, j10 = c4[8] & 255 | (c4[9] & 255) << 8 | (c4[10] & 255) << 16 | (c4[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c4[12] & 255 | (c4[13] & 255) << 8 | (c4[14] & 255) << 16 | (c4[15] & 255) << 24;
      var x0 = j02, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i2 = 0;i2 < 20; i2 += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      x0 = x0 + j02 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o3[0] = x0 >>> 0 & 255;
      o3[1] = x0 >>> 8 & 255;
      o3[2] = x0 >>> 16 & 255;
      o3[3] = x0 >>> 24 & 255;
      o3[4] = x1 >>> 0 & 255;
      o3[5] = x1 >>> 8 & 255;
      o3[6] = x1 >>> 16 & 255;
      o3[7] = x1 >>> 24 & 255;
      o3[8] = x2 >>> 0 & 255;
      o3[9] = x2 >>> 8 & 255;
      o3[10] = x2 >>> 16 & 255;
      o3[11] = x2 >>> 24 & 255;
      o3[12] = x3 >>> 0 & 255;
      o3[13] = x3 >>> 8 & 255;
      o3[14] = x3 >>> 16 & 255;
      o3[15] = x3 >>> 24 & 255;
      o3[16] = x4 >>> 0 & 255;
      o3[17] = x4 >>> 8 & 255;
      o3[18] = x4 >>> 16 & 255;
      o3[19] = x4 >>> 24 & 255;
      o3[20] = x5 >>> 0 & 255;
      o3[21] = x5 >>> 8 & 255;
      o3[22] = x5 >>> 16 & 255;
      o3[23] = x5 >>> 24 & 255;
      o3[24] = x6 >>> 0 & 255;
      o3[25] = x6 >>> 8 & 255;
      o3[26] = x6 >>> 16 & 255;
      o3[27] = x6 >>> 24 & 255;
      o3[28] = x7 >>> 0 & 255;
      o3[29] = x7 >>> 8 & 255;
      o3[30] = x7 >>> 16 & 255;
      o3[31] = x7 >>> 24 & 255;
      o3[32] = x8 >>> 0 & 255;
      o3[33] = x8 >>> 8 & 255;
      o3[34] = x8 >>> 16 & 255;
      o3[35] = x8 >>> 24 & 255;
      o3[36] = x9 >>> 0 & 255;
      o3[37] = x9 >>> 8 & 255;
      o3[38] = x9 >>> 16 & 255;
      o3[39] = x9 >>> 24 & 255;
      o3[40] = x10 >>> 0 & 255;
      o3[41] = x10 >>> 8 & 255;
      o3[42] = x10 >>> 16 & 255;
      o3[43] = x10 >>> 24 & 255;
      o3[44] = x11 >>> 0 & 255;
      o3[45] = x11 >>> 8 & 255;
      o3[46] = x11 >>> 16 & 255;
      o3[47] = x11 >>> 24 & 255;
      o3[48] = x12 >>> 0 & 255;
      o3[49] = x12 >>> 8 & 255;
      o3[50] = x12 >>> 16 & 255;
      o3[51] = x12 >>> 24 & 255;
      o3[52] = x13 >>> 0 & 255;
      o3[53] = x13 >>> 8 & 255;
      o3[54] = x13 >>> 16 & 255;
      o3[55] = x13 >>> 24 & 255;
      o3[56] = x14 >>> 0 & 255;
      o3[57] = x14 >>> 8 & 255;
      o3[58] = x14 >>> 16 & 255;
      o3[59] = x14 >>> 24 & 255;
      o3[60] = x15 >>> 0 & 255;
      o3[61] = x15 >>> 8 & 255;
      o3[62] = x15 >>> 16 & 255;
      o3[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o3, p3, k3, c4) {
      var j02 = c4[0] & 255 | (c4[1] & 255) << 8 | (c4[2] & 255) << 16 | (c4[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j2 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c4[4] & 255 | (c4[5] & 255) << 8 | (c4[6] & 255) << 16 | (c4[7] & 255) << 24, j6 = p3[0] & 255 | (p3[1] & 255) << 8 | (p3[2] & 255) << 16 | (p3[3] & 255) << 24, j7 = p3[4] & 255 | (p3[5] & 255) << 8 | (p3[6] & 255) << 16 | (p3[7] & 255) << 24, j8 = p3[8] & 255 | (p3[9] & 255) << 8 | (p3[10] & 255) << 16 | (p3[11] & 255) << 24, j9 = p3[12] & 255 | (p3[13] & 255) << 8 | (p3[14] & 255) << 16 | (p3[15] & 255) << 24, j10 = c4[8] & 255 | (c4[9] & 255) << 8 | (c4[10] & 255) << 16 | (c4[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c4[12] & 255 | (c4[13] & 255) << 8 | (c4[14] & 255) << 16 | (c4[15] & 255) << 24;
      var x0 = j02, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i2 = 0;i2 < 20; i2 += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      o3[0] = x0 >>> 0 & 255;
      o3[1] = x0 >>> 8 & 255;
      o3[2] = x0 >>> 16 & 255;
      o3[3] = x0 >>> 24 & 255;
      o3[4] = x5 >>> 0 & 255;
      o3[5] = x5 >>> 8 & 255;
      o3[6] = x5 >>> 16 & 255;
      o3[7] = x5 >>> 24 & 255;
      o3[8] = x10 >>> 0 & 255;
      o3[9] = x10 >>> 8 & 255;
      o3[10] = x10 >>> 16 & 255;
      o3[11] = x10 >>> 24 & 255;
      o3[12] = x15 >>> 0 & 255;
      o3[13] = x15 >>> 8 & 255;
      o3[14] = x15 >>> 16 & 255;
      o3[15] = x15 >>> 24 & 255;
      o3[16] = x6 >>> 0 & 255;
      o3[17] = x6 >>> 8 & 255;
      o3[18] = x6 >>> 16 & 255;
      o3[19] = x6 >>> 24 & 255;
      o3[20] = x7 >>> 0 & 255;
      o3[21] = x7 >>> 8 & 255;
      o3[22] = x7 >>> 16 & 255;
      o3[23] = x7 >>> 24 & 255;
      o3[24] = x8 >>> 0 & 255;
      o3[25] = x8 >>> 8 & 255;
      o3[26] = x8 >>> 16 & 255;
      o3[27] = x8 >>> 24 & 255;
      o3[28] = x9 >>> 0 & 255;
      o3[29] = x9 >>> 8 & 255;
      o3[30] = x9 >>> 16 & 255;
      o3[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k3, c4) {
      core_salsa20(out, inp, k3, c4);
    }
    function crypto_core_hsalsa20(out, inp, k3, c4) {
      core_hsalsa20(out, inp, k3, c4);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c4, cpos, m3, mpos, b2, n4, k3) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i2;
      for (i2 = 0;i2 < 16; i2++)
        z2[i2] = 0;
      for (i2 = 0;i2 < 8; i2++)
        z2[i2] = n4[i2];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k3, sigma);
        for (i2 = 0;i2 < 64; i2++)
          c4[cpos + i2] = m3[mpos + i2] ^ x2[i2];
        u2 = 1;
        for (i2 = 8;i2 < 16; i2++) {
          u2 = u2 + (z2[i2] & 255) | 0;
          z2[i2] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k3, sigma);
        for (i2 = 0;i2 < b2; i2++)
          c4[cpos + i2] = m3[mpos + i2] ^ x2[i2];
      }
      return 0;
    }
    function crypto_stream_salsa20(c4, cpos, b2, n4, k3) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i2;
      for (i2 = 0;i2 < 16; i2++)
        z2[i2] = 0;
      for (i2 = 0;i2 < 8; i2++)
        z2[i2] = n4[i2];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k3, sigma);
        for (i2 = 0;i2 < 64; i2++)
          c4[cpos + i2] = x2[i2];
        u2 = 1;
        for (i2 = 8;i2 < 16; i2++) {
          u2 = u2 + (z2[i2] & 255) | 0;
          z2[i2] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k3, sigma);
        for (i2 = 0;i2 < b2; i2++)
          c4[cpos + i2] = x2[i2];
      }
      return 0;
    }
    function crypto_stream(c4, cpos, d2, n4, k3) {
      var s3 = new Uint8Array(32);
      crypto_core_hsalsa20(s3, n4, k3, sigma);
      var sn2 = new Uint8Array(8);
      for (var i2 = 0;i2 < 8; i2++)
        sn2[i2] = n4[i2 + 16];
      return crypto_stream_salsa20(c4, cpos, d2, sn2, s3);
    }
    function crypto_stream_xor(c4, cpos, m3, mpos, d2, n4, k3) {
      var s3 = new Uint8Array(32);
      crypto_core_hsalsa20(s3, n4, k3, sigma);
      var sn2 = new Uint8Array(8);
      for (var i2 = 0;i2 < 8; i2++)
        sn2[i2] = n4[i2 + 16];
      return crypto_stream_salsa20_xor(c4, cpos, m3, mpos, d2, sn2, s3);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t22, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t22 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t22 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m3, mpos, bytes2) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t22, t3, t4, t5, t6, t7, c4;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h12 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h52 = this.h[5], h62 = this.h[6], h72 = this.h[7], h8 = this.h[8], h92 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r32 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes2 >= 16) {
        t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
        h12 += (t0 >>> 13 | t1 << 3) & 8191;
        t22 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
        h22 += (t1 >>> 10 | t22 << 6) & 8191;
        t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
        h32 += (t22 >>> 7 | t3 << 9) & 8191;
        t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
        h42 += (t3 >>> 4 | t4 << 12) & 8191;
        h52 += t4 >>> 1 & 8191;
        t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
        h62 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
        h72 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h92 += t7 >>> 5 | hibit;
        c4 = 0;
        d0 = c4;
        d0 += h0 * r0;
        d0 += h12 * (5 * r9);
        d0 += h22 * (5 * r8);
        d0 += h32 * (5 * r7);
        d0 += h42 * (5 * r6);
        c4 = d0 >>> 13;
        d0 &= 8191;
        d0 += h52 * (5 * r5);
        d0 += h62 * (5 * r4);
        d0 += h72 * (5 * r32);
        d0 += h8 * (5 * r22);
        d0 += h92 * (5 * r1);
        c4 += d0 >>> 13;
        d0 &= 8191;
        d1 = c4;
        d1 += h0 * r1;
        d1 += h12 * r0;
        d1 += h22 * (5 * r9);
        d1 += h32 * (5 * r8);
        d1 += h42 * (5 * r7);
        c4 = d1 >>> 13;
        d1 &= 8191;
        d1 += h52 * (5 * r6);
        d1 += h62 * (5 * r5);
        d1 += h72 * (5 * r4);
        d1 += h8 * (5 * r32);
        d1 += h92 * (5 * r22);
        c4 += d1 >>> 13;
        d1 &= 8191;
        d2 = c4;
        d2 += h0 * r22;
        d2 += h12 * r1;
        d2 += h22 * r0;
        d2 += h32 * (5 * r9);
        d2 += h42 * (5 * r8);
        c4 = d2 >>> 13;
        d2 &= 8191;
        d2 += h52 * (5 * r7);
        d2 += h62 * (5 * r6);
        d2 += h72 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h92 * (5 * r32);
        c4 += d2 >>> 13;
        d2 &= 8191;
        d3 = c4;
        d3 += h0 * r32;
        d3 += h12 * r22;
        d3 += h22 * r1;
        d3 += h32 * r0;
        d3 += h42 * (5 * r9);
        c4 = d3 >>> 13;
        d3 &= 8191;
        d3 += h52 * (5 * r8);
        d3 += h62 * (5 * r7);
        d3 += h72 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h92 * (5 * r4);
        c4 += d3 >>> 13;
        d3 &= 8191;
        d4 = c4;
        d4 += h0 * r4;
        d4 += h12 * r32;
        d4 += h22 * r22;
        d4 += h32 * r1;
        d4 += h42 * r0;
        c4 = d4 >>> 13;
        d4 &= 8191;
        d4 += h52 * (5 * r9);
        d4 += h62 * (5 * r8);
        d4 += h72 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h92 * (5 * r5);
        c4 += d4 >>> 13;
        d4 &= 8191;
        d5 = c4;
        d5 += h0 * r5;
        d5 += h12 * r4;
        d5 += h22 * r32;
        d5 += h32 * r22;
        d5 += h42 * r1;
        c4 = d5 >>> 13;
        d5 &= 8191;
        d5 += h52 * r0;
        d5 += h62 * (5 * r9);
        d5 += h72 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h92 * (5 * r6);
        c4 += d5 >>> 13;
        d5 &= 8191;
        d6 = c4;
        d6 += h0 * r6;
        d6 += h12 * r5;
        d6 += h22 * r4;
        d6 += h32 * r32;
        d6 += h42 * r22;
        c4 = d6 >>> 13;
        d6 &= 8191;
        d6 += h52 * r1;
        d6 += h62 * r0;
        d6 += h72 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h92 * (5 * r7);
        c4 += d6 >>> 13;
        d6 &= 8191;
        d7 = c4;
        d7 += h0 * r7;
        d7 += h12 * r6;
        d7 += h22 * r5;
        d7 += h32 * r4;
        d7 += h42 * r32;
        c4 = d7 >>> 13;
        d7 &= 8191;
        d7 += h52 * r22;
        d7 += h62 * r1;
        d7 += h72 * r0;
        d7 += h8 * (5 * r9);
        d7 += h92 * (5 * r8);
        c4 += d7 >>> 13;
        d7 &= 8191;
        d8 = c4;
        d8 += h0 * r8;
        d8 += h12 * r7;
        d8 += h22 * r6;
        d8 += h32 * r5;
        d8 += h42 * r4;
        c4 = d8 >>> 13;
        d8 &= 8191;
        d8 += h52 * r32;
        d8 += h62 * r22;
        d8 += h72 * r1;
        d8 += h8 * r0;
        d8 += h92 * (5 * r9);
        c4 += d8 >>> 13;
        d8 &= 8191;
        d9 = c4;
        d9 += h0 * r9;
        d9 += h12 * r8;
        d9 += h22 * r7;
        d9 += h32 * r6;
        d9 += h42 * r5;
        c4 = d9 >>> 13;
        d9 &= 8191;
        d9 += h52 * r4;
        d9 += h62 * r32;
        d9 += h72 * r22;
        d9 += h8 * r1;
        d9 += h92 * r0;
        c4 += d9 >>> 13;
        d9 &= 8191;
        c4 = (c4 << 2) + c4 | 0;
        c4 = c4 + d0 | 0;
        d0 = c4 & 8191;
        c4 = c4 >>> 13;
        d1 += c4;
        h0 = d0;
        h12 = d1;
        h22 = d2;
        h32 = d3;
        h42 = d4;
        h52 = d5;
        h62 = d6;
        h72 = d7;
        h8 = d8;
        h92 = d9;
        mpos += 16;
        bytes2 -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h12;
      this.h[2] = h22;
      this.h[3] = h32;
      this.h[4] = h42;
      this.h[5] = h52;
      this.h[6] = h62;
      this.h[7] = h72;
      this.h[8] = h8;
      this.h[9] = h92;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g3 = new Uint16Array(10);
      var c4, mask, f2, i2;
      if (this.leftover) {
        i2 = this.leftover;
        this.buffer[i2++] = 1;
        for (;i2 < 16; i2++)
          this.buffer[i2] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c4 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i2 = 2;i2 < 10; i2++) {
        this.h[i2] += c4;
        c4 = this.h[i2] >>> 13;
        this.h[i2] &= 8191;
      }
      this.h[0] += c4 * 5;
      c4 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c4;
      c4 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c4;
      g3[0] = this.h[0] + 5;
      c4 = g3[0] >>> 13;
      g3[0] &= 8191;
      for (i2 = 1;i2 < 10; i2++) {
        g3[i2] = this.h[i2] + c4;
        c4 = g3[i2] >>> 13;
        g3[i2] &= 8191;
      }
      g3[9] -= 1 << 13;
      mask = (c4 ^ 1) - 1;
      for (i2 = 0;i2 < 10; i2++)
        g3[i2] &= mask;
      mask = ~mask;
      for (i2 = 0;i2 < 10; i2++)
        this.h[i2] = this.h[i2] & mask | g3[i2];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i2 = 1;i2 < 8; i2++) {
        f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
        this.h[i2] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m3, mpos, bytes2) {
      var i2, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes2)
          want = bytes2;
        for (i2 = 0;i2 < want; i2++)
          this.buffer[this.leftover + i2] = m3[mpos + i2];
        bytes2 -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes2 >= 16) {
        want = bytes2 - bytes2 % 16;
        this.blocks(m3, mpos, want);
        mpos += want;
        bytes2 -= want;
      }
      if (bytes2) {
        for (i2 = 0;i2 < bytes2; i2++)
          this.buffer[this.leftover + i2] = m3[mpos + i2];
        this.leftover += bytes2;
      }
    };
    function crypto_onetimeauth(out, outpos, m3, mpos, n4, k3) {
      var s3 = new poly1305(k3);
      s3.update(m3, mpos, n4);
      s3.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h8, hpos, m3, mpos, n4, k3) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m3, mpos, n4, k3);
      return crypto_verify_16(h8, hpos, x2, 0);
    }
    function crypto_secretbox(c4, m3, d2, n4, k3) {
      var i2;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c4, 0, m3, 0, d2, n4, k3);
      crypto_onetimeauth(c4, 16, c4, 32, d2 - 32, c4);
      for (i2 = 0;i2 < 16; i2++)
        c4[i2] = 0;
      return 0;
    }
    function crypto_secretbox_open(m3, c4, d2, n4, k3) {
      var i2;
      var x2 = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x2, 0, 32, n4, k3);
      if (crypto_onetimeauth_verify(c4, 16, c4, 32, d2 - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m3, 0, c4, 0, d2, n4, k3);
      for (i2 = 0;i2 < 32; i2++)
        m3[i2] = 0;
      return 0;
    }
    function set25519(r4, a2) {
      var i2;
      for (i2 = 0;i2 < 16; i2++)
        r4[i2] = a2[i2] | 0;
    }
    function car25519(o3) {
      var i2, v2, c4 = 1;
      for (i2 = 0;i2 < 16; i2++) {
        v2 = o3[i2] + c4 + 65535;
        c4 = Math.floor(v2 / 65536);
        o3[i2] = v2 - c4 * 65536;
      }
      o3[0] += c4 - 1 + 37 * (c4 - 1);
    }
    function sel25519(p3, q2, b2) {
      var t3, c4 = ~(b2 - 1);
      for (var i2 = 0;i2 < 16; i2++) {
        t3 = c4 & (p3[i2] ^ q2[i2]);
        p3[i2] ^= t3;
        q2[i2] ^= t3;
      }
    }
    function pack25519(o3, n4) {
      var i2, j2, b2;
      var m3 = gf(), t3 = gf();
      for (i2 = 0;i2 < 16; i2++)
        t3[i2] = n4[i2];
      car25519(t3);
      car25519(t3);
      car25519(t3);
      for (j2 = 0;j2 < 2; j2++) {
        m3[0] = t3[0] - 65517;
        for (i2 = 1;i2 < 15; i2++) {
          m3[i2] = t3[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
          m3[i2 - 1] &= 65535;
        }
        m3[15] = t3[15] - 32767 - (m3[14] >> 16 & 1);
        b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t3, m3, 1 - b2);
      }
      for (i2 = 0;i2 < 16; i2++) {
        o3[2 * i2] = t3[i2] & 255;
        o3[2 * i2 + 1] = t3[i2] >> 8;
      }
    }
    function neq25519(a2, b2) {
      var c4 = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c4, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c4, 0, d2, 0);
    }
    function par25519(a2) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function unpack25519(o3, n4) {
      var i2;
      for (i2 = 0;i2 < 16; i2++)
        o3[i2] = n4[2 * i2] + (n4[2 * i2 + 1] << 8);
      o3[15] &= 32767;
    }
    function A(o3, a2, b2) {
      for (var i2 = 0;i2 < 16; i2++)
        o3[i2] = a2[i2] + b2[i2];
    }
    function Z2(o3, a2, b2) {
      for (var i2 = 0;i2 < 16; i2++)
        o3[i2] = a2[i2] - b2[i2];
    }
    function M2(o3, a2, b2) {
      var v2, c4, t0 = 0, t1 = 0, t22 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t22 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t22 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t22 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t222 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t222 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t222 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t222 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t222 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t222 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t222 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t222 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t222 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t22 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t222;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t22 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t22 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t22 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t22 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      o3[0] = t0;
      o3[1] = t1;
      o3[2] = t22;
      o3[3] = t3;
      o3[4] = t4;
      o3[5] = t5;
      o3[6] = t6;
      o3[7] = t7;
      o3[8] = t8;
      o3[9] = t9;
      o3[10] = t10;
      o3[11] = t11;
      o3[12] = t12;
      o3[13] = t13;
      o3[14] = t14;
      o3[15] = t15;
    }
    function S(o3, a2) {
      M2(o3, a2, a2);
    }
    function inv25519(o3, i2) {
      var c4 = gf();
      var a2;
      for (a2 = 0;a2 < 16; a2++)
        c4[a2] = i2[a2];
      for (a2 = 253;a2 >= 0; a2--) {
        S(c4, c4);
        if (a2 !== 2 && a2 !== 4)
          M2(c4, c4, i2);
      }
      for (a2 = 0;a2 < 16; a2++)
        o3[a2] = c4[a2];
    }
    function pow2523(o3, i2) {
      var c4 = gf();
      var a2;
      for (a2 = 0;a2 < 16; a2++)
        c4[a2] = i2[a2];
      for (a2 = 250;a2 >= 0; a2--) {
        S(c4, c4);
        if (a2 !== 1)
          M2(c4, c4, i2);
      }
      for (a2 = 0;a2 < 16; a2++)
        o3[a2] = c4[a2];
    }
    function crypto_scalarmult(q2, n4, p3) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r4, i2;
      var a2 = gf(), b2 = gf(), c4 = gf(), d2 = gf(), e3 = gf(), f2 = gf();
      for (i2 = 0;i2 < 31; i2++)
        z2[i2] = n4[i2];
      z2[31] = n4[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p3);
      for (i2 = 0;i2 < 16; i2++) {
        b2[i2] = x2[i2];
        d2[i2] = a2[i2] = c4[i2] = 0;
      }
      a2[0] = d2[0] = 1;
      for (i2 = 254;i2 >= 0; --i2) {
        r4 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a2, b2, r4);
        sel25519(c4, d2, r4);
        A(e3, a2, c4);
        Z2(a2, a2, c4);
        A(c4, b2, d2);
        Z2(b2, b2, d2);
        S(d2, e3);
        S(f2, a2);
        M2(a2, c4, a2);
        M2(c4, b2, e3);
        A(e3, a2, c4);
        Z2(a2, a2, c4);
        S(b2, a2);
        Z2(c4, d2, f2);
        M2(a2, c4, _121665);
        A(a2, a2, d2);
        M2(c4, c4, a2);
        M2(a2, d2, f2);
        M2(d2, b2, x2);
        S(b2, e3);
        sel25519(a2, b2, r4);
        sel25519(c4, d2, r4);
      }
      for (i2 = 0;i2 < 16; i2++) {
        x2[i2 + 16] = a2[i2];
        x2[i2 + 32] = c4[i2];
        x2[i2 + 48] = b2[i2];
        x2[i2 + 64] = d2[i2];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n4) {
      return crypto_scalarmult(q2, n4, _9);
    }
    function crypto_box_keypair(y, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y, x2);
    }
    function crypto_box_beforenm(k3, y, x2) {
      var s3 = new Uint8Array(32);
      crypto_scalarmult(s3, x2, y);
      return crypto_core_hsalsa20(k3, _0, s3, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c4, m3, d2, n4, y, x2) {
      var k3 = new Uint8Array(32);
      crypto_box_beforenm(k3, y, x2);
      return crypto_box_afternm(c4, m3, d2, n4, k3);
    }
    function crypto_box_open(m3, c4, d2, n4, y, x2) {
      var k3 = new Uint8Array(32);
      crypto_box_beforenm(k3, y, x2);
      return crypto_box_open_afternm(m3, c4, d2, n4, k3);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m3, n4) {
      var wh = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j2, h8, l3, a2, b2, c4, d2;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n4 >= 128) {
        for (i2 = 0;i2 < 16; i2++) {
          j2 = 8 * i2 + pos;
          wh[i2] = m3[j2 + 0] << 24 | m3[j2 + 1] << 16 | m3[j2 + 2] << 8 | m3[j2 + 3];
          wl2[i2] = m3[j2 + 4] << 24 | m3[j2 + 5] << 16 | m3[j2 + 6] << 8 | m3[j2 + 7];
        }
        for (i2 = 0;i2 < 80; i2++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h8 = ah7;
          l3 = al7;
          a2 = l3 & 65535;
          b2 = l3 >>> 16;
          c4 = h8 & 65535;
          d2 = h8 >>> 16;
          h8 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l3 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          h8 = ah4 & ah5 ^ ~ah4 & ah6;
          l3 = al4 & al5 ^ ~al4 & al6;
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          h8 = K2[i2 * 2];
          l3 = K2[i2 * 2 + 1];
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          h8 = wh[i2 % 16];
          l3 = wl2[i2 % 16];
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          b2 += a2 >>> 16;
          c4 += b2 >>> 16;
          d2 += c4 >>> 16;
          th = c4 & 65535 | d2 << 16;
          tl = a2 & 65535 | b2 << 16;
          h8 = th;
          l3 = tl;
          a2 = l3 & 65535;
          b2 = l3 >>> 16;
          c4 = h8 & 65535;
          d2 = h8 >>> 16;
          h8 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l3 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          h8 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l3 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          b2 += a2 >>> 16;
          c4 += b2 >>> 16;
          d2 += c4 >>> 16;
          bh7 = c4 & 65535 | d2 << 16;
          bl7 = a2 & 65535 | b2 << 16;
          h8 = bh3;
          l3 = bl3;
          a2 = l3 & 65535;
          b2 = l3 >>> 16;
          c4 = h8 & 65535;
          d2 = h8 >>> 16;
          h8 = th;
          l3 = tl;
          a2 += l3 & 65535;
          b2 += l3 >>> 16;
          c4 += h8 & 65535;
          d2 += h8 >>> 16;
          b2 += a2 >>> 16;
          c4 += b2 >>> 16;
          d2 += c4 >>> 16;
          bh3 = c4 & 65535 | d2 << 16;
          bl3 = a2 & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i2 % 16 === 15) {
            for (j2 = 0;j2 < 16; j2++) {
              h8 = wh[j2];
              l3 = wl2[j2];
              a2 = l3 & 65535;
              b2 = l3 >>> 16;
              c4 = h8 & 65535;
              d2 = h8 >>> 16;
              h8 = wh[(j2 + 9) % 16];
              l3 = wl2[(j2 + 9) % 16];
              a2 += l3 & 65535;
              b2 += l3 >>> 16;
              c4 += h8 & 65535;
              d2 += h8 >>> 16;
              th = wh[(j2 + 1) % 16];
              tl = wl2[(j2 + 1) % 16];
              h8 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l3 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a2 += l3 & 65535;
              b2 += l3 >>> 16;
              c4 += h8 & 65535;
              d2 += h8 >>> 16;
              th = wh[(j2 + 14) % 16];
              tl = wl2[(j2 + 14) % 16];
              h8 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l3 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a2 += l3 & 65535;
              b2 += l3 >>> 16;
              c4 += h8 & 65535;
              d2 += h8 >>> 16;
              b2 += a2 >>> 16;
              c4 += b2 >>> 16;
              d2 += c4 >>> 16;
              wh[j2] = c4 & 65535 | d2 << 16;
              wl2[j2] = a2 & 65535 | b2 << 16;
            }
          }
        }
        h8 = ah0;
        l3 = al0;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[0];
        l3 = hl[0];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[0] = ah0 = c4 & 65535 | d2 << 16;
        hl[0] = al0 = a2 & 65535 | b2 << 16;
        h8 = ah1;
        l3 = al1;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[1];
        l3 = hl[1];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[1] = ah1 = c4 & 65535 | d2 << 16;
        hl[1] = al1 = a2 & 65535 | b2 << 16;
        h8 = ah2;
        l3 = al2;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[2];
        l3 = hl[2];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[2] = ah2 = c4 & 65535 | d2 << 16;
        hl[2] = al2 = a2 & 65535 | b2 << 16;
        h8 = ah3;
        l3 = al3;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[3];
        l3 = hl[3];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[3] = ah3 = c4 & 65535 | d2 << 16;
        hl[3] = al3 = a2 & 65535 | b2 << 16;
        h8 = ah4;
        l3 = al4;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[4];
        l3 = hl[4];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[4] = ah4 = c4 & 65535 | d2 << 16;
        hl[4] = al4 = a2 & 65535 | b2 << 16;
        h8 = ah5;
        l3 = al5;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[5];
        l3 = hl[5];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[5] = ah5 = c4 & 65535 | d2 << 16;
        hl[5] = al5 = a2 & 65535 | b2 << 16;
        h8 = ah6;
        l3 = al6;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[6];
        l3 = hl[6];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[6] = ah6 = c4 & 65535 | d2 << 16;
        hl[6] = al6 = a2 & 65535 | b2 << 16;
        h8 = ah7;
        l3 = al7;
        a2 = l3 & 65535;
        b2 = l3 >>> 16;
        c4 = h8 & 65535;
        d2 = h8 >>> 16;
        h8 = hh[7];
        l3 = hl[7];
        a2 += l3 & 65535;
        b2 += l3 >>> 16;
        c4 += h8 & 65535;
        d2 += h8 >>> 16;
        b2 += a2 >>> 16;
        c4 += b2 >>> 16;
        d2 += c4 >>> 16;
        hh[7] = ah7 = c4 & 65535 | d2 << 16;
        hl[7] = al7 = a2 & 65535 | b2 << 16;
        pos += 128;
        n4 -= 128;
      }
      return n4;
    }
    function crypto_hash(out, m3, n4) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n4;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m3, n4);
      n4 %= 128;
      for (i2 = 0;i2 < n4; i2++)
        x2[i2] = m3[b2 - n4 + i2];
      x2[n4] = 128;
      n4 = 256 - 128 * (n4 < 112 ? 1 : 0);
      x2[n4 - 9] = 0;
      ts64(x2, n4 - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh, hl, x2, n4);
      for (i2 = 0;i2 < 8; i2++)
        ts64(out, 8 * i2, hh[i2], hl[i2]);
      return 0;
    }
    function add(p3, q2) {
      var a2 = gf(), b2 = gf(), c4 = gf(), d2 = gf(), e3 = gf(), f2 = gf(), g3 = gf(), h8 = gf(), t3 = gf();
      Z2(a2, p3[1], p3[0]);
      Z2(t3, q2[1], q2[0]);
      M2(a2, a2, t3);
      A(b2, p3[0], p3[1]);
      A(t3, q2[0], q2[1]);
      M2(b2, b2, t3);
      M2(c4, p3[3], q2[3]);
      M2(c4, c4, D2);
      M2(d2, p3[2], q2[2]);
      A(d2, d2, d2);
      Z2(e3, b2, a2);
      Z2(f2, d2, c4);
      A(g3, d2, c4);
      A(h8, b2, a2);
      M2(p3[0], e3, f2);
      M2(p3[1], h8, g3);
      M2(p3[2], g3, f2);
      M2(p3[3], e3, h8);
    }
    function cswap(p3, q2, b2) {
      var i2;
      for (i2 = 0;i2 < 4; i2++) {
        sel25519(p3[i2], q2[i2], b2);
      }
    }
    function pack(r4, p3) {
      var tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p3[2]);
      M2(tx, p3[0], zi2);
      M2(ty, p3[1], zi2);
      pack25519(r4, ty);
      r4[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p3, q2, s3) {
      var b2, i2;
      set25519(p3[0], gf0);
      set25519(p3[1], gf1);
      set25519(p3[2], gf1);
      set25519(p3[3], gf0);
      for (i2 = 255;i2 >= 0; --i2) {
        b2 = s3[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p3, q2, b2);
        add(q2, p3);
        add(p3, p3);
        cswap(p3, q2, b2);
      }
    }
    function scalarbase(p3, s3) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p3, q2, s3);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d2 = new Uint8Array(64);
      var p3 = [gf(), gf(), gf(), gf()];
      var i2;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p3, d2);
      pack(pk, p3);
      for (i2 = 0;i2 < 32; i2++)
        sk[i2 + 32] = pk[i2];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r4, x2) {
      var carry, i2, j2, k3;
      for (i2 = 63;i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k3 = i2 - 12;j2 < k3; ++j2) {
          x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i2] = 0;
      }
      carry = 0;
      for (j2 = 0;j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0;j2 < 32; j2++)
        x2[j2] -= carry * L2[j2];
      for (i2 = 0;i2 < 32; i2++) {
        x2[i2 + 1] += x2[i2] >> 8;
        r4[i2] = x2[i2] & 255;
      }
    }
    function reduce(r4) {
      var x2 = new Float64Array(64), i2;
      for (i2 = 0;i2 < 64; i2++)
        x2[i2] = r4[i2];
      for (i2 = 0;i2 < 64; i2++)
        r4[i2] = 0;
      modL(r4, x2);
    }
    function crypto_sign(sm, m3, n4, sk) {
      var d2 = new Uint8Array(64), h8 = new Uint8Array(64), r4 = new Uint8Array(64);
      var i2, j2, x2 = new Float64Array(64);
      var p3 = [gf(), gf(), gf(), gf()];
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n4 + 64;
      for (i2 = 0;i2 < n4; i2++)
        sm[64 + i2] = m3[i2];
      for (i2 = 0;i2 < 32; i2++)
        sm[32 + i2] = d2[32 + i2];
      crypto_hash(r4, sm.subarray(32), n4 + 32);
      reduce(r4);
      scalarbase(p3, r4);
      pack(sm, p3);
      for (i2 = 32;i2 < 64; i2++)
        sm[i2] = sk[i2];
      crypto_hash(h8, sm, n4 + 64);
      reduce(h8);
      for (i2 = 0;i2 < 64; i2++)
        x2[i2] = 0;
      for (i2 = 0;i2 < 32; i2++)
        x2[i2] = r4[i2];
      for (i2 = 0;i2 < 32; i2++) {
        for (j2 = 0;j2 < 32; j2++) {
          x2[i2 + j2] += h8[i2] * d2[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r4, p3) {
      var t3 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r4[2], gf1);
      unpack25519(r4[1], p3);
      S(num, r4[1]);
      M2(den, num, D);
      Z2(num, num, r4[2]);
      A(den, r4[2], den);
      S(den2, den);
      S(den4, den2);
      M2(den6, den4, den2);
      M2(t3, den6, num);
      M2(t3, t3, den);
      pow2523(t3, t3);
      M2(t3, t3, num);
      M2(t3, t3, den);
      M2(t3, t3, den);
      M2(r4[0], t3, den);
      S(chk, r4[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r4[0], r4[0], I2);
      S(chk, r4[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r4[0]) === p3[31] >> 7)
        Z2(r4[0], gf0, r4[0]);
      M2(r4[3], r4[0], r4[1]);
      return 0;
    }
    function crypto_sign_open(m3, sm, n4, pk) {
      var i2;
      var t3 = new Uint8Array(32), h8 = new Uint8Array(64);
      var p3 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      if (n4 < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i2 = 0;i2 < n4; i2++)
        m3[i2] = sm[i2];
      for (i2 = 0;i2 < 32; i2++)
        m3[i2 + 32] = pk[i2];
      crypto_hash(h8, m3, n4);
      reduce(h8);
      scalarmult(p3, q2, h8);
      scalarbase(q2, sm.subarray(32));
      add(p3, q2);
      pack(t3, p3);
      n4 -= 64;
      if (crypto_verify_32(sm, 0, t3, 0)) {
        for (i2 = 0;i2 < n4; i2++)
          m3[i2] = 0;
        return -1;
      }
      for (i2 = 0;i2 < n4; i2++)
        m3[i2] = sm[i2 + 64];
      return n4;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A,
      S,
      Z: Z2,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k3, n4) {
      if (k3.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n4.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i2 = 0;i2 < arguments.length; i2++) {
        if (!(arguments[i2] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup2(arr) {
      for (var i2 = 0;i2 < arr.length; i2++)
        arr[i2] = 0;
    }
    nacl.randomBytes = function(n4) {
      var b2 = new Uint8Array(n4);
      randombytes(b2, n4);
      return b2;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c4 = new Uint8Array(m3.length);
      for (var i2 = 0;i2 < msg.length; i2++)
        m3[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
      crypto_secretbox(c4, m3, m3.length, nonce, key);
      return c4.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c4 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m3 = new Uint8Array(c4.length);
      for (var i2 = 0;i2 < box.length; i2++)
        c4[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
      if (c4.length < 32)
        return null;
      if (crypto_secretbox_open(m3, c4, c4.length, nonce, key) !== 0)
        return null;
      return m3.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n4, p3) {
      checkArrayTypes(n4, p3);
      if (n4.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p3.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n4, p3);
      return q2;
    };
    nacl.scalarMult.base = function(n4) {
      checkArrayTypes(n4);
      if (n4.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n4);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k3 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k3);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k3, publicKey, secretKey);
      return k3;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k3 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k3);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m3 = new Uint8Array(mlen);
      for (var i2 = 0;i2 < m3.length; i2++)
        m3[i2] = tmp[i2];
      return m3;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i2 = 0;i2 < sig.length; i2++)
        sig[i2] = signedMsg[i2];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i2;
      for (i2 = 0;i2 < crypto_sign_BYTES; i2++)
        sm[i2] = sig[i2];
      for (i2 = 0;i2 < msg.length; i2++)
        sm[i2 + crypto_sign_BYTES] = msg[i2];
      return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i2 = 0;i2 < pk.length; i2++)
        pk[i2] = secretKey[32 + i2];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i2 = 0;i2 < 32; i2++)
        sk[i2] = seed[i2];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h8 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h8, msg, msg.length);
      return h8;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x2, y) {
      checkArrayTypes(x2, y);
      if (x2.length === 0 || y.length === 0)
        return false;
      if (x2.length !== y.length)
        return false;
      return vn2(x2, 0, y, 0, x2.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn2) {
      randombytes = fn2;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x2, n4) {
          var i2, v2 = new Uint8Array(n4);
          for (i2 = 0;i2 < n4; i2 += QUOTA) {
            crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n4 - i2, QUOTA)));
          }
          for (i2 = 0;i2 < n4; i2++)
            x2[i2] = v2[i2];
          cleanup2(v2);
        });
      } else if (true) {
        crypto2 = __require("crypto");
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x2, n4) {
            var i2, v2 = crypto2.randomBytes(n4);
            for (i2 = 0;i2 < n4; i2++)
              x2[i2] = v2[i2];
            cleanup2(v2);
          });
        }
      }
    })();
  })(typeof module !== "undefined" && exports ? exports : self.nacl = self.nacl || {});
});

// ../../../../node_modules/tweetnacl-util/nacl-util.js
var require_nacl_util = __commonJS((exports, module) => {
  (function(root3, f2) {
    if (typeof module !== "undefined" && module.exports)
      module.exports = f2();
    else if (root3.nacl)
      root3.nacl.util = f2();
    else {
      root3.nacl = {};
      root3.nacl.util = f2();
    }
  })(exports, function() {
    var util2 = {};
    function validateBase64(s3) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s3)) {
        throw new TypeError("invalid encoding");
      }
    }
    util2.decodeUTF8 = function(s3) {
      if (typeof s3 !== "string")
        throw new TypeError("expected string");
      var i2, d2 = unescape(encodeURIComponent(s3)), b2 = new Uint8Array(d2.length);
      for (i2 = 0;i2 < d2.length; i2++)
        b2[i2] = d2.charCodeAt(i2);
      return b2;
    };
    util2.encodeUTF8 = function(arr) {
      var i2, s3 = [];
      for (i2 = 0;i2 < arr.length; i2++)
        s3.push(String.fromCharCode(arr[i2]));
      return decodeURIComponent(escape(s3.join("")));
    };
    if (typeof atob === "undefined") {
      if (typeof Buffer.from !== "undefined") {
        util2.encodeBase64 = function(arr) {
          return Buffer.from(arr).toString("base64");
        };
        util2.decodeBase64 = function(s3) {
          validateBase64(s3);
          return new Uint8Array(Array.prototype.slice.call(Buffer.from(s3, "base64"), 0));
        };
      } else {
        util2.encodeBase64 = function(arr) {
          return new Buffer(arr).toString("base64");
        };
        util2.decodeBase64 = function(s3) {
          validateBase64(s3);
          return new Uint8Array(Array.prototype.slice.call(new Buffer(s3, "base64"), 0));
        };
      }
    } else {
      util2.encodeBase64 = function(arr) {
        var i2, s3 = [], len = arr.length;
        for (i2 = 0;i2 < len; i2++)
          s3.push(String.fromCharCode(arr[i2]));
        return btoa(s3.join(""));
      };
      util2.decodeBase64 = function(s3) {
        validateBase64(s3);
        var i2, d2 = atob(s3), b2 = new Uint8Array(d2.length);
        for (i2 = 0;i2 < d2.length; i2++)
          b2[i2] = d2.charCodeAt(i2);
        return b2;
      };
    }
    return util2;
  });
});

// ../../../../node_modules/pusher/lib/events.js
var require_events = __commonJS((exports) => {
  var util2 = require_util();
  var nacl = require_nacl_fast();
  var naclUtil = require_nacl_util();
  function encrypt2(pusher, channel, data) {
    if (pusher.config.encryptionMasterKey === undefined) {
      throw new Error("Set encryptionMasterKey before triggering events on encrypted channels");
    }
    const nonceBytes = nacl.randomBytes(24);
    const ciphertextBytes = nacl.secretbox(naclUtil.decodeUTF8(JSON.stringify(data)), nonceBytes, pusher.channelSharedSecret(channel));
    return JSON.stringify({
      nonce: naclUtil.encodeBase64(nonceBytes),
      ciphertext: naclUtil.encodeBase64(ciphertextBytes)
    });
  }
  exports.trigger = function(pusher, channels, eventName, data, params) {
    if (channels.length === 1 && util2.isEncryptedChannel(channels[0])) {
      const channel = channels[0];
      const event = {
        name: eventName,
        data: encrypt2(pusher, channel, data),
        channels: [channel],
        ...params
      };
      return pusher.post({ path: "/events", body: event });
    } else {
      for (let i2 = 0;i2 < channels.length; i2++) {
        if (util2.isEncryptedChannel(channels[i2])) {
          throw new Error("You cannot trigger to multiple channels when using encrypted channels");
        }
      }
      const event = {
        name: eventName,
        data: ensureJSON(data),
        channels,
        ...params
      };
      return pusher.post({ path: "/events", body: event });
    }
  };
  exports.triggerBatch = function(pusher, batch) {
    for (let i2 = 0;i2 < batch.length; i2++) {
      batch[i2].data = util2.isEncryptedChannel(batch[i2].channel) ? encrypt2(pusher, batch[i2].channel, batch[i2].data) : ensureJSON(batch[i2].data);
    }
    return pusher.post({ path: "/batch_events", body: { batch } });
  };
  function ensureJSON(data) {
    return typeof data === "string" ? data : JSON.stringify(data);
  }
});

// ../../../../node_modules/pusher/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "pusher",
    description: "Node.js client to interact with the Pusher Channels REST API",
    version: "5.2.0",
    author: "Pusher <support@pusher.com>",
    contributors: [
      {
        name: "fabrik42",
        email: "fabrik42@gmail.com"
      },
      {
        name: "Jaewoong Kim",
        email: "jwoongkim@gmail.com"
      },
      {
        name: "Phil Leggetter",
        email: "phil@leggetter.co.uk"
      },
      {
        name: "Pawe\u0142 Ledwo\u0144",
        email: "me@ludvik.pl"
      }
    ],
    dependencies: {
      "abort-controller": "^3.0.0",
      "is-base64": "^1.1.0",
      "node-fetch": "^2.6.1",
      tweetnacl: "^1.0.0",
      "tweetnacl-util": "^0.15.0",
      "@types/node-fetch": "^2.5.7"
    },
    devDependencies: {
      "@types/node": "^14.14.6",
      eslint: "^7.11.0",
      "expect.js": "=0.3.1",
      express: "^4.17.1",
      "https-proxy-agent": "^5.0.0",
      mocha: "^7.2.0",
      nock: "^12.0.3",
      prettier: "2.1.2",
      sinon: "=1.10.2",
      webpack: "^4.42.1",
      "webpack-cli": "^3.3.11"
    },
    scripts: {
      "local-test": "npx mocha 'tests/integration/**/*.js'",
      test: "npx mocha 'tests/{integration,remote}/**/*.js'",
      lint: "npx eslint . && npx prettier --check .",
      format: "npx prettier --write ."
    },
    keywords: [
      "pusher",
      "websockets",
      "realtime"
    ],
    license: "MIT",
    repository: "git://github.com/pusher/pusher-http-node",
    main: "lib/pusher",
    typings: "index.d.ts",
    engines: {
      node: ">= 4.0.0"
    }
  };
});

// ../../../../node_modules/pusher/lib/version.js
var require_version2 = __commonJS((exports, module) => {
  module.exports = require_package().version;
});

// ../../../../node_modules/pusher/lib/requests.js
var require_requests = __commonJS((exports) => {
  var fetch3 = __require("node-fetch").default;
  var AbortController = __require("abort-controller").default;
  var errors3 = require_errors();
  var util2 = require_util();
  var pusherLibraryVersion = require_version2();
  var RESERVED_QUERY_KEYS = {
    auth_key: true,
    auth_timestamp: true,
    auth_version: true,
    auth_signature: true,
    body_md5: true
  };
  function send(config10, options3) {
    const method = options3.method;
    const path3 = config10.prefixPath(options3.path);
    const body = options3.body ? JSON.stringify(options3.body) : undefined;
    const url = `${config10.getBaseURL()}${path3}?${createSignedQueryString(config10.token, {
      method,
      path: path3,
      params: options3.params,
      body
    })}`;
    const headers = {
      "x-pusher-library": "pusher-http-node " + pusherLibraryVersion
    };
    if (body) {
      headers["content-type"] = "application/json";
    }
    let signal;
    let timeout;
    if (config10.timeout) {
      const controller = new AbortController;
      timeout = setTimeout(() => controller.abort(), config10.timeout);
      signal = controller.signal;
    }
    return fetch3(url, {
      method,
      body,
      headers,
      signal,
      agent: config10.agent
    }).then((res) => {
      clearTimeout(timeout);
      if (res.status >= 400) {
        return res.text().then((body2) => {
          throw new errors3.RequestError("Unexpected status code " + res.status, url, undefined, res.status, body2);
        });
      }
      return res;
    }, (err) => {
      clearTimeout(timeout);
      throw new errors3.RequestError("Request failed with an error", url, err);
    });
  }
  function createSignedQueryString(token2, request2) {
    const timestamp2 = Date.now() / 1000 | 0;
    const params = {
      auth_key: token2.key,
      auth_timestamp: timestamp2,
      auth_version: "1.0"
    };
    if (request2.body) {
      params.body_md5 = util2.getMD5(request2.body);
    }
    if (request2.params) {
      for (const key in request2.params) {
        if (RESERVED_QUERY_KEYS[key] !== undefined) {
          throw Error(key + " is a required parameter and cannot be overidden");
        }
        params[key] = request2.params[key];
      }
    }
    const method = request2.method.toUpperCase();
    const sortedKeyVal = util2.toOrderedArray(params);
    let queryString = sortedKeyVal.join("&");
    const signData = [method, request2.path, queryString].join(`
`);
    queryString += "&auth_signature=" + token2.sign(signData);
    return queryString;
  }
  exports.send = send;
  exports.createSignedQueryString = createSignedQueryString;
});

// ../../../../node_modules/pusher/lib/token.js
var require_token = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var util2 = require_util();

  class Token2 {
    constructor(key, secret) {
      this.key = key;
      this.secret = secret;
    }
    sign(string4) {
      return crypto2.createHmac("sha256", this.secret).update(Buffer.from(string4)).digest("hex");
    }
    verify(string4, signature) {
      return util2.secureCompare(this.sign(string4), signature);
    }
  }
  module.exports = Token2;
});

// ../../../../node_modules/is-base64/is-base64.js
var require_is_base64 = __commonJS((exports, module) => {
  (function(root3) {
    function isBase642(v2, opts) {
      if (v2 instanceof Boolean || typeof v2 === "boolean") {
        return false;
      }
      if (!(opts instanceof Object)) {
        opts = {};
      }
      if (opts.allowEmpty === false && v2 === "") {
        return false;
      }
      var regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?";
      var mimeRegex = "(data:\\w+\\/[a-zA-Z\\+\\-\\.]+;base64,)";
      if (opts.mimeRequired === true) {
        regex = mimeRegex + regex;
      } else if (opts.allowMime === true) {
        regex = mimeRegex + "?" + regex;
      }
      if (opts.paddingRequired === false) {
        regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?";
      }
      return new RegExp("^" + regex + "$", "gi").test(v2);
    }
    if (typeof exports !== "undefined") {
      if (typeof module !== "undefined" && module.exports) {
        exports = module.exports = isBase642;
      }
      exports.isBase64 = isBase642;
    } else if (typeof define === "function" && define.amd) {
      define([], function() {
        return isBase642;
      });
    } else {
      root3.isBase64 = isBase642;
    }
  })(exports);
});

// ../../../../node_modules/pusher/lib/config.js
var require_config = __commonJS((exports, module) => {
  var Token2 = require_token();
  var isBase642 = require_is_base64();
  function Config(options3) {
    options3 = options3 || {};
    let useTLS = false;
    if (options3.useTLS !== undefined && options3.encrypted !== undefined) {
      throw new Error("Cannot set both `useTLS` and `encrypted` configuration options");
    } else if (options3.useTLS !== undefined) {
      useTLS = options3.useTLS;
    } else if (options3.encrypted !== undefined) {
      console.warn("`encrypted` option is deprecated in favor of `useTLS`");
      useTLS = options3.encrypted;
    }
    this.scheme = options3.scheme || (useTLS ? "https" : "http");
    this.port = options3.port;
    this.appId = options3.appId;
    this.token = new Token2(options3.key, options3.secret);
    this.timeout = options3.timeout;
    this.agent = options3.agent;
    if (options3.encryptionMasterKey !== undefined) {
      if (options3.encryptionMasterKeyBase64 !== undefined) {
        throw new Error("Do not specify both encryptionMasterKey and encryptionMasterKeyBase64. " + "encryptionMasterKey is deprecated, please specify only encryptionMasterKeyBase64.");
      }
      console.warn("`encryptionMasterKey` option is deprecated in favor of `encryptionMasterKeyBase64`");
      if (typeof options3.encryptionMasterKey !== "string") {
        throw new Error("encryptionMasterKey must be a string");
      }
      if (options3.encryptionMasterKey.length !== 32) {
        throw new Error("encryptionMasterKey must be 32 bytes long, but the string '" + options3.encryptionMasterKey + "' is " + options3.encryptionMasterKey.length + " bytes long");
      }
      this.encryptionMasterKey = Buffer.from(options3.encryptionMasterKey);
    }
    if (options3.encryptionMasterKeyBase64 !== undefined) {
      if (typeof options3.encryptionMasterKeyBase64 !== "string") {
        throw new Error("encryptionMasterKeyBase64 must be a string");
      }
      if (!isBase642(options3.encryptionMasterKeyBase64)) {
        throw new Error("encryptionMasterKeyBase64 must be valid base64");
      }
      const decodedKey = Buffer.from(options3.encryptionMasterKeyBase64, "base64");
      if (decodedKey.length !== 32) {
        throw new Error("encryptionMasterKeyBase64 must decode to 32 bytes, but the string " + options3.encryptionMasterKeyBase64 + "' decodes to " + decodedKey.length + " bytes");
      }
      this.encryptionMasterKey = decodedKey;
    }
  }
  Config.prototype.prefixPath = function() {
    throw "NotImplementedError: #prefixPath should be implemented by subclasses";
  };
  Config.prototype.getBaseURL = function() {
    const port = this.port ? ":" + this.port : "";
    return this.scheme + "://" + this.host + port;
  };
  module.exports = Config;
});

// ../../../../node_modules/pusher/lib/pusher_config.js
var require_pusher_config = __commonJS((exports, module) => {
  var Config = require_config();
  function PusherConfig(options3) {
    Config.call(this, options3);
    if (options3.host) {
      this.host = options3.host;
    } else if (options3.cluster) {
      this.host = "api-" + options3.cluster + ".pusher.com";
    } else {
      this.host = "api.pusherapp.com";
    }
  }
  Object.assign(PusherConfig.prototype, Config.prototype);
  PusherConfig.prototype.prefixPath = function(subPath) {
    return "/apps/" + this.appId + subPath;
  };
  module.exports = PusherConfig;
});

// ../../../../node_modules/pusher/lib/webhook.js
var require_webhook = __commonJS((exports, module) => {
  var errors3 = require_errors();
  var Token2 = require_token();
  function WebHook(token2, request2) {
    this.token = token2;
    this.key = request2.headers["x-pusher-key"];
    this.signature = request2.headers["x-pusher-signature"];
    this.contentType = request2.headers["content-type"];
    this.body = request2.rawBody;
    if (this.isContentTypeValid()) {
      try {
        this.data = JSON.parse(this.body);
      } catch (e3) {}
    }
  }
  WebHook.prototype.isValid = function(extraTokens) {
    if (!this.isBodyValid()) {
      return false;
    }
    extraTokens = extraTokens || [];
    if (!(extraTokens instanceof Array)) {
      extraTokens = [extraTokens];
    }
    const tokens = [this.token].concat(extraTokens);
    for (const i2 in tokens) {
      let token2 = tokens[i2];
      if (token2 instanceof Token2 === false) {
        token2 = new Token2(token2.key, token2.secret);
      }
      if (this.key == token2.key && token2.verify(this.body, this.signature)) {
        return true;
      }
    }
    return false;
  };
  WebHook.prototype.isContentTypeValid = function() {
    return this.contentType === "application/json";
  };
  WebHook.prototype.isBodyValid = function() {
    return this.data !== undefined;
  };
  WebHook.prototype.getData = function() {
    if (!this.isBodyValid()) {
      throw new errors3.WebHookError("Invalid WebHook body", this.contentType, this.body, this.signature);
    }
    return this.data;
  };
  WebHook.prototype.getEvents = function() {
    return this.getData().events;
  };
  WebHook.prototype.getTime = function() {
    return new Date(this.getData().time_ms);
  };
  module.exports = WebHook;
});

// ../../../../node_modules/pusher/lib/pusher.js
var require_pusher = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var url = __require("url");
  var auth = require_auth();
  var errors3 = require_errors();
  var events = require_events();
  var requests = require_requests();
  var PusherConfig = require_pusher_config();
  var Token2 = require_token();
  var WebHook = require_webhook();
  var validateChannel = function(channel) {
    if (typeof channel !== "string" || channel === "" || channel.match(/[^A-Za-z0-9_\-=@,.;]/)) {
      throw new Error("Invalid channel name: '" + channel + "'");
    }
    if (channel.length > 200) {
      throw new Error("Channel name too long: '" + channel + "'");
    }
  };
  var validateSocketId = function(socketId) {
    if (typeof socketId !== "string" || socketId === "" || !socketId.match(/^\d+\.\d+$/)) {
      throw new Error("Invalid socket id: '" + socketId + "'");
    }
  };
  var validateUserId = function(userId) {
    if (typeof userId !== "string" || userId === "") {
      throw new Error("Invalid user id: '" + userId + "'");
    }
  };
  var validateUserData = function(userData) {
    if (userData == null || typeof userData !== "object") {
      throw new Error("Invalid user data: '" + userData + "'");
    }
    validateUserId(userData.id);
  };
  function Pusher(options3) {
    this.config = new PusherConfig(options3);
  }
  Pusher.forURL = function(pusherUrl, options3) {
    const apiUrl = url.parse(pusherUrl);
    const apiPath = apiUrl.pathname.split("/");
    const apiAuth = apiUrl.auth.split(":");
    return new Pusher(Object.assign({}, options3 || {}, {
      scheme: apiUrl.protocol.replace(/:$/, ""),
      host: apiUrl.hostname,
      port: parseInt(apiUrl.port, 10) || undefined,
      appId: parseInt(apiPath[apiPath.length - 1], 10),
      key: apiAuth[0],
      secret: apiAuth[1]
    }));
  };
  Pusher.forCluster = function(cluster, options3) {
    return new Pusher(Object.assign({}, options3 || {}, {
      host: "api-" + cluster + ".pusher.com"
    }));
  };
  Pusher.prototype.authorizeChannel = function(socketId, channel, data) {
    validateSocketId(socketId);
    validateChannel(channel);
    return auth.getSocketSignature(this, this.config.token, channel, socketId, data);
  };
  Pusher.prototype.authenticate = Pusher.prototype.authorizeChannel;
  Pusher.prototype.authenticateUser = function(socketId, userData) {
    validateSocketId(socketId);
    validateUserData(userData);
    return auth.getSocketSignatureForUser(this.config.token, socketId, userData);
  };
  Pusher.prototype.sendToUser = function(userId, event, data) {
    if (event.length > 200) {
      throw new Error("Too long event name: '" + event + "'");
    }
    validateUserId(userId);
    return events.trigger(this, [`#server-to-user-${userId}`], event, data);
  };
  Pusher.prototype.terminateUserConnections = function(userId) {
    validateUserId(userId);
    return this.post({ path: `/users/${userId}/terminate_connections`, body: {} });
  };
  Pusher.prototype.trigger = function(channels, event, data, params) {
    if (params && params.socket_id) {
      validateSocketId(params.socket_id);
    }
    if (!(channels instanceof Array)) {
      channels = [channels];
    }
    if (event.length > 200) {
      throw new Error("Too long event name: '" + event + "'");
    }
    if (channels.length > 100) {
      throw new Error("Can't trigger a message to more than 100 channels");
    }
    for (let i2 = 0;i2 < channels.length; i2++) {
      validateChannel(channels[i2]);
    }
    return events.trigger(this, channels, event, data, params);
  };
  Pusher.prototype.triggerBatch = function(batch) {
    return events.triggerBatch(this, batch);
  };
  Pusher.prototype.post = function(options3) {
    return requests.send(this.config, Object.assign({}, options3, { method: "POST" }));
  };
  Pusher.prototype.get = function(options3) {
    return requests.send(this.config, Object.assign({}, options3, { method: "GET" }));
  };
  Pusher.prototype.webhook = function(request2) {
    return new WebHook(this.config.token, request2);
  };
  Pusher.prototype.createSignedQueryString = function(options3) {
    return requests.createSignedQueryString(this.config.token, options3);
  };
  Pusher.prototype.channelSharedSecret = function(channel) {
    return crypto2.createHash("sha256").update(Buffer.concat([Buffer.from(channel), this.config.encryptionMasterKey])).digest();
  };
  Pusher.Token = Token2;
  Pusher.RequestError = errors3.RequestError;
  Pusher.WebHookError = errors3.WebHookError;
  module.exports = Pusher;
});

// ../../../../node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports, module) => {
  module.exports = preferredCharsets;
  module.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(",");
    for (var i2 = 0, j2 = 0;i2 < accepts.length; i2++) {
      var charset = parseCharset(accepts[i2].trim(), i2);
      if (charset) {
        accepts[j2++] = charset;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseCharset(str2, i2) {
    var match = simpleCharsetRegExp.exec(str2);
    if (!match)
      return null;
    var charset = match[1];
    var q2 = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p3 = params[j2].trim().split("=");
        if (p3[0] === "q") {
          q2 = parseFloat(p3[1]);
          break;
        }
      }
    }
    return {
      charset,
      q: q2,
      i: i2
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(charset, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s3 = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s3 |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s3
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a2, b2) {
    return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../../../node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  module.exports = preferredEncodings;
  module.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i2 = 0, j2 = 0;i2 < accepts.length; i2++) {
      var encoding = parseEncoding(accepts[i2].trim(), i2);
      if (encoding) {
        accepts[j2++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j2++] = {
        encoding: "identity",
        q: minQuality,
        i: i2
      };
    }
    accepts.length = j2;
    return accepts;
  }
  function parseEncoding(str2, i2) {
    var match = simpleEncodingRegExp.exec(str2);
    if (!match)
      return null;
    var encoding = match[1];
    var q2 = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p3 = params[j2].trim().split("=");
        if (p3[0] === "q") {
          q2 = parseFloat(p3[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q: q2,
      i: i2
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(encoding, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s3 = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s3 |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s3
    };
  }
  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a2, b2) {
    return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../../../node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports, module) => {
  module.exports = preferredLanguages;
  module.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(",");
    for (var i2 = 0, j2 = 0;i2 < accepts.length; i2++) {
      var language = parseLanguage(accepts[i2].trim(), i2);
      if (language) {
        accepts[j2++] = language;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseLanguage(str2, i2) {
    var match = simpleLanguageRegExp.exec(str2);
    if (!match)
      return null;
    var prefix2 = match[1];
    var suffix = match[2];
    var full = prefix2;
    if (suffix)
      full += "-" + suffix;
    var q2 = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p3 = params[j2].split("=");
        if (p3[0] === "q")
          q2 = parseFloat(p3[1]);
      }
    }
    return {
      prefix: prefix2,
      suffix,
      q: q2,
      i: i2,
      full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(language, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p3 = parseLanguage(language);
    if (!p3)
      return null;
    var s3 = 0;
    if (spec.full.toLowerCase() === p3.full.toLowerCase()) {
      s3 |= 4;
    } else if (spec.prefix.toLowerCase() === p3.full.toLowerCase()) {
      s3 |= 2;
    } else if (spec.full.toLowerCase() === p3.prefix.toLowerCase()) {
      s3 |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s3
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a2, b2) {
    return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../../../node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports, module) => {
  module.exports = preferredMediaTypes;
  module.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i2 = 0, j2 = 0;i2 < accepts.length; i2++) {
      var mediaType = parseMediaType(accepts[i2].trim(), i2);
      if (mediaType) {
        accepts[j2++] = mediaType;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseMediaType(str2, i2) {
    var match = simpleMediaTypeRegExp.exec(str2);
    if (!match)
      return null;
    var params = Object.create(null);
    var q2 = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j2 = 0;j2 < kvps.length; j2++) {
        var pair = kvps[j2];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === "q") {
          q2 = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q: q2,
      i: i2
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i2 = 0;i2 < accepted.length; i2++) {
      var spec = specify(type, accepted[i2], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p3 = parseMediaType(type);
    var s3 = 0;
    if (!p3) {
      return null;
    }
    if (spec.type.toLowerCase() == p3.type.toLowerCase()) {
      s3 |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p3.subtype.toLowerCase()) {
      s3 |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k3) {
        return spec.params[k3] == "*" || (spec.params[k3] || "").toLowerCase() == (p3.params[k3] || "").toLowerCase();
      })) {
        s3 |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s3
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a2, b2) {
    return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string4) {
    var count = 0;
    var index = 0;
    while ((index = string4.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str2) {
    var index = str2.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str2;
    } else {
      key = str2.substr(0, index);
      val = str2.substr(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(",");
    for (var i2 = 1, j2 = 0;i2 < accepts.length; i2++) {
      if (quoteCount(accepts[j2]) % 2 == 0) {
        accepts[++j2] = accepts[i2];
      } else {
        accepts[j2] += "," + accepts[i2];
      }
    }
    accepts.length = j2 + 1;
    return accepts;
  }
  function splitParameters(str2) {
    var parameters2 = str2.split(";");
    for (var i2 = 1, j2 = 0;i2 < parameters2.length; i2++) {
      if (quoteCount(parameters2[j2]) % 2 == 0) {
        parameters2[++j2] = parameters2[i2];
      } else {
        parameters2[j2] += ";" + parameters2[i2];
      }
    }
    parameters2.length = j2 + 1;
    for (var i2 = 0;i2 < parameters2.length; i2++) {
      parameters2[i2] = parameters2[i2].trim();
    }
    return parameters2;
  }
});

// ../../../../node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports, module) => {
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var preferredCharsets = require_charset();
  var preferredEncodings = require_encoding();
  var preferredLanguages = require_language();
  var preferredMediaTypes = require_mediaType();
  module.exports = Negotiator;
  module.exports.Negotiator = Negotiator;
  function Negotiator(request2) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request2);
    }
    this.request = request2;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
});

// ../../../../node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// ../../../../node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// ../../../../node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db2 = require_mime_db();
  var extname2 = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension2;
  exports.extensions = Object.create(null);
  exports.lookup = lookup3;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db2[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime = str2.indexOf("/") === -1 ? exports.lookup(str2) : str2;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension2(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup3(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension3 = extname2("x." + path3).toLowerCase().substr(1);
    if (!extension3) {
      return false;
    }
    return exports.types[extension3] || false;
  }
  function populateMaps(extensions2, types6) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db2).forEach(function forEachMimeType(type) {
      var mime = db2[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions2[type] = exts;
      for (var i2 = 0;i2 < exts.length; i2++) {
        var extension3 = exts[i2];
        if (types6[extension3]) {
          var from2 = preference.indexOf(db2[types6[extension3]].source);
          var to = preference.indexOf(mime.source);
          if (types6[extension3] !== "application/octet-stream" && (from2 > to || from2 === to && types6[extension3].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types6[extension3] = type;
      }
    });
  }
});

// ../../../../node_modules/accepts/index.js
var require_accepts = __commonJS((exports, module) => {
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Negotiator = require_negotiator();
  var mime = require_mime_types();
  module.exports = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types6 = types_;
    if (types6 && !Array.isArray(types6)) {
      types6 = new Array(arguments.length);
      for (var i2 = 0;i2 < types6.length; i2++) {
        types6[i2] = arguments[i2];
      }
    }
    if (!types6 || types6.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types6[0];
    }
    var mimes = types6.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types6[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i2 = 0;i2 < encodings.length; i2++) {
        encodings[i2] = arguments[i2];
      }
    }
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i2 = 0;i2 < charsets.length; i2++) {
        charsets[i2] = arguments[i2];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i2 = 0;i2 < languages.length; i2++) {
        languages[i2] = arguments[i2];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type) {
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function validMime(type) {
    return typeof type === "string";
  }
});

// ../../../../node_modules/base64id/lib/base64id.js
var require_base64id = __commonJS((exports, module) => {
  /*!
   * base64id v0.1.0
   */
  var crypto2 = __require("crypto");
  var Base64Id = function() {};
  Base64Id.prototype.getRandomBytes = function(bytes2) {
    var BUFFER_SIZE = 4096;
    var self2 = this;
    bytes2 = bytes2 || 12;
    if (bytes2 > BUFFER_SIZE) {
      return crypto2.randomBytes(bytes2);
    }
    var bytesInBuffer = parseInt(BUFFER_SIZE / bytes2);
    var threshold = parseInt(bytesInBuffer * 0.85);
    if (!threshold) {
      return crypto2.randomBytes(bytes2);
    }
    if (this.bytesBufferIndex == null) {
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == bytesInBuffer) {
      this.bytesBuffer = null;
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
      if (!this.isGeneratingBytes) {
        this.isGeneratingBytes = true;
        crypto2.randomBytes(BUFFER_SIZE, function(err, bytes3) {
          self2.bytesBuffer = bytes3;
          self2.bytesBufferIndex = 0;
          self2.isGeneratingBytes = false;
        });
      }
      if (this.bytesBufferIndex == -1) {
        return crypto2.randomBytes(bytes2);
      }
    }
    var result2 = this.bytesBuffer.slice(bytes2 * this.bytesBufferIndex, bytes2 * (this.bytesBufferIndex + 1));
    this.bytesBufferIndex++;
    return result2;
  };
  Base64Id.prototype.generateId = function() {
    var rand = Buffer.alloc(15);
    if (!rand.writeInt32BE) {
      return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
    }
    this.sequenceNumber = this.sequenceNumber + 1 | 0;
    rand.writeInt32BE(this.sequenceNumber, 11);
    if (crypto2.randomBytes) {
      this.getRandomBytes(12).copy(rand);
    } else {
      [0, 4, 8].forEach(function(i2) {
        rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i2);
      });
    }
    return rand.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
  };
  exports = module.exports = new Base64Id;
});

// ../../../../node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = undefined;
  var PACKET_TYPES = Object.create(null);
  exports.PACKET_TYPES = PACKET_TYPES;
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  var PACKET_TYPES_REVERSE = Object.create(null);
  exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  var ERROR_PACKET = { type: "error", data: "parser error" };
  exports.ERROR_PACKET = ERROR_PACKET;
});

// ../../../../node_modules/engine.io-parser/build/cjs/encodePacket.js
var require_encodePacket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodePacket = undefined;
  exports.encodePacketToBinary = encodePacketToBinary;
  var commons_js_1 = require_commons();
  var encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
      return callback(supportsBinary ? data : "b" + toBuffer2(data, true).toString("base64"));
    }
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
  };
  exports.encodePacket = encodePacket;
  var toBuffer2 = (data, forceBufferConversion) => {
    if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return Buffer.from(data);
    } else {
      return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
  };
  var TEXT_ENCODER;
  function encodePacketToBinary(packet, callback) {
    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
      return callback(toBuffer2(packet.data, false));
    }
    (0, exports.encodePacket)(packet, true, (encoded) => {
      if (!TEXT_ENCODER) {
        TEXT_ENCODER = new TextEncoder;
      }
      callback(TEXT_ENCODER.encode(encoded));
    });
  }
});

// ../../../../node_modules/engine.io-parser/build/cjs/decodePacket.js
var require_decodePacket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodePacket = undefined;
  var commons_js_1 = require_commons();
  var decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
      const buffer = Buffer.from(encodedPacket.substring(1), "base64");
      return {
        type: "message",
        data: mapBinary(buffer, binaryType)
      };
    }
    if (!commons_js_1.PACKET_TYPES_REVERSE[type]) {
      return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: commons_js_1.PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: commons_js_1.PACKET_TYPES_REVERSE[type]
    };
  };
  exports.decodePacket = decodePacket;
  var mapBinary = (data, binaryType) => {
    switch (binaryType) {
      case "arraybuffer":
        if (data instanceof ArrayBuffer) {
          return data;
        } else if (Buffer.isBuffer(data)) {
          return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
        } else {
          return data.buffer;
        }
      case "nodebuffer":
      default:
        if (Buffer.isBuffer(data)) {
          return data;
        } else {
          return Buffer.from(data);
        }
    }
  };
});

// ../../../../node_modules/engine.io-parser/build/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = undefined;
  exports.createPacketEncoderStream = createPacketEncoderStream;
  exports.createPacketDecoderStream = createPacketDecoderStream;
  var encodePacket_js_1 = require_encodePacket();
  Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function() {
    return encodePacket_js_1.encodePacket;
  } });
  var decodePacket_js_1 = require_decodePacket();
  Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function() {
    return decodePacket_js_1.decodePacket;
  } });
  var commons_js_1 = require_commons();
  var SEPARATOR = String.fromCharCode(30);
  var encodePayload = (packets, callback) => {
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i2) => {
      (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
        encodedPackets[i2] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };
  exports.encodePayload = encodePayload;
  var decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i2 = 0;i2 < encodedPackets.length; i2++) {
      const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i2], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  exports.decodePayload = decodePayload;
  function createPacketEncoderStream() {
    return new TransformStream({
      transform(packet, controller) {
        (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
          const payloadLength = encodedPacket.length;
          let header;
          if (payloadLength < 126) {
            header = new Uint8Array(1);
            new DataView(header.buffer).setUint8(0, payloadLength);
          } else if (payloadLength < 65536) {
            header = new Uint8Array(3);
            const view = new DataView(header.buffer);
            view.setUint8(0, 126);
            view.setUint16(1, payloadLength);
          } else {
            header = new Uint8Array(9);
            const view = new DataView(header.buffer);
            view.setUint8(0, 127);
            view.setBigUint64(1, BigInt(payloadLength));
          }
          if (packet.data && typeof packet.data !== "string") {
            header[0] |= 128;
          }
          controller.enqueue(header);
          controller.enqueue(encodedPacket);
        });
      }
    });
  }
  var TEXT_DECODER2;
  function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
  }
  function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
      return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j2 = 0;
    for (let i2 = 0;i2 < size; i2++) {
      buffer[i2] = chunks[0][j2++];
      if (j2 === chunks[0].length) {
        chunks.shift();
        j2 = 0;
      }
    }
    if (chunks.length && j2 < chunks[0].length) {
      chunks[0] = chunks[0].slice(j2);
    }
    return buffer;
  }
  function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER2) {
      TEXT_DECODER2 = new TextDecoder;
    }
    const chunks = [];
    let state = 0;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
      transform(chunk, controller) {
        chunks.push(chunk);
        while (true) {
          if (state === 0) {
            if (totalLength(chunks) < 1) {
              break;
            }
            const header = concatChunks(chunks, 1);
            isBinary = (header[0] & 128) === 128;
            expectedLength = header[0] & 127;
            if (expectedLength < 126) {
              state = 3;
            } else if (expectedLength === 126) {
              state = 1;
            } else {
              state = 2;
            }
          } else if (state === 1) {
            if (totalLength(chunks) < 2) {
              break;
            }
            const headerArray = concatChunks(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state = 3;
          } else if (state === 2) {
            if (totalLength(chunks) < 8) {
              break;
            }
            const headerArray = concatChunks(chunks, 8);
            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
            const n4 = view.getUint32(0);
            if (n4 > Math.pow(2, 53 - 32) - 1) {
              controller.enqueue(commons_js_1.ERROR_PACKET);
              break;
            }
            expectedLength = n4 * Math.pow(2, 32) + view.getUint32(4);
            state = 3;
          } else {
            if (totalLength(chunks) < expectedLength) {
              break;
            }
            const data = concatChunks(chunks, expectedLength);
            controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER2.decode(data), binaryType));
            state = 0;
          }
          if (expectedLength === 0 || expectedLength > maxPayload) {
            controller.enqueue(commons_js_1.ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  exports.protocol = 4;
});

// ../../../../node_modules/engine.io/build/parser-v3/utf8.js
var require_utf82 = __commonJS((exports, module) => {
  /*! https://mths.be/utf8js v2.1.2 by @mathias */
  var stringFromCharCode2 = String.fromCharCode;
  function ucs2decode2(string4) {
    var output2 = [];
    var counter = 0;
    var length = string4.length;
    var value;
    var extra;
    while (counter < length) {
      value = string4.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = string4.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output2.push(value);
          counter--;
        }
      } else {
        output2.push(value);
      }
    }
    return output2;
  }
  function ucs2encode(array) {
    var length = array.length;
    var index = -1;
    var value;
    var output2 = "";
    while (++index < length) {
      value = array[index];
      if (value > 65535) {
        value -= 65536;
        output2 += stringFromCharCode2(value >>> 10 & 1023 | 55296);
        value = 56320 | value & 1023;
      }
      output2 += stringFromCharCode2(value);
    }
    return output2;
  }
  function checkScalarValue(codePoint, strict) {
    if (codePoint >= 55296 && codePoint <= 57343) {
      if (strict) {
        throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
      }
      return false;
    }
    return true;
  }
  function createByte(codePoint, shift) {
    return stringFromCharCode2(codePoint >> shift & 63 | 128);
  }
  function encodeCodePoint(codePoint, strict) {
    if ((codePoint & 4294967168) == 0) {
      return stringFromCharCode2(codePoint);
    }
    var symbol = "";
    if ((codePoint & 4294965248) == 0) {
      symbol = stringFromCharCode2(codePoint >> 6 & 31 | 192);
    } else if ((codePoint & 4294901760) == 0) {
      if (!checkScalarValue(codePoint, strict)) {
        codePoint = 65533;
      }
      symbol = stringFromCharCode2(codePoint >> 12 & 15 | 224);
      symbol += createByte(codePoint, 6);
    } else if ((codePoint & 4292870144) == 0) {
      symbol = stringFromCharCode2(codePoint >> 18 & 7 | 240);
      symbol += createByte(codePoint, 12);
      symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode2(codePoint & 63 | 128);
    return symbol;
  }
  function utf8encode(string4, opts) {
    opts = opts || {};
    var strict = opts.strict !== false;
    var codePoints = ucs2decode2(string4);
    var length = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = "";
    while (++index < length) {
      codePoint = codePoints[index];
      byteString += encodeCodePoint(codePoint, strict);
    }
    return byteString;
  }
  function readContinuationByte() {
    if (byteIndex >= byteCount) {
      throw Error("Invalid byte index");
    }
    var continuationByte = byteArray[byteIndex] & 255;
    byteIndex++;
    if ((continuationByte & 192) == 128) {
      return continuationByte & 63;
    }
    throw Error("Invalid continuation byte");
  }
  function decodeSymbol(strict) {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;
    if (byteIndex > byteCount) {
      throw Error("Invalid byte index");
    }
    if (byteIndex == byteCount) {
      return false;
    }
    byte1 = byteArray[byteIndex] & 255;
    byteIndex++;
    if ((byte1 & 128) == 0) {
      return byte1;
    }
    if ((byte1 & 224) == 192) {
      byte2 = readContinuationByte();
      codePoint = (byte1 & 31) << 6 | byte2;
      if (codePoint >= 128) {
        return codePoint;
      } else {
        throw Error("Invalid continuation byte");
      }
    }
    if ((byte1 & 240) == 224) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
      if (codePoint >= 2048) {
        return checkScalarValue(codePoint, strict) ? codePoint : 65533;
      } else {
        throw Error("Invalid continuation byte");
      }
    }
    if ((byte1 & 248) == 240) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      byte4 = readContinuationByte();
      codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (codePoint >= 65536 && codePoint <= 1114111) {
        return codePoint;
      }
    }
    throw Error("Invalid UTF-8 detected");
  }
  var byteArray;
  var byteCount;
  var byteIndex;
  function utf8decode(byteString, opts) {
    opts = opts || {};
    var strict = opts.strict !== false;
    byteArray = ucs2decode2(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol(strict)) !== false) {
      codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
  }
  module.exports = {
    version: "2.1.2",
    encode: utf8encode,
    decode: utf8decode
  };
});

// ../../../../node_modules/engine.io/build/parser-v3/index.js
var require_parser_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.packets = exports.protocol = undefined;
  exports.encodePacket = encodePacket;
  exports.encodeBase64Packet = encodeBase64Packet;
  exports.decodePacket = decodePacket;
  exports.decodeBase64Packet = decodeBase64Packet;
  exports.encodePayload = encodePayload;
  exports.decodePayload = decodePayload;
  exports.encodePayloadAsBinary = encodePayloadAsBinary;
  exports.decodePayloadAsBinary = decodePayloadAsBinary;
  var utf8 = require_utf82();
  exports.protocol = 3;
  var hasBinary = (packets) => {
    for (const packet of packets) {
      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return true;
      }
    }
    return false;
  };
  exports.packets = {
    open: 0,
    close: 1,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = Object.keys(exports.packets);
  var err = { type: "error", data: "parser error" };
  var EMPTY_BUFFER2 = Buffer.concat([]);
  function encodePacket(packet, supportsBinary, utf8encode, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (typeof utf8encode === "function") {
      callback = utf8encode;
      utf8encode = null;
    }
    if (Buffer.isBuffer(packet.data)) {
      return encodeBuffer(packet, supportsBinary, callback);
    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
      return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
    }
    var encoded = exports.packets[packet.type];
    if (packet.data !== undefined) {
      encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
    }
    return callback("" + encoded);
  }
  function encodeBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return encodeBase64Packet(packet, callback);
    }
    var data = packet.data;
    var typeBuffer = Buffer.allocUnsafe(1);
    typeBuffer[0] = exports.packets[packet.type];
    return callback(Buffer.concat([typeBuffer, data]));
  }
  function encodeBase64Packet(packet, callback) {
    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
    var message = "b" + exports.packets[packet.type];
    message += data.toString("base64");
    return callback(message);
  }
  function decodePacket(data, binaryType, utf8decode) {
    if (data === undefined) {
      return err;
    }
    var type;
    if (typeof data === "string") {
      type = data.charAt(0);
      if (type === "b") {
        return decodeBase64Packet(data.slice(1), binaryType);
      }
      if (utf8decode) {
        data = tryDecode(data);
        if (data === false) {
          return err;
        }
      }
      if (Number(type) != type || !packetslist[type]) {
        return err;
      }
      if (data.length > 1) {
        return { type: packetslist[type], data: data.slice(1) };
      } else {
        return { type: packetslist[type] };
      }
    }
    if (binaryType === "arraybuffer") {
      var intArray = new Uint8Array(data);
      type = intArray[0];
      return { type: packetslist[type], data: intArray.buffer.slice(1) };
    }
    if (data instanceof ArrayBuffer) {
      data = arrayBufferToBuffer(data);
    }
    type = data[0];
    return { type: packetslist[type], data: data.slice(1) };
  }
  function tryDecode(data) {
    try {
      data = utf8.decode(data, { strict: false });
    } catch (e3) {
      return false;
    }
    return data;
  }
  function decodeBase64Packet(msg, binaryType) {
    var type = packetslist[msg.charAt(0)];
    var data = Buffer.from(msg.slice(1), "base64");
    if (binaryType === "arraybuffer") {
      var abv = new Uint8Array(data.length);
      for (var i2 = 0;i2 < abv.length; i2++) {
        abv[i2] = data[i2];
      }
      data = abv.buffer;
    }
    return { type, data };
  }
  function encodePayload(packets, supportsBinary, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (supportsBinary && hasBinary(packets)) {
      return encodePayloadAsBinary(packets, callback);
    }
    if (!packets.length) {
      return callback("0:");
    }
    function encodeOne(packet, doneCallback) {
      encodePacket(packet, supportsBinary, false, function(message) {
        doneCallback(null, setLengthHeader(message));
      });
    }
    map3(packets, encodeOne, function(err2, results) {
      return callback(results.join(""));
    });
  }
  function setLengthHeader(message) {
    return message.length + ":" + message;
  }
  function map3(ary, each, done) {
    const results = new Array(ary.length);
    let count = 0;
    for (let i2 = 0;i2 < ary.length; i2++) {
      each(ary[i2], (error2, msg) => {
        results[i2] = msg;
        if (++count === ary.length) {
          done(null, results);
        }
      });
    }
  }
  function decodePayload(data, binaryType, callback) {
    if (typeof data !== "string") {
      return decodePayloadAsBinary(data, binaryType, callback);
    }
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    if (data === "") {
      return callback(err, 0, 1);
    }
    var length = "", n4, msg, packet;
    for (var i2 = 0, l3 = data.length;i2 < l3; i2++) {
      var chr = data.charAt(i2);
      if (chr !== ":") {
        length += chr;
        continue;
      }
      if (length === "" || length != (n4 = Number(length))) {
        return callback(err, 0, 1);
      }
      msg = data.slice(i2 + 1, i2 + 1 + n4);
      if (length != msg.length) {
        return callback(err, 0, 1);
      }
      if (msg.length) {
        packet = decodePacket(msg, binaryType, false);
        if (err.type === packet.type && err.data === packet.data) {
          return callback(err, 0, 1);
        }
        var more = callback(packet, i2 + n4, l3);
        if (more === false)
          return;
      }
      i2 += n4;
      length = "";
    }
    if (length !== "") {
      return callback(err, 0, 1);
    }
  }
  function bufferToString(buffer) {
    var str2 = "";
    for (var i2 = 0, l3 = buffer.length;i2 < l3; i2++) {
      str2 += String.fromCharCode(buffer[i2]);
    }
    return str2;
  }
  function stringToBuffer(string4) {
    var buf = Buffer.allocUnsafe(string4.length);
    for (var i2 = 0, l3 = string4.length;i2 < l3; i2++) {
      buf.writeUInt8(string4.charCodeAt(i2), i2);
    }
    return buf;
  }
  function arrayBufferToBuffer(data) {
    var length = data.byteLength || data.length;
    var offset = data.byteOffset || 0;
    return Buffer.from(data.buffer || data, offset, length);
  }
  function encodePayloadAsBinary(packets, callback) {
    if (!packets.length) {
      return callback(EMPTY_BUFFER2);
    }
    map3(packets, encodeOneBinaryPacket, function(err2, results) {
      return callback(Buffer.concat(results));
    });
  }
  function encodeOneBinaryPacket(p3, doneCallback) {
    function onBinaryPacketEncode(packet) {
      var encodingLength = "" + packet.length;
      var sizeBuffer;
      if (typeof packet === "string") {
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 0;
        for (var i2 = 0;i2 < encodingLength.length; i2++) {
          sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
      }
      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
      sizeBuffer[0] = 1;
      for (var i2 = 0;i2 < encodingLength.length; i2++) {
        sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
      }
      sizeBuffer[sizeBuffer.length - 1] = 255;
      doneCallback(null, Buffer.concat([sizeBuffer, packet]));
    }
    encodePacket(p3, true, true, onBinaryPacketEncode);
  }
  function decodePayloadAsBinary(data, binaryType, callback) {
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    var bufferTail = data;
    var buffers = [];
    var i2;
    while (bufferTail.length > 0) {
      var strLen = "";
      var isString2 = bufferTail[0] === 0;
      for (i2 = 1;; i2++) {
        if (bufferTail[i2] === 255)
          break;
        if (strLen.length > 310) {
          return callback(err, 0, 1);
        }
        strLen += "" + bufferTail[i2];
      }
      bufferTail = bufferTail.slice(strLen.length + 1);
      var msgLength = parseInt(strLen, 10);
      var msg = bufferTail.slice(1, msgLength + 1);
      if (isString2)
        msg = bufferToString(msg);
      buffers.push(msg);
      bufferTail = bufferTail.slice(msgLength + 1);
    }
    var total = buffers.length;
    for (i2 = 0;i2 < total; i2++) {
      var buffer = buffers[i2];
      callback(decodePacket(buffer, binaryType, true), i2, total);
    }
  }
});

// ../../../../node_modules/engine.io/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace2.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace2;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace2);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace2, delimiter2) {
      const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0;i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name3) {
      if (name3[name3.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length;i2 < len; i2++) {
        if (createDebug.skips[i2].test(name3)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length;i2 < len; i2++) {
        if (createDebug.names[i2].test(name3)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../../../node_modules/engine.io/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned2 = false;
    return () => {
      if (!warned2) {
        warned2 = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m3;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c4 = "color: " + this.color;
    args.splice(1, 0, c4, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c4);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r4;
    try {
      r4 = exports.storage.getItem("debug");
    } catch (error2) {}
    if (!r4 && typeof process !== "undefined" && "env" in process) {
      r4 = process.env.DEBUG;
    }
    return r4;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../../../node_modules/engine.io/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util2 = __require("util");
  exports.init = init2;
  exports.log = log4;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (init_supports_color(), __toCommonJS(exports_supports_color));
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
      return k3.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name3, useColors: useColors2 } = this;
    if (useColors2) {
      const c4 = this.color;
      const colorCode = "\x1B[3" + (c4 < 8 ? c4 : "8;5;" + c4);
      const prefix2 = `  ${colorCode};1m${name3} \x1B[0m`;
      args[0] = prefix2 + args[0].split(`
`).join(`
` + prefix2);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name3 + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map((str2) => str2.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// ../../../../node_modules/engine.io/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser2();
  } else {
    module.exports = require_node();
  }
});

// ../../../../node_modules/engine.io/build/transport.js
var require_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transport = undefined;
  var events_1 = __require("events");
  var parser_v4 = require_cjs();
  var parser_v3 = require_parser_v3();
  var debug_1 = require_src();
  var debug = (0, debug_1.default)("engine:transport");
  function noop2() {}

  class Transport extends events_1.EventEmitter {
    get readyState() {
      return this._readyState;
    }
    set readyState(state) {
      debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
      this._readyState = state;
    }
    constructor(req) {
      super();
      this.writable = false;
      this._readyState = "open";
      this.discarded = false;
      this.protocol = req._query.EIO === "4" ? 4 : 3;
      this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
      this.supportsBinary = !(req._query && req._query.b64);
    }
    discard() {
      this.discarded = true;
    }
    onRequest(req) {}
    close(fn2) {
      if (this.readyState === "closed" || this.readyState === "closing")
        return;
      this.readyState = "closing";
      this.doClose(fn2 || noop2);
    }
    onError(msg, desc) {
      if (this.listeners("error").length) {
        const err = new Error(msg);
        err.type = "TransportError";
        err.description = desc;
        this.emit("error", err);
      } else {
        debug("ignored transport error %s (%s)", msg, desc);
      }
    }
    onPacket(packet) {
      this.emit("packet", packet);
    }
    onData(data) {
      this.onPacket(this.parser.decodePacket(data));
    }
    onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }
  exports.Transport = Transport;
});

// ../../../../node_modules/engine.io/build/transports/polling.js
var require_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var transport_1 = require_transport();
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var debug_1 = require_src();
  var debug = (0, debug_1.default)("engine:polling");
  var compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate
  };

  class Polling extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.closeTimeout = 30 * 1000;
    }
    get name() {
      return "polling";
    }
    onRequest(req) {
      const res = req.res;
      req.res = null;
      if (req.method === "GET") {
        this.onPollRequest(req, res);
      } else if (req.method === "POST") {
        this.onDataRequest(req, res);
      } else {
        res.writeHead(500);
        res.end();
      }
    }
    onPollRequest(req, res) {
      if (this.req) {
        debug("request overlap");
        this.onError("overlap from client");
        res.writeHead(400);
        res.end();
        return;
      }
      debug("setting request");
      this.req = req;
      this.res = res;
      const onClose = () => {
        this.onError("poll connection closed prematurely");
      };
      const cleanup2 = () => {
        req.removeListener("close", onClose);
        this.req = this.res = null;
      };
      req.cleanup = cleanup2;
      req.on("close", onClose);
      this.writable = true;
      this.emit("ready");
      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{ type: "noop" }]);
      }
    }
    onDataRequest(req, res) {
      if (this.dataReq) {
        this.onError("data request overlap from client");
        res.writeHead(400);
        res.end();
        return;
      }
      const isBinary = req.headers["content-type"] === "application/octet-stream";
      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }
      this.dataReq = req;
      this.dataRes = res;
      let chunks = isBinary ? Buffer.concat([]) : "";
      const cleanup2 = () => {
        req.removeListener("data", onData);
        req.removeListener("end", onEnd);
        req.removeListener("close", onClose);
        this.dataReq = this.dataRes = chunks = null;
      };
      const onClose = () => {
        cleanup2();
        this.onError("data request connection closed prematurely");
      };
      const onData = (data) => {
        let contentLength;
        if (isBinary) {
          chunks = Buffer.concat([chunks, data]);
          contentLength = chunks.length;
        } else {
          chunks += data;
          contentLength = Buffer.byteLength(chunks);
        }
        if (contentLength > this.maxHttpBufferSize) {
          res.writeHead(413).end();
          cleanup2();
        }
      };
      const onEnd = () => {
        this.onData(chunks);
        const headers = {
          "Content-Type": "text/html",
          "Content-Length": "2"
        };
        res.writeHead(200, this.headers(req, headers));
        res.end("ok");
        cleanup2();
      };
      req.on("close", onClose);
      if (!isBinary)
        req.setEncoding("utf8");
      req.on("data", onData);
      req.on("end", onEnd);
    }
    onData(data) {
      debug('received "%s"', data);
      const callback = (packet) => {
        if (packet.type === "close") {
          debug("got xhr close packet");
          this.onClose();
          return false;
        }
        this.onPacket(packet);
      };
      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    onClose() {
      if (this.writable) {
        this.send([{ type: "noop" }]);
      }
      super.onClose();
    }
    send(packets) {
      this.writable = false;
      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({ type: "close" });
        this.shouldClose();
        this.shouldClose = null;
      }
      const doWrite = (data) => {
        const compress = packets.some((packet) => {
          return packet.options && packet.options.compress;
        });
        this.write(data, { compress });
      };
      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    write(data, options3) {
      debug('writing "%s"', data);
      this.doWrite(data, options3, () => {
        this.req.cleanup();
        this.emit("drain");
      });
    }
    doWrite(data, options3, callback) {
      const isString2 = typeof data === "string";
      const contentType = isString2 ? "text/plain; charset=UTF-8" : "application/octet-stream";
      const headers = {
        "Content-Type": contentType
      };
      const respond = (data2) => {
        headers["Content-Length"] = typeof data2 === "string" ? Buffer.byteLength(data2) : data2.length;
        this.res.writeHead(200, this.headers(this.req, headers));
        this.res.end(data2);
        callback();
      };
      if (!this.httpCompression || !options3.compress) {
        respond(data);
        return;
      }
      const len = isString2 ? Buffer.byteLength(data) : data.length;
      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }
      const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
      if (!encoding) {
        respond(data);
        return;
      }
      this.compress(data, encoding, (err, data2) => {
        if (err) {
          this.res.writeHead(500);
          this.res.end();
          callback(err);
          return;
        }
        headers["Content-Encoding"] = encoding;
        respond(data2);
      });
    }
    compress(data, encoding, callback) {
      debug("compressing");
      const buffers = [];
      let nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function() {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    doClose(fn2) {
      debug("closing");
      let closeTimeoutTimer;
      if (this.dataReq) {
        debug("aborting ongoing data request");
        this.dataReq.destroy();
      }
      const onClose = () => {
        clearTimeout(closeTimeoutTimer);
        fn2();
        this.onClose();
      };
      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{ type: "close" }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    headers(req, headers = {}) {
      const ua2 = req.headers["user-agent"];
      if (ua2 && (~ua2.indexOf(";MSIE") || ~ua2.indexOf("Trident/"))) {
        headers["X-XSS-Protection"] = "0";
      }
      headers["cache-control"] = "no-store";
      this.emit("headers", headers, req);
      return headers;
    }
  }
  exports.Polling = Polling;
});

// ../../../../node_modules/engine.io/build/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSONP = undefined;
  var polling_1 = require_polling();
  var qs2 = __require("querystring");
  var rDoubleSlashes = /\\\\n/g;
  var rSlashes = /(\\)?\\n/g;

  class JSONP extends polling_1.Polling {
    constructor(req) {
      super(req);
      this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
      this.foot = ");";
    }
    onData(data) {
      data = qs2.parse(data).d;
      if (typeof data === "string") {
        data = data.replace(rSlashes, function(match, slashes) {
          return slashes ? match : `
`;
        });
        super.onData(data.replace(rDoubleSlashes, "\\n"));
      }
    }
    doWrite(data, options3, callback) {
      const js3 = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      data = this.head + js3 + this.foot;
      super.doWrite(data, options3, callback);
    }
  }
  exports.JSONP = JSONP;
});

// ../../../../node_modules/engine.io/build/transports/websocket.js
var require_websocket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebSocket = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var debug = (0, debug_1.default)("engine:ws");

  class WebSocket extends transport_1.Transport {
    constructor(req) {
      super(req);
      this._doSend = (data) => {
        this.socket.send(data, this._onSent);
      };
      this._doSendLast = (data) => {
        this.socket.send(data, this._onSentLast);
      };
      this._onSent = (err) => {
        if (err) {
          this.onError("write error", err.stack);
        }
      };
      this._onSentLast = (err) => {
        if (err) {
          this.onError("write error", err.stack);
        } else {
          this.emit("drain");
          this.writable = true;
          this.emit("ready");
        }
      };
      this.socket = req.websocket;
      this.socket.on("message", (data, isBinary) => {
        const message = isBinary ? data : data.toString();
        debug('received "%s"', message);
        super.onData(message);
      });
      this.socket.once("close", this.onClose.bind(this));
      this.socket.on("error", this.onError.bind(this));
      this.writable = true;
      this.perMessageDeflate = null;
    }
    get name() {
      return "websocket";
    }
    get handlesUpgrades() {
      return true;
    }
    send(packets) {
      this.writable = false;
      for (let i2 = 0;i2 < packets.length; i2++) {
        const packet = packets[i2];
        const isLast = i2 + 1 === packets.length;
        if (this._canSendPreEncodedFrame(packet)) {
          this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);
        } else {
          this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);
        }
      }
    }
    _canSendPreEncodedFrame(packet) {
      var _a4, _b3, _c;
      return !this.perMessageDeflate && typeof ((_b3 = (_a4 = this.socket) === null || _a4 === undefined ? undefined : _a4._sender) === null || _b3 === undefined ? undefined : _b3.sendFrame) === "function" && ((_c = packet.options) === null || _c === undefined ? undefined : _c.wsPreEncodedFrame) !== undefined;
    }
    doClose(fn2) {
      debug("closing");
      this.socket.close();
      fn2 && fn2();
    }
  }
  exports.WebSocket = WebSocket;
});

// ../../../../node_modules/engine.io/build/transports/webtransport.js
var require_webtransport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebTransport = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var engine_io_parser_1 = require_cjs();
  var debug = (0, debug_1.default)("engine:webtransport");

  class WebTransport extends transport_1.Transport {
    constructor(session, stream, reader) {
      super({ _query: { EIO: "4" } });
      this.session = session;
      const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
      transformStream.readable.pipeTo(stream.writable).catch(() => {
        debug("the stream was closed");
      });
      this.writer = transformStream.writable.getWriter();
      (async () => {
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              debug("session is closed");
              break;
            }
            debug("received chunk: %o", value);
            this.onPacket(value);
          }
        } catch (e3) {
          debug("error while reading: %s", e3.message);
        }
      })();
      session.closed.then(() => this.onClose());
      this.writable = true;
    }
    get name() {
      return "webtransport";
    }
    async send(packets) {
      this.writable = false;
      try {
        for (let i2 = 0;i2 < packets.length; i2++) {
          const packet = packets[i2];
          await this.writer.write(packet);
        }
      } catch (e3) {
        debug("error while writing: %s", e3.message);
      }
      this.emit("drain");
      this.writable = true;
      this.emit("ready");
    }
    doClose(fn2) {
      debug("closing WebTransport session");
      this.session.close();
      fn2 && fn2();
    }
  }
  exports.WebTransport = WebTransport;
});

// ../../../../node_modules/engine.io/build/transports/index.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var polling_1 = require_polling();
  var polling_jsonp_1 = require_polling_jsonp();
  var websocket_1 = require_websocket();
  var webtransport_1 = require_webtransport();
  exports.default = {
    polling,
    websocket: websocket_1.WebSocket,
    webtransport: webtransport_1.WebTransport
  };
  function polling(req) {
    if (typeof req._query.j === "string") {
      return new polling_jsonp_1.JSONP(req);
    } else {
      return new polling_1.Polling(req);
    }
  }
  polling.upgradesTo = ["websocket", "webtransport"];
});

// ../../../../node_modules/engine.io/build/socket.js
var require_socket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Socket = undefined;
  var events_1 = __require("events");
  var debug_1 = require_src();
  var timers_1 = __require("timers");
  var debug = (0, debug_1.default)("engine:socket");

  class Socket extends events_1.EventEmitter {
    get readyState() {
      return this._readyState;
    }
    set readyState(state) {
      debug("readyState updated from %s to %s", this._readyState, state);
      this._readyState = state;
    }
    constructor(id3, server, transport, req, protocol) {
      super();
      this._readyState = "opening";
      this.upgrading = false;
      this.upgraded = false;
      this.writeBuffer = [];
      this.packetsFn = [];
      this.sentCallbackFn = [];
      this.cleanupFn = [];
      this.id = id3;
      this.server = server;
      this.request = req;
      this.protocol = protocol;
      if (req) {
        if (req.websocket && req.websocket._socket) {
          this.remoteAddress = req.websocket._socket.remoteAddress;
        } else {
          this.remoteAddress = req.connection.remoteAddress;
        }
      } else {}
      this.pingTimeoutTimer = null;
      this.pingIntervalTimer = null;
      this.setTransport(transport);
      this.onOpen();
    }
    onOpen() {
      this.readyState = "open";
      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout,
        maxPayload: this.server.opts.maxHttpBufferSize
      }));
      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }
      this.emit("open");
      if (this.protocol === 3) {
        this.resetPingTimeout();
      } else {
        this.schedulePing();
      }
    }
    onPacket(packet) {
      if (this.readyState !== "open") {
        return debug("packet received with closed socket");
      }
      debug(`received packet ${packet.type}`);
      this.emit("packet", packet);
      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError(new Error("invalid heartbeat direction"));
            return;
          }
          debug("got ping");
          this.pingTimeoutTimer.refresh();
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;
        case "pong":
          if (this.transport.protocol === 3) {
            this.onError(new Error("invalid heartbeat direction"));
            return;
          }
          debug("got pong");
          (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
          this.pingIntervalTimer.refresh();
          this.emit("heartbeat");
          break;
        case "error":
          this.onClose("parse error");
          break;
        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    onError(err) {
      debug("transport error");
      this.onClose("transport error", err);
    }
    schedulePing() {
      this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
        debug("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
        this.sendPacket("ping");
        this.resetPingTimeout();
      }, this.server.opts.pingInterval);
    }
    resetPingTimeout() {
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
        if (this.readyState === "closed")
          return;
        this.onClose("ping timeout");
      }, this.protocol === 3 ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);
    }
    setTransport(transport) {
      const onError = this.onError.bind(this);
      const onReady = () => this.flush();
      const onPacket = this.onPacket.bind(this);
      const onDrain = this.onDrain.bind(this);
      const onClose = this.onClose.bind(this, "transport close");
      this.transport = transport;
      this.transport.once("error", onError);
      this.transport.on("ready", onReady);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", onDrain);
      this.transport.once("close", onClose);
      this.cleanupFn.push(function() {
        transport.removeListener("error", onError);
        transport.removeListener("ready", onReady);
        transport.removeListener("packet", onPacket);
        transport.removeListener("drain", onDrain);
        transport.removeListener("close", onClose);
      });
    }
    onDrain() {
      if (this.sentCallbackFn.length > 0) {
        debug("executing batch send callback");
        const seqFn = this.sentCallbackFn.shift();
        if (seqFn) {
          for (let i2 = 0;i2 < seqFn.length; i2++) {
            seqFn[i2](this.transport);
          }
        }
      }
    }
    _maybeUpgrade(transport) {
      debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
      this.upgrading = true;
      const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
        debug("client did not complete upgrade - closing transport");
        cleanup2();
        if (transport.readyState === "open") {
          transport.close();
        }
      }, this.server.opts.upgradeTimeout);
      let checkIntervalTimer;
      const onPacket = (packet) => {
        if (packet.type === "ping" && packet.data === "probe") {
          debug("got probe ping packet, sending pong");
          transport.send([{ type: "pong", data: "probe" }]);
          this.emit("upgrading", transport);
          clearInterval(checkIntervalTimer);
          checkIntervalTimer = setInterval(check, 100);
        } else if (packet.type === "upgrade" && this.readyState !== "closed") {
          debug("got upgrade packet - upgrading");
          cleanup2();
          this.transport.discard();
          this.upgraded = true;
          this.clearTransport();
          this.setTransport(transport);
          this.emit("upgrade", transport);
          this.flush();
          if (this.readyState === "closing") {
            transport.close(() => {
              this.onClose("forced close");
            });
          }
        } else {
          cleanup2();
          transport.close();
        }
      };
      const check = () => {
        if (this.transport.name === "polling" && this.transport.writable) {
          debug("writing a noop packet to polling for fast upgrade");
          this.transport.send([{ type: "noop" }]);
        }
      };
      const cleanup2 = () => {
        this.upgrading = false;
        clearInterval(checkIntervalTimer);
        (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
        transport.removeListener("packet", onPacket);
        transport.removeListener("close", onTransportClose);
        transport.removeListener("error", onError);
        this.removeListener("close", onClose);
      };
      const onError = (err) => {
        debug("client did not complete upgrade - %s", err);
        cleanup2();
        transport.close();
        transport = null;
      };
      const onTransportClose = () => {
        onError("transport closed");
      };
      const onClose = () => {
        onError("socket closed");
      };
      transport.on("packet", onPacket);
      transport.once("close", onTransportClose);
      transport.once("error", onError);
      this.once("close", onClose);
    }
    clearTransport() {
      let cleanup2;
      const toCleanUp = this.cleanupFn.length;
      for (let i2 = 0;i2 < toCleanUp; i2++) {
        cleanup2 = this.cleanupFn.shift();
        cleanup2();
      }
      this.transport.on("error", function() {
        debug("error triggered by discarded transport");
      });
      this.transport.close();
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    onClose(reason, description) {
      if (this.readyState !== "closed") {
        this.readyState = "closed";
        (0, timers_1.clearTimeout)(this.pingIntervalTimer);
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        process.nextTick(() => {
          this.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    send(data, options3, callback) {
      this.sendPacket("message", data, options3, callback);
      return this;
    }
    write(data, options3, callback) {
      this.sendPacket("message", data, options3, callback);
      return this;
    }
    sendPacket(type, data, options3 = {}, callback) {
      if (typeof options3 === "function") {
        callback = options3;
        options3 = {};
      }
      if (this.readyState !== "closing" && this.readyState !== "closed") {
        debug('sending packet "%s" (%s)', type, data);
        options3.compress = options3.compress !== false;
        const packet = {
          type,
          options: options3
        };
        if (data)
          packet.data = data;
        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (typeof callback === "function")
          this.packetsFn.push(callback);
        this.flush();
      }
    }
    flush() {
      if (this.readyState !== "closed" && this.transport.writable && this.writeBuffer.length) {
        debug("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        const wbuf = this.writeBuffer;
        this.writeBuffer = [];
        if (this.packetsFn.length) {
          this.sentCallbackFn.push(this.packetsFn);
          this.packetsFn = [];
        } else {
          this.sentCallbackFn.push(null);
        }
        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    getAvailableUpgrades() {
      const availableUpgrades = [];
      const allUpgrades = this.server.upgrades(this.transport.name);
      for (let i2 = 0;i2 < allUpgrades.length; ++i2) {
        const upg = allUpgrades[i2];
        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }
      return availableUpgrades;
    }
    close(discard) {
      if (discard && (this.readyState === "open" || this.readyState === "closing")) {
        return this.closeTransport(discard);
      }
      if (this.readyState !== "open")
        return;
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
        this.once("drain", () => {
          debug("all packets have been sent, closing the transport");
          this.closeTransport(discard);
        });
        return;
      }
      debug("the buffer is empty, closing the transport right away");
      this.closeTransport(discard);
    }
    closeTransport(discard) {
      debug("closing the transport (discard? %s)", !!discard);
      if (discard)
        this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }
  exports.Socket = Socket;
});

// ../../../../node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse2;
  exports.serialize = serialize2;
  var __toString = Object.prototype.toString;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  function parse2(str2, opt) {
    if (typeof str2 !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var len = str2.length;
    if (len < 2)
      return obj;
    var dec = opt && opt.decode || decode2;
    var index = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
      eqIdx = str2.indexOf("=", index);
      if (eqIdx === -1)
        break;
      endIdx = str2.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = len;
      } else if (eqIdx > endIdx) {
        index = str2.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var keyStartIdx = startIndex(str2, index, eqIdx);
      var keyEndIdx = endIndex(str2, eqIdx, keyStartIdx);
      var key = str2.slice(keyStartIdx, keyEndIdx);
      if (!__hasOwnProperty.call(obj, key)) {
        var valStartIdx = startIndex(str2, eqIdx + 1, endIdx);
        var valEndIdx = endIndex(str2, endIdx, valStartIdx);
        if (str2.charCodeAt(valStartIdx) === 34 && str2.charCodeAt(valEndIdx - 1) === 34) {
          valStartIdx++;
          valEndIdx--;
        }
        var val = str2.slice(valStartIdx, valEndIdx);
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str2, index, max) {
    do {
      var code2 = str2.charCodeAt(index);
      if (code2 !== 32 && code2 !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str2, index, min) {
    while (index > min) {
      var code2 = str2.charCodeAt(--index);
      if (code2 !== 32 && code2 !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize2(name3, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!cookieNameRegExp.test(name3)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str2 = name3 + "=" + value;
    if (!opt)
      return str2;
    if (opt.maxAge != null) {
      var maxAge = Math.floor(opt.maxAge);
      if (!isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str2 += "; Max-Age=" + maxAge;
    }
    if (opt.domain) {
      if (!domainValueRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str2 += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!pathValueRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str2 += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate2(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str2 += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str2 += "; HttpOnly";
    }
    if (opt.secure) {
      str2 += "; Secure";
    }
    if (opt.partitioned) {
      str2 += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str2 += "; Priority=Low";
          break;
        case "medium":
          str2 += "; Priority=Medium";
          break;
        case "high":
          str2 += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str2 += "; SameSite=Strict";
          break;
        case "lax":
          str2 += "; SameSite=Lax";
          break;
        case "strict":
          str2 += "; SameSite=Strict";
          break;
        case "none":
          str2 += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str2;
  }
  function decode2(str2) {
    return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]";
  }
  function tryDecode(str2, decode3) {
    try {
      return decode3(str2);
    } catch (e3) {
      return str2;
    }
  }
});

// ../../../../node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module) => {
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0;i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n4) {
        return test2[n4];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols2;
    for (var s3 = 1;s3 < arguments.length; s3++) {
      from2 = Object(arguments[s3]);
      for (var key in from2) {
        if (hasOwnProperty2.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols2 = getOwnPropertySymbols(from2);
        for (var i2 = 0;i2 < symbols2.length; i2++) {
          if (propIsEnumerable.call(from2, symbols2[i2])) {
            to[symbols2[i2]] = from2[symbols2[i2]];
          }
        }
      }
    }
    return to;
  };
});

// ../../../../node_modules/vary/index.js
var require_vary = __commonJS((exports, module) => {
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse2(String(field)) : field;
    for (var j2 = 0;j2 < fields.length; j2++) {
      if (!FIELD_NAME_REGEXP.test(fields[j2])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse2(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i2 = 0;i2 < fields.length; i2++) {
      var fld = fields[i2].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i2] : fields[i2];
      }
    }
    return val;
  }
  function parse2(header) {
    var end = 0;
    var list2 = [];
    var start = 0;
    for (var i2 = 0, len = header.length;i2 < len; i2++) {
      switch (header.charCodeAt(i2)) {
        case 32:
          if (start === end) {
            start = end = i2 + 1;
          }
          break;
        case 44:
          list2.push(header.substring(start, end));
          start = end = i2 + 1;
          break;
        default:
          end = i2 + 1;
          break;
      }
    }
    list2.push(header.substring(start, end));
    return list2;
  }
  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
});

// ../../../../node_modules/cors/lib/index.js
var require_lib = __commonJS((exports, module) => {
  (function() {
    var assign2 = require_object_assign();
    var vary = require_vary();
    var defaults = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString2(s3) {
      return typeof s3 === "string" || s3 instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i2 = 0;i2 < allowedOrigin.length; ++i2) {
          if (isOriginAllowed(origin, allowedOrigin[i2])) {
            return true;
          }
        }
        return false;
      } else if (isString2(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options3, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options3.origin || options3.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString2(options3.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options3.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options3.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options3) {
      var methods = options3.methods;
      if (methods.join) {
        methods = options3.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods
      };
    }
    function configureCredentials(options3) {
      if (options3.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options3, req) {
      var allowedHeaders = options3.allowedHeaders || options3.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options3) {
      var headers = options3.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options3) {
      var maxAge = (typeof options3.maxAge === "number" || options3.maxAge) && options3.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i2 = 0, n4 = headers.length;i2 < n4; i2++) {
        var header = headers[i2];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options3, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options3, req));
        headers.push(configureCredentials(options3, req));
        headers.push(configureMethods(options3, req));
        headers.push(configureAllowedHeaders(options3, req));
        headers.push(configureMaxAge(options3, req));
        headers.push(configureExposedHeaders(options3, req));
        applyHeaders(headers, res);
        if (options3.preflightContinue) {
          next();
        } else {
          res.statusCode = options3.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options3, req));
        headers.push(configureCredentials(options3, req));
        headers.push(configureExposedHeaders(options3, req));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o3) {
      var optionsCallback = null;
      if (typeof o3 === "function") {
        optionsCallback = o3;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o3);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options3) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign2({}, defaults, options3);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    module.exports = middlewareWrapper;
  })();
});

// ../../../../node_modules/engine.io/build/server.js
var require_server2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = exports.BaseServer = undefined;
  var qs2 = __require("querystring");
  var url_1 = __require("url");
  var base64id = require_base64id();
  var transports_1 = require_transports();
  var events_1 = __require("events");
  var socket_1 = require_socket();
  var debug_1 = require_src();
  var cookie_1 = require_cookie();
  var ws_1 = __require("ws");
  var webtransport_1 = require_webtransport();
  var engine_io_parser_1 = require_cjs();
  var debug = (0, debug_1.default)("engine");
  var kResponseHeaders = Symbol("responseHeaders");
  function parseSessionId(data) {
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed.sid === "string") {
        return parsed.sid;
      }
    } catch (e3) {}
  }

  class BaseServer extends events_1.EventEmitter {
    constructor(opts = {}) {
      super();
      this.middlewares = [];
      this.clients = {};
      this.clientsCount = 0;
      this.opts = Object.assign({
        wsEngine: ws_1.Server,
        pingTimeout: 20000,
        pingInterval: 25000,
        upgradeTimeout: 1e4,
        maxHttpBufferSize: 1e6,
        transports: ["polling", "websocket"],
        allowUpgrades: true,
        httpCompression: {
          threshold: 1024
        },
        cors: false,
        allowEIO3: false
      }, opts);
      if (opts.cookie) {
        this.opts.cookie = Object.assign({
          name: "io",
          path: "/",
          httpOnly: opts.cookie.path !== false,
          sameSite: "lax"
        }, opts.cookie);
      }
      if (this.opts.cors) {
        this.use(require_lib()(this.opts.cors));
      }
      if (opts.perMessageDeflate) {
        this.opts.perMessageDeflate = Object.assign({
          threshold: 1024
        }, opts.perMessageDeflate);
      }
      this.init();
    }
    _computePath(options3) {
      let path3 = (options3.path || "/engine.io").replace(/\/$/, "");
      if (options3.addTrailingSlash !== false) {
        path3 += "/";
      }
      return path3;
    }
    upgrades(transport) {
      if (!this.opts.allowUpgrades)
        return [];
      return transports_1.default[transport].upgradesTo || [];
    }
    verify(req, upgrade, fn2) {
      const transport = req._query.transport;
      if (!~this.opts.transports.indexOf(transport) || transport === "webtransport") {
        debug('unknown transport "%s"', transport);
        return fn2(Server.errors.UNKNOWN_TRANSPORT, { transport });
      }
      const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
      if (isOriginInvalid) {
        const origin = req.headers.origin;
        req.headers.origin = null;
        debug("origin header invalid");
        return fn2(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin
        });
      }
      const sid = req._query.sid;
      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug('unknown sid "%s"', sid);
          return fn2(Server.errors.UNKNOWN_SID, {
            sid
          });
        }
        const previousTransport = this.clients[sid].transport.name;
        if (!upgrade && previousTransport !== transport) {
          debug("bad request: unexpected transport without upgrade");
          return fn2(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport,
            previousTransport
          });
        }
      } else {
        if (req.method !== "GET") {
          return fn2(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }
        if (transport === "websocket" && !upgrade) {
          debug("invalid transport upgrade");
          return fn2(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_HANDSHAKE_ERROR"
          });
        }
        if (!this.opts.allowRequest)
          return fn2();
        return this.opts.allowRequest(req, (message, success) => {
          if (!success) {
            return fn2(Server.errors.FORBIDDEN, {
              message
            });
          }
          fn2();
        });
      }
      fn2();
    }
    use(fn2) {
      this.middlewares.push(fn2);
    }
    _applyMiddlewares(req, res, callback) {
      if (this.middlewares.length === 0) {
        debug("no middleware to apply, skipping");
        return callback();
      }
      const apply2 = (i2) => {
        debug("applying middleware n\xB0%d", i2 + 1);
        this.middlewares[i2](req, res, (err) => {
          if (err) {
            return callback(err);
          }
          if (i2 + 1 < this.middlewares.length) {
            apply2(i2 + 1);
          } else {
            callback();
          }
        });
      };
      apply2(0);
    }
    close() {
      debug("closing all open clients");
      for (let i2 in this.clients) {
        if (this.clients.hasOwnProperty(i2)) {
          this.clients[i2].close(true);
        }
      }
      this.cleanup();
      return this;
    }
    generateId(req) {
      return base64id.generateId();
    }
    async handshake(transportName, req, closeConnection) {
      const protocol = req._query.EIO === "4" ? 4 : 3;
      if (protocol === 3 && !this.opts.allowEIO3) {
        debug("unsupported protocol version");
        this.emit("connection_error", {
          req,
          code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
          message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
          context: {
            protocol
          }
        });
        closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
        return;
      }
      let id3;
      try {
        id3 = await this.generateId(req);
      } catch (e3) {
        debug("error while generating an id");
        this.emit("connection_error", {
          req,
          code: Server.errors.BAD_REQUEST,
          message: Server.errorMessages[Server.errors.BAD_REQUEST],
          context: {
            name: "ID_GENERATION_ERROR",
            error: e3
          }
        });
        closeConnection(Server.errors.BAD_REQUEST);
        return;
      }
      debug('handshaking client "%s"', id3);
      try {
        var transport = this.createTransport(transportName, req);
        if (transportName === "polling") {
          transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
          transport.httpCompression = this.opts.httpCompression;
        } else if (transportName === "websocket") {
          transport.perMessageDeflate = this.opts.perMessageDeflate;
        }
      } catch (e3) {
        debug('error handshaking to transport "%s"', transportName);
        this.emit("connection_error", {
          req,
          code: Server.errors.BAD_REQUEST,
          message: Server.errorMessages[Server.errors.BAD_REQUEST],
          context: {
            name: "TRANSPORT_HANDSHAKE_ERROR",
            error: e3
          }
        });
        closeConnection(Server.errors.BAD_REQUEST);
        return;
      }
      const socket = new socket_1.Socket(id3, this, transport, req, protocol);
      transport.on("headers", (headers, req2) => {
        const isInitialRequest = !req2._query.sid;
        if (isInitialRequest) {
          if (this.opts.cookie) {
            headers["Set-Cookie"] = [
              (0, cookie_1.serialize)(this.opts.cookie.name, id3, this.opts.cookie)
            ];
          }
          this.emit("initial_headers", headers, req2);
        }
        this.emit("headers", headers, req2);
      });
      transport.onRequest(req);
      this.clients[id3] = socket;
      this.clientsCount++;
      socket.once("close", () => {
        delete this.clients[id3];
        this.clientsCount--;
      });
      this.emit("connection", socket);
      return transport;
    }
    async onWebTransportSession(session) {
      const timeout = setTimeout(() => {
        debug("the client failed to establish a bidirectional stream in the given period");
        session.close();
      }, this.opts.upgradeTimeout);
      const streamReader = session.incomingBidirectionalStreams.getReader();
      const result2 = await streamReader.read();
      if (result2.done) {
        debug("session is closed");
        return;
      }
      const stream = result2.value;
      const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
      const reader = stream.readable.pipeThrough(transformStream).getReader();
      const { value, done } = await reader.read();
      if (done) {
        debug("stream is closed");
        return;
      }
      clearTimeout(timeout);
      if (value.type !== "open") {
        debug("invalid WebTransport handshake");
        return session.close();
      }
      if (value.data === undefined) {
        const transport = new webtransport_1.WebTransport(session, stream, reader);
        const id3 = base64id.generateId();
        debug('handshaking client "%s" (WebTransport)', id3);
        const socket = new socket_1.Socket(id3, this, transport, null, 4);
        this.clients[id3] = socket;
        this.clientsCount++;
        socket.once("close", () => {
          delete this.clients[id3];
          this.clientsCount--;
        });
        this.emit("connection", socket);
        return;
      }
      const sid = parseSessionId(value.data);
      if (!sid) {
        debug("invalid WebTransport handshake");
        return session.close();
      }
      const client2 = this.clients[sid];
      if (!client2) {
        debug("upgrade attempt for closed client");
        session.close();
      } else if (client2.upgrading) {
        debug("transport has already been trying to upgrade");
        session.close();
      } else if (client2.upgraded) {
        debug("transport had already been upgraded");
        session.close();
      } else {
        debug("upgrading existing transport");
        const transport = new webtransport_1.WebTransport(session, stream, reader);
        client2._maybeUpgrade(transport);
      }
    }
  }
  exports.BaseServer = BaseServer;
  BaseServer.errors = {
    UNKNOWN_TRANSPORT: 0,
    UNKNOWN_SID: 1,
    BAD_HANDSHAKE_METHOD: 2,
    BAD_REQUEST: 3,
    FORBIDDEN: 4,
    UNSUPPORTED_PROTOCOL_VERSION: 5
  };
  BaseServer.errorMessages = {
    0: "Transport unknown",
    1: "Session ID unknown",
    2: "Bad handshake method",
    3: "Bad request",
    4: "Forbidden",
    5: "Unsupported protocol version"
  };

  class WebSocketResponse {
    constructor(req, socket) {
      this.req = req;
      this.socket = socket;
      req[kResponseHeaders] = {};
    }
    setHeader(name3, value) {
      this.req[kResponseHeaders][name3] = value;
    }
    getHeader(name3) {
      return this.req[kResponseHeaders][name3];
    }
    removeHeader(name3) {
      delete this.req[kResponseHeaders][name3];
    }
    write() {}
    writeHead() {}
    end() {
      this.socket.destroy();
    }
  }

  class Server extends BaseServer {
    init() {
      if (!~this.opts.transports.indexOf("websocket"))
        return;
      if (this.ws)
        this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });
      if (typeof this.ws.on === "function") {
        this.ws.on("headers", (headersArray, req) => {
          const additionalHeaders = req[kResponseHeaders] || {};
          delete req[kResponseHeaders];
          const isInitialRequest = !req._query.sid;
          if (isInitialRequest) {
            this.emit("initial_headers", additionalHeaders, req);
          }
          this.emit("headers", additionalHeaders, req);
          debug("writing headers: %j", additionalHeaders);
          Object.keys(additionalHeaders).forEach((key) => {
            headersArray.push(`${key}: ${additionalHeaders[key]}`);
          });
        });
      }
    }
    cleanup() {
      if (this.ws) {
        debug("closing webSocketServer");
        this.ws.close();
      }
    }
    prepare(req) {
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs2.parse((0, url_1.parse)(req.url).query) : {};
      }
    }
    createTransport(transportName, req) {
      return new transports_1.default[transportName](req);
    }
    handleRequest(req, res) {
      debug('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });
          abortRequest(res, errorCode, errorContext);
          return;
        }
        if (req._query.sid) {
          debug("setting new request for existing client");
          this.clients[req._query.sid].transport.onRequest(req);
        } else {
          const closeConnection = (errorCode2, errorContext2) => abortRequest(res, errorCode2, errorContext2);
          this.handshake(req._query.transport, req, closeConnection);
        }
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, false, callback);
        }
      });
    }
    handleUpgrade(req, socket, upgradeHead) {
      this.prepare(req);
      const res = new WebSocketResponse(req, socket);
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });
          abortUpgrade(socket, errorCode, errorContext);
          return;
        }
        const head = Buffer.from(upgradeHead);
        upgradeHead = null;
        res.writeHead();
        this.ws.handleUpgrade(req, socket, head, (websocket) => {
          this.onWebSocket(req, socket, websocket);
        });
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, true, callback);
        }
      });
    }
    onWebSocket(req, socket, websocket) {
      websocket.on("error", onUpgradeError);
      if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
        debug("transport doesnt handle upgraded requests");
        websocket.close();
        return;
      }
      const id3 = req._query.sid;
      req.websocket = websocket;
      if (id3) {
        const client2 = this.clients[id3];
        if (!client2) {
          debug("upgrade attempt for closed client");
          websocket.close();
        } else if (client2.upgrading) {
          debug("transport has already been trying to upgrade");
          websocket.close();
        } else if (client2.upgraded) {
          debug("transport had already been upgraded");
          websocket.close();
        } else {
          debug("upgrading existing transport");
          websocket.removeListener("error", onUpgradeError);
          const transport = this.createTransport(req._query.transport, req);
          transport.perMessageDeflate = this.opts.perMessageDeflate;
          client2._maybeUpgrade(transport);
        }
      } else {
        const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);
        this.handshake(req._query.transport, req, closeConnection);
      }
      function onUpgradeError() {
        debug("websocket error before upgrade");
      }
    }
    attach(server, options3 = {}) {
      const path3 = this._computePath(options3);
      const destroyUpgradeTimeout = options3.destroyUpgradeTimeout || 1000;
      function check(req) {
        return path3 === req.url.slice(0, path3.length);
      }
      const listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this));
      server.on("request", (req, res) => {
        if (check(req)) {
          debug('intercepting request for path "%s"', path3);
          this.handleRequest(req, res);
        } else {
          let i2 = 0;
          const l3 = listeners.length;
          for (;i2 < l3; i2++) {
            listeners[i2].call(server, req, res);
          }
        }
      });
      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", (req, socket, head) => {
          if (check(req)) {
            this.handleUpgrade(req, socket, head);
          } else if (options3.destroyUpgrade !== false) {
            setTimeout(function() {
              if (socket.writable && socket.bytesWritten <= 0) {
                socket.on("error", (e3) => {
                  debug("error while destroying upgrade: %s", e3.message);
                });
                return socket.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }
  exports.Server = Server;
  function abortRequest(res, errorCode, errorContext) {
    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
    const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
    res.writeHead(statusCode, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
      code: errorCode,
      message
    }));
  }
  function abortUpgrade(socket, errorCode, errorContext = {}) {
    socket.on("error", () => {
      debug("ignoring error from closed connection");
    });
    if (socket.writable) {
      const message = errorContext.message || Server.errorMessages[errorCode];
      const length = Buffer.byteLength(message);
      socket.write(`HTTP/1.1 400 Bad Request\r
` + `Connection: close\r
` + `Content-type: text/html\r
` + "Content-Length: " + length + `\r
` + `\r
` + message);
    }
    socket.destroy();
  }
  var validHdrChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  function checkInvalidHeaderChar(val) {
    val += "";
    if (val.length < 1)
      return false;
    if (!validHdrChars[val.charCodeAt(0)]) {
      debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
      return true;
    }
    if (val.length < 2)
      return false;
    if (!validHdrChars[val.charCodeAt(1)]) {
      debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
      return true;
    }
    if (val.length < 3)
      return false;
    if (!validHdrChars[val.charCodeAt(2)]) {
      debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
      return true;
    }
    if (val.length < 4)
      return false;
    if (!validHdrChars[val.charCodeAt(3)]) {
      debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
      return true;
    }
    for (let i2 = 4;i2 < val.length; ++i2) {
      if (!validHdrChars[val.charCodeAt(i2)]) {
        debug('invalid header, index "%i", char "%s"', i2, val.charCodeAt(i2));
        return true;
      }
    }
    return false;
  }
});

// ../../../../node_modules/engine.io/build/transports-uws/polling.js
var require_polling2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var transport_1 = require_transport();
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var debug_1 = require_src();
  var debug = (0, debug_1.default)("engine:polling");
  var compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate
  };

  class Polling extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.closeTimeout = 30 * 1000;
    }
    get name() {
      return "polling";
    }
    onRequest(req) {
      const res = req.res;
      req.res = null;
      if (req.getMethod() === "get") {
        this.onPollRequest(req, res);
      } else if (req.getMethod() === "post") {
        this.onDataRequest(req, res);
      } else {
        res.writeStatus("500 Internal Server Error");
        res.end();
      }
    }
    onPollRequest(req, res) {
      if (this.req) {
        debug("request overlap");
        this.onError("overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }
      debug("setting request");
      this.req = req;
      this.res = res;
      const onClose = () => {
        this.writable = false;
        this.onError("poll connection closed prematurely");
      };
      const cleanup2 = () => {
        this.req = this.res = null;
      };
      req.cleanup = cleanup2;
      res.onAborted(onClose);
      this.writable = true;
      this.emit("ready");
      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{ type: "noop" }]);
      }
    }
    onDataRequest(req, res) {
      if (this.dataReq) {
        this.onError("data request overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }
      const expectedContentLength = Number(req.headers["content-length"]);
      if (!expectedContentLength) {
        this.onError("content-length header required");
        res.writeStatus("411 Length Required").end();
        return;
      }
      if (expectedContentLength > this.maxHttpBufferSize) {
        this.onError("payload too large");
        res.writeStatus("413 Payload Too Large").end();
        return;
      }
      const isBinary = req.headers["content-type"] === "application/octet-stream";
      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }
      this.dataReq = req;
      this.dataRes = res;
      let buffer;
      let offset = 0;
      const headers = {
        "Content-Type": "text/html"
      };
      this.headers(req, headers);
      for (let key in headers) {
        res.writeHeader(key, String(headers[key]));
      }
      const onEnd = (buffer2) => {
        this.onData(buffer2.toString());
        this.onDataRequestCleanup();
        res.cork(() => {
          res.end("ok");
        });
      };
      res.onAborted(() => {
        this.onDataRequestCleanup();
        this.onError("data request connection closed prematurely");
      });
      res.onData((arrayBuffer, isLast) => {
        const totalLength = offset + arrayBuffer.byteLength;
        if (totalLength > expectedContentLength) {
          this.onError("content-length mismatch");
          res.close();
          return;
        }
        if (!buffer) {
          if (isLast) {
            onEnd(Buffer.from(arrayBuffer));
            return;
          }
          buffer = Buffer.allocUnsafe(expectedContentLength);
        }
        Buffer.from(arrayBuffer).copy(buffer, offset);
        if (isLast) {
          if (totalLength != expectedContentLength) {
            this.onError("content-length mismatch");
            res.writeStatus("400 Content-Length Mismatch").end();
            this.onDataRequestCleanup();
            return;
          }
          onEnd(buffer);
          return;
        }
        offset = totalLength;
      });
    }
    onDataRequestCleanup() {
      this.dataReq = this.dataRes = null;
    }
    onData(data) {
      debug('received "%s"', data);
      const callback = (packet) => {
        if (packet.type === "close") {
          debug("got xhr close packet");
          this.onClose();
          return false;
        }
        this.onPacket(packet);
      };
      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    onClose() {
      if (this.writable) {
        this.send([{ type: "noop" }]);
      }
      super.onClose();
    }
    send(packets) {
      this.writable = false;
      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({ type: "close" });
        this.shouldClose();
        this.shouldClose = null;
      }
      const doWrite = (data) => {
        const compress = packets.some((packet) => {
          return packet.options && packet.options.compress;
        });
        this.write(data, { compress });
      };
      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    write(data, options3) {
      debug('writing "%s"', data);
      this.doWrite(data, options3, () => {
        this.req.cleanup();
        this.emit("drain");
      });
    }
    doWrite(data, options3, callback) {
      const isString2 = typeof data === "string";
      const contentType = isString2 ? "text/plain; charset=UTF-8" : "application/octet-stream";
      const headers = {
        "Content-Type": contentType
      };
      const respond = (data2) => {
        this.headers(this.req, headers);
        this.res.cork(() => {
          Object.keys(headers).forEach((key) => {
            this.res.writeHeader(key, String(headers[key]));
          });
          this.res.end(data2);
        });
        callback();
      };
      if (!this.httpCompression || !options3.compress) {
        respond(data);
        return;
      }
      const len = isString2 ? Buffer.byteLength(data) : data.length;
      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }
      const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
      if (!encoding) {
        respond(data);
        return;
      }
      this.compress(data, encoding, (err, data2) => {
        if (err) {
          this.res.writeStatus("500 Internal Server Error");
          this.res.end();
          callback(err);
          return;
        }
        headers["Content-Encoding"] = encoding;
        respond(data2);
      });
    }
    compress(data, encoding, callback) {
      debug("compressing");
      const buffers = [];
      let nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function() {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    doClose(fn2) {
      debug("closing");
      let closeTimeoutTimer;
      const onClose = () => {
        clearTimeout(closeTimeoutTimer);
        fn2();
        this.onClose();
      };
      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{ type: "close" }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    headers(req, headers) {
      headers = headers || {};
      const ua2 = req.headers["user-agent"];
      if (ua2 && (~ua2.indexOf(";MSIE") || ~ua2.indexOf("Trident/"))) {
        headers["X-XSS-Protection"] = "0";
      }
      headers["cache-control"] = "no-store";
      this.emit("headers", headers, req);
      return headers;
    }
  }
  exports.Polling = Polling;
});

// ../../../../node_modules/engine.io/build/transports-uws/websocket.js
var require_websocket2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebSocket = undefined;
  var transport_1 = require_transport();
  var debug_1 = require_src();
  var debug = (0, debug_1.default)("engine:ws");

  class WebSocket extends transport_1.Transport {
    constructor(req) {
      super(req);
      this.writable = false;
      this.perMessageDeflate = null;
    }
    get name() {
      return "websocket";
    }
    get handlesUpgrades() {
      return true;
    }
    send(packets) {
      this.writable = false;
      for (let i2 = 0;i2 < packets.length; i2++) {
        const packet = packets[i2];
        const isLast = i2 + 1 === packets.length;
        const send = (data) => {
          const isBinary = typeof data !== "string";
          const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
          debug('writing "%s"', data);
          this.socket.send(data, isBinary, compress);
          if (isLast) {
            this.emit("drain");
            this.writable = true;
            this.emit("ready");
          }
        };
        if (packet.options && typeof packet.options.wsPreEncoded === "string") {
          send(packet.options.wsPreEncoded);
        } else {
          this.parser.encodePacket(packet, this.supportsBinary, send);
        }
      }
    }
    doClose(fn2) {
      debug("closing");
      fn2 && fn2();
      this.socket.end();
    }
  }
  exports.WebSocket = WebSocket;
});

// ../../../../node_modules/engine.io/build/transports-uws/index.js
var require_transports_uws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var polling_1 = require_polling2();
  var websocket_1 = require_websocket2();
  exports.default = {
    polling: polling_1.Polling,
    websocket: websocket_1.WebSocket
  };
});

// ../../../../node_modules/engine.io/build/userver.js
var require_userver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uServer = undefined;
  var debug_1 = require_src();
  var server_1 = require_server2();
  var transports_uws_1 = require_transports_uws();
  var debug = (0, debug_1.default)("engine:uws");

  class uServer extends server_1.BaseServer {
    init() {}
    cleanup() {}
    prepare(req, res) {
      req.method = req.getMethod().toUpperCase();
      req.url = req.getUrl();
      const params = new URLSearchParams(req.getQuery());
      req._query = Object.fromEntries(params.entries());
      req.headers = {};
      req.forEach((key, value) => {
        req.headers[key] = value;
      });
      req.connection = {
        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
      };
      res.onAborted(() => {
        debug("response has been aborted");
      });
    }
    createTransport(transportName, req) {
      return new transports_uws_1.default[transportName](req);
    }
    attach(app, options3 = {}) {
      const path3 = this._computePath(options3);
      app.any(path3, this.handleRequest.bind(this)).ws(path3, {
        compression: options3.compression,
        idleTimeout: options3.idleTimeout,
        maxBackpressure: options3.maxBackpressure,
        maxPayloadLength: this.opts.maxHttpBufferSize,
        upgrade: this.handleUpgrade.bind(this),
        open: (ws3) => {
          const transport = ws3.getUserData().transport;
          transport.socket = ws3;
          transport.writable = true;
          transport.emit("ready");
        },
        message: (ws3, message, isBinary) => {
          ws3.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
        },
        close: (ws3, code2, message) => {
          ws3.getUserData().transport.onClose(code2, message);
        }
      });
    }
    _applyMiddlewares(req, res, callback) {
      if (this.middlewares.length === 0) {
        return callback();
      }
      req.res = new ResponseWrapper(res);
      super._applyMiddlewares(req, req.res, (err) => {
        req.res.writeHead();
        callback(err);
      });
    }
    handleRequest(res, req) {
      debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
      this.prepare(req, res);
      req.res = res;
      const callback = (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });
          this.abortRequest(req.res, errorCode, errorContext);
          return;
        }
        if (req._query.sid) {
          debug("setting new request for existing client");
          this.clients[req._query.sid].transport.onRequest(req);
        } else {
          const closeConnection = (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2);
          this.handshake(req._query.transport, req, closeConnection);
        }
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, false, callback);
        }
      });
    }
    handleUpgrade(res, req, context) {
      debug("on upgrade");
      this.prepare(req, res);
      req.res = res;
      const callback = async (errorCode, errorContext) => {
        if (errorCode !== undefined) {
          this.emit("connection_error", {
            req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });
          this.abortRequest(res, errorCode, errorContext);
          return;
        }
        const id3 = req._query.sid;
        let transport;
        if (id3) {
          const client2 = this.clients[id3];
          if (!client2) {
            debug("upgrade attempt for closed client");
            return res.close();
          } else if (client2.upgrading) {
            debug("transport has already been trying to upgrade");
            return res.close();
          } else if (client2.upgraded) {
            debug("transport had already been upgraded");
            return res.close();
          } else {
            debug("upgrading existing transport");
            transport = this.createTransport(req._query.transport, req);
            client2._maybeUpgrade(transport);
          }
        } else {
          transport = await this.handshake(req._query.transport, req, (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2));
          if (!transport) {
            return;
          }
        }
        req.res.writeStatus("101 Switching Protocols");
        res.upgrade({
          transport
        }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
      };
      this._applyMiddlewares(req, res, (err) => {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
        } else {
          this.verify(req, true, callback);
        }
      });
    }
    abortRequest(res, errorCode, errorContext) {
      const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
      const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
      res.writeStatus(statusCode);
      res.writeHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: errorCode,
        message
      }));
    }
  }
  exports.uServer = uServer;

  class ResponseWrapper {
    constructor(res) {
      this.res = res;
      this.statusWritten = false;
      this.headers = [];
      this.isAborted = false;
    }
    set statusCode(status) {
      if (!status) {
        return;
      }
      this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
    writeHead(status) {
      this.statusCode = status;
    }
    setHeader(key, value) {
      if (Array.isArray(value)) {
        value.forEach((val) => {
          this.writeHeader(key, val);
        });
      } else {
        this.writeHeader(key, value);
      }
    }
    removeHeader() {}
    getHeader() {}
    writeStatus(status) {
      if (this.isAborted)
        return;
      this.res.writeStatus(status);
      this.statusWritten = true;
      this.writeBufferedHeaders();
      return this;
    }
    writeHeader(key, value) {
      if (this.isAborted)
        return;
      if (key === "Content-Length") {
        return;
      }
      if (this.statusWritten) {
        this.res.writeHeader(key, value);
      } else {
        this.headers.push([key, value]);
      }
    }
    writeBufferedHeaders() {
      this.headers.forEach(([key, value]) => {
        this.res.writeHeader(key, value);
      });
    }
    end(data) {
      if (this.isAborted)
        return;
      this.res.cork(() => {
        if (!this.statusWritten) {
          this.writeBufferedHeaders();
        }
        this.res.end(data);
      });
    }
    onData(fn2) {
      if (this.isAborted)
        return;
      this.res.onData(fn2);
    }
    onAborted(fn2) {
      if (this.isAborted)
        return;
      this.res.onAborted(() => {
        this.isAborted = true;
        fn2();
      });
    }
    cork(fn2) {
      if (this.isAborted)
        return;
      this.res.cork(fn2);
    }
  }
});

// ../../../../node_modules/engine.io/build/engine.io.js
var require_engine_io = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.transports = exports.Server = undefined;
  exports.listen = listen;
  exports.attach = attach;
  var http_1 = __require("http");
  var server_1 = require_server2();
  Object.defineProperty(exports, "Server", { enumerable: true, get: function() {
    return server_1.Server;
  } });
  var index_1 = require_transports();
  exports.transports = index_1.default;
  var parser2 = require_cjs();
  exports.parser = parser2;
  var userver_1 = require_userver();
  Object.defineProperty(exports, "uServer", { enumerable: true, get: function() {
    return userver_1.uServer;
  } });
  var socket_1 = require_socket();
  Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
    return socket_1.Socket;
  } });
  var transport_1 = require_transport();
  Object.defineProperty(exports, "Transport", { enumerable: true, get: function() {
    return transport_1.Transport;
  } });
  exports.protocol = parser2.protocol;
  function listen(port, options3, fn2) {
    if (typeof options3 === "function") {
      fn2 = options3;
      options3 = {};
    }
    const server = (0, http_1.createServer)(function(req, res) {
      res.writeHead(501);
      res.end("Not Implemented");
    });
    const engine = attach(server, options3);
    engine.httpServer = server;
    server.listen(port, fn2);
    return engine;
  }
  function attach(server, options3) {
    const engine = new server_1.Server(options3);
    engine.attach(server, options3);
    return engine;
  }
});

// ../../../../node_modules/@socket.io/component-emitter/lib/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  exports.Emitter = Emitter;
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn2) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn2);
    return this;
  };
  Emitter.prototype.once = function(event, fn2) {
    function on3() {
      this.off(event, on3);
      fn2.apply(this, arguments);
    }
    on3.fn = fn2;
    this.on(event, on3);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn2) {
    this._callbacks = this._callbacks || {};
    if (arguments.length == 0) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (arguments.length == 1) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i2 = 0;i2 < callbacks.length; i2++) {
      cb = callbacks[i2];
      if (cb === fn2 || cb.fn === fn2) {
        callbacks.splice(i2, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i2 = 1;i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i2 = 0, len = callbacks.length;i2 < len; ++i2) {
        callbacks[i2].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.emitReserved = Emitter.prototype.emit;
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
});

// ../../../../node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasBinary = exports.isBinary = undefined;
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  var toString4 = Object.prototype.toString;
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString4.call(Blob) === "[object BlobConstructor]";
  var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString4.call(File) === "[object FileConstructor]";
  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  exports.isBinary = isBinary;
  function hasBinary(obj, toJSON2) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i2 = 0, l3 = obj.length;i2 < l3; i2++) {
        if (hasBinary(obj[i2])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  exports.hasBinary = hasBinary;
});

// ../../../../node_modules/socket.io-parser/build/cjs/binary.js
var require_binary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconstructPacket = exports.deconstructPacket = undefined;
  var is_binary_js_1 = require_is_binary();
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  }
  exports.deconstructPacket = deconstructPacket;
  function _deconstructPacket(data, buffers) {
    if (!data)
      return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i2 = 0;i2 < data.length; i2++) {
        newData[i2] = _deconstructPacket(data[i2], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments;
    return packet;
  }
  exports.reconstructPacket = reconstructPacket;
  function _reconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder === true) {
      const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (let i2 = 0;i2 < data.length; i2++) {
        data[i2] = _reconstructPacket(data[i2], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }
});

// ../../../../node_modules/socket.io-parser/node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace2.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace2;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace2);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace2, delimiter2) {
      const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0;i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name3) {
      if (name3[name3.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length;i2 < len; i2++) {
        if (createDebug.skips[i2].test(name3)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length;i2 < len; i2++) {
        if (createDebug.names[i2].test(name3)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../../../node_modules/socket.io-parser/node_modules/debug/src/browser.js
var require_browser3 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned2 = false;
    return () => {
      if (!warned2) {
        warned2 = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m3;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c4 = "color: " + this.color;
    args.splice(1, 0, c4, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c4);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r4;
    try {
      r4 = exports.storage.getItem("debug");
    } catch (error2) {}
    if (!r4 && typeof process !== "undefined" && "env" in process) {
      r4 = process.env.DEBUG;
    }
    return r4;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../../../node_modules/socket.io-parser/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util2 = __require("util");
  exports.init = init2;
  exports.log = log4;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (init_supports_color(), __toCommonJS(exports_supports_color));
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
      return k3.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name3, useColors: useColors2 } = this;
    if (useColors2) {
      const c4 = this.color;
      const colorCode = "\x1B[3" + (c4 < 8 ? c4 : "8;5;" + c4);
      const prefix2 = `  ${colorCode};1m${name3} \x1B[0m`;
      args[0] = prefix2 + args[0].split(`
`).join(`
` + prefix2);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name3 + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map((str2) => str2.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// ../../../../node_modules/socket.io-parser/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser3();
  } else {
    module.exports = require_node2();
  }
});

// ../../../../node_modules/socket.io-parser/build/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = undefined;
  var component_emitter_1 = require_cjs2();
  var binary_js_1 = require_binary();
  var is_binary_js_1 = require_is_binary();
  var debug_1 = require_src2();
  var debug = (0, debug_1.default)("socket.io-parser");
  var RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
  ];
  exports.protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType = exports.PacketType || (exports.PacketType = {}));

  class Encoder {
    constructor(replacer2) {
      this.replacer = replacer2;
    }
    encode(obj) {
      debug("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, is_binary_js_1.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    encodeAsString(obj) {
      let str2 = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str2 += obj.attachments + "-";
      }
      if (obj.nsp && obj.nsp !== "/") {
        str2 += obj.nsp + ",";
      }
      if (obj.id != null) {
        str2 += obj.id;
      }
      if (obj.data != null) {
        str2 += JSON.stringify(obj.data, this.replacer);
      }
      debug("encoded %j as %s", obj, str2);
      return str2;
    }
    encodeAsBinary(obj) {
      const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  }
  exports.Encoder = Encoder;
  function isObject3(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }

  class Decoder extends component_emitter_1.Emitter {
    constructor(reviver) {
      super();
      this.reviver = reviver;
    }
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emitReserved("decoded", packet);
          }
        } else {
          super.emitReserved("decoded", packet);
        }
      } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emitReserved("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    decodeString(str2) {
      let i2 = 0;
      const p3 = {
        type: Number(str2.charAt(0))
      };
      if (PacketType[p3.type] === undefined) {
        throw new Error("unknown packet type " + p3.type);
      }
      if (p3.type === PacketType.BINARY_EVENT || p3.type === PacketType.BINARY_ACK) {
        const start = i2 + 1;
        while (str2.charAt(++i2) !== "-" && i2 != str2.length) {}
        const buf = str2.substring(start, i2);
        if (buf != Number(buf) || str2.charAt(i2) !== "-") {
          throw new Error("Illegal attachments");
        }
        p3.attachments = Number(buf);
      }
      if (str2.charAt(i2 + 1) === "/") {
        const start = i2 + 1;
        while (++i2) {
          const c4 = str2.charAt(i2);
          if (c4 === ",")
            break;
          if (i2 === str2.length)
            break;
        }
        p3.nsp = str2.substring(start, i2);
      } else {
        p3.nsp = "/";
      }
      const next = str2.charAt(i2 + 1);
      if (next !== "" && Number(next) == next) {
        const start = i2 + 1;
        while (++i2) {
          const c4 = str2.charAt(i2);
          if (c4 == null || Number(c4) != c4) {
            --i2;
            break;
          }
          if (i2 === str2.length)
            break;
        }
        p3.id = Number(str2.substring(start, i2 + 1));
      }
      if (str2.charAt(++i2)) {
        const payload = this.tryParse(str2.substr(i2));
        if (Decoder.isPayloadValid(p3.type, payload)) {
          p3.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str2, p3);
      return p3;
    }
    tryParse(str2) {
      try {
        return JSON.parse(str2, this.reviver);
      } catch (e3) {
        return false;
      }
    }
    static isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject3(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject3(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }
  exports.Decoder = Decoder;

  class BinaryReconstructor {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }
});

// ../../../../node_modules/socket.io/node_modules/debug/src/common.js
var require_common3 = __commonJS((exports, module) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace2.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace2;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace2);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace2, delimiter2) {
      const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0;i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name3) {
      if (name3[name3.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length;i2 < len; i2++) {
        if (createDebug.skips[i2].test(name3)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length;i2 < len; i2++) {
        if (createDebug.names[i2].test(name3)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../../../node_modules/socket.io/node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned2 = false;
    return () => {
      if (!warned2) {
        warned2 = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m3;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c4 = "color: " + this.color;
    args.splice(1, 0, c4, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c4);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r4;
    try {
      r4 = exports.storage.getItem("debug");
    } catch (error2) {}
    if (!r4 && typeof process !== "undefined" && "env" in process) {
      r4 = process.env.DEBUG;
    }
    return r4;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../../../node_modules/socket.io/node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util2 = __require("util");
  exports.init = init2;
  exports.log = log4;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (init_supports_color(), __toCommonJS(exports_supports_color));
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
      return k3.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name3, useColors: useColors2 } = this;
    if (useColors2) {
      const c4 = this.color;
      const colorCode = "\x1B[3" + (c4 < 8 ? c4 : "8;5;" + c4);
      const prefix2 = `  ${colorCode};1m${name3} \x1B[0m`;
      args[0] = prefix2 + args[0].split(`
`).join(`
` + prefix2);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name3 + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map((str2) => str2.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// ../../../../node_modules/socket.io/node_modules/debug/src/index.js
var require_src3 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser4();
  } else {
    module.exports = require_node3();
  }
});

// ../../../../node_modules/socket.io/dist/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = undefined;
  var socket_io_parser_1 = require_cjs3();
  var debugModule = require_src3();
  var url = __require("url");
  var debug = debugModule("socket.io:client");

  class Client2 {
    constructor(server, conn) {
      this.sockets = new Map;
      this.nsps = new Map;
      this.server = server;
      this.conn = conn;
      this.encoder = server.encoder;
      this.decoder = new server._parser.Decoder;
      this.id = conn.id;
      this.setup();
    }
    get request() {
      return this.conn.request;
    }
    setup() {
      this.onclose = this.onclose.bind(this);
      this.ondata = this.ondata.bind(this);
      this.onerror = this.onerror.bind(this);
      this.ondecoded = this.ondecoded.bind(this);
      this.decoder.on("decoded", this.ondecoded);
      this.conn.on("data", this.ondata);
      this.conn.on("error", this.onerror);
      this.conn.on("close", this.onclose);
      this.connectTimeout = setTimeout(() => {
        if (this.nsps.size === 0) {
          debug("no namespace joined yet, close the client");
          this.close();
        } else {
          debug("the client has already joined a namespace, nothing to do");
        }
      }, this.server._connectTimeout);
    }
    connect(name3, auth = {}) {
      if (this.server._nsps.has(name3)) {
        debug("connecting to namespace %s", name3);
        return this.doConnect(name3, auth);
      }
      this.server._checkNamespace(name3, auth, (dynamicNspName) => {
        if (dynamicNspName) {
          this.doConnect(name3, auth);
        } else {
          debug("creation of namespace %s was denied", name3);
          this._packet({
            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
            nsp: name3,
            data: {
              message: "Invalid namespace"
            }
          });
        }
      });
    }
    doConnect(name3, auth) {
      const nsp = this.server.of(name3);
      nsp._add(this, auth, (socket) => {
        this.sockets.set(socket.id, socket);
        this.nsps.set(nsp.name, socket);
        if (this.connectTimeout) {
          clearTimeout(this.connectTimeout);
          this.connectTimeout = undefined;
        }
      });
    }
    _disconnect() {
      for (const socket of this.sockets.values()) {
        socket.disconnect();
      }
      this.sockets.clear();
      this.close();
    }
    _remove(socket) {
      if (this.sockets.has(socket.id)) {
        const nsp = this.sockets.get(socket.id).nsp.name;
        this.sockets.delete(socket.id);
        this.nsps.delete(nsp);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    close() {
      if (this.conn.readyState === "open") {
        debug("forcing transport close");
        this.conn.close();
        this.onclose("forced server close");
      }
    }
    _packet(packet, opts = {}) {
      if (this.conn.readyState !== "open") {
        debug("ignoring packet write %j", packet);
        return;
      }
      const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
      this.writeToEngine(encodedPackets, opts);
    }
    writeToEngine(encodedPackets, opts) {
      if (opts.volatile && !this.conn.transport.writable) {
        debug("volatile packet is discarded since the transport is not currently writable");
        return;
      }
      const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];
      for (const encodedPacket of packets) {
        this.conn.write(encodedPacket, opts);
      }
    }
    ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e3) {
        debug("invalid packet format");
        this.onerror(e3);
      }
    }
    ondecoded(packet) {
      let namespace2;
      let authPayload;
      if (this.conn.protocol === 3) {
        const parsed = url.parse(packet.nsp, true);
        namespace2 = parsed.pathname;
        authPayload = parsed.query;
      } else {
        namespace2 = packet.nsp;
        authPayload = packet.data;
      }
      const socket = this.nsps.get(namespace2);
      if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {
        this.connect(namespace2, authPayload);
      } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {
        process.nextTick(function() {
          socket._onpacket(packet);
        });
      } else {
        debug("invalid state (packet type: %s)", packet.type);
        this.close();
      }
    }
    onerror(err) {
      for (const socket of this.sockets.values()) {
        socket._onerror(err);
      }
      this.conn.close();
    }
    onclose(reason, description) {
      debug("client close with reason %s", reason);
      this.destroy();
      for (const socket of this.sockets.values()) {
        socket._onclose(reason, description);
      }
      this.sockets.clear();
      this.decoder.destroy();
    }
    destroy() {
      this.conn.removeListener("data", this.ondata);
      this.conn.removeListener("error", this.onerror);
      this.conn.removeListener("close", this.onclose);
      this.decoder.removeListener("decoded", this.ondecoded);
      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }
    }
  }
  exports.Client = Client2;
});

// ../../../../node_modules/socket.io/dist/typed-events.js
var require_typed_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StrictEventEmitter = undefined;
  var events_1 = __require("events");

  class StrictEventEmitter extends events_1.EventEmitter {
    on(ev2, listener) {
      return super.on(ev2, listener);
    }
    once(ev2, listener) {
      return super.once(ev2, listener);
    }
    emit(ev2, ...args) {
      return super.emit(ev2, ...args);
    }
    emitReserved(ev2, ...args) {
      return super.emit(ev2, ...args);
    }
    emitUntyped(ev2, ...args) {
      return super.emit(ev2, ...args);
    }
    listeners(event) {
      return super.listeners(event);
    }
  }
  exports.StrictEventEmitter = StrictEventEmitter;
});

// ../../../../node_modules/socket.io/dist/socket-types.js
var require_socket_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RESERVED_EVENTS = undefined;
  exports.RESERVED_EVENTS = new Set([
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
  ]);
});

// ../../../../node_modules/socket.io/dist/broadcast-operator.js
var require_broadcast_operator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoteSocket = exports.BroadcastOperator = undefined;
  var socket_types_1 = require_socket_types();
  var socket_io_parser_1 = require_cjs3();

  class BroadcastOperator {
    constructor(adapter, rooms = new Set, exceptRooms = new Set, flags = {}) {
      this.adapter = adapter;
      this.rooms = rooms;
      this.exceptRooms = exceptRooms;
      this.flags = flags;
    }
    to(room) {
      const rooms = new Set(this.rooms);
      if (Array.isArray(room)) {
        room.forEach((r4) => rooms.add(r4));
      } else {
        rooms.add(room);
      }
      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    in(room) {
      return this.to(room);
    }
    except(room) {
      const exceptRooms = new Set(this.exceptRooms);
      if (Array.isArray(room)) {
        room.forEach((r4) => exceptRooms.add(r4));
      } else {
        exceptRooms.add(room);
      }
      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    compress(compress) {
      const flags = Object.assign({}, this.flags, { compress });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    get volatile() {
      const flags = Object.assign({}, this.flags, { volatile: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    get local() {
      const flags = Object.assign({}, this.flags, { local: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    timeout(timeout) {
      const flags = Object.assign({}, this.flags, { timeout });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    emit(ev2, ...args) {
      if (socket_types_1.RESERVED_EVENTS.has(ev2)) {
        throw new Error(`"${String(ev2)}" is a reserved event name`);
      }
      const data = [ev2, ...args];
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data
      };
      const withAck = typeof data[data.length - 1] === "function";
      if (!withAck) {
        this.adapter.broadcast(packet, {
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        });
        return true;
      }
      const ack = data.pop();
      let timedOut = false;
      let responses = [];
      const timer = setTimeout(() => {
        timedOut = true;
        ack.apply(this, [
          new Error("operation has timed out"),
          this.flags.expectSingleResponse ? null : responses
        ]);
      }, this.flags.timeout);
      let expectedServerCount = -1;
      let actualServerCount = 0;
      let expectedClientCount = 0;
      const checkCompleteness = () => {
        if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
          clearTimeout(timer);
          ack.apply(this, [
            null,
            this.flags.expectSingleResponse ? responses[0] : responses
          ]);
        }
      };
      this.adapter.broadcastWithAck(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, (clientCount) => {
        expectedClientCount += clientCount;
        actualServerCount++;
        checkCompleteness();
      }, (clientResponse) => {
        responses.push(clientResponse);
        checkCompleteness();
      });
      this.adapter.serverCount().then((serverCount) => {
        expectedServerCount = serverCount;
        checkCompleteness();
      });
      return true;
    }
    emitWithAck(ev2, ...args) {
      return new Promise((resolve3, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve3(responses);
          }
        });
        this.emit(ev2, ...args);
      });
    }
    allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }
      return this.adapter.sockets(this.rooms);
    }
    fetchSockets() {
      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }).then((sockets) => {
        return sockets.map((socket) => {
          if (socket.server) {
            return socket;
          } else {
            return new RemoteSocket(this.adapter, socket);
          }
        });
      });
    }
    socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    disconnectSockets(close = false) {
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, close);
    }
  }
  exports.BroadcastOperator = BroadcastOperator;

  class RemoteSocket {
    constructor(adapter, details) {
      this.id = details.id;
      this.handshake = details.handshake;
      this.rooms = new Set(details.rooms);
      this.data = details.data;
      this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set, {
        expectSingleResponse: true
      });
    }
    timeout(timeout) {
      return this.operator.timeout(timeout);
    }
    emit(ev2, ...args) {
      return this.operator.emit(ev2, ...args);
    }
    join(room) {
      return this.operator.socketsJoin(room);
    }
    leave(room) {
      return this.operator.socketsLeave(room);
    }
    disconnect(close = false) {
      this.operator.disconnectSockets(close);
      return this;
    }
  }
  exports.RemoteSocket = RemoteSocket;
});

// ../../../../node_modules/socket.io/dist/socket.js
var require_socket2 = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Socket = undefined;
  var socket_io_parser_1 = require_cjs3();
  var debug_1 = __importDefault2(require_src3());
  var typed_events_1 = require_typed_events();
  var base64id_1 = __importDefault2(require_base64id());
  var broadcast_operator_1 = require_broadcast_operator();
  var socket_types_1 = require_socket_types();
  var debug = (0, debug_1.default)("socket.io:socket");
  var RECOVERABLE_DISCONNECT_REASONS = new Set([
    "transport error",
    "transport close",
    "forced close",
    "ping timeout",
    "server shutting down",
    "forced server close"
  ]);
  function noop2() {}

  class Socket extends typed_events_1.StrictEventEmitter {
    constructor(nsp, client2, auth, previousSession) {
      super();
      this.nsp = nsp;
      this.client = client2;
      this.recovered = false;
      this.data = {};
      this.connected = false;
      this.acks = new Map;
      this.fns = [];
      this.flags = {};
      this.server = nsp.server;
      this.adapter = this.nsp.adapter;
      if (previousSession) {
        this.id = previousSession.sid;
        this.pid = previousSession.pid;
        previousSession.rooms.forEach((room) => this.join(room));
        this.data = previousSession.data;
        previousSession.missedPackets.forEach((packet) => {
          this.packet({
            type: socket_io_parser_1.PacketType.EVENT,
            data: packet
          });
        });
        this.recovered = true;
      } else {
        if (client2.conn.protocol === 3) {
          this.id = nsp.name !== "/" ? nsp.name + "#" + client2.id : client2.id;
        } else {
          this.id = base64id_1.default.generateId();
        }
        if (this.server._opts.connectionStateRecovery) {
          this.pid = base64id_1.default.generateId();
        }
      }
      this.handshake = this.buildHandshake(auth);
      this.on("error", noop2);
    }
    buildHandshake(auth) {
      var _a4, _b3, _c, _d;
      return {
        headers: ((_a4 = this.request) === null || _a4 === undefined ? undefined : _a4.headers) || {},
        time: new Date + "",
        address: this.conn.remoteAddress,
        xdomain: !!((_b3 = this.request) === null || _b3 === undefined ? undefined : _b3.headers.origin),
        secure: !this.request || !!this.request.connection.encrypted,
        issued: +new Date,
        url: (_c = this.request) === null || _c === undefined ? undefined : _c.url,
        query: ((_d = this.request) === null || _d === undefined ? undefined : _d._query) || {},
        auth
      };
    }
    emit(ev2, ...args) {
      if (socket_types_1.RESERVED_EVENTS.has(ev2)) {
        throw new Error(`"${String(ev2)}" is a reserved event name`);
      }
      const data = [ev2, ...args];
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data
      };
      if (typeof data[data.length - 1] === "function") {
        const id3 = this.nsp._ids++;
        debug("emitting packet with ack id %d", id3);
        this.registerAckCallback(id3, data.pop());
        packet.id = id3;
      }
      const flags = Object.assign({}, this.flags);
      this.flags = {};
      if (this.nsp.server.opts.connectionStateRecovery) {
        this.adapter.broadcast(packet, {
          rooms: new Set([this.id]),
          except: new Set,
          flags
        });
      } else {
        this.notifyOutgoingListeners(packet);
        this.packet(packet, flags);
      }
      return true;
    }
    emitWithAck(ev2, ...args) {
      const withErr = this.flags.timeout !== undefined;
      return new Promise((resolve3, reject) => {
        args.push((arg1, arg2) => {
          if (withErr) {
            return arg1 ? reject(arg1) : resolve3(arg2);
          } else {
            return resolve3(arg1);
          }
        });
        this.emit(ev2, ...args);
      });
    }
    registerAckCallback(id3, ack) {
      const timeout = this.flags.timeout;
      if (timeout === undefined) {
        this.acks.set(id3, ack);
        return;
      }
      const timer = setTimeout(() => {
        debug("event with ack id %d has timed out after %d ms", id3, timeout);
        this.acks.delete(id3);
        ack.call(this, new Error("operation has timed out"));
      }, timeout);
      this.acks.set(id3, (...args) => {
        clearTimeout(timer);
        ack.apply(this, [null, ...args]);
      });
    }
    to(room) {
      return this.newBroadcastOperator().to(room);
    }
    in(room) {
      return this.newBroadcastOperator().in(room);
    }
    except(room) {
      return this.newBroadcastOperator().except(room);
    }
    send(...args) {
      this.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.emit("message", ...args);
      return this;
    }
    packet(packet, opts = {}) {
      packet.nsp = this.nsp.name;
      opts.compress = opts.compress !== false;
      this.client._packet(packet, opts);
    }
    join(rooms) {
      debug("join room %s", rooms);
      return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    leave(room) {
      debug("leave room %s", room);
      return this.adapter.del(this.id, room);
    }
    leaveAll() {
      this.adapter.delAll(this.id);
    }
    _onconnect() {
      debug("socket connected - writing packet");
      this.connected = true;
      this.join(this.id);
      if (this.conn.protocol === 3) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: { sid: this.id, pid: this.pid }
        });
      }
    }
    _onpacket(packet) {
      debug("got packet %j", packet);
      switch (packet.type) {
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
      }
    }
    onevent(packet) {
      const args = packet.data || [];
      debug("emitting event %j", args);
      if (packet.id != null) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      this.dispatch(args);
    }
    ack(id3) {
      const self2 = this;
      let sent = false;
      return function() {
        if (sent)
          return;
        const args = Array.prototype.slice.call(arguments);
        debug("sending ack %j", args);
        self2.packet({
          id: id3,
          type: socket_io_parser_1.PacketType.ACK,
          data: args
        });
        sent = true;
      };
    }
    onack(packet) {
      const ack = this.acks.get(packet.id);
      if (typeof ack == "function") {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        this.acks.delete(packet.id);
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    ondisconnect() {
      debug("got disconnect packet");
      this._onclose("client namespace disconnect");
    }
    _onerror(err) {
      this.emitReserved("error", err);
    }
    _onclose(reason, description) {
      if (!this.connected)
        return this;
      debug("closing socket - reason %s", reason);
      this.emitReserved("disconnecting", reason, description);
      if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
        debug("connection state recovery is enabled for sid %s", this.id);
        this.adapter.persistSession({
          sid: this.id,
          pid: this.pid,
          rooms: [...this.rooms],
          data: this.data
        });
      }
      this._cleanup();
      this.client._remove(this);
      this.connected = false;
      this.emitReserved("disconnect", reason, description);
      return;
    }
    _cleanup() {
      this.leaveAll();
      this.nsp._remove(this);
      this.join = noop2;
    }
    _error(err) {
      this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
    }
    disconnect(close = false) {
      if (!this.connected)
        return this;
      if (close) {
        this.client._disconnect();
      } else {
        this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        this._onclose("server namespace disconnect");
      }
      return this;
    }
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    get broadcast() {
      return this.newBroadcastOperator();
    }
    get local() {
      return this.newBroadcastOperator().local;
    }
    timeout(timeout) {
      this.flags.timeout = timeout;
      return this;
    }
    dispatch(event) {
      debug("dispatching an event %j", event);
      this.run(event, (err) => {
        process.nextTick(() => {
          if (err) {
            return this._onerror(err);
          }
          if (this.connected) {
            super.emitUntyped.apply(this, event);
          } else {
            debug("ignore packet received after disconnection");
          }
        });
      });
    }
    use(fn2) {
      this.fns.push(fn2);
      return this;
    }
    run(event, fn2) {
      if (!this.fns.length)
        return fn2();
      const fns = this.fns.slice(0);
      function run(i2) {
        fns[i2](event, (err) => {
          if (err)
            return fn2(err);
          if (!fns[i2 + 1])
            return fn2();
          run(i2 + 1);
        });
      }
      run(0);
    }
    get disconnected() {
      return !this.connected;
    }
    get request() {
      return this.client.request;
    }
    get conn() {
      return this.client.conn;
    }
    get rooms() {
      return this.adapter.socketRooms(this.id) || new Set;
    }
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i2 = 0;i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    listenersAny() {
      return this._anyListeners || [];
    }
    onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyOutgoingListeners;
        for (let i2 = 0;i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const listeners = this._anyOutgoingListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, packet.data);
        }
      }
    }
    newBroadcastOperator() {
      const flags = Object.assign({}, this.flags);
      this.flags = {};
      return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set, new Set([this.id]), flags);
    }
  }
  exports.Socket = Socket;
});

// ../../../../node_modules/socket.io/dist/namespace.js
var require_namespace = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Namespace = exports.RESERVED_EVENTS = undefined;
  var socket_1 = require_socket2();
  var typed_events_1 = require_typed_events();
  var debug_1 = __importDefault2(require_src3());
  var broadcast_operator_1 = require_broadcast_operator();
  var debug = (0, debug_1.default)("socket.io:namespace");
  exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);

  class Namespace extends typed_events_1.StrictEventEmitter {
    constructor(server, name3) {
      super();
      this.sockets = new Map;
      this._preConnectSockets = new Map;
      this._fns = [];
      this._ids = 0;
      this.server = server;
      this.name = name3;
      this._initAdapter();
    }
    _initAdapter() {
      this.adapter = new (this.server.adapter())(this);
    }
    use(fn2) {
      this._fns.push(fn2);
      return this;
    }
    run(socket, fn2) {
      if (!this._fns.length)
        return fn2();
      const fns = this._fns.slice(0);
      function run(i2) {
        fns[i2](socket, (err) => {
          if (err)
            return fn2(err);
          if (!fns[i2 + 1])
            return fn2();
          run(i2 + 1);
        });
      }
      run(0);
    }
    to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
    }
    except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    async _add(client2, auth, fn2) {
      var _a4;
      debug("adding socket to nsp %s", this.name);
      const socket = await this._createSocket(client2, auth);
      this._preConnectSockets.set(socket.id, socket);
      if (((_a4 = this.server.opts.connectionStateRecovery) === null || _a4 === undefined ? undefined : _a4.skipMiddlewares) && socket.recovered && client2.conn.readyState === "open") {
        return this._doConnect(socket, fn2);
      }
      this.run(socket, (err) => {
        process.nextTick(() => {
          if (client2.conn.readyState !== "open") {
            debug("next called after client was closed - ignoring socket");
            socket._cleanup();
            return;
          }
          if (err) {
            debug("middleware error, sending CONNECT_ERROR packet to the client");
            socket._cleanup();
            if (client2.conn.protocol === 3) {
              return socket._error(err.data || err.message);
            } else {
              return socket._error({
                message: err.message,
                data: err.data
              });
            }
          }
          this._doConnect(socket, fn2);
        });
      });
    }
    async _createSocket(client2, auth) {
      const sessionId = auth.pid;
      const offset = auth.offset;
      if (this.server.opts.connectionStateRecovery && typeof sessionId === "string" && typeof offset === "string") {
        let session;
        try {
          session = await this.adapter.restoreSession(sessionId, offset);
        } catch (e3) {
          debug("error while restoring session: %s", e3);
        }
        if (session) {
          debug("connection state recovered for sid %s", session.sid);
          return new socket_1.Socket(this, client2, auth, session);
        }
      }
      return new socket_1.Socket(this, client2, auth);
    }
    _doConnect(socket, fn2) {
      this._preConnectSockets.delete(socket.id);
      this.sockets.set(socket.id, socket);
      socket._onconnect();
      if (fn2)
        fn2(socket);
      this.emitReserved("connect", socket);
      this.emitReserved("connection", socket);
    }
    _remove(socket) {
      this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
    }
    emit(ev2, ...args) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev2, ...args);
    }
    send(...args) {
      this.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.emit("message", ...args);
      return this;
    }
    serverSideEmit(ev2, ...args) {
      if (exports.RESERVED_EVENTS.has(ev2)) {
        throw new Error(`"${String(ev2)}" is a reserved event name`);
      }
      args.unshift(ev2);
      this.adapter.serverSideEmit(args);
      return true;
    }
    serverSideEmitWithAck(ev2, ...args) {
      return new Promise((resolve3, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve3(responses);
          }
        });
        this.serverSideEmit(ev2, ...args);
      });
    }
    _onServerSideEmit(args) {
      super.emitUntyped.apply(this, args);
    }
    allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    compress(compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
    }
    get volatile() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
    }
    get local() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    timeout(timeout) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
    }
    fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    disconnectSockets(close = false) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }
  exports.Namespace = Namespace;
});

// ../../../../node_modules/socket.io-adapter/dist/contrib/yeast.js
var require_yeast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.yeast = exports.decode = exports.encode = undefined;
  var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
  var length = 64;
  var map3 = {};
  var seed = 0;
  var i2 = 0;
  var prev;
  function encode4(num) {
    let encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  exports.encode = encode4;
  function decode2(str2) {
    let decoded = 0;
    for (i2 = 0;i2 < str2.length; i2++) {
      decoded = decoded * length + map3[str2.charAt(i2)];
    }
    return decoded;
  }
  exports.decode = decode2;
  function yeast() {
    const now2 = encode4(+new Date);
    if (now2 !== prev)
      return seed = 0, prev = now2;
    return now2 + "." + encode4(seed++);
  }
  exports.yeast = yeast;
  for (;i2 < length; i2++)
    map3[alphabet[i2]] = i2;
});

// ../../../../node_modules/socket.io-adapter/dist/in-memory-adapter.js
var require_in_memory_adapter = __commonJS((exports) => {
  var _a4;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SessionAwareAdapter = exports.Adapter = undefined;
  var events_1 = __require("events");
  var yeast_1 = require_yeast();
  var WebSocket = __require("ws");
  var canPreComputeFrame = typeof ((_a4 = WebSocket === null || WebSocket === undefined ? undefined : WebSocket.Sender) === null || _a4 === undefined ? undefined : _a4.frame) === "function";

  class Adapter extends events_1.EventEmitter {
    constructor(nsp) {
      super();
      this.nsp = nsp;
      this.rooms = new Map;
      this.sids = new Map;
      this.encoder = nsp.server.encoder;
    }
    init() {}
    close() {}
    serverCount() {
      return Promise.resolve(1);
    }
    addAll(id3, rooms) {
      if (!this.sids.has(id3)) {
        this.sids.set(id3, new Set);
      }
      for (const room of rooms) {
        this.sids.get(id3).add(room);
        if (!this.rooms.has(room)) {
          this.rooms.set(room, new Set);
          this.emit("create-room", room);
        }
        if (!this.rooms.get(room).has(id3)) {
          this.rooms.get(room).add(id3);
          this.emit("join-room", room, id3);
        }
      }
    }
    del(id3, room) {
      if (this.sids.has(id3)) {
        this.sids.get(id3).delete(room);
      }
      this._del(room, id3);
    }
    _del(room, id3) {
      const _room = this.rooms.get(room);
      if (_room != null) {
        const deleted = _room.delete(id3);
        if (deleted) {
          this.emit("leave-room", room, id3);
        }
        if (_room.size === 0 && this.rooms.delete(room)) {
          this.emit("delete-room", room);
        }
      }
    }
    delAll(id3) {
      if (!this.sids.has(id3)) {
        return;
      }
      for (const room of this.sids.get(id3)) {
        this._del(room, id3);
      }
      this.sids.delete(id3);
    }
    broadcast(packet, opts) {
      const flags = opts.flags || {};
      const packetOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      const encodedPackets = this._encode(packet, packetOpts);
      this.apply(opts, (socket) => {
        if (typeof socket.notifyOutgoingListeners === "function") {
          socket.notifyOutgoingListeners(packet);
        }
        socket.client.writeToEngine(encodedPackets, packetOpts);
      });
    }
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
      const flags = opts.flags || {};
      const packetOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      packet.id = this.nsp._ids++;
      const encodedPackets = this._encode(packet, packetOpts);
      let clientCount = 0;
      this.apply(opts, (socket) => {
        clientCount++;
        socket.acks.set(packet.id, ack);
        if (typeof socket.notifyOutgoingListeners === "function") {
          socket.notifyOutgoingListeners(packet);
        }
        socket.client.writeToEngine(encodedPackets, packetOpts);
      });
      clientCountCallback(clientCount);
    }
    _encode(packet, packetOpts) {
      const encodedPackets = this.encoder.encode(packet);
      if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === "string") {
        const data = Buffer.from("4" + encodedPackets[0]);
        packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
          readOnly: false,
          mask: false,
          rsv1: false,
          opcode: 1,
          fin: true
        });
      }
      return encodedPackets;
    }
    sockets(rooms) {
      const sids = new Set;
      this.apply({ rooms }, (socket) => {
        sids.add(socket.id);
      });
      return Promise.resolve(sids);
    }
    socketRooms(id3) {
      return this.sids.get(id3);
    }
    fetchSockets(opts) {
      const sockets = [];
      this.apply(opts, (socket) => {
        sockets.push(socket);
      });
      return Promise.resolve(sockets);
    }
    addSockets(opts, rooms) {
      this.apply(opts, (socket) => {
        socket.join(rooms);
      });
    }
    delSockets(opts, rooms) {
      this.apply(opts, (socket) => {
        rooms.forEach((room) => socket.leave(room));
      });
    }
    disconnectSockets(opts, close) {
      this.apply(opts, (socket) => {
        socket.disconnect(close);
      });
    }
    apply(opts, callback) {
      const rooms = opts.rooms;
      const except = this.computeExceptSids(opts.except);
      if (rooms.size) {
        const ids = new Set;
        for (const room of rooms) {
          if (!this.rooms.has(room))
            continue;
          for (const id3 of this.rooms.get(room)) {
            if (ids.has(id3) || except.has(id3))
              continue;
            const socket = this.nsp.sockets.get(id3);
            if (socket) {
              callback(socket);
              ids.add(id3);
            }
          }
        }
      } else {
        for (const [id3] of this.sids) {
          if (except.has(id3))
            continue;
          const socket = this.nsp.sockets.get(id3);
          if (socket)
            callback(socket);
        }
      }
    }
    computeExceptSids(exceptRooms) {
      const exceptSids = new Set;
      if (exceptRooms && exceptRooms.size > 0) {
        for (const room of exceptRooms) {
          if (this.rooms.has(room)) {
            this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
          }
        }
      }
      return exceptSids;
    }
    serverSideEmit(packet) {
      console.warn("this adapter does not support the serverSideEmit() functionality");
    }
    persistSession(session) {}
    restoreSession(pid, offset) {
      return null;
    }
  }
  exports.Adapter = Adapter;

  class SessionAwareAdapter extends Adapter {
    constructor(nsp) {
      super(nsp);
      this.nsp = nsp;
      this.sessions = new Map;
      this.packets = [];
      this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
      const timer = setInterval(() => {
        const threshold = Date.now() - this.maxDisconnectionDuration;
        this.sessions.forEach((session, sessionId) => {
          const hasExpired = session.disconnectedAt < threshold;
          if (hasExpired) {
            this.sessions.delete(sessionId);
          }
        });
        for (let i2 = this.packets.length - 1;i2 >= 0; i2--) {
          const hasExpired = this.packets[i2].emittedAt < threshold;
          if (hasExpired) {
            this.packets.splice(0, i2 + 1);
            break;
          }
        }
      }, 60 * 1000);
      timer.unref();
    }
    persistSession(session) {
      session.disconnectedAt = Date.now();
      this.sessions.set(session.pid, session);
    }
    restoreSession(pid, offset) {
      const session = this.sessions.get(pid);
      if (!session) {
        return null;
      }
      const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
      if (hasExpired) {
        this.sessions.delete(pid);
        return null;
      }
      const index = this.packets.findIndex((packet) => packet.id === offset);
      if (index === -1) {
        return null;
      }
      const missedPackets = [];
      for (let i2 = index + 1;i2 < this.packets.length; i2++) {
        const packet = this.packets[i2];
        if (shouldIncludePacket(session.rooms, packet.opts)) {
          missedPackets.push(packet.data);
        }
      }
      return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
    }
    broadcast(packet, opts) {
      var _a5;
      const isEventPacket = packet.type === 2;
      const withoutAcknowledgement = packet.id === undefined;
      const notVolatile = ((_a5 = opts.flags) === null || _a5 === undefined ? undefined : _a5.volatile) === undefined;
      if (isEventPacket && withoutAcknowledgement && notVolatile) {
        const id3 = (0, yeast_1.yeast)();
        packet.data.push(id3);
        this.packets.push({
          id: id3,
          opts,
          data: packet.data,
          emittedAt: Date.now()
        });
      }
      super.broadcast(packet, opts);
    }
  }
  exports.SessionAwareAdapter = SessionAwareAdapter;
  function shouldIncludePacket(sessionRooms, opts) {
    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
    return included && notExcluded;
  }
});

// ../../../../node_modules/socket.io-adapter/node_modules/debug/src/common.js
var require_common4 = __commonJS((exports, module) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace2.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace2;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace2);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace2, delimiter2) {
      const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0;i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name3) {
      if (name3[name3.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length;i2 < len; i2++) {
        if (createDebug.skips[i2].test(name3)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length;i2 < len; i2++) {
        if (createDebug.names[i2].test(name3)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../../../node_modules/socket.io-adapter/node_modules/debug/src/browser.js
var require_browser5 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned2 = false;
    return () => {
      if (!warned2) {
        warned2 = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m3;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c4 = "color: " + this.color;
    args.splice(1, 0, c4, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c4);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r4;
    try {
      r4 = exports.storage.getItem("debug");
    } catch (error2) {}
    if (!r4 && typeof process !== "undefined" && "env" in process) {
      r4 = process.env.DEBUG;
    }
    return r4;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../../../node_modules/socket.io-adapter/node_modules/debug/src/node.js
var require_node4 = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util2 = __require("util");
  exports.init = init2;
  exports.log = log4;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (init_supports_color(), __toCommonJS(exports_supports_color));
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
      return k3.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name3, useColors: useColors2 } = this;
    if (useColors2) {
      const c4 = this.color;
      const colorCode = "\x1B[3" + (c4 < 8 ? c4 : "8;5;" + c4);
      const prefix2 = `  ${colorCode};1m${name3} \x1B[0m`;
      args[0] = prefix2 + args[0].split(`
`).join(`
` + prefix2);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name3 + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map((str2) => str2.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// ../../../../node_modules/socket.io-adapter/node_modules/debug/src/index.js
var require_src4 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser5();
  } else {
    module.exports = require_node4();
  }
});

// ../../../../node_modules/socket.io-adapter/dist/cluster-adapter.js
var require_cluster_adapter = __commonJS((exports) => {
  var __rest2 = exports && exports.__rest || function(s3, e3) {
    var t3 = {};
    for (var p3 in s3)
      if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
        t3[p3] = s3[p3];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3);i2 < p3.length; i2++) {
        if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
          t3[p3[i2]] = s3[p3[i2]];
      }
    return t3;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = undefined;
  var in_memory_adapter_1 = require_in_memory_adapter();
  var debug_1 = require_src4();
  var crypto_1 = __require("crypto");
  var debug = (0, debug_1.debug)("socket.io-adapter");
  var EMITTER_UID = "emitter";
  var DEFAULT_TIMEOUT = 5000;
  function randomId() {
    return (0, crypto_1.randomBytes)(8).toString("hex");
  }
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
    MessageType2[MessageType2["HEARTBEAT"] = 2] = "HEARTBEAT";
    MessageType2[MessageType2["BROADCAST"] = 3] = "BROADCAST";
    MessageType2[MessageType2["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
    MessageType2[MessageType2["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
    MessageType2[MessageType2["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
    MessageType2[MessageType2["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
    MessageType2[MessageType2["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
    MessageType2[MessageType2["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
    MessageType2[MessageType2["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
    MessageType2[MessageType2["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
    MessageType2[MessageType2["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
    MessageType2[MessageType2["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
  })(MessageType = exports.MessageType || (exports.MessageType = {}));
  function encodeOptions(opts) {
    return {
      rooms: [...opts.rooms],
      except: [...opts.except],
      flags: opts.flags
    };
  }
  function decodeOptions(opts) {
    return {
      rooms: new Set(opts.rooms),
      except: new Set(opts.except),
      flags: opts.flags
    };
  }

  class ClusterAdapter extends in_memory_adapter_1.Adapter {
    constructor(nsp) {
      super(nsp);
      this.requests = new Map;
      this.ackRequests = new Map;
      this.uid = randomId();
    }
    onMessage(message, offset) {
      if (message.uid === this.uid) {
        return debug("[%s] ignore message from self", this.uid);
      }
      debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
      switch (message.type) {
        case MessageType.BROADCAST: {
          const withAck = message.data.requestId !== undefined;
          if (withAck) {
            super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {
              debug("[%s] waiting for %d client acknowledgements", this.uid, clientCount);
              this.publishResponse(message.uid, {
                type: MessageType.BROADCAST_CLIENT_COUNT,
                data: {
                  requestId: message.data.requestId,
                  clientCount
                }
              });
            }, (arg) => {
              debug("[%s] received acknowledgement with value %j", this.uid, arg);
              this.publishResponse(message.uid, {
                type: MessageType.BROADCAST_ACK,
                data: {
                  requestId: message.data.requestId,
                  packet: arg
                }
              });
            });
          } else {
            const packet = message.data.packet;
            const opts = decodeOptions(message.data.opts);
            this.addOffsetIfNecessary(packet, opts, offset);
            super.broadcast(packet, opts);
          }
          break;
        }
        case MessageType.SOCKETS_JOIN:
          super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
          break;
        case MessageType.SOCKETS_LEAVE:
          super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
          break;
        case MessageType.DISCONNECT_SOCKETS:
          super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
          break;
        case MessageType.FETCH_SOCKETS: {
          debug("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);
          super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets) => {
            this.publishResponse(message.uid, {
              type: MessageType.FETCH_SOCKETS_RESPONSE,
              data: {
                requestId: message.data.requestId,
                sockets: localSockets.map((socket) => {
                  const _a4 = socket.handshake, { sessionStore } = _a4, handshake = __rest2(_a4, ["sessionStore"]);
                  return {
                    id: socket.id,
                    handshake,
                    rooms: [...socket.rooms],
                    data: socket.data
                  };
                })
              }
            });
          });
          break;
        }
        case MessageType.SERVER_SIDE_EMIT: {
          const packet = message.data.packet;
          const withAck = message.data.requestId !== undefined;
          if (!withAck) {
            this.nsp._onServerSideEmit(packet);
            return;
          }
          let called = false;
          const callback = (arg) => {
            if (called) {
              return;
            }
            called = true;
            debug("[%s] calling acknowledgement with %j", this.uid, arg);
            this.publishResponse(message.uid, {
              type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
              data: {
                requestId: message.data.requestId,
                packet: arg
              }
            });
          };
          this.nsp._onServerSideEmit([...packet, callback]);
          break;
        }
        case MessageType.BROADCAST_CLIENT_COUNT:
        case MessageType.BROADCAST_ACK:
        case MessageType.FETCH_SOCKETS_RESPONSE:
        case MessageType.SERVER_SIDE_EMIT_RESPONSE:
          this.onResponse(message);
          break;
        default:
          debug("[%s] unknown message type: %s", this.uid, message.type);
      }
    }
    onResponse(response2) {
      var _a4, _b3;
      const requestId = response2.data.requestId;
      debug("[%s] received response %s to request %s", this.uid, response2.type, requestId);
      switch (response2.type) {
        case MessageType.BROADCAST_CLIENT_COUNT: {
          (_a4 = this.ackRequests.get(requestId)) === null || _a4 === undefined || _a4.clientCountCallback(response2.data.clientCount);
          break;
        }
        case MessageType.BROADCAST_ACK: {
          (_b3 = this.ackRequests.get(requestId)) === null || _b3 === undefined || _b3.ack(response2.data.packet);
          break;
        }
        case MessageType.FETCH_SOCKETS_RESPONSE: {
          const request2 = this.requests.get(requestId);
          if (!request2) {
            return;
          }
          request2.current++;
          response2.data.sockets.forEach((socket) => request2.responses.push(socket));
          if (request2.current === request2.expected) {
            clearTimeout(request2.timeout);
            request2.resolve(request2.responses);
            this.requests.delete(requestId);
          }
          break;
        }
        case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
          const request2 = this.requests.get(requestId);
          if (!request2) {
            return;
          }
          request2.current++;
          request2.responses.push(response2.data.packet);
          if (request2.current === request2.expected) {
            clearTimeout(request2.timeout);
            request2.resolve(null, request2.responses);
            this.requests.delete(requestId);
          }
          break;
        }
        default:
          debug("[%s] unknown response type: %s", this.uid, response2.type);
      }
    }
    async broadcast(packet, opts) {
      var _a4;
      const onlyLocal = (_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local;
      if (!onlyLocal) {
        try {
          const offset = await this.publishAndReturnOffset({
            type: MessageType.BROADCAST,
            data: {
              packet,
              opts: encodeOptions(opts)
            }
          });
          this.addOffsetIfNecessary(packet, opts, offset);
        } catch (e3) {
          return debug("[%s] error while broadcasting message: %s", this.uid, e3.message);
        }
      }
      super.broadcast(packet, opts);
    }
    addOffsetIfNecessary(packet, opts, offset) {
      var _a4;
      if (!this.nsp.server.opts.connectionStateRecovery) {
        return;
      }
      const isEventPacket = packet.type === 2;
      const withoutAcknowledgement = packet.id === undefined;
      const notVolatile = ((_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.volatile) === undefined;
      if (isEventPacket && withoutAcknowledgement && notVolatile) {
        packet.data.push(offset);
      }
    }
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
      var _a4;
      const onlyLocal = (_a4 = opts === null || opts === undefined ? undefined : opts.flags) === null || _a4 === undefined ? undefined : _a4.local;
      if (!onlyLocal) {
        const requestId = randomId();
        this.ackRequests.set(requestId, {
          clientCountCallback,
          ack
        });
        this.publish({
          type: MessageType.BROADCAST,
          data: {
            packet,
            requestId,
            opts: encodeOptions(opts)
          }
        });
        setTimeout(() => {
          this.ackRequests.delete(requestId);
        }, opts.flags.timeout);
      }
      super.broadcastWithAck(packet, opts, clientCountCallback, ack);
    }
    async addSockets(opts, rooms) {
      var _a4;
      const onlyLocal = (_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.SOCKETS_JOIN,
            data: {
              opts: encodeOptions(opts),
              rooms
            }
          });
        } catch (e3) {
          debug("[%s] error while publishing message: %s", this.uid, e3.message);
        }
      }
      super.addSockets(opts, rooms);
    }
    async delSockets(opts, rooms) {
      var _a4;
      const onlyLocal = (_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.SOCKETS_LEAVE,
            data: {
              opts: encodeOptions(opts),
              rooms
            }
          });
        } catch (e3) {
          debug("[%s] error while publishing message: %s", this.uid, e3.message);
        }
      }
      super.delSockets(opts, rooms);
    }
    async disconnectSockets(opts, close) {
      var _a4;
      const onlyLocal = (_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.DISCONNECT_SOCKETS,
            data: {
              opts: encodeOptions(opts),
              close
            }
          });
        } catch (e3) {
          debug("[%s] error while publishing message: %s", this.uid, e3.message);
        }
      }
      super.disconnectSockets(opts, close);
    }
    async fetchSockets(opts) {
      var _a4;
      const [localSockets, serverCount] = await Promise.all([
        super.fetchSockets(opts),
        this.serverCount()
      ]);
      const expectedResponseCount = serverCount - 1;
      if (((_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local) || expectedResponseCount <= 0) {
        return localSockets;
      }
      const requestId = randomId();
      return new Promise((resolve3, reject) => {
        const timeout = setTimeout(() => {
          const storedRequest2 = this.requests.get(requestId);
          if (storedRequest2) {
            reject(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`));
            this.requests.delete(requestId);
          }
        }, opts.flags.timeout || DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.FETCH_SOCKETS,
          resolve: resolve3,
          timeout,
          current: 0,
          expected: expectedResponseCount,
          responses: localSockets
        };
        this.requests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.FETCH_SOCKETS,
          data: {
            opts: encodeOptions(opts),
            requestId
          }
        });
      });
    }
    async serverSideEmit(packet) {
      const withAck = typeof packet[packet.length - 1] === "function";
      if (!withAck) {
        return this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            packet
          }
        });
      }
      const ack = packet.pop();
      const expectedResponseCount = await this.serverCount() - 1;
      debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
      if (expectedResponseCount <= 0) {
        return ack(null, []);
      }
      const requestId = randomId();
      const timeout = setTimeout(() => {
        const storedRequest2 = this.requests.get(requestId);
        if (storedRequest2) {
          ack(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`), storedRequest2.responses);
          this.requests.delete(requestId);
        }
      }, DEFAULT_TIMEOUT);
      const storedRequest = {
        type: MessageType.SERVER_SIDE_EMIT,
        resolve: ack,
        timeout,
        current: 0,
        expected: expectedResponseCount,
        responses: []
      };
      this.requests.set(requestId, storedRequest);
      this.publish({
        type: MessageType.SERVER_SIDE_EMIT,
        data: {
          requestId,
          packet
        }
      });
    }
    publish(message) {
      this.publishAndReturnOffset(message).catch((err) => {
        debug("[%s] error while publishing message: %s", this.uid, err);
      });
    }
    publishAndReturnOffset(message) {
      message.uid = this.uid;
      message.nsp = this.nsp.name;
      return this.doPublish(message);
    }
    publishResponse(requesterUid, response2) {
      response2.uid = this.uid;
      response2.nsp = this.nsp.name;
      this.doPublishResponse(requesterUid, response2).catch((err) => {
        debug("[%s] error while publishing response: %s", this.uid, err);
      });
    }
  }
  exports.ClusterAdapter = ClusterAdapter;

  class ClusterAdapterWithHeartbeat extends ClusterAdapter {
    constructor(nsp, opts) {
      super(nsp);
      this.nodesMap = new Map;
      this.customRequests = new Map;
      this._opts = Object.assign({
        heartbeatInterval: 5000,
        heartbeatTimeout: 1e4
      }, opts);
      this.cleanupTimer = setInterval(() => {
        const now2 = Date.now();
        this.nodesMap.forEach((lastSeen, uid) => {
          const nodeSeemsDown = now2 - lastSeen > this._opts.heartbeatTimeout;
          if (nodeSeemsDown) {
            debug("[%s] node %s seems down", this.uid, uid);
            this.removeNode(uid);
          }
        });
      }, 1000);
    }
    init() {
      this.publish({
        type: MessageType.INITIAL_HEARTBEAT
      });
    }
    scheduleHeartbeat() {
      if (this.heartbeatTimer) {
        this.heartbeatTimer.refresh();
      } else {
        this.heartbeatTimer = setTimeout(() => {
          this.publish({
            type: MessageType.HEARTBEAT
          });
        }, this._opts.heartbeatInterval);
      }
    }
    close() {
      this.publish({
        type: MessageType.ADAPTER_CLOSE
      });
      clearTimeout(this.heartbeatTimer);
      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
      }
    }
    onMessage(message, offset) {
      if (message.uid === this.uid) {
        return debug("[%s] ignore message from self", this.uid);
      }
      if (message.uid && message.uid !== EMITTER_UID) {
        this.nodesMap.set(message.uid, Date.now());
      }
      debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
      switch (message.type) {
        case MessageType.INITIAL_HEARTBEAT:
          this.publish({
            type: MessageType.HEARTBEAT
          });
          break;
        case MessageType.HEARTBEAT:
          break;
        case MessageType.ADAPTER_CLOSE:
          this.removeNode(message.uid);
          break;
        default:
          super.onMessage(message, offset);
      }
    }
    serverCount() {
      return Promise.resolve(1 + this.nodesMap.size);
    }
    publish(message) {
      this.scheduleHeartbeat();
      return super.publish(message);
    }
    async serverSideEmit(packet) {
      const withAck = typeof packet[packet.length - 1] === "function";
      if (!withAck) {
        return this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            packet
          }
        });
      }
      const ack = packet.pop();
      const expectedResponseCount = this.nodesMap.size;
      debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
      if (expectedResponseCount <= 0) {
        return ack(null, []);
      }
      const requestId = randomId();
      const timeout = setTimeout(() => {
        const storedRequest2 = this.customRequests.get(requestId);
        if (storedRequest2) {
          ack(new Error(`timeout reached: missing ${storedRequest2.missingUids.size} responses`), storedRequest2.responses);
          this.customRequests.delete(requestId);
        }
      }, DEFAULT_TIMEOUT);
      const storedRequest = {
        type: MessageType.SERVER_SIDE_EMIT,
        resolve: ack,
        timeout,
        missingUids: new Set([...this.nodesMap.keys()]),
        responses: []
      };
      this.customRequests.set(requestId, storedRequest);
      this.publish({
        type: MessageType.SERVER_SIDE_EMIT,
        data: {
          requestId,
          packet
        }
      });
    }
    async fetchSockets(opts) {
      var _a4;
      const [localSockets, serverCount] = await Promise.all([
        super.fetchSockets({
          rooms: opts.rooms,
          except: opts.except,
          flags: {
            local: true
          }
        }),
        this.serverCount()
      ]);
      const expectedResponseCount = serverCount - 1;
      if (((_a4 = opts.flags) === null || _a4 === undefined ? undefined : _a4.local) || expectedResponseCount <= 0) {
        return localSockets;
      }
      const requestId = randomId();
      return new Promise((resolve3, reject) => {
        const timeout = setTimeout(() => {
          const storedRequest2 = this.customRequests.get(requestId);
          if (storedRequest2) {
            reject(new Error(`timeout reached: missing ${storedRequest2.missingUids.size} responses`));
            this.customRequests.delete(requestId);
          }
        }, opts.flags.timeout || DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.FETCH_SOCKETS,
          resolve: resolve3,
          timeout,
          missingUids: new Set([...this.nodesMap.keys()]),
          responses: localSockets
        };
        this.customRequests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.FETCH_SOCKETS,
          data: {
            opts: encodeOptions(opts),
            requestId
          }
        });
      });
    }
    onResponse(response2) {
      const requestId = response2.data.requestId;
      debug("[%s] received response %s to request %s", this.uid, response2.type, requestId);
      switch (response2.type) {
        case MessageType.FETCH_SOCKETS_RESPONSE: {
          const request2 = this.customRequests.get(requestId);
          if (!request2) {
            return;
          }
          response2.data.sockets.forEach((socket) => request2.responses.push(socket));
          request2.missingUids.delete(response2.uid);
          if (request2.missingUids.size === 0) {
            clearTimeout(request2.timeout);
            request2.resolve(request2.responses);
            this.customRequests.delete(requestId);
          }
          break;
        }
        case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
          const request2 = this.customRequests.get(requestId);
          if (!request2) {
            return;
          }
          request2.responses.push(response2.data.packet);
          request2.missingUids.delete(response2.uid);
          if (request2.missingUids.size === 0) {
            clearTimeout(request2.timeout);
            request2.resolve(null, request2.responses);
            this.customRequests.delete(requestId);
          }
          break;
        }
        default:
          super.onResponse(response2);
      }
    }
    removeNode(uid) {
      this.customRequests.forEach((request2, requestId) => {
        request2.missingUids.delete(uid);
        if (request2.missingUids.size === 0) {
          clearTimeout(request2.timeout);
          if (request2.type === MessageType.FETCH_SOCKETS) {
            request2.resolve(request2.responses);
          } else if (request2.type === MessageType.SERVER_SIDE_EMIT) {
            request2.resolve(null, request2.responses);
          }
          this.customRequests.delete(requestId);
        }
      });
      this.nodesMap.delete(uid);
    }
  }
  exports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;
});

// ../../../../node_modules/socket.io-adapter/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = undefined;
  var in_memory_adapter_1 = require_in_memory_adapter();
  Object.defineProperty(exports, "Adapter", { enumerable: true, get: function() {
    return in_memory_adapter_1.Adapter;
  } });
  Object.defineProperty(exports, "SessionAwareAdapter", { enumerable: true, get: function() {
    return in_memory_adapter_1.SessionAwareAdapter;
  } });
  var cluster_adapter_1 = require_cluster_adapter();
  Object.defineProperty(exports, "ClusterAdapter", { enumerable: true, get: function() {
    return cluster_adapter_1.ClusterAdapter;
  } });
  Object.defineProperty(exports, "ClusterAdapterWithHeartbeat", { enumerable: true, get: function() {
    return cluster_adapter_1.ClusterAdapterWithHeartbeat;
  } });
  Object.defineProperty(exports, "MessageType", { enumerable: true, get: function() {
    return cluster_adapter_1.MessageType;
  } });
});

// ../../../../node_modules/socket.io/dist/parent-namespace.js
var require_parent_namespace = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentNamespace = undefined;
  var namespace_1 = require_namespace();
  var socket_io_adapter_1 = require_dist();
  var debug_1 = __importDefault2(require_src3());
  var debug = (0, debug_1.default)("socket.io:parent-namespace");

  class ParentNamespace extends namespace_1.Namespace {
    constructor(server) {
      super(server, "/_" + ParentNamespace.count++);
      this.children = new Set;
    }
    _initAdapter() {
      this.adapter = new ParentBroadcastAdapter(this);
    }
    emit(ev2, ...args) {
      this.children.forEach((nsp) => {
        nsp.emit(ev2, ...args);
      });
      return true;
    }
    createChild(name3) {
      debug("creating child namespace %s", name3);
      const namespace2 = new namespace_1.Namespace(this.server, name3);
      this["_fns"].forEach((fn2) => namespace2.use(fn2));
      this.listeners("connect").forEach((listener) => namespace2.on("connect", listener));
      this.listeners("connection").forEach((listener) => namespace2.on("connection", listener));
      this.children.add(namespace2);
      if (this.server._opts.cleanupEmptyChildNamespaces) {
        const remove = namespace2._remove;
        namespace2._remove = (socket) => {
          remove.call(namespace2, socket);
          if (namespace2.sockets.size === 0) {
            debug("closing child namespace %s", name3);
            namespace2.adapter.close();
            this.server._nsps.delete(namespace2.name);
            this.children.delete(namespace2);
          }
        };
      }
      this.server._nsps.set(name3, namespace2);
      this.server.sockets.emitReserved("new_namespace", namespace2);
      return namespace2;
    }
    fetchSockets() {
      throw new Error("fetchSockets() is not supported on parent namespaces");
    }
  }
  exports.ParentNamespace = ParentNamespace;
  ParentNamespace.count = 0;

  class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {
    broadcast(packet, opts) {
      this.nsp.children.forEach((nsp) => {
        nsp.adapter.broadcast(packet, opts);
      });
    }
  }
});

// ../../../../node_modules/socket.io/dist/uws.js
var require_uws = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.patchAdapter = patchAdapter;
  exports.restoreAdapter = restoreAdapter;
  exports.serveFile = serveFile;
  var socket_io_adapter_1 = require_dist();
  var fs_1 = __require("fs");
  var debug_1 = __importDefault2(require_src3());
  var debug = (0, debug_1.default)("socket.io:adapter-uws");
  var SEPARATOR = "\x1F";
  var { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
  function patchAdapter(app) {
    socket_io_adapter_1.Adapter.prototype.addAll = function(id3, rooms) {
      const isNew = !this.sids.has(id3);
      addAll.call(this, id3, rooms);
      const socket = this.nsp.sockets.get(id3) || this.nsp._preConnectSockets.get(id3);
      if (!socket) {
        return;
      }
      if (socket.conn.transport.name === "websocket") {
        subscribe(this.nsp.name, socket, isNew, rooms);
        return;
      }
      if (isNew) {
        socket.conn.on("upgrade", () => {
          const rooms2 = this.sids.get(id3);
          if (rooms2) {
            subscribe(this.nsp.name, socket, isNew, rooms2);
          }
        });
      }
    };
    socket_io_adapter_1.Adapter.prototype.del = function(id3, room) {
      del.call(this, id3, room);
      const socket = this.nsp.sockets.get(id3) || this.nsp._preConnectSockets.get(id3);
      if (socket && socket.conn.transport.name === "websocket") {
        const sessionId = socket.conn.id;
        const websocket = socket.conn.transport.socket;
        const topic = `${this.nsp.name}${SEPARATOR}${room}`;
        debug("unsubscribe connection %s from topic %s", sessionId, topic);
        websocket.unsubscribe(topic);
      }
    };
    socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
      const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
      if (!useFastPublish) {
        broadcast.call(this, packet, opts);
        return;
      }
      const flags = opts.flags || {};
      const basePacketOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      const encodedPackets = this.encoder.encode(packet);
      const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
      debug("fast publish to %s", topic);
      encodedPackets.forEach((encodedPacket) => {
        const isBinary = typeof encodedPacket !== "string";
        app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
      });
      this.apply(opts, (socket) => {
        if (socket.conn.transport.name !== "websocket") {
          socket.client.writeToEngine(encodedPackets, basePacketOpts);
        }
      });
    };
  }
  function subscribe(namespaceName, socket, isNew, rooms) {
    const sessionId = socket.conn.id;
    const websocket = socket.conn.transport.socket;
    if (isNew) {
      debug("subscribe connection %s to topic %s", sessionId, namespaceName);
      websocket.subscribe(namespaceName);
    }
    rooms.forEach((room) => {
      const topic = `${namespaceName}${SEPARATOR}${room}`;
      debug("subscribe connection %s to topic %s", sessionId, topic);
      websocket.subscribe(topic);
    });
  }
  function restoreAdapter() {
    socket_io_adapter_1.Adapter.prototype.addAll = addAll;
    socket_io_adapter_1.Adapter.prototype.del = del;
    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
  }
  var toArrayBuffer = (buffer) => {
    const { buffer: arrayBuffer, byteOffset, byteLength: byteLength2 } = buffer;
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength2);
  };
  function serveFile(res, filepath) {
    const { size } = (0, fs_1.statSync)(filepath);
    const readStream = (0, fs_1.createReadStream)(filepath);
    const destroyReadStream = () => !readStream.destroyed && readStream.destroy();
    const onError = (error2) => {
      destroyReadStream();
      throw error2;
    };
    const onDataChunk = (chunk) => {
      const arrayBufferChunk = toArrayBuffer(chunk);
      res.cork(() => {
        const lastOffset = res.getWriteOffset();
        const [ok2, done] = res.tryEnd(arrayBufferChunk, size);
        if (!done && !ok2) {
          readStream.pause();
          res.onWritable((offset) => {
            const [ok3, done2] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
            if (!done2 && ok3) {
              readStream.resume();
            }
            return ok3;
          });
        }
      });
    };
    res.onAborted(destroyReadStream);
    readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
  }
});

// ../../../../node_modules/socket.io/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "socket.io",
    version: "4.8.1",
    description: "node.js realtime framework server",
    keywords: [
      "realtime",
      "framework",
      "websocket",
      "tcp",
      "events",
      "socket",
      "io"
    ],
    files: [
      "dist/",
      "client-dist/",
      "wrapper.mjs",
      "!**/*.tsbuildinfo"
    ],
    directories: {
      doc: "docs/",
      example: "example/",
      lib: "lib/",
      test: "test/"
    },
    type: "commonjs",
    main: "./dist/index.js",
    exports: {
      types: "./dist/index.d.ts",
      import: "./wrapper.mjs",
      require: "./dist/index.js"
    },
    types: "./dist/index.d.ts",
    license: "MIT",
    homepage: "https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme",
    repository: {
      type: "git",
      url: "git+https://github.com/socketio/socket.io.git"
    },
    bugs: {
      url: "https://github.com/socketio/socket.io/issues"
    },
    scripts: {
      compile: "rimraf ./dist && tsc",
      test: "npm run format:check && npm run compile && npm run test:types && npm run test:unit",
      "test:types": "tsd",
      "test:unit": "nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts",
      "format:check": 'prettier --check "lib/**/*.ts" "test/**/*.ts"',
      "format:fix": 'prettier --write "lib/**/*.ts" "test/**/*.ts"',
      prepack: "npm run compile"
    },
    dependencies: {
      accepts: "~1.3.4",
      base64id: "~2.0.0",
      cors: "~2.8.5",
      debug: "~4.3.2",
      "engine.io": "~6.6.0",
      "socket.io-adapter": "~2.5.2",
      "socket.io-parser": "~4.2.4"
    },
    contributors: [
      {
        name: "Guillermo Rauch",
        email: "rauchg@gmail.com"
      },
      {
        name: "Arnout Kazemier",
        email: "info@3rd-eden.com"
      },
      {
        name: "Vladimir Dronnikov",
        email: "dronnikov@gmail.com"
      },
      {
        name: "Einar Otto Stangvik",
        email: "einaros@gmail.com"
      }
    ],
    engines: {
      node: ">=10.2.0"
    },
    tsd: {
      directory: "test"
    }
  };
});

// ../../../../node_modules/socket.io/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __dirname = "/Users/glennmichaeltorregosa/Documents/Projects/stacks/node_modules/socket.io/dist";
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    var desc = Object.getOwnPropertyDescriptor(m3, k3);
    if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m3[k3];
      } };
    }
    Object.defineProperty(o3, k22, desc);
  } : function(o3, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o3[k22] = m3[k3];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v2) {
    Object.defineProperty(o3, "default", { enumerable: true, value: v2 });
  } : function(o3, v2) {
    o3["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k3 in mod)
        if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
          __createBinding2(result2, mod, k3);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Namespace = exports.Socket = exports.Server = undefined;
  var http = __require("http");
  var fs_1 = __require("fs");
  var zlib_1 = __require("zlib");
  var accepts = require_accepts();
  var stream_1 = __require("stream");
  var path3 = __require("path");
  var engine_io_1 = require_engine_io();
  var client_1 = require_client();
  var events_1 = __require("events");
  var namespace_1 = require_namespace();
  Object.defineProperty(exports, "Namespace", { enumerable: true, get: function() {
    return namespace_1.Namespace;
  } });
  var parent_namespace_1 = require_parent_namespace();
  var socket_io_adapter_1 = require_dist();
  var parser2 = __importStar2(require_cjs3());
  var debug_1 = __importDefault2(require_src3());
  var socket_1 = require_socket2();
  Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
    return socket_1.Socket;
  } });
  var typed_events_1 = require_typed_events();
  var uws_1 = require_uws();
  var cors_1 = __importDefault2(require_lib());
  var debug = (0, debug_1.default)("socket.io:server");
  var clientVersion = require_package2().version;
  var dotMapRegex = /\.map/;

  class Server extends typed_events_1.StrictEventEmitter {
    constructor(srv, opts = {}) {
      super();
      this._nsps = new Map;
      this.parentNsps = new Map;
      this.parentNamespacesFromRegExp = new Map;
      if (typeof srv === "object" && srv instanceof Object && !srv.listen) {
        opts = srv;
        srv = undefined;
      }
      this.path(opts.path || "/socket.io");
      this.connectTimeout(opts.connectTimeout || 45000);
      this.serveClient(opts.serveClient !== false);
      this._parser = opts.parser || parser2;
      this.encoder = new this._parser.Encoder;
      this.opts = opts;
      if (opts.connectionStateRecovery) {
        opts.connectionStateRecovery = Object.assign({
          maxDisconnectionDuration: 2 * 60 * 1000,
          skipMiddlewares: true
        }, opts.connectionStateRecovery);
        this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
      } else {
        this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
      }
      opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
      this.sockets = this.of("/");
      if (srv || typeof srv == "number")
        this.attach(srv);
      if (this.opts.cors) {
        this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
      }
    }
    get _opts() {
      return this.opts;
    }
    serveClient(v2) {
      if (!arguments.length)
        return this._serveClient;
      this._serveClient = v2;
      return this;
    }
    _checkNamespace(name3, auth, fn2) {
      if (this.parentNsps.size === 0)
        return fn2(false);
      const keysIterator = this.parentNsps.keys();
      const run = () => {
        const nextFn = keysIterator.next();
        if (nextFn.done) {
          return fn2(false);
        }
        nextFn.value(name3, auth, (err, allow) => {
          if (err || !allow) {
            return run();
          }
          if (this._nsps.has(name3)) {
            debug("dynamic namespace %s already exists", name3);
            return fn2(this._nsps.get(name3));
          }
          const namespace2 = this.parentNsps.get(nextFn.value).createChild(name3);
          debug("dynamic namespace %s was created", name3);
          fn2(namespace2);
        });
      };
      run();
    }
    path(v2) {
      if (!arguments.length)
        return this._path;
      this._path = v2.replace(/\/$/, "");
      const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
      return this;
    }
    connectTimeout(v2) {
      if (v2 === undefined)
        return this._connectTimeout;
      this._connectTimeout = v2;
      return this;
    }
    adapter(v2) {
      if (!arguments.length)
        return this._adapter;
      this._adapter = v2;
      for (const nsp of this._nsps.values()) {
        nsp._initAdapter();
      }
      return this;
    }
    listen(srv, opts = {}) {
      return this.attach(srv, opts);
    }
    attach(srv, opts = {}) {
      if (typeof srv == "function") {
        const msg = "You are trying to attach socket.io to an express " + "request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      }
      if (Number(srv) == srv) {
        srv = Number(srv);
      }
      if (typeof srv == "number") {
        debug("creating http server and binding to %d", srv);
        const port = srv;
        srv = http.createServer((req, res) => {
          res.writeHead(404);
          res.end();
        });
        srv.listen(port);
      }
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
    attachApp(app, opts = {}) {
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      debug("creating uWebSockets.js-based engine with opts %j", opts);
      const engine = new engine_io_1.uServer(opts);
      engine.attach(app, opts);
      this.bind(engine);
      if (this._serveClient) {
        app.get(`${this._path}/*`, (res, req) => {
          if (!this.clientPathRegex.test(req.getUrl())) {
            req.setYield(true);
            return;
          }
          const filename = req.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
          const isMap2 = dotMapRegex.test(filename);
          const type = isMap2 ? "map" : "source";
          const expectedEtag = '"' + clientVersion + '"';
          const weakEtag = "W/" + expectedEtag;
          const etag = req.getHeader("if-none-match");
          if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
              debug("serve client %s 304", type);
              res.writeStatus("304 Not Modified");
              res.end();
              return;
            }
          }
          debug("serve client %s", type);
          res.writeHeader("cache-control", "public, max-age=0");
          res.writeHeader("content-type", "application/" + (isMap2 ? "json" : "javascript") + "; charset=utf-8");
          res.writeHeader("etag", expectedEtag);
          const filepath = path3.join(__dirname, "../client-dist/", filename);
          (0, uws_1.serveFile)(res, filepath);
        });
      }
      (0, uws_1.patchAdapter)(app);
    }
    initEngine(srv, opts) {
      debug("creating engine.io instance with opts %j", opts);
      this.eio = (0, engine_io_1.attach)(srv, opts);
      if (this._serveClient)
        this.attachServe(srv);
      this.httpServer = srv;
      this.bind(this.eio);
    }
    attachServe(srv) {
      debug("attaching client serving req handler");
      const evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", (req, res) => {
        if (this.clientPathRegex.test(req.url)) {
          if (this._corsMiddleware) {
            this._corsMiddleware(req, res, () => {
              this.serve(req, res);
            });
          } else {
            this.serve(req, res);
          }
        } else {
          for (let i2 = 0;i2 < evs.length; i2++) {
            evs[i2].call(srv, req, res);
          }
        }
      });
    }
    serve(req, res) {
      const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
      const isMap2 = dotMapRegex.test(filename);
      const type = isMap2 ? "map" : "source";
      const expectedEtag = '"' + clientVersion + '"';
      const weakEtag = "W/" + expectedEtag;
      const etag = req.headers["if-none-match"];
      if (etag) {
        if (expectedEtag === etag || weakEtag === etag) {
          debug("serve client %s 304", type);
          res.writeHead(304);
          res.end();
          return;
        }
      }
      debug("serve client %s", type);
      res.setHeader("Cache-Control", "public, max-age=0");
      res.setHeader("Content-Type", "application/" + (isMap2 ? "json" : "javascript") + "; charset=utf-8");
      res.setHeader("ETag", expectedEtag);
      Server.sendFile(filename, req, res);
    }
    static sendFile(filename, req, res) {
      const readStream = (0, fs_1.createReadStream)(path3.join(__dirname, "../client-dist/", filename));
      const encoding = accepts(req).encodings(["br", "gzip", "deflate"]);
      const onError = (err) => {
        if (err) {
          res.end();
        }
      };
      switch (encoding) {
        case "br":
          res.writeHead(200, { "content-encoding": "br" });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
          break;
        case "gzip":
          res.writeHead(200, { "content-encoding": "gzip" });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
          break;
        case "deflate":
          res.writeHead(200, { "content-encoding": "deflate" });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
          break;
        default:
          res.writeHead(200);
          (0, stream_1.pipeline)(readStream, res, onError);
      }
    }
    bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    onconnection(conn) {
      debug("incoming connection with id %s", conn.id);
      const client2 = new client_1.Client(this, conn);
      if (conn.protocol === 3) {
        client2.connect("/");
      }
      return this;
    }
    of(name3, fn2) {
      if (typeof name3 === "function" || name3 instanceof RegExp) {
        const parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug("initializing parent namespace %s", parentNsp.name);
        if (typeof name3 === "function") {
          this.parentNsps.set(name3, parentNsp);
        } else {
          this.parentNsps.set((nsp2, conn, next) => next(null, name3.test(nsp2)), parentNsp);
          this.parentNamespacesFromRegExp.set(name3, parentNsp);
        }
        if (fn2) {
          parentNsp.on("connect", fn2);
        }
        return parentNsp;
      }
      if (String(name3)[0] !== "/")
        name3 = "/" + name3;
      let nsp = this._nsps.get(name3);
      if (!nsp) {
        for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
          if (regex.test(name3)) {
            debug("attaching namespace %s to parent namespace %s", name3, regex);
            return parentNamespace.createChild(name3);
          }
        }
        debug("initializing namespace %s", name3);
        nsp = new namespace_1.Namespace(this, name3);
        this._nsps.set(name3, nsp);
        if (name3 !== "/") {
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }
      if (fn2)
        nsp.on("connect", fn2);
      return nsp;
    }
    async close(fn2) {
      await Promise.allSettled([...this._nsps.values()].map(async (nsp) => {
        nsp.sockets.forEach((socket) => {
          socket._onclose("server shutting down");
        });
        await nsp.adapter.close();
      }));
      this.engine.close();
      (0, uws_1.restoreAdapter)();
      if (this.httpServer) {
        this.httpServer.close(fn2);
      } else {
        fn2 && fn2();
      }
    }
    use(fn2) {
      this.sockets.use(fn2);
      return this;
    }
    to(room) {
      return this.sockets.to(room);
    }
    in(room) {
      return this.sockets.in(room);
    }
    except(room) {
      return this.sockets.except(room);
    }
    send(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    write(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    serverSideEmit(ev2, ...args) {
      return this.sockets.serverSideEmit(ev2, ...args);
    }
    serverSideEmitWithAck(ev2, ...args) {
      return this.sockets.serverSideEmitWithAck(ev2, ...args);
    }
    allSockets() {
      return this.sockets.allSockets();
    }
    compress(compress) {
      return this.sockets.compress(compress);
    }
    get volatile() {
      return this.sockets.volatile;
    }
    get local() {
      return this.sockets.local;
    }
    timeout(timeout) {
      return this.sockets.timeout(timeout);
    }
    fetchSockets() {
      return this.sockets.fetchSockets();
    }
    socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    disconnectSockets(close = false) {
      return this.sockets.disconnectSockets(close);
    }
  }
  exports.Server = Server;
  var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {
    return typeof events_1.EventEmitter.prototype[key] === "function";
  });
  emitterMethods.forEach(function(fn2) {
    Server.prototype[fn2] = function() {
      return this.sockets[fn2].apply(this.sockets, arguments);
    };
  });
  module.exports = (srv, opts) => new Server(srv, opts);
  module.exports.Server = Server;
  module.exports.Namespace = namespace_1.Namespace;
  module.exports.Socket = socket_1.Socket;
});

// ../router/src/router.ts
import { handleError as handleError2 } from "@stacksjs/error-handling";
import { log as log14 } from "@stacksjs/logging";
import { path as p3 } from "@stacksjs/path";
import { fs as fs2 } from "@stacksjs/storage";

// ../router/src/middleware.ts
import { userMiddlewarePath } from "@stacksjs/path";
// ../auth/src/authentication.ts
import { randomBytes as randomBytes2 } from "crypto";
import { config } from "@stacksjs/config";
import { HttpError as HttpError3 } from "@stacksjs/error-handling";

// ../auth/src/rate-limiter.ts
import { HttpError } from "@stacksjs/error-handling";
var MAX_ATTEMPTS = 5;
var LOCKOUT_DURATION = 15 * 60 * 1000;
var attemptStore = new Map;

class RateLimiter {
  static isRateLimited(email) {
    const now = Date.now();
    const userAttempts = attemptStore.get(email);
    if (!userAttempts)
      return false;
    if (userAttempts.lockedUntil > now)
      return true;
    if (userAttempts.attempts >= MAX_ATTEMPTS) {
      attemptStore.set(email, { attempts: 0, lockedUntil: now + LOCKOUT_DURATION });
      return true;
    }
    return false;
  }
  static recordFailedAttempt(email) {
    const userAttempts = attemptStore.get(email) || { attempts: 0, lockedUntil: 0 };
    userAttempts.attempts++;
    attemptStore.set(email, userAttempts);
  }
  static resetAttempts(email) {
    attemptStore.delete(email);
  }
  static validateAttempt(email) {
    if (this.isRateLimited(email))
      throw new HttpError(429, "Too many login attempts. Please try again later.");
  }
}

// ../auth/src/token.ts
import { Buffer as Buffer2 } from "buffer";
import { randomBytes } from "crypto";
import { HttpError as HttpError2 } from "@stacksjs/error-handling";

class TokenManager {
  static async createAccessToken(user) {
    const token = randomBytes(40).toString("hex");
    const result = await db.insertInto("oauth_access_tokens").values({
      oauth_client_id: 1,
      user_id: user.id,
      token,
      name: "auth-token",
      scopes: JSON.stringify(["read", "write", "admin"]),
      revoked: false,
      expires_at: sql`${new Date(Date.now() + 1000 * 60 * 60 * 24 * 30).toISOString()}`,
      created_at: sql`${new Date().toISOString()}`,
      updated_at: sql`${new Date().toISOString()}`
    }).executeTakeFirst();
    if (!result?.insertId)
      throw new HttpError2(500, "Failed to create access token");
    return token;
  }
  static async validateToken(token) {
    const accessToken = await db.selectFrom("oauth_access_tokens").where("token", "=", token).selectAll().executeTakeFirst();
    if (!accessToken)
      return false;
    if (accessToken.expires_at && new Date(accessToken.expires_at) < new Date) {
      await db.deleteFrom("oauth_access_tokens").where("id", "=", accessToken.id).execute();
      return false;
    }
    if (accessToken.revoked)
      return false;
    const lastUsed = accessToken.updated_at ? new Date(accessToken.updated_at) : new Date;
    const now = new Date;
    const hoursSinceLastUse = (now.getTime() - lastUsed.getTime()) / (1000 * 60 * 60);
    if (hoursSinceLastUse >= 24) {
      await this.rotateToken(token);
    } else {
      await db.updateTable("oauth_access_tokens").set({
        updated_at: sql`${now.toISOString()}`
      }).where("id", "=", accessToken.id).execute();
    }
    return true;
  }
  static async rotateToken(oldToken) {
    const accessToken = await db.selectFrom("oauth_access_tokens").where("token", "=", oldToken).selectAll().executeTakeFirst();
    if (!accessToken)
      return null;
    const newToken = randomBytes(40).toString("hex");
    await db.updateTable("oauth_access_tokens").set({
      token: newToken,
      updated_at: sql`${new Date().toISOString()}`
    }).where("id", "=", accessToken.id).execute();
    return newToken;
  }
  static async revokeToken(token) {
    await db.updateTable("oauth_access_tokens").set({
      revoked: true,
      updated_at: sql`${new Date().toISOString()}`
    }).where("token", "=", token).execute();
  }
  static async generateLongJWT(userId) {
    const randomPart = randomBytes(64).toString("base64");
    const header = {
      alg: "HS256",
      typ: "JWT"
    };
    const payload = {
      sub: userId,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 30,
      jti: randomBytes(16).toString("hex")
    };
    const encodedHeader = Buffer2.from(JSON.stringify(header)).toString("base64");
    const encodedPayload = Buffer2.from(JSON.stringify(payload)).toString("base64");
    return `${encodedHeader}.${encodedPayload}.${randomPart}`;
  }
}

// ../auth/src/authentication.ts
class Auth {
  static authUser = undefined;
  static clientSecret = undefined;
  static async getClientSecret() {
    if (this.clientSecret)
      return this.clientSecret;
    const client = await this.getPersonalAccessClient();
    this.clientSecret = client.secret;
    return client.secret;
  }
  static async getPersonalAccessClient() {
    const client = await db.selectFrom("oauth_clients").where("personal_access_client", "=", true).selectAll().executeTakeFirst();
    if (!client)
      throw new HttpError3(500, "No personal access client found. Please run `./buddy auth:token` to create a personal access client.");
    return client;
  }
  static async validateClient(clientId, clientSecret) {
    const client = await db.selectFrom("oauth_clients").where("id", "=", clientId).selectAll().executeTakeFirst();
    if (!client)
      return false;
    return client.secret === clientSecret;
  }
  static async attempt(credentials) {
    const username = config.auth.username || "email";
    const password = config.auth.password || "password";
    const email = credentials[username];
    let hashCheck = false;
    const user = await User_default.where("email", "=", email).first();
    const authPass = credentials[password] || "";
    if (user?.password)
      hashCheck = await verify(authPass, user.password, "bcrypt");
    if (!email)
      return false;
    if (hashCheck && user) {
      RateLimiter.resetAttempts(email);
      this.authUser = user;
      return true;
    }
    RateLimiter.recordFailedAttempt(email);
    return false;
  }
  static async createToken(user, name = config.auth.defaultTokenName || "auth-token") {
    const client = await this.getPersonalAccessClient();
    const clientSecret = await this.getClientSecret();
    const jwtToken = await TokenManager.generateLongJWT(user.id);
    const expiresAt = new Date;
    expiresAt.setDate(expiresAt.getDate() + 30);
    const result = await db.insertInto("oauth_access_tokens").values({
      user_id: user.id,
      oauth_client_id: client.id,
      name,
      token: jwtToken,
      scopes: "[]",
      revoked: false,
      expires_at: formatDate(expiresAt)
    }).executeTakeFirst();
    const insertId = Number(result?.insertId) || Number(result?.numInsertedOrUpdatedRows);
    if (!insertId)
      throw new HttpError3(500, "Failed to create token");
    const encryptedId = encrypt(insertId.toString(), clientSecret);
    return `${jwtToken}:${encryptedId}`;
  }
  static async requestToken(credentials, clientId, clientSecret) {
    const isValidClient = await this.validateClient(clientId, clientSecret);
    if (!isValidClient)
      throw new HttpError3(401, "Invalid client credentials");
    const isValid = await this.attempt(credentials);
    if (!isValid || !this.authUser)
      return null;
    return { token: await this.createToken(this.authUser, "user-auth-token") };
  }
  static async login(credentials) {
    const isValid = await this.attempt(credentials);
    if (!isValid || !this.authUser)
      return null;
    return { user: this.authUser, token: await this.createToken(this.authUser, "user-auth-token") };
  }
  static async rotateToken(oldToken) {
    const [jwtToken, tokenId] = oldToken.split(":");
    if (!tokenId || !jwtToken)
      return null;
    const clientSecret = await this.getClientSecret();
    const decryptedId = decrypt(tokenId, clientSecret);
    if (!decryptedId)
      return null;
    const accessToken = await db.selectFrom("oauth_access_tokens").where("id", "=", Number(decryptedId)).selectAll().executeTakeFirst();
    if (!accessToken)
      return null;
    const isValid = await verify(jwtToken, accessToken.token, "bcrypt");
    if (!isValid)
      return null;
    const newToken = randomBytes2(40).toString("hex");
    const hashedNewToken = await make(newToken, { algorithm: "bcrypt" });
    await db.updateTable("oauth_access_tokens").set({
      token: hashedNewToken,
      updated_at: formatDate(new Date)
    }).where("id", "=", accessToken.id).execute();
    const encryptedId = encrypt(accessToken.id.toString(), clientSecret);
    return `${newToken}:${encryptedId}`;
  }
  static async validateToken(token) {
    const [jwtToken, tokenId] = token.split(":");
    if (!tokenId || !jwtToken)
      return false;
    const clientSecret = await this.getClientSecret();
    const decryptedId = decrypt(tokenId, clientSecret);
    if (!decryptedId)
      return false;
    const accessToken = await db.selectFrom("oauth_access_tokens").where("id", "=", Number(decryptedId)).selectAll().executeTakeFirst();
    if (!accessToken)
      return false;
    if (accessToken.expires_at && new Date(accessToken.expires_at) < new Date) {
      await db.deleteFrom("oauth_access_tokens").where("id", "=", accessToken.id).execute();
      return false;
    }
    if (accessToken.revoked)
      return false;
    const lastUsed = accessToken.updated_at ? new Date(accessToken.updated_at) : new Date;
    const now = new Date;
    const hoursSinceLastUse = (now.getTime() - lastUsed.getTime()) / (1000 * 60 * 60);
    if (hoursSinceLastUse >= 24) {
      await this.rotateToken(token);
    } else {
      await db.updateTable("oauth_access_tokens").set({
        updated_at: formatDate(now)
      }).where("id", "=", accessToken.id).execute();
    }
    return true;
  }
  static async getUserFromToken(token) {
    const [jwtToken, tokenId] = token.split(":");
    if (!tokenId || !jwtToken)
      return;
    const clientSecret = await this.getClientSecret();
    const decryptedId = decrypt(tokenId, clientSecret);
    if (!decryptedId)
      return;
    const accessToken = await db.selectFrom("oauth_access_tokens").where("id", "=", Number(decryptedId)).selectAll().executeTakeFirst();
    if (!accessToken || accessToken.token !== jwtToken)
      return;
    if (accessToken.expires_at && new Date(accessToken.expires_at) < new Date) {
      await db.deleteFrom("oauth_access_tokens").where("id", "=", accessToken.id).execute();
      return;
    }
    if (accessToken.revoked)
      return;
    await db.updateTable("oauth_access_tokens").set({
      updated_at: formatDate(new Date)
    }).where("id", "=", accessToken.id).execute();
    if (!accessToken?.user_id)
      return;
    return await User_default.find(accessToken.user_id);
  }
  static async revokeToken(token) {
    const [jwtToken, tokenId] = token.split(":");
    if (!tokenId || !jwtToken)
      return;
    const clientSecret = await this.getClientSecret();
    const decryptedId = decrypt(tokenId, clientSecret);
    if (!decryptedId)
      return;
    await db.updateTable("oauth_access_tokens").set({ revoked: true }).where("id", "=", Number(decryptedId)).execute();
  }
  static async logout() {
    const bearerToken = request.bearerToken();
    if (bearerToken)
      await this.revokeToken(bearerToken);
    this.authUser = undefined;
  }
}
// ../auth/src/authenticator.ts
var import_otplib = __toESM(require_otplib(), 1);
var import_qrcode = __toESM(require_server(), 1);
import { handleError } from "@stacksjs/error-handling";
// ../auth/src/client.ts
import { HttpError as HttpError4, ok } from "@stacksjs/error-handling";
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js
var exports_isoBase64URL = {};
__export(exports_isoBase64URL, {
  trimPadding: () => trimPadding,
  toUTF8String: () => toUTF8String,
  toBuffer: () => toBuffer,
  toBase64: () => toBase642,
  isBase64URL: () => isBase64URL,
  isBase64: () => isBase64,
  fromUTF8String: () => fromUTF8String,
  fromBuffer: () => fromBuffer
});

// ../../../../node_modules/@hexagon/base64/src/base64.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var charsUrl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var genLookup = (target) => {
  const lookupTemp = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  const len = chars.length;
  for (let i = 0;i < len; i++) {
    lookupTemp[target.charCodeAt(i)] = i;
  }
  return lookupTemp;
};
var lookup = genLookup(chars);
var lookupUrl = genLookup(charsUrl);
var base64UrlPattern = /^[-A-Za-z0-9\-_]*$/;
var base64Pattern = /^[-A-Za-z0-9+/]*={0,3}$/;
var base64 = {};
base64.toArrayBuffer = (data, urlMode) => {
  const len = data.length;
  let bufferLength = data.length * 0.75, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (data[data.length - 1] === "=") {
    bufferLength--;
    if (data[data.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer), target = urlMode ? lookupUrl : lookup;
  for (i = 0;i < len; i += 4) {
    encoded1 = target[data.charCodeAt(i)];
    encoded2 = target[data.charCodeAt(i + 1)];
    encoded3 = target[data.charCodeAt(i + 2)];
    encoded4 = target[data.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
base64.fromArrayBuffer = (arrBuf, urlMode) => {
  const bytes = new Uint8Array(arrBuf);
  let i, result = "";
  const len = bytes.length, target = urlMode ? charsUrl : chars;
  for (i = 0;i < len; i += 3) {
    result += target[bytes[i] >> 2];
    result += target[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    result += target[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    result += target[bytes[i + 2] & 63];
  }
  const remainder = len % 3;
  if (remainder === 2) {
    result = result.substring(0, result.length - 1) + (urlMode ? "" : "=");
  } else if (remainder === 1) {
    result = result.substring(0, result.length - 2) + (urlMode ? "" : "==");
  }
  return result;
};
base64.toString = (str, urlMode) => {
  return new TextDecoder().decode(base64.toArrayBuffer(str, urlMode));
};
base64.fromString = (str, urlMode) => {
  return base64.fromArrayBuffer(new TextEncoder().encode(str), urlMode);
};
base64.validate = (encoded, urlMode) => {
  if (!(typeof encoded === "string" || encoded instanceof String)) {
    return false;
  }
  try {
    return urlMode ? base64UrlPattern.test(encoded) : base64Pattern.test(encoded);
  } catch (_e) {
    return false;
  }
};
base64.base64 = base64;
var base64_default = base64;

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js
function toBuffer(base64urlString, from = "base64url") {
  const _buffer = base64_default.toArrayBuffer(base64urlString, from === "base64url");
  return new Uint8Array(_buffer);
}
function fromBuffer(buffer, to = "base64url") {
  return base64_default.fromArrayBuffer(buffer, to === "base64url");
}
function toBase642(base64urlString) {
  const fromBase64Url = base64_default.toArrayBuffer(base64urlString, true);
  const toBase643 = base64_default.fromArrayBuffer(fromBase64Url);
  return toBase643;
}
function fromUTF8String(utf8String) {
  return base64_default.fromString(utf8String, true);
}
function toUTF8String(base64urlString) {
  return base64_default.toString(base64urlString, true);
}
function isBase64(input) {
  return base64_default.validate(input, false);
}
function isBase64URL(input) {
  input = trimPadding(input);
  return base64_default.validate(input, true);
}
function trimPadding(input) {
  return input.replace(/=/g, "");
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js
var exports_isoCBOR = {};
__export(exports_isoCBOR, {
  encode: () => encode,
  decodeFirst: () => decodeFirst
});

// ../../../../node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js
function decodeLength(data, argument, index) {
  if (argument < 24) {
    return [argument, 1];
  }
  const remainingDataLength = data.byteLength - index - 1;
  const view = new DataView(data.buffer, index + 1);
  let output;
  let bytes = 0;
  switch (argument) {
    case 24: {
      if (remainingDataLength > 0) {
        output = view.getUint8(0);
        bytes = 2;
      }
      break;
    }
    case 25: {
      if (remainingDataLength > 1) {
        output = view.getUint16(0, false);
        bytes = 3;
      }
      break;
    }
    case 26: {
      if (remainingDataLength > 3) {
        output = view.getUint32(0, false);
        bytes = 5;
      }
      break;
    }
    case 27: {
      if (remainingDataLength > 7) {
        const bigOutput = view.getBigUint64(0, false);
        if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {
          return [Number(bigOutput), 9];
        }
      }
      break;
    }
  }
  if (output && output >= 24) {
    return [output, bytes];
  }
  throw new Error("Length not supported or not well formed");
}
var MAJOR_TYPE_UNSIGNED_INTEGER = 0;
var MAJOR_TYPE_NEGATIVE_INTEGER = 1;
var MAJOR_TYPE_BYTE_STRING = 2;
var MAJOR_TYPE_TEXT_STRING = 3;
var MAJOR_TYPE_ARRAY = 4;
var MAJOR_TYPE_MAP = 5;
var MAJOR_TYPE_TAG = 6;
var MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;
function encodeLength(major, argument) {
  const majorEncoded = major << 5;
  if (argument < 0) {
    throw new Error("CBOR Data Item argument must not be negative");
  }
  let bigintArgument;
  if (typeof argument == "number") {
    if (!Number.isInteger(argument)) {
      throw new Error("CBOR Data Item argument must be an integer");
    }
    bigintArgument = BigInt(argument);
  } else {
    bigintArgument = argument;
  }
  if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {
    if (bigintArgument == 0n) {
      throw new Error("CBOR Data Item argument cannot be zero when negative");
    }
    bigintArgument = bigintArgument - 1n;
  }
  if (bigintArgument > 18446744073709551615n) {
    throw new Error("CBOR number out of range");
  }
  const buffer = new Uint8Array(8);
  const view = new DataView(buffer.buffer);
  view.setBigUint64(0, bigintArgument, false);
  if (bigintArgument <= 23) {
    return [majorEncoded | buffer[7]];
  } else if (bigintArgument <= 255) {
    return [majorEncoded | 24, buffer[7]];
  } else if (bigintArgument <= 65535) {
    return [majorEncoded | 25, ...buffer.slice(6)];
  } else if (bigintArgument <= 4294967295) {
    return [
      majorEncoded | 26,
      ...buffer.slice(4)
    ];
  } else {
    return [
      majorEncoded | 27,
      ...buffer
    ];
  }
}

// ../../../../node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js
class CBORTag {
  constructor(tag, value) {
    Object.defineProperty(this, "tagId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tagValue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.tagId = tag;
    this.tagValue = value;
  }
  get tag() {
    return this.tagId;
  }
  get value() {
    return this.tagValue;
  }
}
function decodeUnsignedInteger(data, argument, index) {
  return decodeLength(data, argument, index);
}
function decodeNegativeInteger(data, argument, index) {
  const [value, length] = decodeUnsignedInteger(data, argument, index);
  return [-value - 1, length];
}
function decodeByteString(data, argument, index) {
  const [lengthValue, lengthConsumed] = decodeLength(data, argument, index);
  const dataStartIndex = index + lengthConsumed;
  return [
    new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),
    lengthConsumed + lengthValue
  ];
}
var TEXT_DECODER = new TextDecoder;
function decodeString(data, argument, index) {
  const [value, length] = decodeByteString(data, argument, index);
  return [TEXT_DECODER.decode(value), length];
}
function decodeArray(data, argument, index) {
  if (argument === 0) {
    return [[], 1];
  }
  const [length, lengthConsumed] = decodeLength(data, argument, index);
  let consumedLength = lengthConsumed;
  const value = [];
  for (let i = 0;i < length; i++) {
    const remainingDataLength = data.byteLength - index - consumedLength;
    if (remainingDataLength <= 0) {
      throw new Error("array is not supported or well formed");
    }
    const [decodedValue, consumed] = decodeNext(data, index + consumedLength);
    value.push(decodedValue);
    consumedLength += consumed;
  }
  return [value, consumedLength];
}
var MAP_ERROR = "Map is not supported or well formed";
function decodeMap(data, argument, index) {
  if (argument === 0) {
    return [new Map, 1];
  }
  const [length, lengthConsumed] = decodeLength(data, argument, index);
  let consumedLength = lengthConsumed;
  const result = new Map;
  for (let i = 0;i < length; i++) {
    let remainingDataLength = data.byteLength - index - consumedLength;
    if (remainingDataLength <= 0) {
      throw new Error(MAP_ERROR);
    }
    const [key, keyConsumed] = decodeNext(data, index + consumedLength);
    consumedLength += keyConsumed;
    remainingDataLength -= keyConsumed;
    if (remainingDataLength <= 0) {
      throw new Error(MAP_ERROR);
    }
    if (typeof key !== "string" && typeof key !== "number") {
      throw new Error(MAP_ERROR);
    }
    if (result.has(key)) {
      throw new Error(MAP_ERROR);
    }
    const [value, valueConsumed] = decodeNext(data, index + consumedLength);
    consumedLength += valueConsumed;
    result.set(key, value);
  }
  return [result, consumedLength];
}
function decodeFloat16(data, index) {
  if (index + 3 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 16");
  }
  const result = data.getUint16(index + 1, false);
  if (result == 31744) {
    return [Infinity, 3];
  } else if (result == 32256) {
    return [NaN, 3];
  } else if (result == 64512) {
    return [-Infinity, 3];
  }
  throw new Error("Float16 data is unsupported");
}
function decodeFloat32(data, index) {
  if (index + 5 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 32");
  }
  const result = data.getFloat32(index + 1, false);
  return [result, 5];
}
function decodeFloat64(data, index) {
  if (index + 9 > data.byteLength) {
    throw new Error("CBOR stream ended before end of Float 64");
  }
  const result = data.getFloat64(index + 1, false);
  return [result, 9];
}
function decodeTag(data, argument, index) {
  const [tag, tagBytes] = decodeLength(data, argument, index);
  const [value, valueBytes] = decodeNext(data, index + tagBytes);
  return [new CBORTag(tag, value), tagBytes + valueBytes];
}
function decodeNext(data, index) {
  if (index >= data.byteLength) {
    throw new Error("CBOR stream ended before tag value");
  }
  const byte = data.getUint8(index);
  const majorType = byte >> 5;
  const argument = byte & 31;
  switch (majorType) {
    case MAJOR_TYPE_UNSIGNED_INTEGER: {
      return decodeUnsignedInteger(data, argument, index);
    }
    case MAJOR_TYPE_NEGATIVE_INTEGER: {
      return decodeNegativeInteger(data, argument, index);
    }
    case MAJOR_TYPE_BYTE_STRING: {
      return decodeByteString(data, argument, index);
    }
    case MAJOR_TYPE_TEXT_STRING: {
      return decodeString(data, argument, index);
    }
    case MAJOR_TYPE_ARRAY: {
      return decodeArray(data, argument, index);
    }
    case MAJOR_TYPE_MAP: {
      return decodeMap(data, argument, index);
    }
    case MAJOR_TYPE_TAG: {
      return decodeTag(data, argument, index);
    }
    case MAJOR_TYPE_SIMPLE_OR_FLOAT: {
      switch (argument) {
        case 20:
          return [false, 1];
        case 21:
          return [true, 1];
        case 22:
          return [null, 1];
        case 23:
          return [undefined, 1];
        case 25:
          return decodeFloat16(data, index);
        case 26:
          return decodeFloat32(data, index);
        case 27:
          return decodeFloat64(data, index);
      }
    }
  }
  throw new Error(`Unsupported or not well formed at ${index}`);
}
function encodeSimple(data) {
  if (data === true) {
    return 245;
  } else if (data === false) {
    return 244;
  } else if (data === null) {
    return 246;
  }
  return 247;
}
function encodeFloat(data) {
  if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {
    const output = new Uint8Array(5);
    output[0] = 250;
    const view = new DataView(output.buffer);
    view.setFloat32(1, data, false);
    return output;
  } else {
    const output = new Uint8Array(9);
    output[0] = 251;
    const view = new DataView(output.buffer);
    view.setFloat64(1, data, false);
    return output;
  }
}
function encodeNumber(data) {
  if (typeof data == "number") {
    if (Number.isSafeInteger(data)) {
      if (data < 0) {
        return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));
      } else {
        return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);
      }
    }
    return [encodeFloat(data)];
  } else {
    if (data < 0n) {
      return encodeLength(MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);
    } else {
      return encodeLength(MAJOR_TYPE_UNSIGNED_INTEGER, data);
    }
  }
}
var ENCODER = new TextEncoder;
function encodeString(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_TEXT_STRING, data.length));
  output.push(ENCODER.encode(data));
}
function encodeBytes(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_BYTE_STRING, data.length));
  output.push(data);
}
function encodeArray(data, output) {
  output.push(...encodeLength(MAJOR_TYPE_ARRAY, data.length));
  for (const element of data) {
    encodePartialCBOR(element, output);
  }
}
function encodeMap(data, output) {
  output.push(new Uint8Array(encodeLength(MAJOR_TYPE_MAP, data.size)));
  for (const [key, value] of data.entries()) {
    encodePartialCBOR(key, output);
    encodePartialCBOR(value, output);
  }
}
function encodeTag(tag, output) {
  output.push(...encodeLength(MAJOR_TYPE_TAG, tag.tag));
  encodePartialCBOR(tag.value, output);
}
function encodePartialCBOR(data, output) {
  if (typeof data == "boolean" || data === null || data == undefined) {
    output.push(encodeSimple(data));
    return;
  }
  if (typeof data == "number" || typeof data == "bigint") {
    output.push(...encodeNumber(data));
    return;
  }
  if (typeof data == "string") {
    encodeString(data, output);
    return;
  }
  if (data instanceof Uint8Array) {
    encodeBytes(data, output);
    return;
  }
  if (Array.isArray(data)) {
    encodeArray(data, output);
    return;
  }
  if (data instanceof Map) {
    encodeMap(data, output);
    return;
  }
  if (data instanceof CBORTag) {
    encodeTag(data, output);
    return;
  }
  throw new Error("Not implemented");
}
function decodePartialCBOR(data, index) {
  if (data.byteLength === 0 || data.byteLength <= index || index < 0) {
    throw new Error("No data");
  }
  if (data instanceof Uint8Array) {
    return decodeNext(new DataView(data.buffer), index);
  } else if (data instanceof ArrayBuffer) {
    return decodeNext(new DataView(data), index);
  }
  return decodeNext(data, index);
}
function encodeCBOR(data) {
  const results = [];
  encodePartialCBOR(data, results);
  let length = 0;
  for (const result of results) {
    if (typeof result == "number") {
      length += 1;
    } else {
      length += result.length;
    }
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const result of results) {
    if (typeof result == "number") {
      output[index] = result;
      index += 1;
    } else {
      output.set(result, index);
      index += result.length;
    }
  }
  return output;
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js
function decodeFirst(input) {
  const _input = new Uint8Array(input);
  const decoded = decodePartialCBOR(_input, 0);
  const [first] = decoded;
  return first;
}
function encode(input) {
  return encodeCBOR(input);
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/index.js
var exports_isoCrypto = {};
__export(exports_isoCrypto, {
  verify: () => verify2,
  getRandomValues: () => getRandomValues,
  digest: () => digest
});

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/cose.js
function isCOSEPublicKeyOKP(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.OKP;
}
function isCOSEPublicKeyEC2(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.EC2;
}
function isCOSEPublicKeyRSA(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.RSA;
}
var COSEKEYS;
(function(COSEKEYS2) {
  COSEKEYS2[COSEKEYS2["kty"] = 1] = "kty";
  COSEKEYS2[COSEKEYS2["alg"] = 3] = "alg";
  COSEKEYS2[COSEKEYS2["crv"] = -1] = "crv";
  COSEKEYS2[COSEKEYS2["x"] = -2] = "x";
  COSEKEYS2[COSEKEYS2["y"] = -3] = "y";
  COSEKEYS2[COSEKEYS2["n"] = -1] = "n";
  COSEKEYS2[COSEKEYS2["e"] = -2] = "e";
})(COSEKEYS || (COSEKEYS = {}));
var COSEKTY;
(function(COSEKTY2) {
  COSEKTY2[COSEKTY2["OKP"] = 1] = "OKP";
  COSEKTY2[COSEKTY2["EC2"] = 2] = "EC2";
  COSEKTY2[COSEKTY2["RSA"] = 3] = "RSA";
})(COSEKTY || (COSEKTY = {}));
function isCOSEKty(kty) {
  return Object.values(COSEKTY).indexOf(kty) >= 0;
}
var COSECRV;
(function(COSECRV2) {
  COSECRV2[COSECRV2["P256"] = 1] = "P256";
  COSECRV2[COSECRV2["P384"] = 2] = "P384";
  COSECRV2[COSECRV2["P521"] = 3] = "P521";
  COSECRV2[COSECRV2["ED25519"] = 6] = "ED25519";
  COSECRV2[COSECRV2["SECP256K1"] = 8] = "SECP256K1";
})(COSECRV || (COSECRV = {}));
function isCOSECrv(crv) {
  return Object.values(COSECRV).indexOf(crv) >= 0;
}
var COSEALG;
(function(COSEALG2) {
  COSEALG2[COSEALG2["ES256"] = -7] = "ES256";
  COSEALG2[COSEALG2["EdDSA"] = -8] = "EdDSA";
  COSEALG2[COSEALG2["ES384"] = -35] = "ES384";
  COSEALG2[COSEALG2["ES512"] = -36] = "ES512";
  COSEALG2[COSEALG2["PS256"] = -37] = "PS256";
  COSEALG2[COSEALG2["PS384"] = -38] = "PS384";
  COSEALG2[COSEALG2["PS512"] = -39] = "PS512";
  COSEALG2[COSEALG2["ES256K"] = -47] = "ES256K";
  COSEALG2[COSEALG2["RS256"] = -257] = "RS256";
  COSEALG2[COSEALG2["RS384"] = -258] = "RS384";
  COSEALG2[COSEALG2["RS512"] = -259] = "RS512";
  COSEALG2[COSEALG2["RS1"] = -65535] = "RS1";
})(COSEALG || (COSEALG = {}));
function isCOSEAlg(alg) {
  return Object.values(COSEALG).indexOf(alg) >= 0;
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoAlg.js
function mapCoseAlgToWebCryptoAlg(alg) {
  if ([COSEALG.RS1].indexOf(alg) >= 0) {
    return "SHA-1";
  } else if ([COSEALG.ES256, COSEALG.PS256, COSEALG.RS256].indexOf(alg) >= 0) {
    return "SHA-256";
  } else if ([COSEALG.ES384, COSEALG.PS384, COSEALG.RS384].indexOf(alg) >= 0) {
    return "SHA-384";
  } else if ([COSEALG.ES512, COSEALG.PS512, COSEALG.RS512, COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "SHA-512";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto alg`);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getWebCrypto.js
var webCrypto = undefined;
function getWebCrypto() {
  const toResolve = new Promise((resolve, reject) => {
    if (webCrypto) {
      return resolve(webCrypto);
    }
    const _globalThisCrypto = _getWebCryptoInternals.stubThisGlobalThisCrypto();
    if (_globalThisCrypto) {
      webCrypto = _globalThisCrypto;
      return resolve(webCrypto);
    }
    return reject(new MissingWebCrypto);
  });
  return toResolve;
}

class MissingWebCrypto extends Error {
  constructor() {
    const message = "An instance of the Crypto API could not be located";
    super(message);
    this.name = "MissingWebCrypto";
  }
}
var _getWebCryptoInternals = {
  stubThisGlobalThisCrypto: () => globalThis.crypto,
  setCachedCrypto: (newCrypto) => {
    webCrypto = newCrypto;
  }
};

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/digest.js
async function digest(data, algorithm) {
  const WebCrypto = await getWebCrypto();
  const subtleAlgorithm = mapCoseAlgToWebCryptoAlg(algorithm);
  const hashed = await WebCrypto.subtle.digest(subtleAlgorithm, data);
  return new Uint8Array(hashed);
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getRandomValues.js
async function getRandomValues(array) {
  const WebCrypto = await getWebCrypto();
  WebCrypto.getRandomValues(array);
  return array;
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/importKey.js
async function importKey(opts) {
  const WebCrypto = await getWebCrypto();
  const { keyData, algorithm } = opts;
  return WebCrypto.subtle.importKey("jwk", keyData, algorithm, false, [
    "verify"
  ]);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyEC2.js
async function verifyEC2(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x = cosePublicKey.get(COSEKEYS.x);
  const y = cosePublicKey.get(COSEKEYS.y);
  if (!alg) {
    throw new Error("Public key was missing alg (EC2)");
  }
  if (!crv) {
    throw new Error("Public key was missing crv (EC2)");
  }
  if (!x) {
    throw new Error("Public key was missing x (EC2)");
  }
  if (!y) {
    throw new Error("Public key was missing y (EC2)");
  }
  let _crv;
  if (crv === COSECRV.P256) {
    _crv = "P-256";
  } else if (crv === COSECRV.P384) {
    _crv = "P-384";
  } else if (crv === COSECRV.P521) {
    _crv = "P-521";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);
  }
  const keyData = {
    kty: "EC",
    crv: _crv,
    x: exports_isoBase64URL.fromBuffer(x),
    y: exports_isoBase64URL.fromBuffer(y),
    ext: false
  };
  const keyAlgorithm = {
    name: "ECDSA",
    namedCurve: _crv
  };
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  let subtleAlg = mapCoseAlgToWebCryptoAlg(alg);
  if (shaHashOverride) {
    subtleAlg = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  const verifyAlgorithm = {
    name: "ECDSA",
    hash: { name: subtleAlg }
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoKeyAlgName.js
function mapCoseAlgToWebCryptoKeyAlgName(alg) {
  if ([COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "Ed25519";
  } else if ([COSEALG.ES256, COSEALG.ES384, COSEALG.ES512, COSEALG.ES256K].indexOf(alg) >= 0) {
    return "ECDSA";
  } else if ([COSEALG.RS256, COSEALG.RS384, COSEALG.RS512, COSEALG.RS1].indexOf(alg) >= 0) {
    return "RSASSA-PKCS1-v1_5";
  } else if ([COSEALG.PS256, COSEALG.PS384, COSEALG.PS512].indexOf(alg) >= 0) {
    return "RSA-PSS";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto key alg name`);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyRSA.js
async function verifyRSA(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const n = cosePublicKey.get(COSEKEYS.n);
  const e = cosePublicKey.get(COSEKEYS.e);
  if (!alg) {
    throw new Error("Public key was missing alg (RSA)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (RSA)`);
  }
  if (!n) {
    throw new Error("Public key was missing n (RSA)");
  }
  if (!e) {
    throw new Error("Public key was missing e (RSA)");
  }
  const keyData = {
    kty: "RSA",
    alg: "",
    n: exports_isoBase64URL.fromBuffer(n),
    e: exports_isoBase64URL.fromBuffer(e),
    ext: false
  };
  const keyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg),
    hash: { name: mapCoseAlgToWebCryptoAlg(alg) }
  };
  const verifyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg)
  };
  if (shaHashOverride) {
    keyAlgorithm.hash.name = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  if (keyAlgorithm.name === "RSASSA-PKCS1-v1_5") {
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "RS256";
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "RS384";
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "RS512";
    } else if (keyAlgorithm.hash.name === "SHA-1") {
      keyData.alg = "RS1";
    }
  } else if (keyAlgorithm.name === "RSA-PSS") {
    let saltLength = 0;
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "PS256";
      saltLength = 32;
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "PS384";
      saltLength = 48;
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "PS512";
      saltLength = 64;
    }
    verifyAlgorithm.saltLength = saltLength;
  } else {
    throw new Error(`Unexpected RSA key algorithm ${alg} (${keyAlgorithm.name})`);
  }
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/convertAAGUIDToString.js
function convertAAGUIDToString(aaguid) {
  const hex = exports_isoUint8Array.toHex(aaguid);
  const segments = [
    hex.slice(0, 8),
    hex.slice(8, 12),
    hex.slice(12, 16),
    hex.slice(16, 20),
    hex.slice(20, 32)
  ];
  return segments.join("-");
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/convertCertBufferToPEM.js
function convertCertBufferToPEM(certBuffer) {
  let b64cert;
  if (typeof certBuffer === "string") {
    if (exports_isoBase64URL.isBase64URL(certBuffer)) {
      b64cert = exports_isoBase64URL.toBase64(certBuffer);
    } else if (exports_isoBase64URL.isBase64(certBuffer)) {
      b64cert = certBuffer;
    } else {
      throw new Error("Certificate is not a valid base64 or base64url string");
    }
  } else {
    b64cert = exports_isoBase64URL.fromBuffer(certBuffer, "base64");
  }
  let PEMKey = "";
  for (let i = 0;i < Math.ceil(b64cert.length / 64); i += 1) {
    const start = 64 * i;
    PEMKey += `${b64cert.substr(start, 64)}
`;
  }
  PEMKey = `-----BEGIN CERTIFICATE-----
${PEMKey}-----END CERTIFICATE-----
`;
  return PEMKey;
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/decodeCredentialPublicKey.js
function decodeCredentialPublicKey(publicKey) {
  return _decodeCredentialPublicKeyInternals.stubThis(exports_isoCBOR.decodeFirst(publicKey));
}
var _decodeCredentialPublicKeyInternals = {
  stubThis: (value) => value
};
// ../../../../node_modules/asn1js/build/index.es.js
var exports_index_es = {};
__export(exports_index_es, {
  verifySchema: () => verifySchema,
  fromBER: () => fromBER,
  compareSchema: () => compareSchema,
  VisibleString: () => VisibleString,
  ViewWriter: () => ViewWriter,
  VideotexString: () => VideotexString,
  ValueBlock: () => ValueBlock,
  Utf8String: () => Utf8String,
  UniversalString: () => UniversalString,
  UTCTime: () => UTCTime,
  TimeOfDay: () => TimeOfDay,
  TeletexString: () => TeletexString,
  TIME: () => TIME,
  Set: () => Set2,
  Sequence: () => Sequence,
  Repeated: () => Repeated,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier,
  RawData: () => RawData,
  PrintableString: () => PrintableString,
  Primitive: () => Primitive,
  OctetString: () => OctetString,
  ObjectIdentifier: () => ObjectIdentifier,
  NumericString: () => NumericString,
  Null: () => Null,
  Integer: () => Integer,
  IA5String: () => IA5String,
  HexBlock: () => HexBlock,
  GraphicString: () => GraphicString,
  GeneralizedTime: () => GeneralizedTime,
  GeneralString: () => GeneralString,
  Enumerated: () => Enumerated,
  EndOfContent: () => EndOfContent,
  Duration: () => Duration,
  DateTime: () => DateTime,
  DATE: () => DATE,
  Constructed: () => Constructed,
  Choice: () => Choice,
  CharacterString: () => CharacterString,
  Boolean: () => Boolean2,
  BmpString: () => BmpString,
  BitString: () => BitString,
  BaseStringBlock: () => BaseStringBlock,
  BaseBlock: () => BaseBlock,
  Any: () => Any
});

// ../../../../node_modules/pvtsutils/build/index.es.js
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";

class BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = BufferSourceConverter.toUint8Array(a);
    const bView = BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i = 0;i < aView.length; i++) {
      if (aView[i] !== bView[i]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer of buffers) {
      size += buffer.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer of buffers) {
      const view = this.toUint8Array(buffer);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
}
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f\s]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;

class Utf8Converter {
  static fromString(text) {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);
    for (let i = 0;i < s.length; i++) {
      uintArray[i] = s.charCodeAt(i);
    }
    return uintArray.buffer;
  }
  static toString(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let encodedString = "";
    for (let i = 0;i < buf.length; i++) {
      encodedString += String.fromCharCode(buf[i]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
}

class Utf16Converter {
  static toString(buffer, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
    const dataView = new DataView(arrayBuffer);
    let res = "";
    for (let i = 0;i < arrayBuffer.byteLength; i += 2) {
      const code = dataView.getUint16(i, littleEndian);
      res += String.fromCharCode(code);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView = new DataView(res);
    for (let i = 0;i < text.length; i++) {
      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
    }
    return res;
  }
}

class Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer, enc = "utf8") {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf);
      case "binary":
        return this.ToBinary(buf);
      case "hex":
        return this.ToHex(buf);
      case "base64":
        return this.ToBase64(buf);
      case "base64url":
        return this.ToBase64Url(buf);
      case "utf16le":
        return Utf16Converter.toString(buf, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf).toString("base64");
    }
  }
  static FromBase64(base642) {
    const formatted = this.formatString(base642);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url) {
    const formatted = this.formatString(base64url);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer);
      case "utf8":
        return Utf8Converter.toString(buffer);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i = 0;i < stringLength; i++) {
      resultView[i] = text.charCodeAt(i);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let res = "";
    for (let i = 0;i < buf.length; i++) {
      res += String.fromCharCode(buf[i]);
    }
    return res;
  }
  static ToHex(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let result = "";
    const len = buf.length;
    for (let i = 0;i < len; i++) {
      const byte = buf[i];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i = 0;i < formatted.length; i = i + 2) {
      const c = formatted.slice(i, i + 2);
      res[i / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer, littleEndian = false) {
    return Utf16Converter.toString(buffer, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base642) {
    const padCount = 4 - base642.length % 4;
    if (padCount < 4) {
      for (let i = 0;i < padCount; i++) {
        base642 += "=";
      }
    }
    return base642;
  }
  static formatString(data) {
    return (data === null || data === undefined ? undefined : data.replace(/[\n\r\t ]/g, "")) || "";
  }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";
function isEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// ../../../../node_modules/pvutils/build/utils.es.js
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1;i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i = 1;i < 8; i++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1;j >= 0; j--) {
        const basis = Math.pow(2, j * base);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0;i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0;j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i = 1;i < 8; i++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0;k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0;i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i = 0;i < dif; i++) {
    padding[i] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
var log2 = Math.log(2);

// ../../../../node_modules/asn1js/build/index.es.js
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0;i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}

class ViewWriter {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat(this.items);
  }
}
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var NAME = "name";
var VALUE_HEX_VIEW = "valueHexView";
var IS_HEX_ONLY = "isHexOnly";
var ID_BLOCK = "idBlock";
var TAG_CLASS = "tagClass";
var TAG_NUMBER = "tagNumber";
var IS_CONSTRUCTED = "isConstructed";
var FROM_BER = "fromBER";
var TO_BER = "toBER";
var LOCAL = "local";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a;
  return _a = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== undefined ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a.NAME = "hexBlock", _a;
}

class LocalBaseBlock {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock.NAME = "baseBlock";

class ValueBlock extends LocalBaseBlock {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock.NAME = "valueBlock";

class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== undefined ? _a : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== undefined ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== undefined ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== undefined ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0;i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0;i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0;i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0;i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock.NAME = "identificationBlock";

class LocalLengthBlock extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a, _b, _c;
    super();
    this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== undefined ? _a : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== undefined ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== undefined ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0;i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};

class BaseBlock extends LocalBaseBlock {
  constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter;
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  var _a;
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a = baseBlock.lenBlock) === null || _a === undefined ? undefined : _a.isIndefiniteForm);
}

class BaseStringBlock extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock.NAME = "BaseStringBlock";

class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;

class Primitive extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
}
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType;
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock;
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed : new typeStore.Primitive;
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}

class LocalConstructedValueBlock extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter;
    for (let i = 0;i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;

class Constructed extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split(`
`).map((o) => `  ${o}`).join(`
`));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join(`
`)}` : `${blockName} :`;
  }
}
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";

class LocalEndOfContentValueBlock extends ValueBlock {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER;
  }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;

class EndOfContent extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;

class Null extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";

class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;

class Boolean2 extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
}
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";

class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0;i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;

class OctetString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {}
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    const name = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;

class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {}
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;

class BitString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== undefined || (parameters.isConstructed = !!((_c = parameters.value) === null || _c === undefined ? undefined : _c.length));
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name} : ${value}`;
    }
  }
}
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max;i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length;p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1;i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first, second) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength;i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1;i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}

class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== undefined) {
      this.valueDec = value;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1;byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0;i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0;i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;

class Integer extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter;
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;

class Enumerated extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";

class LocalSidValueBlock extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0;i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock.NAME = "sidBlock";

class LocalObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock;
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;

class ObjectIdentifier extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";

class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0;i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0;i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0;i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0;i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";

class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock;
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0;i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock;
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0;i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0;i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;

class RelativeObjectIdentifier extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;

class Sequence extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;

class Set2 extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
}
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";

class LocalStringValueBlock extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock.NAME = "StringValueBlock";

class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";

class LocalSimpleStringBlock extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0;i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";

class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;

class Utf8String extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";

class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;

class BmpString extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";

class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0;i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0;i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1;j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;

class UniversalString extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;

class NumericString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;

class PrintableString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;

class TeletexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;

class VideotexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;

class IA5String extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;

class GraphicString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;

class VisibleString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;

class GeneralString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;

class CharacterString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;

class UTCTime extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0;i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0;i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2000 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;

class GeneralizedTime extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== undefined || (this.millisecond = 0);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1000 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1000 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1;j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;

class DATE extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;

class TimeOfDay extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;

class DateTime extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;

class Duration extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;

class TIME extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

class Any {
  constructor({ name = EMPTY_STRING, optional = false } = {}) {
    this.name = name;
    this.optional = optional;
  }
}

class Choice extends Any {
  constructor({ value = [], ...parameters } = {}) {
    super(parameters);
    this.value = value;
  }
}

class Repeated extends Any {
  constructor({ value = new Any, local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.local = local;
  }
}

class RawData {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value) {
    this.dataView = BufferSourceConverter.toUint8Array(value);
  }
  constructor({ data = EMPTY_VIEW } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
}
function compareSchema(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice) {
    for (const element of inputSchema.value) {
      const result = compareSchema(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any) {
    if (inputSchema.hasOwnProperty(NAME))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0;i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0;i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
    const asn1 = localFromBER(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema(asn1.result, asn1.result, inputSchema);
}

// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes;
(function(AsnTypeTypes2) {
  AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
  AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
  AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
})(AsnTypeTypes || (AsnTypeTypes = {}));
var AsnPropTypes;
(function(AsnPropTypes2) {
  AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
  AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
  AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
  AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
  AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
  AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
  AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
  AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
  AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
  AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
  AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
  AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
  AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
})(AsnPropTypes || (AsnPropTypes = {}));

// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
class BitString2 {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name) {
    return new BitString({ name });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value) {
    let bits = value.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
class OctetString2 {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString({ valueHex: this.buffer });
  }
  toSchema(name) {
    return new OctetString({ name });
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter = {
  fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecodeView,
  toASN: (value) => {
    if (value === null) {
      return new Null;
    }
    const schema = fromBER(value);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter = {
  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
  toASN: (value) => new Integer({ value: +value })
};
var AsnEnumeratedConverter = {
  fromASN: (value) => value.valueBlock.valueDec,
  toASN: (value) => new Enumerated({ value })
};
var AsnIntegerArrayBufferConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new Integer({ valueHex: value })
};
var AsnBitStringConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new BitString({ valueHex: value })
};
var AsnObjectIdentifierConverter = {
  fromASN: (value) => value.valueBlock.toString(),
  toASN: (value) => new ObjectIdentifier({ value })
};
var AsnBooleanConverter = {
  fromASN: (value) => value.valueBlock.value,
  toASN: (value) => new Boolean2({ value })
};
var AsnOctetStringConverter = {
  fromASN: (value) => value.valueBlock.valueHexView,
  toASN: (value) => new OctetString({ valueHex: value })
};
function createStringConverter(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
var AsnUtf8StringConverter = createStringConverter(Utf8String);
var AsnBmpStringConverter = createStringConverter(BmpString);
var AsnUniversalStringConverter = createStringConverter(UniversalString);
var AsnNumericStringConverter = createStringConverter(NumericString);
var AsnPrintableStringConverter = createStringConverter(PrintableString);
var AsnTeletexStringConverter = createStringConverter(TeletexString);
var AsnVideotexStringConverter = createStringConverter(VideotexString);
var AsnIA5StringConverter = createStringConverter(IA5String);
var AsnGraphicStringConverter = createStringConverter(GraphicString);
var AsnVisibleStringConverter = createStringConverter(VisibleString);
var AsnGeneralStringConverter = createStringConverter(GeneralString);
var AsnCharacterStringConverter = createStringConverter(CharacterString);
var AsnUTCTimeConverter = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new UTCTime({ valueDate: value })
};
var AsnGeneralizedTimeConverter = {
  fromASN: (value) => value.toDate(),
  toASN: (value) => new GeneralizedTime({ valueDate: value })
};
var AsnNullConverter = {
  fromASN: () => null,
  toASN: () => {
    return new Null;
  }
};
function defaultConverter(type) {
  switch (type) {
    case AsnPropTypes.Any:
      return AsnAnyConverter;
    case AsnPropTypes.BitString:
      return AsnBitStringConverter;
    case AsnPropTypes.BmpString:
      return AsnBmpStringConverter;
    case AsnPropTypes.Boolean:
      return AsnBooleanConverter;
    case AsnPropTypes.CharacterString:
      return AsnCharacterStringConverter;
    case AsnPropTypes.Enumerated:
      return AsnEnumeratedConverter;
    case AsnPropTypes.GeneralString:
      return AsnGeneralStringConverter;
    case AsnPropTypes.GeneralizedTime:
      return AsnGeneralizedTimeConverter;
    case AsnPropTypes.GraphicString:
      return AsnGraphicStringConverter;
    case AsnPropTypes.IA5String:
      return AsnIA5StringConverter;
    case AsnPropTypes.Integer:
      return AsnIntegerConverter;
    case AsnPropTypes.Null:
      return AsnNullConverter;
    case AsnPropTypes.NumericString:
      return AsnNumericStringConverter;
    case AsnPropTypes.ObjectIdentifier:
      return AsnObjectIdentifierConverter;
    case AsnPropTypes.OctetString:
      return AsnOctetStringConverter;
    case AsnPropTypes.PrintableString:
      return AsnPrintableStringConverter;
    case AsnPropTypes.TeletexString:
      return AsnTeletexStringConverter;
    case AsnPropTypes.UTCTime:
      return AsnUTCTimeConverter;
    case AsnPropTypes.UniversalString:
      return AsnUniversalStringConverter;
    case AsnPropTypes.Utf8String:
      return AsnUtf8StringConverter;
    case AsnPropTypes.VideotexString:
      return AsnVideotexStringConverter;
    case AsnPropTypes.VisibleString:
      return AsnVisibleStringConverter;
    default:
      return null;
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && ("toASN" in target) && ("fromASN" in target));
  }
}
function isTypeOfArray(target) {
  var _a2;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a2 = proto === null || proto === undefined ? undefined : proto.prototype) === null || _a2 === undefined ? undefined : _a2.constructor) === Array) {
      return true;
    }
    return isTypeOfArray(proto);
  }
  return false;
}
function isArrayEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0;i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/schema.js
class AsnSchemaStorage {
  constructor() {
    this.items = new WeakMap;
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = {
      type: AsnTypeTypes.Sequence,
      items: {}
    };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes[item.type];
        const Asn1Type = exports_index_es[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name });
      } else if (isConvertible(item.type)) {
        const instance = new item.type;
        asn1Item = instance.toSchema(name);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes.Choice) {
          asn1Item = new Any({ name });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name;
        }
      } else {
        asn1Item = new Any({ name });
      }
      const optional = !!item.optional || item.defaultValue !== undefined;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set2 : Sequence;
        asn1Item = new Container({
          name: "",
          value: [
            new Repeated({
              name,
              value: asn1Item
            })
          ]
        });
      }
      if (item.context !== null && item.context !== undefined) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible(item.type)) {
            const Container = item.repeated ? Constructed : Primitive;
            asn1Value.push(new Container({
              name,
              optional,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              }
            }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value = "valueBlock" in value ? value.valueBlock.value : value.value;
            asn1Value.push(new Constructed({
              name: !isRepeated ? name : "",
              optional,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              },
              value
            }));
          }
        } else {
          asn1Value.push(new Constructed({
            optional,
            idBlock: {
              tagClass: 3,
              tagNumber: item.context
            },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        return new Sequence({ value: asn1Value, name: "" });
      case AsnTypeTypes.Set:
        return new Set2({ value: asn1Value, name: "" });
      case AsnTypeTypes.Choice:
        return new Choice({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
}

// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage = new AsnSchemaStorage;

// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType = (options) => (target) => {
  let schema;
  if (!schemaStorage.has(target)) {
    schema = schemaStorage.createDefault(target);
    schemaStorage.set(target, schema);
  } else {
    schema = schemaStorage.get(target);
  }
  Object.assign(schema, options);
};
var AsnProp = (options) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage.has(target.constructor)) {
    schema = schemaStorage.createDefault(target.constructor);
    schemaStorage.set(target.constructor, schema);
  } else {
    schema = schemaStorage.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter2 = defaultConverter(options.type);
    if (!defaultConverter2) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter2;
  }
  schema.items[propertyKey] = copyOptions;
};
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
class AsnSchemaValidationError extends Error {
  constructor() {
    super(...arguments);
    this.schemas = [];
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/parser.js
class AsnParser {
  static parse(data, target) {
    const asn1Parsed = fromBER(data);
    if (asn1Parsed.result.error) {
      throw new Error(asn1Parsed.result.error);
    }
    const res = this.fromASN(asn1Parsed.result, target);
    return res;
  }
  static fromASN(asn1Schema, target) {
    var _a2;
    try {
      if (isConvertible(target)) {
        const value = new target;
        return value.fromASN(asn1Schema);
      }
      const schema = schemaStorage.get(target);
      schemaStorage.cache(target);
      let targetSchema = schema.schema;
      if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
        targetSchema = new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: asn1Schema.idBlock.tagNumber
          },
          value: schema.schema.valueBlock.value
        });
        for (const key in schema.items) {
          delete asn1Schema[key];
        }
      }
      const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
      }
      const res = new target;
      if (isTypeOfArray(target)) {
        if (!(("value" in asn1Schema.valueBlock) && Array.isArray(asn1Schema.valueBlock.value))) {
          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
        }
        const itemType = schema.itemType;
        if (typeof itemType === "number") {
          const converter = defaultConverter(itemType);
          if (!converter) {
            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
          }
          return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
        } else {
          return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
        }
      }
      for (const key in schema.items) {
        const asn1SchemaValue = asn1ComparedSchema.result[key];
        if (!asn1SchemaValue) {
          continue;
        }
        const schemaItem = schema.items[key];
        const schemaItemType = schemaItem.type;
        if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
          const converter = (_a2 = schemaItem.converter) !== null && _a2 !== undefined ? _a2 : isConvertible(schemaItemType) ? new schemaItemType : null;
          if (!converter) {
            throw new Error("Converter is empty");
          }
          if (schemaItem.repeated) {
            if (schemaItem.implicit) {
              const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
              const newItem = new Container;
              newItem.valueBlock = asn1SchemaValue.valueBlock;
              const newItemAsn = fromBER(newItem.toBER(false));
              if (newItemAsn.offset === -1) {
                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
              }
              if (!(("value" in newItemAsn.result.valueBlock) && Array.isArray(newItemAsn.result.valueBlock.value))) {
                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
              }
              const value = newItemAsn.result.valueBlock.value;
              res[key] = Array.from(value, (element) => converter.fromASN(element));
            } else {
              res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
            }
          } else {
            let value = asn1SchemaValue;
            if (schemaItem.implicit) {
              let newItem;
              if (isConvertible(schemaItemType)) {
                newItem = new schemaItemType().toSchema("");
              } else {
                const Asn1TypeName = AsnPropTypes[schemaItemType];
                const Asn1Type = exports_index_es[Asn1TypeName];
                if (!Asn1Type) {
                  throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                }
                newItem = new Asn1Type;
              }
              newItem.valueBlock = value.valueBlock;
              value = fromBER(newItem.toBER(false)).result;
            }
            res[key] = converter.fromASN(value);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(asn1SchemaValue)) {
              throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
            }
            res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
          } else {
            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
          }
        }
      }
      return res;
    } catch (error) {
      if (error instanceof AsnSchemaValidationError) {
        error.schemas.push(target.name);
      }
      throw error;
    }
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
class AsnSerializer {
  static serialize(obj) {
    if (obj instanceof BaseBlock) {
      return obj.toBER(false);
    }
    return this.toASN(obj).toBER(false);
  }
  static toASN(obj) {
    if (obj && typeof obj === "object" && isConvertible(obj)) {
      return obj.toASN();
    }
    if (!(obj && typeof obj === "object")) {
      throw new TypeError("Parameter 1 should be type of Object.");
    }
    const target = obj.constructor;
    const schema = schemaStorage.get(target);
    schemaStorage.cache(target);
    let asn1Value = [];
    if (schema.itemType) {
      if (!Array.isArray(obj)) {
        throw new TypeError("Parameter 1 should be type of Array.");
      }
      if (typeof schema.itemType === "number") {
        const converter = defaultConverter(schema.itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
        }
        asn1Value = obj.map((o) => converter.toASN(o));
      } else {
        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
      }
    } else {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        const objProp = obj[key];
        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
          continue;
        }
        const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
        if (typeof schemaItem.context === "number") {
          if (schemaItem.implicit) {
            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
              const value = {};
              value.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
              asn1Value.push(new Primitive({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                ...value
              }));
            } else {
              asn1Value.push(new Constructed({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: asn1Item.valueBlock.value
              }));
            }
          } else {
            asn1Value.push(new Constructed({
              optional: schemaItem.optional,
              idBlock: {
                tagClass: 3,
                tagNumber: schemaItem.context
              },
              value: [asn1Item]
            }));
          }
        } else if (schemaItem.repeated) {
          asn1Value = asn1Value.concat(asn1Item);
        } else {
          asn1Value.push(asn1Item);
        }
      }
    }
    let asnSchema;
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        asnSchema = new Sequence({ value: asn1Value });
        break;
      case AsnTypeTypes.Set:
        asnSchema = new Set2({ value: asn1Value });
        break;
      case AsnTypeTypes.Choice:
        if (!asn1Value[0]) {
          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
        }
        asnSchema = asn1Value[0];
        break;
    }
    return asnSchema;
  }
  static toAsnItem(schemaItem, key, target, objProp) {
    let asn1Item;
    if (typeof schemaItem.type === "number") {
      const converter = schemaItem.converter;
      if (!converter) {
        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
      }
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => converter.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = converter.toASN(objProp);
      }
    } else {
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => this.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = this.toASN(objProp);
      }
    }
    return asn1Item;
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/objects.js
class AsnArray extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
}
// ../../../../node_modules/@peculiar/asn1-schema/build/es2015/convert.js
class AsnConvert {
  static serialize(obj) {
    return AsnSerializer.serialize(obj);
  }
  static parse(data, target) {
    return AsnParser.parse(data, target);
  }
  static toString(data) {
    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);
    const asn = fromBER(buf);
    if (asn.offset === -1) {
      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
    }
    return asn.result.toString();
  }
}
// ../../../../node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
} = import_tslib.default;

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
class IpConverter {
  static isIPv4(ip) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip);
  }
  static parseIPv4(ip) {
    const parts = ip.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip) {
    const expandedIP = this.expandIPv6(ip);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip) {
    if (!ip.includes("::")) {
      return ip;
    }
    const parts = ip.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0;i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip) {
    const parts = ip.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value) {
    if (value.length === 64 && parseInt(value, 16) === 0) {
      return "::/0";
    }
    if (value.length !== 16) {
      return value;
    }
    const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip = value.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
    ip = ip.slice(0, -1);
    return `${ip}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0;i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
}

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_1;
var RDNSequence_1;
var Name_1;
var DirectoryString = class DirectoryString2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.TeletexString })
], DirectoryString.prototype, "teletexString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.PrintableString })
], DirectoryString.prototype, "printableString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.UniversalString })
], DirectoryString.prototype, "universalString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DirectoryString.prototype, "utf8String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DirectoryString.prototype, "bmpString", undefined);
DirectoryString = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DirectoryString);
var AttributeValue = class AttributeValue2 extends DirectoryString {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], AttributeValue.prototype, "ia5String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], AttributeValue.prototype, "anyValue", undefined);
AttributeValue = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], AttributeValue);
class AttributeTypeAndValue {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AttributeTypeAndValue.prototype, "type", undefined);
__decorate([
  AsnProp({ type: AttributeValue })
], AttributeTypeAndValue.prototype, "value", undefined);
var RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
  }
};
RelativeDistinguishedName = RelativeDistinguishedName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
], RelativeDistinguishedName);
var RDNSequence = RDNSequence_1 = class RDNSequence2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_1.prototype);
  }
};
RDNSequence = RDNSequence_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
], RDNSequence);
var Name = Name_1 = class Name2 extends RDNSequence {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_1.prototype);
  }
};
Name = Name_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], Name);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter = {
  fromASN: (value) => IpConverter.toString(AsnOctetStringConverter.fromASN(value)),
  toASN: (value) => AsnOctetStringConverter.toASN(IpConverter.fromString(value))
};

class OtherName {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherName.prototype, "typeId", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], OtherName.prototype, "value", undefined);

class EDIPartyName {
  constructor(params = {}) {
    this.partyName = new DirectoryString;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DirectoryString, optional: true, context: 0, implicit: true })
], EDIPartyName.prototype, "nameAssigner", undefined);
__decorate([
  AsnProp({ type: DirectoryString, context: 1, implicit: true })
], EDIPartyName.prototype, "partyName", undefined);
var GeneralName = class GeneralName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: OtherName, context: 0, implicit: true })
], GeneralName.prototype, "otherName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 1, implicit: true })
], GeneralName.prototype, "rfc822Name", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 2, implicit: true })
], GeneralName.prototype, "dNSName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 3, implicit: true })
], GeneralName.prototype, "x400Address", undefined);
__decorate([
  AsnProp({ type: Name, context: 4, implicit: false })
], GeneralName.prototype, "directoryName", undefined);
__decorate([
  AsnProp({ type: EDIPartyName, context: 5 })
], GeneralName.prototype, "ediPartyName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 6, implicit: true })
], GeneralName.prototype, "uniformResourceIdentifier", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter
  })
], GeneralName.prototype, "iPAddress", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
], GeneralName.prototype, "registeredID", undefined);
GeneralName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], GeneralName);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix = "1.3.6.1.5.5.7";
var id_pe = `${id_pkix}.1`;
var id_qt = `${id_pkix}.2`;
var id_kp = `${id_pkix}.3`;
var id_ad = `${id_pkix}.48`;
var id_qt_csp = `${id_qt}.1`;
var id_qt_unotice = `${id_qt}.2`;
var id_ad_ocsp = `${id_ad}.1`;
var id_ad_caIssuers = `${id_ad}.2`;
var id_ad_timeStamping = `${id_ad}.3`;
var id_ad_caRepository = `${id_ad}.5`;
var id_ce = "2.5.29";

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_1;
var id_pe_authorityInfoAccess = `${id_pe}.1`;

class AccessDescription {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AccessDescription.prototype, "accessMethod", undefined);
__decorate([
  AsnProp({ type: GeneralName })
], AccessDescription.prototype, "accessLocation", undefined);
var AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
  }
};
AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], AuthorityInfoAccessSyntax);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier = `${id_ce}.35`;

class KeyIdentifier extends OctetString2 {
}

class AuthorityKeyIdentifier {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
}
__decorate([
  AsnProp({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier.prototype, "keyIdentifier", undefined);
__decorate([
  AsnProp({ type: GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter
  })
], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints = `${id_ce}.19`;

class BasicConstraints {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, defaultValue: false })
], BasicConstraints.prototype, "cA", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], BasicConstraints.prototype, "pathLenConstraint", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_1;
var GeneralNames = GeneralNames_1 = class GeneralNames2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_1.prototype);
  }
};
GeneralNames = GeneralNames_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralName })
], GeneralNames);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_1;
var id_ce_certificateIssuer = `${id_ce}.29`;
var CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
  }
};
CertificateIssuer = CertificateIssuer_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], CertificateIssuer);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_1;
var id_ce_certificatePolicies = `${id_ce}.32`;
var id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
var DisplayText = class DisplayText2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], DisplayText.prototype, "ia5String", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.VisibleString })
], DisplayText.prototype, "visibleString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DisplayText.prototype, "bmpString", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DisplayText.prototype, "utf8String", undefined);
DisplayText = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DisplayText);
class NoticeReference {
  constructor(params = {}) {
    this.organization = new DisplayText;
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DisplayText })
], NoticeReference.prototype, "organization", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, repeated: "sequence" })
], NoticeReference.prototype, "noticeNumbers", undefined);

class UserNotice {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: NoticeReference, optional: true })
], UserNotice.prototype, "noticeRef", undefined);
__decorate([
  AsnProp({ type: DisplayText, optional: true })
], UserNotice.prototype, "explicitText", undefined);
var Qualifier = class Qualifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], Qualifier.prototype, "cPSuri", undefined);
__decorate([
  AsnProp({ type: UserNotice })
], Qualifier.prototype, "userNotice", undefined);
Qualifier = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Qualifier);
class PolicyQualifierInfo {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyQualifierInfo.prototype, "policyQualifierId", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], PolicyQualifierInfo.prototype, "qualifier", undefined);

class PolicyInformation {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyInformation.prototype, "policyIdentifier", undefined);
__decorate([
  AsnProp({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
], PolicyInformation.prototype, "policyQualifiers", undefined);
var CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
  }
};
CertificatePolicies = CertificatePolicies_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyInformation })
], CertificatePolicies);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber = `${id_ce}.20`;
var CRLNumber = class CRLNumber2 {
  constructor(value = 0) {
    this.value = value;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], CRLNumber.prototype, "value", undefined);
CRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLNumber);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator = `${id_ce}.27`;
var BaseCRLNumber = class BaseCRLNumber2 extends CRLNumber {
};
BaseCRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], BaseCRLNumber);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_1;
var id_ce_cRLDistributionPoints = `${id_ce}.31`;
var ReasonFlags;
(function(ReasonFlags2) {
  ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
  ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
  ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
  ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
  ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags || (ReasonFlags = {}));

class Reason extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}
var DistributionPointName = class DistributionPointName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: GeneralName, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName.prototype, "fullName", undefined);
__decorate([
  AsnProp({ type: RelativeDistinguishedName, context: 1, implicit: true })
], DistributionPointName.prototype, "nameRelativeToCRLIssuer", undefined);
DistributionPointName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DistributionPointName);
class DistributionPoint {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], DistributionPoint.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp({ type: Reason, context: 1, optional: true, implicit: true })
], DistributionPoint.prototype, "reasons", undefined);
__decorate([
  AsnProp({ type: GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint.prototype, "cRLIssuer", undefined);
var CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
  }
};
CRLDistributionPoints = CRLDistributionPoints_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], CRLDistributionPoints);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_1;
var id_ce_freshestCRL = `${id_ce}.46`;
var FreshestCRL = FreshestCRL_1 = class FreshestCRL2 extends CRLDistributionPoints {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_1.prototype);
  }
};
FreshestCRL = FreshestCRL_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], FreshestCRL);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint = `${id_ce}.28`;

class IssuingDistributionPoint {
  constructor(params = {}) {
    this.onlyContainsUserCerts = IssuingDistributionPoint.ONLY;
    this.onlyContainsCACerts = IssuingDistributionPoint.ONLY;
    this.indirectCRL = IssuingDistributionPoint.ONLY;
    this.onlyContainsAttributeCerts = IssuingDistributionPoint.ONLY;
    Object.assign(this, params);
  }
}
IssuingDistributionPoint.ONLY = false;
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], IssuingDistributionPoint.prototype, "distributionPoint", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsCACerts", undefined);
__decorate([
  AsnProp({ type: Reason, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint.prototype, "onlySomeReasons", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "indirectCRL", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons = `${id_ce}.21`;
var CRLReasons;
(function(CRLReasons2) {
  CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
  CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
  CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
  CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
  CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
})(CRLReasons || (CRLReasons = {}));
var CRLReason = class CRLReason2 {
  constructor(reason = CRLReasons.unspecified) {
    this.reason = CRLReasons.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], CRLReason.prototype, "reason", undefined);
CRLReason = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLReason);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_1;
var id_ce_extKeyUsage = `${id_ce}.37`;
var ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
  }
};
ExtendedKeyUsage = ExtendedKeyUsage_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
], ExtendedKeyUsage);
var anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
var id_kp_serverAuth = `${id_kp}.1`;
var id_kp_clientAuth = `${id_kp}.2`;
var id_kp_codeSigning = `${id_kp}.3`;
var id_kp_emailProtection = `${id_kp}.4`;
var id_kp_timeStamping = `${id_kp}.8`;
var id_kp_OCSPSigning = `${id_kp}.9`;
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy = `${id_ce}.54`;
var InhibitAnyPolicy = class InhibitAnyPolicy2 {
  constructor(value = new ArrayBuffer(0)) {
    this.value = value;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], InhibitAnyPolicy.prototype, "value", undefined);
InhibitAnyPolicy = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InhibitAnyPolicy);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate = `${id_ce}.24`;
var InvalidityDate = class InvalidityDate2 {
  constructor(value) {
    this.value = new Date;
    if (value) {
      this.value = value;
    }
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], InvalidityDate.prototype, "value", undefined);
InvalidityDate = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InvalidityDate);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_1;
var id_ce_issuerAltName = `${id_ce}.18`;
var IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
  }
};
IssueAlternativeName = IssueAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], IssueAlternativeName);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage = `${id_ce}.15`;
var KeyUsageFlags;
(function(KeyUsageFlags2) {
  KeyUsageFlags2[KeyUsageFlags2["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags2[KeyUsageFlags2["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags2[KeyUsageFlags2["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags2[KeyUsageFlags2["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags2[KeyUsageFlags2["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags2[KeyUsageFlags2["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags2[KeyUsageFlags2["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags2[KeyUsageFlags2["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags2[KeyUsageFlags2["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags || (KeyUsageFlags = {}));
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_1;
var id_ce_nameConstraints = `${id_ce}.30`;

class GeneralSubtree {
  constructor(params = {}) {
    this.base = new GeneralName;
    this.minimum = 0;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: GeneralName })
], GeneralSubtree.prototype, "base", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree.prototype, "minimum", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree.prototype, "maximum", undefined);
var GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
  }
};
GeneralSubtrees = GeneralSubtrees_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralSubtree })
], GeneralSubtrees);
class NameConstraints {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
], NameConstraints.prototype, "permittedSubtrees", undefined);
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
], NameConstraints.prototype, "excludedSubtrees", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints = `${id_ce}.36`;

class PolicyConstraints {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "requireExplicitPolicy", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "inhibitPolicyMapping", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_1;
var id_ce_policyMappings = `${id_ce}.33`;

class PolicyMapping {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "issuerDomainPolicy", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "subjectDomainPolicy", undefined);
var PolicyMappings = PolicyMappings_1 = class PolicyMappings2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_1.prototype);
  }
};
PolicyMappings = PolicyMappings_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyMapping })
], PolicyMappings);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_1;
var id_ce_subjectAltName = `${id_ce}.17`;
var SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
  }
};
SubjectAlternativeName = SubjectAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], SubjectAlternativeName);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
class Attribute {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Attribute.prototype, "type", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
], Attribute.prototype, "values", undefined);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_1;
var id_ce_subjectDirectoryAttributes = `${id_ce}.9`;
var SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
  }
};
SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
], SubjectDirectoryAttributes);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier = `${id_ce}.14`;

class SubjectKeyIdentifier extends KeyIdentifier {
}
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod = `${id_ce}.16`;

class PrivateKeyUsagePeriod {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notBefore", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notAfter", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags;
(function(EntrustInfoFlags2) {
  EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags || (EntrustInfoFlags = {}));

class EntrustInfo extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
}

class EntrustVersionInfo {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralString })
], EntrustVersionInfo.prototype, "entrustVers", undefined);
__decorate([
  AsnProp({ type: EntrustInfo })
], EntrustVersionInfo.prototype, "entrustInfoFlags", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_1;
var id_pe_subjectInfoAccess = `${id_pe}.11`;
var SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
  }
};
SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], SubjectInfoAccessSyntax);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
class AlgorithmIdentifier {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.ObjectIdentifier
  })
], AlgorithmIdentifier.prototype, "algorithm", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Any,
    optional: true
  })
], AlgorithmIdentifier.prototype, "parameters", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
class SubjectPublicKeyInfo {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier;
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], SubjectPublicKeyInfo.prototype, "algorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], SubjectPublicKeyInfo.prototype, "subjectPublicKey", undefined);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time = class Time2 {
  constructor(time) {
    if (time) {
      if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
        const date = new Date(time);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time);
      }
    }
  }
  getTime() {
    const time = this.utcTime || this.generalTime;
    if (!time) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time;
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.UTCTime
  })
], Time.prototype, "utcTime", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.GeneralizedTime
  })
], Time.prototype, "generalTime", undefined);
Time = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Time);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/validity.js
class Validity {
  constructor(params) {
    this.notBefore = new Time(new Date);
    this.notAfter = new Time(new Date);
    if (params) {
      this.notBefore = new Time(params.notBefore);
      this.notAfter = new Time(params.notAfter);
    }
  }
}
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notBefore", undefined);
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notAfter", undefined);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_1;

class Extension {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = Extension.CRITICAL;
    this.extnValue = new OctetString2;
    Object.assign(this, params);
  }
}
Extension.CRITICAL = false;
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Extension.prototype, "extnID", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    defaultValue: Extension.CRITICAL
  })
], Extension.prototype, "critical", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], Extension.prototype, "extnValue", undefined);
var Extensions = Extensions_1 = class Extensions2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_1.prototype);
  }
};
Extensions = Extensions_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Extension })
], Extensions);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version;
(function(Version2) {
  Version2[Version2["v1"] = 0] = "v1";
  Version2[Version2["v2"] = 1] = "v2";
  Version2[Version2["v3"] = 2] = "v3";
})(Version || (Version = {}));

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
class TBSCertificate {
  constructor(params = {}) {
    this.version = Version.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier;
    this.issuer = new Name;
    this.validity = new Validity;
    this.subject = new Name;
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    defaultValue: Version.v1
  })
], TBSCertificate.prototype, "version", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    converter: AsnIntegerArrayBufferConverter
  })
], TBSCertificate.prototype, "serialNumber", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertificate.prototype, "signature", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "issuer", undefined);
__decorate([
  AsnProp({ type: Validity })
], TBSCertificate.prototype, "validity", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "subject", undefined);
__decorate([
  AsnProp({ type: SubjectPublicKeyInfo })
], TBSCertificate.prototype, "subjectPublicKeyInfo", undefined);
__decorate([
  AsnProp({
    type: AsnPropTypes.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate.prototype, "issuerUniqueID", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate.prototype, "subjectUniqueID", undefined);
__decorate([
  AsnProp({ type: Extensions, context: 3, optional: true })
], TBSCertificate.prototype, "extensions", undefined);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
class Certificate {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate;
    this.signatureAlgorithm = new AlgorithmIdentifier;
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: TBSCertificate })
], Certificate.prototype, "tbsCertificate", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], Certificate.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], Certificate.prototype, "signatureValue", undefined);
// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
class RevokedCertificate {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RevokedCertificate.prototype, "userCertificate", undefined);
__decorate([
  AsnProp({ type: Time })
], RevokedCertificate.prototype, "revocationDate", undefined);
__decorate([
  AsnProp({ type: Extension, optional: true, repeated: "sequence" })
], RevokedCertificate.prototype, "crlEntryExtensions", undefined);

class TBSCertList {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier;
    this.issuer = new Name;
    this.thisUpdate = new Time;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], TBSCertList.prototype, "version", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertList.prototype, "signature", undefined);
__decorate([
  AsnProp({ type: Name })
], TBSCertList.prototype, "issuer", undefined);
__decorate([
  AsnProp({ type: Time })
], TBSCertList.prototype, "thisUpdate", undefined);
__decorate([
  AsnProp({ type: Time, optional: true })
], TBSCertList.prototype, "nextUpdate", undefined);
__decorate([
  AsnProp({ type: RevokedCertificate, repeated: "sequence", optional: true })
], TBSCertList.prototype, "revokedCertificates", undefined);
__decorate([
  AsnProp({ type: Extension, optional: true, context: 0, repeated: "sequence" })
], TBSCertList.prototype, "crlExtensions", undefined);

// ../../../../node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
class CertificateList {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList;
    this.signatureAlgorithm = new AlgorithmIdentifier;
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: TBSCertList })
], CertificateList.prototype, "tbsCertList", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], CertificateList.prototype, "signatureAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], CertificateList.prototype, "signature", undefined);
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/getCertificateInfo.js
var issuerSubjectIDKey = {
  "2.5.4.6": "C",
  "2.5.4.10": "O",
  "2.5.4.11": "OU",
  "2.5.4.3": "CN"
};
function getCertificateInfo(leafCertBuffer) {
  const x509 = AsnParser.parse(leafCertBuffer, Certificate);
  const parsedCert = x509.tbsCertificate;
  const issuer = { combined: "" };
  parsedCert.issuer.forEach(([iss]) => {
    const key = issuerSubjectIDKey[iss.type];
    if (key) {
      issuer[key] = iss.value.toString();
    }
  });
  issuer.combined = issuerSubjectToString(issuer);
  const subject = { combined: "" };
  parsedCert.subject.forEach(([iss]) => {
    const key = issuerSubjectIDKey[iss.type];
    if (key) {
      subject[key] = iss.value.toString();
    }
  });
  subject.combined = issuerSubjectToString(subject);
  let basicConstraintsCA = false;
  if (parsedCert.extensions) {
    for (const ext of parsedCert.extensions) {
      if (ext.extnID === id_ce_basicConstraints) {
        const basicConstraints = AsnParser.parse(ext.extnValue, BasicConstraints);
        basicConstraintsCA = basicConstraints.cA;
      }
    }
  }
  return {
    issuer,
    subject,
    version: parsedCert.version,
    basicConstraintsCA,
    notBefore: parsedCert.validity.notBefore.getTime(),
    notAfter: parsedCert.validity.notAfter.getTime(),
    parsedCertificate: x509
  };
}
function issuerSubjectToString(input) {
  const parts = [];
  if (input.C) {
    parts.push(input.C);
  }
  if (input.O) {
    parts.push(input.O);
  }
  if (input.OU) {
    parts.push(input.OU);
  }
  if (input.CN) {
    parts.push(input.CN);
  }
  return parts.join(" : ");
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/fetch.js
function fetch2(url) {
  return _fetchInternals.stubThis(url);
}
var _fetchInternals = {
  stubThis: (url) => globalThis.fetch(url)
};

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/isCertRevoked.js
var cacheRevokedCerts = {};
async function isCertRevoked(cert) {
  const { extensions: extensions2 } = cert.tbsCertificate;
  if (!extensions2) {
    return false;
  }
  let extAuthorityKeyID;
  let extSubjectKeyID;
  let extCRLDistributionPoints;
  extensions2.forEach((ext) => {
    if (ext.extnID === id_ce_authorityKeyIdentifier) {
      extAuthorityKeyID = AsnParser.parse(ext.extnValue, AuthorityKeyIdentifier);
    } else if (ext.extnID === id_ce_subjectKeyIdentifier) {
      extSubjectKeyID = AsnParser.parse(ext.extnValue, SubjectKeyIdentifier);
    } else if (ext.extnID === id_ce_cRLDistributionPoints) {
      extCRLDistributionPoints = AsnParser.parse(ext.extnValue, CRLDistributionPoints);
    }
  });
  let keyIdentifier = undefined;
  if (extAuthorityKeyID && extAuthorityKeyID.keyIdentifier) {
    keyIdentifier = exports_isoUint8Array.toHex(new Uint8Array(extAuthorityKeyID.keyIdentifier.buffer));
  } else if (extSubjectKeyID) {
    keyIdentifier = exports_isoUint8Array.toHex(new Uint8Array(extSubjectKeyID.buffer));
  }
  const certSerialHex = exports_isoUint8Array.toHex(new Uint8Array(cert.tbsCertificate.serialNumber));
  if (keyIdentifier) {
    const cached = cacheRevokedCerts[keyIdentifier];
    if (cached) {
      const now = new Date;
      if (!cached.nextUpdate || cached.nextUpdate > now) {
        return cached.revokedCerts.indexOf(certSerialHex) >= 0;
      }
    }
  }
  const crlURL = extCRLDistributionPoints?.[0].distributionPoint?.fullName?.[0].uniformResourceIdentifier;
  if (!crlURL) {
    return false;
  }
  let certListBytes;
  try {
    const respCRL = await fetch2(crlURL);
    certListBytes = await respCRL.arrayBuffer();
  } catch (_err) {
    return false;
  }
  let data;
  try {
    data = AsnParser.parse(certListBytes, CertificateList);
  } catch (_err) {
    return false;
  }
  const newCached = {
    revokedCerts: [],
    nextUpdate: undefined
  };
  if (data.tbsCertList.nextUpdate) {
    newCached.nextUpdate = data.tbsCertList.nextUpdate.getTime();
  }
  const revokedCerts = data.tbsCertList.revokedCertificates;
  if (revokedCerts) {
    for (const cert2 of revokedCerts) {
      const revokedHex = exports_isoUint8Array.toHex(new Uint8Array(cert2.userCertificate));
      newCached.revokedCerts.push(revokedHex);
    }
    if (keyIdentifier) {
      cacheRevokedCerts[keyIdentifier] = newCached;
    }
    return newCached.revokedCerts.indexOf(certSerialHex) >= 0;
  }
  return false;
}
// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
var id_ecPublicKey = "1.2.840.10045.2.1";
var id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
var id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
var id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
var id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
var id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
var id_secp256r1 = "1.2.840.10045.3.1.7";
var id_secp384r1 = "1.3.132.0.34";

// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
function create(algorithm) {
  return new AlgorithmIdentifier({ algorithm });
}
var ecdsaWithSHA1 = create(id_ecdsaWithSHA1);
var ecdsaWithSHA224 = create(id_ecdsaWithSHA224);
var ecdsaWithSHA256 = create(id_ecdsaWithSHA256);
var ecdsaWithSHA384 = create(id_ecdsaWithSHA384);
var ecdsaWithSHA512 = create(id_ecdsaWithSHA512);
// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js
var FieldID = class FieldID2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], FieldID.prototype, "fieldType", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], FieldID.prototype, "parameters", undefined);
FieldID = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], FieldID);
class ECPoint extends OctetString2 {
}
var Curve = class Curve2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve.prototype, "a", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve.prototype, "b", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, optional: true })
], Curve.prototype, "seed", undefined);
Curve = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], Curve);
var ECPVer;
(function(ECPVer2) {
  ECPVer2[ECPVer2["ecpVer1"] = 1] = "ecpVer1";
})(ECPVer || (ECPVer = {}));
var SpecifiedECDomain = class SpecifiedECDomain2 {
  constructor(params = {}) {
    this.version = ECPVer.ecpVer1;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], SpecifiedECDomain.prototype, "version", undefined);
__decorate([
  AsnProp({ type: FieldID })
], SpecifiedECDomain.prototype, "fieldID", undefined);
__decorate([
  AsnProp({ type: Curve })
], SpecifiedECDomain.prototype, "curve", undefined);
__decorate([
  AsnProp({ type: ECPoint })
], SpecifiedECDomain.prototype, "base", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], SpecifiedECDomain.prototype, "order", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], SpecifiedECDomain.prototype, "cofactor", undefined);
SpecifiedECDomain = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], SpecifiedECDomain);

// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
var ECParameters = class ECParameters2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ECParameters.prototype, "namedCurve", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Null })
], ECParameters.prototype, "implicitCurve", undefined);
__decorate([
  AsnProp({ type: SpecifiedECDomain })
], ECParameters.prototype, "specifiedCurve", undefined);
ECParameters = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], ECParameters);
// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
class ECPrivateKey {
  constructor(params = {}) {
    this.version = 1;
    this.privateKey = new OctetString2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], ECPrivateKey.prototype, "version", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], ECPrivateKey.prototype, "privateKey", undefined);
__decorate([
  AsnProp({ type: ECParameters, context: 0, optional: true })
], ECPrivateKey.prototype, "parameters", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, context: 1, optional: true })
], ECPrivateKey.prototype, "publicKey", undefined);
// ../../../../node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
class ECDSASigValue {
  constructor(params = {}) {
    this.r = new ArrayBuffer(0);
    this.s = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "r", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "s", undefined);
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_1 = "1.2.840.113549.1.1";
var id_rsaEncryption = `${id_pkcs_1}.1`;
var id_RSAES_OAEP = `${id_pkcs_1}.7`;
var id_pSpecified = `${id_pkcs_1}.9`;
var id_RSASSA_PSS = `${id_pkcs_1}.10`;
var id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
var id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
var id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
var id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
var id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
var id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
var id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
var id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
var id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
var id_sha1 = "1.3.14.3.2.26";
var id_sha224 = "2.16.840.1.101.3.4.2.4";
var id_sha256 = "2.16.840.1.101.3.4.2.1";
var id_sha384 = "2.16.840.1.101.3.4.2.2";
var id_sha512 = "2.16.840.1.101.3.4.2.3";
var id_sha512_224 = "2.16.840.1.101.3.4.2.5";
var id_sha512_256 = "2.16.840.1.101.3.4.2.6";
var id_md2 = "1.2.840.113549.2.2";
var id_md5 = "1.2.840.113549.2.5";
var id_mgf1 = `${id_pkcs_1}.8`;

// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create2(algorithm) {
  return new AlgorithmIdentifier({ algorithm, parameters: null });
}
var md2 = create2(id_md2);
var md4 = create2(id_md5);
var sha1 = create2(id_sha1);
var sha224 = create2(id_sha224);
var sha256 = create2(id_sha256);
var sha384 = create2(id_sha384);
var sha512 = create2(id_sha512);
var sha512_224 = create2(id_sha512_224);
var sha512_256 = create2(id_sha512_256);
var mgf1SHA1 = new AlgorithmIdentifier({
  algorithm: id_mgf1,
  parameters: AsnConvert.serialize(sha1)
});
var pSpecifiedEmpty = new AlgorithmIdentifier({
  algorithm: id_pSpecified,
  parameters: AsnConvert.serialize(AsnOctetStringConverter.toASN(new Uint8Array([
    218,
    57,
    163,
    238,
    94,
    107,
    75,
    13,
    50,
    85,
    191,
    239,
    149,
    96,
    24,
    144,
    175,
    216,
    7,
    9
  ]).buffer))
});
var rsaEncryption = create2(id_rsaEncryption);
var md2WithRSAEncryption = create2(id_md2WithRSAEncryption);
var md5WithRSAEncryption = create2(id_md5WithRSAEncryption);
var sha1WithRSAEncryption = create2(id_sha1WithRSAEncryption);
var sha224WithRSAEncryption = create2(id_sha512_224WithRSAEncryption);
var sha256WithRSAEncryption = create2(id_sha512_256WithRSAEncryption);
var sha384WithRSAEncryption = create2(id_sha384WithRSAEncryption);
var sha512WithRSAEncryption = create2(id_sha512WithRSAEncryption);
var sha512_224WithRSAEncryption = create2(id_sha512_224WithRSAEncryption);
var sha512_256WithRSAEncryption = create2(id_sha512_256WithRSAEncryption);

// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
class RsaEsOaepParams {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf1,
      parameters: AsnConvert.serialize(sha1)
    });
    this.pSourceAlgorithm = new AlgorithmIdentifier(pSpecifiedEmpty);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
], RsaEsOaepParams.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
], RsaEsOaepParams.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 2, defaultValue: pSpecifiedEmpty })
], RsaEsOaepParams.prototype, "pSourceAlgorithm", undefined);
var RSAES_OAEP = new AlgorithmIdentifier({
  algorithm: id_RSAES_OAEP,
  parameters: AsnConvert.serialize(new RsaEsOaepParams)
});
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
class RsaSaPssParams {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf1,
      parameters: AsnConvert.serialize(sha1)
    });
    this.saltLength = 20;
    this.trailerField = 1;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
], RsaSaPssParams.prototype, "hashAlgorithm", undefined);
__decorate([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
], RsaSaPssParams.prototype, "maskGenAlgorithm", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams.prototype, "saltLength", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams.prototype, "trailerField", undefined);
var RSASSA_PSS = new AlgorithmIdentifier({
  algorithm: id_RSASSA_PSS,
  parameters: AsnConvert.serialize(new RsaSaPssParams)
});
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
class DigestInfo {
  constructor(params = {}) {
    this.digestAlgorithm = new AlgorithmIdentifier;
    this.digest = new OctetString2;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], DigestInfo.prototype, "digestAlgorithm", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], DigestInfo.prototype, "digest", undefined);
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_1;

class OtherPrimeInfo {
  constructor(params = {}) {
    this.prime = new ArrayBuffer(0);
    this.exponent = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "prime", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "exponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "coefficient", undefined);
var OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
  }
};
OtherPrimeInfos = OtherPrimeInfos_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
], OtherPrimeInfos);
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
class RSAPrivateKey {
  constructor(params = {}) {
    this.version = 0;
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    this.privateExponent = new ArrayBuffer(0);
    this.prime1 = new ArrayBuffer(0);
    this.prime2 = new ArrayBuffer(0);
    this.exponent1 = new ArrayBuffer(0);
    this.exponent2 = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], RSAPrivateKey.prototype, "version", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "modulus", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "publicExponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "privateExponent", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime1", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime2", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent1", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent2", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "coefficient", undefined);
__decorate([
  AsnProp({ type: OtherPrimeInfos, optional: true })
], RSAPrivateKey.prototype, "otherPrimeInfos", undefined);
// ../../../../node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
class RSAPublicKey {
  constructor(params = {}) {
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "modulus", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "publicExponent", undefined);
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/mapX509SignatureAlgToCOSEAlg.js
function mapX509SignatureAlgToCOSEAlg(signatureAlgorithm) {
  let alg;
  if (signatureAlgorithm === "1.2.840.10045.4.3.2") {
    alg = COSEALG.ES256;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.3") {
    alg = COSEALG.ES384;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.4") {
    alg = COSEALG.ES512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.11") {
    alg = COSEALG.RS256;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.12") {
    alg = COSEALG.RS384;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.13") {
    alg = COSEALG.RS512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.5") {
    alg = COSEALG.RS1;
  } else {
    throw new Error(`Unable to map X.509 signature algorithm ${signatureAlgorithm} to a COSE algorithm`);
  }
  return alg;
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/convertX509PublicKeyToCOSE.js
function convertX509PublicKeyToCOSE(x509Certificate) {
  let cosePublicKey = new Map;
  const x509 = AsnParser.parse(x509Certificate, Certificate);
  const { tbsCertificate } = x509;
  const { subjectPublicKeyInfo, signature: _tbsSignature } = tbsCertificate;
  const signatureAlgorithm = _tbsSignature.algorithm;
  const publicKeyAlgorithmID = subjectPublicKeyInfo.algorithm.algorithm;
  if (publicKeyAlgorithmID === id_ecPublicKey) {
    if (!subjectPublicKeyInfo.algorithm.parameters) {
      throw new Error("Certificate public key was missing parameters (EC2)");
    }
    const ecParameters = AsnParser.parse(new Uint8Array(subjectPublicKeyInfo.algorithm.parameters), ECParameters);
    let crv = -999;
    const { namedCurve } = ecParameters;
    if (namedCurve === id_secp256r1) {
      crv = COSECRV.P256;
    } else if (namedCurve === id_secp384r1) {
      crv = COSECRV.P384;
    } else {
      throw new Error(`Certificate public key contained unexpected namedCurve ${namedCurve} (EC2)`);
    }
    const subjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);
    let x;
    let y;
    if (subjectPublicKey[0] === 4) {
      let pointer = 1;
      const halfLength = (subjectPublicKey.length - 1) / 2;
      x = subjectPublicKey.slice(pointer, pointer += halfLength);
      y = subjectPublicKey.slice(pointer);
    } else {
      throw new Error('TODO: Figure out how to handle public keys in "compressed form"');
    }
    const coseEC2PubKey = new Map;
    coseEC2PubKey.set(COSEKEYS.kty, COSEKTY.EC2);
    coseEC2PubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseEC2PubKey.set(COSEKEYS.crv, crv);
    coseEC2PubKey.set(COSEKEYS.x, x);
    coseEC2PubKey.set(COSEKEYS.y, y);
    cosePublicKey = coseEC2PubKey;
  } else if (publicKeyAlgorithmID === "1.2.840.113549.1.1.1") {
    const rsaPublicKey = AsnParser.parse(subjectPublicKeyInfo.subjectPublicKey, RSAPublicKey);
    const coseRSAPubKey = new Map;
    coseRSAPubKey.set(COSEKEYS.kty, COSEKTY.RSA);
    coseRSAPubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseRSAPubKey.set(COSEKEYS.n, new Uint8Array(rsaPublicKey.modulus));
    coseRSAPubKey.set(COSEKEYS.e, new Uint8Array(rsaPublicKey.publicExponent));
    cosePublicKey = coseRSAPubKey;
  } else {
    throw new Error(`Certificate public key contained unexpected algorithm ID ${publicKeyAlgorithmID}`);
  }
  return cosePublicKey;
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/verifySignature.js
function verifySignature(opts) {
  const { signature, data, credentialPublicKey, x509Certificate, hashAlgorithm } = opts;
  if (!x509Certificate && !credentialPublicKey) {
    throw new Error('Must declare either "leafCert" or "credentialPublicKey"');
  }
  if (x509Certificate && credentialPublicKey) {
    throw new Error('Must not declare both "leafCert" and "credentialPublicKey"');
  }
  let cosePublicKey = new Map;
  if (credentialPublicKey) {
    cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);
  } else if (x509Certificate) {
    cosePublicKey = convertX509PublicKeyToCOSE(x509Certificate);
  }
  return _verifySignatureInternals.stubThis(exports_isoCrypto.verify({
    cosePublicKey,
    signature,
    data,
    shaHashOverride: hashAlgorithm
  }));
}
var _verifySignatureInternals = {
  stubThis: (value) => value
};

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/convertPEMToBytes.js
function convertPEMToBytes(pem) {
  const certBase64 = pem.replace("-----BEGIN CERTIFICATE-----", "").replace("-----END CERTIFICATE-----", "").replace(/[\n ]/g, "");
  return exports_isoBase64URL.toBuffer(certBase64, "base64");
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/validateCertificatePath.js
async function validateCertificatePath(x5cCertsPEM, trustAnchorsPEM = []) {
  if (trustAnchorsPEM.length === 0) {
    return true;
  }
  let invalidSubjectAndIssuerError = false;
  let certificateNotYetValidOrExpiredErrorMessage = undefined;
  for (const anchorPEM of trustAnchorsPEM) {
    try {
      const certsWithTrustAnchor = x5cCertsPEM.concat([anchorPEM]);
      await _validatePath(certsWithTrustAnchor);
      invalidSubjectAndIssuerError = false;
      certificateNotYetValidOrExpiredErrorMessage = undefined;
      break;
    } catch (err) {
      if (err instanceof InvalidSubjectAndIssuer) {
        invalidSubjectAndIssuerError = true;
      } else if (err instanceof CertificateNotYetValidOrExpired) {
        certificateNotYetValidOrExpiredErrorMessage = err.message;
      } else {
        throw err;
      }
    }
  }
  if (invalidSubjectAndIssuerError) {
    throw new InvalidSubjectAndIssuer;
  } else if (certificateNotYetValidOrExpiredErrorMessage) {
    throw new CertificateNotYetValidOrExpired(certificateNotYetValidOrExpiredErrorMessage);
  }
  return true;
}
async function _validatePath(x5cCertsWithTrustAnchorPEM) {
  if (new Set(x5cCertsWithTrustAnchorPEM).size !== x5cCertsWithTrustAnchorPEM.length) {
    throw new Error("Invalid certificate path: found duplicate certificates");
  }
  for (const certificatePEM of x5cCertsWithTrustAnchorPEM) {
    const certInfo = getCertificateInfo(convertPEMToBytes(certificatePEM));
    await assertCertNotRevoked(certInfo.parsedCertificate);
    assertCertIsWithinValidTimeWindow(certInfo, certificatePEM);
  }
  for (let i = 0;i < x5cCertsWithTrustAnchorPEM.length - 1; i += 1) {
    const subjectPem = x5cCertsWithTrustAnchorPEM[i];
    const issuerPem = x5cCertsWithTrustAnchorPEM[i + 1];
    const subjectInfo = getCertificateInfo(convertPEMToBytes(subjectPem));
    const issuerInfo = getCertificateInfo(convertPEMToBytes(issuerPem));
    if (subjectInfo.issuer.combined !== issuerInfo.subject.combined) {
      throw new InvalidSubjectAndIssuer;
    }
    const issuerCertIsRootCert = issuerInfo.issuer.combined === issuerInfo.subject.combined;
    await assertSubjectIsSignedByIssuer(subjectInfo.parsedCertificate, issuerPem);
    if (issuerCertIsRootCert) {
      await assertSubjectIsSignedByIssuer(issuerInfo.parsedCertificate, issuerPem);
    }
  }
  return true;
}
async function assertCertNotRevoked(certificate2) {
  const subjectCertRevoked = await isCertRevoked(certificate2);
  if (subjectCertRevoked) {
    throw new Error(`Found revoked certificate in certificate path`);
  }
}
function assertCertIsWithinValidTimeWindow(certInfo, certPEM) {
  const { notBefore, notAfter } = certInfo;
  const now = new Date(Date.now());
  if (notBefore > now || notAfter < now) {
    throw new CertificateNotYetValidOrExpired(`Certificate is not yet valid or expired: ${certPEM}`);
  }
}
async function assertSubjectIsSignedByIssuer(subjectCert, issuerPEM) {
  const data = AsnSerializer.serialize(subjectCert.tbsCertificate);
  const signature = subjectCert.signatureValue;
  const signatureAlgorithm = mapX509SignatureAlgToCOSEAlg(subjectCert.signatureAlgorithm.algorithm);
  const issuerCertBytes = convertPEMToBytes(issuerPEM);
  const verified = await verifySignature({
    data: new Uint8Array(data),
    signature: new Uint8Array(signature),
    x509Certificate: issuerCertBytes,
    hashAlgorithm: signatureAlgorithm
  });
  if (!verified) {
    throw new InvalidSubjectSignatureForIssuer;
  }
}

class InvalidSubjectAndIssuer extends Error {
  constructor() {
    const message = "Subject issuer did not match issuer subject";
    super(message);
    this.name = "InvalidSubjectAndIssuer";
  }
}

class InvalidSubjectSignatureForIssuer extends Error {
  constructor() {
    const message = "Subject signature was invalid for issuer";
    super(message);
    this.name = "InvalidSubjectSignatureForIssuer";
  }
}

class CertificateNotYetValidOrExpired extends Error {
  constructor(message) {
    super(message);
    this.name = "CertificateNotYetValidOrExpired";
  }
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyOKP.js
async function verifyOKP(opts) {
  const { cosePublicKey, signature, data } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x = cosePublicKey.get(COSEKEYS.x);
  if (!alg) {
    throw new Error("Public key was missing alg (OKP)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (OKP)`);
  }
  if (!crv) {
    throw new Error("Public key was missing crv (OKP)");
  }
  if (!x) {
    throw new Error("Public key was missing x (OKP)");
  }
  let _crv;
  if (crv === COSECRV.ED25519) {
    _crv = "Ed25519";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (OKP)`);
  }
  const keyData = {
    kty: "OKP",
    crv: _crv,
    alg: "EdDSA",
    x: exports_isoBase64URL.fromBuffer(x),
    ext: false
  };
  const keyAlgorithm = {
    name: _crv,
    namedCurve: _crv
  };
  const key = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  const verifyAlgorithm = {
    name: _crv
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/unwrapEC2Signature.js
function unwrapEC2Signature(signature, crv) {
  const parsedSignature = AsnParser.parse(signature, ECDSASigValue);
  const rBytes = new Uint8Array(parsedSignature.r);
  const sBytes = new Uint8Array(parsedSignature.s);
  const componentLength = getSignatureComponentLength(crv);
  const rNormalizedBytes = toNormalizedBytes(rBytes, componentLength);
  const sNormalizedBytes = toNormalizedBytes(sBytes, componentLength);
  const finalSignature = exports_isoUint8Array.concat([
    rNormalizedBytes,
    sNormalizedBytes
  ]);
  return finalSignature;
}
function getSignatureComponentLength(crv) {
  switch (crv) {
    case COSECRV.P256:
      return 32;
    case COSECRV.P384:
      return 48;
    case COSECRV.P521:
      return 66;
    default:
      throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);
  }
}
function toNormalizedBytes(bytes, componentLength) {
  let normalizedBytes;
  if (bytes.length < componentLength) {
    normalizedBytes = new Uint8Array(componentLength);
    normalizedBytes.set(bytes, componentLength - bytes.length);
  } else if (bytes.length === componentLength) {
    normalizedBytes = bytes;
  } else if (bytes.length === componentLength + 1 && bytes[0] === 0 && (bytes[1] & 128) === 128) {
    normalizedBytes = bytes.subarray(1);
  } else {
    throw new Error(`Invalid signature component length ${bytes.length}, expected ${componentLength}`);
  }
  return normalizedBytes;
}

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verify.js
function verify2(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  if (isCOSEPublicKeyEC2(cosePublicKey)) {
    const crv = cosePublicKey.get(COSEKEYS.crv);
    if (!isCOSECrv(crv)) {
      throw new Error(`unknown COSE curve ${crv}`);
    }
    const unwrappedSignature = unwrapEC2Signature(signature, crv);
    return verifyEC2({
      cosePublicKey,
      signature: unwrappedSignature,
      data,
      shaHashOverride
    });
  } else if (isCOSEPublicKeyRSA(cosePublicKey)) {
    return verifyRSA({ cosePublicKey, signature, data, shaHashOverride });
  } else if (isCOSEPublicKeyOKP(cosePublicKey)) {
    return verifyOKP({ cosePublicKey, signature, data });
  }
  const kty = cosePublicKey.get(COSEKEYS.kty);
  throw new Error(`Signature verification with public key of kty ${kty} is not supported by this method`);
}
// ../../../../node_modules/@simplewebauthn/server/esm/helpers/iso/isoUint8Array.js
var exports_isoUint8Array = {};
__export(exports_isoUint8Array, {
  toUTF8String: () => toUTF8String2,
  toHex: () => toHex,
  toDataView: () => toDataView,
  fromUTF8String: () => fromUTF8String2,
  fromHex: () => fromHex,
  fromASCIIString: () => fromASCIIString,
  concat: () => concat2,
  areEqual: () => areEqual
});
function areEqual(array1, array2) {
  if (array1.length != array2.length) {
    return false;
  }
  return array1.every((val, i) => val === array2[i]);
}
function toHex(array) {
  const hexParts = Array.from(array, (i) => i.toString(16).padStart(2, "0"));
  return hexParts.join("");
}
function fromHex(hex) {
  if (!hex) {
    return Uint8Array.from([]);
  }
  const isValid = hex.length !== 0 && hex.length % 2 === 0 && !/[^a-fA-F0-9]/u.test(hex);
  if (!isValid) {
    throw new Error("Invalid hex string");
  }
  const byteStrings = hex.match(/.{1,2}/g) ?? [];
  return Uint8Array.from(byteStrings.map((byte) => parseInt(byte, 16)));
}
function concat2(arrays) {
  let pointer = 0;
  const totalLength = arrays.reduce((prev, curr) => prev + curr.length, 0);
  const toReturn = new Uint8Array(totalLength);
  arrays.forEach((arr) => {
    toReturn.set(arr, pointer);
    pointer += arr.length;
  });
  return toReturn;
}
function toUTF8String2(array) {
  const decoder = new globalThis.TextDecoder("utf-8");
  return decoder.decode(array);
}
function fromUTF8String2(utf8String) {
  const encoder = new globalThis.TextEncoder;
  return encoder.encode(utf8String);
}
function fromASCIIString(value) {
  return Uint8Array.from(value.split("").map((x) => x.charCodeAt(0)));
}
function toDataView(array) {
  return new DataView(array.buffer, array.byteOffset, array.length);
}
// ../../../../node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-safetynet.js
var GlobalSign_Root_CA = `-----BEGIN CERTIFICATE-----
MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
-----END CERTIFICATE-----
`;

// ../../../../node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-key.js
var Google_Hardware_Attestation_Root_1 = `-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIJAOj6GWMU0voYMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTYwNTI2MTYyODUyWhcNMjYwNTI0MTYy
ODUyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaOBpjCBozAdBgNVHQ4EFgQUNmHhAHyIBQlRi0RsR/8aTMnqTxIwHwYD
VR0jBBgwFoAUNmHhAHyIBQlRi0RsR/8aTMnqTxIwDwYDVR0TAQH/BAUwAwEB/zAO
BgNVHQ8BAf8EBAMCAYYwQAYDVR0fBDkwNzA1oDOgMYYvaHR0cHM6Ly9hbmRyb2lk
Lmdvb2dsZWFwaXMuY29tL2F0dGVzdGF0aW9uL2NybC8wDQYJKoZIhvcNAQELBQAD
ggIBACDIw41L3KlXG0aMiS//cqrG+EShHUGo8HNsw30W1kJtjn6UBwRM6jnmiwfB
Pb8VA91chb2vssAtX2zbTvqBJ9+LBPGCdw/E53Rbf86qhxKaiAHOjpvAy5Y3m00m
qC0w/Zwvju1twb4vhLaJ5NkUJYsUS7rmJKHHBnETLi8GFqiEsqTWpG/6ibYCv7rY
DBJDcR9W62BW9jfIoBQcxUCUJouMPH25lLNcDc1ssqvC2v7iUgI9LeoM1sNovqPm
QUiG9rHli1vXxzCyaMTjwftkJLkf6724DFhuKug2jITV0QkXvaJWF4nUaHOTNA4u
JU9WDvZLI1j83A+/xnAJUucIv/zGJ1AMH2boHqF8CY16LpsYgBt6tKxxWH00XcyD
CdW2KlBCeqbQPcsFmWyWugxdcekhYsAWyoSf818NUsZdBWBaR/OukXrNLfkQ79Iy
ZohZbvabO/X+MVT3rriAoKc8oE2Uws6DF+60PV7/WIPjNvXySdqspImSN78mflxD
qwLqRBYkA3I75qppLGG9rp7UCdRjxMl8ZDBld+7yvHVgt1cVzJx9xnyGCC23Uaic
MDSXYrB4I4WHXPGjxhZuCuPBLTdOLU8YRvMYdEvYebWHMpvwGCF6bAx3JBpIeOQ1
wDB5y0USicV3YgYGmi+NZfhA4URSh77Yd6uuJOJENRaNVTzk
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_2 = `-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz
NzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu
XKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U
h6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno
L/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok
QBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA
D32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI
mMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW
Fua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91
oeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o
jm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB
ZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH
ex0SdDrx+tWUDqG8At2JHA==
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_3 = `
-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJAMNrfES5rhgxMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjExMTE3MjMxMDQyWhcNMzYxMTEzMjMx
MDQyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBTNNZe5cuf8oiq+jV0itTG
zWVhSTjOBEk2FQvh11J3o3lna0o7rd8RFHnN00q4hi6TapFhh4qaw/iG6Xg+xOan
63niLWIC5GOPFgPeYXM9+nBb3zZzC8ABypYuCusWCmt6Tn3+Pjbz3MTVhRGXuT/T
QH4KGFY4PhvzAyXwdjTOCXID+aHud4RLcSySr0Fq/L+R8TWalvM1wJJPhyRjqRCJ
erGtfBagiALzvhnmY7U1qFcS0NCnKjoO7oFedKdWlZz0YAfu3aGCJd4KHT0MsGiL
Zez9WP81xYSrKMNEsDK+zK5fVzw6jA7cxmpXcARTnmAuGUeI7VVDhDzKeVOctf3a
0qQLwC+d0+xrETZ4r2fRGNw2YEs2W8Qj6oDcfPvq9JySe7pJ6wcHnl5EZ0lwc4xH
7Y4Dx9RA1JlfooLMw3tOdJZH0enxPXaydfAD3YifeZpFaUzicHeLzVJLt9dvGB0b
HQLE4+EqKFgOZv2EoP686DQqbVS1u+9k0p2xbMA105TBIk7npraa8VM0fnrRKi7w
lZKwdH+aNAyhbXRW9xsnODJ+g8eF452zvbiKKngEKirK5LGieoXBX7tZ9D1GNBH2
Ob3bKOwwIWdEFle/YF/h6zWgdeoaNGDqVBrLr2+0DtWoiB1aDEjLWl9FmyIUyUm7
mD/vFDkzF+wm7cyWpQpCVQ==
-----END CERTIFICATE-----
`;
var Google_Hardware_Attestation_Root_4 = `
-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJAPHBcqaZ6vUdMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjIwMzIwMTgwNzQ4WhcNNDIwMzE1MTgw
NzQ4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQB8cMqTllHc8U+qCrOlg3H7
174lmaCsbo/bJ0C17JEgMLb4kvrqsXZs01U3mB/qABg/1t5Pd5AORHARs1hhqGIC
W/nKMav574f9rZN4PC2ZlufGXb7sIdJpGiO9ctRhiLuYuly10JccUZGEHpHSYM2G
tkgYbZba6lsCPYAAP83cyDV+1aOkTf1RCp/lM0PKvmxYN10RYsK631jrleGdcdkx
oSK//mSQbgcWnmAEZrzHoF1/0gso1HZgIn0YLzVhLSA/iXCX4QT2h3J5z3znluKG
1nv8NQdxei2DIIhASWfu804CA96cQKTTlaae2fweqXjdN1/v2nqOhngNyz1361mF
mr4XmaKH/ItTwOe72NI9ZcwS1lVaCvsIkTDCEXdm9rCNPAY10iTunIHFXRh+7KPz
lHGewCq/8TOohBRn0/NNfh7uRslOSZ/xKbN9tMBtw37Z8d2vvnXq/YWdsm1+JLVw
n6yYD/yacNJBlwpddla8eaVMjsF6nBnIgQOf9zKSe06nSTqvgwUHosgOECZJZ1Eu
zbH4yswbt02tKtKEFhx+v+OTge/06V+jGsqTWLsfrOCNLuA8H++z+pUENmpqnnHo
vaI47gC+TNpkgYGkkBT6B/m/U01BuOBBTzhIlMEZq9qkDWuM2cA5kW5V3FJUcfHn
w1IdYIg2Wxg7yHcQZemFQg==
-----END CERTIFICATE-----
`;

// ../../../../node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/apple.js
var Apple_WebAuthn_Root_CA = `-----BEGIN CERTIFICATE-----
MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w
HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ
bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx
NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG
A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49
AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k
xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/
pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk
2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA
MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3
jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B
1bWeT0vT
-----END CERTIFICATE-----
`;

// ../../../../node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/mds.js
var GlobalSign_Root_CA_R3 = `-----BEGIN CERTIFICATE-----
 MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
 A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
 Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
 MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
 A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
 hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
 RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
 gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
 KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
 QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
 XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
 DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
 LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
 RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
 jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
 6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
 mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
 Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
 WD9f
 -----END CERTIFICATE-----
 `;

// ../../../../node_modules/@simplewebauthn/server/esm/services/settingsService.js
class BaseSettingsService {
  constructor() {
    Object.defineProperty(this, "pemCertificates", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.pemCertificates = new Map;
  }
  setRootCertificates(opts) {
    const { identifier, certificates } = opts;
    const newCertificates = [];
    for (const cert of certificates) {
      if (cert instanceof Uint8Array) {
        newCertificates.push(convertCertBufferToPEM(cert));
      } else {
        newCertificates.push(cert);
      }
    }
    this.pemCertificates.set(identifier, newCertificates);
  }
  getRootCertificates(opts) {
    const { identifier } = opts;
    return this.pemCertificates.get(identifier) ?? [];
  }
}
var SettingsService = new BaseSettingsService;
SettingsService.setRootCertificates({
  identifier: "android-key",
  certificates: [
    Google_Hardware_Attestation_Root_1,
    Google_Hardware_Attestation_Root_2,
    Google_Hardware_Attestation_Root_3,
    Google_Hardware_Attestation_Root_4
  ]
});
SettingsService.setRootCertificates({
  identifier: "android-safetynet",
  certificates: [GlobalSign_Root_CA]
});
SettingsService.setRootCertificates({
  identifier: "apple",
  certificates: [Apple_WebAuthn_Root_CA]
});
SettingsService.setRootCertificates({
  identifier: "mds",
  certificates: [GlobalSign_Root_CA_R3]
});

// ../../../../node_modules/@simplewebauthn/server/esm/helpers/logging.js
function getLogger(_name) {
  return (_message, ..._rest) => {};
}

// ../../../../node_modules/@simplewebauthn/server/esm/metadata/parseJWT.js
function parseJWT(jwt) {
  const parts = jwt.split(".");
  return [
    JSON.parse(exports_isoBase64URL.toUTF8String(parts[0])),
    JSON.parse(exports_isoBase64URL.toUTF8String(parts[1])),
    parts[2]
  ];
}

// ../../../../node_modules/@simplewebauthn/server/esm/metadata/verifyJWT.js
function verifyJWT(jwt, leafCert) {
  const [header, payload, signature] = jwt.split(".");
  const certCOSE = convertX509PublicKeyToCOSE(leafCert);
  const data = exports_isoUint8Array.fromUTF8String(`${header}.${payload}`);
  const signatureBytes = exports_isoBase64URL.toBuffer(signature);
  if (isCOSEPublicKeyEC2(certCOSE)) {
    return verifyEC2({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE,
      shaHashOverride: COSEALG.ES256
    });
  } else if (isCOSEPublicKeyRSA(certCOSE)) {
    return verifyRSA({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE
    });
  }
  const kty = certCOSE.get(COSEKEYS.kty);
  throw new Error(`JWT verification with public key of kty ${kty} is not supported by this method`);
}

// ../../../../node_modules/@simplewebauthn/server/esm/services/metadataService.js
var defaultURLMDS = "https://mds.fidoalliance.org/";
var SERVICE_STATE;
(function(SERVICE_STATE2) {
  SERVICE_STATE2[SERVICE_STATE2["DISABLED"] = 0] = "DISABLED";
  SERVICE_STATE2[SERVICE_STATE2["REFRESHING"] = 1] = "REFRESHING";
  SERVICE_STATE2[SERVICE_STATE2["READY"] = 2] = "READY";
})(SERVICE_STATE || (SERVICE_STATE = {}));
var log = getLogger("MetadataService");

class BaseMetadataService {
  constructor() {
    Object.defineProperty(this, "mdsCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "statementCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: SERVICE_STATE.DISABLED
    });
    Object.defineProperty(this, "verificationMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "strict"
    });
  }
  async initialize(opts = {}) {
    const { mdsServers = [defaultURLMDS], statements, verificationMode } = opts;
    this.setState(SERVICE_STATE.REFRESHING);
    if (statements?.length) {
      let statementsAdded = 0;
      statements.forEach((statement) => {
        if (statement.aaguid) {
          this.statementCache[statement.aaguid] = {
            entry: {
              metadataStatement: statement,
              statusReports: [],
              timeOfLastStatusChange: "1970-01-01"
            },
            url: ""
          };
          statementsAdded += 1;
        }
      });
      log(`Cached ${statementsAdded} local statements`);
    }
    if (mdsServers?.length) {
      const currentCacheCount = Object.keys(this.statementCache).length;
      let numServers = mdsServers.length;
      for (const url of mdsServers) {
        try {
          await this.downloadBlob({
            url,
            no: 0,
            nextUpdate: new Date(0)
          });
        } catch (err) {
          log(`Could not download BLOB from ${url}:`, err);
          numServers -= 1;
        }
      }
      const newCacheCount = Object.keys(this.statementCache).length;
      const cacheDiff = newCacheCount - currentCacheCount;
      log(`Cached ${cacheDiff} statements from ${numServers} metadata server(s)`);
    }
    if (verificationMode) {
      this.verificationMode = verificationMode;
    }
    this.setState(SERVICE_STATE.READY);
  }
  async getStatement(aaguid) {
    if (this.state === SERVICE_STATE.DISABLED) {
      return;
    }
    if (!aaguid) {
      return;
    }
    if (aaguid instanceof Uint8Array) {
      aaguid = convertAAGUIDToString(aaguid);
    }
    await this.pauseUntilReady();
    const cachedStatement = this.statementCache[aaguid];
    if (!cachedStatement) {
      if (this.verificationMode === "strict") {
        throw new Error(`No metadata statement found for aaguid "${aaguid}"`);
      }
      return;
    }
    if (cachedStatement.url) {
      const mds = this.mdsCache[cachedStatement.url];
      const now = new Date;
      if (now > mds.nextUpdate) {
        try {
          this.setState(SERVICE_STATE.REFRESHING);
          await this.downloadBlob(mds);
        } finally {
          this.setState(SERVICE_STATE.READY);
        }
      }
    }
    const { entry } = cachedStatement;
    for (const report of entry.statusReports) {
      const { status } = report;
      if (status === "USER_VERIFICATION_BYPASS" || status === "ATTESTATION_KEY_COMPROMISE" || status === "USER_KEY_REMOTE_COMPROMISE" || status === "USER_KEY_PHYSICAL_COMPROMISE") {
        throw new Error(`Detected compromised aaguid "${aaguid}"`);
      }
    }
    return entry.metadataStatement;
  }
  async downloadBlob(mds) {
    const { url, no } = mds;
    const resp = await fetch2(url);
    const data = await resp.text();
    const parsedJWT = parseJWT(data);
    const header = parsedJWT[0];
    const payload = parsedJWT[1];
    if (payload.no <= no) {
      throw new Error(`Latest BLOB no. "${payload.no}" is not greater than previous ${no}`);
    }
    const headerCertsPEM = header.x5c.map(convertCertBufferToPEM);
    try {
      const rootCerts = SettingsService.getRootCertificates({
        identifier: "mds"
      });
      await validateCertificatePath(headerCertsPEM, rootCerts);
    } catch (error) {
      const _error = error;
      throw new Error(`BLOB certificate path could not be validated: ${_error.message}`);
    }
    const leafCert = headerCertsPEM[0];
    const verified = await verifyJWT(data, convertPEMToBytes(leafCert));
    if (!verified) {
      throw new Error("BLOB signature could not be verified");
    }
    for (const entry of payload.entries) {
      if (entry.aaguid) {
        this.statementCache[entry.aaguid] = { entry, url };
      }
    }
    const [year, month, day] = payload.nextUpdate.split("-");
    this.mdsCache[url] = {
      ...mds,
      no: payload.no,
      nextUpdate: new Date(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10))
    };
  }
  pauseUntilReady() {
    if (this.state === SERVICE_STATE.READY) {
      return new Promise((resolve) => {
        resolve();
      });
    }
    const readyPromise = new Promise((resolve, reject) => {
      const totalTimeoutMS = 70000;
      const intervalMS = 100;
      let iterations = totalTimeoutMS / intervalMS;
      const intervalID = globalThis.setInterval(() => {
        if (iterations < 1) {
          clearInterval(intervalID);
          reject(`State did not become ready in ${totalTimeoutMS / 1000} seconds`);
        } else if (this.state === SERVICE_STATE.READY) {
          clearInterval(intervalID);
          resolve();
        }
        iterations -= 1;
      }, intervalMS);
    });
    return readyPromise;
  }
  setState(newState) {
    this.state = newState;
    if (newState === SERVICE_STATE.DISABLED) {
      log("MetadataService is DISABLED");
    } else if (newState === SERVICE_STATE.REFRESHING) {
      log("MetadataService is REFRESHING");
    } else if (newState === SERVICE_STATE.READY) {
      log("MetadataService is READY");
    }
  }
}
var MetadataService = new BaseMetadataService;

// ../../../../node_modules/@peculiar/asn1-android/build/es2015/key_description.js
var IntegerSet_1;
var VerifiedBootState;
(function(VerifiedBootState2) {
  VerifiedBootState2[VerifiedBootState2["verified"] = 0] = "verified";
  VerifiedBootState2[VerifiedBootState2["selfSigned"] = 1] = "selfSigned";
  VerifiedBootState2[VerifiedBootState2["unverified"] = 2] = "unverified";
  VerifiedBootState2[VerifiedBootState2["failed"] = 3] = "failed";
})(VerifiedBootState || (VerifiedBootState = {}));

class RootOfTrust {
  constructor(params = {}) {
    this.verifiedBootKey = new OctetString2;
    this.deviceLocked = false;
    this.verifiedBootState = VerifiedBootState.verified;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: OctetString2 })
], RootOfTrust.prototype, "verifiedBootKey", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean })
], RootOfTrust.prototype, "deviceLocked", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], RootOfTrust.prototype, "verifiedBootState", undefined);
__decorate([
  AsnProp({ type: OctetString2, optional: true })
], RootOfTrust.prototype, "verifiedBootHash", undefined);
var IntegerSet = IntegerSet_1 = class IntegerSet2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IntegerSet_1.prototype);
  }
};
IntegerSet = IntegerSet_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Set, itemType: AsnPropTypes.Integer })
], IntegerSet);
class AuthorizationList {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ context: 1, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "purpose", undefined);
__decorate([
  AsnProp({ context: 2, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "algorithm", undefined);
__decorate([
  AsnProp({ context: 3, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "keySize", undefined);
__decorate([
  AsnProp({ context: 5, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "digest", undefined);
__decorate([
  AsnProp({ context: 6, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "padding", undefined);
__decorate([
  AsnProp({ context: 10, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "ecCurve", undefined);
__decorate([
  AsnProp({ context: 200, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "rsaPublicExponent", undefined);
__decorate([
  AsnProp({ context: 203, type: IntegerSet, optional: true })
], AuthorizationList.prototype, "mgfDigest", undefined);
__decorate([
  AsnProp({ context: 303, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "rollbackResistance", undefined);
__decorate([
  AsnProp({ context: 305, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "earlyBootOnly", undefined);
__decorate([
  AsnProp({ context: 400, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "activeDateTime", undefined);
__decorate([
  AsnProp({ context: 401, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "originationExpireDateTime", undefined);
__decorate([
  AsnProp({ context: 402, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "usageExpireDateTime", undefined);
__decorate([
  AsnProp({ context: 405, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "usageCountLimit", undefined);
__decorate([
  AsnProp({ context: 503, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "noAuthRequired", undefined);
__decorate([
  AsnProp({ context: 504, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "userAuthType", undefined);
__decorate([
  AsnProp({ context: 505, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "authTimeout", undefined);
__decorate([
  AsnProp({ context: 506, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "allowWhileOnBody", undefined);
__decorate([
  AsnProp({ context: 507, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "trustedUserPresenceRequired", undefined);
__decorate([
  AsnProp({ context: 508, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "trustedConfirmationRequired", undefined);
__decorate([
  AsnProp({ context: 509, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "unlockedDeviceRequired", undefined);
__decorate([
  AsnProp({ context: 600, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "allApplications", undefined);
__decorate([
  AsnProp({ context: 601, type: OctetString2, optional: true })
], AuthorizationList.prototype, "applicationId", undefined);
__decorate([
  AsnProp({ context: 701, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "creationDateTime", undefined);
__decorate([
  AsnProp({ context: 702, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "origin", undefined);
__decorate([
  AsnProp({ context: 703, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "rollbackResistant", undefined);
__decorate([
  AsnProp({ context: 704, type: RootOfTrust, optional: true })
], AuthorizationList.prototype, "rootOfTrust", undefined);
__decorate([
  AsnProp({ context: 705, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "osVersion", undefined);
__decorate([
  AsnProp({ context: 706, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "osPatchLevel", undefined);
__decorate([
  AsnProp({ context: 709, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationApplicationId", undefined);
__decorate([
  AsnProp({ context: 710, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdBrand", undefined);
__decorate([
  AsnProp({ context: 711, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdDevice", undefined);
__decorate([
  AsnProp({ context: 712, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdProduct", undefined);
__decorate([
  AsnProp({ context: 713, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdSerial", undefined);
__decorate([
  AsnProp({ context: 714, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdImei", undefined);
__decorate([
  AsnProp({ context: 715, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdMeid", undefined);
__decorate([
  AsnProp({ context: 716, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdManufacturer", undefined);
__decorate([
  AsnProp({ context: 717, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdModel", undefined);
__decorate([
  AsnProp({ context: 718, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "vendorPatchLevel", undefined);
__decorate([
  AsnProp({ context: 719, type: AsnPropTypes.Integer, optional: true })
], AuthorizationList.prototype, "bootPatchLevel", undefined);
__decorate([
  AsnProp({ context: 720, type: AsnPropTypes.Null, optional: true })
], AuthorizationList.prototype, "deviceUniqueAttestation", undefined);
__decorate([
  AsnProp({ context: 723, type: OctetString2, optional: true })
], AuthorizationList.prototype, "attestationIdSecondImei", undefined);
__decorate([
  AsnProp({ context: 724, type: OctetString2, optional: true })
], AuthorizationList.prototype, "moduleHash", undefined);
var SecurityLevel;
(function(SecurityLevel2) {
  SecurityLevel2[SecurityLevel2["software"] = 0] = "software";
  SecurityLevel2[SecurityLevel2["trustedEnvironment"] = 1] = "trustedEnvironment";
  SecurityLevel2[SecurityLevel2["strongBox"] = 2] = "strongBox";
})(SecurityLevel || (SecurityLevel = {}));
var Version2;
(function(Version3) {
  Version3[Version3["KM2"] = 1] = "KM2";
  Version3[Version3["KM3"] = 2] = "KM3";
  Version3[Version3["KM4"] = 3] = "KM4";
  Version3[Version3["KM4_1"] = 4] = "KM4_1";
  Version3[Version3["keyMint1"] = 100] = "keyMint1";
  Version3[Version3["keyMint2"] = 200] = "keyMint2";
  Version3[Version3["keyMint3"] = 300] = "keyMint3";
  Version3[Version3["keyMint4"] = 400] = "keyMint4";
})(Version2 || (Version2 = {}));

class KeyDescription {
  constructor(params = {}) {
    this.attestationVersion = Version2.KM4;
    this.attestationSecurityLevel = SecurityLevel.software;
    this.keymasterVersion = 0;
    this.keymasterSecurityLevel = SecurityLevel.software;
    this.attestationChallenge = new OctetString2;
    this.uniqueId = new OctetString2;
    this.softwareEnforced = new AuthorizationList;
    this.teeEnforced = new AuthorizationList;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyDescription.prototype, "attestationVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyDescription.prototype, "attestationSecurityLevel", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyDescription.prototype, "keymasterVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyDescription.prototype, "keymasterSecurityLevel", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyDescription.prototype, "attestationChallenge", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyDescription.prototype, "uniqueId", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyDescription.prototype, "softwareEnforced", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyDescription.prototype, "teeEnforced", undefined);

class KeyMintKeyDescription {
  constructor(params = {}) {
    this.attestationVersion = Version2.keyMint4;
    this.attestationSecurityLevel = SecurityLevel.software;
    this.keyMintVersion = 0;
    this.keyMintSecurityLevel = SecurityLevel.software;
    this.attestationChallenge = new OctetString2;
    this.uniqueId = new OctetString2;
    this.softwareEnforced = new AuthorizationList;
    this.hardwareEnforced = new AuthorizationList;
    Object.assign(this, params);
  }
  toLegacyKeyDescription() {
    return new KeyDescription({
      attestationVersion: this.attestationVersion,
      attestationSecurityLevel: this.attestationSecurityLevel,
      keymasterVersion: this.keyMintVersion,
      keymasterSecurityLevel: this.keyMintSecurityLevel,
      attestationChallenge: this.attestationChallenge,
      uniqueId: this.uniqueId,
      softwareEnforced: this.softwareEnforced,
      teeEnforced: this.hardwareEnforced
    });
  }
  static fromLegacyKeyDescription(keyDesc) {
    return new KeyMintKeyDescription({
      attestationVersion: keyDesc.attestationVersion,
      attestationSecurityLevel: keyDesc.attestationSecurityLevel,
      keyMintVersion: keyDesc.keymasterVersion,
      keyMintSecurityLevel: keyDesc.keymasterSecurityLevel,
      attestationChallenge: keyDesc.attestationChallenge,
      uniqueId: keyDesc.uniqueId,
      softwareEnforced: keyDesc.softwareEnforced,
      hardwareEnforced: keyDesc.teeEnforced
    });
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyMintKeyDescription.prototype, "attestationVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyMintKeyDescription.prototype, "attestationSecurityLevel", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyMintKeyDescription.prototype, "keyMintVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], KeyMintKeyDescription.prototype, "keyMintSecurityLevel", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyMintKeyDescription.prototype, "attestationChallenge", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], KeyMintKeyDescription.prototype, "uniqueId", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyMintKeyDescription.prototype, "softwareEnforced", undefined);
__decorate([
  AsnProp({ type: AuthorizationList })
], KeyMintKeyDescription.prototype, "hardwareEnforced", undefined);
// ../../../../node_modules/@peculiar/asn1-android/build/es2015/nonstandard.js
var NonStandardAuthorizationList_1;
var NonStandardAuthorization = class NonStandardAuthorization2 extends AuthorizationList {
};
NonStandardAuthorization = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], NonStandardAuthorization);
var NonStandardAuthorizationList = NonStandardAuthorizationList_1 = class NonStandardAuthorizationList2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, NonStandardAuthorizationList_1.prototype);
  }
  findProperty(key) {
    const prop = this.find((o) => (key in o));
    if (prop) {
      return prop[key];
    }
    return;
  }
};
NonStandardAuthorizationList = NonStandardAuthorizationList_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: NonStandardAuthorization })
], NonStandardAuthorizationList);
class NonStandardKeyDescription {
  get keyMintVersion() {
    return this.keymasterVersion;
  }
  set keyMintVersion(value) {
    this.keymasterVersion = value;
  }
  get keyMintSecurityLevel() {
    return this.keymasterSecurityLevel;
  }
  set keyMintSecurityLevel(value) {
    this.keymasterSecurityLevel = value;
  }
  get hardwareEnforced() {
    return this.teeEnforced;
  }
  set hardwareEnforced(value) {
    this.teeEnforced = value;
  }
  constructor(params = {}) {
    this.attestationVersion = Version2.KM4;
    this.attestationSecurityLevel = SecurityLevel.software;
    this.keymasterVersion = 0;
    this.keymasterSecurityLevel = SecurityLevel.software;
    this.attestationChallenge = new OctetString2;
    this.uniqueId = new OctetString2;
    this.softwareEnforced = new NonStandardAuthorizationList;
    this.teeEnforced = new NonStandardAuthorizationList;
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], NonStandardKeyDescription.prototype, "attestationVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], NonStandardKeyDescription.prototype, "attestationSecurityLevel", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], NonStandardKeyDescription.prototype, "keymasterVersion", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], NonStandardKeyDescription.prototype, "keymasterSecurityLevel", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], NonStandardKeyDescription.prototype, "attestationChallenge", undefined);
__decorate([
  AsnProp({ type: OctetString2 })
], NonStandardKeyDescription.prototype, "uniqueId", undefined);
__decorate([
  AsnProp({ type: NonStandardAuthorizationList })
], NonStandardKeyDescription.prototype, "softwareEnforced", undefined);
__decorate([
  AsnProp({ type: NonStandardAuthorizationList })
], NonStandardKeyDescription.prototype, "teeEnforced", undefined);
var NonStandardKeyMintKeyDescription = class NonStandardKeyMintKeyDescription2 extends NonStandardKeyDescription {
  constructor(params = {}) {
    if ("keymasterVersion" in params && !("keyMintVersion" in params)) {
      params.keyMintVersion = params.keymasterVersion;
    }
    if ("keymasterSecurityLevel" in params && !("keyMintSecurityLevel" in params)) {
      params.keyMintSecurityLevel = params.keymasterSecurityLevel;
    }
    if ("teeEnforced" in params && !("hardwareEnforced" in params)) {
      params.hardwareEnforced = params.teeEnforced;
    }
    super(params);
  }
};
NonStandardKeyMintKeyDescription = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], NonStandardKeyMintKeyDescription);
// ../../../../node_modules/@peculiar/asn1-android/build/es2015/attestation.js
class AttestationPackageInfo {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString })
], AttestationPackageInfo.prototype, "packageName", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], AttestationPackageInfo.prototype, "version", undefined);

class AttestationApplicationId {
  constructor(params = {}) {
    Object.assign(this, params);
  }
}
__decorate([
  AsnProp({ type: AttestationPackageInfo, repeated: "set" })
], AttestationApplicationId.prototype, "packageInfos", undefined);
__decorate([
  AsnProp({ type: AsnPropTypes.OctetString, repeated: "set" })
], AttestationApplicationId.prototype, "signatureDigests", undefined);
// ../auth/src/password/reset.ts
import { config as config9 } from "@stacksjs/config";

// ../email/src/drivers/mailgun.ts
import { Buffer as Buffer3 } from "buffer";
import { config as config4 } from "@stacksjs/config";
import { log as log6 } from "@stacksjs/logging";

// ../email/src/template.ts
import process3 from "process";
import { resourcesPath } from "@stacksjs/path";

// ../../../../node_modules/@vue-email/compiler/dist/index.mjs
import { resolve as resolve$3, join as join$3, extname as extname$1 } from "path";
import { readFileSync as readFileSync$1, readdirSync, statSync } from "fs";

// ../../../../node_modules/ufo/dist/index.mjs
var r = String.fromCharCode;
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_SPACE_RE = /%20/gi;
function encode2(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode2(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === undefined) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== undefined).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}
var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withoutLeadingSlash(input = "") {
  return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
}
function cleanDoubleSlashes(input = "") {
  return input.split("://").map((string_) => string_.replace(/\/{2,}/g, "/")).join("://");
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function resolveURL(base = "", ...inputs) {
  if (typeof base !== "string") {
    throw new TypeError(`URL input should be string received ${typeof base} (${base})`);
  }
  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));
  if (filteredInputs.length === 0) {
    return base;
  }
  const url = parseURL(base);
  for (const inputSegment of filteredInputs) {
    const urlSegment = parseURL(inputSegment);
    if (urlSegment.pathname) {
      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);
    }
    if (urlSegment.hash && urlSegment.hash !== "#") {
      url.hash = urlSegment.hash;
    }
    if (urlSegment.search && urlSegment.search !== "?") {
      if (url.search && url.search !== "?") {
        const queryString = stringifyQuery({
          ...parseQuery(url.search),
          ...parseQuery(urlSegment.search)
        });
        url.search = queryString.length > 0 ? "?" + queryString : "";
      } else {
        url.search = urlSegment.search;
      }
    }
  }
  return stringifyParsedURL(url);
}
var protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

// ../../../../node_modules/vue/server-renderer/index.mjs
var exports_server_renderer = {};
__reExport(exports_server_renderer, __toESM(require_server_renderer_cjs(), 1));

// ../../../../node_modules/@vue-email/tailwind/dist/index.mjs
var lp = Object.create;
var gr = Object.defineProperty;
var up = Object.getOwnPropertyDescriptor;
var fp = Object.getOwnPropertyNames;
var cp = Object.getPrototypeOf;
var pp = Object.prototype.hasOwnProperty;
var pt = (t, e) => () => (t && (e = t(t = 0)), e);
var k = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var yr = (t, e) => {
  for (var r2 in e)
    gr(t, r2, { get: e[r2], enumerable: true });
};
var ka = (t, e, r2, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of fp(e))
      !pp.call(t, i) && i !== r2 && gr(t, i, { get: () => e[i], enumerable: !(n = up(e, i)) || n.enumerable });
  return t;
};
var H = (t, e, r2) => (r2 = t != null ? lp(cp(t)) : {}, ka(e || !t || !t.__esModule ? gr(r2, "default", { value: t, enumerable: true }) : r2, t));
var Ue = (t) => ka(gr({}, "__esModule", { value: true }), t);
var Ea = {};
yr(Ea, { default: () => dp });
var dp;
var Oa = pt(() => {
  dp = { yellow: (t) => t };
});
var In = k(() => {});
var vr = k(($w, _a2) => {
  var Aa = (Oa(), Ue(Ea)), Ca = In(), dt = class t extends Error {
    constructor(e, r2, n, i, a, s) {
      super(e), this.name = "CssSyntaxError", this.reason = e, a && (this.file = a), i && (this.source = i), s && (this.plugin = s), typeof r2 < "u" && typeof n < "u" && (typeof r2 == "number" ? (this.line = r2, this.column = n) : (this.line = r2.line, this.column = r2.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e) {
      if (!this.source)
        return "";
      let r2 = this.source;
      e == null && (e = Aa.isColorSupported), Ca && e && (r2 = Ca(r2));
      let n = r2.split(/\r?\n/), i = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, n.length), s = String(a).length, o, l;
      if (e) {
        let { bold: u, gray: f, red: c } = Aa.createColors(true);
        o = (p) => u(c(p)), l = (p) => f(p);
      } else
        o = l = (u) => u;
      return n.slice(i, a).map((u, f) => {
        let c = i + 1 + f, p = " " + (" " + c).slice(-s) + " | ";
        if (c === this.line) {
          let d = l(p.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o(">") + l(p) + u + `
 ` + d + o("^");
        }
        return " " + l(p) + u;
      }).join(`
`);
    }
    toString() {
      let e = this.showSourceCode();
      return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
    }
  };
  _a2.exports = dt;
  dt.default = dt;
});
var wr = k((jw, Rn) => {
  Rn.exports.isClean = Symbol("isClean");
  Rn.exports.my = Symbol("my");
});
var Dn = k((zw, Pa) => {
  var Ta = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function hp(t) {
    return t[0].toUpperCase() + t.slice(1);
  }
  var ht = class {
    constructor(e) {
      this.builder = e;
    }
    atrule(e, r2) {
      let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
      if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes)
        this.block(e, n + i);
      else {
        let a = (e.raws.between || "") + (r2 ? ";" : "");
        this.builder(n + i + a, e);
      }
    }
    beforeAfter(e, r2) {
      let n;
      e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : r2 === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
      let i = e.parent, a = 0;
      for (;i && i.type !== "root"; )
        a += 1, i = i.parent;
      if (n.includes(`
`)) {
        let s = this.raw(e, null, "indent");
        if (s.length)
          for (let o = 0;o < a; o++)
            n += s;
      }
      return n;
    }
    block(e, r2) {
      let n = this.raw(e, "between", "beforeOpen");
      this.builder(r2 + n + "{", e, "start");
      let i;
      e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
    }
    body(e) {
      let r2 = e.nodes.length - 1;
      for (;r2 > 0 && e.nodes[r2].type === "comment"; )
        r2 -= 1;
      let n = this.raw(e, "semicolon");
      for (let i = 0;i < e.nodes.length; i++) {
        let a = e.nodes[i], s = this.raw(a, "before");
        s && this.builder(s), this.stringify(a, r2 !== i || n);
      }
    }
    comment(e) {
      let r2 = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
      this.builder("/*" + r2 + e.text + n + "*/", e);
    }
    decl(e, r2) {
      let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
      e.important && (i += e.raws.important || " !important"), r2 && (i += ";"), this.builder(i, e);
    }
    document(e) {
      this.body(e);
    }
    raw(e, r2, n) {
      let i;
      if (n || (n = r2), r2 && (i = e.raws[r2], typeof i < "u"))
        return i;
      let a = e.parent;
      if (n === "before" && (!a || a.type === "root" && a.first === e || a && a.type === "document"))
        return "";
      if (!a)
        return Ta[n];
      let s = e.root();
      if (s.rawCache || (s.rawCache = {}), typeof s.rawCache[n] < "u")
        return s.rawCache[n];
      if (n === "before" || n === "after")
        return this.beforeAfter(e, n);
      {
        let o = "raw" + hp(n);
        this[o] ? i = this[o](s, e) : s.walk((l) => {
          if (i = l.raws[r2], typeof i < "u")
            return false;
        });
      }
      return typeof i > "u" && (i = Ta[n]), s.rawCache[n] = i, i;
    }
    rawBeforeClose(e) {
      let r2;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
          return r2 = n.raws.after, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawBeforeComment(e, r2) {
      let n;
      return e.walkComments((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r2, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeDecl(e, r2) {
      let n;
      return e.walkDecls((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r2, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeOpen(e) {
      let r2;
      return e.walk((n) => {
        if (n.type !== "decl" && (r2 = n.raws.between, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawBeforeRule(e) {
      let r2;
      return e.walk((n) => {
        if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
          return r2 = n.raws.before, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawColon(e) {
      let r2;
      return e.walkDecls((n) => {
        if (typeof n.raws.between < "u")
          return r2 = n.raws.between.replace(/[^\s:]/g, ""), false;
      }), r2;
    }
    rawEmptyBody(e) {
      let r2;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length === 0 && (r2 = n.raws.after, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawIndent(e) {
      if (e.raws.indent)
        return e.raws.indent;
      let r2;
      return e.walk((n) => {
        let i = n.parent;
        if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
          let a = n.raws.before.split(`
`);
          return r2 = a[a.length - 1], r2 = r2.replace(/\S/g, ""), false;
        }
      }), r2;
    }
    rawSemicolon(e) {
      let r2;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length && n.last.type === "decl" && (r2 = n.raws.semicolon, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawValue(e, r2) {
      let n = e[r2], i = e.raws[r2];
      return i && i.value === n ? i.raw : n;
    }
    root(e) {
      this.body(e), e.raws.after && this.builder(e.raws.after);
    }
    rule(e) {
      this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
    }
    stringify(e, r2) {
      if (!this[e.type])
        throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
      this[e.type](e, r2);
    }
  };
  Pa.exports = ht;
  ht.default = ht;
});
var mt = k((Vw, Ia) => {
  var mp = Dn();
  function Mn(t, e) {
    new mp(e).stringify(t);
  }
  Ia.exports = Mn;
  Mn.default = Mn;
});
var yt = k((Ww, Ra) => {
  var { isClean: br, my: gp } = wr(), yp = vr(), vp = Dn(), wp = mt();
  function Ln(t, e) {
    let r2 = new t.constructor;
    for (let n in t) {
      if (!Object.prototype.hasOwnProperty.call(t, n) || n === "proxyCache")
        continue;
      let i = t[n], a = typeof i;
      n === "parent" && a === "object" ? e && (r2[n] = e) : n === "source" ? r2[n] = i : Array.isArray(i) ? r2[n] = i.map((s) => Ln(s, r2)) : (a === "object" && i !== null && (i = Ln(i)), r2[n] = i);
    }
    return r2;
  }
  var gt = class {
    constructor(e = {}) {
      this.raws = {}, this[br] = false, this[gp] = true;
      for (let r2 in e)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let n of e[r2])
            typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
        } else
          this[r2] = e[r2];
    }
    addToError(e) {
      if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
        let r2 = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`);
      }
      return e;
    }
    after(e) {
      return this.parent.insertAfter(this, e), this;
    }
    assign(e = {}) {
      for (let r2 in e)
        this[r2] = e[r2];
      return this;
    }
    before(e) {
      return this.parent.insertBefore(this, e), this;
    }
    cleanRaws(e) {
      delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
    }
    clone(e = {}) {
      let r2 = Ln(this);
      for (let n in e)
        r2[n] = e[n];
      return r2;
    }
    cloneAfter(e = {}) {
      let r2 = this.clone(e);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e = {}) {
      let r2 = this.clone(e);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e, r2 = {}) {
      if (this.source) {
        let { end: n, start: i } = this.rangeBy(r2);
        return this.source.input.error(e, { column: i.column, line: i.line }, { column: n.column, line: n.line }, r2);
      }
      return new yp(e);
    }
    getProxyProcessor() {
      return { get(e, r2) {
        return r2 === "proxyOf" ? e : r2 === "root" ? () => e.root().toProxy() : e[r2];
      }, set(e, r2, n) {
        return e[r2] === n || (e[r2] = n, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || r2 === "text") && e.markDirty()), true;
      } };
    }
    markDirty() {
      if (this[br]) {
        this[br] = false;
        let e = this;
        for (;e = e.parent; )
          e[br] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e + 1];
    }
    positionBy(e, r2) {
      let n = this.source.start;
      if (e.index)
        n = this.positionInside(e.index, r2);
      else if (e.word) {
        r2 = this.toString();
        let i = r2.indexOf(e.word);
        i !== -1 && (n = this.positionInside(i, r2));
      }
      return n;
    }
    positionInside(e, r2) {
      let n = r2 || this.toString(), i = this.source.start.column, a = this.source.start.line;
      for (let s = 0;s < e; s++)
        n[s] === `
` ? (i = 1, a += 1) : i += 1;
      return { column: i, line: a };
    }
    prev() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e - 1];
    }
    rangeBy(e) {
      let r2 = { column: this.source.start.column, line: this.source.start.line }, n = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: r2.column + 1, line: r2.line };
      if (e.word) {
        let i = this.toString(), a = i.indexOf(e.word);
        a !== -1 && (r2 = this.positionInside(a, i), n = this.positionInside(a + e.word.length, i));
      } else
        e.start ? r2 = { column: e.start.column, line: e.start.line } : e.index && (r2 = this.positionInside(e.index)), e.end ? n = { column: e.end.column, line: e.end.line } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
      return (n.line < r2.line || n.line === r2.line && n.column <= r2.column) && (n = { column: r2.column + 1, line: r2.line }), { end: n, start: r2 };
    }
    raw(e, r2) {
      return new vp().raw(this, e, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }
    replaceWith(...e) {
      if (this.parent) {
        let r2 = this, n = false;
        for (let i of e)
          i === this ? n = true : n ? (this.parent.insertAfter(r2, i), r2 = i) : this.parent.insertBefore(r2, i);
        n || this.remove();
      }
      return this;
    }
    root() {
      let e = this;
      for (;e.parent && e.parent.type !== "document"; )
        e = e.parent;
      return e;
    }
    toJSON(e, r2) {
      let n = {}, i = r2 == null;
      r2 = r2 || new Map;
      let a = 0;
      for (let s in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s) || s === "parent" || s === "proxyCache")
          continue;
        let o = this[s];
        if (Array.isArray(o))
          n[s] = o.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, r2) : l);
        else if (typeof o == "object" && o.toJSON)
          n[s] = o.toJSON(null, r2);
        else if (s === "source") {
          let l = r2.get(o.input);
          l == null && (l = a, r2.set(o.input, a), a++), n[s] = { end: o.end, inputId: l, start: o.start };
        } else
          n[s] = o;
      }
      return i && (n.inputs = [...r2.keys()].map((s) => s.toJSON())), n;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e = wp) {
      e.stringify && (e = e.stringify);
      let r2 = "";
      return e(this, (n) => {
        r2 += n;
      }), r2;
    }
    warn(e, r2, n) {
      let i = { node: this };
      for (let a in n)
        i[a] = n[a];
      return e.warn(r2, i);
    }
    get proxyOf() {
      return this;
    }
  };
  Ra.exports = gt;
  gt.default = gt;
});
var wt = k((Bw, Da) => {
  var bp = yt(), vt = class extends bp {
    constructor(e) {
      e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Da.exports = vt;
  vt.default = vt;
});
var xr = k(() => {});
var bt = {};
yr(bt, { join: () => Nn });
var Nn;
var xt = pt(() => {
  Nn = () => "";
});
var Fn = {};
yr(Fn, { default: () => xp });
var xp;
var qn = pt(() => {
  xp = null;
});
var La = k((Yw, Ma) => {
  var Sp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", kp = (t, e = 21) => (r2 = e) => {
    let n = "", i = r2;
    for (;i--; )
      n += t[Math.random() * t.length | 0];
    return n;
  }, Ep = (t = 21) => {
    let e = "", r2 = t;
    for (;r2--; )
      e += Sp[Math.random() * 64 | 0];
    return e;
  };
  Ma.exports = { nanoid: Ep, customAlphabet: kp };
});
var Fa;
var Na = pt(() => {
  Fa = {};
});
var qa = {};
yr(qa, { default: () => St });
var St;
var Sr = pt(() => {
  Na();
  St = { readFileSync: () => Fa };
});
var $n = k((Xw, ja) => {
  var { SourceMapConsumer: Ua, SourceMapGenerator: $a } = xr(), { existsSync: Ap, readFileSync: Cp } = (Sr(), Ue(qa)), { dirname: Un, join: _p } = (xt(), Ue(bt));
  function Tp(t) {
    return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
  }
  var kt = class {
    constructor(e, r2) {
      if (r2.map === false)
        return;
      this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
      let n = r2.map ? r2.map.prev : undefined, i = this.loadMap(r2.from, n);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = Un(this.mapFile)), i && (this.text = i);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Ua(this.text)), this.consumerCache;
    }
    decodeInline(e) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, a = /^data:application\/json,/;
      if (i.test(e) || a.test(e))
        return decodeURIComponent(e.substr(RegExp.lastMatch.length));
      if (r2.test(e) || n.test(e))
        return Tp(e.substr(RegExp.lastMatch.length));
      let s = e.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + s);
    }
    getAnnotationURL(e) {
      return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e) {
      return typeof e != "object" ? false : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
    }
    loadAnnotation(e) {
      let r2 = e.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r2)
        return;
      let n = e.lastIndexOf(r2.pop()), i = e.indexOf("*/", n);
      n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
    }
    loadFile(e) {
      if (this.root = Un(e), Ap(e))
        return this.mapFile = e, Cp(e, "utf-8").toString().trim();
    }
    loadMap(e, r2) {
      if (r2 === false)
        return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let n = r2(e);
          if (n) {
            let i = this.loadFile(n);
            if (!i)
              throw new Error("Unable to load previous source map: " + n.toString());
            return i;
          }
        } else {
          if (r2 instanceof Ua)
            return $a.fromSourceMap(r2).toString();
          if (r2 instanceof $a)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error("Unsupported previous source map format: " + r2.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n = this.annotation;
          return e && (n = _p(Un(e), n)), this.loadFile(n);
        }
      }
    }
    startWith(e, r2) {
      return e ? e.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  };
  ja.exports = kt;
  kt.default = kt;
});
var Et = k((Kw, Ba) => {
  var { SourceMapConsumer: Pp, SourceMapGenerator: Ip } = xr(), { fileURLToPath: za, pathToFileURL: kr } = (qn(), Ue(Fn)), { isAbsolute: Vn, resolve: Wn } = (xt(), Ue(bt)), { nanoid: Rp } = La(), jn = In(), Va = vr(), Dp = $n(), zn = Symbol("fromOffsetCache"), Mp = !!(Pp && Ip), Wa = !!(Wn && Vn), He = class {
    constructor(e, r2 = {}) {
      if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
        throw new Error(`PostCSS received ${e} instead of CSS string`);
      if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r2.from && (!Wa || /^\w+:\/\//.test(r2.from) || Vn(r2.from) ? this.file = r2.from : this.file = Wn(r2.from)), Wa && Mp) {
        let n = new Dp(this.css, r2);
        if (n.text) {
          this.map = n;
          let i = n.consumer().file;
          !this.file && i && (this.file = this.mapResolve(i));
        }
      }
      this.file || (this.id = "<input css " + Rp(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e, r2, n, i = {}) {
      let a, s, o;
      if (r2 && typeof r2 == "object") {
        let u = r2, f = n;
        if (typeof u.offset == "number") {
          let c = this.fromOffset(u.offset);
          r2 = c.line, n = c.col;
        } else
          r2 = u.line, n = u.column;
        if (typeof f.offset == "number") {
          let c = this.fromOffset(f.offset);
          s = c.line, o = c.col;
        } else
          s = f.line, o = f.column;
      } else if (!n) {
        let u = this.fromOffset(r2);
        r2 = u.line, n = u.col;
      }
      let l = this.origin(r2, n, s, o);
      return l ? a = new Va(e, l.endLine === undefined ? l.line : { column: l.column, line: l.line }, l.endLine === undefined ? l.column : { column: l.endColumn, line: l.endLine }, l.source, l.file, i.plugin) : a = new Va(e, s === undefined ? r2 : { column: n, line: r2 }, s === undefined ? n : { column: o, line: s }, this.css, this.file, i.plugin), a.input = { column: n, endColumn: o, endLine: s, line: r2, source: this.css }, this.file && (kr && (a.input.url = kr(this.file).toString()), a.input.file = this.file), a;
    }
    fromOffset(e) {
      let r2, n;
      if (this[zn])
        n = this[zn];
      else {
        let a = this.css.split(`
`);
        n = new Array(a.length);
        let s = 0;
        for (let o = 0, l = a.length;o < l; o++)
          n[o] = s, s += a[o].length + 1;
        this[zn] = n;
      }
      r2 = n[n.length - 1];
      let i = 0;
      if (e >= r2)
        i = n.length - 1;
      else {
        let a = n.length - 2, s;
        for (;i < a; )
          if (s = i + (a - i >> 1), e < n[s])
            a = s - 1;
          else if (e >= n[s + 1])
            i = s + 1;
          else {
            i = s;
            break;
          }
      }
      return { col: e - n[i] + 1, line: i + 1 };
    }
    mapResolve(e) {
      return /^\w+:\/\//.test(e) ? e : Wn(this.map.consumer().sourceRoot || this.map.root || ".", e);
    }
    origin(e, r2, n, i) {
      if (!this.map)
        return false;
      let a = this.map.consumer(), s = a.originalPositionFor({ column: r2, line: e });
      if (!s.source)
        return false;
      let o;
      typeof n == "number" && (o = a.originalPositionFor({ column: i, line: n }));
      let l;
      Vn(s.source) ? l = kr(s.source) : l = new URL(s.source, this.map.consumer().sourceRoot || kr(this.map.mapFile));
      let u = { column: s.column, endColumn: o && o.column, endLine: o && o.line, line: s.line, url: l.toString() };
      if (l.protocol === "file:")
        if (za)
          u.file = za(l);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f = a.sourceContentFor(s.source);
      return f && (u.source = f), u;
    }
    toJSON() {
      let e = {};
      for (let r2 of ["hasBOM", "css", "file", "id"])
        this[r2] != null && (e[r2] = this[r2]);
      return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = undefined)), e;
    }
    get from() {
      return this.file || this.id;
    }
  };
  Ba.exports = He;
  He.default = He;
  jn && jn.registerInput && jn.registerInput(He);
});
var Gn = k((Zw, Xa) => {
  var { SourceMapConsumer: Ha, SourceMapGenerator: Er } = xr(), { dirname: Or, relative: Ya, resolve: Qa, sep: Ja } = (xt(), Ue(bt)), { pathToFileURL: Ga } = (qn(), Ue(Fn)), Lp = Et(), Np = !!(Ha && Er), Fp = !!(Or && Qa && Ya && Ja), Bn = class {
    constructor(e, r2, n, i) {
      this.stringify = e, this.mapOpts = n.map || {}, this.root = r2, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = new Map, this.memoizedPaths = new Map, this.memoizedURLs = new Map;
    }
    addAnnotation() {
      let e;
      this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
      let r2 = `
`;
      this.css.includes(`\r
`) && (r2 = `\r
`), this.css += r2 + "/*# sourceMappingURL=" + e + " */";
    }
    applyPrevMaps() {
      for (let e of this.previous()) {
        let r2 = this.toUrl(this.path(e.file)), n = e.root || Or(e.file), i;
        this.mapOpts.sourcesContent === false ? (i = new Ha(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, r2, this.toUrl(this.path(n)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e;
          for (let r2 = this.root.nodes.length - 1;r2 >= 0; r2--)
            e = this.root.nodes[r2], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r2);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), Fp && Np && this.isMap())
        return this.generateMap();
      {
        let e = "";
        return this.stringify(this.root, (r2) => {
          e += r2;
        }), [e];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e = this.previous()[0].consumer();
        e.file = this.outputFile(), this.map = Er.fromSourceMap(e);
      } else
        this.map = new Er({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new Er({ file: this.outputFile() });
      let e = 1, r2 = 1, n = "<no source>", i = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, a, s;
      this.stringify(this.root, (o, l, u) => {
        if (this.css += o, l && u !== "end" && (i.generated.line = e, i.generated.column = r2 - 1, l.source && l.source.start ? (i.source = this.sourcePath(l), i.original.line = l.source.start.line, i.original.column = l.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), a = o.match(/\n/g), a ? (e += a.length, s = o.lastIndexOf(`
`), r2 = o.length - s) : r2 += o.length, l && u !== "start") {
          let f = l.parent || { raws: {} };
          (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== f.last || f.raws.semicolon) && (l.source && l.source.end ? (i.source = this.sourcePath(l), i.original.line = l.source.end.line, i.original.column = l.source.end.column - 1, i.generated.line = e, i.generated.column = r2 - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = r2 - 1, this.map.addMapping(i)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e = this.mapOpts.annotation;
      return typeof e < "u" && e !== true ? false : this.previous().length ? this.previous().some((r2) => r2.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e) {
      if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e))
        return e;
      let r2 = this.memoizedPaths.get(e);
      if (r2)
        return r2;
      let n = this.opts.to ? Or(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (n = Or(Qa(n, this.mapOpts.annotation)));
      let i = Ya(n, e);
      return this.memoizedPaths.set(e, i), i;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e) => {
            if (e.source && e.source.input.map) {
              let r2 = e.source.input.map;
              this.previousMaps.includes(r2) || this.previousMaps.push(r2);
            }
          });
        else {
          let e = new Lp(this.css, this.opts);
          e.map && this.previousMaps.push(e.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e = {};
      if (this.root)
        this.root.walk((r2) => {
          if (r2.source) {
            let n = r2.source.input.from;
            if (n && !e[n]) {
              e[n] = true;
              let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
              this.map.setSourceContent(i, r2.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r2, this.css);
      }
    }
    sourcePath(e) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
    }
    toBase64(e) {
      return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
    }
    toFileUrl(e) {
      let r2 = this.memoizedFileURLs.get(e);
      if (r2)
        return r2;
      if (Ga) {
        let n = Ga(e).toString();
        return this.memoizedFileURLs.set(e, n), n;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e) {
      let r2 = this.memoizedURLs.get(e);
      if (r2)
        return r2;
      Ja === "\\" && (e = e.replace(/\\/g, "/"));
      let n = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e, n), n;
    }
  };
  Xa.exports = Bn;
});
var At = k((eb, Ka) => {
  var qp = yt(), Ot = class extends qp {
    constructor(e) {
      super(e), this.type = "comment";
    }
  };
  Ka.exports = Ot;
  Ot.default = Ot;
});
var Ce = k((tb, oo) => {
  var { isClean: Za, my: eo } = wr(), to = wt(), ro = At(), Up = yt(), no, Hn, Yn, io;
  function so(t) {
    return t.map((e) => (e.nodes && (e.nodes = so(e.nodes)), delete e.source, e));
  }
  function ao(t) {
    if (t[Za] = false, t.proxyOf.nodes)
      for (let e of t.proxyOf.nodes)
        ao(e);
  }
  var pe = class t extends Up {
    append(...e) {
      for (let r2 of e) {
        let n = this.normalize(r2, this.last);
        for (let i of n)
          this.proxyOf.nodes.push(i);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e) {
      if (super.cleanRaws(e), this.nodes)
        for (let r2 of this.nodes)
          r2.cleanRaws(e);
    }
    each(e) {
      if (!this.proxyOf.nodes)
        return;
      let r2 = this.getIterator(), n, i;
      for (;this.indexes[r2] < this.proxyOf.nodes.length && (n = this.indexes[r2], i = e(this.proxyOf.nodes[n], n), i !== false); )
        this.indexes[r2] += 1;
      return delete this.indexes[r2], i;
    }
    every(e) {
      return this.nodes.every(e);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e = this.lastEach;
      return this.indexes[e] = 0, e;
    }
    getProxyProcessor() {
      return { get(e, r2) {
        return r2 === "proxyOf" ? e : e[r2] ? r2 === "each" || typeof r2 == "string" && r2.startsWith("walk") ? (...n) => e[r2](...n.map((i) => typeof i == "function" ? (a, s) => i(a.toProxy(), s) : i)) : r2 === "every" || r2 === "some" ? (n) => e[r2]((i, ...a) => n(i.toProxy(), ...a)) : r2 === "root" ? () => e.root().toProxy() : r2 === "nodes" ? e.nodes.map((n) => n.toProxy()) : r2 === "first" || r2 === "last" ? e[r2].toProxy() : e[r2] : e[r2];
      }, set(e, r2, n) {
        return e[r2] === n || (e[r2] = n, (r2 === "name" || r2 === "params" || r2 === "selector") && e.markDirty()), true;
      } };
    }
    index(e) {
      return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
    }
    insertAfter(e, r2) {
      let n = this.index(e), i = this.normalize(r2, this.proxyOf.nodes[n]).reverse();
      n = this.index(e);
      for (let s of i)
        this.proxyOf.nodes.splice(n + 1, 0, s);
      let a;
      for (let s in this.indexes)
        a = this.indexes[s], n < a && (this.indexes[s] = a + i.length);
      return this.markDirty(), this;
    }
    insertBefore(e, r2) {
      let n = this.index(e), i = n === 0 ? "prepend" : false, a = this.normalize(r2, this.proxyOf.nodes[n], i).reverse();
      n = this.index(e);
      for (let o of a)
        this.proxyOf.nodes.splice(n, 0, o);
      let s;
      for (let o in this.indexes)
        s = this.indexes[o], n <= s && (this.indexes[o] = s + a.length);
      return this.markDirty(), this;
    }
    normalize(e, r2) {
      if (typeof e == "string")
        e = so(no(e).nodes);
      else if (Array.isArray(e)) {
        e = e.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type === "root" && this.type !== "document") {
        e = e.nodes.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type)
        e = [e];
      else if (e.prop) {
        if (typeof e.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e.value != "string" && (e.value = String(e.value)), e = [new to(e)];
      } else if (e.selector)
        e = [new Hn(e)];
      else if (e.name)
        e = [new Yn(e)];
      else if (e.text)
        e = [new ro(e)];
      else
        throw new Error("Unknown node type in node creation");
      return e.map((i) => (i[eo] || t.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[Za] && ao(i), typeof i.raws.before > "u" && r2 && typeof r2.raws.before < "u" && (i.raws.before = r2.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
    }
    prepend(...e) {
      e = e.reverse();
      for (let r2 of e) {
        let n = this.normalize(r2, this.first, "prepend").reverse();
        for (let i of n)
          this.proxyOf.nodes.unshift(i);
        for (let i in this.indexes)
          this.indexes[i] = this.indexes[i] + n.length;
      }
      return this.markDirty(), this;
    }
    push(e) {
      return e.parent = this, this.proxyOf.nodes.push(e), this;
    }
    removeAll() {
      for (let e of this.proxyOf.nodes)
        e.parent = undefined;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e) {
      e = this.index(e), this.proxyOf.nodes[e].parent = undefined, this.proxyOf.nodes.splice(e, 1);
      let r2;
      for (let n in this.indexes)
        r2 = this.indexes[n], r2 >= e && (this.indexes[n] = r2 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e, r2, n) {
      return n || (n = r2, r2 = {}), this.walkDecls((i) => {
        r2.props && !r2.props.includes(i.prop) || r2.fast && !i.value.includes(r2.fast) || (i.value = i.value.replace(e, n));
      }), this.markDirty(), this;
    }
    some(e) {
      return this.nodes.some(e);
    }
    walk(e) {
      return this.each((r2, n) => {
        let i;
        try {
          i = e(r2, n);
        } catch (a) {
          throw r2.addToError(a);
        }
        return i !== false && r2.walk && (i = r2.walk(e)), i;
      });
    }
    walkAtRules(e, r2) {
      return r2 ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "atrule" && e.test(n.name))
          return r2(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "atrule" && n.name === e)
          return r2(n, i);
      }) : (r2 = e, this.walk((n, i) => {
        if (n.type === "atrule")
          return r2(n, i);
      }));
    }
    walkComments(e) {
      return this.walk((r2, n) => {
        if (r2.type === "comment")
          return e(r2, n);
      });
    }
    walkDecls(e, r2) {
      return r2 ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "decl" && e.test(n.prop))
          return r2(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "decl" && n.prop === e)
          return r2(n, i);
      }) : (r2 = e, this.walk((n, i) => {
        if (n.type === "decl")
          return r2(n, i);
      }));
    }
    walkRules(e, r2) {
      return r2 ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "rule" && e.test(n.selector))
          return r2(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "rule" && n.selector === e)
          return r2(n, i);
      }) : (r2 = e, this.walk((n, i) => {
        if (n.type === "rule")
          return r2(n, i);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  pe.registerParse = (t) => {
    no = t;
  };
  pe.registerRule = (t) => {
    Hn = t;
  };
  pe.registerAtRule = (t) => {
    Yn = t;
  };
  pe.registerRoot = (t) => {
    io = t;
  };
  oo.exports = pe;
  pe.default = pe;
  pe.rebuild = (t) => {
    t.type === "atrule" ? Object.setPrototypeOf(t, Yn.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, Hn.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, to.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, ro.prototype) : t.type === "root" && Object.setPrototypeOf(t, io.prototype), t[eo] = true, t.nodes && t.nodes.forEach((e) => {
      pe.rebuild(e);
    });
  };
});
var Ar = k((rb, fo) => {
  var $p = Ce(), lo, uo, $e = class extends $p {
    constructor(e) {
      super({ type: "document", ...e }), this.nodes || (this.nodes = []);
    }
    toResult(e = {}) {
      return new lo(new uo, this, e).stringify();
    }
  };
  $e.registerLazyResult = (t) => {
    lo = t;
  };
  $e.registerProcessor = (t) => {
    uo = t;
  };
  fo.exports = $e;
  $e.default = $e;
});
var Qn = k((nb, po) => {
  var co = {};
  po.exports = function(e) {
    co[e] || (co[e] = true, typeof console < "u" && console.warn && console.warn(e));
  };
});
var Jn = k((ib, ho) => {
  var Ct = class {
    constructor(e, r2 = {}) {
      if (this.type = "warning", this.text = e, r2.node && r2.node.source) {
        let n = r2.node.rangeBy(r2);
        this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
      }
      for (let n in r2)
        this[n] = r2[n];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  ho.exports = Ct;
  Ct.default = Ct;
});
var Cr = k((sb, mo) => {
  var jp = Jn(), _t = class {
    constructor(e, r2, n) {
      this.processor = e, this.messages = [], this.root = r2, this.opts = n, this.css = undefined, this.map = undefined;
    }
    toString() {
      return this.css;
    }
    warn(e, r2 = {}) {
      r2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r2.plugin = this.lastPlugin.postcssPlugin);
      let n = new jp(e, r2);
      return this.messages.push(n), n;
    }
    warnings() {
      return this.messages.filter((e) => e.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  mo.exports = _t;
  _t.default = _t;
});
var vo = k((ab, yo) => {
  var _r = /[\t\n\f\r "#'()/;[\\\]{}]/g, Tr = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, zp = /.[\r\n"'(/\\]/, go = /[\da-f]/i;
  yo.exports = function(e, r2 = {}) {
    let n = e.css.valueOf(), i = r2.ignoreErrors, a, s, o, l, u, f, c, p, d, m, w = n.length, h = 0, g = [], y = [];
    function b() {
      return h;
    }
    function v(S) {
      throw e.error("Unclosed " + S, h);
    }
    function O() {
      return y.length === 0 && h >= w;
    }
    function x(S) {
      if (y.length)
        return y.pop();
      if (h >= w)
        return;
      let I = S ? S.ignoreUnclosed : false;
      switch (a = n.charCodeAt(h), a) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          s = h;
          do
            s += 1, a = n.charCodeAt(s);
          while (a === 32 || a === 10 || a === 9 || a === 13 || a === 12);
          m = ["space", n.slice(h, s)], h = s - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let R = String.fromCharCode(a);
          m = [R, R, h];
          break;
        }
        case 40: {
          if (p = g.length ? g.pop()[1] : "", d = n.charCodeAt(h + 1), p === "url" && d !== 39 && d !== 34 && d !== 32 && d !== 10 && d !== 9 && d !== 12 && d !== 13) {
            s = h;
            do {
              if (f = false, s = n.indexOf(")", s + 1), s === -1)
                if (i || I) {
                  s = h;
                  break;
                } else
                  v("bracket");
              for (c = s;n.charCodeAt(c - 1) === 92; )
                c -= 1, f = !f;
            } while (f);
            m = ["brackets", n.slice(h, s + 1), h, s], h = s;
          } else
            s = n.indexOf(")", h + 1), l = n.slice(h, s + 1), s === -1 || zp.test(l) ? m = ["(", "(", h] : (m = ["brackets", l, h, s], h = s);
          break;
        }
        case 39:
        case 34: {
          o = a === 39 ? "'" : '"', s = h;
          do {
            if (f = false, s = n.indexOf(o, s + 1), s === -1)
              if (i || I) {
                s = h + 1;
                break;
              } else
                v("string");
            for (c = s;n.charCodeAt(c - 1) === 92; )
              c -= 1, f = !f;
          } while (f);
          m = ["string", n.slice(h, s + 1), h, s], h = s;
          break;
        }
        case 64: {
          _r.lastIndex = h + 1, _r.test(n), _r.lastIndex === 0 ? s = n.length - 1 : s = _r.lastIndex - 2, m = ["at-word", n.slice(h, s + 1), h, s], h = s;
          break;
        }
        case 92: {
          for (s = h, u = true;n.charCodeAt(s + 1) === 92; )
            s += 1, u = !u;
          if (a = n.charCodeAt(s + 1), u && a !== 47 && a !== 32 && a !== 10 && a !== 9 && a !== 13 && a !== 12 && (s += 1, go.test(n.charAt(s)))) {
            for (;go.test(n.charAt(s + 1)); )
              s += 1;
            n.charCodeAt(s + 1) === 32 && (s += 1);
          }
          m = ["word", n.slice(h, s + 1), h, s], h = s;
          break;
        }
        default: {
          a === 47 && n.charCodeAt(h + 1) === 42 ? (s = n.indexOf("*/", h + 2) + 1, s === 0 && (i || I ? s = n.length : v("comment")), m = ["comment", n.slice(h, s + 1), h, s], h = s) : (Tr.lastIndex = h + 1, Tr.test(n), Tr.lastIndex === 0 ? s = n.length - 1 : s = Tr.lastIndex - 2, m = ["word", n.slice(h, s + 1), h, s], g.push(m), h = s);
          break;
        }
      }
      return h++, m;
    }
    function C(S) {
      y.push(S);
    }
    return { back: C, endOfFile: O, nextToken: x, position: b };
  };
});
var Pr = k((ob, bo) => {
  var wo = Ce(), Ye = class extends wo {
    constructor(e) {
      super(e), this.type = "atrule";
    }
    append(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
    }
    prepend(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
    }
  };
  bo.exports = Ye;
  Ye.default = Ye;
  wo.registerAtRule(Ye);
});
var Qe = k((lb, Eo) => {
  var xo = Ce(), So, ko, _e = class extends xo {
    constructor(e) {
      super(e), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e, r2, n) {
      let i = super.normalize(e);
      if (r2) {
        if (n === "prepend")
          this.nodes.length > 1 ? r2.raws.before = this.nodes[1].raws.before : delete r2.raws.before;
        else if (this.first !== r2)
          for (let a of i)
            a.raws.before = r2.raws.before;
      }
      return i;
    }
    removeChild(e, r2) {
      let n = this.index(e);
      return !r2 && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
    }
    toResult(e = {}) {
      return new So(new ko, this, e).stringify();
    }
  };
  _e.registerLazyResult = (t) => {
    So = t;
  };
  _e.registerProcessor = (t) => {
    ko = t;
  };
  Eo.exports = _e;
  _e.default = _e;
  xo.registerRoot(_e);
});
var Xn = k((ub, Oo) => {
  var Tt = { comma(t) {
    return Tt.split(t, [","], true);
  }, space(t) {
    let e = [" ", `
`, "\t"];
    return Tt.split(t, e);
  }, split(t, e, r2) {
    let n = [], i = "", a = false, s = 0, o = false, l = "", u = false;
    for (let f of t)
      u ? u = false : f === "\\" ? u = true : o ? f === l && (o = false) : f === '"' || f === "'" ? (o = true, l = f) : f === "(" ? s += 1 : f === ")" ? s > 0 && (s -= 1) : s === 0 && e.includes(f) && (a = true), a ? (i !== "" && n.push(i.trim()), i = "", a = false) : i += f;
    return (r2 || i !== "") && n.push(i.trim()), n;
  } };
  Oo.exports = Tt;
  Tt.default = Tt;
});
var Ir = k((fb, Co) => {
  var Ao = Ce(), Vp = Xn(), Je = class extends Ao {
    constructor(e) {
      super(e), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return Vp.comma(this.selector);
    }
    set selectors(e) {
      let r2 = this.selector ? this.selector.match(/,\s*/) : null, n = r2 ? r2[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e.join(n);
    }
  };
  Co.exports = Je;
  Je.default = Je;
  Ao.registerRule(Je);
});
var Io = k((cb, Po) => {
  var Wp = wt(), Bp = vo(), Gp = At(), Hp = Pr(), Yp = Qe(), _o = Ir(), To = { empty: true, space: true };
  function Qp(t) {
    for (let e = t.length - 1;e >= 0; e--) {
      let r2 = t[e], n = r2[3] || r2[2];
      if (n)
        return n;
    }
  }
  var Kn = class {
    constructor(e) {
      this.input = e, this.root = new Yp, this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e) {
      let r2 = new Hp;
      r2.name = e[1].slice(1), r2.name === "" && this.unnamedAtrule(r2, e), this.init(r2, e[2]);
      let n, i, a, s = false, o = false, l = [], u = [];
      for (;!this.tokenizer.endOfFile(); ) {
        if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? u.push(n === "(" ? ")" : "]") : n === "{" && u.length > 0 ? u.push("}") : n === u[u.length - 1] && u.pop(), u.length === 0)
          if (n === ";") {
            r2.source.end = this.getPosition(e[2]), r2.source.end.offset++, this.semicolon = true;
            break;
          } else if (n === "{") {
            o = true;
            break;
          } else if (n === "}") {
            if (l.length > 0) {
              for (a = l.length - 1, i = l[a];i && i[0] === "space"; )
                i = l[--a];
              i && (r2.source.end = this.getPosition(i[3] || i[2]), r2.source.end.offset++);
            }
            this.end(e);
            break;
          } else
            l.push(e);
        else
          l.push(e);
        if (this.tokenizer.endOfFile()) {
          s = true;
          break;
        }
      }
      r2.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (r2.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(r2, "params", l), s && (e = l[l.length - 1], r2.source.end = this.getPosition(e[3] || e[2]), r2.source.end.offset++, this.spaces = r2.raws.between, r2.raws.between = "")) : (r2.raws.afterName = "", r2.params = ""), o && (r2.nodes = [], this.current = r2);
    }
    checkMissedSemicolon(e) {
      let r2 = this.colon(e);
      if (r2 === false)
        return;
      let n = 0, i;
      for (let a = r2 - 1;a >= 0 && (i = e[a], !(i[0] !== "space" && (n += 1, n === 2))); a--)
        ;
      throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2]);
    }
    colon(e) {
      let r2 = 0, n, i, a;
      for (let [s, o] of e.entries()) {
        if (n = o, i = n[0], i === "(" && (r2 += 1), i === ")" && (r2 -= 1), r2 === 0 && i === ":")
          if (!a)
            this.doubleColon(n);
          else {
            if (a[0] === "word" && a[1] === "progid")
              continue;
            return s;
          }
        a = n;
      }
      return false;
    }
    comment(e) {
      let r2 = new Gp;
      this.init(r2, e[2]), r2.source.end = this.getPosition(e[3] || e[2]), r2.source.end.offset++;
      let n = e[1].slice(2, -2);
      if (/^\s*$/.test(n))
        r2.text = "", r2.raws.left = n, r2.raws.right = "";
      else {
        let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
        r2.text = i[2], r2.raws.left = i[1], r2.raws.right = i[3];
      }
    }
    createTokenizer() {
      this.tokenizer = Bp(this.input);
    }
    decl(e, r2) {
      let n = new Wp;
      this.init(n, e[0][2]);
      let i = e[e.length - 1];
      for (i[0] === ";" && (this.semicolon = true, e.pop()), n.source.end = this.getPosition(i[3] || i[2] || Qp(e)), n.source.end.offset++;e[0][0] !== "word"; )
        e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
      for (n.source.start = this.getPosition(e[0][2]), n.prop = "";e.length; ) {
        let u = e[0][0];
        if (u === ":" || u === "space" || u === "comment")
          break;
        n.prop += e.shift()[1];
      }
      n.raws.between = "";
      let a;
      for (;e.length; )
        if (a = e.shift(), a[0] === ":") {
          n.raws.between += a[1];
          break;
        } else
          a[0] === "word" && /\w/.test(a[1]) && this.unknownWord([a]), n.raws.between += a[1];
      (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
      let s = [], o;
      for (;e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
        s.push(e.shift());
      this.precheckMissedSemicolon(e);
      for (let u = e.length - 1;u >= 0; u--) {
        if (a = e[u], a[1].toLowerCase() === "!important") {
          n.important = true;
          let f = this.stringFrom(e, u);
          f = this.spacesFromEnd(e) + f, f !== " !important" && (n.raws.important = f);
          break;
        } else if (a[1].toLowerCase() === "important") {
          let f = e.slice(0), c = "";
          for (let p = u;p > 0; p--) {
            let d = f[p][0];
            if (c.trim().indexOf("!") === 0 && d !== "space")
              break;
            c = f.pop()[1] + c;
          }
          c.trim().indexOf("!") === 0 && (n.important = true, n.raws.important = c, e = f);
        }
        if (a[0] !== "space" && a[0] !== "comment")
          break;
      }
      e.some((u) => u[0] !== "space" && u[0] !== "comment") && (n.raws.between += s.map((u) => u[1]).join(""), s = []), this.raw(n, "value", s.concat(e), r2), n.value.includes(":") && !r2 && this.checkMissedSemicolon(e);
    }
    doubleColon(e) {
      throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
    }
    emptyRule(e) {
      let r2 = new _o;
      this.init(r2, e[2]), r2.selector = "", r2.raws.between = "", this.current = r2;
    }
    end(e) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e) {
      if (this.spaces += e[1], this.current.nodes) {
        let r2 = this.current.nodes[this.current.nodes.length - 1];
        r2 && r2.type === "rule" && !r2.raws.ownSemicolon && (r2.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e) {
      let r2 = this.input.fromOffset(e);
      return { column: r2.col, line: r2.line, offset: e };
    }
    init(e, r2) {
      this.current.push(e), e.source = { input: this.input, start: this.getPosition(r2) }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = false);
    }
    other(e) {
      let r2 = false, n = null, i = false, a = null, s = [], o = e[1].startsWith("--"), l = [], u = e;
      for (;u; ) {
        if (n = u[0], l.push(u), n === "(" || n === "[")
          a || (a = u), s.push(n === "(" ? ")" : "]");
        else if (o && i && n === "{")
          a || (a = u), s.push("}");
        else if (s.length === 0)
          if (n === ";")
            if (i) {
              this.decl(l, o);
              return;
            } else
              break;
          else if (n === "{") {
            this.rule(l);
            return;
          } else if (n === "}") {
            this.tokenizer.back(l.pop()), r2 = true;
            break;
          } else
            n === ":" && (i = true);
        else
          n === s[s.length - 1] && (s.pop(), s.length === 0 && (a = null));
        u = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r2 = true), s.length > 0 && this.unclosedBracket(a), r2 && i) {
        if (!o)
          for (;l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment")); )
            this.tokenizer.back(l.pop());
        this.decl(l, o);
      } else
        this.unknownWord(l);
    }
    parse() {
      let e;
      for (;!this.tokenizer.endOfFile(); )
        switch (e = this.tokenizer.nextToken(), e[0]) {
          case "space":
            this.spaces += e[1];
            break;
          case ";":
            this.freeSemicolon(e);
            break;
          case "}":
            this.end(e);
            break;
          case "comment":
            this.comment(e);
            break;
          case "at-word":
            this.atrule(e);
            break;
          case "{":
            this.emptyRule(e);
            break;
          default:
            this.other(e);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {}
    raw(e, r2, n, i) {
      let a, s, o = n.length, l = "", u = true, f, c;
      for (let p = 0;p < o; p += 1)
        a = n[p], s = a[0], s === "space" && p === o - 1 && !i ? u = false : s === "comment" ? (c = n[p - 1] ? n[p - 1][0] : "empty", f = n[p + 1] ? n[p + 1][0] : "empty", !To[c] && !To[f] ? l.slice(-1) === "," ? u = false : l += a[1] : u = false) : l += a[1];
      if (!u) {
        let p = n.reduce((d, m) => d + m[1], "");
        e.raws[r2] = { raw: p, value: l };
      }
      e[r2] = l;
    }
    rule(e) {
      e.pop();
      let r2 = new _o;
      this.init(r2, e[0][2]), r2.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(r2, "selector", e), this.current = r2;
    }
    spacesAndCommentsFromEnd(e) {
      let r2, n = "";
      for (;e.length && (r2 = e[e.length - 1][0], !(r2 !== "space" && r2 !== "comment")); )
        n = e.pop()[1] + n;
      return n;
    }
    spacesAndCommentsFromStart(e) {
      let r2, n = "";
      for (;e.length && (r2 = e[0][0], !(r2 !== "space" && r2 !== "comment")); )
        n += e.shift()[1];
      return n;
    }
    spacesFromEnd(e) {
      let r2, n = "";
      for (;e.length && (r2 = e[e.length - 1][0], r2 === "space"); )
        n = e.pop()[1] + n;
      return n;
    }
    stringFrom(e, r2) {
      let n = "";
      for (let i = r2;i < e.length; i++)
        n += e[i][1];
      return e.splice(r2, e.length - r2), n;
    }
    unclosedBlock() {
      let e = this.current.source.start;
      throw this.input.error("Unclosed block", e.line, e.column);
    }
    unclosedBracket(e) {
      throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unexpectedClose(e) {
      throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unknownWord(e) {
      throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
    }
    unnamedAtrule(e, r2) {
      throw this.input.error("At-rule without name", { offset: r2[2] }, { offset: r2[2] + r2[1].length });
    }
  };
  Po.exports = Kn;
});
var Dr = k((pb, Ro) => {
  var Jp = Ce(), Xp = Io(), Kp = Et();
  function Rr(t, e) {
    let r2 = new Kp(t, e), n = new Xp(r2);
    try {
      n.parse();
    } catch (i) {
      throw i;
    }
    return n.root;
  }
  Ro.exports = Rr;
  Rr.default = Rr;
  Jp.registerParse(Rr);
});
var ti = k((hb, No) => {
  var { isClean: me, my: Zp } = wr(), ed = Gn(), td = mt(), rd = Ce(), nd = Ar(), db2 = Qn(), Do = Cr(), id = Dr(), sd = Qe(), ad = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, od = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, ld = { Once: true, postcssPlugin: true, prepare: true }, Xe = 0;
  function Pt(t) {
    return typeof t == "object" && typeof t.then == "function";
  }
  function Lo(t) {
    let e = false, r2 = ad[t.type];
    return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [r2, r2 + "-" + e, Xe, r2 + "Exit", r2 + "Exit-" + e] : e ? [r2, r2 + "-" + e, r2 + "Exit", r2 + "Exit-" + e] : t.append ? [r2, Xe, r2 + "Exit"] : [r2, r2 + "Exit"];
  }
  function Mo(t) {
    let e;
    return t.type === "document" ? e = ["Document", Xe, "DocumentExit"] : t.type === "root" ? e = ["Root", Xe, "RootExit"] : e = Lo(t), { eventIndex: 0, events: e, iterator: 0, node: t, visitorIndex: 0, visitors: [] };
  }
  function Zn(t) {
    return t[me] = false, t.nodes && t.nodes.forEach((e) => Zn(e)), t;
  }
  var ei = {}, Te = class t {
    constructor(e, r2, n) {
      this.stringified = false, this.processed = false;
      let i;
      if (typeof r2 == "object" && r2 !== null && (r2.type === "root" || r2.type === "document"))
        i = Zn(r2);
      else if (r2 instanceof t || r2 instanceof Do)
        i = Zn(r2.root), r2.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = false), n.map.prev = r2.map);
      else {
        let a = id;
        n.syntax && (a = n.syntax.parse), n.parser && (a = n.parser), a.parse && (a = a.parse);
        try {
          i = a(r2, n);
        } catch (s) {
          this.processed = true, this.error = s;
        }
        i && !i[Zp] && rd.rebuild(i);
      }
      this.result = new Do(e, i, n), this.helpers = { ...ei, postcss: ei, result: this.result }, this.plugins = this.processor.plugins.map((a) => typeof a == "object" && a.prepare ? { ...a, ...a.prepare(this.result) } : a);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e, r2) {
      let n = this.result.lastPlugin;
      try {
        r2 && r2.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = n.postcssPlugin, e.setMessage()) : n.postcssVersion;
      } catch (i) {
        console && console.error && console.error(i);
      }
      return e;
    }
    prepareVisitors() {
      this.listeners = {};
      let e = (r2, n, i) => {
        this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([r2, i]);
      };
      for (let r2 of this.plugins)
        if (typeof r2 == "object")
          for (let n in r2) {
            if (!od[n] && /^[A-Z]/.test(n))
              throw new Error(`Unknown event ${n} in ${r2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!ld[n])
              if (typeof r2[n] == "object")
                for (let i in r2[n])
                  i === "*" ? e(r2, n, r2[n][i]) : e(r2, n + "-" + i.toLowerCase(), r2[n][i]);
              else
                typeof r2[n] == "function" && e(r2, n, r2[n]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e = 0;e < this.plugins.length; e++) {
        let r2 = this.plugins[e], n = this.runOnRoot(r2);
        if (Pt(n))
          try {
            await n;
          } catch (i) {
            throw this.handleError(i);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (;!e[me]; ) {
          e[me] = true;
          let r2 = [Mo(e)];
          for (;r2.length > 0; ) {
            let n = this.visitTick(r2);
            if (Pt(n))
              try {
                await n;
              } catch (i) {
                let a = r2[r2.length - 1].node;
                throw this.handleError(i, a);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r2, n] of this.listeners.OnceExit) {
            this.result.lastPlugin = r2;
            try {
              if (e.type === "document") {
                let i = e.nodes.map((a) => n(a, this.helpers));
                await Promise.all(i);
              } else
                await n(e, this.helpers);
            } catch (i) {
              throw this.handleError(i);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e) {
      this.result.lastPlugin = e;
      try {
        if (typeof e == "object" && e.Once) {
          if (this.result.root.type === "document") {
            let r2 = this.result.root.nodes.map((n) => e.Once(n, this.helpers));
            return Pt(r2[0]) ? Promise.all(r2) : r2;
          }
          return e.Once(this.result.root, this.helpers);
        } else if (typeof e == "function")
          return e(this.result.root, this.result);
      } catch (r2) {
        throw this.handleError(r2);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e = this.result.opts, r2 = td;
      e.syntax && (r2 = e.syntax.stringify), e.stringifier && (r2 = e.stringifier), r2.stringify && (r2 = r2.stringify);
      let i = new ed(r2, this.result.root, this.result.opts).generate();
      return this.result.css = i[0], this.result.map = i[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e of this.plugins) {
        let r2 = this.runOnRoot(e);
        if (Pt(r2))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (;!e[me]; )
          e[me] = true, this.walkSync(e);
        if (this.listeners.OnceExit)
          if (e.type === "document")
            for (let r2 of e.nodes)
              this.visitSync(this.listeners.OnceExit, r2);
          else
            this.visitSync(this.listeners.OnceExit, e);
      }
      return this.result;
    }
    then(e, r2) {
      return this.async().then(e, r2);
    }
    toString() {
      return this.css;
    }
    visitSync(e, r2) {
      for (let [n, i] of e) {
        this.result.lastPlugin = n;
        let a;
        try {
          a = i(r2, this.helpers);
        } catch (s) {
          throw this.handleError(s, r2.proxyOf);
        }
        if (r2.type !== "root" && r2.type !== "document" && !r2.parent)
          return true;
        if (Pt(a))
          throw this.getAsyncError();
      }
    }
    visitTick(e) {
      let r2 = e[e.length - 1], { node: n, visitors: i } = r2;
      if (n.type !== "root" && n.type !== "document" && !n.parent) {
        e.pop();
        return;
      }
      if (i.length > 0 && r2.visitorIndex < i.length) {
        let [s, o] = i[r2.visitorIndex];
        r2.visitorIndex += 1, r2.visitorIndex === i.length && (r2.visitors = [], r2.visitorIndex = 0), this.result.lastPlugin = s;
        try {
          return o(n.toProxy(), this.helpers);
        } catch (l) {
          throw this.handleError(l, n);
        }
      }
      if (r2.iterator !== 0) {
        let s = r2.iterator, o;
        for (;o = n.nodes[n.indexes[s]]; )
          if (n.indexes[s] += 1, !o[me]) {
            o[me] = true, e.push(Mo(o));
            return;
          }
        r2.iterator = 0, delete n.indexes[s];
      }
      let a = r2.events;
      for (;r2.eventIndex < a.length; ) {
        let s = a[r2.eventIndex];
        if (r2.eventIndex += 1, s === Xe) {
          n.nodes && n.nodes.length && (n[me] = true, r2.iterator = n.getIterator());
          return;
        } else if (this.listeners[s]) {
          r2.visitors = this.listeners[s];
          return;
        }
      }
      e.pop();
    }
    walkSync(e) {
      e[me] = true;
      let r2 = Lo(e);
      for (let n of r2)
        if (n === Xe)
          e.nodes && e.each((i) => {
            i[me] || this.walkSync(i);
          });
        else {
          let i = this.listeners[n];
          if (i && this.visitSync(i, e.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  Te.registerPostcss = (t) => {
    ei = t;
  };
  No.exports = Te;
  Te.default = Te;
  sd.registerLazyResult(Te);
  nd.registerLazyResult(Te);
});
var qo = k((gb, Fo) => {
  var ud = Gn(), fd = mt(), mb = Qn(), cd = Dr(), pd = Cr(), It = class {
    constructor(e, r2, n) {
      r2 = r2.toString(), this.stringified = false, this._processor = e, this._css = r2, this._opts = n, this._map = undefined;
      let i, a = fd;
      this.result = new pd(this._processor, i, this._opts), this.result.css = r2;
      let s = this;
      Object.defineProperty(this.result, "root", { get() {
        return s.root;
      } });
      let o = new ud(a, i, this._opts, r2);
      if (o.isMap()) {
        let [l, u] = o.generate();
        l && (this.result.css = l), u && (this.result.map = u);
      }
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(e, r2) {
      return this.async().then(e, r2);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let e, r2 = cd;
      try {
        e = r2(this._css, this._opts);
      } catch (n) {
        this.error = n;
      }
      if (this.error)
        throw this.error;
      return this._root = e, e;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  Fo.exports = It;
  It.default = It;
});
var $o = k((yb, Uo) => {
  var dd = qo(), hd = ti(), md = Ar(), gd = Qe(), je = class {
    constructor(e = []) {
      this.version = "8.4.32", this.plugins = this.normalize(e);
    }
    normalize(e) {
      let r2 = [];
      for (let n of e)
        if (n.postcss === true ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
          r2 = r2.concat(n.plugins);
        else if (typeof n == "object" && n.postcssPlugin)
          r2.push(n);
        else if (typeof n == "function")
          r2.push(n);
        else if (!(typeof n == "object" && (n.parse || n.stringify)))
          throw new Error(n + " is not a PostCSS plugin");
      return r2;
    }
    process(e, r2 = {}) {
      return this.plugins.length === 0 && typeof r2.parser > "u" && typeof r2.stringifier > "u" && typeof r2.syntax > "u" ? new dd(this, e, r2) : new hd(this, e, r2);
    }
    use(e) {
      return this.plugins = this.plugins.concat(this.normalize([e])), this;
    }
  };
  Uo.exports = je;
  je.default = je;
  gd.registerProcessor(je);
  md.registerProcessor(je);
});
var zo = k((vb, jo) => {
  var yd = wt(), vd = $n(), wd = At(), bd = Pr(), xd = Et(), Sd = Qe(), kd = Ir();
  function Rt(t, e) {
    if (Array.isArray(t))
      return t.map((i) => Rt(i));
    let { inputs: r2, ...n } = t;
    if (r2) {
      e = [];
      for (let i of r2) {
        let a = { ...i, __proto__: xd.prototype };
        a.map && (a.map = { ...a.map, __proto__: vd.prototype }), e.push(a);
      }
    }
    if (n.nodes && (n.nodes = t.nodes.map((i) => Rt(i, e))), n.source) {
      let { inputId: i, ...a } = n.source;
      n.source = a, i != null && (n.source.input = e[i]);
    }
    if (n.type === "root")
      return new Sd(n);
    if (n.type === "decl")
      return new yd(n);
    if (n.type === "rule")
      return new kd(n);
    if (n.type === "comment")
      return new wd(n);
    if (n.type === "atrule")
      return new bd(n);
    throw new Error("Unknown node type: " + t.type);
  }
  jo.exports = Rt;
  Rt.default = Rt;
});
var Ke = k((wb, Qo) => {
  var Ed = vr(), Vo = wt(), Od = ti(), Ad = Ce(), ri = $o(), Cd = mt(), _d = zo(), Wo = Ar(), Td = Jn(), Bo = At(), Go = Pr(), Pd = Cr(), Id = Et(), Rd = Dr(), Dd = Xn(), Ho = Ir(), Yo = Qe(), Md = yt();
  function N(...t) {
    return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new ri(t);
  }
  N.plugin = function(e, r2) {
    let n = false;
    function i(...s) {
      console && console.warn && !n && (n = true, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
      let o = r2(...s);
      return o.postcssPlugin = e, o.postcssVersion = new ri().version, o;
    }
    let a;
    return Object.defineProperty(i, "postcss", { get() {
      return a || (a = i()), a;
    } }), i.process = function(s, o, l) {
      return N([i(l)]).process(s, o);
    }, i;
  };
  N.stringify = Cd;
  N.parse = Rd;
  N.fromJSON = _d;
  N.list = Dd;
  N.comment = (t) => new Bo(t);
  N.atRule = (t) => new Go(t);
  N.decl = (t) => new Vo(t);
  N.rule = (t) => new Ho(t);
  N.root = (t) => new Yo(t);
  N.document = (t) => new Wo(t);
  N.CssSyntaxError = Ed;
  N.Declaration = Vo;
  N.Container = Ad;
  N.Processor = ri;
  N.Document = Wo;
  N.Comment = Bo;
  N.Warning = Td;
  N.AtRule = Go;
  N.Result = Pd;
  N.Input = Id;
  N.Rule = Ho;
  N.Root = Yo;
  N.Node = Md;
  Od.registerPostcss(N);
  Qo.exports = N;
  N.default = N;
});
var il = k((Bb, nl) => {
  var Mr = Object.prototype.hasOwnProperty, rl = Object.prototype.toString, Jo = Object.defineProperty, Xo = Object.getOwnPropertyDescriptor, Ko = function(e) {
    return typeof Array.isArray == "function" ? Array.isArray(e) : rl.call(e) === "[object Array]";
  }, Zo = function(e) {
    if (!e || rl.call(e) !== "[object Object]")
      return false;
    var r2 = Mr.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Mr.call(e.constructor.prototype, "isPrototypeOf");
    if (e.constructor && !r2 && !n)
      return false;
    var i;
    for (i in e)
      ;
    return typeof i > "u" || Mr.call(e, i);
  }, el = function(e, r2) {
    Jo && r2.name === "__proto__" ? Jo(e, r2.name, { enumerable: true, configurable: true, value: r2.newValue, writable: true }) : e[r2.name] = r2.newValue;
  }, tl = function(e, r2) {
    if (r2 === "__proto__")
      if (Mr.call(e, r2)) {
        if (Xo)
          return Xo(e, r2).value;
      } else
        return;
    return e[r2];
  };
  nl.exports = function t() {
    var e, r2, n, i, a, s, o = arguments[0], l = 1, u = arguments.length, f = false;
    for (typeof o == "boolean" && (f = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {});l < u; ++l)
      if (e = arguments[l], e != null)
        for (r2 in e)
          n = tl(o, r2), i = tl(e, r2), o !== i && (f && i && (Zo(i) || (a = Ko(i))) ? (a ? (a = false, s = n && Ko(n) ? n : []) : s = n && Zo(n) ? n : {}, el(o, { name: r2, newValue: t(f, s, i) })) : typeof i < "u" && el(o, { name: r2, newValue: i }));
    return o;
  };
});
var Lr = k((Gb, sl) => {
  var ni = function(t, e) {
    var r2 = new t.constructor;
    return Object.keys(t).forEach(function(n) {
      if (t.hasOwnProperty(n)) {
        var i = t[n], a = typeof i;
        n === "parent" && a === "object" ? e && (r2[n] = e) : n === "source" ? r2[n] = i : i instanceof Array ? n === "nodes" ? r2[n] = [] : r2[n] = i.map(function(s) {
          ni(s, r2);
        }) : n !== "before" && n !== "after" && n !== "between" && n !== "semicolon" && (a === "object" && (i = ni(i)), r2[n] = i);
      }
    }), r2;
  };
  sl.exports = ni;
});
var fl = k((Hb, ul) => {
  ul.exports = ol;
  function ol(t, e, r2) {
    t instanceof RegExp && (t = al(t, r2)), e instanceof RegExp && (e = al(e, r2));
    var n = ll(t, e, r2);
    return n && { start: n[0], end: n[1], pre: r2.slice(0, n[0]), body: r2.slice(n[0] + t.length, n[1]), post: r2.slice(n[1] + e.length) };
  }
  function al(t, e) {
    var r2 = e.match(t);
    return r2 ? r2[0] : null;
  }
  ol.range = ll;
  function ll(t, e, r2) {
    var n, i, a, s, o, l = r2.indexOf(t), u = r2.indexOf(e, l + 1), f = l;
    if (l >= 0 && u > 0) {
      if (t === e)
        return [l, u];
      for (n = [], a = r2.length;f >= 0 && !o; )
        f == l ? (n.push(f), l = r2.indexOf(t, f + 1)) : n.length == 1 ? o = [n.pop(), u] : (i = n.pop(), i < a && (a = i, s = u), u = r2.indexOf(e, f + 1)), f = l < u && l >= 0 ? l : u;
      n.length && (o = [a, s]);
    }
    return o;
  }
});
var pl = k((Yb, cl) => {
  var Ld = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, Nd = function(t) {
    return t.split(Ld).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  cl.exports = Nd;
});
var Dt = k((Qb, dl) => {
  var Fd = pl(), qd = function(t, e) {
    e = e || false;
    for (var r2 = [[]], n = e ? t : t.parent;n; ) {
      var i = (n.selectors || []).map(function(s) {
        return { value: s, type: "selector" };
      });
      n.type === "atrule" && (i = [].concat(n.params).map(function(s) {
        return { value: "@" + n.name + " " + s, type: "atrule" };
      }));
      var a = (i.length > 0 ? i : [1]).map(function() {
        return r2.map(function(s) {
          return s.slice(0);
        });
      });
      i.forEach(function(s, o) {
        a[o] = a[o].map(function(l) {
          var u = [s.value];
          return s.type === "selector" && (u = Fd(s.value)), l.unshift.apply(l, u), l;
        });
      }), r2 = [], a.forEach(function(s) {
        r2 = r2.concat(s);
      }), n = n.parent;
    }
    return r2;
  };
  dl.exports = qd;
});
var ml = k((Jb, hl) => {
  var Ud = /[|\\{}()[\]^$+*?.]/g;
  hl.exports = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(Ud, "\\$&");
  };
});
var yl = k((Xb, gl) => {
  var $d = { "*": true, ":root": true, html: true }, jd = function(t) {
    return !!$d[t];
  };
  gl.exports = jd;
});
var wl = k((Kb, vl) => {
  var zd = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, Vd = function(t) {
    return t.split(zd).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  vl.exports = Vd;
});
var ii = k((Zb, Al) => {
  var Wd = ml(), bl = yl(), xl = wl(), Bd = /^@.*/, kl = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function El(t, e) {
    var r2, n, i = e.some(function(a) {
      return t.some(function(s) {
        r2 = null;
        var o = true;
        for (n = 0;n < a.length; n++) {
          for (var l = a[n], u = r2 || 0, f = -1, c = s.slice(u), p = 0;p < c.length; p++) {
            var d = c[p], m = u + p;
            if (new RegExp(Wd(l) + "$").test(d)) {
              f = m;
              break;
            }
            if (bl(l) || bl(d)) {
              f = m;
              break;
            }
            var w = xl(d);
            if (w.length > 1) {
              var h = [].concat([w]), g = [].concat([a.slice(n).reduce(function(v, O) {
                return v.concat(xl(O));
              }, [])]), y = El(h, g);
              (y.doesMatchScope || n + 1 < a.length) && (f = m, n += y.scopePieceIndex - 1);
              break;
            }
          }
          var b = f >= u;
          if (r2 = f + 1, o = o && b, !o)
            break;
        }
        return o;
      });
    });
    return { doesMatchScope: i, nodeScopePieceIndex: r2 - 1, scopePieceIndex: n };
  }
  var Sl = function(t) {
    return t.map(function(e) {
      return e.map(function(r2) {
        return Bd.test(r2) ? r2 : r2.replace(new RegExp(kl.source, "g"), function(n, i, a, s) {
          return i + s;
        });
      });
    });
  }, Ol = function(t, e, r2) {
    return t = Sl(t), r2 && (e = Sl(e)), El(t, e).doesMatchScope;
  };
  Ol.RE_PSEUDO_SELECTOR = kl;
  Al.exports = Ol;
});
var si = k((ex, _l) => {
  var Gd = ii(), Cl = Dt(), Hd = function(t, e, r2) {
    var n = Cl(t, true), i = Cl(e, true);
    return Gd(n, i, r2);
  };
  _l.exports = Hd;
});
var ai = k((tx, Pl) => {
  var Tl = function(t, e, r2) {
    r2 = r2 || [];
    var n = false;
    return t && (r2 = t.reduce(function(i, a) {
      var s = !!e[a], o = s ? i.some(function(l) {
        return e[a].some(function(u) {
          return l === u;
        });
      }) : false;
      return n = n || o, s && !n && (i = i.concat(e[a]), (e[a] || []).forEach(function(l) {
        var u = Tl(l.variablesUsed, e, i);
        i = u.deps, n = n || u.hasCircularOrSelfReference;
      })), i;
    }, r2)), { deps: r2, hasCircularOrSelfReference: n };
  };
  Pl.exports = Tl;
});
var oi = k((rx, Il) => {
  var Yd = Dt(), Qd = function(t, e) {
    for (var r2, n = e;n.parent && !r2; ) {
      var i = Yd(n.clone(), true);
      i.some(function(a) {
        return a.some(function(s) {
          return s === t ? (r2 = n, true) : false;
        });
      }), n = n.parent;
    }
    return r2;
  };
  Il.exports = Qd;
});
var li = k((nx, Dl) => {
  var Rl = Lr(), Jd = function(t, e, r2) {
    r2 = r2 || function() {
      return true;
    };
    for (var n = [], i = t, a = false;i && !a; )
      i.type === "decl" ? n.push(i.clone()) : n.push(Rl(i)), a = r2(i), i = i.parent;
    for (var s = [], o = e;o; )
      s.push(Rl(o)), o = o.parent;
    return s.forEach(function(l, u, f) {
      u + 1 < f.length && (l.parent = f[u + 1]);
    }), n.forEach(function(l, u, f) {
      u + 1 < f.length ? l.parent = f[u + 1] : (s.slice(-1)[0].parent = i, l.parent = s[0]);
    }), n[0];
  };
  Dl.exports = Jd;
});
var ui = k((ix, Ll) => {
  var Xd = fl(), Kd = Dt(), Ml = si(), Zd = ai(), eh = oi(), th = li(), rh = /var\(\s*(--[^,\s)]+)/;
  function nh(t) {
    return String(t);
  }
  function Nr(t) {
    var e = Xd("(", ")", t);
    if (e) {
      if (/(?:^|[^\w-])var$/.test(e.pre))
        return { pre: e.pre.slice(0, -3), body: e.body, post: e.post };
      var r2 = Nr(e.body);
      if (r2)
        return { pre: e.pre + "(" + r2.pre, body: r2.body, post: r2.post + ")" + e.post };
      var n = Nr(e.post);
      if (n)
        return { pre: e.pre + "(" + e.body + ")" + n.pre, body: n.body, post: n.post };
    }
  }
  var Fr = function(t, e, r2, n) {
    for (var i = n ? "\t" : "", a = undefined, s = nh(t.value), o = [], l = {}, u = s;a = Nr(u); ) {
      var f = a.body.split(","), c = f[0].trim();
      l[c] = true, u = (a.pre || "") + a.body.replace(c, "") + (a.post || "");
    }
    u = undefined;
    for (var p = Object.keys(l), d = false;a = Nr(s); ) {
      var m = undefined, f = a.body.split(","), c = f[0].trim(), w = f.length > 1 ? f.slice(1).join(",").trim() : undefined;
      (e[c] || []).forEach(function(C) {
        var S = C.parent.type === "root" || C.parent.selectors[0] === ":root", I = Ml(t.parent, C.parent), R = Ml(t.parent, C.parent, r2);
        R && (!(m || {}).isImportant || C.isImportant) && (m = C);
      });
      var h = (m || {}).calculatedInPlaceValue || function() {
        var C = w;
        if (w) {
          var S = t.clone({ parent: t.parent, value: w });
          C = Fr(S, e, false, true).value;
        }
        return C;
      }();
      if (m !== undefined && !Zd(p, e).hasCircularOrSelfReference) {
        var g = Kd(t.parent.parent, true), y = g[0].slice(-1)[0], b = eh(y, m.decl.parent), v = th(m.decl, t.parent.parent, function(C) {
          return C === b;
        });
        h = Fr(v, e, false, true).value;
      }
      d = h === undefined, d && o.push(["variable " + c + " is undefined and used without a fallback", { node: t }]), s = (a.pre || "") + h + (a.post || "");
    }
    return { value: d ? undefined : s, variablesUsed: p, warnings: o };
  };
  Fr.RE_VAR_FUNC = rh;
  Ll.exports = Fr;
});
var Ul = k((sx, ql) => {
  var Nl = ui(), ih = Dt(), sh = ai(), Fl = ii(), ah = si(), qr = Lr(), oh = oi(), lh = li();
  function uh(t, e, r2, n) {
    t.forEach(function(i) {
      sh(t, e).deps.forEach(function(a) {
        var s;
        if (a.isUnderAtRule) {
          var o = ih(a.parent, true), l = o[0].slice(-1)[0], u = oh(l, r2.parent), f = a.parent.parent;
          s = lh(r2, f, function(m) {
            return m === u;
          });
        } else if (Fl.RE_PSEUDO_SELECTOR.test(a.parent.selector)) {
          var c = qr(r2.parent);
          c.parent = r2.parent.parent, s = r2.clone(), c.append(s);
          var p = a.parent.selector.match(new RegExp(Fl.RE_PSEUDO_SELECTOR.source + "$")), d = p ? p[2] : "";
          c.selector += d;
        }
        s && ah(s, a.parent, true) && n(s, a);
      });
    });
  }
  function fh(t, e, r2, n, i) {
    r2 = (typeof r2 == "function" ? r2(t) : r2) || false, n = n || false;
    var a = function(l) {
      return i && i(l), l;
    }, s = a(Nl(t, e)), o;
    uh(s.variablesUsed, e, t, function(l, u) {
      var f = qr(t.parent), c = t.clone();
      f.append(c);
      let p;
      if (typeof r2 == "function" ? p = r2(t) : p = r2, p === true && c.cloneAfter(), c.value = a(Nl(l, e, true)).value, u.isUnderAtRule) {
        var d = qr(u.parent.parent);
        d.append(f);
        for (var m = d, w = u.parent.parent;w.parent.type === "atrule"; ) {
          var h = qr(w.parent);
          h.append(m), m = h, w = w.parent;
        }
        t.parent.parent.insertAfter(n && o || t.parent, m), o = m;
      } else
        f.selector = l.parent.selector, t.parent.parent.insertAfter(n && o || t.parent, f);
    }), r2 === true && t.value !== s.value && t.cloneAfter(), s.value === undefined && (s.value = "undefined"), t.value = s.value;
  }
  ql.exports = fh;
});
var Vl = k((ax, fi) => {
  var $l = il(), ch = Lr(), jl = ui(), ph = Ul(), zl = /(--(.+))/;
  function dh(t, e) {
    t.walkDecls(function(r2) {
      zl.test(r2.prop) && e(r2);
    });
  }
  function hh(t) {
    for (var e = t;e && e.nodes.length <= 0; ) {
      var r2 = e.type !== "root" ? e : null;
      r2 ? (e = r2.parent, r2.remove()) : e = null;
    }
  }
  var mh = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  fi.exports = (t = {}) => {
    var e = $l({}, mh, t);
    return { postcssPlugin: "postcss-css-variables", Once(r2, { decl: n, result: i, rule: a }) {
      var s = [], o = [], l = {};
      l = $l(l, Object.keys(e.variables).reduce(function(c, p) {
        var d = e.variables[p];
        p = p.slice(0, 2) === "--" ? p : "--" + p;
        var m = (d || {}).value || d, w = (d || {}).isImportant || false, h = a({ selector: ":root" });
        r2.root().prepend(h);
        var g = n({ prop: p, value: m, important: w });
        return h.append(g), e.preserveInjectedVariables || o.push(g), c[p] = (c[p] || []).concat({ decl: g, prop: p, calculatedInPlaceValue: m, isImportant: w, variablesUsed: [], parent: h, isUnderAtRule: false }), c;
      }, {}));
      var u = function(c) {
        var p = [].concat(c.warnings);
        return p.forEach(function(d) {
          d = [].concat(d), i.warn.apply(i, d);
        }), c;
      };
      dh(r2, function(c) {
        var p = c.parent, d = u(jl(c, l));
        c.parent.selectors.forEach(function(w) {
          var h = ch(c.parent);
          h.selector = w, h.parent = c.parent.parent;
          var g = c.clone();
          h.append(g);
          var y = c.prop;
          l[y] = (l[y] || []).concat({ decl: g, prop: y, calculatedInPlaceValue: d.value, isImportant: c.important || false, variablesUsed: d.variablesUsed, parent: h, isUnderAtRule: h.parent.type === "atrule" });
        });
        let m;
        typeof e.preserve == "function" ? m = e.preserve(c) : m = e.preserve, m ? m === "computed" && (c.value = d.value) : c.remove(), p.nodes.length <= 0 && s.push(p);
      });
      var f = [];
      r2.walk(function(c) {
        if (c.nodes !== undefined) {
          var p = c.nodes.some(function(d) {
            if (d.type === "decl") {
              var m = d;
              if (jl.RE_VAR_FUNC.test(m.value) && !zl.test(m.prop))
                return true;
            }
            return false;
          });
          p && (c.type === "rule" && c.selectors.length > 1 ? (c.selectors.reverse().forEach(function(d) {
            var m = c.cloneAfter();
            return m.selector = d, m;
          }), c.remove()) : f.push(c));
        }
      }), f.forEach(function(c) {
        c.nodes.slice(0).forEach(function(p) {
          if (p.type === "decl") {
            var d = p;
            ph(d, l, e.preserve, e.preserveAtRulesOrder, u);
          }
        });
      }), s.forEach(hh), o.forEach(function(c) {
        c.remove();
      });
    } };
  };
  fi.exports.postcss = true;
});
var Bl = k((fx, Wl) => {
  var di = class {
    constructor(e = {}) {
      if (!(e.maxSize && e.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e.maxAge == "number" && e.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0;
    }
    _emitEvictions(e) {
      if (typeof this.onEviction == "function")
        for (let [r2, n] of e)
          this.onEviction(r2, n.value);
    }
    _deleteIfExpired(e, r2) {
      return typeof r2.expiry == "number" && r2.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, r2.value), this.delete(e)) : false;
    }
    _getOrDeleteIfExpired(e, r2) {
      if (this._deleteIfExpired(e, r2) === false)
        return r2.value;
    }
    _getItemValue(e, r2) {
      return r2.expiry ? this._getOrDeleteIfExpired(e, r2) : r2.value;
    }
    _peek(e, r2) {
      let n = r2.get(e);
      return this._getItemValue(e, n);
    }
    _set(e, r2) {
      this.cache.set(e, r2), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map);
    }
    _moveToRecent(e, r2) {
      this.oldCache.delete(e), this._set(e, r2);
    }
    *_entriesAscending() {
      for (let e of this.oldCache) {
        let [r2, n] = e;
        this.cache.has(r2) || this._deleteIfExpired(r2, n) === false && (yield e);
      }
      for (let e of this.cache) {
        let [r2, n] = e;
        this._deleteIfExpired(r2, n) === false && (yield e);
      }
    }
    get(e) {
      if (this.cache.has(e)) {
        let r2 = this.cache.get(e);
        return this._getItemValue(e, r2);
      }
      if (this.oldCache.has(e)) {
        let r2 = this.oldCache.get(e);
        if (this._deleteIfExpired(e, r2) === false)
          return this._moveToRecent(e, r2), r2.value;
      }
    }
    set(e, r2, { maxAge: n = this.maxAge === 1 / 0 ? undefined : Date.now() + this.maxAge } = {}) {
      this.cache.has(e) ? this.cache.set(e, { value: r2, maxAge: n }) : this._set(e, { value: r2, expiry: n });
    }
    has(e) {
      return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : false;
    }
    peek(e) {
      if (this.cache.has(e))
        return this._peek(e, this.cache);
      if (this.oldCache.has(e))
        return this._peek(e, this.oldCache);
    }
    delete(e) {
      let r2 = this.cache.delete(e);
      return r2 && this._size--, this.oldCache.delete(e) || r2;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e) {
      if (!(e && e > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      let r2 = [...this._entriesAscending()], n = r2.length - e;
      n < 0 ? (this.cache = new Map(r2), this.oldCache = new Map, this._size = r2.length) : (n > 0 && this._emitEvictions(r2.slice(0, n)), this.oldCache = new Map(r2.slice(n)), this.cache = new Map, this._size = 0), this.maxSize = e;
    }
    *keys() {
      for (let [e] of this)
        yield e;
    }
    *values() {
      for (let [, e] of this)
        yield e;
    }
    *[Symbol.iterator]() {
      for (let e of this.cache) {
        let [r2, n] = e;
        this._deleteIfExpired(r2, n) === false && (yield [r2, n.value]);
      }
      for (let e of this.oldCache) {
        let [r2, n] = e;
        this.cache.has(r2) || this._deleteIfExpired(r2, n) === false && (yield [r2, n.value]);
      }
    }
    *entriesDescending() {
      let e = [...this.cache];
      for (let r2 = e.length - 1;r2 >= 0; --r2) {
        let n = e[r2], [i, a] = n;
        this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
      e = [...this.oldCache];
      for (let r2 = e.length - 1;r2 >= 0; --r2) {
        let n = e[r2], [i, a] = n;
        this.cache.has(i) || this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
    }
    *entriesAscending() {
      for (let [e, r2] of this._entriesAscending())
        yield [e, r2.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e = 0;
      for (let r2 of this.oldCache.keys())
        this.cache.has(r2) || e++;
      return Math.min(this._size + e, this.maxSize);
    }
  };
  Wl.exports = di;
});
var jr = k(($r, Yl) => {
  $r.__esModule = true;
  $r.default = wh;
  function yh(t) {
    for (var e = t.toLowerCase(), r2 = "", n = false, i = 0;i < 6 && e[i] !== undefined; i++) {
      var a = e.charCodeAt(i), s = a >= 97 && a <= 102 || a >= 48 && a <= 57;
      if (n = a === 32, !s)
        break;
      r2 += e[i];
    }
    if (r2.length !== 0) {
      var o = parseInt(r2, 16), l = o >= 55296 && o <= 57343;
      return l || o === 0 || o > 1114111 ? ["\uFFFD", r2.length + (n ? 1 : 0)] : [String.fromCodePoint(o), r2.length + (n ? 1 : 0)];
    }
  }
  var vh = /\\/;
  function wh(t) {
    var e = vh.test(t);
    if (!e)
      return t;
    for (var r2 = "", n = 0;n < t.length; n++) {
      if (t[n] === "\\") {
        var i = yh(t.slice(n + 1, n + 7));
        if (i !== undefined) {
          r2 += i[0], n += i[1];
          continue;
        }
        if (t[n + 1] === "\\") {
          r2 += "\\", n++;
          continue;
        }
        t.length === n + 1 && (r2 += t[n]);
        continue;
      }
      r2 += t[n];
    }
    return r2;
  }
  Yl.exports = $r.default;
});
var Jl = k((zr, Ql) => {
  zr.__esModule = true;
  zr.default = bh;
  function bh(t) {
    for (var e = arguments.length, r2 = new Array(e > 1 ? e - 1 : 0), n = 1;n < e; n++)
      r2[n - 1] = arguments[n];
    for (;r2.length > 0; ) {
      var i = r2.shift();
      if (!t[i])
        return;
      t = t[i];
    }
    return t;
  }
  Ql.exports = zr.default;
});
var Kl = k((Vr, Xl) => {
  Vr.__esModule = true;
  Vr.default = xh;
  function xh(t) {
    for (var e = arguments.length, r2 = new Array(e > 1 ? e - 1 : 0), n = 1;n < e; n++)
      r2[n - 1] = arguments[n];
    for (;r2.length > 0; ) {
      var i = r2.shift();
      t[i] || (t[i] = {}), t = t[i];
    }
  }
  Xl.exports = Vr.default;
});
var eu = k((Wr, Zl) => {
  Wr.__esModule = true;
  Wr.default = Sh;
  function Sh(t) {
    for (var e = "", r2 = t.indexOf("/*"), n = 0;r2 >= 0; ) {
      e = e + t.slice(n, r2);
      var i = t.indexOf("*/", r2 + 2);
      if (i < 0)
        return e;
      n = i + 2, r2 = t.indexOf("/*", n);
    }
    return e = e + t.slice(n), e;
  }
  Zl.exports = Wr.default;
});
var Lt = k((ge) => {
  ge.__esModule = true;
  ge.unesc = ge.stripComments = ge.getProp = ge.ensureObject = undefined;
  var kh = Br(jr());
  ge.unesc = kh.default;
  var Eh = Br(Jl());
  ge.getProp = Eh.default;
  var Oh = Br(Kl());
  ge.ensureObject = Oh.default;
  var Ah = Br(eu());
  ge.stripComments = Ah.default;
  function Br(t) {
    return t && t.__esModule ? t : { default: t };
  }
});
var ke = k((Nt, nu) => {
  Nt.__esModule = true;
  Nt.default = undefined;
  var tu = Lt();
  function ru(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Ch(t, e, r2) {
    return e && ru(t.prototype, e), r2 && ru(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  var _h = function t(e, r2) {
    if (typeof e != "object" || e === null)
      return e;
    var n = new e.constructor;
    for (var i in e)
      if (e.hasOwnProperty(i)) {
        var a = e[i], s = typeof a;
        i === "parent" && s === "object" ? r2 && (n[i] = r2) : a instanceof Array ? n[i] = a.map(function(o) {
          return t(o, n);
        }) : n[i] = t(a, n);
      }
    return n;
  }, Th = function() {
    function t(r2) {
      r2 === undefined && (r2 = {}), Object.assign(this, r2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e = t.prototype;
    return e.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }, e.replaceWith = function() {
      if (this.parent) {
        for (var n in arguments)
          this.parent.insertBefore(this, arguments[n]);
        this.remove();
      }
      return this;
    }, e.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e.clone = function(n) {
      n === undefined && (n = {});
      var i = _h(this);
      for (var a in n)
        i[a] = n[a];
      return i;
    }, e.appendToPropertyAndEscape = function(n, i, a) {
      this.raws || (this.raws = {});
      var s = this[n], o = this.raws[n];
      this[n] = s + i, o || a !== i ? this.raws[n] = (o || s) + a : delete this.raws[n];
    }, e.setPropertyAndEscape = function(n, i, a) {
      this.raws || (this.raws = {}), this[n] = i, this.raws[n] = a;
    }, e.setPropertyWithoutEscape = function(n, i) {
      this[n] = i, this.raws && delete this.raws[n];
    }, e.isAtPosition = function(n, i) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n || this.source.end.line < n || this.source.start.line === n && this.source.start.column > i || this.source.end.line === n && this.source.end.column < i);
    }, e.stringifyProperty = function(n) {
      return this.raws && this.raws[n] || this[n];
    }, e.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, Ch(t, [{ key: "rawSpaceBefore", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n === undefined && (n = this.spaces && this.spaces.before), n || "";
    }, set: function(n) {
      (0, tu.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n;
    } }, { key: "rawSpaceAfter", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n === undefined && (n = this.spaces.after), n || "";
    }, set: function(n) {
      (0, tu.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n;
    } }]), t;
  }();
  Nt.default = Th;
  nu.exports = Nt.default;
});
var J = k(($) => {
  $.__esModule = true;
  $.UNIVERSAL = $.TAG = $.STRING = $.SELECTOR = $.ROOT = $.PSEUDO = $.NESTING = $.ID = $.COMMENT = $.COMBINATOR = $.CLASS = $.ATTRIBUTE = undefined;
  var Ph = "tag";
  $.TAG = Ph;
  var Ih = "string";
  $.STRING = Ih;
  var Rh = "selector";
  $.SELECTOR = Rh;
  var Dh = "root";
  $.ROOT = Dh;
  var Mh = "pseudo";
  $.PSEUDO = Mh;
  var Lh = "nesting";
  $.NESTING = Lh;
  var Nh = "id";
  $.ID = Nh;
  var Fh = "comment";
  $.COMMENT = Fh;
  var qh = "combinator";
  $.COMBINATOR = qh;
  var Uh = "class";
  $.CLASS = Uh;
  var $h = "attribute";
  $.ATTRIBUTE = $h;
  var jh = "universal";
  $.UNIVERSAL = jh;
});
var Gr = k((Ft, ou) => {
  Ft.__esModule = true;
  Ft.default = undefined;
  var zh = Wh(ke()), Ee = Vh(J());
  function au(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r2 = new WeakMap;
    return (au = function(i) {
      return i ? r2 : e;
    })(t);
  }
  function Vh(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r2 = au(e);
    if (r2 && r2.has(t))
      return r2.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r2 && r2.set(t, n), n;
  }
  function Wh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Bh(t, e) {
    var r2 = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r2)
      return (r2 = r2.call(t)).next.bind(r2);
    if (Array.isArray(t) || (r2 = Gh(t)) || e && t && typeof t.length == "number") {
      r2 && (t = r2);
      var n = 0;
      return function() {
        return n >= t.length ? { done: true } : { done: false, value: t[n++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function Gh(t, e) {
    if (t) {
      if (typeof t == "string")
        return iu(t, e);
      var r2 = Object.prototype.toString.call(t).slice(8, -1);
      if (r2 === "Object" && t.constructor && (r2 = t.constructor.name), r2 === "Map" || r2 === "Set")
        return Array.from(t);
      if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
        return iu(t, e);
    }
  }
  function iu(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r2 = 0, n = new Array(e);r2 < e; r2++)
      n[r2] = t[r2];
    return n;
  }
  function su(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Hh(t, e, r2) {
    return e && su(t.prototype, e), r2 && su(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function Yh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, yi(t, e);
  }
  function yi(t, e) {
    return yi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, yi(t, e);
  }
  var Qh = function(t) {
    Yh(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.nodes || (i.nodes = []), i;
    }
    var r2 = e.prototype;
    return r2.append = function(i) {
      return i.parent = this, this.nodes.push(i), this;
    }, r2.prepend = function(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }, r2.at = function(i) {
      return this.nodes[i];
    }, r2.index = function(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }, r2.removeChild = function(i) {
      i = this.index(i), this.at(i).parent = undefined, this.nodes.splice(i, 1);
      var a;
      for (var s in this.indexes)
        a = this.indexes[s], a >= i && (this.indexes[s] = a - 1);
      return this;
    }, r2.removeAll = function() {
      for (var i = Bh(this.nodes), a;!(a = i()).done; ) {
        var s = a.value;
        s.parent = undefined;
      }
      return this.nodes = [], this;
    }, r2.empty = function() {
      return this.removeAll();
    }, r2.insertAfter = function(i, a) {
      a.parent = this;
      var s = this.index(i);
      this.nodes.splice(s + 1, 0, a), a.parent = this;
      var o;
      for (var l in this.indexes)
        o = this.indexes[l], s <= o && (this.indexes[l] = o + 1);
      return this;
    }, r2.insertBefore = function(i, a) {
      a.parent = this;
      var s = this.index(i);
      this.nodes.splice(s, 0, a), a.parent = this;
      var o;
      for (var l in this.indexes)
        o = this.indexes[l], o <= s && (this.indexes[l] = o + 1);
      return this;
    }, r2._findChildAtPosition = function(i, a) {
      var s = undefined;
      return this.each(function(o) {
        if (o.atPosition) {
          var l = o.atPosition(i, a);
          if (l)
            return s = l, false;
        } else if (o.isAtPosition(i, a))
          return s = o, false;
      }), s;
    }, r2.atPosition = function(i, a) {
      if (this.isAtPosition(i, a))
        return this._findChildAtPosition(i, a) || this;
    }, r2._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r2.each = function(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var a = this.lastEach;
      if (this.indexes[a] = 0, !!this.length) {
        for (var s, o;this.indexes[a] < this.length && (s = this.indexes[a], o = i(this.at(s), s), o !== false); )
          this.indexes[a] += 1;
        if (delete this.indexes[a], o === false)
          return false;
      }
    }, r2.walk = function(i) {
      return this.each(function(a, s) {
        var o = i(a, s);
        if (o !== false && a.length && (o = a.walk(i)), o === false)
          return false;
      });
    }, r2.walkAttributes = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.ATTRIBUTE)
          return i.call(a, s);
      });
    }, r2.walkClasses = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.CLASS)
          return i.call(a, s);
      });
    }, r2.walkCombinators = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.COMBINATOR)
          return i.call(a, s);
      });
    }, r2.walkComments = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.COMMENT)
          return i.call(a, s);
      });
    }, r2.walkIds = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.ID)
          return i.call(a, s);
      });
    }, r2.walkNesting = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.NESTING)
          return i.call(a, s);
      });
    }, r2.walkPseudos = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.PSEUDO)
          return i.call(a, s);
      });
    }, r2.walkTags = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.TAG)
          return i.call(a, s);
      });
    }, r2.walkUniversals = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.UNIVERSAL)
          return i.call(a, s);
      });
    }, r2.split = function(i) {
      var a = this, s = [];
      return this.reduce(function(o, l, u) {
        var f = i.call(a, l);
        return s.push(l), f ? (o.push(s), s = []) : u === a.length - 1 && o.push(s), o;
      }, []);
    }, r2.map = function(i) {
      return this.nodes.map(i);
    }, r2.reduce = function(i, a) {
      return this.nodes.reduce(i, a);
    }, r2.every = function(i) {
      return this.nodes.every(i);
    }, r2.some = function(i) {
      return this.nodes.some(i);
    }, r2.filter = function(i) {
      return this.nodes.filter(i);
    }, r2.sort = function(i) {
      return this.nodes.sort(i);
    }, r2.toString = function() {
      return this.map(String).join("");
    }, Hh(e, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e;
  }(zh.default);
  Ft.default = Qh;
  ou.exports = Ft.default;
});
var wi = k((qt, uu) => {
  qt.__esModule = true;
  qt.default = undefined;
  var Jh = Kh(Gr()), Xh = J();
  function Kh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function lu(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Zh(t, e, r2) {
    return e && lu(t.prototype, e), r2 && lu(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function em(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, vi(t, e);
  }
  function vi(t, e) {
    return vi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, vi(t, e);
  }
  var tm = function(t) {
    em(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = Xh.ROOT, i;
    }
    var r2 = e.prototype;
    return r2.toString = function() {
      var i = this.reduce(function(a, s) {
        return a.push(String(s)), a;
      }, []).join(",");
      return this.trailingComma ? i + "," : i;
    }, r2.error = function(i, a) {
      return this._error ? this._error(i, a) : new Error(i);
    }, Zh(e, [{ key: "errorGenerator", set: function(i) {
      this._error = i;
    } }]), e;
  }(Jh.default);
  qt.default = tm;
  uu.exports = qt.default;
});
var xi = k((Ut, fu) => {
  Ut.__esModule = true;
  Ut.default = undefined;
  var rm = im(Gr()), nm = J();
  function im(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function sm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, bi(t, e);
  }
  function bi(t, e) {
    return bi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, bi(t, e);
  }
  var am = function(t) {
    sm(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = nm.SELECTOR, n;
    }
    return e;
  }(rm.default);
  Ut.default = am;
  fu.exports = Ut.default;
});
var Hr = k((mx, cu) => {
  var om = {}, lm = om.hasOwnProperty, um = function(e, r2) {
    if (!e)
      return r2;
    var n = {};
    for (var i in r2)
      n[i] = lm.call(e, i) ? e[i] : r2[i];
    return n;
  }, fm = /[ -,\.\/:-@\[-\^`\{-~]/, cm = /[ -,\.\/:-@\[\]\^`\{-~]/, pm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Si = function t(e, r2) {
    r2 = um(r2, t.options), r2.quotes != "single" && r2.quotes != "double" && (r2.quotes = "single");
    for (var n = r2.quotes == "double" ? '"' : "'", i = r2.isIdentifier, a = e.charAt(0), s = "", o = 0, l = e.length;o < l; ) {
      var u = e.charAt(o++), f = u.charCodeAt(), c = undefined;
      if (f < 32 || f > 126) {
        if (f >= 55296 && f <= 56319 && o < l) {
          var p = e.charCodeAt(o++);
          (p & 64512) == 56320 ? f = ((f & 1023) << 10) + (p & 1023) + 65536 : o--;
        }
        c = "\\" + f.toString(16).toUpperCase() + " ";
      } else
        r2.escapeEverything ? fm.test(u) ? c = "\\" + u : c = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u) ? c = "\\" + f.toString(16).toUpperCase() + " " : u == "\\" || !i && (u == '"' && n == u || u == "'" && n == u) || i && cm.test(u) ? c = "\\" + u : c = u;
      s += c;
    }
    return i && (/^-[-\d]/.test(s) ? s = "\\-" + s.slice(1) : /\d/.test(a) && (s = "\\3" + a + " " + s.slice(1))), s = s.replace(pm, function(d, m, w) {
      return m && m.length % 2 ? d : (m || "") + w;
    }), !i && r2.wrap ? n + s + n : s;
  };
  Si.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Si.version = "3.0.0";
  cu.exports = Si;
});
var Ei = k(($t, hu) => {
  $t.__esModule = true;
  $t.default = undefined;
  var dm = du(Hr()), hm = Lt(), mm = du(ke()), gm = J();
  function du(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function pu(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function ym(t, e, r2) {
    return e && pu(t.prototype, e), r2 && pu(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function vm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, ki(t, e);
  }
  function ki(t, e) {
    return ki = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, ki(t, e);
  }
  var wm = function(t) {
    vm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = gm.CLASS, i._constructed = true, i;
    }
    var r2 = e.prototype;
    return r2.valueToString = function() {
      return "." + t.prototype.valueToString.call(this);
    }, ym(e, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = (0, dm.default)(i, { isIdentifier: true });
        a !== i ? ((0, hm.ensureObject)(this, "raws"), this.raws.value = a) : this.raws && delete this.raws.value;
      }
      this._value = i;
    } }]), e;
  }(mm.default);
  $t.default = wm;
  hu.exports = $t.default;
});
var Ai = k((jt, mu) => {
  jt.__esModule = true;
  jt.default = undefined;
  var bm = Sm(ke()), xm = J();
  function Sm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function km(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Oi(t, e);
  }
  function Oi(t, e) {
    return Oi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Oi(t, e);
  }
  var Em = function(t) {
    km(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = xm.COMMENT, n;
    }
    return e;
  }(bm.default);
  jt.default = Em;
  mu.exports = jt.default;
});
var _i = k((zt, gu) => {
  zt.__esModule = true;
  zt.default = undefined;
  var Om = Cm(ke()), Am = J();
  function Cm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function _m(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ci(t, e);
  }
  function Ci(t, e) {
    return Ci = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ci(t, e);
  }
  var Tm = function(t) {
    _m(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = Am.ID, i;
    }
    var r2 = e.prototype;
    return r2.valueToString = function() {
      return "#" + t.prototype.valueToString.call(this);
    }, e;
  }(Om.default);
  zt.default = Tm;
  gu.exports = zt.default;
});
var Yr = k((Vt, wu) => {
  Vt.__esModule = true;
  Vt.default = undefined;
  var Pm = vu(Hr()), Im = Lt(), Rm = vu(ke());
  function vu(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function yu(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Dm(t, e, r2) {
    return e && yu(t.prototype, e), r2 && yu(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function Mm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ti(t, e);
  }
  function Ti(t, e) {
    return Ti = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ti(t, e);
  }
  var Lm = function(t) {
    Mm(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    var r2 = e.prototype;
    return r2.qualifiedName = function(i) {
      return this.namespace ? this.namespaceString + "|" + i : i;
    }, r2.valueToString = function() {
      return this.qualifiedName(t.prototype.valueToString.call(this));
    }, Dm(e, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i) {
      if (i === true || i === "*" || i === "&") {
        this._namespace = i, this.raws && delete this.raws.namespace;
        return;
      }
      var a = (0, Pm.default)(i, { isIdentifier: true });
      this._namespace = i, a !== i ? ((0, Im.ensureObject)(this, "raws"), this.raws.namespace = a) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i) {
      this.namespace = i;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i = this.stringifyProperty("namespace");
        return i === true ? "" : i;
      } else
        return "";
    } }]), e;
  }(Rm.default);
  Vt.default = Lm;
  wu.exports = Vt.default;
});
var Ii = k((Wt, bu) => {
  Wt.__esModule = true;
  Wt.default = undefined;
  var Nm = qm(Yr()), Fm = J();
  function qm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Um(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Pi(t, e);
  }
  function Pi(t, e) {
    return Pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Pi(t, e);
  }
  var $m = function(t) {
    Um(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = Fm.TAG, n;
    }
    return e;
  }(Nm.default);
  Wt.default = $m;
  bu.exports = Wt.default;
});
var Di = k((Bt, xu) => {
  Bt.__esModule = true;
  Bt.default = undefined;
  var jm = Vm(ke()), zm = J();
  function Vm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Wm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ri(t, e);
  }
  function Ri(t, e) {
    return Ri = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ri(t, e);
  }
  var Bm = function(t) {
    Wm(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = zm.STRING, n;
    }
    return e;
  }(jm.default);
  Bt.default = Bm;
  xu.exports = Bt.default;
});
var Li = k((Gt, Su) => {
  Gt.__esModule = true;
  Gt.default = undefined;
  var Gm = Ym(Gr()), Hm = J();
  function Ym(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Qm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Mi(t, e);
  }
  function Mi(t, e) {
    return Mi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Mi(t, e);
  }
  var Jm = function(t) {
    Qm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = Hm.PSEUDO, i;
    }
    var r2 = e.prototype;
    return r2.toString = function() {
      var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i, this.rawSpaceAfter].join("");
    }, e;
  }(Gm.default);
  Gt.default = Jm;
  Su.exports = Gt.default;
});
var Eu = k((gx, ku) => {
  ku.exports = Xm;
  function Xm(t, e) {
    if (Ni("noDeprecation"))
      return t;
    var r2 = false;
    function n() {
      if (!r2) {
        if (Ni("throwDeprecation"))
          throw new Error(e);
        Ni("traceDeprecation") ? console.trace(e) : console.warn(e), r2 = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function Ni(t) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = global.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var zi = k((Qt) => {
  Qt.__esModule = true;
  Qt.default = undefined;
  Qt.unescapeValue = ji;
  var Ht = $i(Hr()), Km = $i(jr()), Zm = $i(Yr()), eg = J(), Fi;
  function $i(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Ou(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function tg(t, e, r2) {
    return e && Ou(t.prototype, e), r2 && Ou(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function rg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ui(t, e);
  }
  function Ui(t, e) {
    return Ui = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ui(t, e);
  }
  var Yt = Eu(), ng = /^('|")([^]*)\1$/, ig = Yt(function() {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), sg = Yt(function() {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), ag = Yt(function() {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function ji(t) {
    var e = false, r2 = null, n = t, i = n.match(ng);
    return i && (r2 = i[1], n = i[2]), n = (0, Km.default)(n), n !== t && (e = true), { deprecatedUsage: e, unescaped: n, quoteMark: r2 };
  }
  function og(t) {
    if (t.quoteMark !== undefined || t.value === undefined)
      return t;
    ag();
    var e = ji(t.value), r2 = e.quoteMark, n = e.unescaped;
    return t.raws || (t.raws = {}), t.raws.value === undefined && (t.raws.value = t.value), t.value = n, t.quoteMark = r2, t;
  }
  var Qr = function(t) {
    rg(e, t);
    function e(n) {
      var i;
      return n === undefined && (n = {}), i = t.call(this, og(n)) || this, i.type = eg.ATTRIBUTE, i.raws = i.raws || {}, Object.defineProperty(i.raws, "unquoted", { get: Yt(function() {
        return i.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Yt(function() {
        return i.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i._constructed = true, i;
    }
    var r2 = e.prototype;
    return r2.getQuotedValue = function(i) {
      i === undefined && (i = {});
      var a = this._determineQuoteMark(i), s = qi[a], o = (0, Ht.default)(this._value, s);
      return o;
    }, r2._determineQuoteMark = function(i) {
      return i.smart ? this.smartQuoteMark(i) : this.preferredQuoteMark(i);
    }, r2.setValue = function(i, a) {
      a === undefined && (a = {}), this._value = i, this._quoteMark = this._determineQuoteMark(a), this._syncRawValue();
    }, r2.smartQuoteMark = function(i) {
      var a = this.value, s = a.replace(/[^']/g, "").length, o = a.replace(/[^"]/g, "").length;
      if (s + o === 0) {
        var l = (0, Ht.default)(a, { isIdentifier: true });
        if (l === a)
          return e.NO_QUOTE;
        var u = this.preferredQuoteMark(i);
        if (u === e.NO_QUOTE) {
          var f = this.quoteMark || i.quoteMark || e.DOUBLE_QUOTE, c = qi[f], p = (0, Ht.default)(a, c);
          if (p.length < l.length)
            return f;
        }
        return u;
      } else
        return o === s ? this.preferredQuoteMark(i) : o < s ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE;
    }, r2.preferredQuoteMark = function(i) {
      var a = i.preferCurrentQuoteMark ? this.quoteMark : i.quoteMark;
      return a === undefined && (a = i.preferCurrentQuoteMark ? i.quoteMark : this.quoteMark), a === undefined && (a = e.DOUBLE_QUOTE), a;
    }, r2._syncRawValue = function() {
      var i = (0, Ht.default)(this._value, qi[this.quoteMark]);
      i === this._value ? this.raws && delete this.raws.value : this.raws.value = i;
    }, r2._handleEscapes = function(i, a) {
      if (this._constructed) {
        var s = (0, Ht.default)(a, { isIdentifier: true });
        s !== a ? this.raws[i] = s : delete this.raws[i];
      }
    }, r2._spacesFor = function(i) {
      var a = { before: "", after: "" }, s = this.spaces[i] || {}, o = this.raws.spaces && this.raws.spaces[i] || {};
      return Object.assign(a, s, o);
    }, r2._stringFor = function(i, a, s) {
      a === undefined && (a = i), s === undefined && (s = Au);
      var o = this._spacesFor(a);
      return s(this.stringifyProperty(i), o);
    }, r2.offsetOf = function(i) {
      var a = 1, s = this._spacesFor("attribute");
      if (a += s.before.length, i === "namespace" || i === "ns")
        return this.namespace ? a : -1;
      if (i === "attributeNS" || (a += this.namespaceString.length, this.namespace && (a += 1), i === "attribute"))
        return a;
      a += this.stringifyProperty("attribute").length, a += s.after.length;
      var o = this._spacesFor("operator");
      a += o.before.length;
      var l = this.stringifyProperty("operator");
      if (i === "operator")
        return l ? a : -1;
      a += l.length, a += o.after.length;
      var u = this._spacesFor("value");
      a += u.before.length;
      var f = this.stringifyProperty("value");
      if (i === "value")
        return f ? a : -1;
      a += f.length, a += u.after.length;
      var c = this._spacesFor("insensitive");
      return a += c.before.length, i === "insensitive" && this.insensitive ? a : -1;
    }, r2.toString = function() {
      var i = this, a = [this.rawSpaceBefore, "["];
      return a.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a.push(this._stringFor("operator")), a.push(this._stringFor("value")), a.push(this._stringFor("insensitiveFlag", "insensitive", function(s, o) {
        return s.length > 0 && !i.quoted && o.before.length === 0 && !(i.spaces.value && i.spaces.value.after) && (o.before = " "), Au(s, o);
      }))), a.push("]"), a.push(this.rawSpaceAfter), a.join("");
    }, tg(e, [{ key: "quoted", get: function() {
      var i = this.quoteMark;
      return i === "'" || i === '"';
    }, set: function(i) {
      sg();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i) {
      if (!this._constructed) {
        this._quoteMark = i;
        return;
      }
      this._quoteMark !== i && (this._quoteMark = i, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = ji(i), s = a.deprecatedUsage, o = a.unescaped, l = a.quoteMark;
        if (s && ig(), o === this._value && l === this._quoteMark)
          return;
        this._value = o, this._quoteMark = l, this._syncRawValue();
      } else
        this._value = i;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i) {
      i || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = undefined)), this._insensitive = i;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i) {
      this._handleEscapes("attribute", i), this._attribute = i;
    } }]), e;
  }(Zm.default);
  Qt.default = Qr;
  Qr.NO_QUOTE = null;
  Qr.SINGLE_QUOTE = "'";
  Qr.DOUBLE_QUOTE = '"';
  var qi = (Fi = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Fi[null] = { isIdentifier: true }, Fi);
  function Au(t, e) {
    return "" + e.before + t + e.after;
  }
});
var Wi = k((Jt, Cu) => {
  Jt.__esModule = true;
  Jt.default = undefined;
  var lg = fg(Yr()), ug = J();
  function fg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function cg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Vi(t, e);
  }
  function Vi(t, e) {
    return Vi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Vi(t, e);
  }
  var pg = function(t) {
    cg(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = ug.UNIVERSAL, n.value = "*", n;
    }
    return e;
  }(lg.default);
  Jt.default = pg;
  Cu.exports = Jt.default;
});
var Gi = k((Xt, _u) => {
  Xt.__esModule = true;
  Xt.default = undefined;
  var dg = mg(ke()), hg = J();
  function mg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function gg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Bi(t, e);
  }
  function Bi(t, e) {
    return Bi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Bi(t, e);
  }
  var yg = function(t) {
    gg(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = hg.COMBINATOR, n;
    }
    return e;
  }(dg.default);
  Xt.default = yg;
  _u.exports = Xt.default;
});
var Yi = k((Kt, Tu) => {
  Kt.__esModule = true;
  Kt.default = undefined;
  var vg = bg(ke()), wg = J();
  function bg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function xg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Hi(t, e);
  }
  function Hi(t, e) {
    return Hi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Hi(t, e);
  }
  var Sg = function(t) {
    xg(e, t);
    function e(r2) {
      var n;
      return n = t.call(this, r2) || this, n.type = wg.NESTING, n.value = "&", n;
    }
    return e;
  }(vg.default);
  Kt.default = Sg;
  Tu.exports = Kt.default;
});
var Iu = k((Jr, Pu) => {
  Jr.__esModule = true;
  Jr.default = kg;
  function kg(t) {
    return t.sort(function(e, r2) {
      return e - r2;
    });
  }
  Pu.exports = Jr.default;
});
var Qi = k((P) => {
  P.__esModule = true;
  P.word = P.tilde = P.tab = P.str = P.space = P.slash = P.singleQuote = P.semicolon = P.plus = P.pipe = P.openSquare = P.openParenthesis = P.newline = P.greaterThan = P.feed = P.equals = P.doubleQuote = P.dollar = P.cr = P.comment = P.comma = P.combinator = P.colon = P.closeSquare = P.closeParenthesis = P.caret = P.bang = P.backslash = P.at = P.asterisk = P.ampersand = undefined;
  var Eg = 38;
  P.ampersand = Eg;
  var Og = 42;
  P.asterisk = Og;
  var Ag = 64;
  P.at = Ag;
  var Cg = 44;
  P.comma = Cg;
  var _g = 58;
  P.colon = _g;
  var Tg = 59;
  P.semicolon = Tg;
  var Pg = 40;
  P.openParenthesis = Pg;
  var Ig = 41;
  P.closeParenthesis = Ig;
  var Rg = 91;
  P.openSquare = Rg;
  var Dg = 93;
  P.closeSquare = Dg;
  var Mg = 36;
  P.dollar = Mg;
  var Lg = 126;
  P.tilde = Lg;
  var Ng = 94;
  P.caret = Ng;
  var Fg = 43;
  P.plus = Fg;
  var qg = 61;
  P.equals = qg;
  var Ug = 124;
  P.pipe = Ug;
  var $g = 62;
  P.greaterThan = $g;
  var jg = 32;
  P.space = jg;
  var Ru = 39;
  P.singleQuote = Ru;
  var zg = 34;
  P.doubleQuote = zg;
  var Vg = 47;
  P.slash = Vg;
  var Wg = 33;
  P.bang = Wg;
  var Bg = 92;
  P.backslash = Bg;
  var Gg = 13;
  P.cr = Gg;
  var Hg = 12;
  P.feed = Hg;
  var Yg = 10;
  P.newline = Yg;
  var Qg = 9;
  P.tab = Qg;
  var Jg = Ru;
  P.str = Jg;
  var Xg = -1;
  P.comment = Xg;
  var Kg = -2;
  P.word = Kg;
  var Zg = -3;
  P.combinator = Zg;
});
var Lu = k((Zt) => {
  Zt.__esModule = true;
  Zt.FIELDS = undefined;
  Zt.default = ay;
  var A = ey(Qi()), Ze, q;
  function Mu(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r2 = new WeakMap;
    return (Mu = function(i) {
      return i ? r2 : e;
    })(t);
  }
  function ey(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r2 = Mu(e);
    if (r2 && r2.has(t))
      return r2.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r2 && r2.set(t, n), n;
  }
  var ty = (Ze = {}, Ze[A.tab] = true, Ze[A.newline] = true, Ze[A.cr] = true, Ze[A.feed] = true, Ze), ry = (q = {}, q[A.space] = true, q[A.tab] = true, q[A.newline] = true, q[A.cr] = true, q[A.feed] = true, q[A.ampersand] = true, q[A.asterisk] = true, q[A.bang] = true, q[A.comma] = true, q[A.colon] = true, q[A.semicolon] = true, q[A.openParenthesis] = true, q[A.closeParenthesis] = true, q[A.openSquare] = true, q[A.closeSquare] = true, q[A.singleQuote] = true, q[A.doubleQuote] = true, q[A.plus] = true, q[A.pipe] = true, q[A.tilde] = true, q[A.greaterThan] = true, q[A.equals] = true, q[A.dollar] = true, q[A.caret] = true, q[A.slash] = true, q), Ji = {}, Du = "0123456789abcdefABCDEF";
  for (Xr = 0;Xr < Du.length; Xr++)
    Ji[Du.charCodeAt(Xr)] = true;
  var Xr;
  function ny(t, e) {
    var r2 = e, n;
    do {
      if (n = t.charCodeAt(r2), ry[n])
        return r2 - 1;
      n === A.backslash ? r2 = iy(t, r2) + 1 : r2++;
    } while (r2 < t.length);
    return r2 - 1;
  }
  function iy(t, e) {
    var r2 = e, n = t.charCodeAt(r2 + 1);
    if (!ty[n])
      if (Ji[n]) {
        var i = 0;
        do
          r2++, i++, n = t.charCodeAt(r2 + 1);
        while (Ji[n] && i < 6);
        i < 6 && n === A.space && r2++;
      } else
        r2++;
    return r2;
  }
  var sy = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt.FIELDS = sy;
  function ay(t) {
    var e = [], r2 = t.css.valueOf(), n = r2, i = n.length, a = -1, s = 1, o = 0, l = 0, u, f, c, p, d, m, w, h, g, y, b, v, O;
    function x(C, S) {
      if (t.safe)
        r2 += S, g = r2.length - 1;
      else
        throw t.error("Unclosed " + C, s, o - a, o);
    }
    for (;o < i; ) {
      switch (u = r2.charCodeAt(o), u === A.newline && (a = o, s += 1), u) {
        case A.space:
        case A.tab:
        case A.newline:
        case A.cr:
        case A.feed:
          g = o;
          do
            g += 1, u = r2.charCodeAt(g), u === A.newline && (a = g, s += 1);
          while (u === A.space || u === A.newline || u === A.tab || u === A.cr || u === A.feed);
          O = A.space, p = s, c = g - a - 1, l = g;
          break;
        case A.plus:
        case A.greaterThan:
        case A.tilde:
        case A.pipe:
          g = o;
          do
            g += 1, u = r2.charCodeAt(g);
          while (u === A.plus || u === A.greaterThan || u === A.tilde || u === A.pipe);
          O = A.combinator, p = s, c = o - a, l = g;
          break;
        case A.asterisk:
        case A.ampersand:
        case A.bang:
        case A.comma:
        case A.equals:
        case A.dollar:
        case A.caret:
        case A.openSquare:
        case A.closeSquare:
        case A.colon:
        case A.semicolon:
        case A.openParenthesis:
        case A.closeParenthesis:
          g = o, O = u, p = s, c = o - a, l = g + 1;
          break;
        case A.singleQuote:
        case A.doubleQuote:
          v = u === A.singleQuote ? "'" : '"', g = o;
          do
            for (d = false, g = r2.indexOf(v, g + 1), g === -1 && x("quote", v), m = g;r2.charCodeAt(m - 1) === A.backslash; )
              m -= 1, d = !d;
          while (d);
          O = A.str, p = s, c = o - a, l = g + 1;
          break;
        default:
          u === A.slash && r2.charCodeAt(o + 1) === A.asterisk ? (g = r2.indexOf("*/", o + 2) + 1, g === 0 && x("comment", "*/"), f = r2.slice(o, g + 1), h = f.split(`
`), w = h.length - 1, w > 0 ? (y = s + w, b = g - h[w].length) : (y = s, b = a), O = A.comment, s = y, p = y, c = g - b) : u === A.slash ? (g = o, O = u, p = s, c = o - a, l = g + 1) : (g = ny(r2, o), O = A.word, p = s, c = g - a), l = g + 1;
          break;
      }
      e.push([O, s, o - a, p, c, o, l]), b && (a = b, b = null), o = l;
    }
    return e;
  }
});
var Vu = k((er, zu) => {
  er.__esModule = true;
  er.default = undefined;
  var oy = le(wi()), Xi = le(xi()), ly = le(Ei()), Nu = le(Ai()), uy = le(_i()), fy = le(Ii()), Ki = le(Di()), cy = le(Li()), Fu = Kr(zi()), py = le(Wi()), Zi = le(Gi()), dy = le(Yi()), hy = le(Iu()), E = Kr(Lu()), _ = Kr(Qi()), my = Kr(J()), V = Lt(), ze, es;
  function ju(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r2 = new WeakMap;
    return (ju = function(i) {
      return i ? r2 : e;
    })(t);
  }
  function Kr(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r2 = ju(e);
    if (r2 && r2.has(t))
      return r2.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r2 && r2.set(t, n), n;
  }
  function le(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function qu(t, e) {
    for (var r2 = 0;r2 < e.length; r2++) {
      var n = e[r2];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function gy(t, e, r2) {
    return e && qu(t.prototype, e), r2 && qu(t, r2), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  var ns = (ze = {}, ze[_.space] = true, ze[_.cr] = true, ze[_.feed] = true, ze[_.newline] = true, ze[_.tab] = true, ze), yy = Object.assign({}, ns, (es = {}, es[_.comment] = true, es));
  function Uu(t) {
    return { line: t[E.FIELDS.START_LINE], column: t[E.FIELDS.START_COL] };
  }
  function $u(t) {
    return { line: t[E.FIELDS.END_LINE], column: t[E.FIELDS.END_COL] };
  }
  function Ve(t, e, r2, n) {
    return { start: { line: t, column: e }, end: { line: r2, column: n } };
  }
  function et(t) {
    return Ve(t[E.FIELDS.START_LINE], t[E.FIELDS.START_COL], t[E.FIELDS.END_LINE], t[E.FIELDS.END_COL]);
  }
  function ts(t, e) {
    if (t)
      return Ve(t[E.FIELDS.START_LINE], t[E.FIELDS.START_COL], e[E.FIELDS.END_LINE], e[E.FIELDS.END_COL]);
  }
  function tt(t, e) {
    var r2 = t[e];
    if (typeof r2 == "string")
      return r2.indexOf("\\") !== -1 && ((0, V.ensureObject)(t, "raws"), t[e] = (0, V.unesc)(r2), t.raws[e] === undefined && (t.raws[e] = r2)), t;
  }
  function rs(t, e) {
    for (var r2 = -1, n = [];(r2 = t.indexOf(e, r2 + 1)) !== -1; )
      n.push(r2);
    return n;
  }
  function vy() {
    var t = Array.prototype.concat.apply([], arguments);
    return t.filter(function(e, r2) {
      return r2 === t.indexOf(e);
    });
  }
  var wy = function() {
    function t(r2, n) {
      n === undefined && (n = {}), this.rule = r2, this.options = Object.assign({ lossy: false, safe: false }, n), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, E.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i = ts(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new oy.default({ source: i }), this.root.errorGenerator = this._errorGenerator();
      var a = new Xi.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(a), this.current = a, this.loop();
    }
    var e = t.prototype;
    return e._errorGenerator = function() {
      var n = this;
      return function(i, a) {
        return typeof n.rule == "string" ? new Error(i) : n.rule.error(i, a);
      };
    }, e.attribute = function() {
      var n = [], i = this.currToken;
      for (this.position++;this.position < this.tokens.length && this.currToken[E.FIELDS.TYPE] !== _.closeSquare; )
        n.push(this.currToken), this.position++;
      if (this.currToken[E.FIELDS.TYPE] !== _.closeSquare)
        return this.expected("closing square bracket", this.currToken[E.FIELDS.START_POS]);
      var a = n.length, s = { source: Ve(i[1], i[2], this.currToken[3], this.currToken[4]), sourceIndex: i[E.FIELDS.START_POS] };
      if (a === 1 && !~[_.word].indexOf(n[0][E.FIELDS.TYPE]))
        return this.expected("attribute", n[0][E.FIELDS.START_POS]);
      for (var o = 0, l = "", u = "", f = null, c = false;o < a; ) {
        var p = n[o], d = this.content(p), m = n[o + 1];
        switch (p[E.FIELDS.TYPE]) {
          case _.space:
            if (c = true, this.options.lossy)
              break;
            if (f) {
              (0, V.ensureObject)(s, "spaces", f);
              var w = s.spaces[f].after || "";
              s.spaces[f].after = w + d;
              var h = (0, V.getProp)(s, "raws", "spaces", f, "after") || null;
              h && (s.raws.spaces[f].after = h + d);
            } else
              l = l + d, u = u + d;
            break;
          case _.asterisk:
            if (m[E.FIELDS.TYPE] === _.equals)
              s.operator = d, f = "operator";
            else if ((!s.namespace || f === "namespace" && !c) && m) {
              l && ((0, V.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = l, u = ""), s.namespace = (s.namespace || "") + d;
              var g = (0, V.getProp)(s, "raws", "namespace") || null;
              g && (s.raws.namespace += d), f = "namespace";
            }
            c = false;
            break;
          case _.dollar:
            if (f === "value") {
              var y = (0, V.getProp)(s, "raws", "value");
              s.value += "$", y && (s.raws.value = y + "$");
              break;
            }
          case _.caret:
            m[E.FIELDS.TYPE] === _.equals && (s.operator = d, f = "operator"), c = false;
            break;
          case _.combinator:
            if (d === "~" && m[E.FIELDS.TYPE] === _.equals && (s.operator = d, f = "operator"), d !== "|") {
              c = false;
              break;
            }
            m[E.FIELDS.TYPE] === _.equals ? (s.operator = d, f = "operator") : !s.namespace && !s.attribute && (s.namespace = true), c = false;
            break;
          case _.word:
            if (m && this.content(m) === "|" && n[o + 2] && n[o + 2][E.FIELDS.TYPE] !== _.equals && !s.operator && !s.namespace)
              s.namespace = d, f = "namespace";
            else if (!s.attribute || f === "attribute" && !c) {
              l && ((0, V.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = u, u = ""), s.attribute = (s.attribute || "") + d;
              var b = (0, V.getProp)(s, "raws", "attribute") || null;
              b && (s.raws.attribute += d), f = "attribute";
            } else if (!s.value && s.value !== "" || f === "value" && !(c || s.quoteMark)) {
              var v = (0, V.unesc)(d), O = (0, V.getProp)(s, "raws", "value") || "", x = s.value || "";
              s.value = x + v, s.quoteMark = null, (v !== d || O) && ((0, V.ensureObject)(s, "raws"), s.raws.value = (O || x) + d), f = "value";
            } else {
              var C = d === "i" || d === "I";
              (s.value || s.value === "") && (s.quoteMark || c) ? (s.insensitive = C, (!C || d === "I") && ((0, V.ensureObject)(s, "raws"), s.raws.insensitiveFlag = d), f = "insensitive", l && ((0, V.ensureObject)(s, "spaces", "insensitive"), s.spaces.insensitive.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "insensitive"), s.raws.spaces.insensitive.before = u, u = "")) : (s.value || s.value === "") && (f = "value", s.value += d, s.raws.value && (s.raws.value += d));
            }
            c = false;
            break;
          case _.str:
            if (!s.attribute || !s.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: p[E.FIELDS.START_POS] });
            var S = (0, Fu.unescapeValue)(d), I = S.unescaped, R = S.quoteMark;
            s.value = I, s.quoteMark = R, f = "value", (0, V.ensureObject)(s, "raws"), s.raws.value = d, c = false;
            break;
          case _.equals:
            if (!s.attribute)
              return this.expected("attribute", p[E.FIELDS.START_POS], d);
            if (s.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: p[E.FIELDS.START_POS] });
            s.operator = s.operator ? s.operator + d : d, f = "operator", c = false;
            break;
          case _.comment:
            if (f)
              if (c || m && m[E.FIELDS.TYPE] === _.space || f === "insensitive") {
                var B = (0, V.getProp)(s, "spaces", f, "after") || "", ne = (0, V.getProp)(s, "raws", "spaces", f, "after") || B;
                (0, V.ensureObject)(s, "raws", "spaces", f), s.raws.spaces[f].after = ne + d;
              } else {
                var G = s[f] || "", qe = (0, V.getProp)(s, "raws", f) || G;
                (0, V.ensureObject)(s, "raws"), s.raws[f] = qe + d;
              }
            else
              u = u + d;
            break;
          default:
            return this.error('Unexpected "' + d + '" found.', { index: p[E.FIELDS.START_POS] });
        }
        o++;
      }
      tt(s, "attribute"), tt(s, "namespace"), this.newNode(new Fu.default(s)), this.position++;
    }, e.parseWhitespaceEquivalentTokens = function(n) {
      n < 0 && (n = this.tokens.length);
      var i = this.position, a = [], s = "", o = undefined;
      do
        if (ns[this.currToken[E.FIELDS.TYPE]])
          this.options.lossy || (s += this.content());
        else if (this.currToken[E.FIELDS.TYPE] === _.comment) {
          var l = {};
          s && (l.before = s, s = ""), o = new Nu.default({ value: this.content(), source: et(this.currToken), sourceIndex: this.currToken[E.FIELDS.START_POS], spaces: l }), a.push(o);
        }
      while (++this.position < n);
      if (s) {
        if (o)
          o.spaces.after = s;
        else if (!this.options.lossy) {
          var u = this.tokens[i], f = this.tokens[this.position - 1];
          a.push(new Ki.default({ value: "", source: Ve(u[E.FIELDS.START_LINE], u[E.FIELDS.START_COL], f[E.FIELDS.END_LINE], f[E.FIELDS.END_COL]), sourceIndex: u[E.FIELDS.START_POS], spaces: { before: s, after: "" } }));
        }
      }
      return a;
    }, e.convertWhitespaceNodesToSpace = function(n, i) {
      var a = this;
      i === undefined && (i = false);
      var s = "", o = "";
      n.forEach(function(u) {
        var f = a.lossySpace(u.spaces.before, i), c = a.lossySpace(u.rawSpaceBefore, i);
        s += f + a.lossySpace(u.spaces.after, i && f.length === 0), o += f + u.value + a.lossySpace(u.rawSpaceAfter, i && c.length === 0);
      }), o === s && (o = undefined);
      var l = { space: s, rawSpace: o };
      return l;
    }, e.isNamedCombinator = function(n) {
      return n === undefined && (n = this.position), this.tokens[n + 0] && this.tokens[n + 0][E.FIELDS.TYPE] === _.slash && this.tokens[n + 1] && this.tokens[n + 1][E.FIELDS.TYPE] === _.word && this.tokens[n + 2] && this.tokens[n + 2][E.FIELDS.TYPE] === _.slash;
    }, e.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n = this.content(this.tokens[this.position + 1]), i = (0, V.unesc)(n).toLowerCase(), a = {};
        i !== n && (a.value = "/" + n + "/");
        var s = new Zi.default({ value: "/" + i + "/", source: Ve(this.currToken[E.FIELDS.START_LINE], this.currToken[E.FIELDS.START_COL], this.tokens[this.position + 2][E.FIELDS.END_LINE], this.tokens[this.position + 2][E.FIELDS.END_COL]), sourceIndex: this.currToken[E.FIELDS.START_POS], raws: a });
        return this.position = this.position + 3, s;
      } else
        this.unexpected();
    }, e.combinator = function() {
      var n = this;
      if (this.content() === "|")
        return this.namespace();
      var i = this.locateNextMeaningfulToken(this.position);
      if (i < 0 || this.tokens[i][E.FIELDS.TYPE] === _.comma) {
        var a = this.parseWhitespaceEquivalentTokens(i);
        if (a.length > 0) {
          var s = this.current.last;
          if (s) {
            var o = this.convertWhitespaceNodesToSpace(a), l = o.space, u = o.rawSpace;
            u !== undefined && (s.rawSpaceAfter += u), s.spaces.after += l;
          } else
            a.forEach(function(O) {
              return n.newNode(O);
            });
        }
        return;
      }
      var f = this.currToken, c = undefined;
      i > this.position && (c = this.parseWhitespaceEquivalentTokens(i));
      var p;
      if (this.isNamedCombinator() ? p = this.namedCombinator() : this.currToken[E.FIELDS.TYPE] === _.combinator ? (p = new Zi.default({ value: this.content(), source: et(this.currToken), sourceIndex: this.currToken[E.FIELDS.START_POS] }), this.position++) : ns[this.currToken[E.FIELDS.TYPE]] || c || this.unexpected(), p) {
        if (c) {
          var d = this.convertWhitespaceNodesToSpace(c), m = d.space, w = d.rawSpace;
          p.spaces.before = m, p.rawSpaceBefore = w;
        }
      } else {
        var h = this.convertWhitespaceNodesToSpace(c, true), g = h.space, y = h.rawSpace;
        y || (y = g);
        var b = {}, v = { spaces: {} };
        g.endsWith(" ") && y.endsWith(" ") ? (b.before = g.slice(0, g.length - 1), v.spaces.before = y.slice(0, y.length - 1)) : g.startsWith(" ") && y.startsWith(" ") ? (b.after = g.slice(1), v.spaces.after = y.slice(1)) : v.value = y, p = new Zi.default({ value: " ", source: ts(f, this.tokens[this.position - 1]), sourceIndex: f[E.FIELDS.START_POS], spaces: b, raws: v });
      }
      return this.currToken && this.currToken[E.FIELDS.TYPE] === _.space && (p.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(p);
    }, e.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n = new Xi.default({ source: { start: Uu(this.tokens[this.position + 1]) } });
      this.current.parent.append(n), this.current = n, this.position++;
    }, e.comment = function() {
      var n = this.currToken;
      this.newNode(new Nu.default({ value: this.content(), source: et(n), sourceIndex: n[E.FIELDS.START_POS] })), this.position++;
    }, e.error = function(n, i) {
      throw this.root.error(n, i);
    }, e.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[E.FIELDS.START_POS] });
    }, e.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[E.FIELDS.START_POS]);
    }, e.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[E.FIELDS.START_POS]);
    }, e.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[E.FIELDS.START_POS]);
    }, e.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[E.FIELDS.START_POS]);
    }, e.namespace = function() {
      var n = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[E.FIELDS.TYPE] === _.word)
        return this.position++, this.word(n);
      if (this.nextToken[E.FIELDS.TYPE] === _.asterisk)
        return this.position++, this.universal(n);
      this.unexpectedPipe();
    }, e.nesting = function() {
      if (this.nextToken) {
        var n = this.content(this.nextToken);
        if (n === "|") {
          this.position++;
          return;
        }
      }
      var i = this.currToken;
      this.newNode(new dy.default({ value: this.content(), source: et(i), sourceIndex: i[E.FIELDS.START_POS] })), this.position++;
    }, e.parentheses = function() {
      var n = this.current.last, i = 1;
      if (this.position++, n && n.type === my.PSEUDO) {
        var a = new Xi.default({ source: { start: Uu(this.tokens[this.position - 1]) } }), s = this.current;
        for (n.append(a), this.current = a;this.position < this.tokens.length && i; )
          this.currToken[E.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[E.FIELDS.TYPE] === _.closeParenthesis && i--, i ? this.parse() : (this.current.source.end = $u(this.currToken), this.current.parent.source.end = $u(this.currToken), this.position++);
        this.current = s;
      } else {
        for (var o = this.currToken, l = "(", u;this.position < this.tokens.length && i; )
          this.currToken[E.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[E.FIELDS.TYPE] === _.closeParenthesis && i--, u = this.currToken, l += this.parseParenthesisToken(this.currToken), this.position++;
        n ? n.appendToPropertyAndEscape("value", l, l) : this.newNode(new Ki.default({ value: l, source: Ve(o[E.FIELDS.START_LINE], o[E.FIELDS.START_COL], u[E.FIELDS.END_LINE], u[E.FIELDS.END_COL]), sourceIndex: o[E.FIELDS.START_POS] }));
      }
      if (i)
        return this.expected("closing parenthesis", this.currToken[E.FIELDS.START_POS]);
    }, e.pseudo = function() {
      for (var n = this, i = "", a = this.currToken;this.currToken && this.currToken[E.FIELDS.TYPE] === _.colon; )
        i += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[E.FIELDS.TYPE] === _.word)
        this.splitWord(false, function(s, o) {
          i += s, n.newNode(new cy.default({ value: i, source: ts(a, n.currToken), sourceIndex: a[E.FIELDS.START_POS] })), o > 1 && n.nextToken && n.nextToken[E.FIELDS.TYPE] === _.openParenthesis && n.error("Misplaced parenthesis.", { index: n.nextToken[E.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[E.FIELDS.START_POS]);
    }, e.space = function() {
      var n = this.content();
      this.position === 0 || this.prevToken[E.FIELDS.TYPE] === _.comma || this.prevToken[E.FIELDS.TYPE] === _.openParenthesis || this.current.nodes.every(function(i) {
        return i.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[E.FIELDS.TYPE] === _.comma || this.nextToken[E.FIELDS.TYPE] === _.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n), this.position++) : this.combinator();
    }, e.string = function() {
      var n = this.currToken;
      this.newNode(new Ki.default({ value: this.content(), source: et(n), sourceIndex: n[E.FIELDS.START_POS] })), this.position++;
    }, e.universal = function(n) {
      var i = this.nextToken;
      if (i && this.content(i) === "|")
        return this.position++, this.namespace();
      var a = this.currToken;
      this.newNode(new py.default({ value: this.content(), source: et(a), sourceIndex: a[E.FIELDS.START_POS] }), n), this.position++;
    }, e.splitWord = function(n, i) {
      for (var a = this, s = this.nextToken, o = this.content();s && ~[_.dollar, _.caret, _.equals, _.word].indexOf(s[E.FIELDS.TYPE]); ) {
        this.position++;
        var l = this.content();
        if (o += l, l.lastIndexOf("\\") === l.length - 1) {
          var u = this.nextToken;
          u && u[E.FIELDS.TYPE] === _.space && (o += this.requiredSpace(this.content(u)), this.position++);
        }
        s = this.nextToken;
      }
      var f = rs(o, ".").filter(function(m) {
        var w = o[m - 1] === "\\", h = /^\d+\.\d+%$/.test(o);
        return !w && !h;
      }), c = rs(o, "#").filter(function(m) {
        return o[m - 1] !== "\\";
      }), p = rs(o, "#{");
      p.length && (c = c.filter(function(m) {
        return !~p.indexOf(m);
      }));
      var d = (0, hy.default)(vy([0].concat(f, c)));
      d.forEach(function(m, w) {
        var h = d[w + 1] || o.length, g = o.slice(m, h);
        if (w === 0 && i)
          return i.call(a, g, d.length);
        var y, b = a.currToken, v = b[E.FIELDS.START_POS] + d[w], O = Ve(b[1], b[2] + m, b[3], b[2] + (h - 1));
        if (~f.indexOf(m)) {
          var x = { value: g.slice(1), source: O, sourceIndex: v };
          y = new ly.default(tt(x, "value"));
        } else if (~c.indexOf(m)) {
          var C = { value: g.slice(1), source: O, sourceIndex: v };
          y = new uy.default(tt(C, "value"));
        } else {
          var S = { value: g, source: O, sourceIndex: v };
          tt(S, "value"), y = new fy.default(S);
        }
        a.newNode(y, n), n = null;
      }), this.position++;
    }, e.word = function(n) {
      var i = this.nextToken;
      return i && this.content(i) === "|" ? (this.position++, this.namespace()) : this.splitWord(n);
    }, e.loop = function() {
      for (;this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e.parse = function(n) {
      switch (this.currToken[E.FIELDS.TYPE]) {
        case _.space:
          this.space();
          break;
        case _.comment:
          this.comment();
          break;
        case _.openParenthesis:
          this.parentheses();
          break;
        case _.closeParenthesis:
          n && this.missingParenthesis();
          break;
        case _.openSquare:
          this.attribute();
          break;
        case _.dollar:
        case _.caret:
        case _.equals:
        case _.word:
          this.word();
          break;
        case _.colon:
          this.pseudo();
          break;
        case _.comma:
          this.comma();
          break;
        case _.asterisk:
          this.universal();
          break;
        case _.ampersand:
          this.nesting();
          break;
        case _.slash:
        case _.combinator:
          this.combinator();
          break;
        case _.str:
          this.string();
          break;
        case _.closeSquare:
          this.missingSquareBracket();
        case _.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e.expected = function(n, i, a) {
      if (Array.isArray(n)) {
        var s = n.pop();
        n = n.join(", ") + " or " + s;
      }
      var o = /^[aeiou]/.test(n[0]) ? "an" : "a";
      return a ? this.error("Expected " + o + " " + n + ', found "' + a + '" instead.', { index: i }) : this.error("Expected " + o + " " + n + ".", { index: i });
    }, e.requiredSpace = function(n) {
      return this.options.lossy ? " " : n;
    }, e.optionalSpace = function(n) {
      return this.options.lossy ? "" : n;
    }, e.lossySpace = function(n, i) {
      return this.options.lossy ? i ? " " : "" : n;
    }, e.parseParenthesisToken = function(n) {
      var i = this.content(n);
      return n[E.FIELDS.TYPE] === _.space ? this.requiredSpace(i) : i;
    }, e.newNode = function(n, i) {
      return i && (/^ +$/.test(i) && (this.options.lossy || (this.spaces = (this.spaces || "") + i), i = true), n.namespace = i, tt(n, "namespace")), this.spaces && (n.spaces.before = this.spaces, this.spaces = ""), this.current.append(n);
    }, e.content = function(n) {
      return n === undefined && (n = this.currToken), this.css.slice(n[E.FIELDS.START_POS], n[E.FIELDS.END_POS]);
    }, e.locateNextMeaningfulToken = function(n) {
      n === undefined && (n = this.position + 1);
      for (var i = n;i < this.tokens.length; )
        if (yy[this.tokens[i][E.FIELDS.TYPE]]) {
          i++;
          continue;
        } else
          return i;
      return -1;
    }, gy(t, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t;
  }();
  er.default = wy;
  zu.exports = er.default;
});
var Bu = k((tr, Wu) => {
  tr.__esModule = true;
  tr.default = undefined;
  var by = xy(Vu());
  function xy(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var Sy = function() {
    function t(r2, n) {
      this.func = r2 || function() {}, this.funcRes = null, this.options = n;
    }
    var e = t.prototype;
    return e._shouldUpdateSelector = function(n, i) {
      i === undefined && (i = {});
      var a = Object.assign({}, this.options, i);
      return a.updateSelector === false ? false : typeof n != "string";
    }, e._isLossy = function(n) {
      n === undefined && (n = {});
      var i = Object.assign({}, this.options, n);
      return i.lossless === false;
    }, e._root = function(n, i) {
      i === undefined && (i = {});
      var a = new by.default(n, this._parseOptions(i));
      return a.root;
    }, e._parseOptions = function(n) {
      return { lossy: this._isLossy(n) };
    }, e._run = function(n, i) {
      var a = this;
      return i === undefined && (i = {}), new Promise(function(s, o) {
        try {
          var l = a._root(n, i);
          Promise.resolve(a.func(l)).then(function(u) {
            var f = undefined;
            return a._shouldUpdateSelector(n, i) && (f = l.toString(), n.selector = f), { transform: u, root: l, string: f };
          }).then(s, o);
        } catch (u) {
          o(u);
          return;
        }
      });
    }, e._runSync = function(n, i) {
      i === undefined && (i = {});
      var a = this._root(n, i), s = this.func(a);
      if (s && typeof s.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o = undefined;
      return i.updateSelector && typeof n != "string" && (o = a.toString(), n.selector = o), { transform: s, root: a, string: o };
    }, e.ast = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.root;
      });
    }, e.astSync = function(n, i) {
      return this._runSync(n, i).root;
    }, e.transform = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.transform;
      });
    }, e.transformSync = function(n, i) {
      return this._runSync(n, i).transform;
    }, e.process = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.string || a.root.toString();
      });
    }, e.processSync = function(n, i) {
      var a = this._runSync(n, i);
      return a.string || a.root.toString();
    }, t;
  }();
  tr.default = Sy;
  Wu.exports = tr.default;
});
var Gu = k((j) => {
  j.__esModule = true;
  j.universal = j.tag = j.string = j.selector = j.root = j.pseudo = j.nesting = j.id = j.comment = j.combinator = j.className = j.attribute = undefined;
  var ky = ue(zi()), Ey = ue(Ei()), Oy = ue(Gi()), Ay = ue(Ai()), Cy = ue(_i()), _y = ue(Yi()), Ty = ue(Li()), Py = ue(wi()), Iy = ue(xi()), Ry = ue(Di()), Dy = ue(Ii()), My = ue(Wi());
  function ue(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var Ly = function(e) {
    return new ky.default(e);
  };
  j.attribute = Ly;
  var Ny = function(e) {
    return new Ey.default(e);
  };
  j.className = Ny;
  var Fy = function(e) {
    return new Oy.default(e);
  };
  j.combinator = Fy;
  var qy = function(e) {
    return new Ay.default(e);
  };
  j.comment = qy;
  var Uy = function(e) {
    return new Cy.default(e);
  };
  j.id = Uy;
  var $y = function(e) {
    return new _y.default(e);
  };
  j.nesting = $y;
  var jy = function(e) {
    return new Ty.default(e);
  };
  j.pseudo = jy;
  var zy = function(e) {
    return new Py.default(e);
  };
  j.root = zy;
  var Vy = function(e) {
    return new Iy.default(e);
  };
  j.selector = Vy;
  var Wy = function(e) {
    return new Ry.default(e);
  };
  j.string = Wy;
  var By = function(e) {
    return new Dy.default(e);
  };
  j.tag = By;
  var Gy = function(e) {
    return new My.default(e);
  };
  j.universal = Gy;
});
var Ju = k((D) => {
  D.__esModule = true;
  D.isComment = D.isCombinator = D.isClassName = D.isAttribute = undefined;
  D.isContainer = i0;
  D.isIdentifier = undefined;
  D.isNamespace = s0;
  D.isNesting = undefined;
  D.isNode = is;
  D.isPseudo = undefined;
  D.isPseudoClass = n0;
  D.isPseudoElement = Qu;
  D.isUniversal = D.isTag = D.isString = D.isSelector = D.isRoot = undefined;
  var W = J(), ee, Hy = (ee = {}, ee[W.ATTRIBUTE] = true, ee[W.CLASS] = true, ee[W.COMBINATOR] = true, ee[W.COMMENT] = true, ee[W.ID] = true, ee[W.NESTING] = true, ee[W.PSEUDO] = true, ee[W.ROOT] = true, ee[W.SELECTOR] = true, ee[W.STRING] = true, ee[W.TAG] = true, ee[W.UNIVERSAL] = true, ee);
  function is(t) {
    return typeof t == "object" && Hy[t.type];
  }
  function fe(t, e) {
    return is(e) && e.type === t;
  }
  var Hu = fe.bind(null, W.ATTRIBUTE);
  D.isAttribute = Hu;
  var Yy = fe.bind(null, W.CLASS);
  D.isClassName = Yy;
  var Qy = fe.bind(null, W.COMBINATOR);
  D.isCombinator = Qy;
  var Jy = fe.bind(null, W.COMMENT);
  D.isComment = Jy;
  var Xy = fe.bind(null, W.ID);
  D.isIdentifier = Xy;
  var Ky = fe.bind(null, W.NESTING);
  D.isNesting = Ky;
  var ss = fe.bind(null, W.PSEUDO);
  D.isPseudo = ss;
  var Zy = fe.bind(null, W.ROOT);
  D.isRoot = Zy;
  var e0 = fe.bind(null, W.SELECTOR);
  D.isSelector = e0;
  var t0 = fe.bind(null, W.STRING);
  D.isString = t0;
  var Yu = fe.bind(null, W.TAG);
  D.isTag = Yu;
  var r0 = fe.bind(null, W.UNIVERSAL);
  D.isUniversal = r0;
  function Qu(t) {
    return ss(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
  }
  function n0(t) {
    return ss(t) && !Qu(t);
  }
  function i0(t) {
    return !!(is(t) && t.walk);
  }
  function s0(t) {
    return Hu(t) || Yu(t);
  }
});
var Xu = k((de) => {
  de.__esModule = true;
  var as = J();
  Object.keys(as).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === as[t] || (de[t] = as[t]);
  });
  var os = Gu();
  Object.keys(os).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === os[t] || (de[t] = os[t]);
  });
  var ls = Ju();
  Object.keys(ls).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === ls[t] || (de[t] = ls[t]);
  });
});
var ye = k((rr, Zu) => {
  rr.__esModule = true;
  rr.default = undefined;
  var a0 = u0(Bu()), o0 = l0(Xu());
  function Ku(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r2 = new WeakMap;
    return (Ku = function(i) {
      return i ? r2 : e;
    })(t);
  }
  function l0(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r2 = Ku(e);
    if (r2 && r2.has(t))
      return r2.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r2 && r2.set(t, n), n;
  }
  function u0(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var us = function(e) {
    return new a0.default(e);
  };
  Object.assign(us, o0);
  delete us.__esModule;
  var f0 = us;
  rr.default = f0;
  Zu.exports = rr.default;
});
var of = k((kx, hs) => {
  var { Rule: tf, AtRule: c0 } = Ke(), rf = ye();
  function ps(t, e) {
    let r2;
    try {
      rf((n) => {
        r2 = n;
      }).processSync(t);
    } catch (n) {
      throw t.includes(":") ? e ? e.error("Missed semicolon") : n : e ? e.error(n.message) : n;
    }
    return r2.at(0);
  }
  function nf(t, e) {
    let r2 = false;
    return t.each((n) => {
      if (n.type === "nesting") {
        let i = e.clone({});
        n.value !== "&" ? n.replaceWith(ps(n.value.replace("&", i.toString()))) : n.replaceWith(i), r2 = true;
      } else
        "nodes" in n && n.nodes && nf(n, e) && (r2 = true);
    }), r2;
  }
  function sf(t, e) {
    let r2 = [];
    return t.selectors.forEach((n) => {
      let i = ps(n, t);
      e.selectors.forEach((a) => {
        if (!a)
          return;
        let s = ps(a, e);
        nf(s, i) || (s.prepend(rf.combinator({ value: " " })), s.prepend(i.clone({}))), r2.push(s.toString());
      });
    }), r2;
  }
  function Zr(t, e) {
    let r2 = t.prev();
    for (e.after(t);r2 && r2.type === "comment"; ) {
      let n = r2.prev();
      e.after(r2), r2 = n;
    }
    return t;
  }
  function p0(t) {
    return function e(r2, n, i, a = i) {
      let s = [];
      if (n.each((o) => {
        o.type === "rule" && i ? a && (o.selectors = sf(r2, o)) : o.type === "atrule" && o.nodes ? t[o.name] ? e(r2, o, a) : n[ds] !== false && s.push(o) : s.push(o);
      }), i && s.length) {
        let o = r2.clone({ nodes: [] });
        for (let l of s)
          o.append(l);
        n.prepend(o);
      }
    };
  }
  function fs(t, e, r2) {
    let n = new tf({ selector: t, nodes: [] });
    return n.append(e), r2.after(n), n;
  }
  function ef(t, e) {
    let r2 = {};
    for (let n of t)
      r2[n] = true;
    if (e)
      for (let n of e)
        r2[n.replace(/^@/, "")] = true;
    return r2;
  }
  function d0(t) {
    t = t.trim();
    let e = t.match(/^\((.*)\)$/);
    if (!e)
      return { type: "basic", selector: t };
    let r2 = e[1].match(/^(with(?:out)?):(.+)$/);
    if (r2) {
      let n = r2[1] === "with", i = Object.fromEntries(r2[2].trim().split(/\s+/).map((s) => [s, true]));
      if (n && i.all)
        return { type: "noop" };
      let a = (s) => !!i[s];
      return i.all ? a = () => true : n && (a = (s) => s === "all" ? false : !i[s]), { type: "withrules", escapes: a };
    }
    return { type: "unknown" };
  }
  function h0(t) {
    let e = [], r2 = t.parent;
    for (;r2 && r2 instanceof c0; )
      e.push(r2), r2 = r2.parent;
    return e;
  }
  function m0(t) {
    let e = t[af];
    if (!e)
      t.after(t.nodes);
    else {
      let r2 = t.nodes, n, i = -1, a, s, o, l = h0(t);
      if (l.forEach((u, f) => {
        if (e(u.name))
          n = u, i = f, s = o;
        else {
          let c = o;
          o = u.clone({ nodes: [] }), c && o.append(c), a = a || o;
        }
      }), n ? s ? (a.append(r2), n.after(s)) : n.after(r2) : t.after(r2), t.next() && n) {
        let u;
        l.slice(0, i + 1).forEach((f, c, p) => {
          let d = u;
          u = f.clone({ nodes: [] }), d && u.append(d);
          let m = [], h = (p[c - 1] || t).next();
          for (;h; )
            m.push(h), h = h.next();
          u.append(m);
        }), u && (s || r2[r2.length - 1]).after(u);
      }
    }
    t.remove();
  }
  var ds = Symbol("rootRuleMergeSel"), af = Symbol("rootRuleEscapes");
  function g0(t) {
    let { params: e } = t, { type: r2, selector: n, escapes: i } = d0(e);
    if (r2 === "unknown")
      throw t.error(`Unknown @${t.name} parameter ${JSON.stringify(e)}`);
    if (r2 === "basic" && n) {
      let a = new tf({ selector: n, nodes: t.nodes });
      t.removeAll(), t.append(a);
    }
    t[af] = i, t[ds] = i ? !i("all") : r2 === "noop";
  }
  var cs = Symbol("hasRootRule");
  hs.exports = (t = {}) => {
    let e = ef(["media", "supports", "layer", "container"], t.bubble), r2 = p0(e), n = ef(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t.unwrap), i = (t.rootRuleName || "at-root").replace(/^@/, ""), a = t.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(s) {
      s.walkAtRules(i, (o) => {
        g0(o), s[cs] = true;
      });
    }, Rule(s) {
      let o = false, l = s, u = false, f = [];
      s.each((c) => {
        c.type === "rule" ? (f.length && (l = fs(s.selector, f, l), f = []), u = true, o = true, c.selectors = sf(s, c), l = Zr(c, l)) : c.type === "atrule" ? (f.length && (l = fs(s.selector, f, l), f = []), c.name === i ? (o = true, r2(s, c, true, c[ds]), l = Zr(c, l)) : e[c.name] ? (u = true, o = true, r2(s, c, true), l = Zr(c, l)) : n[c.name] ? (u = true, o = true, r2(s, c, false), l = Zr(c, l)) : u && f.push(c)) : c.type === "decl" && u && f.push(c);
      }), f.length && (l = fs(s.selector, f, l)), o && a !== true && (s.raws.semicolon = true, s.nodes.length === 0 && s.remove());
    }, RootExit(s) {
      s[cs] && (s.walkAtRules(i, m0), s[cs] = false);
    } };
  };
  hs.exports.postcss = true;
});
var cf = k((Ex, ff) => {
  var lf = /-(\w|$)/g, uf = function(e, r2) {
    return r2.toUpperCase();
  }, y0 = function(e) {
    return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(lf, uf) : e.replace(lf, uf);
  };
  ff.exports = y0;
});
var ys = k((Ox, pf) => {
  var v0 = cf(), w0 = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function ms(t) {
    return typeof t.nodes > "u" ? true : gs(t);
  }
  function gs(t) {
    let e, r2 = {};
    return t.each((n) => {
      if (n.type === "atrule")
        e = "@" + n.name, n.params && (e += " " + n.params), typeof r2[e] > "u" ? r2[e] = ms(n) : Array.isArray(r2[e]) ? r2[e].push(ms(n)) : r2[e] = [r2[e], ms(n)];
      else if (n.type === "rule") {
        let i = gs(n);
        if (r2[n.selector])
          for (let a in i)
            r2[n.selector][a] = i[a];
        else
          r2[n.selector] = i;
      } else if (n.type === "decl") {
        n.prop[0] === "-" && n.prop[1] === "-" || n.parent && n.parent.selector === ":export" ? e = n.prop : e = v0(n.prop);
        let i = n.value;
        !isNaN(n.value) && w0[e] && (i = parseFloat(n.value)), n.important && (i += " !important"), typeof r2[e] > "u" ? r2[e] = i : Array.isArray(r2[e]) ? r2[e].push(i) : r2[e] = [r2[e], i];
      }
    }), r2;
  }
  pf.exports = gs;
});
var en = k((Ax, gf) => {
  var nr = Ke(), df = /\s*!important\s*$/i, b0 = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function x0(t) {
    return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function hf(t, e, r2) {
    r2 === false || r2 === null || (e.startsWith("--") || (e = x0(e)), typeof r2 == "number" && (r2 === 0 || b0[e] ? r2 = r2.toString() : r2 += "px"), e === "css-float" && (e = "float"), df.test(r2) ? (r2 = r2.replace(df, ""), t.push(nr.decl({ prop: e, value: r2, important: true }))) : t.push(nr.decl({ prop: e, value: r2 })));
  }
  function mf(t, e, r2) {
    let n = nr.atRule({ name: e[1], params: e[3] || "" });
    typeof r2 == "object" && (n.nodes = [], vs(r2, n)), t.push(n);
  }
  function vs(t, e) {
    let r2, n, i;
    for (r2 in t)
      if (n = t[r2], !(n === null || typeof n > "u"))
        if (r2[0] === "@") {
          let a = r2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n))
            for (let s of n)
              mf(e, a, s);
          else
            mf(e, a, n);
        } else if (Array.isArray(n))
          for (let a of n)
            hf(e, r2, a);
        else
          typeof n == "object" ? (i = nr.rule({ selector: r2 }), vs(n, i), e.push(i)) : hf(e, r2, n);
  }
  gf.exports = function(t) {
    let e = nr.root();
    return vs(t, e), e;
  };
});
var ws = k((Cx, yf) => {
  var S0 = ys();
  yf.exports = function(e) {
    return console && console.warn && e.warnings().forEach((r2) => {
      let n = r2.plugin || "PostCSS";
      console.warn(n + ": " + r2.text);
    }), S0(e.root);
  };
});
var wf = k((_x, vf) => {
  var k0 = Ke(), E0 = ws(), O0 = en();
  vf.exports = function(e) {
    let r2 = k0(e);
    return async (n) => {
      let i = await r2.process(n, { parser: O0, from: undefined });
      return E0(i);
    };
  };
});
var xf = k((Tx, bf) => {
  var A0 = Ke(), C0 = ws(), _0 = en();
  bf.exports = function(t) {
    let e = A0(t);
    return (r2) => {
      let n = e.process(r2, { parser: _0, from: undefined });
      return C0(n);
    };
  };
});
var kf = k((Px, Sf) => {
  var T0 = ys(), P0 = en(), I0 = wf(), R0 = xf();
  Sf.exports = { objectify: T0, parse: P0, async: I0, sync: R0 };
});
var Ls = k((Ds, Ms) => {
  (function(t, e) {
    typeof Ds == "object" && typeof Ms < "u" ? Ms.exports = function(r2, n, i, a, s) {
      for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
        r2 = r2 ? r2[n[a]] : s;
      return r2 === s ? i : r2;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r2, n, i, a, s) {
        for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
          r2 = r2 ? r2[n[a]] : s;
        return r2 === s ? i : r2;
      };
    }) : t.dlv = function(r2, n, i, a, s) {
      for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
        r2 = r2 ? r2[n[a]] : s;
      return r2 === s ? i : r2;
    };
  })(Ds);
});
var Cc = k((uk, bn) => {
  (function() {
    function t(n, i, a) {
      if (!n)
        return null;
      t.caseSensitive || (n = n.toLowerCase());
      var s = t.threshold === null ? null : t.threshold * n.length, o = t.thresholdAbsolute, l;
      s !== null && o !== null ? l = Math.min(s, o) : s !== null ? l = s : o !== null ? l = o : l = null;
      var u, f, c, p, d, m = i.length;
      for (d = 0;d < m; d++)
        if (f = i[d], a && (f = f[a]), !!f && (t.caseSensitive ? c = f : c = f.toLowerCase(), p = r2(n, c, l), (l === null || p < l) && (l = p, a && t.returnWinningObject ? u = i[d] : u = f, t.returnFirstMatch)))
          return u;
      return u || t.nullResultValue;
    }
    t.threshold = 0.4, t.thresholdAbsolute = 20, t.caseSensitive = false, t.nullResultValue = null, t.returnWinningObject = null, t.returnFirstMatch = false, typeof bn < "u" && bn.exports ? bn.exports = t : window.didYouMean = t;
    var e = Math.pow(2, 32) - 1;
    function r2(n, i, a) {
      a = a || a === 0 ? a : e;
      var s = n.length, o = i.length;
      if (s === 0)
        return Math.min(a + 1, o);
      if (o === 0)
        return Math.min(a + 1, s);
      if (Math.abs(s - o) > a)
        return a + 1;
      var l = [], u, f, c, p, d;
      for (u = 0;u <= o; u++)
        l[u] = [u];
      for (f = 0;f <= s; f++)
        l[0][f] = f;
      for (u = 1;u <= o; u++) {
        for (c = e, p = 1, u > a && (p = u - a), d = o + 1, d > a + u && (d = a + u), f = 1;f <= s; f++)
          f < p || f > d ? l[u][f] = a + 1 : i.charAt(u - 1) === n.charAt(f - 1) ? l[u][f] = l[u - 1][f - 1] : l[u][f] = Math.min(l[u - 1][f - 1] + 1, Math.min(l[u][f - 1] + 1, l[u - 1][f] + 1)), l[u][f] < c && (c = l[u][f]);
        if (c > a)
          return a + 1;
      }
      return l[o][s];
    }
  })();
});
var Tc = k((fk, _c) => {
  var Xs = 40, Ks = 41, xn = 39, Zs = 34, ea = 92, ut = 47, ta = 44, ra = 58, Sn = 42, nw = 117, iw = 85, sw = 43, aw = /^[a-f0-9?-]+$/i;
  _c.exports = function(t) {
    for (var e = [], r2 = t, n, i, a, s, o, l, u, f, c = 0, p = r2.charCodeAt(c), d = r2.length, m = [{ nodes: e }], w = 0, h, g = "", y = "", b = "";c < d; )
      if (p <= 32) {
        n = c;
        do
          n += 1, p = r2.charCodeAt(n);
        while (p <= 32);
        s = r2.slice(c, n), a = e[e.length - 1], p === Ks && w ? b = s : a && a.type === "div" ? (a.after = s, a.sourceEndIndex += s.length) : p === ta || p === ra || p === ut && r2.charCodeAt(n + 1) !== Sn && (!h || h && h.type === "function" && false) ? y = s : e.push({ type: "space", sourceIndex: c, sourceEndIndex: n, value: s }), c = n;
      } else if (p === xn || p === Zs) {
        n = c, i = p === xn ? "'" : '"', s = { type: "string", sourceIndex: c, quote: i };
        do
          if (o = false, n = r2.indexOf(i, n + 1), ~n)
            for (l = n;r2.charCodeAt(l - 1) === ea; )
              l -= 1, o = !o;
          else
            r2 += i, n = r2.length - 1, s.unclosed = true;
        while (o);
        s.value = r2.slice(c + 1, n), s.sourceEndIndex = s.unclosed ? n : n + 1, e.push(s), c = n + 1, p = r2.charCodeAt(c);
      } else if (p === ut && r2.charCodeAt(c + 1) === Sn)
        n = r2.indexOf("*/", c), s = { type: "comment", sourceIndex: c, sourceEndIndex: n + 2 }, n === -1 && (s.unclosed = true, n = r2.length, s.sourceEndIndex = n), s.value = r2.slice(c + 2, n), e.push(s), c = n + 2, p = r2.charCodeAt(c);
      else if ((p === ut || p === Sn) && h && h.type === "function")
        s = r2[c], e.push({ type: "word", sourceIndex: c - y.length, sourceEndIndex: c + s.length, value: s }), c += 1, p = r2.charCodeAt(c);
      else if (p === ut || p === ta || p === ra)
        s = r2[c], e.push({ type: "div", sourceIndex: c - y.length, sourceEndIndex: c + s.length, value: s, before: y, after: "" }), y = "", c += 1, p = r2.charCodeAt(c);
      else if (Xs === p) {
        n = c;
        do
          n += 1, p = r2.charCodeAt(n);
        while (p <= 32);
        if (f = c, s = { type: "function", sourceIndex: c - g.length, value: g, before: r2.slice(f + 1, n) }, c = n, g === "url" && p !== xn && p !== Zs) {
          n -= 1;
          do
            if (o = false, n = r2.indexOf(")", n + 1), ~n)
              for (l = n;r2.charCodeAt(l - 1) === ea; )
                l -= 1, o = !o;
            else
              r2 += ")", n = r2.length - 1, s.unclosed = true;
          while (o);
          u = n;
          do
            u -= 1, p = r2.charCodeAt(u);
          while (p <= 32);
          f < u ? (c !== u + 1 ? s.nodes = [{ type: "word", sourceIndex: c, sourceEndIndex: u + 1, value: r2.slice(c, u + 1) }] : s.nodes = [], s.unclosed && u + 1 !== n ? (s.after = "", s.nodes.push({ type: "space", sourceIndex: u + 1, sourceEndIndex: n, value: r2.slice(u + 1, n) })) : (s.after = r2.slice(u + 1, n), s.sourceEndIndex = n)) : (s.after = "", s.nodes = []), c = n + 1, s.sourceEndIndex = s.unclosed ? n : c, p = r2.charCodeAt(c), e.push(s);
        } else
          w += 1, s.after = "", s.sourceEndIndex = c + 1, e.push(s), m.push(s), e = s.nodes = [], h = s;
        g = "";
      } else if (Ks === p && w)
        c += 1, p = r2.charCodeAt(c), h.after = b, h.sourceEndIndex += b.length, b = "", w -= 1, m[m.length - 1].sourceEndIndex = c, m.pop(), h = m[w], e = h.nodes;
      else {
        n = c;
        do
          p === ea && (n += 1), n += 1, p = r2.charCodeAt(n);
        while (n < d && !(p <= 32 || p === xn || p === Zs || p === ta || p === ra || p === ut || p === Xs || p === Sn && h && h.type === "function" || p === ut && h.type === "function" || p === Ks && w));
        s = r2.slice(c, n), Xs === p ? g = s : (nw === s.charCodeAt(0) || iw === s.charCodeAt(0)) && sw === s.charCodeAt(1) && aw.test(s.slice(2)) ? e.push({ type: "unicode-range", sourceIndex: c, sourceEndIndex: n, value: s }) : e.push({ type: "word", sourceIndex: c, sourceEndIndex: n, value: s }), c = n;
      }
    for (c = m.length - 1;c; c -= 1)
      m[c].unclosed = true, m[c].sourceEndIndex = r2.length;
    return m[0].nodes;
  };
});
var Ic = k((ck, Pc) => {
  Pc.exports = function t(e, r2, n) {
    var i, a, s, o;
    for (i = 0, a = e.length;i < a; i += 1)
      s = e[i], n || (o = r2(s, i, e)), o !== false && s.type === "function" && Array.isArray(s.nodes) && t(s.nodes, r2, n), n && r2(s, i, e);
  };
});
var Lc = k((pk, Mc) => {
  function Rc(t, e) {
    var { type: r2, value: n } = t, i, a;
    return e && (a = e(t)) !== undefined ? a : r2 === "word" || r2 === "space" ? n : r2 === "string" ? (i = t.quote || "", i + n + (t.unclosed ? "" : i)) : r2 === "comment" ? "/*" + n + (t.unclosed ? "" : "*/") : r2 === "div" ? (t.before || "") + n + (t.after || "") : Array.isArray(t.nodes) ? (i = Dc(t.nodes, e), r2 !== "function" ? i : n + "(" + (t.before || "") + i + (t.after || "") + (t.unclosed ? "" : ")")) : n;
  }
  function Dc(t, e) {
    var r2, n;
    if (Array.isArray(t)) {
      for (r2 = "", n = t.length - 1;~n; n -= 1)
        r2 = Rc(t[n], e) + r2;
      return r2;
    }
    return Rc(t, e);
  }
  Mc.exports = Dc;
});
var Fc = k((dk, Nc) => {
  var kn = 45, En = 43, na = 46, ow = 101, lw = 69;
  function uw(t) {
    var e = t.charCodeAt(0), r2;
    if (e === En || e === kn) {
      if (r2 = t.charCodeAt(1), r2 >= 48 && r2 <= 57)
        return true;
      var n = t.charCodeAt(2);
      return r2 === na && n >= 48 && n <= 57;
    }
    return e === na ? (r2 = t.charCodeAt(1), r2 >= 48 && r2 <= 57) : e >= 48 && e <= 57;
  }
  Nc.exports = function(t) {
    var e = 0, r2 = t.length, n, i, a;
    if (r2 === 0 || !uw(t))
      return false;
    for (n = t.charCodeAt(e), (n === En || n === kn) && e++;e < r2 && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
      e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), n === na && i >= 48 && i <= 57)
      for (e += 2;e < r2 && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), a = t.charCodeAt(e + 2), (n === ow || n === lw) && (i >= 48 && i <= 57 || (i === En || i === kn) && a >= 48 && a <= 57))
      for (e += i === En || i === kn ? 3 : 2;e < r2 && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    return { number: t.slice(0, e), unit: t.slice(e) };
  };
});
var jc = k((hk, $c) => {
  var fw = Tc(), qc = Ic(), Uc = Lc();
  function Fe(t) {
    return this instanceof Fe ? (this.nodes = fw(t), this) : new Fe(t);
  }
  Fe.prototype.toString = function() {
    return Array.isArray(this.nodes) ? Uc(this.nodes) : "";
  };
  Fe.prototype.walk = function(t, e) {
    return qc(this.nodes, t, e), this;
  };
  Fe.unit = Fc();
  Fe.walk = qc;
  Fe.stringify = Uc;
  $c.exports = Fe;
});
var ip = k((gE, np) => {
  np.exports = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t }) => ({ ...t("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { busy: 'busy="true"', checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t }) => t("blur"), backdropBrightness: ({ theme: t }) => t("brightness"), backdropContrast: ({ theme: t }) => t("contrast"), backdropGrayscale: ({ theme: t }) => t("grayscale"), backdropHueRotate: ({ theme: t }) => t("hueRotate"), backdropInvert: ({ theme: t }) => t("invert"), backdropOpacity: ({ theme: t }) => t("opacity"), backdropSaturate: ({ theme: t }) => t("saturate"), backdropSepia: ({ theme: t }) => t("sepia"), backgroundColor: ({ theme: t }) => t("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t }) => t("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t }) => ({ ...t("colors"), DEFAULT: t("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t }) => t("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t }) => ({ ...t("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t }) => t("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t }) => t("colors"), colors: ({ colors: t }) => ({ inherit: t.inherit, current: t.current, transparent: t.transparent, black: t.black, white: t.white, slate: t.slate, gray: t.gray, zinc: t.zinc, neutral: t.neutral, stone: t.stone, red: t.red, orange: t.orange, amber: t.amber, yellow: t.yellow, lime: t.lime, green: t.green, emerald: t.emerald, teal: t.teal, cyan: t.cyan, sky: t.sky, blue: t.blue, indigo: t.indigo, violet: t.violet, purple: t.purple, fuchsia: t.fuchsia, pink: t.pink, rose: t.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t }) => t("borderColor"), divideOpacity: ({ theme: t }) => t("borderOpacity"), divideWidth: ({ theme: t }) => t("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t }) => ({ none: "none", ...t("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t }) => t("spacing"), gradientColorStops: ({ theme: t }) => t("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t }) => ({ auto: "auto", ...t("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: t }) => ({ ...t("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t, breakpoints: e }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e(t("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t }) => t("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t }) => t("spacing"), placeholderColor: ({ theme: t }) => t("colors"), placeholderOpacity: ({ theme: t }) => t("opacity"), ringColor: ({ theme: t }) => ({ DEFAULT: t("colors.blue.500", "#3b82f6"), ...t("colors") }), ringOffsetColor: ({ theme: t }) => t("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t }) => ({ DEFAULT: "0.5", ...t("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t }) => ({ ...t("spacing") }), scrollPadding: ({ theme: t }) => t("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t }) => ({ ...t("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t }) => ({ none: "none", ...t("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t }) => t("colors"), textDecorationColor: ({ theme: t }) => t("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t }) => ({ ...t("spacing") }), textOpacity: ({ theme: t }) => t("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t }) => ({ ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
});
var U = H(Ke(), 1);
var L = U.default;
var bb = U.default.stringify;
var xb = U.default.fromJSON;
var Sb = U.default.plugin;
var kb = U.default.parse;
var Eb = U.default.list;
var Ob = U.default.document;
var Ab = U.default.comment;
var Cb = U.default.atRule;
var _b = U.default.rule;
var Tb = U.default.decl;
var Pb = U.default.root;
var Ib = U.default.CssSyntaxError;
var Rb = U.default.Declaration;
var Db = U.default.Container;
var Mb = U.default.Processor;
var Lb = U.default.Document;
var Nb = U.default.Comment;
var Fb = U.default.Warning;
var qb = U.default.AtRule;
var Ub = U.default.Result;
var $b = U.default.Input;
var jb = U.default.Rule;
var zb = U.default.Root;
var Vb = U.default.Node;
var op = H(Vl(), 1);
function ci() {}
var F = { info: ci, warn: ci, risk: ci };
function pi(t) {
  let e = new Set, r2 = new Set, n = new Set;
  if (t.walkAtRules((i) => {
    i.name === "apply" && n.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), e.add(i.params)), ["layer", "responsive", "variants"].includes(i.name) && (["responsive", "variants"].includes(i.name) && F.warn(`${i.name}-at-rule-deprecated`, [`The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r2.add(i));
  }), !e.has("base") || !e.has("components") || !e.has("utilities")) {
    for (let i of r2)
      if (i.name === "layer" && ["base", "components", "utilities"].includes(i.params)) {
        if (!e.has(i.params))
          throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
      } else if (i.name === "responsive") {
        if (!e.has("utilities"))
          throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i.name === "variants" && !e.has("utilities"))
        throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e, applyDirectives: n };
}
Sr();
var xc = H(Bl());
var Hl = "3.3.6";
var hi = { name: "tailwindcss", version: Hl, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`, postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "^0.1.62", "@swc/core": "^1.3.55", "@swc/jest": "^0.2.26", "@swc/register": "^0.1.10", autoprefixer: "^10.4.14", browserslist: "^4.21.5", concurrently: "^8.0.1", cssnano: "^6.0.0", esbuild: "^0.17.18", eslint: "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", jest: "^29.6.0", "jest-diff": "^29.6.0", lightningcss: "1.18.0", prettier: "^2.8.8", rimraf: "^5.0.0", "source-map-js": "^1.0.2", turbo: "^1.9.3" }, dependencies: { "@alloc/quick-lru": "^5.2.0", arg: "^5.0.2", chokidar: "^3.5.3", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.3.0", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", jiti: "^1.19.1", lilconfig: "^2.1.0", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.4.23", "postcss-import": "^15.1.0", "postcss-js": "^4.0.1", "postcss-load-config": "^4.0.1", "postcss-nested": "^6.0.1", "postcss-selector-parser": "^6.0.11", resolve: "^1.22.2", sucrase: "^3.32.0" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 30000, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=14.0.0" } };
var mi = typeof process < "u" ? { NODE_ENV: "production", DEBUG: gh(undefined), ENGINE: hi.tailwindcss.engine } : { NODE_ENV: "production", DEBUG: false, ENGINE: hi.tailwindcss.engine };
var gi = new Map;
var Se = new String("*");
var Mt = Symbol("__NONE__");
function gh(t) {
  if (t === undefined)
    return false;
  if (t === "true" || t === "1")
    return true;
  if (t === "false" || t === "0")
    return false;
  if (t === "*")
    return true;
  let e = t.split(",").map((r2) => r2.split(":")[0]);
  return e.includes("-tailwindcss") ? false : !!e.includes("tailwindcss");
}
var yn = H(ye());
var Of = H(of());
var rt = H(kf(), 1);
var Ef = rt.default;
var Ix = rt.default.objectify;
var Rx = rt.default.parse;
var Dx = rt.default.async;
var Mx = rt.default.sync;
function nt(t) {
  return Array.isArray(t) ? t.flatMap((e) => L([(0, Of.default)({ bubble: ["screen"] })]).process(e, { parser: Ef }).root.nodes) : nt([t]);
}
function X(t) {
  if (Object.prototype.toString.call(t) !== "[object Object]")
    return false;
  let e = Object.getPrototypeOf(t);
  return e === null || Object.getPrototypeOf(e) === null;
}
var Af = H(ye());
function it(t, e, r2 = false) {
  if (t === "")
    return e;
  let n = typeof e == "string" ? (0, Af.default)().astSync(e) : e;
  return n.walkClasses((i) => {
    let a = i.value, s = r2 && a.startsWith("-");
    i.value = s ? `-${t}${a.slice(1)}` : `${t}${a}`;
  }), typeof e == "string" ? n.toString() : n;
}
function We(t) {
  return t.replace(/\\,/g, "\\2c ");
}
var bs = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var D0 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var M0 = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Pe = /(?:\d+|\d*\.\d+)%?/;
var tn = /(?:\s*,\s*|\s+)/;
var Cf = /\s*[,/]\s*/;
var Ie = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/;
var L0 = new RegExp(`^(rgba?)\\(\\s*(${Pe.source}|${Ie.source})(?:${tn.source}(${Pe.source}|${Ie.source}))?(?:${tn.source}(${Pe.source}|${Ie.source}))?(?:${Cf.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
var N0 = new RegExp(`^(hsla?)\\(\\s*((?:${Pe.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${tn.source}(${Pe.source}|${Ie.source}))?(?:${tn.source}(${Pe.source}|${Ie.source}))?(?:${Cf.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
function ir(t, { loose: e = false } = {}) {
  var a, s, o;
  if (typeof t != "string")
    return null;
  if (t = t.trim(), t === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t in bs)
    return { mode: "rgb", color: bs[t].map((l) => l.toString()) };
  let r2 = t.replace(M0, (l, u, f, c, p) => ["#", u, u, f, f, c, c, p ? p + p : ""].join("")).match(D0);
  if (r2 !== null)
    return { mode: "rgb", color: [parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16)].map((l) => l.toString()), alpha: r2[4] ? (parseInt(r2[4], 16) / 255).toString() : undefined };
  let n = (a = t.match(L0)) != null ? a : t.match(N0);
  if (n === null)
    return null;
  let i = [n[2], n[3], n[4]].filter(Boolean).map((l) => l.toString());
  return i.length === 2 && i[0].startsWith("var(") ? { mode: n[1], color: [i[0]], alpha: i[1] } : !e && i.length !== 3 || i.length < 3 && !i.some((l) => /^var\(.*?\)$/.test(l)) ? null : { mode: n[1], color: i, alpha: (o = (s = n[5]) == null ? undefined : s.toString) == null ? undefined : o.call(s) };
}
function xs({ mode: t, color: e, alpha: r2 }) {
  let n = r2 !== undefined;
  return t === "rgba" || t === "hsla" ? `${t}(${e.join(", ")}${n ? `, ${r2}` : ""})` : `${t}(${e.join(" ")}${n ? ` / ${r2}` : ""})`;
}
function ve(t, e, r2) {
  if (typeof t == "function")
    return t({ opacityValue: e });
  let n = ir(t, { loose: true });
  return n === null ? r2 : xs({ ...n, alpha: e });
}
function K({ color: t, property: e, variable: r2 }) {
  let n = [].concat(e);
  if (typeof t == "function")
    return { [r2]: "1", ...Object.fromEntries(n.map((a) => [a, t({ opacityVariable: r2, opacityValue: `var(${r2})` })])) };
  let i = ir(t);
  return i === null ? Object.fromEntries(n.map((a) => [a, t])) : i.alpha !== undefined ? Object.fromEntries(n.map((a) => [a, t])) : { [r2]: "1", ...Object.fromEntries(n.map((a) => [a, xs({ ...i, alpha: `var(${r2})` })])) };
}
function Z(t, e) {
  let r2 = [], n = [], i = 0, a = false;
  for (let s = 0;s < t.length; s++) {
    let o = t[s];
    r2.length === 0 && o === e[0] && !a && (e.length === 1 || t.slice(s, s + e.length) === e) && (n.push(t.slice(i, s)), i = s + e.length), a ? a = false : o === "\\" && (a = true), o === "(" || o === "[" || o === "{" ? r2.push(o) : (o === ")" && r2[r2.length - 1] === "(" || o === "]" && r2[r2.length - 1] === "[" || o === "}" && r2[r2.length - 1] === "{") && r2.pop();
  }
  return n.push(t.slice(i)), n;
}
var F0 = new Set(["inset", "inherit", "initial", "revert", "unset"]);
var q0 = /\ +(?![^(]*\))/g;
var _f = /^-?(\d+|\.\d+)(.*?)$/g;
function rn(t) {
  return Z(t, ",").map((r2) => {
    let n = r2.trim(), i = { raw: n }, a = n.split(q0), s = new Set;
    for (let o of a)
      _f.lastIndex = 0, !s.has("KEYWORD") && F0.has(o) ? (i.keyword = o, s.add("KEYWORD")) : _f.test(o) ? s.has("X") ? s.has("Y") ? s.has("BLUR") ? s.has("SPREAD") || (i.spread = o, s.add("SPREAD")) : (i.blur = o, s.add("BLUR")) : (i.y = o, s.add("Y")) : (i.x = o, s.add("X")) : i.color ? (i.unknown || (i.unknown = []), i.unknown.push(o)) : i.color = o;
    return i.valid = i.x !== undefined && i.y !== undefined, i;
  });
}
function Tf(t) {
  return t.map((e) => e.valid ? [e.keyword, e.x, e.y, e.blur, e.spread, e.color].filter(Boolean).join(" ") : e.raw).join(", ");
}
var U0 = ["min", "max", "clamp", "calc"];
function Ss(t) {
  return U0.some((e) => new RegExp(`^${e}\\(.*\\)`).test(t));
}
var $0 = new Set(["scroll-timeline-name", "timeline-scope", "view-timeline-name", "font-palette", "scroll-timeline", "animation-timeline", "view-timeline"]);
function z(t, e = null, r2 = true) {
  let n = e && $0.has(e.property);
  return t.startsWith("--") && !n ? `var(${t})` : t.includes("url(") ? t.split(/(url\(.*?\))/g).filter(Boolean).map((i) => /^url\(.*?\)$/.test(i) ? i : z(i, e, false)).join("") : (t = t.replace(/([^\\])_+/g, (i, a) => a + " ".repeat(i.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), r2 && (t = t.trim()), t = j0(t), t);
}
function j0(t) {
  let e = ["theme"], r2 = ["min-content", "max-content", "fit-content", "safe-area-inset-top", "safe-area-inset-right", "safe-area-inset-bottom", "safe-area-inset-left", "titlebar-area-x", "titlebar-area-y", "titlebar-area-width", "titlebar-area-height", "keyboard-inset-top", "keyboard-inset-right", "keyboard-inset-bottom", "keyboard-inset-left", "keyboard-inset-width", "keyboard-inset-height"];
  return t.replace(/(calc|min|max|clamp)\(.+\)/g, (n) => {
    let i = "";
    function a() {
      let s = i.trimEnd();
      return s[s.length - 1];
    }
    for (let s = 0;s < n.length; s++) {
      let o = function(f) {
        return f.split("").every((c, p) => n[s + p] === c);
      }, l = function(f) {
        let c = 1 / 0;
        for (let d of f) {
          let m = n.indexOf(d, s);
          m !== -1 && m < c && (c = m);
        }
        let p = n.slice(s, c);
        return s += p.length - 1, p;
      }, u = n[s];
      if (o("var"))
        i += l([")", ","]);
      else if (r2.some((f) => o(f))) {
        let f = r2.find((c) => o(c));
        i += f, s += f.length - 1;
      } else
        e.some((f) => o(f)) ? i += l([")"]) : ["+", "-", "*", "/"].includes(u) && !["(", "+", "-", "*", "/", ","].includes(a()) ? i += ` ${u} ` : i += u;
    }
    return i.replace(/\s+/g, " ");
  });
}
function ks(t) {
  return t.startsWith("url(");
}
function Es(t) {
  return !isNaN(Number(t)) || Ss(t);
}
function sr(t) {
  return t.endsWith("%") && Es(t.slice(0, -1)) || Ss(t);
}
var z0 = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var V0 = `(?:${z0.join("|")})`;
function ar(t) {
  return t === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${V0}$`).test(t) || Ss(t);
}
var W0 = new Set(["thin", "medium", "thick"]);
function Pf(t) {
  return W0.has(t);
}
function If(t) {
  let e = rn(z(t));
  for (let r2 of e)
    if (!r2.valid)
      return false;
  return true;
}
function Rf(t) {
  let e = 0;
  return Z(t, "_").every((n) => (n = z(n), n.startsWith("var(") ? true : ir(n, { loose: true }) !== null ? (e++, true) : false)) ? e > 0 : false;
}
function Df(t) {
  let e = 0;
  return Z(t, ",").every((n) => (n = z(n), n.startsWith("var(") ? true : ks(n) || G0(n) || ["element(", "image(", "cross-fade(", "image-set("].some((i) => n.startsWith(i)) ? (e++, true) : false)) ? e > 0 : false;
}
var B0 = new Set(["conic-gradient", "linear-gradient", "radial-gradient", "repeating-conic-gradient", "repeating-linear-gradient", "repeating-radial-gradient"]);
function G0(t) {
  t = z(t);
  for (let e of B0)
    if (t.startsWith(`${e}(`))
      return true;
  return false;
}
var H0 = new Set(["center", "top", "right", "bottom", "left"]);
function Mf(t) {
  let e = 0;
  return Z(t, "_").every((n) => (n = z(n), n.startsWith("var(") ? true : H0.has(n) || ar(n) || sr(n) ? (e++, true) : false)) ? e > 0 : false;
}
function Lf(t) {
  let e = 0;
  return Z(t, ",").every((n) => (n = z(n), n.startsWith("var(") ? true : n.includes(" ") && !/(['"])([^"']+)\1/g.test(n) || /^\d/g.test(n) ? false : (e++, true))) ? e > 0 : false;
}
var Y0 = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
function Nf(t) {
  return Y0.has(t);
}
var Q0 = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
function Ff(t) {
  return Q0.has(t);
}
var J0 = new Set(["larger", "smaller"]);
function qf(t) {
  return J0.has(t);
}
function Re(t) {
  if (t = `${t}`, t === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t))
    return t.replace(/^[+-]?/, (r2) => r2 === "-" ? "" : "-");
  let e = ["var", "calc", "min", "max", "clamp"];
  for (let r2 of e)
    if (t.includes(`${r2}(`))
      return `calc(${t} * -1)`;
}
function Uf(t) {
  let e = ["cover", "contain"];
  return Z(t, ",").every((r2) => {
    let n = Z(r2, "_").filter(Boolean);
    return n.length === 1 && e.includes(n[0]) ? true : n.length !== 1 && n.length !== 2 ? false : n.every((i) => ar(i) || sr(i) || i === "auto");
  });
}
var $f = { optimizeUniversalDefaults: false, generalizedModifiers: true, get disableColorOpacityUtilitiesByDefault() {}, get relativeContentPathsByDefault() {} };
var jf = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
function Y(t, e) {
  var r2, n, i, a, s, o;
  return jf.future.includes(e) ? t.future === "all" || ((i = (n = (r2 = t == null ? undefined : t.future) == null ? undefined : r2[e]) != null ? n : $f[e]) != null ? i : false) : jf.experimental.includes(e) ? t.experimental === "all" || ((o = (s = (a = t == null ? undefined : t.experimental) == null ? undefined : a[e]) != null ? s : $f[e]) != null ? o : false) : false;
}
function Vf(t, e) {
  t.walkClasses((r2) => {
    r2.value = e(r2.value), r2.raws && r2.raws.value && (r2.raws.value = We(r2.raws.value));
  });
}
function Wf(t, e) {
  if (!De(t))
    return;
  let r2 = t.slice(1, -1);
  if (e(r2))
    return z(r2);
}
function X0(t, e = {}, r2) {
  let n = e[t];
  if (n !== undefined)
    return Re(n);
  if (De(t)) {
    let i = Wf(t, r2);
    return i === undefined ? undefined : Re(i);
  }
}
function nn(t, e = {}, { validate: r2 = () => true } = {}) {
  var i;
  let n = (i = e.values) == null ? undefined : i[t];
  return n !== undefined ? n : e.supportsNegativeValues && t.startsWith("-") ? X0(t.slice(1), e.values, r2) : Wf(t, r2);
}
function De(t) {
  return t.startsWith("[") && t.endsWith("]");
}
function Bf(t) {
  let e = t.lastIndexOf("/"), r2 = t.lastIndexOf("[", e), n = t.indexOf("]", e);
  return t[e - 1] === "]" || t[e + 1] === "[" || r2 !== -1 && n !== -1 && r2 < e && e < n && (e = t.lastIndexOf("/", r2)), e === -1 || e === t.length - 1 ? [t, undefined] : De(t) && !t.includes("]/[") ? [t, undefined] : [t.slice(0, e), t.slice(e + 1)];
}
function st(t) {
  if (typeof t == "string" && t.includes("<alpha-value>")) {
    let e = t;
    return ({ opacityValue: r2 = 1 }) => e.replace("<alpha-value>", r2);
  }
  return t;
}
function Gf(t) {
  return z(t.slice(1, -1));
}
function K0(t, e = {}, { tailwindConfig: r2 = {} } = {}) {
  var a, s, o, l, u, f;
  if (((a = e.values) == null ? undefined : a[t]) !== undefined)
    return st((s = e.values) == null ? undefined : s[t]);
  let [n, i] = Bf(t);
  if (i !== undefined) {
    let c = (l = (o = e.values) == null ? undefined : o[n]) != null ? l : De(n) ? n.slice(1, -1) : undefined;
    return c === undefined ? undefined : (c = st(c), De(i) ? ve(c, Gf(i)) : ((f = (u = r2.theme) == null ? undefined : u.opacity) == null ? undefined : f[i]) === undefined ? undefined : ve(c, r2.theme.opacity[i]));
  }
  return nn(t, e, { validate: Rf });
}
function Z0(t, e = {}) {
  var r2;
  return (r2 = e.values) == null ? undefined : r2[t];
}
function ae(t) {
  return (e, r2) => nn(e, r2, { validate: t });
}
var Os = { any: nn, color: K0, url: ae(ks), image: ae(Df), length: ae(ar), percentage: ae(sr), position: ae(Mf), lookup: Z0, "generic-name": ae(Nf), "family-name": ae(Lf), number: ae(Es), "line-width": ae(Pf), "absolute-size": ae(Ff), "relative-size": ae(qf), shadow: ae(If), size: ae(Uf) };
var zf = Object.keys(Os);
function ev(t, e) {
  let r2 = t.indexOf(e);
  return r2 === -1 ? [undefined, t] : [t.slice(0, r2), t.slice(r2 + 1)];
}
function As(t, e, r2, n) {
  if (r2.values && e in r2.values)
    for (let { type: a } of t != null ? t : []) {
      let s = Os[a](e, r2, { tailwindConfig: n });
      if (s !== undefined)
        return [s, a, null];
    }
  if (De(e)) {
    let a = e.slice(1, -1), [s, o] = ev(a, ":");
    if (!/^[\w-_]+$/g.test(s))
      o = a;
    else if (s !== undefined && !zf.includes(s))
      return [];
    if (o.length > 0 && zf.includes(s))
      return [nn(`[${o}]`, r2), s, null];
  }
  let i = Cs(t, e, r2, n);
  for (let a of i)
    return a;
  return [];
}
function* Cs(t, e, r2, n) {
  var l, u;
  let i = Y(n, "generalizedModifiers"), [a, s] = Bf(e);
  if (i && r2.modifiers != null && (r2.modifiers === "any" || typeof r2.modifiers == "object" && (s && De(s) || (s in r2.modifiers))) || (a = e, s = undefined), s !== undefined && a === "" && (a = "DEFAULT"), s !== undefined && typeof r2.modifiers == "object") {
    let f = (u = (l = r2.modifiers) == null ? undefined : l[s]) != null ? u : null;
    f !== null ? s = f : De(s) && (s = Gf(s));
  }
  for (let { type: f } of t != null ? t : []) {
    let c = Os[f](a, r2, { tailwindConfig: n });
    c !== undefined && (yield [c, f, s != null ? s : null]);
  }
}
var we = H(ye());
var Xf = H(jr());
var Hf = H(ye());
function te(t) {
  var r2, n;
  let e = Hf.default.className();
  return e.value = t, We((n = (r2 = e == null ? undefined : e.raws) == null ? undefined : r2.value) != null ? n : e.value);
}
var _s = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal", "jumpable"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal", "jumpable"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal", "jumpable"], "::selection": ["terminal", "jumpable"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::deep": ["actionable"], "::v-deep": ["actionable"], "::ng-deep": ["actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], __default__: ["terminal", "actionable"] };
function at(t) {
  let [e] = Yf(t);
  return e.forEach(([r2, n]) => r2.removeChild(n)), t.nodes.push(...e.map(([, r2]) => r2)), t;
}
function Yf(t) {
  var n;
  let e = [], r2 = null;
  for (let i of t.nodes)
    if (i.type === "combinator")
      e = e.filter(([, a]) => Ts(a).includes("jumpable")), r2 = null;
    else if (i.type === "pseudo") {
      tv(i) ? (r2 = i, e.push([t, i, null])) : r2 && rv(i, r2) ? e.push([t, i, r2]) : r2 = null;
      for (let a of (n = i.nodes) != null ? n : []) {
        let [s, o] = Yf(a);
        r2 = o || r2, e.push(...s);
      }
    }
  return [e, r2];
}
function Qf(t) {
  return t.value.startsWith("::") || _s[t.value] !== undefined;
}
function tv(t) {
  return Qf(t) && Ts(t).includes("terminal");
}
function rv(t, e) {
  return t.type !== "pseudo" || Qf(t) ? false : Ts(e).includes("actionable");
}
function Ts(t) {
  var e;
  return (e = _s[t.value]) != null ? e : _s.__default__;
}
var Ps = ":merge";
function ot(t, { context: e, candidate: r2 }) {
  var s;
  let n = (s = e == null ? undefined : e.tailwindConfig.prefix) != null ? s : "", i = t.map((o) => {
    let l = (0, we.default)().astSync(o.format);
    return { ...o, ast: o.respectPrefix ? it(n, l) : l };
  }), a = we.default.root({ nodes: [we.default.selector({ nodes: [we.default.className({ value: te(r2) })] })] });
  for (let { ast: o } of i)
    [a, o] = iv(a, o), o.walkNesting((l) => l.replaceWith(...a.nodes[0].nodes)), a = o;
  return a;
}
function Jf(t) {
  let e = [];
  for (;t.prev() && t.prev().type !== "combinator"; )
    t = t.prev();
  for (;t && t.type !== "combinator"; )
    e.push(t), t = t.next();
  return e;
}
function nv(t) {
  return t.sort((e, r2) => e.type === "tag" && r2.type === "class" ? -1 : e.type === "class" && r2.type === "tag" ? 1 : e.type === "class" && r2.type === "pseudo" && r2.value.startsWith("::") ? -1 : e.type === "pseudo" && e.value.startsWith("::") && r2.type === "class" ? 1 : t.index(e) - t.index(r2)), t;
}
function Is(t, e) {
  let r2 = false;
  t.walk((n) => {
    if (n.type === "class" && n.value === e)
      return r2 = true, false;
  }), r2 || t.remove();
}
function sn(t, e, { context: r2, candidate: n, base: i }) {
  var f, c;
  let a = (c = (f = r2 == null ? undefined : r2.tailwindConfig) == null ? undefined : f.separator) != null ? c : ":";
  i = i != null ? i : Z(n, a).pop();
  let s = (0, we.default)().astSync(t);
  if (s.walkClasses((p) => {
    p.raws && p.value.includes(i) && (p.raws.value = te((0, Xf.default)(p.raws.value)));
  }), s.each((p) => Is(p, i)), s.length === 0)
    return null;
  let o = Array.isArray(e) ? ot(e, { context: r2, candidate: n }) : e;
  if (o === null)
    return s.toString();
  let l = we.default.comment({ value: "/*__simple__*/" }), u = we.default.comment({ value: "/*__simple__*/" });
  return s.walkClasses((p) => {
    if (p.value !== i)
      return;
    let d = p.parent, m = o.nodes[0].nodes;
    if (d.nodes.length === 1) {
      p.replaceWith(...m);
      return;
    }
    let w = Jf(p);
    d.insertBefore(w[0], l), d.insertAfter(w[w.length - 1], u);
    for (let g of m)
      d.insertBefore(w[0], g.clone());
    p.remove(), w = Jf(l);
    let h = d.index(l);
    d.nodes.splice(h, w.length, ...nv(we.default.selector({ nodes: w })).nodes), l.remove(), u.remove();
  }), s.walkPseudos((p) => {
    p.value === Ps && p.replaceWith(p.nodes);
  }), s.each((p) => at(p)), s.toString();
}
function iv(t, e) {
  let r2 = [];
  return t.walkPseudos((n) => {
    n.value === Ps && r2.push({ pseudo: n, value: n.nodes[0].toString() });
  }), e.walkPseudos((n) => {
    if (n.value !== Ps)
      return;
    let i = n.nodes[0].toString(), a = r2.find((u) => u.value === i);
    if (!a)
      return;
    let s = [], o = n.next();
    for (;o && o.type !== "combinator"; )
      s.push(o), o = o.next();
    let l = o;
    a.pseudo.parent.insertAfter(a.pseudo, we.default.selector({ nodes: s.map((u) => u.clone()) })), n.remove(), s.forEach((u) => u.remove()), l && l.type === "combinator" && l.remove();
  }), [t, e];
}
function Rs(t) {
  return We(`.${te(t)}`);
}
function an(t, e) {
  return Rs(or(t, e));
}
function or(t, e) {
  return e === "DEFAULT" ? t : e === "-" || e === "-DEFAULT" ? `-${t}` : e.startsWith("-") ? `-${t}${e}` : e.startsWith("/") ? `${t}${e}` : `${t}-${e}`;
}
var lc = H(Ls());
var $s = H(ye());
function Oe(t) {
  return ["fontSize", "outline"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e) : t === "fontFamily" ? (e) => {
    typeof e == "function" && (e = e({}));
    let r2 = Array.isArray(e) && X(e[1]) ? e[0] : e;
    return Array.isArray(r2) ? r2.join(", ") : r2;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), typeof e == "string" && (e = L.list.comma(e).join(" ")), e) : (e, r2 = {}) => (typeof e == "function" && (e = e(r2)), e);
}
Sr();
xt();
function T(t, e = [[t, [t]]], { filterDefault: r2 = false, ...n } = {}) {
  let i = Oe(t);
  return function({ matchUtilities: a, theme: s }) {
    var o;
    for (let l of e) {
      let u = Array.isArray(l[0]) ? l : [l];
      a(u.reduce((f, [c, p]) => Object.assign(f, { [c]: (d) => p.reduce((m, w) => Array.isArray(w) ? Object.assign(m, { [w[0]]: w[1] }) : Object.assign(m, { [w]: i(d) }), {}) }), {}), { ...n, values: r2 ? Object.fromEntries(Object.entries((o = s(t)) != null ? o : {}).filter(([f]) => f !== "DEFAULT")) : s(t) });
    }
  };
}
function Me(t) {
  return t = Array.isArray(t) ? t : [t], t.map((e) => {
    let r2 = e.values.map((n) => n.raw !== undefined ? n.raw : [n.min && `(min-width: ${n.min})`, n.max && `(max-width: ${n.max})`].filter(Boolean).join(" and "));
    return e.not ? `not all and ${r2}` : r2;
  }).join(", ");
}
var sv = new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var av = new Set(["running", "paused"]);
var ov = new Set(["none", "forwards", "backwards", "both"]);
var lv = new Set(["infinite"]);
var uv = new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var fv = ["cubic-bezier", "steps"];
var cv = /\,(?![^(]*\))/g;
var pv = /\ +(?![^(]*\))/g;
var Kf = /^(-?[\d.]+m?s)$/;
var dv = /^(\d+)$/;
function Ns(t) {
  return t.split(cv).map((r2) => {
    let n = r2.trim(), i = { value: n }, a = n.split(pv), s = new Set;
    for (let o of a)
      !s.has("DIRECTIONS") && sv.has(o) ? (i.direction = o, s.add("DIRECTIONS")) : !s.has("PLAY_STATES") && av.has(o) ? (i.playState = o, s.add("PLAY_STATES")) : !s.has("FILL_MODES") && ov.has(o) ? (i.fillMode = o, s.add("FILL_MODES")) : !s.has("ITERATION_COUNTS") && (lv.has(o) || dv.test(o)) ? (i.iterationCount = o, s.add("ITERATION_COUNTS")) : !s.has("TIMING_FUNCTION") && uv.has(o) || !s.has("TIMING_FUNCTION") && fv.some((l) => o.startsWith(`${l}(`)) ? (i.timingFunction = o, s.add("TIMING_FUNCTION")) : !s.has("DURATION") && Kf.test(o) ? (i.duration = o, s.add("DURATION")) : !s.has("DELAY") && Kf.test(o) ? (i.delay = o, s.add("DELAY")) : s.has("NAME") ? (i.unknown || (i.unknown = []), i.unknown.push(o)) : (i.name = o, s.add("NAME"));
    return i;
  });
}
var Zf = (t) => Object.assign({}, ...Object.entries(t != null ? t : {}).flatMap(([e, r2]) => typeof r2 == "object" ? Object.entries(Zf(r2)).map(([n, i]) => ({ [e + (n === "DEFAULT" ? "" : `-${n}`)]: i })) : [{ [`${e}`]: r2 }]));
var Q = Zf;
function M(t) {
  return typeof t == "function" ? t({}) : t;
}
function Le(t, e = true) {
  return Array.isArray(t) ? t.map((r2) => {
    if (e && Array.isArray(r2))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r2 == "string")
      return { name: r2.toString(), not: false, values: [{ min: r2, max: undefined }] };
    let [n, i] = r2;
    return n = n.toString(), typeof i == "string" ? { name: n, not: false, values: [{ min: i, max: undefined }] } : Array.isArray(i) ? { name: n, not: false, values: i.map((a) => ec(a)) } : { name: n, not: false, values: [ec(i)] };
  }) : Le(Object.entries(t != null ? t : {}), false);
}
function on(t) {
  return t.values.length !== 1 ? { result: false, reason: "multiple-values" } : t.values[0].raw !== undefined ? { result: false, reason: "raw-values" } : t.values[0].min !== undefined && t.values[0].max !== undefined ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
}
function tc(t, e, r2) {
  let n = ln(e, t), i = ln(r2, t), a = on(n), s = on(i);
  if (a.reason === "multiple-values" || s.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (a.reason === "raw-values" || s.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (a.reason === "min-and-max" || s.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o, max: l } = n.values[0], { min: u, max: f } = i.values[0];
  e.not && ([o, l] = [l, o]), r2.not && ([u, f] = [f, u]), o = o === undefined ? o : parseFloat(o), l = l === undefined ? l : parseFloat(l), u = u === undefined ? u : parseFloat(u), f = f === undefined ? f : parseFloat(f);
  let [c, p] = t === "min" ? [o, u] : [f, l];
  return c - p;
}
function ln(t, e) {
  return typeof t == "object" ? t : { name: "arbitrary-screen", values: [{ [e]: t }] };
}
function ec({ "min-width": t, min: e = t, max: r2, raw: n } = {}) {
  return { min: e, max: r2, raw: n };
}
function un(t, e) {
  t.walkDecls((r2) => {
    if (e.includes(r2.prop)) {
      r2.remove();
      return;
    }
    for (let n of e)
      r2.value.includes(`/ var(${n})`) && (r2.value = r2.value.replace(`/ var(${n})`, ""));
  });
}
var re = { pseudoElementVariants: ({ addVariant: t }) => {
  t("first-letter", "&::first-letter"), t("first-line", "&::first-line"), t("marker", [({ container: e }) => (un(e, ["--tw-text-opacity"]), "& *::marker"), ({ container: e }) => (un(e, ["--tw-text-opacity"]), "&::marker")]), t("selection", ["& *::selection", "&::selection"]), t("file", "&::file-selector-button"), t("placeholder", "&::placeholder"), t("backdrop", "&::backdrop"), t("before", ({ container: e }) => (e.walkRules((r2) => {
    let n = false;
    r2.walkDecls("content", () => {
      n = true;
    }), n || r2.prepend(L.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t("after", ({ container: e }) => (e.walkRules((r2) => {
    let n = false;
    r2.walkDecls("content", () => {
      n = true;
    }), n || r2.prepend(L.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t, matchVariant: e, config: r2, prefix: n }) => {
  let i = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: s }) => (un(s, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", Y(r2(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((s) => Array.isArray(s) ? s : [s, `&:${s}`]);
  for (let [s, o] of i)
    t(s, (l) => typeof o == "function" ? o(l) : o);
  let a = { group: (s, { modifier: o }) => o ? [`:merge(${n(".group")}\\/${te(o)})`, " &"] : [`:merge(${n(".group")})`, " &"], peer: (s, { modifier: o }) => o ? [`:merge(${n(".peer")}\\/${te(o)})`, " ~ &"] : [`:merge(${n(".peer")})`, " ~ &"] };
  for (let [s, o] of Object.entries(a))
    e(s, (l = "", u) => {
      let f = z(typeof l == "function" ? l(u) : l);
      f.includes("&") || (f = "&" + f);
      let [c, p] = o("", u), d = null, m = null, w = 0;
      for (let h = 0;h < f.length; ++h) {
        let g = f[h];
        g === "&" ? d = h : g === "'" || g === '"' ? w += 1 : d !== null && g === " " && !w && (m = h);
      }
      return d !== null && m === null && (m = f.length), f.slice(0, d) + c + f.slice(d + 1, m) + p + f.slice(m);
    }, { values: Object.fromEntries(i), [lr]: { respectPrefix: false } });
}, directionVariants: ({ addVariant: t }) => {
  t("ltr", ':is([dir="ltr"] &)'), t("rtl", ':is([dir="rtl"] &)');
}, reducedMotionVariants: ({ addVariant: t }) => {
  t("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t, addVariant: e }) => {
  let [r2, n = ".dark"] = [].concat(t("darkMode", "media"));
  r2 === false && (r2 = "media", F.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r2 === "class" ? e("dark", `:is(${n} &)`) : r2 === "media" && e("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t }) => {
  t("print", "@media print");
}, screenVariants: ({ theme: t, addVariant: e, matchVariant: r2 }) => {
  var g;
  let n = (g = t("screens")) != null ? g : {}, i = Object.values(n).every((y) => typeof y == "string"), a = Le(t("screens")), s = new Set([]);
  function o(y) {
    var b, v;
    return (v = (b = y.match(/(\D+)$/)) == null ? undefined : b[1]) != null ? v : "(none)";
  }
  function l(y) {
    y !== undefined && s.add(o(y));
  }
  function u(y) {
    return l(y), s.size === 1;
  }
  for (let y of a)
    for (let b of y.values)
      l(b.min), l(b.max);
  let f = s.size <= 1;
  function c(y) {
    return Object.fromEntries(a.filter((b) => on(b).result).map((b) => {
      let { min: v, max: O } = b.values[0];
      if (y === "min" && v !== undefined)
        return b;
      if (y === "min" && O !== undefined)
        return { ...b, not: !b.not };
      if (y === "max" && O !== undefined)
        return b;
      if (y === "max" && v !== undefined)
        return { ...b, not: !b.not };
    }).map((b) => [b.name, b]));
  }
  function p(y) {
    return (b, v) => tc(y, b.value, v.value);
  }
  let d = p("max"), m = p("min");
  function w(y) {
    return (b) => {
      if (i)
        if (f) {
          if (typeof b == "string" && !u(b))
            return F.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return F.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return F.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Me(ln(b, y))}`];
    };
  }
  r2("max", w("max"), { sort: d, values: i ? c("max") : {} });
  let h = "min-screens";
  for (let y of a)
    e(y.name, `@media ${Me(y)}`, { id: h, sort: i && f ? m : undefined, value: y });
  r2("min", w("min"), { id: h, sort: m });
}, supportsVariants: ({ matchVariant: t, theme: e }) => {
  var r2;
  t("supports", (n = "") => {
    let i = z(n), a = /^\w*\s*\(/.test(i);
    return i = a ? i.replace(/\b(and|or|not)\b/g, " $1 ") : i, a ? `@supports ${i}` : (i.includes(":") || (i = `${i}: var(--tw)`), i.startsWith("(") && i.endsWith(")") || (i = `(${i})`), `@supports ${i}`);
  }, { values: (r2 = e("supports")) != null ? r2 : {} });
}, ariaVariants: ({ matchVariant: t, theme: e }) => {
  var r2, n, i;
  t("aria", (a) => `&[aria-${z(a)}]`, { values: (r2 = e("aria")) != null ? r2 : {} }), t("group-aria", (a, { modifier: s }) => s ? `:merge(.group\\/${s})[aria-${z(a)}] &` : `:merge(.group)[aria-${z(a)}] &`, { values: (n = e("aria")) != null ? n : {} }), t("peer-aria", (a, { modifier: s }) => s ? `:merge(.peer\\/${s})[aria-${z(a)}] ~ &` : `:merge(.peer)[aria-${z(a)}] ~ &`, { values: (i = e("aria")) != null ? i : {} });
}, dataVariants: ({ matchVariant: t, theme: e }) => {
  var r2, n, i;
  t("data", (a) => `&[data-${z(a)}]`, { values: (r2 = e("data")) != null ? r2 : {} }), t("group-data", (a, { modifier: s }) => s ? `:merge(.group\\/${s})[data-${z(a)}] &` : `:merge(.group)[data-${z(a)}] &`, { values: (n = e("data")) != null ? n : {} }), t("peer-data", (a, { modifier: s }) => s ? `:merge(.peer\\/${s})[data-${z(a)}] ~ &` : `:merge(.peer)[data-${z(a)}] ~ &`, { values: (i = e("data")) != null ? i : {} });
}, orientationVariants: ({ addVariant: t }) => {
  t("portrait", "@media (orientation: portrait)"), t("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t }) => {
  t("contrast-more", "@media (prefers-contrast: more)"), t("contrast-less", "@media (prefers-contrast: less)");
} };
var he = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var be = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var xe = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var rc = { preflight: ({ addBase: t }) => {
  let e = L.parse(St.readFileSync(Nn("/", "./css/preflight.css"), "utf8"));
  t([L.comment({ text: `! tailwindcss v${Hl} | MIT License | https://tailwindcss.com` }), ...e.nodes]);
}, container: (() => {
  function t(r2 = []) {
    return r2.flatMap((n) => n.values.map((i) => i.min)).filter((n) => n !== undefined);
  }
  function e(r2, n, i) {
    if (typeof i > "u")
      return [];
    if (!(typeof i == "object" && i !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i }];
    let a = [];
    i.DEFAULT && a.push({ screen: "DEFAULT", minWidth: 0, padding: i.DEFAULT });
    for (let s of r2)
      for (let o of n)
        for (let { min: l } of o.values)
          l === s && a.push({ minWidth: s, padding: i[o.name] });
    return a;
  }
  return function({ addComponents: r2, theme: n }) {
    let i = Le(n("container.screens", n("screens"))), a = t(i), s = e(a, i, n("container.padding")), o = (u) => {
      let f = s.find((c) => c.minWidth === u);
      return f ? { paddingRight: f.padding, paddingLeft: f.padding } : {};
    }, l = Array.from(new Set(a.slice().sort((u, f) => parseInt(u) - parseInt(f)))).map((u) => ({ [`@media (min-width: ${u})`]: { ".container": { "max-width": u, ...o(u) } } }));
    r2([{ ".container": Object.assign({ width: "100%" }, n("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o(0)) }, ...l]);
  };
})(), accessibility: ({ addUtilities: t }) => {
  t({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t }) => {
  t({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t }) => {
  t({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t }) => {
  t({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t }) => {
  t({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T("order", undefined, { supportsNegativeValues: true }), gridColumn: T("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T("gridRow", [["row", ["gridRow"]]]), gridRowStart: T("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t }) => {
  t({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t }) => {
  t({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t }) => {
  t({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, lineClamp: ({ matchUtilities: t, addUtilities: e, theme: r2 }) => {
  t({ "line-clamp": (n) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${n}` }) }, { values: r2("lineClamp") }), e({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
}, display: ({ addUtilities: t }) => {
  t({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T("height", [["h", ["height"]]]), maxHeight: T("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T("minHeight", [["min-h", ["minHeight"]]]), width: T("width", [["w", ["width"]]]), minWidth: T("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T("maxWidth", [["max-w", ["maxWidth"]]]), flex: T("flex"), flexShrink: T("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t }) => {
  t({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, captionSide: ({ addUtilities: t }) => {
  t({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
}, borderCollapse: ({ addUtilities: t }) => {
  t({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t, matchUtilities: e, theme: r2 }) => {
  t("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e({ "border-spacing": (n) => ({ "--tw-border-spacing-x": n, "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n) => ({ "--tw-border-spacing-x": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n) => ({ "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r2("borderSpacing") });
}, transformOrigin: T("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he]]]]], { supportsNegativeValues: true }), rotate: T("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he]]]], { supportsNegativeValues: true }), skew: T("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he]]]]], { supportsNegativeValues: true }), scale: T("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t, addUtilities: e }) => {
  t("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e({ ".transform": { "@defaults transform": {}, transform: he }, ".transform-cpu": { transform: he }, ".transform-gpu": { transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t, theme: e, config: r2 }) => {
  var a;
  let n = (s) => te(r2("prefix") + s), i = Object.fromEntries(Object.entries((a = e("keyframes")) != null ? a : {}).map(([s, o]) => [s, { [`@keyframes ${n(s)}`]: o }]));
  t({ animate: (s) => {
    let o = Ns(s);
    return [...o.flatMap((l) => i[l.name]), { animation: o.map(({ name: l, value: u }) => l === undefined || i[l] === undefined ? u : u.replace(l, n(l))).join(", ") }];
  } }, { values: e("animation") });
}, cursor: T("cursor"), touchAction: ({ addDefaults: t, addUtilities: e }) => {
  t("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r2 = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r2 }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r2 }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r2 }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r2 }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r2 }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r2 }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r2 }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t }) => {
  t({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t }) => {
  t({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t, addUtilities: e }) => {
  t("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t }) => {
  t({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t }) => {
  t({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t }) => {
  t({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: T("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: t }) => {
  t({ ".appearance-none": { appearance: "none" } });
}, columns: T("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t }) => {
  t({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t }) => {
  t({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t }) => {
  t({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t }) => {
  t({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t }) => {
  t({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t }) => {
  t({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t }) => {
  t({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t }) => {
  t({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t }) => {
  t({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
}, alignItems: ({ addUtilities: t }) => {
  t({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t }) => {
  t({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
}, justifyItems: ({ addUtilities: t }) => {
  t({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t, addUtilities: e, theme: r2 }) => {
  t({ "space-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n} * var(--tw-space-y-reverse))` } }) }, { values: r2("space"), supportsNegativeValues: true }), e({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t, addUtilities: e, theme: r2 }) => {
  t({ "divide-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n} * var(--tw-divide-y-reverse))` } }) }, { values: r2("divideWidth"), type: ["line-width", "length", "any"] }), e({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t }) => {
  t({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ divide: (n) => r2("divideOpacity") ? { "& > :not([hidden]) ~ :not([hidden])": K({ color: n, property: "border-color", variable: "--tw-divide-opacity" }) } : { "& > :not([hidden]) ~ :not([hidden])": { "border-color": M(n) } } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "divide-opacity": (r2) => ({ "& > :not([hidden]) ~ :not([hidden])": { "--tw-divide-opacity": r2 } }) }, { values: e("divideOpacity") });
}, placeSelf: ({ addUtilities: t }) => {
  t({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t }) => {
  t({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t }) => {
  t({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t }) => {
  t({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t }) => {
  t({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t }) => {
  t({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t }) => {
  t({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, hyphens: ({ addUtilities: t }) => {
  t({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
}, whitespace: ({ addUtilities: t }) => {
  t({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
}, wordBreak: ({ addUtilities: t }) => {
  t({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t }) => {
  t({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ border: (n) => r2("borderOpacity") ? K({ color: n, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] }), t({ "border-x": (n) => r2("borderOpacity") ? K({ color: n, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": M(n), "border-right-color": M(n) }, "border-y": (n) => r2("borderOpacity") ? K({ color: n, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": M(n), "border-bottom-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] }), t({ "border-s": (n) => r2("borderOpacity") ? K({ color: n, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": M(n) }, "border-e": (n) => r2("borderOpacity") ? K({ color: n, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": M(n) }, "border-t": (n) => r2("borderOpacity") ? K({ color: n, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": M(n) }, "border-r": (n) => r2("borderOpacity") ? K({ color: n, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": M(n) }, "border-b": (n) => r2("borderOpacity") ? K({ color: n, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": M(n) }, "border-l": (n) => r2("borderOpacity") ? K({ color: n, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ bg: (n) => r2("backgroundOpacity") ? K({ color: n, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": M(n) } }, { values: Q(e("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t(e) {
    return ve(e, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e, theme: r2, addDefaults: n }) {
    n("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
    let i = { values: Q(r2("gradientColorStops")), type: ["color", "any"] }, a = { values: r2("gradientColorStopPositions"), type: ["length", "percentage"] };
    e({ from: (s) => {
      let o = t(s);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${M(s)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${o} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, i), e({ from: (s) => ({ "--tw-gradient-from-position": s }) }, a), e({ via: (s) => {
      let o = t(s);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${o}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${M(s)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
    } }, i), e({ via: (s) => ({ "--tw-gradient-via-position": s }) }, a), e({ to: (s) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${M(s)} var(--tw-gradient-to-position)` }) }, i), e({ to: (s) => ({ "--tw-gradient-to-position": s }) }, a);
  };
})(), boxDecorationBreak: ({ addUtilities: t }) => {
  t({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t }) => {
  t({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t }) => {
  t({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t }) => {
  t({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t }) => {
  t({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t, theme: e }) => {
  t({ fill: (r2) => ({ fill: M(r2) }) }, { values: Q(e("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t, theme: e }) => {
  t({ stroke: (r2) => ({ stroke: M(r2) }) }, { values: Q(e("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t }) => {
  t({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T("objectPosition", [["object", ["object-position"]]]), padding: T("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t }) => {
  t({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t, matchUtilities: e }) => {
  t({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e({ align: (r2) => ({ "vertical-align": r2 }) });
}, fontFamily: ({ matchUtilities: t, theme: e }) => {
  t({ font: (r2) => {
    let [n, i = {}] = Array.isArray(r2) && X(r2[1]) ? r2 : [r2], { fontFeatureSettings: a, fontVariationSettings: s } = i;
    return { "font-family": Array.isArray(n) ? n.join(", ") : n, ...a === undefined ? {} : { "font-feature-settings": a }, ...s === undefined ? {} : { "font-variation-settings": s } };
  } }, { values: e("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t, theme: e }) => {
  t({ text: (r2, { modifier: n }) => {
    let [i, a] = Array.isArray(r2) ? r2 : [r2];
    if (n)
      return { "font-size": i, "line-height": n };
    let { lineHeight: s, letterSpacing: o, fontWeight: l } = X(a) ? a : { lineHeight: a };
    return { "font-size": i, ...s === undefined ? {} : { "line-height": s }, ...o === undefined ? {} : { "letter-spacing": o }, ...l === undefined ? {} : { "font-weight": l } };
  } }, { values: e("fontSize"), modifiers: e("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t }) => {
  t({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t }) => {
  t({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t, addUtilities: e }) => {
  let r2 = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r2 }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r2 }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r2 }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r2 }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r2 }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r2 }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r2 }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r2 } });
}, lineHeight: T("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ text: (n) => r2("textOpacity") ? K({ color: n, property: "color", variable: "--tw-text-opacity" }) : { color: M(n) } }, { values: Q(e("textColor")), type: ["color", "any"] });
}, textOpacity: T("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t }) => {
  t({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t, theme: e }) => {
  t({ decoration: (r2) => ({ "text-decoration-color": M(r2) }) }, { values: Q(e("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t }) => {
  t({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t }) => {
  t({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ placeholder: (n) => r2("placeholderOpacity") ? { "&::placeholder": K({ color: n, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: M(n) } } }, { values: Q(e("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "placeholder-opacity": (r2) => ({ "&::placeholder": { "--tw-placeholder-opacity": r2 } }) }, { values: e("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t, theme: e }) => {
  t({ caret: (r2) => ({ "caret-color": M(r2) }) }, { values: Q(e("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t, theme: e }) => {
  t({ accent: (r2) => ({ "accent-color": M(r2) }) }, { values: Q(e("accentColor")), type: ["color", "any"] });
}, opacity: T("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t }) => {
  t({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t }) => {
  t({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t = Oe("boxShadow"), e = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r2, addDefaults: n, theme: i }) {
    n(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r2({ shadow: (a) => {
      a = t(a);
      let s = rn(a);
      for (let o of s)
        o.valid && (o.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": a === "none" ? "0 0 #0000" : a, "--tw-shadow-colored": a === "none" ? "0 0 #0000" : Tf(s), "box-shadow": e };
    } }, { values: i("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t, theme: e }) => {
  t({ shadow: (r2) => ({ "--tw-shadow-color": M(r2), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: Q(e("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t }) => {
  t({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t, theme: e }) => {
  t({ outline: (r2) => ({ "outline-color": M(r2) }) }, { values: Q(e("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t, addDefaults: e, addUtilities: r2, theme: n, config: i }) => {
  let a = (() => {
    var o, l;
    if (Y(i(), "respectDefaultRingColorOpacity"))
      return n("ringColor.DEFAULT");
    let s = n("ringOpacity.DEFAULT", "0.5");
    return (o = n("ringColor")) != null && o.DEFAULT ? ve((l = n("ringColor")) == null ? undefined : l.DEFAULT, s, `rgb(147 197 253 / ${s})`) : `rgb(147 197 253 / ${s})`;
  })();
  e("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": a, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t({ ring: (s) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${s} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n("ringWidth"), type: "length" }), r2({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t, theme: e, corePlugins: r2 }) => {
  t({ ring: (n) => r2("ringOpacity") ? K({ color: n, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": M(n) } }, { values: Object.fromEntries(Object.entries(Q(e("ringColor"))).filter(([n]) => n !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t) => {
  let { config: e } = t;
  return T("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !Y(e(), "respectDefaultRingColorOpacity") })(t);
}, ringOffsetWidth: T("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t, theme: e }) => {
  t({ "ring-offset": (r2) => ({ "--tw-ring-offset-color": M(r2) }) }, { values: Q(e("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t, theme: e }) => {
  t({ blur: (r2) => ({ "--tw-blur": `blur(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("blur") });
}, brightness: ({ matchUtilities: t, theme: e }) => {
  t({ brightness: (r2) => ({ "--tw-brightness": `brightness(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("brightness") });
}, contrast: ({ matchUtilities: t, theme: e }) => {
  t({ contrast: (r2) => ({ "--tw-contrast": `contrast(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("contrast") });
}, dropShadow: ({ matchUtilities: t, theme: e }) => {
  t({ "drop-shadow": (r2) => ({ "--tw-drop-shadow": Array.isArray(r2) ? r2.map((n) => `drop-shadow(${n})`).join(" ") : `drop-shadow(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("dropShadow") });
}, grayscale: ({ matchUtilities: t, theme: e }) => {
  t({ grayscale: (r2) => ({ "--tw-grayscale": `grayscale(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("grayscale") });
}, hueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "hue-rotate": (r2) => ({ "--tw-hue-rotate": `hue-rotate(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t, theme: e }) => {
  t({ invert: (r2) => ({ "--tw-invert": `invert(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("invert") });
}, saturate: ({ matchUtilities: t, theme: e }) => {
  t({ saturate: (r2) => ({ "--tw-saturate": `saturate(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("saturate") });
}, sepia: ({ matchUtilities: t, theme: e }) => {
  t({ sepia: (r2) => ({ "--tw-sepia": `sepia(${r2})`, "@defaults filter": {}, filter: be }) }, { values: e("sepia") });
}, filter: ({ addDefaults: t, addUtilities: e }) => {
  t("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e({ ".filter": { "@defaults filter": {}, filter: be }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-blur": (r2) => ({ "--tw-backdrop-blur": `blur(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-brightness": (r2) => ({ "--tw-backdrop-brightness": `brightness(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-contrast": (r2) => ({ "--tw-backdrop-contrast": `contrast(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-grayscale": (r2) => ({ "--tw-backdrop-grayscale": `grayscale(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-hue-rotate": (r2) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-invert": (r2) => ({ "--tw-backdrop-invert": `invert(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-opacity": (r2) => ({ "--tw-backdrop-opacity": `opacity(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-saturate": (r2) => ({ "--tw-backdrop-saturate": `saturate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-sepia": (r2) => ({ "--tw-backdrop-sepia": `sepia(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": xe }) }, { values: e("backdropSepia") });
}, backdropFilter: ({ addDefaults: t, addUtilities: e }) => {
  t("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": xe }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t, theme: e }) => {
  let r2 = e("transitionTimingFunction.DEFAULT"), n = e("transitionDuration.DEFAULT");
  t({ transition: (i) => ({ "transition-property": i, ...i === "none" ? {} : { "transition-timing-function": r2, "transition-duration": n } }) }, { values: e("transitionProperty") });
}, transitionDelay: T("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T("willChange", [["will-change", ["will-change"]]]), content: T("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
function Ne(t) {
  if (Array.isArray(t))
    return t;
  let e = t.split("[").length - 1, r2 = t.split("]").length - 1;
  if (e !== r2)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t}`);
  return t.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var ic = new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var nc = new Map(Array.from(ic.entries()).map(([t, e]) => [e, t]));
var hv = new Set(['"', "'", "`"]);
function lt(t) {
  let e = [], r2 = false;
  for (let n = 0;n < t.length; n++) {
    let i = t[n];
    if (i === ":" && !r2 && e.length === 0)
      return false;
    if (hv.has(i) && t[n - 1] !== "\\" && (r2 = !r2), !r2 && t[n - 1] !== "\\") {
      if (ic.has(i))
        e.push(i);
      else if (nc.has(i)) {
        let a = nc.get(i);
        if (e.length <= 0 || e.pop() !== a)
          return false;
      }
    }
  }
  return !(e.length > 0);
}
function fn(t) {
  return (t > 0n) - (t < 0n);
}
function sc(t, e) {
  let r2 = 0n, n = 0n;
  for (let [i, a] of e)
    t & i && (r2 = r2 | i, n = n | a);
  return t & ~r2 | n;
}
var cn = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = new Map;
  }
  create(e) {
    return { layer: e, parentLayer: e, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e, r2 = 0) {
    let n = this.variantOffsets.get(e);
    if (n === undefined)
      throw new Error(`Cannot find offset for unknown variant ${e}`);
    return { ...this.create("variants"), variants: n << BigInt(r2) };
  }
  applyVariantOffset(e, r2, n) {
    return n.variant = r2.variants, { ...e, layer: "variants", parentLayer: e.layer === "variants" ? e.parentLayer : e.layer, variants: e.variants | r2.variants, options: n.sort ? [].concat(n, e.options) : e.options, parallelIndex: ac([e.parallelIndex, r2.parallelIndex]) };
  }
  applyParallelOffset(e, r2) {
    return { ...e, parallelIndex: BigInt(r2) };
  }
  recordVariants(e, r2) {
    for (let n of e)
      this.recordVariant(n, r2(n));
  }
  recordVariant(e, r2 = 1) {
    return this.variantOffsets.set(e, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r2), { ...this.create("variants"), variants: this.variantOffsets.get(e) };
  }
  compare(e, r2) {
    var n;
    if (e.layer !== r2.layer)
      return this.layerPositions[e.layer] - this.layerPositions[r2.layer];
    if (e.parentLayer !== r2.parentLayer)
      return this.layerPositions[e.parentLayer] - this.layerPositions[r2.parentLayer];
    for (let i of e.options)
      for (let a of r2.options) {
        if (i.id !== a.id || !i.sort || !a.sort)
          continue;
        let s = (n = ac([i.variant, a.variant])) != null ? n : 0n, o = ~(s | s - 1n), l = e.variants & o, u = r2.variants & o;
        if (l !== u)
          continue;
        let f = i.sort({ value: i.value, modifier: i.modifier }, { value: a.value, modifier: a.modifier });
        if (f !== 0)
          return f;
      }
    return e.variants !== r2.variants ? e.variants - r2.variants : e.parallelIndex !== r2.parallelIndex ? e.parallelIndex - r2.parallelIndex : e.arbitrary !== r2.arbitrary ? e.arbitrary - r2.arbitrary : e.index - r2.index;
  }
  recalculateVariantOffsets() {
    let e = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [a]) => mv(i, a)), r2 = e.map(([, i]) => i).sort((i, a) => fn(i - a));
    return e.map(([, i], a) => [i, r2[a]]).filter(([i, a]) => i !== a);
  }
  remapArbitraryVariantOffsets(e) {
    let r2 = this.recalculateVariantOffsets();
    return r2.length === 0 ? e : e.map((n) => {
      let [i, a] = n;
      return i = { ...i, variants: sc(i.variants, r2) }, [i, a];
    });
  }
  sort(e) {
    return e = this.remapArbitraryVariantOffsets(e), e.sort(([r2], [n]) => fn(this.compare(r2, n)));
  }
};
function ac(t) {
  let e = null;
  for (let r2 of t)
    e = e != null ? e : r2, e = e > r2 ? e : r2;
  return e;
}
function mv(t, e) {
  let r2 = t.length, n = e.length, i = r2 < n ? r2 : n;
  for (let a = 0;a < i; a++) {
    let s = t.charCodeAt(a) - e.charCodeAt(a);
    if (s !== 0)
      return s;
  }
  return r2 - n;
}
var lr = Symbol();
var Fs = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var Us = { Base: 1, Dynamic: 2 };
function qs(t, e) {
  let r2 = t.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e) : r2 + e;
}
function oc({ type: t = "any", ...e }) {
  let r2 = [].concat(t);
  return { ...e, types: r2.map((n) => Array.isArray(n) ? { type: n[0], ...n[1] } : { type: n, preferOnConflict: false }) };
}
function gv(t) {
  let e = [], r2 = "", n = 0;
  for (let i = 0;i < t.length; i++) {
    let a = t[i];
    if (a === "\\")
      r2 += "\\" + t[++i];
    else if (a === "{")
      ++n, e.push(r2.trim()), r2 = "";
    else if (a === "}") {
      if (--n < 0)
        throw new Error("Your { and } are unbalanced.");
      e.push(r2.trim()), r2 = "";
    } else
      r2 += a;
  }
  return r2.length > 0 && e.push(r2.trim()), e = e.filter((i) => i !== ""), e;
}
function yv(t, e, { before: r2 = [] } = {}) {
  if (r2 = [].concat(r2), r2.length <= 0) {
    t.push(e);
    return;
  }
  let n = t.length - 1;
  for (let i of r2) {
    let a = t.indexOf(i);
    a !== -1 && (n = Math.min(n, a));
  }
  t.splice(n, 0, e);
}
function uc(t) {
  return Array.isArray(t) ? t.flatMap((e) => !Array.isArray(e) && !X(e) ? e : nt(e)) : uc([t]);
}
function vv(t, e) {
  return (0, $s.default)((n) => {
    let i = [];
    return e && e(n), n.walkClasses((a) => {
      i.push(a.value);
    }), i;
  }).transformSync(t);
}
function wv(t) {
  t.walkPseudos((e) => {
    e.value === ":not" && e.remove();
  });
}
function bv(t, e = { containsNonOnDemandable: false }, r2 = 0) {
  let n = [], i = [];
  t.type === "rule" ? i.push(...t.selectors) : t.type === "atrule" && t.walkRules((a) => i.push(...a.selectors));
  for (let a of i) {
    let s = vv(a, wv);
    s.length === 0 && (e.containsNonOnDemandable = true);
    for (let o of s)
      n.push(o);
  }
  return r2 === 0 ? [e.containsNonOnDemandable || n.length === 0, n] : n;
}
function pn(t) {
  return uc(t).flatMap((e) => {
    let r2 = new Map, [n, i] = bv(e);
    return n && i.unshift(Se), i.map((a) => (r2.has(e) || r2.set(e, e), [a, r2.get(e)]));
  });
}
function dn(t) {
  return t.startsWith("@") || t.includes("&");
}
function ur(t) {
  t = t.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e = gv(t).map((r2) => {
    if (!r2.startsWith("@"))
      return ({ format: a }) => a(r2);
    let [, n, i] = /@(\S*)( .+|[({].*)?/g.exec(r2);
    return ({ wrap: a }) => {
      var s;
      return a(L.atRule({ name: n, params: (s = i == null ? undefined : i.trim()) != null ? s : "" }));
    };
  }).reverse();
  return (r2) => {
    for (let n of e)
      n(r2);
  };
}
function xv(t, e, { variantList: r2, variantMap: n, offsets: i, classList: a }) {
  function s(p, d) {
    return p ? (0, lc.default)(t, p, d) : t;
  }
  function o(p) {
    return it(t.prefix, p);
  }
  function l(p, d) {
    return p === Se ? Se : d.respectPrefix ? e.tailwindConfig.prefix + p : p;
  }
  function u(p, d, m = {}) {
    let w = Ne(p), h = s(["theme", ...w], d);
    return Oe(w[0])(h, m);
  }
  let f = 0, c = { postcss: L, prefix: o, e: te, config: s, theme: u, corePlugins: (p) => Array.isArray(t.corePlugins) ? t.corePlugins.includes(p) : s(["corePlugins", p], true), variants: () => [], addBase(p) {
    for (let [d, m] of pn(p)) {
      let w = l(d, {}), h = i.create("base");
      e.candidateRuleMap.has(w) || e.candidateRuleMap.set(w, []), e.candidateRuleMap.get(w).push([{ sort: h, layer: "base" }, m]);
    }
  }, addDefaults(p, d) {
    let m = { [`@defaults ${p}`]: d };
    for (let [w, h] of pn(m)) {
      let g = l(w, {});
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("defaults"), layer: "defaults" }, h]);
    }
  }, addComponents(p, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d) ? {} : d);
    for (let [w, h] of pn(p)) {
      let g = l(w, d);
      a.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("components"), layer: "components", options: d }, h]);
    }
  }, addUtilities(p, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d) ? {} : d);
    for (let [w, h] of pn(p)) {
      let g = l(w, d);
      a.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("utilities"), layer: "utilities", options: d }, h]);
    }
  }, matchUtilities: function(p, d) {
    d = oc({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d });
    let w = i.create("utilities");
    for (let h in p) {
      let b = function(O, { isOnlyPlugin: x }) {
        let [C, S, I] = As(d.types, O, d, t);
        if (C === undefined)
          return [];
        if (!d.types.some(({ type: G }) => G === S))
          if (x)
            F.warn([`Unnecessary typehint \`${S}\` in \`${h}-${O}\`.`, `You can safely update it to \`${h}-${O.replace(S + ":", "")}\`.`]);
          else
            return [];
        if (!lt(C))
          return [];
        let R = { get modifier() {
          return d.modifiers || F.warn(`modifier-used-without-options-for-${h}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I;
        } }, B = Y(t, "generalizedModifiers");
        return [].concat(B ? y(C, R) : y(C)).filter(Boolean).map((G) => ({ [an(h, O)]: G }));
      }, g = l(h, d), y = p[h];
      a.add([g, d]);
      let v = [{ sort: w, layer: "utilities", options: d }, b];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, matchComponents: function(p, d) {
    d = oc({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d });
    let w = i.create("components");
    for (let h in p) {
      let b = function(O, { isOnlyPlugin: x }) {
        let [C, S, I] = As(d.types, O, d, t);
        if (C === undefined)
          return [];
        if (!d.types.some(({ type: G }) => G === S))
          if (x)
            F.warn([`Unnecessary typehint \`${S}\` in \`${h}-${O}\`.`, `You can safely update it to \`${h}-${O.replace(S + ":", "")}\`.`]);
          else
            return [];
        if (!lt(C))
          return [];
        let R = { get modifier() {
          return d.modifiers || F.warn(`modifier-used-without-options-for-${h}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I;
        } }, B = Y(t, "generalizedModifiers");
        return [].concat(B ? y(C, R) : y(C)).filter(Boolean).map((G) => ({ [an(h, O)]: G }));
      }, g = l(h, d), y = p[h];
      a.add([g, d]);
      let v = [{ sort: w, layer: "components", options: d }, b];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, addVariant(p, d, m = {}) {
    d = [].concat(d).map((w) => {
      if (typeof w != "string")
        return (h = {}) => {
          let { args: g, modifySelectors: y, container: b, separator: v, wrap: O, format: x } = h, C = w(Object.assign({ modifySelectors: y, container: b, separator: v }, m.type === Fs.MatchVariant && { args: g, wrap: O, format: x }));
          if (typeof C == "string" && !dn(C))
            throw new Error(`Your custom variant \`${p}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(C) ? C.filter((S) => typeof S == "string").map((S) => ur(S)) : C && typeof C == "string" && ur(C)(h);
        };
      if (!dn(w))
        throw new Error(`Your custom variant \`${p}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return ur(w);
    }), yv(r2, p, m), n.set(p, d), e.variantOptions.set(p, m);
  }, matchVariant(p, d, m) {
    var b, v, O;
    let w = (b = m == null ? undefined : m.id) != null ? b : ++f, h = p === "@", g = Y(t, "generalizedModifiers");
    for (let [x, C] of Object.entries((v = m == null ? undefined : m.values) != null ? v : {}))
      x !== "DEFAULT" && c.addVariant(h ? `${p}${x}` : `${p}-${x}`, ({ args: S, container: I }) => d(C, g ? { modifier: S == null ? undefined : S.modifier, container: I } : { container: I }), { ...m, value: C, id: w, type: Fs.MatchVariant, variantInfo: Us.Base });
    let y = "DEFAULT" in ((O = m == null ? undefined : m.values) != null ? O : {});
    c.addVariant(p, ({ args: x, container: C }) => {
      var S;
      return (x == null ? undefined : x.value) === Mt && !y ? null : d((x == null ? undefined : x.value) === Mt ? m.values.DEFAULT : (S = x == null ? undefined : x.value) != null ? S : typeof x == "string" ? x : "", g ? { modifier: x == null ? undefined : x.modifier, container: C } : { container: C });
    }, { ...m, id: w, type: Fs.MatchVariant, variantInfo: Us.Dynamic });
  } };
  return c;
}
function fc(t) {
  t.walkAtRules((e) => {
    ["responsive", "variants"].includes(e.name) && (fc(e), e.before(e.nodes), e.remove());
  });
}
function Sv(t) {
  let e = [];
  return t.each((r2) => {
    r2.type === "atrule" && ["responsive", "variants"].includes(r2.name) && (r2.name = "layer", r2.params = "utilities");
  }), t.walkAtRules("layer", (r2) => {
    if (fc(r2), r2.params === "base") {
      for (let n of r2.nodes)
        e.push(function({ addBase: i }) {
          i(n, { respectPrefix: false });
        });
      r2.remove();
    } else if (r2.params === "components") {
      for (let n of r2.nodes)
        e.push(function({ addComponents: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    } else if (r2.params === "utilities") {
      for (let n of r2.nodes)
        e.push(function({ addUtilities: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    }
  }), e;
}
function kv(t, e) {
  let r2 = Object.entries({ ...re, ...rc }).map(([o, l]) => t.tailwindConfig.corePlugins.includes(o) ? l : null).filter(Boolean), n = t.tailwindConfig.plugins.map((o) => (o.__isOptionsFunction && (o = o()), typeof o == "function" ? o : o.handler)), i = Sv(e), a = [re.pseudoElementVariants, re.pseudoClassVariants, re.ariaVariants, re.dataVariants], s = [re.supportsVariants, re.directionVariants, re.reducedMotionVariants, re.prefersContrastVariants, re.darkVariants, re.printVariant, re.screenVariants, re.orientationVariants];
  return [...r2, ...a, ...n, ...s, ...i];
}
function Ev(t, e) {
  var f, c, p;
  let r2 = [], n = new Map;
  e.variantMap = n;
  let i = new cn;
  e.offsets = i;
  let a = new Set, s = xv(e.tailwindConfig, e, { variantList: r2, variantMap: n, offsets: i, classList: a });
  for (let d of t)
    if (Array.isArray(d))
      for (let m of d)
        m(s);
    else
      d == null || d(s);
  i.recordVariants(r2, (d) => n.get(d).length);
  for (let [d, m] of n.entries())
    e.variantMap.set(d, m.map((w, h) => [i.forVariant(d, h), w]));
  let o = ((f = e.tailwindConfig.safelist) != null ? f : []).filter(Boolean);
  if (o.length > 0) {
    let d = [];
    for (let m of o) {
      if (typeof m == "string") {
        e.changedContent.push({ content: m, extension: "html" });
        continue;
      }
      if (m instanceof RegExp) {
        F.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d.push(m);
    }
    if (d.length > 0) {
      let m = new Map, w = e.tailwindConfig.prefix.length, h = d.some((g) => g.pattern.source.includes("!"));
      for (let g of a) {
        let y = Array.isArray(g) ? (() => {
          var C;
          let [b, v] = g, x = Object.keys((C = v == null ? undefined : v.values) != null ? C : {}).map((S) => or(b, S));
          return v != null && v.supportsNegativeValues && (x = [...x, ...x.map((S) => "-" + S)], x = [...x, ...x.map((S) => S.slice(0, w) + "-" + S.slice(w))]), v.types.some(({ type: S }) => S === "color") && (x = [...x, ...x.flatMap((S) => Object.keys(e.tailwindConfig.theme.opacity).map((I) => `${S}/${I}`))]), h && (v != null && v.respectImportant) && (x = [...x, ...x.map((S) => "!" + S)]), x;
        })() : [g];
        for (let b of y)
          for (let { pattern: v, variants: O = [] } of d)
            if (v.lastIndex = 0, m.has(v) || m.set(v, 0), !!v.test(b)) {
              m.set(v, m.get(v) + 1), e.changedContent.push({ content: b, extension: "html" });
              for (let x of O)
                e.changedContent.push({ content: x + e.tailwindConfig.separator + b, extension: "html" });
            }
      }
      for (let [g, y] of m.entries())
        y === 0 && F.warn([`The safelist pattern \`${g}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l = (p = [].concat((c = e.tailwindConfig.darkMode) != null ? c : "media")[1]) != null ? p : "dark", u = [qs(e, l), qs(e, "group"), qs(e, "peer")];
  e.getClassOrder = function(m) {
    var b;
    let w = [...m].sort((v, O) => v === O ? 0 : v < O ? -1 : 1), h = new Map(w.map((v) => [v, null])), g = hn(new Set(w), e, true);
    g = e.offsets.sort(g);
    let y = BigInt(u.length);
    for (let [, v] of g) {
      let O = v.raws.tailwind.candidate;
      h.set(O, (b = h.get(O)) != null ? b : y++);
    }
    return m.map((v) => {
      var C;
      let O = (C = h.get(v)) != null ? C : null, x = u.indexOf(v);
      return O === null && x !== -1 && (O = BigInt(x)), [v, O];
    });
  }, e.getClassList = function(m = {}) {
    var h, g, y, b;
    let w = [];
    for (let v of a)
      if (Array.isArray(v)) {
        let [O, x] = v, C = [], S = Object.keys((h = x == null ? undefined : x.modifiers) != null ? h : {});
        (g = x == null ? undefined : x.types) != null && g.some(({ type: B }) => B === "color") && S.push(...Object.keys((y = e.tailwindConfig.theme.opacity) != null ? y : {}));
        let I = { modifiers: S }, R = m.includeMetadata && S.length > 0;
        for (let [B, ne] of Object.entries((b = x == null ? undefined : x.values) != null ? b : {})) {
          if (ne == null)
            continue;
          let G = or(O, B);
          if (w.push(R ? [G, I] : G), x != null && x.supportsNegativeValues && Re(ne)) {
            let qe = or(O, `-${B}`);
            C.push(R ? [qe, I] : qe);
          }
        }
        w.push(...C);
      } else
        w.push(v);
    return w;
  }, e.getVariants = function() {
    var w;
    let m = [];
    for (let [h, g] of e.variantOptions.entries())
      g.variantInfo !== Us.Base && m.push({ name: h, isArbitrary: g.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((w = g.values) != null ? w : {}), hasDash: h !== "@", selectors({ modifier: y, value: b } = {}) {
        var ya, va, wa, ba, xa;
        let v = "__TAILWIND_PLACEHOLDER__", O = L.rule({ selector: `.${v}` }), x = L.root({ nodes: [O.clone()] }), C = x.toString(), S = ((ya = e.variantMap.get(h)) != null ? ya : []).flatMap(([ie, se]) => se), I = [];
        for (let ie of S) {
          let se = [], hr = { args: { modifier: y, value: (wa = (va = g.values) == null ? undefined : va[b]) != null ? wa : b }, separator: e.tailwindConfig.separator, modifySelectors(ce) {
            return x.each((Pn) => {
              Pn.type === "rule" && (Pn.selectors = Pn.selectors.map((Sa) => ce({ get className() {
                return js(Sa);
              }, selector: Sa })));
            }), x;
          }, format(ce) {
            se.push(ce);
          }, wrap(ce) {
            se.push(`@${ce.name} ${ce.params} { & }`);
          }, container: x }, mr = ie(hr);
          if (se.length > 0 && I.push(se), Array.isArray(mr))
            for (let ce of mr)
              se = [], ce(hr), I.push(se);
        }
        let R = [], B = x.toString();
        C !== B && (x.walkRules((ie) => {
          let se = ie.selector, hr = (0, $s.default)((mr) => {
            mr.walkClasses((ce) => {
              ce.value = `${h}${e.tailwindConfig.separator}${ce.value}`;
            });
          }).processSync(se);
          R.push(se.replace(hr, "&").replace(v, "&"));
        }), x.walkAtRules((ie) => {
          R.push(`@${ie.name} (${ie.params}) { & }`);
        }));
        let ne = !(b in ((ba = g.values) != null ? ba : {})), G = (xa = g[lr]) != null ? xa : {}, qe = !(ne || G.respectPrefix === false);
        I = I.map((ie) => ie.map((se) => ({ format: se, respectPrefix: qe }))), R = R.map((ie) => ({ format: ie, respectPrefix: qe }));
        let Tn = { candidate: v, context: e }, ga = I.map((ie) => sn(`.${v}`, ot(ie, Tn), Tn).replace(`.${v}`, "&").replace("{ & }", "").trim());
        return R.length > 0 && ga.push(ot(R, Tn).toString().replace(`.${v}`, "&")), ga;
      } });
    return m;
  };
}
function cc(t, e) {
  t.classCache.has(e) && (t.notClassCache.add(e), t.classCache.delete(e), t.applyClassCache.delete(e), t.candidateRuleMap.delete(e), t.candidateRuleCache.delete(e), t.stylesheetCache = null);
}
function Ov(t, e) {
  let r2 = e.raws.tailwind.candidate;
  if (r2) {
    for (let n of t.ruleCache)
      n[1].raws.tailwind.candidate === r2 && t.ruleCache.delete(n);
    cc(t, r2);
  }
}
function pc(t, e = [], r2 = L.root()) {
  var a;
  let n = { disposables: [], ruleCache: new Set, candidateRuleCache: new Map, classCache: new Map, applyClassCache: new Map, notClassCache: new Set((a = t.blocklist) != null ? a : []), postCssNodeCache: new Map, candidateRuleMap: new Map, tailwindConfig: t, changedContent: e, variantMap: new Map, stylesheetCache: null, variantOptions: new Map, markInvalidUtilityCandidate: (s) => cc(n, s), markInvalidUtilityNode: (s) => Ov(n, s) }, i = kv(n, r2);
  return Ev(i, n), n;
}
var zs = H(ye());
function mn(t, e) {
  let r2 = (0, zs.default)().astSync(t);
  return r2.each((n) => {
    n.nodes[0].type === "pseudo" && n.nodes[0].value === ":is" && n.nodes.every((a) => a.type !== "combinator") || (n.nodes = [zs.default.pseudo({ value: ":is", nodes: [n.clone()] })]), at(n);
  }), `${e} ${r2.toString()}`;
}
var Av = (0, yn.default)((t) => t.first.filter(({ type: e }) => e === "class").pop().value);
function js(t) {
  return Av.transformSync(t);
}
function* Cv(t) {
  let e = 1 / 0;
  for (;e >= 0; ) {
    let r2, n = false;
    if (e === 1 / 0 && t.endsWith("]")) {
      let s = t.indexOf("[");
      t[s - 1] === "-" ? r2 = s - 1 : t[s - 1] === "/" ? (r2 = s - 1, n = true) : r2 = -1;
    } else
      e === 1 / 0 && t.includes("/") ? (r2 = t.lastIndexOf("/"), n = true) : r2 = t.lastIndexOf("-", e);
    if (r2 < 0)
      break;
    let i = t.slice(0, r2), a = t.slice(n ? r2 : r2 + 1);
    e = r2 - 1, !(i === "" || a === "/") && (yield [i, a]);
  }
}
function _v(t, e) {
  if (t.length === 0 || e.tailwindConfig.prefix === "")
    return t;
  for (let r2 of t) {
    let [n] = r2;
    if (n.options.respectPrefix) {
      let i = L.root({ nodes: [r2[1].clone()] }), a = r2[1].raws.tailwind.classCandidate;
      i.walkRules((s) => {
        let o = a.startsWith("-");
        s.selector = it(e.tailwindConfig.prefix, s.selector, o);
      }), r2[1] = i.nodes[0];
    }
  }
  return t;
}
function Tv(t, e) {
  if (t.length === 0)
    return t;
  let r2 = [];
  for (let [n, i] of t) {
    let a = L.root({ nodes: [i.clone()] });
    a.walkRules((s) => {
      let o = (0, yn.default)().astSync(s.selector);
      o.each((l) => Is(l, e)), Vf(o, (l) => l === e ? `!${l}` : l), s.selector = o.toString(), s.walkDecls((l) => l.important = true);
    }), r2.push([{ ...n, important: true }, a.nodes[0]]);
  }
  return r2;
}
function Pv(t, e, r2) {
  var i, a, s;
  if (e.length === 0)
    return e;
  let n = { modifier: null, value: Mt };
  {
    let [o, ...l] = Z(t, "/");
    if (l.length > 1 && (o = o + "/" + l.slice(0, -1).join("/"), l = l.slice(-1)), l.length && !r2.variantMap.has(t) && (t = o, n.modifier = l[0], !Y(r2.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t.endsWith("]") && !t.startsWith("[")) {
    let o = /(.)(-?)\[(.*)\]/g.exec(t);
    if (o) {
      let [, l, u, f] = o;
      if (l === "@" && u === "-")
        return [];
      if (l !== "@" && u === "")
        return [];
      t = t.replace(`${u}[${f}]`, ""), n.value = f;
    }
  }
  if (Ws(t) && !r2.variantMap.has(t)) {
    let o = r2.offsets.recordVariant(t), l = z(t.slice(1, -1)), u = Z(l, ",");
    if (u.length > 1)
      return [];
    if (!u.every(dn))
      return [];
    let f = u.map((c, p) => [r2.offsets.applyParallelOffset(o, p), ur(c.trim())]);
    r2.variantMap.set(t, f);
  }
  if (r2.variantMap.has(t)) {
    let o = Ws(t), l = (a = (i = r2.variantOptions.get(t)) == null ? undefined : i[lr]) != null ? a : {}, u = r2.variantMap.get(t).slice(), f = [], c = !(o || l.respectPrefix === false);
    for (let [p, d] of e) {
      if (p.layer === "user")
        continue;
      let m = L.root({ nodes: [d.clone()] });
      for (let [w, h, g] of u) {
        let v = function() {
          y.raws.neededBackup || (y.raws.neededBackup = true, y.walkRules((S) => S.raws.originalSelector = S.selector));
        }, O = function(S) {
          return v(), y.each((I) => {
            I.type === "rule" && (I.selectors = I.selectors.map((R) => S({ get className() {
              return js(R);
            }, selector: R })));
          }), y;
        }, y = (g != null ? g : m).clone(), b = [], x = h({ get container() {
          return v(), y;
        }, separator: r2.tailwindConfig.separator, modifySelectors: O, wrap(S) {
          let I = y.nodes;
          y.removeAll(), S.append(I), y.append(S);
        }, format(S) {
          b.push({ format: S, respectPrefix: c });
        }, args: n });
        if (Array.isArray(x)) {
          for (let [S, I] of x.entries())
            u.push([r2.offsets.applyParallelOffset(w, S), I, y.clone()]);
          continue;
        }
        if (typeof x == "string" && b.push({ format: x, respectPrefix: c }), x === null)
          continue;
        y.raws.neededBackup && (delete y.raws.neededBackup, y.walkRules((S) => {
          let I = S.raws.originalSelector;
          if (!I || (delete S.raws.originalSelector, I === S.selector))
            return;
          let R = S.selector, B = (0, yn.default)((ne) => {
            ne.walkClasses((G) => {
              G.value = `${t}${r2.tailwindConfig.separator}${G.value}`;
            });
          }).processSync(I);
          b.push({ format: R.replace(B, "&"), respectPrefix: c }), S.selector = I;
        })), y.nodes[0].raws.tailwind = { ...y.nodes[0].raws.tailwind, parentLayer: p.layer };
        let C = [{ ...p, sort: r2.offsets.applyVariantOffset(p.sort, w, Object.assign(n, r2.variantOptions.get(t))), collectedFormats: ((s = p.collectedFormats) != null ? s : []).concat(b) }, y.nodes[0]];
        f.push(C);
      }
    }
    return f;
  }
  return [];
}
function Vs(t, e, r2 = {}) {
  return !X(t) && !Array.isArray(t) ? [[t], r2] : Array.isArray(t) ? Vs(t[0], e, t[1]) : (e.has(t) || e.set(t, nt(t)), [e.get(t), r2]);
}
var Iv = /^[a-z_-]/;
function Rv(t) {
  return Iv.test(t);
}
function Dv(t) {
  if (!t.includes("://"))
    return false;
  try {
    let e = new URL(t);
    return e.scheme !== "" && e.host !== "";
  } catch {
    return false;
  }
}
function dc(t) {
  let e = true;
  return t.walkDecls((r2) => {
    if (!hc(r2.prop, r2.value))
      return e = false, false;
  }), e;
}
function hc(t, e) {
  if (Dv(`${t}:${e}`))
    return false;
  try {
    return L.parse(`a{${t}:${e}}`).toResult(), true;
  } catch {
    return false;
  }
}
function Mv(t, e) {
  var s;
  let [, r2, n] = (s = t.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? s : [];
  if (n === undefined || !Rv(r2) || !lt(n))
    return null;
  let i = z(n, { property: r2 });
  return hc(r2, i) ? [[{ sort: e.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Rs(t)]: { [r2]: i } })]] : null;
}
function* Lv(t, e) {
  e.candidateRuleMap.has(t) && (yield [e.candidateRuleMap.get(t), "DEFAULT"]), yield* function* (o) {
    o !== null && (yield [o, "DEFAULT"]);
  }(Mv(t, e));
  let r2 = t, n = false, i = e.tailwindConfig.prefix, a = i.length, s = r2.startsWith(i) || r2.startsWith(`-${i}`);
  r2[a] === "-" && s && (n = true, r2 = i + r2.slice(a + 1)), n && e.candidateRuleMap.has(r2) && (yield [e.candidateRuleMap.get(r2), "-DEFAULT"]);
  for (let [o, l] of Cv(r2))
    e.candidateRuleMap.has(o) && (yield [e.candidateRuleMap.get(o), n ? `-${l}` : l]);
}
function Nv(t, e) {
  return t === Se ? [Se] : Z(t, e);
}
function* Fv(t, e) {
  var r2, n;
  for (let i of t)
    i[1].raws.tailwind = { ...i[1].raws.tailwind, classCandidate: e, preserveSource: (n = (r2 = i[0].options) == null ? undefined : r2.preserveSource) != null ? n : false }, yield i;
}
function* Bs(t, e) {
  var s, o, l, u;
  let r2 = e.tailwindConfig.separator, [n, ...i] = Nv(t, r2).reverse(), a = false;
  n.startsWith("!") && (a = true, n = n.slice(1));
  for (let f of Lv(n, e)) {
    let c = [], p = new Map, [d, m] = f, w = d.length === 1;
    for (let [h, g] of d) {
      let y = [];
      if (typeof g == "function")
        for (let b of [].concat(g(m, { isOnlyPlugin: w }))) {
          let [v, O] = Vs(b, e.postCssNodeCache);
          for (let x of v)
            y.push([{ ...h, options: { ...h.options, ...O } }, x]);
        }
      else if (m === "DEFAULT" || m === "-DEFAULT") {
        let b = g, [v, O] = Vs(b, e.postCssNodeCache);
        for (let x of v)
          y.push([{ ...h, options: { ...h.options, ...O } }, x]);
      }
      if (y.length > 0) {
        let b = Array.from(Cs((o = (s = h.options) == null ? undefined : s.types) != null ? o : [], m, (l = h.options) != null ? l : {}, e.tailwindConfig)).map(([v, O]) => O);
        b.length > 0 && p.set(y, b), c.push(y);
      }
    }
    if (Ws(m)) {
      if (c.length > 1) {
        let y = function(v) {
          return v.length === 1 ? v[0] : v.find((O) => {
            let x = p.get(O);
            return O.some(([{ options: C }, S]) => dc(S) ? C.types.some(({ type: I, preferOnConflict: R }) => x.includes(I) && R) : false);
          });
        }, [h, g] = c.reduce((v, O) => (O.some(([{ options: C }]) => C.types.some(({ type: S }) => S === "any")) ? v[0].push(O) : v[1].push(O), v), [[], []]), b = (u = y(g)) != null ? u : y(h);
        if (b)
          c = [b];
        else {
          let v = c.map((x) => {
            var C;
            return new Set([...(C = p.get(x)) != null ? C : []]);
          });
          for (let x of v)
            for (let C of x) {
              let S = false;
              for (let I of v)
                x !== I && I.has(C) && (I.delete(C), S = true);
              S && x.delete(C);
            }
          let O = [];
          for (let [x, C] of v.entries())
            for (let S of C) {
              let I = c[x].map(([, R]) => R).flat().map((R) => R.toString().split(`
`).slice(1, -1).map((B) => B.trim()).map((B) => `      ${B}`).join(`
`)).join(`

`);
              O.push(`  Use \`${t.replace("[", `[${S}:`)}\` for \`${I.trim()}\``);
              break;
            }
          F.warn([`The class \`${t}\` is ambiguous and matches multiple utilities.`, ...O, `If this is content and not a class, replace it with \`${t.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c = c.map((h) => h.filter((g) => dc(g[1])));
    }
    c = c.flat(), c = Array.from(Fv(c, n)), c = _v(c, e), a && (c = Tv(c, n));
    for (let h of i)
      c = Pv(h, c, e);
    for (let h of c)
      h[1].raws.tailwind = { ...h[1].raws.tailwind, candidate: t }, h = qv(h, { context: e, candidate: t }), h !== null && (yield h);
  }
}
function qv(t, { context: e, candidate: r2 }) {
  if (!t[0].collectedFormats)
    return t;
  let n = true, i;
  try {
    i = ot(t[0].collectedFormats, { context: e, candidate: r2 });
  } catch {
    return null;
  }
  let a = L.root({ nodes: [t[1].clone()] });
  return a.walkRules((s) => {
    if (!gn(s))
      try {
        let o = sn(s.selector, i, { candidate: r2, context: e });
        if (o === null) {
          s.remove();
          return;
        }
        s.selector = o;
      } catch {
        return n = false, false;
      }
  }), !n || a.nodes.length === 0 ? null : (t[1] = a.nodes[0], t);
}
function gn(t) {
  return t.parent && t.parent.type === "atrule" && t.parent.name === "keyframes";
}
function Uv(t) {
  if (t === true)
    return (e) => {
      gn(e) || e.walkDecls((r2) => {
        r2.parent.type === "rule" && !gn(r2.parent) && (r2.important = true);
      });
    };
  if (typeof t == "string")
    return (e) => {
      gn(e) || (e.selectors = e.selectors.map((r2) => mn(r2, t)));
    };
}
function hn(t, e, r2 = false) {
  var a;
  let n = [], i = Uv(e.tailwindConfig.important);
  for (let s of t) {
    if (e.notClassCache.has(s))
      continue;
    if (e.candidateRuleCache.has(s)) {
      n = n.concat(Array.from(e.candidateRuleCache.get(s)));
      continue;
    }
    let o = Array.from(Bs(s, e));
    if (o.length === 0) {
      e.notClassCache.add(s);
      continue;
    }
    e.classCache.set(s, o);
    let l = (a = e.candidateRuleCache.get(s)) != null ? a : new Set;
    e.candidateRuleCache.set(s, l);
    for (let u of o) {
      let [{ sort: f, options: c }, p] = u;
      if (c.respectImportant && i) {
        let m = L.root({ nodes: [p.clone()] });
        m.walkRules(i), p = m.nodes[0];
      }
      let d = [f, r2 ? p.clone() : p];
      l.add(d), e.ruleCache.add(d), n.push(d);
    }
  }
  return n;
}
function Ws(t) {
  return t.startsWith("[") && t.endsWith("]");
}
function Be(t, e = undefined, r2 = undefined) {
  return t.map((n) => {
    let i = n.clone();
    return r2 !== undefined && (i.raws.tailwind = { ...i.raws.tailwind, ...r2 }), e !== undefined && mc(i, (a) => {
      var o;
      if (((o = a.raws.tailwind) == null ? undefined : o.preserveSource) === true && a.source)
        return false;
      a.source = e;
    }), i;
  });
}
function mc(t, e) {
  var r2;
  e(t) !== false && ((r2 = t.each) == null || r2.call(t, (n) => mc(n, e)));
}
var gc = /[\\^$.*+?()[\]{}|]/g;
var $v = RegExp(gc.source);
function Gs(t) {
  return t = Array.isArray(t) ? t : [t], t = t.map((e) => e instanceof RegExp ? e.source : e), t.join("");
}
function oe(t) {
  return new RegExp(Gs(t), "g");
}
function Ge(t) {
  return `(?:${t.map(Gs).join("|")})`;
}
function Hs(t) {
  return `(?:${Gs(t)})?`;
}
function yc(t) {
  return t && $v.test(t) ? t.replace(gc, "\\$&") : t || "";
}
function vc(t) {
  let e = Array.from(zv(t));
  return (r2) => {
    var i;
    let n = [];
    for (let a of e)
      for (let s of (i = r2.match(a)) != null ? i : [])
        n.push(Bv(s));
    return n;
  };
}
function* zv(t) {
  let e = t.tailwindConfig.separator, r2 = t.tailwindConfig.prefix !== "" ? Hs(oe([/-?/, yc(t.tailwindConfig.prefix)])) : "", n = Ge([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, oe([/-?(?:\w+)/, Hs(Ge([oe([Ge([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), oe([Ge([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), i = [Ge([oe([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e]), oe([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/\w+/, e]), oe([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e]), oe([/[^\s"'`\[\\]+/, e])]), Ge([oe([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/\w+/, e]), oe([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e]), oe([/[^\s`\[\\]+/, e])])];
  for (let a of i)
    yield oe(["((?=((", a, ")+))\\2)?", /!?/, r2, n]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Vv = /([\[\]'"`])([^\[\]'"`])?/g;
var Wv = /[^"'`\s<>\]]+/;
function Bv(t) {
  if (!t.includes("-["))
    return t;
  let e = 0, r2 = [], n = t.matchAll(Vv);
  n = Array.from(n).flatMap((i) => {
    let [, ...a] = i;
    return a.map((s, o) => Object.assign([], i, { index: i.index + o, 0: s }));
  });
  for (let i of n) {
    let a = i[0], s = r2[r2.length - 1];
    if (a === s ? r2.pop() : (a === "'" || a === '"' || a === "`") && r2.push(a), !s) {
      if (a === "[") {
        e++;
        continue;
      } else if (a === "]") {
        e--;
        continue;
      }
      if (e < 0)
        return t.substring(0, i.index - 1);
      if (e === 0 && !Wv.test(a))
        return t.substring(0, i.index);
    }
  }
  return t;
}
var Ae = mi;
var wc = { DEFAULT: vc };
var bc = { DEFAULT: (t) => t, svelte: (t) => t.replace(/(?:^|\s)class:/g, " ") };
function Gv(t, e) {
  let r2 = t.tailwindConfig.content.extract;
  return r2[e] || r2.DEFAULT || wc[e] || wc.DEFAULT(t);
}
function Hv(t, e) {
  let r2 = t.content.transform;
  return r2[e] || r2.DEFAULT || bc[e] || bc.DEFAULT;
}
var fr = new WeakMap;
function Yv(t, e, r2, n) {
  fr.has(e) || fr.set(e, new xc.default({ maxSize: 25000 }));
  for (let i of t.split(`
`))
    if (i = i.trim(), !n.has(i))
      if (n.add(i), fr.get(e).has(i))
        for (let a of fr.get(e).get(i))
          r2.add(a);
      else {
        let a = e(i).filter((o) => o !== "!*"), s = new Set(a);
        for (let o of s)
          r2.add(o);
        fr.get(e).set(i, s);
      }
}
function Qv(t, e) {
  let r2 = e.offsets.sort(t), n = { base: new Set, defaults: new Set, components: new Set, utilities: new Set, variants: new Set };
  for (let [i, a] of r2)
    n[i.layer].add(a);
  return n;
}
function Ys(t) {
  return async (e) => {
    var m, w;
    let r2 = { base: null, components: null, utilities: null, variants: null };
    if (e.walkAtRules((h) => {
      h.name === "tailwind" && Object.keys(r2).includes(h.params) && (r2[h.params] = h);
    }), Object.values(r2).every((h) => h === null))
      return e;
    let n = new Set([...(m = t.candidates) != null ? m : [], Se]), i = new Set;
    Ae.DEBUG && console.time("Reading changed files");
    {
      let h = [];
      for (let y of t.changedContent) {
        let b = Hv(t.tailwindConfig, y.extension), v = Gv(t, y.extension);
        h.push([y, { transformer: b, extractor: v }]);
      }
      let g = 500;
      for (let y = 0;y < h.length; y += g) {
        let b = h.slice(y, y + g);
        await Promise.all(b.map(async ([{ file: v, content: O }, { transformer: x, extractor: C }]) => {
          O = v ? await St.promises.readFile(v, "utf8") : O, Yv(x(O), C, n, i);
        }));
      }
    }
    Ae.DEBUG && console.timeEnd("Reading changed files");
    let a = t.classCache.size;
    Ae.DEBUG && console.time("Generate rules"), Ae.DEBUG && console.time("Sorting candidates");
    let s = new Set([...n].sort((h, g) => h === g ? 0 : h < g ? -1 : 1));
    Ae.DEBUG && console.timeEnd("Sorting candidates"), hn(s, t), Ae.DEBUG && console.timeEnd("Generate rules"), Ae.DEBUG && console.time("Build stylesheet"), (t.stylesheetCache === null || t.classCache.size !== a) && (t.stylesheetCache = Qv([...t.ruleCache], t)), Ae.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o, base: l, components: u, utilities: f, variants: c } = t.stylesheetCache;
    r2.base && (r2.base.before(Be([...l, ...o], r2.base.source, { layer: "base" })), r2.base.remove()), r2.components && (r2.components.before(Be([...u], r2.components.source, { layer: "components" })), r2.components.remove()), r2.utilities && (r2.utilities.before(Be([...f], r2.utilities.source, { layer: "utilities" })), r2.utilities.remove());
    let p = Array.from(c).filter((h) => {
      var y;
      let g = (y = h.raws.tailwind) == null ? undefined : y.parentLayer;
      return g === "components" ? r2.components !== null : g === "utilities" ? r2.utilities !== null : true;
    });
    r2.variants ? (r2.variants.before(Be(p, r2.variants.source, { layer: "variants" })), r2.variants.remove()) : p.length > 0 && e.append(Be(p, e.source, { layer: "variants" })), e.source.end = (w = e.source.end) != null ? w : e.source.start;
    let d = p.some((h) => {
      var g;
      return ((g = h.raws.tailwind) == null ? undefined : g.parentLayer) === "utilities";
    });
    r2.utilities && f.size === 0 && !d && F.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ae.DEBUG && (console.log("Potential classes: ", n.size), console.log("Active contexts: ", gi.size)), t.changedContent = [], e.walkAtRules("layer", (h) => {
      Object.keys(r2).includes(h.params) && h.remove();
    });
  };
}
var wn = H(ye());
function vn(t) {
  let e = new Map;
  L.root({ nodes: [t.clone()] }).walkRules((a) => {
    (0, wn.default)((s) => {
      s.walkClasses((o) => {
        let l = o.parent.toString(), u = e.get(l);
        u || e.set(l, u = new Set), u.add(o.value);
      });
    }).processSync(a.selector);
  });
  let n = Array.from(e.values(), (a) => Array.from(a)), i = n.flat();
  return Object.assign(i, { groups: n });
}
var Jv = (0, wn.default)();
function Qs(t) {
  return Jv.astSync(t);
}
function Sc(t, e) {
  let r2 = new Set;
  for (let n of t)
    r2.add(n.split(e).pop());
  return Array.from(r2);
}
function kc(t, e) {
  let r2 = t.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e) : r2 + e;
}
function* Oc(t) {
  for (yield t;t.parent; )
    yield t.parent, t = t.parent;
}
function Xv(t, e = {}) {
  let r2 = t.nodes;
  t.nodes = [];
  let n = t.clone(e);
  return t.nodes = r2, n;
}
function Kv(t) {
  for (let e of Oc(t))
    if (t !== e) {
      if (e.type === "root")
        break;
      t = Xv(e, { nodes: [t] });
    }
  return t;
}
function Zv(t, e) {
  let r2 = new Map;
  return t.walkRules((n) => {
    var s;
    for (let o of Oc(n))
      if (((s = o.raws.tailwind) == null ? undefined : s.layer) !== undefined)
        return;
    let i = Kv(n), a = e.offsets.create("user");
    for (let o of vn(n)) {
      let l = r2.get(o) || [];
      r2.set(o, l), l.push([{ layer: "user", sort: a, important: false }, i]);
    }
  }), r2;
}
function ew(t, e) {
  for (let r2 of t) {
    if (e.notClassCache.has(r2) || e.applyClassCache.has(r2))
      continue;
    if (e.classCache.has(r2)) {
      e.applyClassCache.set(r2, e.classCache.get(r2).map(([i, a]) => [i, a.clone()]));
      continue;
    }
    let n = Array.from(Bs(r2, e));
    if (n.length === 0) {
      e.notClassCache.add(r2);
      continue;
    }
    e.applyClassCache.set(r2, n);
  }
  return e.applyClassCache;
}
function tw(t) {
  let e = null;
  return { get: (r2) => (e = e || t(), e.get(r2)), has: (r2) => (e = e || t(), e.has(r2)) };
}
function rw(t) {
  return { get: (e) => t.flatMap((r2) => r2.get(e) || []), has: (e) => t.some((r2) => r2.has(e)) };
}
function Ec(t) {
  let e = t.split(/[\s\t\n]+/g);
  return e[e.length - 1] === "!important" ? [e.slice(0, -1), true] : [e, false];
}
function Ac(t, e, r2) {
  let n = new Set, i = [];
  if (t.walkAtRules("apply", (l) => {
    let [u] = Ec(l.params);
    for (let f of u)
      n.add(f);
    i.push(l);
  }), i.length === 0)
    return;
  let a = rw([r2, ew(n, e)]);
  function s(l, u, f) {
    let c = Qs(l), p = Qs(u), m = Qs(`.${te(f)}`).nodes[0].nodes[0];
    return c.each((w) => {
      let h = new Set;
      p.each((g) => {
        let y = false;
        g = g.clone(), g.walkClasses((b) => {
          b.value === m.value && (y || (b.replaceWith(...w.nodes.map((v) => v.clone())), h.add(g), y = true));
        });
      });
      for (let g of h) {
        let y = [[]];
        for (let b of g.nodes)
          b.type === "combinator" ? (y.push(b), y.push([])) : y[y.length - 1].push(b);
        g.nodes = [];
        for (let b of y)
          Array.isArray(b) && b.sort((v, O) => v.type === "tag" && O.type === "class" ? -1 : v.type === "class" && O.type === "tag" ? 1 : v.type === "class" && O.type === "pseudo" && O.value.startsWith("::") ? -1 : v.type === "pseudo" && v.value.startsWith("::") && O.type === "class" ? 1 : 0), g.nodes = g.nodes.concat(b);
      }
      w.replaceWith(...h);
    }), c.toString();
  }
  let o = new Map;
  for (let l of i) {
    let [u] = o.get(l.parent) || [[], l.source];
    o.set(l.parent, [u, l.source]);
    let [f, c] = Ec(l.params);
    if (l.parent.type === "atrule") {
      if (l.parent.name === "screen") {
        let p = l.parent.params;
        throw l.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f.map((d) => `${p}:${d}`).join(" ")} instead.`);
      }
      throw l.error(`@apply is not supported within nested at-rules like @${l.parent.name}. You can fix this by un-nesting @${l.parent.name}.`);
    }
    for (let p of f) {
      if ([kc(e, "group"), kc(e, "peer")].includes(p))
        throw l.error(`@apply should not be used with the '${p}' utility`);
      if (!a.has(p))
        throw l.error(`The \`${p}\` class does not exist. If \`${p}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d = a.get(p);
      u.push([p, c, d]);
    }
  }
  for (let [l, [u, f]] of o) {
    let c = [];
    for (let [d, m, w] of u) {
      let h = [d, ...Sc([d], e.tailwindConfig.separator)];
      for (let [g, y] of w) {
        let b = vn(l), v = vn(y);
        if (v = v.groups.filter((S) => S.some((I) => h.includes(I))).flat(), v = v.concat(Sc(v, e.tailwindConfig.separator)), b.some((S) => v.includes(S)))
          throw y.error(`You cannot \`@apply\` the \`${d}\` utility here because it creates a circular dependency.`);
        let x = L.root({ nodes: [y.clone()] });
        x.walk((S) => {
          S.source = f;
        }), (y.type !== "atrule" || y.type === "atrule" && y.name !== "keyframes") && x.walkRules((S) => {
          if (!vn(S).some((G) => G === d)) {
            S.remove();
            return;
          }
          let I = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null, B = l.raws.tailwind !== undefined && I && l.selector.indexOf(I) === 0 ? l.selector.slice(I.length) : l.selector;
          B === "" && (B = l.selector), S.selector = s(B, S.selector, d), I && B !== l.selector && (S.selector = mn(S.selector, I)), S.walkDecls((G) => {
            G.important = g.important || m;
          });
          let ne = (0, wn.default)().astSync(S.selector);
          ne.each((G) => at(G)), S.selector = ne.toString();
        }), x.nodes[0] && c.push([g.sort, x.nodes[0]]);
      }
    }
    let p = e.offsets.sort(c).map((d) => d[1]);
    l.after(p);
  }
  for (let l of i)
    l.parent.nodes.length > 1 ? l.remove() : l.parent.remove();
  Ac(t, e, r2);
}
function Js(t) {
  return (e) => {
    let r2 = tw(() => Zv(e, t));
    Ac(e, t, r2);
  };
}
var cr = H(Ls());
var Vc = H(Cc());
var aa = H(jc());
function ia(t) {
  return typeof t == "object" && t !== null;
}
function cw(t, e) {
  let r2 = Ne(e);
  do
    if (r2.pop(), (0, cr.default)(t, r2) !== undefined)
      break;
  while (r2.length);
  return r2.length ? r2 : undefined;
}
function ft(t) {
  return typeof t == "string" ? t : t.reduce((e, r2, n) => r2.includes(".") ? `${e}[${r2}]` : n === 0 ? r2 : `${e}.${r2}`, "");
}
function Wc(t) {
  return t.map((e) => `'${e}'`).join(", ");
}
function zc(t) {
  return Wc(Object.keys(t));
}
function sa(t, e, r2, n = {}) {
  let i = Array.isArray(e) ? ft(e) : e.replace(/^['"]+|['"]+$/g, ""), a = Array.isArray(e) ? e : Ne(i), s = (0, cr.default)(t.theme, a, r2);
  if (s === undefined) {
    let l = `'${i}' does not exist in your theme config.`, u = a.slice(0, -1), f = (0, cr.default)(t.theme, u);
    if (ia(f)) {
      let c = Object.keys(f).filter((d) => sa(t, [...u, d]).isValid), p = (0, Vc.default)(a[a.length - 1], c);
      p ? l += ` Did you mean '${ft([...u, p])}'?` : c.length > 0 && (l += ` '${ft(u)}' has the following valid keys: ${Wc(c)}`);
    } else {
      let c = cw(t.theme, i);
      if (c) {
        let p = (0, cr.default)(t.theme, c);
        ia(p) ? l += ` '${ft(c)}' has the following keys: ${zc(p)}` : l += ` '${ft(c)}' is not an object.`;
      } else
        l += ` Your theme has the following top-level keys: ${zc(t.theme)}`;
    }
    return { isValid: false, error: l };
  }
  if (!(typeof s == "string" || typeof s == "number" || typeof s == "function" || s instanceof String || s instanceof Number || Array.isArray(s))) {
    let l = `'${i}' was found but does not resolve to a string.`;
    if (ia(s)) {
      let u = Object.keys(s).filter((f) => sa(t, [...a, f]).isValid);
      u.length && (l += ` Did you mean something like '${ft([...a, u[0]])}'?`);
    }
    return { isValid: false, error: l };
  }
  let [o] = a;
  return { isValid: true, value: Oe(o)(s, n) };
}
function pw(t, e, r2) {
  e = e.map((i) => Bc(t, i, r2));
  let n = [""];
  for (let i of e)
    i.type === "div" && i.value === "," ? n.push("") : n[n.length - 1] += aa.default.stringify(i);
  return n;
}
function Bc(t, e, r2) {
  if (e.type === "function" && r2[e.value] !== undefined) {
    let n = pw(t, e.nodes, r2);
    e.type = "word", e.value = r2[e.value](t, ...n);
  }
  return e;
}
function dw(t, e, r2) {
  return Object.keys(r2).some((i) => e.includes(`${i}(`)) ? (0, aa.default)(e).walk((i) => {
    Bc(t, i, r2);
  }).toString() : e;
}
var hw = { atrule: "params", decl: "value" };
function* mw(t) {
  t = t.replace(/^['"]+|['"]+$/g, "");
  let e = t.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r2;
  yield [t, undefined], e && (t = e[1], r2 = e[2], yield [t, r2]);
}
function gw(t, e, r2) {
  var i;
  let n = Array.from(mw(e)).map(([a, s]) => Object.assign(sa(t, a, r2, { opacityValue: s }), { resolvedPath: a, alpha: s }));
  return (i = n.find((a) => a.isValid)) != null ? i : n[0];
}
function Gc(t) {
  let e = t.tailwindConfig, r2 = { theme: (n, i, ...a) => {
    var p;
    let { isValid: s, value: o, error: l, alpha: u } = gw(e, i, a.length ? a : undefined);
    if (!s) {
      let d = n.parent, m = (p = d == null ? undefined : d.raws.tailwind) == null ? undefined : p.candidate;
      if (d && m !== undefined) {
        t.markInvalidUtilityNode(d), d.remove(), F.warn("invalid-theme-key-in-class", [`The utility \`${m}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n.error(l);
    }
    let f = st(o);
    return (u !== undefined || f !== undefined && typeof f == "function") && (u === undefined && (u = 1), o = ve(f, u, f)), o;
  }, screen: (n, i) => {
    i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let s = Le(e.theme.screens).find(({ name: o }) => o === i);
    if (!s)
      throw n.error(`The '${i}' screen does not exist in your theme.`);
    return Me(s);
  } };
  return (n) => {
    n.walk((i) => {
      let a = hw[i.type];
      a !== undefined && (i[a] = dw(i, i[a], r2));
    });
  };
}
function Hc({ tailwindConfig: { theme: t } }) {
  return function(e) {
    e.walkAtRules("screen", (r2) => {
      let n = r2.params, a = Le(t.screens).find(({ name: s }) => s === n);
      if (!a)
        throw r2.error(`No \`${n}\` screen found.`);
      r2.name = "media", r2.params = Me(a);
    });
  };
}
var On = H(ye());
var Yc = { id(t) {
  return On.default.attribute({ attribute: "id", operator: "=", value: t.value, quoteMark: '"' });
} };
function yw(t) {
  let e = t.filter((o) => o.type !== "pseudo" || o.nodes.length > 0 ? true : o.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o.value)).reverse(), r2 = new Set(["tag", "class", "id", "attribute"]), n = e.findIndex((o) => r2.has(o.type));
  if (n === -1)
    return e.reverse().join("").trim();
  let i = e[n], a = Yc[i.type] ? Yc[i.type](i) : i;
  e = e.slice(0, n);
  let s = e.findIndex((o) => o.type === "combinator" && o.value === ">");
  return s !== -1 && (e.splice(0, s), e.unshift(On.default.universal())), [a, ...e.reverse()].join("").trim();
}
var vw = (0, On.default)((t) => t.map((e) => {
  let r2 = e.split((n) => n.type === "combinator" && n.value === " ").pop();
  return yw(r2);
}));
var oa = new Map;
function ww(t) {
  return oa.has(t) || oa.set(t, vw.transformSync(t)), oa.get(t);
}
function la({ tailwindConfig: t }) {
  return (e) => {
    var i, a;
    let r2 = new Map, n = new Set;
    if (e.walkAtRules("defaults", (s) => {
      if (s.nodes && s.nodes.length > 0) {
        n.add(s);
        return;
      }
      let o = s.params;
      r2.has(o) || r2.set(o, new Set), r2.get(o).add(s.parent), s.remove();
    }), Y(t, "optimizeUniversalDefaults"))
      for (let s of n) {
        let o = new Map, l = (i = r2.get(s.params)) != null ? i : [];
        for (let u of l)
          for (let f of ww(u.selector)) {
            let c = f.includes(":-") || f.includes("::-") ? f : "__DEFAULT__", p = (a = o.get(c)) != null ? a : new Set;
            o.set(c, p), p.add(f);
          }
        if (Y(t, "optimizeUniversalDefaults")) {
          if (o.size === 0) {
            s.remove();
            continue;
          }
          for (let [, u] of o) {
            let f = L.rule({ source: s.source });
            f.selectors = [...u], f.append(s.nodes.map((c) => c.clone())), s.before(f);
          }
        }
        s.remove();
      }
    else if (n.size) {
      let s = L.rule({ selectors: ["*", "::before", "::after"] });
      for (let l of n)
        s.append(l.nodes), s.parent || l.before(s), s.source || (s.source = l.source), l.remove();
      let o = s.clone({ selectors: ["::backdrop"] });
      s.after(o);
    }
  };
}
var Qc = { atrule: ["name", "params"], rule: ["selector"] };
var bw = new Set(Object.keys(Qc));
function ua() {
  function t(e) {
    let r2 = null;
    e.each((n) => {
      if (!bw.has(n.type)) {
        r2 = null;
        return;
      }
      if (r2 === null) {
        r2 = n;
        return;
      }
      let i = Qc[n.type];
      n.type === "atrule" && n.name === "font-face" ? r2 = n : i.every((a) => {
        var s, o;
        return ((s = n[a]) != null ? s : "").replace(/\s+/g, " ") === ((o = r2[a]) != null ? o : "").replace(/\s+/g, " ");
      }) ? (n.nodes && r2.append(n.nodes), n.remove()) : r2 = n;
    }), e.each((n) => {
      n.type === "atrule" && t(n);
    });
  }
  return (e) => {
    t(e);
  };
}
function fa() {
  return (t) => {
    t.walkRules((e) => {
      let r2 = new Map, n = new Set([]), i = new Map;
      e.walkDecls((a) => {
        if (a.parent === e) {
          if (r2.has(a.prop)) {
            if (r2.get(a.prop).value === a.value) {
              n.add(r2.get(a.prop)), r2.set(a.prop, a);
              return;
            }
            i.has(a.prop) || i.set(a.prop, new Set), i.get(a.prop).add(r2.get(a.prop)), i.get(a.prop).add(a);
          }
          r2.set(a.prop, a);
        }
      });
      for (let a of n)
        a.remove();
      for (let a of i.values()) {
        let s = new Map;
        for (let o of a) {
          let l = Sw(o.value);
          l !== null && (s.has(l) || s.set(l, new Set), s.get(l).add(o));
        }
        for (let o of s.values()) {
          let l = Array.from(o).slice(0, -1);
          for (let u of l)
            u.remove();
        }
      }
    });
  };
}
var xw = Symbol("unitless-number");
function Sw(t) {
  var r2;
  let e = /^-?\d*.?\d+([\w%]+)?$/g.exec(t);
  return e ? (r2 = e[1]) != null ? r2 : xw : null;
}
function kw(t) {
  if (!t.walkAtRules)
    return;
  let e = new Set;
  if (t.walkAtRules("apply", (r2) => {
    e.add(r2.parent);
  }), e.size !== 0)
    for (let r2 of e) {
      let n = [], i = [];
      for (let a of r2.nodes)
        a.type === "atrule" && a.name === "apply" ? (i.length > 0 && (n.push(i), i = []), n.push([a])) : i.push(a);
      if (i.length > 0 && n.push(i), n.length !== 1) {
        for (let a of [...n].reverse()) {
          let s = r2.clone({ nodes: [] });
          s.append(a), r2.after(s);
        }
        r2.remove();
      }
    }
}
function An() {
  return (t) => {
    kw(t);
  };
}
function Ew(t) {
  return t.type === "root";
}
function Ow(t) {
  return t.type === "atrule" && t.name === "layer";
}
function Jc(t) {
  return (e, r2) => {
    let n = false;
    e.walkAtRules("tailwind", (i) => {
      if (n)
        return false;
      if (i.parent && !(Ew(i.parent) || Ow(i.parent)))
        return n = true, i.warn(r2, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e.walkRules((i) => {
      if (n)
        return false;
      i.walkRules((a) => (n = true, a.warn(r2, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
}
function ca(t) {
  return async function(e, r2) {
    let { tailwindDirectives: n, applyDirectives: i } = pi(e);
    Jc()(e, r2), An()(e, r2);
    let a = t({ tailwindDirectives: n, applyDirectives: i, registerDependency(s) {
      r2.messages.push({ plugin: "tailwindcss", parent: r2.opts.from, ...s });
    }, createContext(s, o) {
      return pc(s, o, e);
    } })(e, r2);
    if (a.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    a.tailwindConfig, await Ys(a)(e, r2), An()(e, r2), Js(a)(e, r2), Gc(a)(e, r2), Hc(a)(e, r2), la(a)(e, r2), ua(a)(e, r2), fa(a)(e, r2);
  };
}
var Xc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function Kc(t, e) {
  return t === undefined ? e : Array.isArray(t) ? t : [...new Set(e.filter((n) => t !== false && t[n] !== false).concat(Object.keys(t).filter((n) => t[n] !== false)))];
}
function pr({ version: t, from: e, to: r2 }) {
  F.warn(`${e}-color-renamed`, [`As of Tailwind CSS ${t}, \`${e}\` has been renamed to \`${r2}\`.`, "Update your configuration file to silence this warning."]);
}
var Zc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
  return pr({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return pr({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return pr({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return pr({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return pr({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
function pa(t, ...e) {
  var r2, n;
  for (let i of e) {
    for (let a in i)
      (r2 = t == null ? undefined : t.hasOwnProperty) != null && r2.call(t, a) || (t[a] = i[a]);
    for (let a of Object.getOwnPropertySymbols(i))
      (n = t == null ? undefined : t.hasOwnProperty) != null && n.call(t, a) || (t[a] = i[a]);
  }
  return t;
}
function ep(t) {
  var r2;
  (() => {
    if (t.purge || !t.content || !Array.isArray(t.content) && !(typeof t.content == "object" && t.content !== null))
      return false;
    if (Array.isArray(t.content))
      return t.content.every((n) => typeof n == "string" ? true : !(typeof (n == null ? undefined : n.raw) != "string" || n != null && n.extension && typeof (n == null ? undefined : n.extension) != "string"));
    if (typeof t.content == "object" && t.content !== null) {
      if (Object.keys(t.content).some((n) => !["files", "relative", "extract", "transform"].includes(n)))
        return false;
      if (Array.isArray(t.content.files)) {
        if (!t.content.files.every((n) => typeof n == "string" ? true : !(typeof (n == null ? undefined : n.raw) != "string" || n != null && n.extension && typeof (n == null ? undefined : n.extension) != "string")))
          return false;
        if (typeof t.content.extract == "object") {
          for (let n of Object.values(t.content.extract))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.extract === undefined || typeof t.content.extract == "function"))
          return false;
        if (typeof t.content.transform == "object") {
          for (let n of Object.values(t.content.transform))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.transform === undefined || typeof t.content.transform == "function"))
          return false;
        if (typeof t.content.relative != "boolean" && typeof t.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || F.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t.safelist = (() => {
    var s;
    let { content: n, purge: i, safelist: a } = t;
    return Array.isArray(a) ? a : Array.isArray(n == null ? undefined : n.safelist) ? n.safelist : Array.isArray(i == null ? undefined : i.safelist) ? i.safelist : Array.isArray((s = i == null ? undefined : i.options) == null ? undefined : s.safelist) ? i.options.safelist : [];
  })(), t.blocklist = (() => {
    let { blocklist: n } = t;
    if (Array.isArray(n)) {
      if (n.every((i) => typeof i == "string"))
        return n;
      F.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t.prefix == "function" ? (F.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t.prefix = "") : t.prefix = (r2 = t.prefix) != null ? r2 : "", t.content = { relative: (() => {
    let { content: n } = t;
    return n != null && n.relative ? n.relative : Y(t, "relativeContentPathsByDefault");
  })(), files: (() => {
    let { content: n, purge: i } = t;
    return Array.isArray(i) ? i : Array.isArray(i == null ? undefined : i.content) ? i.content : Array.isArray(n) ? n : Array.isArray(n == null ? undefined : n.content) ? n.content : Array.isArray(n == null ? undefined : n.files) ? n.files : [];
  })(), extract: (() => {
    let n = (() => {
      var s, o, l, u, f, c, p, d, m, w;
      return (s = t.purge) != null && s.extract ? t.purge.extract : (o = t.content) != null && o.extract ? t.content.extract : (u = (l = t.purge) == null ? undefined : l.extract) != null && u.DEFAULT ? t.purge.extract.DEFAULT : (c = (f = t.content) == null ? undefined : f.extract) != null && c.DEFAULT ? t.content.extract.DEFAULT : (d = (p = t.purge) == null ? undefined : p.options) != null && d.extractors ? t.purge.options.extractors : (w = (m = t.content) == null ? undefined : m.options) != null && w.extractors ? t.content.options.extractors : {};
    })(), i = {}, a = (() => {
      var s, o, l, u;
      if ((o = (s = t.purge) == null ? undefined : s.options) != null && o.defaultExtractor)
        return t.purge.options.defaultExtractor;
      if ((u = (l = t.content) == null ? undefined : l.options) != null && u.defaultExtractor)
        return t.content.options.defaultExtractor;
    })();
    if (a !== undefined && (i.DEFAULT = a), typeof n == "function")
      i.DEFAULT = n;
    else if (Array.isArray(n))
      for (let { extensions: s, extractor: o } of n != null ? n : [])
        for (let l of s)
          i[l] = o;
    else
      typeof n == "object" && n !== null && Object.assign(i, n);
    return i;
  })(), transform: (() => {
    let n = (() => {
      var a, s, o, l, u, f;
      return (a = t.purge) != null && a.transform ? t.purge.transform : (s = t.content) != null && s.transform ? t.content.transform : (l = (o = t.purge) == null ? undefined : o.transform) != null && l.DEFAULT ? t.purge.transform.DEFAULT : (f = (u = t.content) == null ? undefined : u.transform) != null && f.DEFAULT ? t.content.transform.DEFAULT : {};
    })(), i = {};
    return typeof n == "function" && (i.DEFAULT = n), typeof n == "object" && n !== null && Object.assign(i, n), i;
  })() };
  for (let n of t.content.files)
    if (typeof n == "string" && /{([^,]*?)}/g.test(n)) {
      F.warn("invalid-glob-braces", [`The glob pattern ${n} in your Tailwind CSS configuration is invalid.`, `Update it to ${n.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t;
}
function Cn(t) {
  return Array.isArray(t) ? t.map((e) => Cn(e)) : typeof t == "object" && t !== null ? Object.fromEntries(Object.entries(t).map(([e, r2]) => [e, Cn(r2)])) : t;
}
function ct(t) {
  return typeof t == "function";
}
function dr(t, ...e) {
  let r2 = e.pop();
  for (let n of e)
    for (let i in n) {
      let a = r2(t[i], n[i]);
      a === undefined ? X(t[i]) && X(n[i]) ? t[i] = dr({}, t[i], n[i], r2) : t[i] = n[i] : t[i] = a;
    }
  return t;
}
var da = { colors: Zc, negative(t) {
  return Object.keys(t).filter((e) => t[e] !== "0").reduce((e, r2) => {
    let n = Re(t[r2]);
    return n !== undefined && (e[`-${r2}`] = n), e;
  }, {});
}, breakpoints(t) {
  return Object.keys(t).filter((e) => typeof t[e] == "string").reduce((e, r2) => ({ ...e, [`screen-${r2}`]: t[r2] }), {});
} };
function Aw(t, ...e) {
  return ct(t) ? t(...e) : t;
}
function Cw(t) {
  return t.reduce((e, { extend: r2 }) => dr(e, r2, (n, i) => n === undefined ? [i] : Array.isArray(n) ? [i, ...n] : [i, n]), {});
}
function _w(t) {
  return { ...t.reduce((e, r2) => pa(e, r2), {}), extend: Cw(t) };
}
function tp(t, e) {
  if (Array.isArray(t) && X(t[0]))
    return t.concat(e);
  if (Array.isArray(e) && X(e[0]) && X(t))
    return [t, ...e];
  if (Array.isArray(e))
    return e;
}
function Tw({ extend: t, ...e }) {
  return dr(e, t, (r2, n) => !ct(r2) && !n.some(ct) ? dr({}, r2, ...n, tp) : (i, a) => dr({}, ...[r2, ...n].map((s) => Aw(s, i, a)), tp));
}
function* Pw(t) {
  let e = Ne(t);
  if (e.length === 0 || (yield e, Array.isArray(t)))
    return;
  let r2 = /^(.*?)\s*\/\s*([^/]+)$/, n = t.match(r2);
  if (n !== null) {
    let [, i, a] = n, s = Ne(i);
    s.alpha = a, yield s;
  }
}
function Iw(t) {
  let e = (r2, n) => {
    for (let i of Pw(r2)) {
      let a = 0, s = t;
      for (;s != null && a < i.length; )
        s = s[i[a++]], s = ct(s) && (i.alpha === undefined || a <= i.length - 1) ? s(e, da) : s;
      if (s !== undefined) {
        if (i.alpha !== undefined) {
          let o = st(s);
          return ve(o, i.alpha, M(o));
        }
        return X(s) ? Cn(s) : s;
      }
    }
    return n;
  };
  return Object.assign(e, { theme: e, ...da }), Object.keys(t).reduce((r2, n) => (r2[n] = ct(t[n]) ? t[n](e, da) : t[n], r2), {});
}
function rp(t) {
  let e = [];
  return t.forEach((r2) => {
    var i;
    e = [...e, r2];
    let n = (i = r2 == null ? undefined : r2.plugins) != null ? i : [];
    n.length !== 0 && n.forEach((a) => {
      var s;
      a.__isOptionsFunction && (a = a()), e = [...e, ...rp([(s = a == null ? undefined : a.config) != null ? s : {}])];
    });
  }), e;
}
function Rw(t) {
  return [...t].reduceRight((r2, n) => ct(n) ? n({ corePlugins: r2 }) : Kc(n, r2), Xc);
}
function Dw(t) {
  return [...t].reduceRight((r2, n) => [...r2, ...n], []);
}
function ha(t) {
  let e = [...rp(t), { prefix: "", important: false, separator: ":" }];
  return ep(pa({ theme: Iw(Tw(_w(e.map((r2) => {
    var n;
    return (n = r2 == null ? undefined : r2.theme) != null ? n : {};
  })))), corePlugins: Rw(e.map((r2) => r2.corePlugins)), plugins: Dw(t.map((r2) => {
    var n;
    return (n = r2 == null ? undefined : r2.plugins) != null ? n : [];
  })) }, ...e));
}
var sp = H(ip());
function _n(t) {
  var i;
  let e = ((i = t == null ? undefined : t.presets) != null ? i : [sp.default]).slice().reverse().flatMap((a) => _n(a instanceof Function ? a() : a)), r2 = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: a }) => ({ DEFAULT: "#3b82f67f", ...a("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n = Object.keys(r2).filter((a) => Y(t, a)).map((a) => r2[a]);
  return [t, ...n, ...e];
}
function ma(...t) {
  let [, ...e] = _n(t[0]);
  return ha([...t, ...e]);
}
function ap(t) {
  var n;
  let e = ma((n = t.config) != null ? n : {});
  return ca((i) => () => i.createContext(e, [{ content: t.content }]));
}
async function CE(t, e) {
  let r2 = e == null ? undefined : e.corePlugins, n = { ...e, corePlugins: { preflight: false, ...r2 } }, i = ap({ config: n, content: t });
  return (await L([i, (0, op.default)()]).process(String.raw`
          @tailwind base;
          @tailwind components;
          @tailwind utilities;
        `, { from: undefined })).css;
}
function TE(t) {
  return t.replace(/([^\\]|^)(?=([^a-zA-Z0-9\-_]))/g, (e, r2, n) => r2 === "" && n === "\\" ? e : `${r2}\\`);
}
function IE(t) {
  let e = {};
  for (let [r2, n, i] of t.matchAll(/\s*\.([\S]+)\s*{([^}]*)}/gm))
    e[n.trim()] = i.replace(/^\n+/, "").replace(/\n+$/, "").trim();
  return e;
}
function LE(t) {
  return t.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}");
}
function FE(t) {
  let e = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/gm;
  return t.replaceAll(e, (r2, n, i, a, s) => {
    let o = s === "1" || typeof s > "u" ? "" : `,${s}`;
    return `rgb(${n},${i},${a}${o})`;
  });
}
/*! Bundled license information:

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/

// ../../../../node_modules/vue-email/dist/index.mjs
function isObject$1(item) {
  return !!item && typeof item === "object" && !Array.isArray(item);
}
function deepmerge$1(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject$1(target) && isObject$1(source)) {
    for (const key in source) {
      if (isObject$1(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        deepmerge$1(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepmerge$1(target, ...sources);
}
function cleanup(str) {
  if (!str || typeof str !== "string")
    return str;
  return str.replace(/ data-v-inspector="[^"]*"/g, "").replace(/<!--\[-->/g, "").replace(/<!--]-->/g, "").replace(/<template>/g, "").replace(/<template[^>]*>/g, "").replace(/<\/template>/g, "").replace(/<clean-component>/g, "").replace(/<clean-component[^>]*>/g, "").replace(/<\/clean-component>/g, "");
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$1(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text$1 = ElementType.Text;
var Directive = ElementType.Directive;
var Comment$1 = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA$1 = ElementType.CDATA;
var Doctype = ElementType.Doctype;

class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}

class DataNode extends Node {
  constructor(data) {
    super();
    this.data = data;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}

class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}

class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}

class ProcessingInstruction extends DataNode {
  constructor(name2, data) {
    super(data);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}

class NodeWithChildren extends Node {
  constructor(children) {
    super();
    this.children = children;
  }
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== undefined ? _a2 : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}

class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}

class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}

class Element extends NodeWithChildren {
  constructor(name2, attribs, children = [], type = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a2, _b2;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === undefined ? undefined : _a2[name2],
        prefix: (_b2 = this["x-attribsPrefix"]) === null || _b2 === undefined ? undefined : _b2[name2]
      };
    });
  }
}
function isTag(node) {
  return isTag$1(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1;i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name2, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text("");
    const node = new CDATA([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data) {
    const node = new ProcessingInstruction(name2, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
}
var e = /\n/g;
function n(n2) {
  const o = [...n2.matchAll(e)].map((e2) => e2.index || 0);
  o.unshift(-1);
  const s = t(o, 0, o.length);
  return (e2) => r2(s, e2);
}
function t(e2, n2, r2) {
  if (r2 - n2 == 1)
    return { offset: e2[n2], index: n2 + 1 };
  const o = Math.ceil((n2 + r2) / 2), s = t(e2, n2, o), l = t(e2, o, r2);
  return { offset: s.offset, low: s, high: l };
}
function r2(e2, n2) {
  return function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  }(e2) ? { line: e2.index, column: n2 - e2.offset } : r2(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t2 = "", r3 = {}) {
  const o2 = typeof t2 != "string" ? t2 : r3, l = typeof t2 == "string" ? t2 : "", c = e2.map(s), f = !!o2.lineNumbers;
  return function(e3, t3 = 0) {
    const r4 = f ? n(e3) : () => ({ line: 0, column: 0 });
    let o3 = t3;
    const s = [];
    e:
      for (;o3 < e3.length; ) {
        let n2 = false;
        for (const t4 of c) {
          t4.regex.lastIndex = o3;
          const c2 = t4.regex.exec(e3);
          if (c2 && c2[0].length > 0) {
            if (!t4.discard) {
              const e4 = r4(o3), n3 = typeof t4.replace == "string" ? c2[0].replace(new RegExp(t4.regex.source, t4.regex.flags), t4.replace) : c2[0];
              s.push({ state: l, name: t4.name, text: n3, offset: o3, len: c2[0].length, line: e4.line, column: e4.column });
            }
            if (o3 = t4.regex.lastIndex, n2 = true, t4.push) {
              const n3 = t4.push(e3, o3);
              s.push(...n3.tokens), o3 = n3.offset;
            }
            if (t4.pop)
              break e;
            break;
          }
        }
        if (!n2)
          break;
      }
    return { tokens: s, offset: o3, complete: e3.length <= o3 };
  };
}
function s(e2, n2) {
  return { ...e2, regex: l(e2, n2) };
}
function l(e2, n2) {
  if (e2.name.length === 0)
    throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  }(e2))
    return function(e3) {
      if (e3.global)
        throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
      return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
    }(e2.regex);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  }(e2)) {
    if (e2.str.length === 0)
      throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
function token$1(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = undefined;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i);
    }
    return value === undefined ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r3, f) {
  return r3.matched ? {
    matched: true,
    position: r3.position,
    value: f(r3.value, r3.position)
  } : r3;
}
function mapOuter(r3, f) {
  return r3.matched ? f(r3) : r3;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function option(p, def) {
  return (data, i) => {
    const r3 = p(data, i);
    return r3.matched ? r3 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps) {
  return (data, i) => {
    for (const p of ps) {
      const result = p(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa2, pb) {
  return (data, i) => {
    const r1 = pa2(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r3 = p(data, i);
      if (r3.matched && test(r3.value, values.length + 1, data, i, r3.position)) {
        values.push(r3.value);
        i = r3.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa2, pb, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapInner(pb(data, ma2.position), (vb, j) => join(ma2.value, vb, data, i, j)));
}
function left(pa2, pb) {
  return ab(pa2, pb, (va) => va);
}
function right(pa2, pb) {
  return ab(pa2, pb, (va, vb) => vb);
}
function abc(pa2, pb, pc2, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapOuter(pb(data, ma2.position), (mb) => mapInner(pc2(data, mb.position), (vc2, j) => join(ma2.value, mb.value, vc2, data, i, j))));
}
function middle(pa2, pb, pc2) {
  return abc(pa2, pb, pc2, (ra, rb) => rb);
}
function all(...ps) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p of ps) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps) {
  return flatten1(all(...ps));
}
function flatten1(p) {
  return map(p, (vs) => vs.flatMap((v) => v));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r3 = f(acc1, data, pos)(data, pos);
      if (r3.matched) {
        acc1 = r3.value;
        pos = r3.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v, data, i, j) => reducer(acc2, v, data, i, j)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}
var ws2 = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
var name2 = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
var string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
var lexSelector = o([
  { name: "ws", regex: new RegExp(ws2) },
  { name: "hash", regex: new RegExp(`#${name2}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string2, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape2, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
  return [a0 + b0, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
}
var unicodeEscapedSequence_ = token$1((t2) => t2.name === "unicode" ? String.fromCodePoint(parseInt(t2.text.slice(1), 16)) : undefined);
var escapedSequence_ = token$1((t2) => t2.name === "escape" ? t2.text.slice(1) : undefined);
var anyChar_ = token$1((t2) => t2.name === "any" ? t2.text : undefined);
var escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(""));
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result.value;
}
function literal(name3) {
  return token$1((t2) => t2.name === name3 ? true : undefined);
}
var whitespace_ = token$1((t2) => t2.name === "ws" ? null : undefined);
var optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
var identifier_ = token$1((t2) => t2.name === "ident" ? unescape2(t2.text) : undefined);
var hashId_ = token$1((t2) => t2.name === "hash" ? unescape2(t2.text.slice(1)) : undefined);
var string_ = token$1((t2) => t2.name.startsWith("str") ? unescape2(t2.text.slice(1, -1)) : undefined);
var namespace_ = left(option(identifier_, ""), literal("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name3) => ({ name: name3, namespace: ns })), map(identifier_, (name3) => ({ name: name3, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map(qualifiedName_, ({ name: name3, namespace }) => ({
  type: "tag",
  name: name3,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal("."), identifier_, (fullstop, name3) => ({
  type: "class",
  name: name3,
  specificity: [0, 1, 0]
}));
var idSelector_ = map(hashId_, (name3) => ({
  type: "id",
  name: name3,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token$1((t2) => {
  if (t2.name === "ident") {
    if (t2.text === "i" || t2.text === "I") {
      return "i";
    }
    if (t2.text === "s" || t2.text === "S") {
      return "s";
    }
  }
  return;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
var attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
var attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name3, namespace }) => ({
  type: "attrPresence",
  name: name3,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name3, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name: name3,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
  return {
    type: "compound",
    list: ss,
    specificity: sumAllSpec(ss.map((s2) => s2.specificity))
  };
});
var combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c2) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!
` + prettyPrintPosition(str, token.offset, token.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t2, r3) => t2 ? "\u2409" : r3 ? "\u240D" : "\u240A")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node) => {
        if (node.type === "combinator") {
          return serialize(node) + acc;
        } else {
          return acc + serialize(node);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns) {
  return ns || ns === "" ? _serIdent(ns) + "|" : "";
}
function _codePoint(char) {
  return `\\${char.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl2, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
}
function _serStr(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs2, nl2, ctrl) => dq ? "\\\"" : bs2 ? "\\\\" : nl2 ? "\uFFFD" : _codePoint(ctrl));
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => serialize(a) < serialize(b) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b) {
  return _compareArrays(a, b);
}
function _compareArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b.length ? a.length : b.length;
  for (let i = 0;i < shorter; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return a.length - b.length;
}

class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0;i < len; i++) {
    const [selectorString, val] = array[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
      matches.forEach((node) => results.push(node));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name3, group]) => ({
    type: "variant",
    value: name3,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name3, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name3);
  }
  return {
    type: "attrPresence",
    name: name3,
    cont: weave(items)
  };
}
function attrValueBranch(name3, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name3, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name3,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length;i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}

class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1;i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node) {
  switch (node.type) {
    case "terminal": {
      const result = [node.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node);
    case "attrValue":
      return handleAttrValueName(node);
    case "attrPresence":
      return handleAttrPresenceName(node);
    case "pushElement":
      return handlePushElementNode(node);
    case "popElement":
      return handlePopElementNode(node);
  }
}
function handleTagName(node) {
  const variants = {};
  for (const variant of node.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node) {
  const attrName = node.name;
  const continuation = handleArray(node.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node) {
  const callbacks = [];
  for (const matcher of node.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node) {
  const continuation = handleArray(node.cont);
  const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag(parent) ? parent : null;
};
function handlePopElementNode(node) {
  const continuation = handleArray(node.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}
var htmlDecodeTree = new Uint16Array("\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\x00\x00\x00\x00\x00\x00\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\x00\x00\x00\u0342\u0354\x00\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\x00\x00\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\x00\x00\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\x00\u0446\x00\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\x00\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\x00\x00\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\x00\x00\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\x00\u05BF\x00\x00\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\x00\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\x00\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\x00\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\x00\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\x00\u08C3bleBracket;\u67E6n\u01D4\u08C8\x00\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B\"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\x00\u1005bleBracket;\u67E7n\u01D4\u100A\x00\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\x00\x00\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\x00\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\x00\u132C\u1331\x00\x00\x00\x00\x00\u1338\u133D\u1377\u1385\x00\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\x00\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\x00\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\x00\u15B0\u15B6\u15BF\x00\x00\x00\x00\u15C6\u15DB\u15EB\u165F\u166D\x00\u1695\u169B\u16B2\u16B9\x00\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\x00\x00\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\x00\x00\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\x00\u1833\u01B2\u182F\x00\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\x00\u19E8\u1A11\u1A15\u1A32\x00\u1A37\u1A50\x00\x00\u1AB4\x00\x00\u1AC1\x00\x00\u1B21\u1B2E\u1B4D\u1B52\x00\u1BFD\x00\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\x00\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\x00\x00\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\x00\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\x00\x00\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\x00\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\x00\x00\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\x00\x00\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\x00\x00\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\x00\x00\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\x00\x00\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\x00\u1F9E\x00\u1FA1\u1FA7\x00\x00\u1FC6\u1FCC\x00\u1FD3\x00\u1FE6\u1FEA\u2000\x00\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\x00\x00\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\x00\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\x00\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\x00\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\x00\u2036;\u6154;\u6156\u02B4\u203E\u2041\x00\x00\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\x00\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\x00\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\x00\u22AA\x00\u22B8\u22C5\u22CE\x00\u22D5\u22F3\x00\x00\u22F8\u2322\u2367\u2362\u237F\x00\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\x00\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\x00\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\x00\u24AA\x00\u24B1\x00\x00\x00\x00\x00\u24B5\u24BA\x00\u24C6\u24C8\u24CD\x00\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\x00\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\x00\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\x00\x00\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\u2D2D\x00\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\x00\x00\u2D8D\u2DAB\x00\u2DC8\u2DCE\x00\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\x00\x00\u2D7C\x00\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\x00\u2E7D\x00\u2E80\u2E9D\x00\u2EA2\u2EB9\x00\x00\u2ECB\u0E9C\x00\u2F13\x00\x00\u2F2B\u2FBC\x00\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\x00\x00\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\x00\u337A\u33A4\x00\x00\u33EC\u33F0\x00\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\x00\u3616\x00\x00\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\x00\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\x00\x00\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\x00\u367E\u36C2\x00\x00\x00\x00\x00\u36DB\u3703\x00\u3709\u376C\x00\x00\x00\u3787\u0272\u3656\x00\x00\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\x00\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\x00\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\x00\x00\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\x00\x00\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\x00\u3A8B\x00\u3A90\u3A9B\x00\x00\u3A9D\u3AA8\u3AAB\u3AAF\x00\x00\u3AC3\u3ACE\x00\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C".split("").map((c2) => c2.charCodeAt(0)));
var xmlDecodeTree = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\x00\x00\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0)));
var _a2;
var decodeMap2 = new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a2 = String.fromCodePoint) !== null && _a2 !== undefined ? _a2 : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== undefined ? _a3 : codePoint;
}
var CharCodes$2;
(function(CharCodes) {
  CharCodes[CharCodes["NUM"] = 35] = "NUM";
  CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
  CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
  CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
  CharCodes[CharCodes["NINE"] = 57] = "NINE";
  CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
  CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
  CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
  CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
  CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
  CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes$2 || (CharCodes$2 = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber$1(code) {
  return code >= CharCodes$2.ZERO && code <= CharCodes$2.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes$2.UPPER_A && code <= CharCodes$2.UPPER_F || code >= CharCodes$2.LOWER_A && code <= CharCodes$2.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes$2.UPPER_A && code <= CharCodes$2.UPPER_Z || code >= CharCodes$2.LOWER_A && code <= CharCodes$2.LOWER_Z || isNumber$1(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes$2.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes$2.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$2.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === undefined || _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes$2.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes$2.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes$2.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === undefined || _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === undefined || _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi2 = lo + branchCount - 1;
  while (lo <= hi2) {
    const mid = lo + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
var CharCodes$1;
(function(CharCodes) {
  CharCodes[CharCodes["Tab"] = 9] = "Tab";
  CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
  CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
  CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes[CharCodes["Space"] = 32] = "Space";
  CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes[CharCodes["Number"] = 35] = "Number";
  CharCodes[CharCodes["Amp"] = 38] = "Amp";
  CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
  CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes[CharCodes["Dash"] = 45] = "Dash";
  CharCodes[CharCodes["Slash"] = 47] = "Slash";
  CharCodes[CharCodes["Zero"] = 48] = "Zero";
  CharCodes[CharCodes["Nine"] = 57] = "Nine";
  CharCodes[CharCodes["Semi"] = 59] = "Semi";
  CharCodes[CharCodes["Lt"] = 60] = "Lt";
  CharCodes[CharCodes["Eq"] = 61] = "Eq";
  CharCodes[CharCodes["Gt"] = 62] = "Gt";
  CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
  CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
  CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
  CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
  CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
  CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
  CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
  CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
  CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes$1 || (CharCodes$1 = {}));
var State$1;
(function(State) {
  State[State["Text"] = 1] = "Text";
  State[State["BeforeTagName"] = 2] = "BeforeTagName";
  State[State["InTagName"] = 3] = "InTagName";
  State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State[State["InClosingTagName"] = 6] = "InClosingTagName";
  State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State[State["InAttributeName"] = 9] = "InAttributeName";
  State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
  State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State[State["InDeclaration"] = 16] = "InDeclaration";
  State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State[State["BeforeComment"] = 18] = "BeforeComment";
  State[State["CDATASequence"] = 19] = "CDATASequence";
  State[State["InSpecialComment"] = 20] = "InSpecialComment";
  State[State["InCommentLike"] = 21] = "InCommentLike";
  State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State[State["InSpecialTag"] = 24] = "InSpecialTag";
  State[State["BeforeEntity"] = 25] = "BeforeEntity";
  State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State[State["InNamedEntity"] = 27] = "InNamedEntity";
  State[State["InNumericEntity"] = 28] = "InNumericEntity";
  State[State["InHexEntity"] = 29] = "InHexEntity";
})(State$1 || (State$1 = {}));
function isWhitespace$3(c2) {
  return c2 === CharCodes$1.Space || c2 === CharCodes$1.NewLine || c2 === CharCodes$1.Tab || c2 === CharCodes$1.FormFeed || c2 === CharCodes$1.CarriageReturn;
}
function isEndOfTagSection$1(c2) {
  return c2 === CharCodes$1.Slash || c2 === CharCodes$1.Gt || isWhitespace$3(c2);
}
function isNumber(c2) {
  return c2 >= CharCodes$1.Zero && c2 <= CharCodes$1.Nine;
}
function isASCIIAlpha$1(c2) {
  return c2 >= CharCodes$1.LowerA && c2 <= CharCodes$1.LowerZ || c2 >= CharCodes$1.UpperA && c2 <= CharCodes$1.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes$1.UpperA && c2 <= CharCodes$1.UpperF || c2 >= CharCodes$1.LowerA && c2 <= CharCodes$1.LowerF;
}
var QuoteType$1;
(function(QuoteType) {
  QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
  QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
  QuoteType[QuoteType["Single"] = 2] = "Single";
  QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType$1 || (QuoteType$1 = {}));
var Sequences$1 = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
};
var Tokenizer$1 = class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State$1.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State$1.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
  }
  reset() {
    this.state = State$1.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State$1.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes$1.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes$1.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State$1.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes$1.Amp) {
      this.state = State$1.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection$1(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State$1.InTagName;
    this.stateInTagName(c2);
  }
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes$1.Gt || isWhitespace$3(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences$1.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes$1.Amp) {
          this.state = State$1.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes$1.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes$1.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences$1.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences$1.Cdata.length) {
        this.state = State$1.InCommentLike;
        this.currentSequence = Sequences$1.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State$1.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences$1.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State$1.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection$1(c2) : isASCIIAlpha$1(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State$1.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes$1.ExclamationMark) {
      this.state = State$1.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$1.Questionmark) {
      this.state = State$1.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences$1.TitleEnd[2]) {
        this.startSpecial(Sequences$1.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences$1.ScriptEnd[2] ? State$1.BeforeSpecialS : State$1.InTagName;
      }
    } else if (c2 === CharCodes$1.Slash) {
      this.state = State$1.BeforeClosingTagName;
    } else {
      this.state = State$1.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection$1(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State$1.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace$3(c2))
      ;
    else if (c2 === CharCodes$1.Gt) {
      this.state = State$1.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State$1.InClosingTagName : State$1.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes$1.Gt || isWhitespace$3(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State$1.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes$1.Gt || this.fastForwardTo(CharCodes$1.Gt)) {
      this.state = State$1.Text;
      this.baseState = State$1.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes$1.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State$1.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State$1.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$1.Slash) {
      this.state = State$1.InSelfClosingTag;
    } else if (!isWhitespace$3(c2)) {
      this.state = State$1.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes$1.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State$1.Text;
      this.baseState = State$1.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace$3(c2)) {
      this.state = State$1.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes$1.Eq || isEndOfTagSection$1(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State$1.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes$1.Eq) {
      this.state = State$1.BeforeAttributeValue;
    } else if (c2 === CharCodes$1.Slash || c2 === CharCodes$1.Gt) {
      this.cbs.onattribend(QuoteType$1.NoValue, this.index);
      this.state = State$1.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace$3(c2)) {
      this.cbs.onattribend(QuoteType$1.NoValue, this.index);
      this.state = State$1.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes$1.DoubleQuote) {
      this.state = State$1.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$1.SingleQuote) {
      this.state = State$1.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace$3(c2)) {
      this.sectionStart = this.index;
      this.state = State$1.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes$1.DoubleQuote ? QuoteType$1.Double : QuoteType$1.Single, this.index);
      this.state = State$1.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes$1.Amp) {
      this.baseState = this.state;
      this.state = State$1.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes$1.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes$1.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace$3(c2) || c2 === CharCodes$1.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType$1.Unquoted, this.index);
      this.state = State$1.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes$1.Amp) {
      this.baseState = this.state;
      this.state = State$1.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes$1.OpeningSquareBracket) {
      this.state = State$1.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes$1.Dash ? State$1.BeforeComment : State$1.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes$1.Gt || this.fastForwardTo(CharCodes$1.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State$1.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes$1.Gt || this.fastForwardTo(CharCodes$1.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State$1.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes$1.Dash) {
      this.state = State$1.InCommentLike;
      this.currentSequence = Sequences$1.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State$1.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes$1.Gt || this.fastForwardTo(CharCodes$1.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State$1.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences$1.ScriptEnd[3]) {
      this.startSpecial(Sequences$1.ScriptEnd, 4);
    } else if (lower === Sequences$1.StyleEnd[3]) {
      this.startSpecial(Sequences$1.StyleEnd, 4);
    } else {
      this.state = State$1.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes$1.Number) {
      this.state = State$1.BeforeNumericEntity;
    } else if (c2 === CharCodes$1.Amp)
      ;
    else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State$1.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes$1.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes$1.LowerX) {
      this.entityExcess++;
      this.state = State$1.InHexEntity;
    } else {
      this.state = State$1.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State$1.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes$1.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes$1.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes$1.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes$1.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes$1.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State$1.Text || this.baseState === State$1.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State$1.Text || this.state === State$1.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State$1.InAttributeValueDq || this.state === State$1.InAttributeValueSq || this.state === State$1.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State$1.Text: {
          this.stateText(c2);
          break;
        }
        case State$1.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State$1.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State$1.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State$1.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State$1.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State$1.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State$1.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State$1.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State$1.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State$1.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State$1.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State$1.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State$1.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State$1.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State$1.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State$1.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State$1.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State$1.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State$1.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State$1.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State$1.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State$1.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State$1.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State$1.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State$1.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State$1.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State$1.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State$1.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State$1.InCommentLike) {
      if (this.currentSequence === Sequences$1.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State$1.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State$1.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State$1.InTagName || this.state === State$1.BeforeAttributeName || this.state === State$1.BeforeAttributeValue || this.state === State$1.AfterAttributeName || this.state === State$1.InAttributeName || this.state === State$1.InAttributeValueSq || this.state === State$1.InAttributeValueDq || this.state === State$1.InAttributeValueNq || this.state === State$1.InClosingTagName)
      ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State$1.Text && this.baseState !== State$1.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp2) {
    if (this.baseState !== State$1.Text && this.baseState !== State$1.InSpecialTag) {
      this.cbs.onattribentity(cp2);
    } else {
      this.cbs.ontextentity(cp2);
    }
  }
};
var formTags$1 = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag$1 = new Set(["p"]);
var tableSectionTags$1 = new Set(["thead", "tbody"]);
var ddtTags$1 = new Set(["dd", "dt"]);
var rtpTags$1 = new Set(["rt", "rp"]);
var openImpliesClose$1 = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag$1],
  ["h1", pTag$1],
  ["h2", pTag$1],
  ["h3", pTag$1],
  ["h4", pTag$1],
  ["h5", pTag$1],
  ["h6", pTag$1],
  ["select", formTags$1],
  ["input", formTags$1],
  ["output", formTags$1],
  ["button", formTags$1],
  ["datalist", formTags$1],
  ["textarea", formTags$1],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags$1],
  ["dt", ddtTags$1],
  ["address", pTag$1],
  ["article", pTag$1],
  ["aside", pTag$1],
  ["blockquote", pTag$1],
  ["details", pTag$1],
  ["div", pTag$1],
  ["dl", pTag$1],
  ["fieldset", pTag$1],
  ["figcaption", pTag$1],
  ["figure", pTag$1],
  ["footer", pTag$1],
  ["form", pTag$1],
  ["header", pTag$1],
  ["hr", pTag$1],
  ["main", pTag$1],
  ["nav", pTag$1],
  ["ol", pTag$1],
  ["pre", pTag$1],
  ["section", pTag$1],
  ["table", pTag$1],
  ["ul", pTag$1],
  ["rt", rtpTags$1],
  ["rp", rtpTags$1],
  ["tbody", tableSectionTags$1],
  ["tfoot", tableSectionTags$1]
]);
var voidElements$1 = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements$1 = new Set(["math", "svg"]);
var htmlIntegrationElements$1 = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd$1 = /\s|\//;
var Parser$1 = class Parser {
  constructor(cbs, options = {}) {
    var _a3, _b2, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== undefined ? _a3 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b2 = options.lowerCaseAttributeNames) !== null && _b2 !== undefined ? _b2 : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer$1)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a3, _b2;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b2 = (_a3 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a3, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp2) {
    var _a3, _b2;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b2 = (_a3 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a3, fromCodePoint(cp2));
    this.startIndex = index;
  }
  isVoidElement(name3) {
    return !this.options.xmlMode && voidElements$1.has(name3);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name3 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    this.emitOpenTag(name3);
  }
  emitOpenTag(name3) {
    var _a3, _b2, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name3;
    const impliesClose = !this.options.xmlMode && openImpliesClose$1.get(name3);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b2 = (_a3 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name3)) {
      this.stack.push(name3);
      if (foreignContextElements$1.has(name3)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements$1.has(name3)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name3);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b2;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b2 = (_a3 = this.cbs).onopentag) === null || _b2 === undefined || _b2.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a3, _b2, _c, _d, _e, _f2;
    this.endIndex = endIndex;
    let name3 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    if (foreignContextElements$1.has(name3) || htmlIntegrationElements$1.has(name3)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name3)) {
      const pos = this.stack.lastIndexOf(name3);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name3 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name3 === "br") {
      (_b2 = (_a3 = this.cbs).onopentagname) === null || _b2 === undefined || _b2.call(_a3, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f2 = (_e = this.cbs).onclosetag) === null || _f2 === undefined || _f2.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b2;
    const name3 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name3) {
      (_b2 = (_a3 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a3, name3, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name3 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name3.toLowerCase() : name3;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp2) {
    this.attribvalue += fromCodePoint(cp2);
  }
  onattribend(quote, endIndex) {
    var _a3, _b2;
    this.endIndex = endIndex;
    (_b2 = (_a3 = this.cbs).onattribute) === null || _b2 === undefined || _b2.call(_a3, this.attribname, this.attribvalue, quote === QuoteType$1.Double ? '"' : quote === QuoteType$1.Single ? "'" : quote === QuoteType$1.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd$1);
    let name3 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    return name3;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name3 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name3}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name3 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name3}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a3, _b2, _c, _d;
    this.endIndex = endIndex;
    (_b2 = (_a3 = this.cbs).oncomment) === null || _b2 === undefined || _b2.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a3, _b2, _c, _d, _e, _f2, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b2 = (_a3 = this.cbs).oncdatastart) === null || _b2 === undefined || _b2.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f2 = (_e = this.cbs).oncdataend) === null || _f2 === undefined || _f2.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a3, _b2;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b2 = (_a3 = this.cbs).onend) === null || _b2 === undefined || _b2.call(_a3);
  }
  reset() {
    var _a3, _b2, _c, _d;
    (_b2 = (_a3 = this.cbs).onreset) === null || _b2 === undefined || _b2.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a3, _b2;
    if (this.ended) {
      (_b2 = (_a3 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a3, _b2;
    if (this.ended) {
      (_b2 = (_a3 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
};
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));
var unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a3;
  if (!attributes)
    return;
  const encode3 = ((_a3 = opts.encodeEntities) !== null && _a3 !== undefined ? _a3 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a4, _b2;
    const value = (_a4 = attributes[key]) !== null && _a4 !== undefined ? _a4 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b2 = attributeNames.get(key)) !== null && _b2 !== undefined ? _b2 : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode3(value)}"`;
  }).join(" ");
}
var singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0;i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment$1:
      return renderComment(node);
    case CDATA$1:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text$1:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a3;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a3 = elementNames.get(elem.name)) !== null && _a3 !== undefined ? _a3 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a3;
  let data = elem.data || "";
  if (((_a3 = opts.encodeEntities) !== null && _a3 !== undefined ? _a3 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0;i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!isTag(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne(test, node.children, true);
    }
  }
  return elem;
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (;; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function parseDocument$1(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser$1(handler, options).end(data);
  return handler.root;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target, symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;
var merge = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
function limitedDepthRecursive(n2, f, g = () => {
  return;
}) {
  if (n2 === undefined) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g), ...args);
    };
  }
  return g;
}
function trimCharacter(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = new Map;
  for (let i = items.length;i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(key, map2.has(key) ? merge(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map2.values()].reverse();
}
var overwriteMerge$1 = (acc, src, options) => [...src];
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
var I = ["I", "X", "C", "M"];
var V = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
}

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join(`
`);
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}

class BlockStackItem extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = undefined,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = undefined,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor(options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor(next = null, transform) {
    super(next);
    this.transform = transform;
  }
}
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === `
`) {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === `
`) {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    }
  }
  addLiteral(text, inlineTextBuilder, noWrap = true) {
    if (!text) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === `
`) {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === `
`) {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text) {
    return this.leadingWhitespaceRe.test(text);
  }
  testTrailingWhitespace(text) {
    return this.trailingWhitespaceRe.test(text);
  }
  testContainsWords(text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }
  countNewlinesNoWords(text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === `
`) {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt2 = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce = this.options.encodeCharacters;
    return wt2 ? ce ? (str) => ce(wt2(str)) : wt2 : ce;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += `
`;
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = `
` + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText(cell), `
`);
    cell.next.cells.push({ colspan, rowspan, text });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + `
`.repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s2) => [s2.selector, s2])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s2, i) => [s2, i + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html, metadata = undefined) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument$1(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"), "g");
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k2, v]) => v === "" ? k2 : `${k2}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j) {
  if (!matrix[j]) {
    matrix[j] = [];
  }
  return matrix[j];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0;i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0;j < i; j++) {
      const rowJ = getRow(matrix, j);
      if (rowI[j] || rowJ[i]) {
        const temp = rowI[j];
        rowI[j] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r3 = 0;r3 < cell.rowspan; r3++) {
    const layoutRow = getRow(layout, baseRow + r3);
    for (let c2 = 0;c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index) {
  if (offsets[index] === undefined) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j = 0;j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0;i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split(`
`);
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0;x < colNumber; x++) {
    let y = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y < rowsInThisColumn) {
      cell = layout[x][y];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j = 0;j < cell.lines.length; j++) {
            const line = cell.lines[j];
            const lineOffset = rowOffsets[y] + j;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y++;
      }
    }
  }
  return outputLines.join(`
`);
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, `
`) : str).split(`
`).map((line) => "> " + line).join(`
`)
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(!text ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: 1 << 24
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  whitespaceCharacters: ` 	\r
\f\u200B`,
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options = {}) {
  options = merge(DEFAULT_OPTIONS, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert2(html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}
function htmlToText(html) {
  if (!html || typeof html !== "string")
    return html;
  return convert2(html, {
    selectors: [
      { selector: "img", format: "skip" },
      { selector: "#__vue-email-preview", format: "skip" }
    ]
  });
}
var emptyStyle = {};
var baseHeaderStyles = {
  fontWeight: "500",
  paddingTop: 20
};
var h1 = {
  ...baseHeaderStyles,
  fontSize: "2.5rem"
};
var h2 = {
  ...baseHeaderStyles,
  fontSize: "2rem"
};
var h3 = {
  ...baseHeaderStyles,
  fontSize: "1.75rem"
};
var h4 = {
  ...baseHeaderStyles,
  fontSize: "1.5rem"
};
var h5 = {
  ...baseHeaderStyles,
  fontSize: "1.25rem"
};
var h6 = {
  ...baseHeaderStyles,
  fontSize: "1rem"
};
var bold = {
  fontWeight: "bold"
};
var italic = {
  fontStyle: "italic"
};
var blockQuote = {
  background: "#f9f9f9",
  borderLeft: "10px solid #ccc",
  margin: "1.5em 10px",
  padding: "1em 10px"
};
var codeInline = {
  color: "#212529",
  fontSize: "87.5%",
  display: "inline",
  background: " #f8f8f8",
  fontFamily: "SFMono-Regular,Menlo,Monaco,Consolas,monospace"
};
var codeBlock = {
  ...codeInline,
  paddingTop: 10,
  paddingRight: 10,
  paddingLeft: 10,
  paddingBottom: 1,
  marginBottom: 20,
  background: " #f8f8f8"
};
var link = {
  color: "#007bff",
  textDecoration: "underline",
  backgroundColor: "transparent"
};
var styles = {
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  blockQuote,
  bold,
  italic,
  link,
  codeBlock: { ...codeBlock, wordWrap: "break-word" },
  codeInline: { ...codeInline, wordWrap: "break-word" },
  p: emptyStyle,
  li: emptyStyle,
  ul: emptyStyle,
  ol: emptyStyle,
  image: emptyStyle,
  br: emptyStyle,
  hr: emptyStyle,
  table: emptyStyle,
  thead: emptyStyle,
  tbody: emptyStyle,
  th: emptyStyle,
  td: emptyStyle,
  tr: emptyStyle,
  strikethrough: emptyStyle
};
var patterns = {
  h1: /^#\s+(.+)$/gm,
  h2: /^##\s+(.+)$/gm,
  h3: /^###\s+(.+)$/gm,
  h4: /^####\s+(.+)$/gm,
  h5: /^#####\s+(.+)$/gm,
  h6: /^######\s+(.+)$/gm,
  p: /^(?!#{1,6}\s)((?!<(pre|blockquote|Text)\b[^>]*>)(?!.*<\/(pre|blockquote|Text)>$)((?!(?:[-*+\s]+|\d+\.\s+|#\s+|.*?\|.*?\||!\[.*?\]\(.*?\)|```\s*\n(?:.|\n)+?```| {4}(?:.|\n)+?))(?:.|\n)+?))(?=\n{2,}|$)/gm,
  bold: /\*\*(.+?)\*\*/g,
  italic: /([*_])(.*?)\1/g,
  li: /^\s*[-|\\*]\s+(.*)$/gm,
  ul: /(<li.*<\/li>)(?![\s\S]*<\/ul>)/gs,
  ol: /^(?:\d+\.\s+.+$(?:\n(?!$).+)*(?:\n|$))+/gm,
  image: /!\[(.*?)\]\((.*?)\)/g,
  link: /\[(.+?)\]\((.*?)\)/g,
  blockQuote: /^>(?: .+?(?:\n|$))+/gm,
  nestedBlockQuote: /^>( .+?(?:\n|$))+/gm,
  codeBlocks: /```(?:[\s\S]*?\n)?([\s\S]*?)\n```/g,
  codeInline: /(?<!`)(`{1,2})(?!`)(.*?)(?<!`)\1(?!`)/g,
  br: / {2}\n/g,
  hr: /^-{3,}$/gm,
  table: /((?:^|\n)(?:\|[^\n]*?)+\|\n)((?:^|\n)(?:\|(?:[\s\S]*?[^\\])?\|[^\n]*)+\|\n)+/gm,
  strikethrough: /~~(.+?)~~/g
};
function camelToKebabCase(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function parseCssInJsToInlineCss(cssProperties) {
  if (!cssProperties)
    return "";
  return Object.entries(cssProperties).map(([property, value]) => `${camelToKebabCase(property)}:${value}`).join(";");
}
async function parseMarkdownToVueEmailJSX(markdown, customStyles = {}, withDataAttr = true) {
  if (markdown === undefined || markdown === null || markdown === "" || typeof markdown !== "string")
    return "";
  const { addHook, sanitize } = (await import("./chunk-ez07sb8k.js")).default;
  addHook("afterSanitizeAttributes", (node) => {
    if ("target" in node)
      node.setAttribute("target", "_blank");
  });
  const finalStyles = { ...styles, ...customStyles };
  let vueMailTemplate = "";
  vueMailTemplate = markdown.replace(patterns.codeInline, `<code${parseCssInJsToInlineCss(finalStyles.codeInline) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.codeInline)}"` : ""}>$2</code>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.codeBlocks, (_, codeContent) => {
    const indentedCodeContent = codeContent.split(`
`).map((line) => `  ${line}`).join(`
`);
    return `<pre${parseCssInJsToInlineCss(finalStyles.codeBlock) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.codeBlock)}"` : ""}>
${indentedCodeContent}
</pre>`;
  });
  function parseMarkdownWithBlockQuotes(markdown2) {
    const blockquoteRegex = /^(>\s*((?:.+\n?)+))(?!\n(?=>\s))/gm;
    function parseBlockQuote(match) {
      const nestedContent = match.replace(/^>\s*/gm, "");
      const nestedHTML = parseMarkdownWithBlockQuotes(nestedContent);
      return `<blockquote${parseCssInJsToInlineCss(finalStyles.blockQuote) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.blockQuote)}"` : ""}>
${nestedHTML}
</blockquote>`;
    }
    return markdown2.replace(blockquoteRegex, parseBlockQuote);
  }
  vueMailTemplate = parseMarkdownWithBlockQuotes(vueMailTemplate);
  vueMailTemplate = vueMailTemplate.replace(patterns.p, `<p${parseCssInJsToInlineCss(finalStyles.p) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.p)}"` : ""}${withDataAttr ? ' data-id="vue-email-text"' : ""}>$1</p>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h1, `<h1${parseCssInJsToInlineCss(finalStyles.h1) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h1)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h1>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h2, `<h2${parseCssInJsToInlineCss(finalStyles.h2) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h2)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h2>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h3, `<h3${parseCssInJsToInlineCss(finalStyles.h3) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h3)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h3>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h4, `<h4${parseCssInJsToInlineCss(finalStyles.h4) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h4)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h4>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h5, `<h5${parseCssInJsToInlineCss(finalStyles.h5) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h5)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h5>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.h6, `<h6${parseCssInJsToInlineCss(finalStyles.h6) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.h6)}"` : ""}${withDataAttr ? ' data-id="vue-email-heading"' : ""}>$1</h6>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.table, (match) => {
    const rows = match.trim().split(`
`);
    const headers = rows[0].split("|").slice(1, -1).map((cell) => cell.trim());
    const alignments = rows[1].split("|").slice(1, -1).map((cell) => {
      const align = cell.trim().toLowerCase();
      return align === ":--" ? "left" : align === "--:" ? "right" : "center";
    });
    const body = rows.slice(2).map((row) => {
      const cells = row.split("|").slice(1, -1).map((cell) => cell.trim());
      return `<tr${parseCssInJsToInlineCss(finalStyles.tr) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.tr)}"` : ""}>${cells.map((cell, index) => `<td  align="${alignments[index]}"${parseCssInJsToInlineCss(finalStyles.td) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.td)}"` : ""}>${cell}</td>`).join("")}</tr>`;
    }).join("");
    const table = `<table${parseCssInJsToInlineCss(finalStyles.table) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.table)}"` : ""}><thead${parseCssInJsToInlineCss(finalStyles.thead) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.thead)}"` : ""}><tr${parseCssInJsToInlineCss(finalStyles.tr) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.tr)}"` : ""}>${headers.map((header, index) => `<th align="${alignments[index]}"${parseCssInJsToInlineCss(finalStyles.th) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.th)}"` : ""}>${header}</th>`).join("")}</tr></thead><tbody${parseCssInJsToInlineCss(finalStyles.tbody) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.tbody)}"` : ""}>${body}</tbody></table>`;
    return table;
  });
  vueMailTemplate = vueMailTemplate.replace(patterns.strikethrough, `<del${parseCssInJsToInlineCss(finalStyles.strikethrough) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.strikethrough)}"` : ""}>$1</del>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.bold, `<strong${parseCssInJsToInlineCss(finalStyles.bold) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.bold)}"` : ""}${withDataAttr ? ' data-id="vue-email-text"' : ""}>$1</strong>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.italic, `<em${parseCssInJsToInlineCss(finalStyles.italic) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.italic)}"` : ""}${withDataAttr ? ' data-id="vue-email-text"' : ""}>$2</em>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.li, `<li${parseCssInJsToInlineCss(finalStyles.li) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.li)}"` : ""}>$1</li>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.ul, `<ul${parseCssInJsToInlineCss(finalStyles.ul) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.ul)}"` : ""}>$&</ul>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.ol, (match) => {
    const listItems = match.split(`
`).map((line) => {
      const listItemContent = line.replace(/^\d+\.\s+/, "");
      return listItemContent ? `<li${parseCssInJsToInlineCss(finalStyles.li) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.li)}"` : ""}>${listItemContent}</li>` : "";
    }).join(`
`);
    return `<ol${parseCssInJsToInlineCss(finalStyles.ol) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.ol)}"` : ""}>${listItems}</ol>`;
  });
  vueMailTemplate = vueMailTemplate.replace(patterns.image, `<img src="$2" alt="$1"${parseCssInJsToInlineCss(finalStyles.image) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.image)}"` : ""}>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.link, `<a${withDataAttr ? ' data-id="vue-email-link"' : ""}${parseCssInJsToInlineCss(finalStyles.link) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.link)}"` : ""} href="$2" target="_blank" >$1</a>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.br, `<br${parseCssInJsToInlineCss(finalStyles.br) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.br)}"` : ""}/>`);
  vueMailTemplate = vueMailTemplate.replace(patterns.hr, `<hr${withDataAttr ? ' data-id="vue-email-hr"' : ""}${parseCssInJsToInlineCss(finalStyles.hr) !== "" ? ` style="${parseCssInJsToInlineCss(finalStyles.hr)}"` : ""}/>`);
  return sanitize(vueMailTemplate, {
    USE_PROFILES: { html: true }
  });
}
function pxToPt(px) {
  return Number.isNaN(Number(px)) ? null : Number.parseInt(`${px}`, 10) * 3 / 4;
}
function withMargin(props) {
  return [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ].filter((s2) => Object.keys(s2).length)[0];
}
function withSpace(value, properties) {
  return properties.reduce((styles2, property) => {
    if (value)
      return { ...styles2, [property]: `${value}px` };
    return styles2;
  }, {});
}
function convertStyleStringToObj(styleString) {
  const styleObj = {};
  const styleDeclarations = styleString.split(";");
  styleDeclarations.forEach((declaration) => {
    const [property, value] = declaration.split(":");
    const propName = property.trim();
    const propValue = value.trim();
    styleObj[propName] = propValue;
  });
  return styleObj;
}
var EBody = exports_vue.defineComponent({
  name: "EBody",
  setup(_, { slots }) {
    return () => {
      const bodyNode = exports_vue.h("body", { "data-id": "__vue-email-body" }, slots.default?.());
      return bodyNode;
    };
  }
});
var EButton = exports_vue.defineComponent({
  name: "EButton",
  props: {
    px: {
      type: [String, Number]
    },
    py: {
      type: [String, Number],
      default: 0
    },
    target: {
      type: String,
      default: "_blank"
    },
    href: String,
    style: Object
  },
  setup(props, { slots }) {
    const px = props.px || 0;
    const py = props.py || 0;
    const textRaise = pxToPt(Number.parseInt(py.toString()) * 2);
    const styles2 = typeof props.style === "string" ? convertStyleStringToObj(props.style) : props.style;
    const buttonStyle = {
      lineHeight: "100%",
      textDecoration: "none",
      display: "inline-block",
      maxWidth: "100%",
      ...styles2
    };
    if ((py || px) && buttonStyle)
      buttonStyle.padding = `${py}px ${px}px`;
    const buttonTextStyle = exports_vue.computed(() => ({
      maxWidth: "100%",
      display: "inline-block",
      lineHeight: "120%",
      textDecoration: "none",
      textTransform: "none",
      msoPaddingAlt: "0px",
      msoTextRaise: pxToPt(py.toString())
    }));
    const firstSpan = `<!--[if mso]><i style="letter-spacing: ${px}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`;
    const secondSpan = `<!--[if mso]><i style="letter-spacing: ${px}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`;
    return () => {
      return exports_vue.h("a", {
        "data-id": "__vue-email-button",
        style: buttonStyle,
        href: props.href,
        target: props.target
      }, [
        exports_vue.h("span", { innerHTML: firstSpan }),
        exports_vue.h("span", {
          style: buttonTextStyle.value
        }, slots.default?.()),
        exports_vue.h("span", { innerHTML: secondSpan })
      ]);
    };
  }
});
var EColumn = exports_vue.defineComponent({
  name: "EColumn",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("td", {
        "data-id": "__vue-email-column",
        role: "presentation"
      }, slots.default?.());
    };
  }
});
var EContainer = exports_vue.defineComponent({
  name: "EmailContainer",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("table", {
        align: "center",
        width: "100%",
        "data-id": "__vue-email-container",
        role: "presentation",
        cellspacing: "0",
        cellpadding: "0",
        border: "0",
        style: "max-width: 37.5em"
      }, [exports_vue.h("tbody", [exports_vue.h("tr", { style: "width: 100%" }, [exports_vue.h("td", {}, slots.default?.())])])]);
    };
  }
});
var EFont = exports_vue.defineComponent({
  name: "EFont",
  props: {
    fontFamily: {
      type: String,
      required: true
    },
    fallbackFontFamily: {
      type: [String, Array],
      default: "Arial"
    },
    webFont: {
      type: Object,
      default: undefined
    },
    fontStyle: {
      type: String,
      default: "normal"
    },
    fontWeight: {
      type: [String, Number],
      default: 400
    }
  },
  setup({ fontFamily, fallbackFontFamily, webFont, fontStyle, fontWeight }) {
    const src = webFont ? `src: url(${webFont.url}) format('${webFont.format}');` : "";
    const style = `
      @font-face {
        font-family: '${fontFamily}';
        font-style: ${fontStyle};
        font-weight: ${fontWeight};
        mso-font-alt: '${Array.isArray(fallbackFontFamily) ? fallbackFontFamily[0] : fallbackFontFamily}';
        ${src}
      }
  
      * {
        font-family: '${fontFamily}', ${Array.isArray(fallbackFontFamily) ? fallbackFontFamily.join(", ") : fallbackFontFamily};
      }
    `;
    return () => {
      return exports_vue.h("style", {
        innerHTML: style
      });
    };
  }
});
var EHead = exports_vue.defineComponent({
  name: "EHead",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("head", [exports_vue.h("meta", { httpEquiv: "Content-Type", content: "text/html; charset=UTF-8" }), slots.default?.()]);
    };
  }
});
var EHeading = exports_vue.defineComponent({
  name: "EHeading",
  props: {
    as: {
      type: String,
      default: "h1"
    },
    m: {
      type: [String, Number],
      default: undefined
    },
    mx: {
      type: [String, Number],
      default: undefined
    },
    my: {
      type: [String, Number],
      default: undefined
    },
    mt: {
      type: [String, Number],
      default: undefined
    },
    mr: {
      type: [String, Number],
      default: undefined
    },
    mb: {
      type: [String, Number],
      default: undefined
    },
    ml: {
      type: [String, Number],
      default: undefined
    },
    style: {
      type: [Object, String],
      default: undefined
    }
  },
  setup(props, { slots }) {
    const styles2 = typeof props.style === "string" ? convertStyleStringToObj(props.style) : props.style;
    return () => {
      return exports_vue.h(props.as, {
        "data-id": "__vue-email-heading",
        style: {
          ...withMargin({
            m: props.m,
            mx: props.mx,
            my: props.my,
            mt: props.mt,
            mr: props.mr,
            mb: props.mb,
            ml: props.ml
          }),
          ...styles2
        }
      }, slots.default?.());
    };
  }
});
var EHr = exports_vue.defineComponent({
  name: "EHr",
  setup() {
    return () => {
      return exports_vue.h("hr", {
        "data-id": "__vue-email-hr",
        style: "width: 100%; border: none; border-top: 1px solid #eaeaea;"
      });
    };
  }
});
var EHtml = exports_vue.defineComponent({
  name: "EHtml",
  props: {
    lang: {
      type: String,
      default: "en"
    },
    dir: {
      type: String,
      default: "ltr"
    }
  },
  setup(props, { slots }) {
    return () => {
      return exports_vue.h("html", {
        id: "__vue-email",
        lang: props.lang,
        dir: props.dir
      }, slots.default?.());
    };
  }
});
var config2 = {};
var EImg = exports_vue.defineComponent({
  name: "EImg",
  props: {
    src: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const baseUrl = config2 && config2.baseUrl ? config2.baseUrl : null;
    const src = exports_vue.ref(props.src);
    if (baseUrl) {
      src.value = resolveURL(baseUrl, src.value);
      src.value = cleanDoubleSlashes(src.value);
    }
    return () => {
      return exports_vue.h("img", {
        "data-id": "__vue-email-img",
        style: "display: block; outline: none; border: none; text-decoration: none",
        src: src.value
      });
    };
  }
});
var ELink = exports_vue.defineComponent({
  name: "ELink",
  props: {
    href: {
      type: String,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => {
      return exports_vue.h("a", {
        "data-id": "__vue-email-link",
        style: "color: #067df7; text-decoration: none",
        href: props.href,
        target: "_blank"
      }, slots.default?.());
    };
  }
});
var PREVIEW_MAX_LENGTH = 150;
var EPreview = exports_vue.defineComponent({
  name: "EPreview",
  setup(_, { slots }) {
    const text = exports_vue.computed(() => {
      if (slots.default !== undefined) {
        const children = slots.default()[0].children;
        const newText = Array.isArray(children) ? children.join("") : children;
        return newText?.substring(0, PREVIEW_MAX_LENGTH);
      }
      return "";
    });
    function renderWhiteSpace(text2) {
      if (text2.length >= PREVIEW_MAX_LENGTH)
        return null;
      const whiteSpaceCodes = "\xA0\u200C\u200B\u200D\u200E\u200F\uFEFF";
      return whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text2.length);
    }
    return () => {
      return exports_vue.h("div", {
        id: "__vue-email-preview",
        style: "display: none; overflow: hidden; line-height: 1px; opacity: 0; max-height: 0; max-width: 0"
      }, [text.value, exports_vue.h("div", [renderWhiteSpace(text.value)])]);
    };
  }
});
var ERow = exports_vue.defineComponent({
  name: "ERow",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("table", {
        align: "center",
        width: "100%",
        "data-id": "__vue-email-row",
        role: "presentation",
        cellSpacing: "0",
        cellPadding: "0",
        border: "0"
      }, [exports_vue.h("tbody", { style: "width: 100%" }, [exports_vue.h("tr", { style: "width: 100%" }, slots.default?.())])]);
    };
  }
});
var ESection = exports_vue.defineComponent({
  name: "ESection",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("table", {
        align: "center",
        width: "100%",
        "data-id": "__vue-email-section",
        border: "0",
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, [exports_vue.h("tbody", [exports_vue.h("tr", [exports_vue.h("td", slots.default?.())])])]);
    };
  }
});
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes2[CharCodes2["Number"] = 35] = "Number";
  CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
  CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
  CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
  CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
  CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
  CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
  CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
  CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
  CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
  CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
  CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
  CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
  CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
  CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
  CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
  State2[State2["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace$2(c2) {
  return c2 === CharCodes.Space || c2 === CharCodes.NewLine || c2 === CharCodes.Tab || c2 === CharCodes.FormFeed || c2 === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes.Slash || c2 === CharCodes.Gt || isWhitespace$2(c2);
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerZ || c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperZ;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
};

class Tokenizer2 {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp2, consumed) => this.emitCodePoint(cp2, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c2) {
    if (c2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes.Gt || isWhitespace$2(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower === Sequences.TitleEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c2 === CharCodes.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace$2(c2))
      ;
    else if (c2 === CharCodes.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes.Gt || isWhitespace$2(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace$2(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace$2(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes.Slash || c2 === CharCodes.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace$2(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace$2(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace$2(c2) || c2 === CharCodes.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeSpecialT(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (lower === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.BeforeSpecialT: {
          this.stateBeforeSpecialT(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName)
      ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp2, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp2);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp2, this.sectionStart);
    }
  }
}
var formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;

class Parser2 {
  constructor(cbs, options = {}) {
    var _a3, _b2, _c, _d, _e, _f2;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== undefined ? _a3 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b2 = options.lowerCaseAttributeNames) !== null && _b2 !== undefined ? _b2 : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== undefined ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== undefined ? _d : Tokenizer2)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f2 = (_e = this.cbs).onparserinit) === null || _f2 === undefined || _f2.call(_e, this);
  }
  ontext(start, endIndex) {
    var _a3, _b2;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b2 = (_a3 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a3, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp2, endIndex) {
    var _a3, _b2;
    this.endIndex = endIndex - 1;
    (_b2 = (_a3 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a3, fromCodePoint(cp2));
    this.startIndex = endIndex;
  }
  isVoidElement(name3) {
    return this.htmlMode && voidElements.has(name3);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name3 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    this.emitOpenTag(name3);
  }
  emitOpenTag(name3) {
    var _a3, _b2, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name3;
    const impliesClose = this.htmlMode && openImpliesClose.get(name3);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b2 = (_a3 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name3)) {
      this.stack.unshift(name3);
      if (this.htmlMode) {
        if (foreignContextElements.has(name3)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name3)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name3);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b2;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b2 = (_a3 = this.cbs).onopentag) === null || _b2 === undefined || _b2.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a3, _b2, _c, _d, _e, _f2, _g, _h;
    this.endIndex = endIndex;
    let name3 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name3) || htmlIntegrationElements.has(name3))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name3)) {
      const pos = this.stack.indexOf(name3);
      if (pos !== -1) {
        for (let index = 0;index <= pos; index++) {
          const element = this.stack.shift();
          (_b2 = (_a3 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a3, element, index !== pos);
        }
      } else if (this.htmlMode && name3 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name3 === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, "br");
      (_f2 = (_e = this.cbs).onopentag) === null || _f2 === undefined || _f2.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === undefined || _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b2;
    const name3 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name3) {
      (_b2 = (_a3 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a3, name3, !isOpenImplied);
      this.stack.shift();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name3 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name3.toLowerCase() : name3;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp2) {
    this.attribvalue += fromCodePoint(cp2);
  }
  onattribend(quote, endIndex) {
    var _a3, _b2;
    this.endIndex = endIndex;
    (_b2 = (_a3 = this.cbs).onattribute) === null || _b2 === undefined || _b2.call(_a3, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name3 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name3 = name3.toLowerCase();
    }
    return name3;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name3 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name3}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name3 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name3}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a3, _b2, _c, _d;
    this.endIndex = endIndex;
    (_b2 = (_a3 = this.cbs).oncomment) === null || _b2 === undefined || _b2.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a3, _b2, _c, _d, _e, _f2, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b2 = (_a3 = this.cbs).oncdatastart) === null || _b2 === undefined || _b2.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f2 = (_e = this.cbs).oncdataend) === null || _f2 === undefined || _f2.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a3, _b2;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = 0;index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b2 = (_a3 = this.cbs).onend) === null || _b2 === undefined || _b2.call(_a3);
  }
  reset() {
    var _a3, _b2, _c, _d;
    (_b2 = (_a3 = this.cbs).onreset) === null || _b2 === undefined || _b2.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a3, _b2;
    if (this.ended) {
      (_b2 = (_a3 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a3, _b2;
    if (this.ended) {
      (_b2 = (_a3 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser2(handler, options).end(data);
  return handler.root;
}
var ETailwind = exports_vue.defineComponent({
  name: "ETailwind",
  props: {
    config: {
      type: Object,
      required: false
    }
  },
  async setup(props, { slots }) {
    if (!slots.default || !slots.default())
      throw new Error("ETailwind component must have a default slot");
    const $default = slots.default();
    let headStyles = [];
    const markupWithTailwindClasses = await exports_server_renderer.renderToString(exports_vue.h("div", $default)).then((html2) => html2.replace(/^<div[^>]*>|<\/div>$/g, ""));
    const tailwindConfig = props.config || config2.tailwind;
    const markupCSS = FE(await CE(markupWithTailwindClasses, tailwindConfig));
    const nonMediaQueryCSS = markupCSS.replaceAll(/@media\s*\(.*\)\s*{\s*\.(.*)\s*{[\s\S]*}\s*}/gm, (mediaQuery, _className) => {
      headStyles.push(mediaQuery.replace(/[\r\n|\r|\n]+/g, "").replace(/\s+/g, " ").replaceAll(/\s*\.[\S]+\s*{([^}]*)}/gm, (match, content) => {
        return match.replace(content, content.split(";").map((propertyDeclaration) => propertyDeclaration.endsWith("!important") ? propertyDeclaration.trim() : `${propertyDeclaration.trim()}!important`).join(";"));
      }));
      return "";
    });
    const nonMediaQueryTailwindStylesPerClass = IE(nonMediaQueryCSS);
    headStyles = headStyles.filter((style) => style.trim().length > 0);
    const hasHTML = /<html[^>]*>/gm.test(markupWithTailwindClasses);
    const hasHead = /<head[^>]*>/gm.test(markupWithTailwindClasses);
    if (headStyles.length > 0 && (!hasHTML || !hasHead))
      throw new Error("Tailwind: To use responsive styles you must have a <EHtml> and <EHead> element in your template.");
    const dom = parseDocument(markupWithTailwindClasses, {
      decodeEntities: false,
      xmlMode: true
    });
    const head = findOne((elem) => elem.name === "head", dom.children);
    if (headStyles.length > 0 && hasHead && head) {
      appendChild(head, {
        type: "tag",
        name: "style",
        children: [
          {
            type: "text",
            data: LE(headStyles.join(""))
          }
        ]
      });
    }
    const hasAttrs = (elem) => elem.attribs && elem.attribs.class;
    findAll((elem) => hasAttrs(elem), dom.children).forEach((elem) => {
      const currentStyles = elem.attribs.style || "";
      if (elem.attribs.class) {
        const fullClassName = elem.attribs.class;
        const classNames = fullClassName.split(" ");
        const classNamesToKeep = [];
        const styles2 = [];
        classNames.forEach((className) => {
          const escapedClassName = TE(className);
          if (typeof nonMediaQueryTailwindStylesPerClass[escapedClassName] === "undefined") {
            classNamesToKeep.push(className);
          } else {
            styles2.push(`${nonMediaQueryTailwindStylesPerClass[escapedClassName]};`);
          }
        });
        if (classNamesToKeep.length > 0)
          elem.attribs.class = classNamesToKeep.join(" ").trim();
        if (styles2.length > 0)
          elem.attribs.style = `${currentStyles} ${styles2.join(" ")}`.trim();
        if (elem.attribs.style === "")
          delete elem.attribs.style;
      }
    });
    const html = render(dom, {
      decodeEntities: false,
      xmlMode: true
    });
    return () => {
      return exports_vue.h("clean-component", { innerHTML: html });
    };
  }
});
var EText = exports_vue.defineComponent({
  name: "EText",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("p", {
        "data-id": "__vue-email-text",
        style: "font-size: 14px; line-height: 24px; margin: 16px 0;"
      }, slots.default?.());
    };
  }
});
var EMarkdown = exports_vue.defineComponent({
  name: "EMarkdown",
  props: {
    source: {
      type: String,
      required: true
    },
    customStyles: {
      type: Object,
      default: undefined
    },
    containerStyles: {
      type: Object,
      default: undefined
    }
  },
  async setup(props) {
    const parsedMarkdown = await parseMarkdownToVueEmailJSX(props.source, props.customStyles);
    return () => {
      return exports_vue.h("div", {
        "data-id": "__vue-email-markdown",
        style: props.containerStyles,
        innerHTML: parsedMarkdown
      });
    };
  }
});
var EStyle = exports_vue.defineComponent({
  name: "EStyle",
  setup(_, { slots }) {
    return () => {
      return exports_vue.h("style", {
        "data-id": "__vue-email-style"
      }, slots.default?.());
    };
  }
});
var ECodeBlock = exports_vue.defineComponent({
  name: "ECodeBlock",
  props: {
    code: {
      type: String,
      required: true
    },
    lang: {
      type: String,
      required: true
    },
    theme: {
      type: String,
      required: true
    },
    class: {
      type: String,
      default: ""
    },
    showLineNumbers: {
      type: Boolean,
      default: false
    },
    lineNumberColor: {
      type: String,
      default: "#636E7B"
    },
    lineHighlightingColor: {
      type: String,
      default: "rgba(101, 117, 133, .16)"
    },
    highlightedLines: {
      type: Array,
      default: () => []
    }
  },
  async setup({ code, lang, theme, showLineNumbers, lineNumberColor, highlightedLines, lineHighlightingColor }) {
    const { getHighlighter } = await import("./chunk-2nds97qa.js");
    const shiki = await getHighlighter({
      langs: [lang],
      themes: [theme]
    });
    const themeColorBg = shiki.getTheme(theme).bg;
    const html = shiki.codeToHtml(code, {
      lang,
      theme,
      transformers: [
        {
          code(node) {
            node.properties.style = "display: table; width: 100%;";
          }
        },
        {
          line(node, line) {
            node.properties.style = "display: table-row; line-height: 1.5; height: 1.5em;";
            if (showLineNumbers) {
              node.children.unshift({
                type: "element",
                tagName: "span",
                properties: {
                  className: ["line-number"],
                  style: `padding-left: 5px; padding-right: 15px; color: ${lineNumberColor}; user-select: none;`
                },
                children: [
                  {
                    type: "text",
                    value: `${line}`
                  }
                ]
              });
            }
            if (highlightedLines.includes(line))
              node.properties.style += `background-color: ${lineHighlightingColor};`;
          }
        }
      ]
    });
    return () => exports_vue.h("pre", {
      class: ["shiki", theme],
      style: {
        backgroundColor: themeColorBg,
        display: "block",
        whiteSpace: "pre",
        fontFamily: "monospace"
      },
      tabindex: 0
    }, [
      exports_vue.h("span", {
        innerHTML: html
      })
    ]);
  }
});
var ECodeInline = exports_vue.defineComponent({
  name: "ECodeInline",
  props: {
    class: {
      type: String,
      default: ""
    },
    style: {
      type: Object
    }
  },
  setup(props, { slots }) {
    return () => [exports_vue.h("style", null, `
      meta ~ .cino {
        display: none !important;
        opacity: 0 !important;
      }

      meta ~ .cio {
        display: block !important;
      }
    `), exports_vue.h("code", {
      ...props,
      class: [
        props.class,
        "cino"
      ],
      style: props.style
    }, slots.default?.()), exports_vue.h("span", {
      ...props,
      class: [
        props.class,
        "cio"
      ],
      style: { ...props.style, display: "none" }
    }, slots.default?.())];
  }
});
var components = {
  __proto__: null,
  EBody,
  EButton,
  ECodeBlock,
  ECodeInline,
  EColumn,
  EContainer,
  EFont,
  EHead,
  EHeading,
  EHr,
  EHtml,
  EImg,
  ELink,
  EMarkdown,
  EPreview,
  ERow,
  ESection,
  EStyle,
  ETailwind,
  EText
};
var VueEmailPlugin = {
  install(app, options = {}) {
    if (options) {
      deepmerge$1(config2, options);
      app.config.globalProperties.$vueEmail = options;
    }
    Object.entries(components).forEach(([name3, component]) => {
      app.component(name3, component);
    });
  }
};
var js2 = { exports: {} };
var src = {};
var javascript = { exports: {} };
var beautifier$2 = {};
var output = {};
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput)
    return output;
  hasRequiredOutput = 1;
  function OutputLine(parent) {
    this.__parent = parent;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  }
  OutputLine.prototype.clone_empty = function() {
    var line = new OutputLine(this.__parent);
    line.set_indent(this.__indent_count, this.__alignment_count);
    return line;
  };
  OutputLine.prototype.item = function(index) {
    if (index < 0) {
      return this.__items[this.__items.length + index];
    } else {
      return this.__items[index];
    }
  };
  OutputLine.prototype.has_match = function(pattern) {
    for (var lastCheckedOutput = this.__items.length - 1;lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next = this.__parent.current_line;
      next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next.__items[0] === " ") {
        next.__items.splice(0, 1);
        next.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf(`
`);
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result += this.__items.join("");
    }
    return result;
  };
  function IndentStringCache(options, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options.indent_size;
    this.__indent_string = options.indent_char;
    if (!options.indent_with_tabs) {
      this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options.indent_level > 0) {
      baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  }
  IndentStringCache.prototype.get_indent_size = function(indent, column) {
    var result = this.__base_string_length;
    column = column || 0;
    if (indent < 0) {
      result = 0;
    }
    result += indent * this.__indent_size;
    result += column;
    return result;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
    var result = this.__base_string;
    column = column || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result = "";
    }
    column += indent_level * this.__indent_size;
    this.__ensure_cache(column);
    result += this.__cache[column];
    return result;
  };
  IndentStringCache.prototype.__ensure_cache = function(column) {
    while (column >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column = this.__cache.length;
    var indent = 0;
    var result = "";
    if (this.__indent_size && column >= this.__indent_size) {
      indent = Math.floor(column / this.__indent_size);
      column -= indent * this.__indent_size;
      result = new Array(indent + 1).join(this.__indent_string);
    }
    if (column) {
      result += new Array(column + 1).join(" ");
    }
    this.__cache.push(result);
  };
  function Output(options, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options, baseIndentString);
    this.raw = false;
    this._end_with_newline = options.end_with_newline;
    this.indent_size = options.indent_size;
    this.wrap_line_length = options.wrap_line_length;
    this.indent_empty_lines = options.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  }
  Output.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output.prototype.get_indent_string = function(indent, column) {
    return this.__indent_cache.get_indent_string(indent, column);
  };
  Output.prototype.get_indent_size = function(indent, column) {
    return this.__indent_cache.get_indent_size(indent, column);
  };
  Output.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === `
`) {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join(`
`);
    if (eol !== `
`) {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output.prototype.add_raw_token = function(token) {
    for (var x = 0;x < token.newlines; x++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token.whitespace_before);
    this.current_line.push(token.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output.prototype.remove_indent = function(index) {
    var output_length = this.__lines.length;
    while (index < output_length) {
      this.__lines[index]._remove_indent();
      index++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index = this.__lines.length - 2;
    while (index >= 0) {
      var potentialEmptyLine = this.__lines[index];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index--;
    }
  };
  output.Output = Output;
  return output;
}
var token = {};
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken)
    return token;
  hasRequiredToken = 1;
  function Token(type, text, newlines, whitespace_before) {
    this.type = type;
    this.text = text;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  }
  token.Token = Token;
  return token;
}
var acorn = {};
var hasRequiredAcorn;
function requireAcorn() {
  if (hasRequiredAcorn)
    return acorn;
  hasRequiredAcorn = 1;
  (function(exports) {
    var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
    var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
    var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
    var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
    var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
    var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
    var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
    exports.identifier = new RegExp(identifierStart + identifierChars, "g");
    exports.identifierStart = new RegExp(identifierStart);
    exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
    exports.newline = /[\n\r\u2028\u2029]/;
    exports.lineBreak = new RegExp(`\r
|` + exports.newline.source);
    exports.allLineBreaks = new RegExp(exports.lineBreak.source, "g");
  })(acorn);
  return acorn;
}
var options$3 = {};
var options$2 = {};
var hasRequiredOptions$3;
function requireOptions$3() {
  if (hasRequiredOptions$3)
    return options$2;
  hasRequiredOptions$3 = 1;
  function Options(options, merge_child_field) {
    this.raw_options = _mergeOpts(options, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "\t");
    if (this.indent_with_tabs) {
      this.indent_char = "\t";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  }
  Options.prototype._get_array = function(name3, default_value) {
    var option_value = this.raw_options[name3];
    var result = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result;
  };
  Options.prototype._get_boolean = function(name3, default_value) {
    var option_value = this.raw_options[name3];
    var result = option_value === undefined ? !!default_value : !!option_value;
    return result;
  };
  Options.prototype._get_characters = function(name3, default_value) {
    var option_value = this.raw_options[name3];
    var result = default_value || "";
    if (typeof option_value === "string") {
      result = option_value.replace(/\\r/, "\r").replace(/\\n/, `
`).replace(/\\t/, "\t");
    }
    return result;
  };
  Options.prototype._get_number = function(name3, default_value) {
    var option_value = this.raw_options[name3];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result = parseInt(option_value, 10);
    if (isNaN(result)) {
      result = default_value;
    }
    return result;
  };
  Options.prototype._get_selection = function(name3, selection_list, default_value) {
    var result = this._get_selection_list(name3, selection_list, default_value);
    if (result.length !== 1) {
      throw new Error("Invalid Option Value: The option '" + name3 + `' can only be one of the following values:
` + selection_list + `
You passed in: '` + this.raw_options[name3] + "'");
    }
    return result[0];
  };
  Options.prototype._get_selection_list = function(name3, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result = this._get_array(name3, default_value);
    if (!this._is_valid_selection(result, selection_list)) {
      throw new Error("Invalid Option Value: The option '" + name3 + `' can contain only the following values:
` + selection_list + `
You passed in: '` + this.raw_options[name3] + "'");
    }
    return result;
  };
  Options.prototype._is_valid_selection = function(result, selection_list) {
    return result.length && selection_list.length && !result.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  function _mergeOpts(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name3;
    for (name3 in allOptions) {
      if (name3 !== childFieldName) {
        finalOpts[name3] = allOptions[name3];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name3 in allOptions[childFieldName]) {
        finalOpts[name3] = allOptions[childFieldName][name3];
      }
    }
    return finalOpts;
  }
  function _normalizeOpts(options) {
    var convertedOpts = {};
    var key;
    for (key in options) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options[key];
    }
    return convertedOpts;
  }
  options$2.Options = Options;
  options$2.normalizeOpts = _normalizeOpts;
  options$2.mergeOpts = _mergeOpts;
  return options$2;
}
var hasRequiredOptions$2;
function requireOptions$2() {
  if (hasRequiredOptions$2)
    return options$3;
  hasRequiredOptions$2 = 1;
  var BaseOptions = requireOptions$3().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  function Options(options) {
    BaseOptions.call(this, options, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== undefined) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs2 = 0;bs2 < brace_style_split.length; bs2++) {
      if (brace_style_split[bs2] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs2];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  }
  Options.prototype = new BaseOptions;
  options$3.Options = Options;
  return options$3;
}
var tokenizer$2 = {};
var inputscanner = {};
var hasRequiredInputscanner;
function requireInputscanner() {
  if (hasRequiredInputscanner)
    return inputscanner;
  hasRequiredInputscanner = 1;
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  function InputScanner(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  }
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val;
  };
  InputScanner.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      val = this.__input.charAt(index);
    }
    return val;
  };
  InputScanner.prototype.__match = function(pattern, index) {
    pattern.lastIndex = index;
    var pattern_match = pattern.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
      if (pattern_match.index !== index) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern, index) {
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      return !!this.__match(pattern, index);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern, index) {
    var val = this.peek(index);
    pattern.lastIndex = 0;
    return val !== null && pattern.test(val);
  };
  InputScanner.prototype.match = function(pattern) {
    var pattern_match = this.__match(pattern, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val += this.readUntil(until_pattern, until_after);
    }
    return val;
  };
  InputScanner.prototype.readUntil = function(pattern, until_after) {
    var val = "";
    var match_index = this.__position;
    pattern.lastIndex = this.__position;
    var pattern_match = pattern.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val;
  };
  InputScanner.prototype.readUntilAfter = function(pattern) {
    return this.readUntil(pattern, true);
  };
  InputScanner.prototype.get_regexp = function(pattern, match_from) {
    var result = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern === "string" && pattern !== "") {
      result = new RegExp(pattern, flags);
    } else if (pattern) {
      result = new RegExp(pattern.source, flags);
    }
    return result;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern) {
    var start = this.__position;
    var val = this.readUntilAfter(pattern);
    this.__position = start;
    return val;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  inputscanner.InputScanner = InputScanner;
  return inputscanner;
}
var tokenizer$1 = {};
var tokenstream = {};
var hasRequiredTokenstream;
function requireTokenstream() {
  if (hasRequiredTokenstream)
    return tokenstream;
  hasRequiredTokenstream = 1;
  function TokenStream(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  }
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val;
  };
  TokenStream.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__tokens_length) {
      val = this.__tokens[index];
    }
    return val;
  };
  TokenStream.prototype.add = function(token2) {
    if (this.__parent_token) {
      token2.parent = this.__parent_token;
    }
    this.__tokens.push(token2);
    this.__tokens_length += 1;
  };
  tokenstream.TokenStream = TokenStream;
  return tokenstream;
}
var whitespacepattern = {};
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern)
    return pattern;
  hasRequiredPattern = 1;
  function Pattern(input_scanner, parent) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent) {
      this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent._until_pattern);
      this._until_after = parent._until_after;
    }
  }
  Pattern.prototype.read = function() {
    var result = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result) {
      result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern2) {
    var result = this._create();
    result._until_after = true;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.until = function(pattern2) {
    var result = this._create();
    result._until_after = false;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.starting_with = function(pattern2) {
    var result = this._create();
    result._starting_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype.matching = function(pattern2) {
    var result = this._create();
    result._match_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {};
  pattern.Pattern = Pattern;
  return pattern;
}
var hasRequiredWhitespacepattern;
function requireWhitespacepattern() {
  if (hasRequiredWhitespacepattern)
    return whitespacepattern;
  hasRequiredWhitespacepattern = 1;
  var Pattern = requirePattern().Pattern;
  function WhitespacePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    if (parent) {
      this._line_regexp = this._input.get_regexp(parent._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  }
  WhitespacePattern.prototype = new Pattern;
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result = this._create();
    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result._update();
    return result;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp, input_string) {
    regexp.lastIndex = 0;
    var start_index = 0;
    var result = [];
    var next_match = regexp.exec(input_string);
    while (next_match) {
      result.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp.exec(input_string);
    }
    if (start_index < input_string.length) {
      result.push(input_string.substring(start_index, input_string.length));
    } else {
      result.push("");
    }
    return result;
  };
  whitespacepattern.WhitespacePattern = WhitespacePattern;
  return whitespacepattern;
}
var hasRequiredTokenizer$2;
function requireTokenizer$2() {
  if (hasRequiredTokenizer$2)
    return tokenizer$1;
  hasRequiredTokenizer$2 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var Token = requireToken().Token;
  var TokenStream = requireTokenstream().TokenStream;
  var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer3 = function(input_string, options) {
    this._input = new InputScanner(input_string);
    this._options = options || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer3.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream;
    this._reset();
    var current;
    var previous = new Token(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream;
    while (previous.type !== TOKEN.EOF) {
      current = this._get_next_token(previous, open_token);
      while (this._is_comment(current)) {
        comments.add(current);
        current = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current.comments_before = comments;
        comments = new TokenStream;
      }
      current.parent = open_token;
      if (this._is_opening(current)) {
        open_stack.push(open_token);
        open_token = current;
      } else if (open_token && this._is_closing(current, open_token)) {
        current.opened = open_token;
        open_token.closed = current;
        open_token = open_stack.pop();
        current.parent = open_token;
      }
      current.previous = previous;
      previous.next = current;
      this.__tokens.add(current);
      previous = current;
    }
    return this.__tokens;
  };
  Tokenizer3.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer3.prototype._reset = function() {};
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer3.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer3.prototype._create_token = function(type, text) {
    var token2 = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
    return token2;
  };
  Tokenizer3.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  tokenizer$1.Tokenizer = Tokenizer3;
  tokenizer$1.TOKEN = TOKEN;
  return tokenizer$1;
}
var directives = {};
var hasRequiredDirectives;
function requireDirectives() {
  if (hasRequiredDirectives)
    return directives;
  hasRequiredDirectives = 1;
  function Directives(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  }
  Directives.prototype.get_directives = function(text) {
    if (!text.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives2 = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text);
    while (directive_match) {
      directives2[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text);
    }
    return directives2;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  directives.Directives = Directives;
  return directives;
}
var templatablepattern = {};
var hasRequiredTemplatablepattern;
function requireTemplatablepattern() {
  if (hasRequiredTemplatablepattern)
    return templatablepattern;
  hasRequiredTemplatablepattern = 1;
  var Pattern = requirePattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false
  };
  function TemplatablePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent) {
      this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent._excluded);
      this._disabled = Object.assign(this._disabled, parent._disabled);
    }
    var pattern2 = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern2.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern2.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern2.starting_with(/{{/).until_after(/}}/),
      php: pattern2.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern2.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      django: pattern2.starting_with(/{%/).until_after(/%}/),
      django_value: pattern2.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern2.starting_with(/{#/).until_after(/#}/),
      smarty: pattern2.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern2.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern2.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  }
  TemplatablePattern.prototype = new Pattern;
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result = this._create();
    result._disabled[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read_options = function(options) {
    var result = this._create();
    for (var language in template_names) {
      result._disabled[language] = options.templating.indexOf(language) === -1;
    }
    result._update();
    return result;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result = this._create();
    result._excluded[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read = function() {
    var result = "";
    if (this._match_pattern) {
      result = this._input.read(this._starting_pattern);
    } else {
      result = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next = this._read_template();
    while (next) {
      if (this._match_pattern) {
        next += this._input.read(this._match_pattern);
      } else {
        next += this._input.readUntil(this.__template_pattern);
      }
      result += next;
      next = this._read_template();
    }
    if (this._until_after) {
      result += this._input.readUntilAfter(this._until_pattern);
    }
    return result;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c2 = this._input.peek();
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c2 === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  templatablepattern.TemplatablePattern = TemplatablePattern;
  return templatablepattern;
}
var hasRequiredTokenizer$1;
function requireTokenizer$1() {
  if (hasRequiredTokenizer$1)
    return tokenizer$2;
  hasRequiredTokenizer$1 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var acorn2 = requireAcorn();
  var Pattern = requirePattern().Pattern;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
  var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer3 = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn2.identifier).matching(acorn2.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn2.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn2.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer3.prototype = new BaseTokenizer;
  Tokenizer3.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer3.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c2 = this._input.peek();
    if (c2 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_non_javascript(c2);
    token2 = token2 || this._read_string(c2);
    token2 = token2 || this._read_pair(c2, this._input.peek(1));
    token2 = token2 || this._read_word(previous_token);
    token2 = token2 || this._read_singles(c2);
    token2 = token2 || this._read_comment(c2);
    token2 = token2 || this._read_regexp(c2, previous_token);
    token2 = token2 || this._read_xml(c2, previous_token);
    token2 = token2 || this._read_punctuation();
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer3.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, `
`);
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer3.prototype._read_singles = function(c2) {
    var token2 = null;
    if (c2 === "(" || c2 === "[") {
      token2 = this._create_token(TOKEN.START_EXPR, c2);
    } else if (c2 === ")" || c2 === "]") {
      token2 = this._create_token(TOKEN.END_EXPR, c2);
    } else if (c2 === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c2);
    } else if (c2 === "}") {
      token2 = this._create_token(TOKEN.END_BLOCK, c2);
    } else if (c2 === ";") {
      token2 = this._create_token(TOKEN.SEMICOLON, c2);
    } else if (c2 === "." && dot_pattern.test(this._input.peek(1))) {
      token2 = this._create_token(TOKEN.DOT, c2);
    } else if (c2 === ",") {
      token2 = this._create_token(TOKEN.COMMA, c2);
    }
    if (token2) {
      this._input.next();
    }
    return token2;
  };
  Tokenizer3.prototype._read_pair = function(c2, d) {
    var token2 = null;
    if (c2 === "#" && d === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c2 + d);
    }
    if (token2) {
      this._input.next();
      this._input.next();
    }
    return token2;
  };
  Tokenizer3.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer3.prototype._read_non_javascript = function(c2) {
    var resulting_string = "";
    if (c2 === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + `
`);
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + `
`);
      }
      c2 = this._input.next();
      var sharp = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c2 = this._input.next();
          sharp += c2;
        } while (this._input.hasNext() && c2 !== "#" && c2 !== "=");
        if (c2 === "#")
          ;
        else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp);
      }
      this._input.back();
    } else if (c2 === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn2.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c2 === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer3.prototype._read_comment = function(c2) {
    var token2 = null;
    if (c2 === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn2.allLineBreaks, `
`);
        token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token2.directives = directives2;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token2 = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_string = function(c2) {
    if (c2 === "`" || c2 === "'" || c2 === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c2 === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c2);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c2) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, `
`);
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer3.prototype._read_regexp = function(c2, previous_token) {
    if (c2 === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c2) && !this._input.testChar(acorn2.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c2) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn2.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._read_xml = function(c2, previous_token) {
    if (this._options.e4x && c2 === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn2.allLineBreaks, `
`);
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  function unescape_string(s2) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s2);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          if (!matched) {
            matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
          }
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s2;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s2;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
        } else if (escaped > 1114111) {
          out += "\\" + matched[0];
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  }
  Tokenizer3.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern2;
    if (delimiter === "'") {
      pattern2 = this.__patterns.single_quote;
    } else if (delimiter === '"') {
      pattern2 = this.__patterns.double_quote;
    } else if (delimiter === "`") {
      pattern2 = this.__patterns.template_text;
    } else if (delimiter === "}") {
      pattern2 = this.__patterns.template_expression;
    }
    var resulting_string = pattern2.read();
    var next = "";
    while (this._input.hasNext()) {
      next = this._input.next();
      if (next === delimiter || !allow_unescaped_newlines && acorn2.newline.test(next)) {
        this._input.back();
        break;
      } else if (next === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === `
`) {
          this._input.next();
        }
        next += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
          next += this._input.next();
        }
        if (start_sub === next) {
          if (delimiter === "`") {
            next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next += this._input.next();
          }
        }
      }
      next += pattern2.read();
      resulting_string += next;
    }
    return resulting_string;
  };
  tokenizer$2.Tokenizer = Tokenizer3;
  tokenizer$2.TOKEN = TOKEN;
  tokenizer$2.positionable_operators = positionable_operators.slice();
  tokenizer$2.line_starters = line_starters.slice();
  return tokenizer$2;
}
var hasRequiredBeautifier$2;
function requireBeautifier$2() {
  if (hasRequiredBeautifier$2)
    return beautifier$2;
  hasRequiredBeautifier$2 = 1;
  var Output = requireOutput().Output;
  var Token = requireToken().Token;
  var acorn2 = requireAcorn();
  var Options = requireOptions$2().Options;
  var Tokenizer3 = requireTokenizer$1().Tokenizer;
  var line_starters = requireTokenizer$1().line_starters;
  var positionable_operators = requireTokenizer$1().positionable_operators;
  var TOKEN = requireTokenizer$1().TOKEN;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function ltrim(s2) {
    return s2.replace(/^\s+/g, "");
  }
  function generateMapFromStrings(list) {
    var result = {};
    for (var x = 0;x < list.length; x++) {
      result[list[x].replace(/-/g, "_")] = list[x];
    }
    return result;
  }
  function reserved_word(token2, word) {
    return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
  }
  function reserved_array(token2, words) {
    return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
  }
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    Statement: "Statement",
    ObjectLiteral: "ObjectLiteral",
    ArrayLiteral: "ArrayLiteral",
    ForInitializer: "ForInitializer",
    Conditional: "Conditional",
    Expression: "Expression"
  };
  function remove_redundant_indentation(output2, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output2.remove_indent(frame.start_line_index);
  }
  function split_linebreaks(s2) {
    s2 = s2.replace(acorn2.allLineBreaks, `
`);
    var out = [], idx = s2.indexOf(`
`);
    while (idx !== -1) {
      out.push(s2.substring(0, idx));
      s2 = s2.substring(idx + 1);
      idx = s2.indexOf(`
`);
    }
    if (s2.length) {
      out.push(s2);
    }
    return out;
  }
  function is_array(mode) {
    return mode === MODE.ArrayLiteral;
  }
  function is_expression(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  }
  function all_lines_start_with(lines, c2) {
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.charAt(0) !== c2) {
        return false;
      }
    }
    return true;
  }
  function each_line_matches_indent(lines, indent) {
    var i = 0, len = lines.length, line;
    for (;i < len; i++) {
      line = lines[i];
      if (line && line.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  }
  function Beautifier(source_text, options) {
    options = options || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options);
  }
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
      last_word: flags_base ? flags_base.last_word : "",
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      in_case: false,
      case_body: false,
      case_block: false,
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer = new Tokenizer3(source_text, this._options);
    this._tokens = tokenizer.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = `
`;
      if (source_text && acorn2.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn2.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i = 0;i < newlines; i += 1) {
        this.print_newline(i > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j = 1;j < newlines; j += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === undefined ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index += 1;
        check_token = this._tokens.peek(index - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property() && !(in_array(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode)))
        ;
      else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix = "NEWLINE";
        } else {
          prefix = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line = this._output.current_line;
        if (line.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD))
      ;
    else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token))
      ;
    else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token))
      ;
    else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (in_array(current_token.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn2.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j = 0;j < lines.length; j++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j]));
        } else if (starless && lines[j]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token))
      ;
    else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === `
`) {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  beautifier$2.Beautifier = Beautifier;
  return beautifier$2;
}
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript)
    return javascript.exports;
  hasRequiredJavascript = 1;
  var Beautifier = requireBeautifier$2().Beautifier, Options = requireOptions$2().Options;
  function js_beautify(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
  }
  javascript.exports = js_beautify;
  javascript.exports.defaultOptions = function() {
    return new Options;
  };
  return javascript.exports;
}
var css = { exports: {} };
var beautifier$1 = {};
var options$1 = {};
var hasRequiredOptions$1;
function requireOptions$1() {
  if (hasRequiredOptions$1)
    return options$1;
  hasRequiredOptions$1 = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options) {
    BaseOptions.call(this, options, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs2 = 0;bs2 < brace_style_split.length; bs2++) {
      if (brace_style_split[bs2] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs2];
      }
    }
  }
  Options.prototype = new BaseOptions;
  options$1.Options = Options;
  return options$1;
}
var hasRequiredBeautifier$1;
function requireBeautifier$1() {
  if (hasRequiredBeautifier$1)
    return beautifier$1;
  hasRequiredBeautifier$1 = 1;
  var Options = requireOptions$1().Options;
  var Output = requireOutput().Output;
  var InputScanner = requireInputscanner().InputScanner;
  var Directives = requireDirectives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  function Beautifier(source_text, options) {
    this._source_text = source_text || "";
    this._options = new Options(options);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      page: true,
      "font-face": true,
      keyframes: true,
      media: true,
      supports: true,
      document: true
    };
    this.CONDITIONAL_GROUP_RULE = {
      media: true,
      supports: true,
      document: true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  }
  Beautifier.prototype.eatString = function(endChars) {
    var result = "";
    this._ch = this._input.next();
    while (this._ch) {
      result += this._ch;
      if (this._ch === "\\") {
        result += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === `
`) {
        break;
      }
      this._ch = this._input.next();
    }
    return result;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === `
`) {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i = 1;
    var ch = this._input.peek(i);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i++;
      ch = this._input.peek(i);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = `
`;
      if (source_text && lineBreak.test(source_text || "")) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, `
`);
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideNonNestedAtRule = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        if (variable.match(/[ :]$/)) {
          variable = this.eatString(": ").replace(/\s+$/, "");
          this.print_string(variable);
          this._output.space_before_token = true;
        }
        if (parenLevel === 0 && variable.indexOf(":") !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      } else if (this._ch === "@") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s+$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          } else if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (parenLevel === 0 && !insidePropertyValue) {
            insideNonNestedAtRule = true;
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        insideNonNestedAtRule = false;
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i = 0;i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideNonNestedAtRule = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === `
` && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  beautifier$1.Beautifier = Beautifier;
  return beautifier$1;
}
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss)
    return css.exports;
  hasRequiredCss = 1;
  var Beautifier = requireBeautifier$1().Beautifier, Options = requireOptions$1().Options;
  function css_beautify(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
  }
  css.exports = css_beautify;
  css.exports.defaultOptions = function() {
    return new Options;
  };
  return css.exports;
}
var html = { exports: {} };
var beautifier = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions)
    return options;
  hasRequiredOptions = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options2) {
    BaseOptions.call(this, options2, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
    this.void_elements = this._get_array("void_elements", [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      "!doctype",
      "?xml",
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  }
  Options.prototype = new BaseOptions;
  options.Options = Options;
  return options;
}
var tokenizer = {};
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer)
    return tokenizer;
  hasRequiredTokenizer = 1;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  var Pattern = requirePattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer3 = function(input_string, options2) {
    BaseTokenizer.call(this, input_string, options2);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer3.prototype = new BaseTokenizer;
  Tokenizer3.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
  };
  Tokenizer3.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c2 = this._input.peek();
    if (c2 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_open_handlebars(c2, open_token);
    token2 = token2 || this._read_attribute(c2, previous_token, open_token);
    token2 = token2 || this._read_close(c2, open_token);
    token2 = token2 || this._read_raw_content(c2, previous_token, open_token);
    token2 = token2 || this._read_content_word(c2);
    token2 = token2 || this._read_comment_or_cdata(c2);
    token2 = token2 || this._read_processing(c2);
    token2 = token2 || this._read_open(c2, open_token);
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer3.prototype._read_comment_or_cdata = function(c2) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives2 = directives_core.get_directives(resulting_string);
          if (directives2 && directives2.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_processing = function(c2) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_open = function(c2, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (c2 === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_open_handlebars = function(c2, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (this._options.indent_handlebars && c2 === "{" && this._input.peek(1) === "{") {
        if (this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_close = function(c2, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (open_token) {
      if (open_token.text[0] === "<" && (c2 === ">" || c2 === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c2 === "/") {
          resulting_string += this._input.next();
        }
        token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c2 === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_attribute = function(c2, previous_token, open_token) {
    var token2 = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c2 === "=") {
        token2 = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c2 === '"' || c2 === "'") {
        var content = this._input.next();
        if (c2 === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token2 = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token2 = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token2;
  };
  Tokenizer3.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer3.prototype._read_raw_content = function(c2, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token2 = this._read_comment_or_cdata(c2);
        if (token2) {
          token2.type = TOKEN.TEXT;
          return token2;
        }
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      } else if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._read_content_word = function(c2) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c2 === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
  };
  tokenizer.Tokenizer = Tokenizer3;
  tokenizer.TOKEN = TOKEN;
  return tokenizer;
}
var hasRequiredBeautifier;
function requireBeautifier() {
  if (hasRequiredBeautifier)
    return beautifier;
  hasRequiredBeautifier = 1;
  var Options = requireOptions().Options;
  var Output = requireOutput().Output;
  var Tokenizer3 = requireTokenizer().Tokenizer;
  var TOKEN = requireTokenizer().TOKEN;
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options2, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options2.max_preserve_newlines;
    this.preserve_newlines = options2.preserve_newlines;
    this._output = new Output(options2, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern2) {
    return this._output.current_line.has_match(pattern2);
  };
  Printer.prototype.set_space_before_token = function(value, non_breaking) {
    this._output.space_before_token = value;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token2) {
    this._output.add_raw_token(token2);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n2 = 0;n2 < newlines; n2++) {
      this.print_newline(n2 > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token2) {
    if (token2.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token2.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result = "null";
    }
    return result;
  };
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function TagFrame(parent, parser_token, indent_level) {
    this.parent = parent || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  }
  function TagStack(printer) {
    this._printer = printer;
    this._current_frame = null;
  }
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  function Beautifier(source_text, options2, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options2 = options2 || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options2, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  }
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = `
`;
      if (source_text && lineBreak.test(source_text)) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, `
`);
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken;
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer3(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline)) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options2) {
          var beautifier2 = new Beautifier(html_source, options2, local._js_beautify, local._css_beautify);
          return beautifier2.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text = text.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre = indentation + matched[1] + `
`;
        text = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text = text.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf(`
`) !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = `
`;
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options;
          text = _beautifier(indentation + text, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text = text.replace(new RegExp(`
(` + white + ")?", "g"), `
`);
          }
          text = indentation + text.replace(/\n/g, `
` + indentation);
        }
      }
      if (pre) {
        if (!text) {
          text = pre + post;
        } else {
          text = pre + text + `
` + post;
        }
      }
      printer.print_newline(false);
      if (text) {
        raw_token.text = text;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
      var peek_index = 0;
      var peek_token;
      do {
        peek_token = tokens.peek(peek_index);
        if (peek_token.type === TOKEN.ATTRIBUTE) {
          parser_token.attr_count += 1;
        }
        peek_index += 1;
      } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(parent, raw_token) {
    this.parent = parent || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf(`
`) === -1)
        ;
      else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result = result || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result = result || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result = result || this._tag_stack.try_pop("dt", ["dl"]);
      result = result || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result = result || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result = result || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("thead", ["table"]);
      result = result || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result;
  };
  beautifier.Beautifier = Beautifier;
  return beautifier;
}
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml)
    return html.exports;
  hasRequiredHtml = 1;
  var Beautifier = requireBeautifier().Beautifier, Options = requireOptions().Options;
  function style_html(html_source, options2, js_beautify, css_beautify) {
    var beautifier2 = new Beautifier(html_source, options2, js_beautify, css_beautify);
    return beautifier2.beautify();
  }
  html.exports = style_html;
  html.exports.defaultOptions = function() {
    return new Options;
  };
  return html.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var js_beautify = requireJavascript();
  var css_beautify = requireCss();
  var html_beautify = requireHtml();
  function style_html(html_source, options2, js3, css2) {
    js3 = js3 || js_beautify;
    css2 = css2 || css_beautify;
    return html_beautify(html_source, options2, js3, css2);
  }
  style_html.defaultOptions = html_beautify.defaultOptions;
  src.js = js_beautify;
  src.css = css_beautify;
  src.html = style_html;
  return src;
}
(function(module) {
  function get_beautify(js_beautify, css_beautify, html_beautify) {
    var beautify = function(src2, config3) {
      return js_beautify.js_beautify(src2, config3);
    };
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
  }
  {
    (function(mod) {
      var beautifier2 = requireSrc();
      beautifier2.js_beautify = beautifier2.js;
      beautifier2.css_beautify = beautifier2.css;
      beautifier2.html_beautify = beautifier2.html;
      mod.exports = get_beautify(beautifier2, beautifier2, beautifier2);
    })(module);
  }
})(js2);
var jsExports = js2.exports;
/*!
 * is-whitespace <https://github.com/jonschlinkert/is-whitespace>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * condense-newlines <https://github.com/jonschlinkert/condense-newlines>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
/*!
 * pretty <https://github.com/jonschlinkert/pretty>
 *
 * Copyright (c) 2013-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

// ../../../../node_modules/kolorist/dist/esm/index.mjs
var enabled = true;
var globalVar = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var supportLevel = 0;
if (globalVar.process && globalVar.process.env && globalVar.process.stdout) {
  const { FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, COLORTERM } = globalVar.process.env;
  if (NODE_DISABLE_COLORS || NO_COLOR || FORCE_COLOR === "0") {
    enabled = false;
  } else if (FORCE_COLOR === "1" || FORCE_COLOR === "2" || FORCE_COLOR === "3") {
    enabled = true;
  } else if (TERM === "dumb") {
    enabled = false;
  } else if ("CI" in globalVar.process.env && [
    "TRAVIS",
    "CIRCLECI",
    "APPVEYOR",
    "GITLAB_CI",
    "GITHUB_ACTIONS",
    "BUILDKITE",
    "DRONE"
  ].some((vendor) => (vendor in globalVar.process.env))) {
    enabled = true;
  } else {
    enabled = process.stdout.isTTY;
  }
  if (enabled) {
    if (process.platform === "win32") {
      supportLevel = 3;
    } else {
      if (COLORTERM && (COLORTERM === "truecolor" || COLORTERM === "24bit")) {
        supportLevel = 3;
      } else if (TERM && (TERM.endsWith("-256color") || TERM.endsWith("256"))) {
        supportLevel = 2;
      } else {
        supportLevel = 1;
      }
    }
  }
}
var options2 = {
  enabled,
  supportLevel
};
function kolorist(start, end, level = 1) {
  const open = `\x1B[${start}m`;
  const close = `\x1B[${end}m`;
  const regex = new RegExp(`\\x1b\\[${end}m`, "g");
  return (str) => {
    return options2.enabled && options2.supportLevel >= level ? open + ("" + str).replace(regex, open) + close : "" + str;
  };
}
var reset = kolorist(0, 0);
var bold2 = kolorist(1, 22);
var dim = kolorist(2, 22);
var italic2 = kolorist(3, 23);
var underline = kolorist(4, 24);
var inverse = kolorist(7, 27);
var hidden = kolorist(8, 28);
var strikethrough = kolorist(9, 29);
var black = kolorist(30, 39);
var red = kolorist(31, 39);
var green = kolorist(32, 39);
var yellow = kolorist(33, 39);
var blue = kolorist(34, 39);
var magenta = kolorist(35, 39);
var cyan = kolorist(36, 39);
var white = kolorist(97, 39);
var gray = kolorist(90, 39);
var lightGray = kolorist(37, 39);
var lightRed = kolorist(91, 39);
var lightGreen = kolorist(92, 39);
var lightYellow = kolorist(93, 39);
var lightBlue = kolorist(94, 39);
var lightMagenta = kolorist(95, 39);
var lightCyan = kolorist(96, 39);
var bgBlack = kolorist(40, 49);
var bgRed = kolorist(41, 49);
var bgGreen = kolorist(42, 49);
var bgYellow = kolorist(43, 49);
var bgBlue = kolorist(44, 49);
var bgMagenta = kolorist(45, 49);
var bgCyan = kolorist(46, 49);
var bgWhite = kolorist(107, 49);
var bgGray = kolorist(100, 49);
var bgLightRed = kolorist(101, 49);
var bgLightGreen = kolorist(102, 49);
var bgLightYellow = kolorist(103, 49);
var bgLightBlue = kolorist(104, 49);
var bgLightMagenta = kolorist(105, 49);
var bgLightCyan = kolorist(106, 49);
var bgLightGray = kolorist(47, 49);

// ../../../../node_modules/scule/dist/index.mjs
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return;
  }
  return char !== char.toLowerCase();
}
function splitByCase(str, separators) {
  const splitters = separators ?? STR_SPLITTERS;
  const parts = [];
  if (!str || typeof str !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = undefined;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function pascalCase2(str, opts) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => upperFirst(opts?.normalize ? p.toLowerCase() : p)).join("") : "";
}

// ../../../../node_modules/module-from-string/dist/index.mjs
import { Module, createRequire } from "module";
import vm, { runInNewContext, createContext } from "vm";

// ../../../../node_modules/nanoid/index.js
import crypto from "crypto";

// ../../../../node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../../../node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = (bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
};
var nanoid = (size = 21) => {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size;i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
};

// ../../../../node_modules/module-from-string/dist/index.mjs
var import_esbuild = __toESM(require_main(), 1);
import { dirname, resolve, isAbsolute, sep } from "path";
import { pathToFileURL, fileURLToPath, URL as URL2 } from "url";
var isInESModuleScope = () => {
  try {
    return module_dist === undefined;
  } catch {
    return true;
  }
};
var FILE_URL_PROTOCOL = "file:";
var isFileURL = (value) => value.startsWith(FILE_URL_PROTOCOL);
var ensureFileURL = (value) => isFileURL(value) ? value : pathToFileURL(value).toString();
var ensurePath = (value) => isFileURL(value) ? fileURLToPath(value) : value;
var internalFunctionNames = [
  "getCallerDirname",
  "requireFromString",
  "importFromStringSync",
  "importFromString",
  "processTicksAndRejections"
];
var getCallerDirname = () => {
  var _a3;
  const __prepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = (_err, stackTraces) => stackTraces;
  const callSites = new Error().stack.filter((callSite) => {
    const functionName = callSite.getFunctionName();
    return functionName === null || !internalFunctionNames.includes(functionName);
  });
  Error.prepareStackTrace = __prepareStackTrace;
  const caller = callSites[0];
  const callerFilename = (_a3 = caller.getFileName()) != null ? _a3 : process.argv[1];
  return dirname(ensurePath(callerFilename));
};
var ensureTrailingSeparator = (dirname2) => {
  const separator = isFileURL(dirname2) ? "/" : sep;
  return dirname2.endsWith(separator) ? dirname2 : `${dirname2}${separator}`;
};
var getModuleFilename = (dirname2, filename) => {
  if (isInESModuleScope()) {
    if (isFileURL(filename)) {
      return filename;
    } else {
      const validatedDirname = ensureTrailingSeparator(dirname2);
      return new URL2(filename, ensureFileURL(validatedDirname)).toString();
    }
  } else {
    return resolve(ensurePath(dirname2), ensurePath(filename));
  }
};
var forEachPropertyKey = (context, callbackfn) => {
  Object.getOwnPropertyNames(context).forEach(callbackfn);
  Object.getOwnPropertySymbols(context).forEach(callbackfn);
};
var shallowMergeContext = (target, source) => {
  forEachPropertyKey(source, (propertyKey) => {
    Object.defineProperty(target, propertyKey, {
      ...Object.getOwnPropertyDescriptor(source, propertyKey)
    });
  });
  return target;
};
var __GLOBAL__ = global;
var getCurrentGlobal = () => {
  const currentGlobal = shallowMergeContext({}, __GLOBAL__);
  delete currentGlobal.global;
  delete currentGlobal.globalThis;
  return currentGlobal;
};
var createGlobalObject = (globals, useCurrentGlobal) => {
  const globalObject = useCurrentGlobal ? getCurrentGlobal() : Object.defineProperty({}, Symbol.toStringTag, {
    ...Object.getOwnPropertyDescriptor(__GLOBAL__, Symbol.toStringTag)
  });
  forEachPropertyKey(globals, (propertyKey) => {
    if (propertyKey in __GLOBAL__) {
      Object.defineProperty(globalObject, propertyKey, {
        ...Object.getOwnPropertyDescriptor(__GLOBAL__, propertyKey),
        value: globals[propertyKey]
      });
    } else {
      Object.defineProperty(globalObject, propertyKey, {
        ...Object.getOwnPropertyDescriptor(globals, propertyKey)
      });
    }
  });
  return globalObject;
};
var createContextObject = (moduleContext, globalObject) => {
  const contextObject = shallowMergeContext(moduleContext, globalObject);
  if (!("global" in contextObject)) {
    contextObject.global = contextObject;
  }
  return contextObject;
};
var resolveModuleSpecifier = (specifier, dirname2) => {
  if (isFileURL(specifier)) {
    return specifier;
  }
  return specifier.startsWith(".") || isAbsolute(specifier) ? resolve(ensurePath(dirname2), specifier) : specifier;
};
var requireFromString = (code, {
  filename = `${nanoid()}.js`,
  dirname: dirname2 = getCallerDirname(),
  globals = {},
  useCurrentGlobal = false
} = {}) => {
  var _a3;
  const moduleFilename = ensurePath(getModuleFilename(dirname2, filename));
  const mainModule = isInESModuleScope() ? undefined : __require.main;
  const contextModule = new Module(moduleFilename, mainModule);
  contextModule.require = createRequire(moduleFilename);
  contextModule.filename = moduleFilename;
  contextModule.paths = (_a3 = mainModule == null ? undefined : mainModule.paths) != null ? _a3 : [];
  const globalObject = createGlobalObject(globals, useCurrentGlobal);
  const contextObject = createContextObject({
    exports: contextModule.exports,
    require: contextModule.require,
    module: contextModule,
    __filename: contextModule.filename,
    __dirname: contextModule.path
  }, globalObject);
  runInNewContext(code, contextObject, {
    filename: moduleFilename,
    async importModuleDynamically(specifier) {
      return await import(resolveModuleSpecifier(specifier, contextModule.path));
    }
  });
  contextModule.loaded = true;
  return contextModule.exports;
};
var USE_STRICT = '"use strict";';
var IMPORT_META_URL_SHIM = 'var import_meta_url = require("url").pathToFileURL(__filename).toString();';
var IMPORT_META_RESOLVE_SHIM = `function import_meta_resolve() {
  throw new Error(
    \`'import.meta.resolve' is not supported
Use asynchronous function 'importFromString' and enable '--experimental-vm-modules' CLI option.
Or use 'transformOptions' to include a polyfill. See https://github.com/evanw/esbuild/issues/1492#issuecomment-893144483 as an example.\`
  );
}`;
var getCommonJS = (transformOptions) => {
  var _a3;
  return {
    ...transformOptions,
    banner: `${USE_STRICT}
${IMPORT_META_URL_SHIM}
${IMPORT_META_RESOLVE_SHIM}
${(_a3 = transformOptions == null ? undefined : transformOptions.banner) != null ? _a3 : ""}`,
    define: {
      "import.meta.url": "import_meta_url",
      "import.meta.resolve": "import_meta_resolve",
      ...transformOptions == null ? undefined : transformOptions.define
    },
    format: "cjs"
  };
};
var ERR_REQUIRE_ESM = "ERR_REQUIRE_ESM";
var importFromStringSync = (code, { transformOptions, ...options3 } = {}) => {
  const { code: transformedCode } = import_esbuild.transformSync(code, getCommonJS(transformOptions));
  try {
    return requireFromString(transformedCode, options3);
  } catch (error) {
    if (error != null && error.code === ERR_REQUIRE_ESM) {
      throw new Error(`'import' statement of ES modules is not supported
Use asynchronous function 'importFromString' instead or replace it with dynamic 'import()' expression.`);
    }
    throw error;
  }
};

// ../../../../node_modules/@swc/wasm/wasm.js
var __dirname = "/Users/glennmichaeltorregosa/Documents/Projects/stacks/node_modules/@swc/wasm";
var imports = {};
imports["__wbindgen_placeholder__"] = exports_wasm;
var wasm;
var { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = __require("util");
var heap = new Array(128).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var cachedTextEncoder = new TextEncoder2("utf-8");
var encodeString2 = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
var cachedTextDecoder = new TextDecoder2("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((state) => {
  wasm.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
});
var $transformSync = function(s2, opts, experimental_plugin_bytes_resolver) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.transformSync(retptr, addHeapObject(s2), addHeapObject(opts), addHeapObject(experimental_plugin_bytes_resolver));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r22 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r22) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
};
var path = __require("path").join(__dirname, "wasm_bg.wasm");
var bytes = __require("fs").readFileSync(path);
var wasmModule = new WebAssembly.Module(bytes);
var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;

// ../../../../node_modules/import-string/dist/index.js
var c2 = (s2, n2, o2) => new Promise((e2, r3) => {
  var d = (t2) => {
    try {
      i(o2.next(t2));
    } catch (a) {
      r3(a);
    }
  }, l2 = (t2) => {
    try {
      i(o2.throw(t2));
    } catch (a) {
      r3(a);
    }
  }, i = (t2) => t2.done ? e2(t2.value) : Promise.resolve(t2.value).then(d, l2);
  i((o2 = o2.apply(s2, n2)).next());
});
var m = () => ("Bun" in globalThis);
var p = () => ("Deno" in globalThis);
var g = () => !m() && !p();
function x(s2) {
  return c2(this, null, function* () {
    if (p()) {
      let { code: n2 } = $transformSync(s2, { jsc: { target: "es2018", parser: { syntax: "typescript" } } });
      return yield import(((r3) => `data:text/javascript;base64,${btoa(r3)}`)(n2));
    }
    if (g() || m())
      return importFromStringSync(s2, { transformOptions: { loader: "ts", target: "es2018" } });
  });
}

// ../../../../node_modules/@vue-email/compiler/dist/index.mjs
function createInitConfig(options3) {
  const config3 = deepmerge$1({
    verbose: true,
    options: options3.options,
    vueCompilerOptions: options3.vueCompilerOptions
  }, options3);
  return config3;
}
function makeMap$1(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0;i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
var EMPTY_OBJ = Object.freeze({});
var NOOP$1 = () => {};
var NO = () => false;
var onRE$1 = /^on[^a-z]/;
var isOn$1 = (key) => onRE$1.test(key);
var extend = Object.assign;
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var hasOwn$1 = (val, key) => hasOwnProperty$3.call(val, key);
var isArray$3 = Array.isArray;
var isMap = (val) => toTypeString$1(val) === "[object Map]";
var isSet = (val) => toTypeString$1(val) === "[object Set]";
var isFunction$1$1 = (val) => typeof val === "function";
var isString$2 = (val) => typeof val === "string";
var isSymbol$1 = (val) => typeof val === "symbol";
var isObject$2 = (val) => val !== null && typeof val === "object";
var objectToString$1 = Object.prototype.toString;
var toTypeString$1 = (value) => objectToString$1.call(value);
var isPlainObject$1 = (val) => toTypeString$1(val) === "[object Object]";
var isReservedProp = /* @__PURE__ */ makeMap$1(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
var isBuiltInDirective = /* @__PURE__ */ makeMap$1("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
var cacheStringFunction$1 = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE, (_, c3) => c3 ? c3.toUpperCase() : "");
});
var hyphenateRE$1 = /\B([A-Z])/g;
var hyphenate$1 = cacheStringFunction$1((str) => str.replace(hyphenateRE$1, "-$1").toLowerCase());
var capitalize$1 = cacheStringFunction$1((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction$1((str) => {
  const s2 = str ? `on${capitalize$1(str)}` : ``;
  return s2;
});
var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name3) {
  return identRE.test(name3) ? `__props.${name3}` : `__props[${JSON.stringify(name3)}]`;
}
var PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
var slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
var isGloballyAllowed = /* @__PURE__ */ makeMap$1(GLOBALS_ALLOWED);
var range = 2;
function generateCodeFrame$1(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0;i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range;j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join(`
`);
}
function normalizeStyle$1(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i = 0;i < value.length; i++) {
      const item = value[i];
      const normalized = isString$2(item) ? parseStringStyle$1(item) : normalizeStyle$1(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value) || isObject$2(value)) {
    return value;
  }
}
var listDelimiterRE$1 = /;(?![^(]*\))/g;
var propertyDelimiterRE$1 = /:([^]+)/;
var styleCommentRE$1 = /\/\*[^]*?\*\//g;
function parseStringStyle$1(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE$1, "").split(listDelimiterRE$1).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE$1);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle$1(styles2) {
  let ret = "";
  if (!styles2 || isString$2(styles2)) {
    return ret;
  }
  for (const key in styles2) {
    const value = styles2[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate$1(key);
    if (isString$2(value) || typeof value === "number") {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass$1(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i = 0;i < value.length; i++) {
      const normalized = normalizeClass$1(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name3 in value) {
      if (value[name3]) {
        res += name3 + " ";
      }
    }
  }
  return res.trim();
}
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS$1 = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var VOID_TAGS$1 = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = /* @__PURE__ */ makeMap$1(HTML_TAGS);
var isSVGTag$1 = /* @__PURE__ */ makeMap$1(SVG_TAGS$1);
var isVoidTag$1 = /* @__PURE__ */ makeMap$1(VOID_TAGS$1);
var specialBooleanAttrs$1 = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isBooleanAttr$1 = /* @__PURE__ */ makeMap$1(specialBooleanAttrs$1 + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
var unsafeAttrCharRE$1 = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache$1 = {};
function isSSRSafeAttrName$1(name3) {
  if (attrValidationCache$1.hasOwnProperty(name3)) {
    return attrValidationCache$1[name3];
  }
  const isUnsafe = unsafeAttrCharRE$1.test(name3);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name3}`);
  }
  return attrValidationCache$1[name3] = !isUnsafe;
}
var propsToAttrMap$1 = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
var isKnownHtmlAttr = /* @__PURE__ */ makeMap$1(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
var isKnownSvgAttr = /* @__PURE__ */ makeMap$1(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
var escapeRE$1 = /["'&<>]/;
function escapeHtml$2(string) {
  const str = "" + string;
  const match = escapeRE$1.exec(str);
  if (!match) {
    return str;
  }
  let html2 = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index;index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html2 += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html2 += escaped;
  }
  return lastIndex !== index ? html2 + str.slice(lastIndex, index) : html2;
}
var toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$3(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$3(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
function defaultOnError$1(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = (messages || errorMessages$3)[code] + (additionalMessage || ``);
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
var errorMessages$3 = {
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  [51]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,
  [52]: `v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.`,
  [53]: ``
};
var FRAGMENT = Symbol(`Fragment`);
var TELEPORT = Symbol(`Teleport`);
var SUSPENSE = Symbol(`Suspense`);
var KEEP_ALIVE = Symbol(`KeepAlive`);
var BASE_TRANSITION = Symbol(`BaseTransition`);
var OPEN_BLOCK = Symbol(`openBlock`);
var CREATE_BLOCK = Symbol(`createBlock`);
var CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
var CREATE_VNODE = Symbol(`createVNode`);
var CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
var CREATE_COMMENT = Symbol(`createCommentVNode`);
var CREATE_TEXT = Symbol(`createTextVNode`);
var CREATE_STATIC = Symbol(`createStaticVNode`);
var RESOLVE_COMPONENT = Symbol(`resolveComponent`);
var RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
var RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
var RESOLVE_FILTER = Symbol(`resolveFilter`);
var WITH_DIRECTIVES = Symbol(`withDirectives`);
var RENDER_LIST = Symbol(`renderList`);
var RENDER_SLOT = Symbol(`renderSlot`);
var CREATE_SLOTS = Symbol(`createSlots`);
var TO_DISPLAY_STRING = Symbol(`toDisplayString`);
var MERGE_PROPS = Symbol(`mergeProps`);
var NORMALIZE_CLASS = Symbol(`normalizeClass`);
var NORMALIZE_STYLE = Symbol(`normalizeStyle`);
var NORMALIZE_PROPS = Symbol(`normalizeProps`);
var GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
var TO_HANDLERS = Symbol(`toHandlers`);
var CAMELIZE = Symbol(`camelize`);
var CAPITALIZE = Symbol(`capitalize`);
var TO_HANDLER_KEY = Symbol(`toHandlerKey`);
var SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
var PUSH_SCOPE_ID = Symbol(`pushScopeId`);
var POP_SCOPE_ID = Symbol(`popScopeId`);
var WITH_CTX = Symbol(`withCtx`);
var UNREF = Symbol(`unref`);
var IS_REF = Symbol(`isRef`);
var WITH_MEMO = Symbol(`withMemo`);
var IS_MEMO_SAME = Symbol(`isMemoSame`);
var helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s2) => {
    helperNameMap[s2] = helpers[s2];
  });
}
var locStub = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: /* @__PURE__ */ new Set,
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives2, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives2) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives: directives2,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString$2(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString$2(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left2, right2) {
  return {
    type: 24,
    left: left2,
    right: right2,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getDefaultExportFromCjs2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a() {
      if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var lib = {};
Object.defineProperty(lib, "__esModule", {
  value: true
});
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0;i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

class Position {
  constructor(line, col, index) {
    this.line = undefined;
    this.column = undefined;
    this.index = undefined;
    this.line = line;
    this.column = col;
    this.index = index;
  }
}

class SourceLocation {
  constructor(start, end) {
    this.start = undefined;
    this.end = undefined;
    this.filename = undefined;
    this.identifierName = undefined;
    this.start = start;
    this.end = end;
  }
}
function createPositionWithColumnOffset(position, columnOffset) {
  const {
    line,
    column,
    index
  } = position;
  return new Position(line, column + columnOffset, index + columnOffset);
}
var code$3 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var ModuleErrors = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code: code$3
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code: code$3
  }
};
var NodeDescriptions = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
};
var toNodeDescription = ({
  type,
  prefix
}) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
var StandardErrors = {
  AccessorIsGenerator: ({
    kind
  }) => `A ${kind}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind
  }) => `Missing initializer in ${kind} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName
  }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  DynamicImportPhaseRequiresImportExpressions: ({
    phase
  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName,
    exportName
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type
  }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type
  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount
  }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix
  }) => `Expected number in radix ${radix}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord
  }) => `Escape sequence in keyword ${reservedWord}.`,
  InvalidIdentifier: ({
    identifierName
  }) => `Invalid identifier ${identifierName}.`,
  InvalidLhs: ({
    ancestor
  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
  InvalidLhsBinding: ({
    ancestor
  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
  InvalidLhsOptionalChaining: ({
    ancestor
  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected
  }) => `Unexpected character '${unexpected}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName
  }) => `Private name #${identifierName} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName
  }) => `Label '${labelName}' is already declared.`,
  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin
  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name3) => JSON.stringify(name3)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name3) => JSON.stringify(name3)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key
  }) => `Duplicate key "${key}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode
  }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName
  }) => `Export '${localName}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName
  }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName
  }) => `Duplicate private name #${identifierName}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword
  }) => `Unexpected keyword '${keyword}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord
  }) => `Unexpected reserved word '${reservedWord}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected,
    unexpected
  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target,
    onlyValidPropertyName
  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName
  }) => `Identifier '${identifierName}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
};
var StrictModeErrors = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName
  }) => `Assigning to '${referenceName}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName
  }) => `Binding '${bindingName}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
var UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var PipelineOperatorErrors = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: token2
  }) => `Invalid topic token ${token2}. In order to use ${token2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token2}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type
  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
    type
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
var _excluded$1 = ["toMessage"];
var _excluded2$1 = ["message"];
function defineHidden(obj, key, value) {
  Object.defineProperty(obj, key, {
    enumerable: false,
    configurable: true,
    value
  });
}
function toParseErrorConstructor(_ref) {
  let {
    toMessage
  } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  return function constructor({
    loc,
    details
  }) {
    const error = new SyntaxError;
    Object.assign(error, properties, {
      loc,
      pos: loc.index
    });
    if ("missingPlugin" in details) {
      Object.assign(error, {
        missingPlugin: details.missingPlugin
      });
    }
    defineHidden(error, "clone", function clone(overrides = {}) {
      var _overrides$loc;
      const {
        line,
        column,
        index
      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
      return constructor({
        loc: new Position(line, column, index),
        details: Object.assign({}, details, overrides.details)
      });
    });
    defineHidden(error, "details", details);
    Object.defineProperty(error, "message", {
      configurable: true,
      get() {
        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
        this.message = message;
        return message;
      },
      set(value) {
        Object.defineProperty(this, "message", {
          value,
          writable: true
        });
      }
    });
    return error;
  };
}
function ParseErrorEnum(argument, syntaxPlugin) {
  if (Array.isArray(argument)) {
    return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
  }
  const ParseErrorConstructors = {};
  for (const reasonCode of Object.keys(argument)) {
    const template = argument[reasonCode];
    const _ref2 = typeof template === "string" ? {
      message: () => template
    } : typeof template === "function" ? {
      message: template
    } : template, {
      message
    } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
    const toMessage = typeof message === "string" ? () => message : message;
    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
      code: "BABEL_PARSER_SYNTAX_ERROR",
      reasonCode,
      toMessage
    }, syntaxPlugin ? {
      syntaxPlugin
    } : {}, rest));
  }
  return ParseErrorConstructors;
}
var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
var {
  defineProperty
} = Object;
var toUnenumerable = (object, key) => defineProperty(object, key, {
  enumerable: false,
  value: object[key]
});
function toESTreeLocation(node) {
  node.loc.start && toUnenumerable(node.loc.start, "index");
  node.loc.end && toUnenumerable(node.loc.end, "index");
  return node;
}
var estree = (superClass) => class ESTreeParserMixin extends superClass {
  parse() {
    const file = toESTreeLocation(super.parse());
    if (this.options.tokens) {
      file.tokens = file.tokens.map(toESTreeLocation);
    }
    return file;
  }
  parseRegExpLiteral({
    pattern: pattern2,
    flags
  }) {
    let regex = null;
    try {
      regex = new RegExp(pattern2, flags);
    } catch (e2) {}
    const node = this.estreeParseLiteral(regex);
    node.regex = {
      pattern: pattern2,
      flags
    };
    return node;
  }
  parseBigIntLiteral(value) {
    let bigInt;
    try {
      bigInt = BigInt(value);
    } catch (_unused) {
      bigInt = null;
    }
    const node = this.estreeParseLiteral(bigInt);
    node.bigint = String(node.value || value);
    return node;
  }
  parseDecimalLiteral(value) {
    const decimal = null;
    const node = this.estreeParseLiteral(decimal);
    node.decimal = String(node.value || value);
    return node;
  }
  estreeParseLiteral(value) {
    return this.parseLiteral(value, "Literal");
  }
  parseStringLiteral(value) {
    return this.estreeParseLiteral(value);
  }
  parseNumericLiteral(value) {
    return this.estreeParseLiteral(value);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(value) {
    return this.estreeParseLiteral(value);
  }
  directiveToStmt(directive) {
    const expression = directive.value;
    delete directive.value;
    expression.type = "Literal";
    expression.raw = expression.extra.raw;
    expression.value = expression.extra.expressionValue;
    const stmt = directive;
    stmt.type = "ExpressionStatement";
    stmt.expression = expression;
    stmt.directive = expression.extra.rawValue;
    delete expression.extra;
    return stmt;
  }
  initFunction(node, isAsync) {
    super.initFunction(node, isAsync);
    node.expression = false;
  }
  checkDeclaration(node) {
    if (node != null && this.isObjectProperty(node)) {
      this.checkDeclaration(node.value);
    } else {
      super.checkDeclaration(node);
    }
  }
  getObjectOrClassMethodParams(method) {
    return method.value.params;
  }
  isValidDirective(stmt) {
    var _stmt$expression$extr;
    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
  }
  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
    const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
    node.body = directiveStatements.concat(node.body);
    delete node.directives;
  }
  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
    if (method.typeParameters) {
      method.value.typeParameters = method.typeParameters;
      delete method.typeParameters;
    }
    classBody.body.push(method);
  }
  parsePrivateName() {
    const node = super.parsePrivateName();
    {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return node;
      }
    }
    return this.convertPrivateNameToPrivateIdentifier(node);
  }
  convertPrivateNameToPrivateIdentifier(node) {
    const name3 = super.getPrivateNameSV(node);
    node = node;
    delete node.id;
    node.name = name3;
    node.type = "PrivateIdentifier";
    return node;
  }
  isPrivateName(node) {
    {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.isPrivateName(node);
      }
    }
    return node.type === "PrivateIdentifier";
  }
  getPrivateNameSV(node) {
    {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.getPrivateNameSV(node);
      }
    }
    return node.name;
  }
  parseLiteral(value, type) {
    const node = super.parseLiteral(value, type);
    node.raw = node.extra.raw;
    delete node.extra;
    return node;
  }
  parseFunctionBody(node, allowExpression, isMethod = false) {
    super.parseFunctionBody(node, allowExpression, isMethod);
    node.expression = node.body.type !== "BlockStatement";
  }
  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    let funcNode = this.startNode();
    funcNode.kind = node.kind;
    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
    funcNode.type = "FunctionExpression";
    delete funcNode.kind;
    node.value = funcNode;
    if (type === "ClassPrivateMethod") {
      node.computed = false;
    }
    return this.finishNode(node, "MethodDefinition");
  }
  parseClassProperty(...args) {
    const propertyNode = super.parseClassProperty(...args);
    {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return propertyNode;
      }
    }
    propertyNode.type = "PropertyDefinition";
    return propertyNode;
  }
  parseClassPrivateProperty(...args) {
    const propertyNode = super.parseClassPrivateProperty(...args);
    {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return propertyNode;
      }
    }
    propertyNode.type = "PropertyDefinition";
    propertyNode.computed = false;
    return propertyNode;
  }
  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
    if (node) {
      node.type = "Property";
      if (node.kind === "method") {
        node.kind = "init";
      }
      node.shorthand = false;
    }
    return node;
  }
  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
    if (node) {
      node.kind = "init";
      node.type = "Property";
    }
    return node;
  }
  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
  }
  isAssignable(node, isBinding) {
    if (node != null && this.isObjectProperty(node)) {
      return this.isAssignable(node.value, isBinding);
    }
    return super.isAssignable(node, isBinding);
  }
  toAssignable(node, isLHS = false) {
    if (node != null && this.isObjectProperty(node)) {
      const {
        key,
        value
      } = node;
      if (this.isPrivateName(key)) {
        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
      }
      this.toAssignable(value, isLHS);
    } else {
      super.toAssignable(node, isLHS);
    }
  }
  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    if (prop.kind === "get" || prop.kind === "set") {
      this.raise(Errors.PatternHasAccessor, {
        at: prop.key
      });
    } else if (prop.method) {
      this.raise(Errors.PatternHasMethod, {
        at: prop.key
      });
    } else {
      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
    }
  }
  finishCallExpression(unfinished, optional) {
    const node = super.finishCallExpression(unfinished, optional);
    if (node.callee.type === "Import") {
      node.type = "ImportExpression";
      node.source = node.arguments[0];
      if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var _node$arguments$, _node$arguments$2;
        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;
      }
      delete node.arguments;
      delete node.callee;
    }
    return node;
  }
  toReferencedArguments(node) {
    if (node.type === "ImportExpression") {
      return;
    }
    super.toReferencedArguments(node);
  }
  parseExport(unfinished, decorators) {
    const exportStartLoc = this.state.lastTokStartLoc;
    const node = super.parseExport(unfinished, decorators);
    switch (node.type) {
      case "ExportAllDeclaration":
        node.exported = null;
        break;
      case "ExportNamedDeclaration":
        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
          node.type = "ExportAllDeclaration";
          node.exported = node.specifiers[0].exported;
          delete node.specifiers;
        }
      case "ExportDefaultDeclaration":
        {
          var _declaration$decorato;
          const {
            declaration
          } = node;
          if ((declaration == null ? undefined : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? undefined : _declaration$decorato.length) > 0 && declaration.start === node.start) {
            this.resetStartLocation(node, exportStartLoc);
          }
        }
        break;
    }
    return node;
  }
  parseSubscript(base, startLoc, noCalls, state) {
    const node = super.parseSubscript(base, startLoc, noCalls, state);
    if (state.optionalChainMember) {
      if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
        node.type = node.type.substring(8);
      }
      if (state.stop) {
        const chain2 = this.startNodeAtNode(node);
        chain2.expression = node;
        return this.finishNode(chain2, "ChainExpression");
      }
    } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
      node.optional = false;
    }
    return node;
  }
  isOptionalMemberExpression(node) {
    if (node.type === "ChainExpression") {
      return node.expression.type === "MemberExpression";
    }
    return super.isOptionalMemberExpression(node);
  }
  hasPropertyAsPrivateName(node) {
    if (node.type === "ChainExpression") {
      node = node.expression;
    }
    return super.hasPropertyAsPrivateName(node);
  }
  isObjectProperty(node) {
    return node.type === "Property" && node.kind === "init" && !node.method;
  }
  isObjectMethod(node) {
    return node.method || node.kind === "get" || node.kind === "set";
  }
  finishNodeAt(node, type, endLoc) {
    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
  }
  resetStartLocation(node, startLoc) {
    super.resetStartLocation(node, startLoc);
    toESTreeLocation(node);
  }
  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
    super.resetEndLocation(node, endLoc);
    toESTreeLocation(node);
  }
};

class TokContext {
  constructor(token2, preserveSpace) {
    this.token = undefined;
    this.preserveSpace = undefined;
    this.token = token2;
    this.preserveSpace = !!preserveSpace;
  }
}
var types$1 = {
  brace: new TokContext("{"),
  j_oTag: new TokContext("<tag"),
  j_cTag: new TokContext("</tag"),
  j_expr: new TokContext("<tag>...</tag>", true)
};
{
  types$1.template = new TokContext("`", true);
}
var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

class ExportedTokenType {
  constructor(label, conf = {}) {
    this.label = undefined;
    this.keyword = undefined;
    this.beforeExpr = undefined;
    this.startsExpr = undefined;
    this.rightAssociative = undefined;
    this.isLoop = undefined;
    this.isAssign = undefined;
    this.prefix = undefined;
    this.postfix = undefined;
    this.binop = undefined;
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    {
      this.updateContext = null;
    }
  }
}
var keywords$1 = new Map;
function createKeyword(name3, options3 = {}) {
  options3.keyword = name3;
  const token2 = createToken(name3, options3);
  keywords$1.set(name3, token2);
  return token2;
}
function createBinop(name3, binop) {
  return createToken(name3, {
    beforeExpr,
    binop
  });
}
var tokenTypeCounter = -1;
var tokenTypes$1 = [];
var tokenLabels = [];
var tokenBinops = [];
var tokenBeforeExprs = [];
var tokenStartsExprs = [];
var tokenPrefixes = [];
function createToken(name3, options3 = {}) {
  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
  ++tokenTypeCounter;
  tokenLabels.push(name3);
  tokenBinops.push((_options$binop = options3.binop) != null ? _options$binop : -1);
  tokenBeforeExprs.push((_options$beforeExpr = options3.beforeExpr) != null ? _options$beforeExpr : false);
  tokenStartsExprs.push((_options$startsExpr = options3.startsExpr) != null ? _options$startsExpr : false);
  tokenPrefixes.push((_options$prefix = options3.prefix) != null ? _options$prefix : false);
  tokenTypes$1.push(new ExportedTokenType(name3, options3));
  return tokenTypeCounter;
}
function createKeywordLike(name3, options3 = {}) {
  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
  ++tokenTypeCounter;
  keywords$1.set(name3, tokenTypeCounter);
  tokenLabels.push(name3);
  tokenBinops.push((_options$binop2 = options3.binop) != null ? _options$binop2 : -1);
  tokenBeforeExprs.push((_options$beforeExpr2 = options3.beforeExpr) != null ? _options$beforeExpr2 : false);
  tokenStartsExprs.push((_options$startsExpr2 = options3.startsExpr) != null ? _options$startsExpr2 : false);
  tokenPrefixes.push((_options$prefix2 = options3.prefix) != null ? _options$prefix2 : false);
  tokenTypes$1.push(new ExportedTokenType("name", options3));
  return tokenTypeCounter;
}
var tt = {
  bracketL: createToken("[", {
    beforeExpr,
    startsExpr
  }),
  bracketHashL: createToken("#[", {
    beforeExpr,
    startsExpr
  }),
  bracketBarL: createToken("[|", {
    beforeExpr,
    startsExpr
  }),
  bracketR: createToken("]"),
  bracketBarR: createToken("|]"),
  braceL: createToken("{", {
    beforeExpr,
    startsExpr
  }),
  braceBarL: createToken("{|", {
    beforeExpr,
    startsExpr
  }),
  braceHashL: createToken("#{", {
    beforeExpr,
    startsExpr
  }),
  braceR: createToken("}"),
  braceBarR: createToken("|}"),
  parenL: createToken("(", {
    beforeExpr,
    startsExpr
  }),
  parenR: createToken(")"),
  comma: createToken(",", {
    beforeExpr
  }),
  semi: createToken(";", {
    beforeExpr
  }),
  colon: createToken(":", {
    beforeExpr
  }),
  doubleColon: createToken("::", {
    beforeExpr
  }),
  dot: createToken("."),
  question: createToken("?", {
    beforeExpr
  }),
  questionDot: createToken("?."),
  arrow: createToken("=>", {
    beforeExpr
  }),
  template: createToken("template"),
  ellipsis: createToken("...", {
    beforeExpr
  }),
  backQuote: createToken("`", {
    startsExpr
  }),
  dollarBraceL: createToken("${", {
    beforeExpr,
    startsExpr
  }),
  templateTail: createToken("...`", {
    startsExpr
  }),
  templateNonTail: createToken("...${", {
    beforeExpr,
    startsExpr
  }),
  at: createToken("@"),
  hash: createToken("#", {
    startsExpr
  }),
  interpreterDirective: createToken("#!..."),
  eq: createToken("=", {
    beforeExpr,
    isAssign
  }),
  assign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  slashAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  xorAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  moduloAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  incDec: createToken("++/--", {
    prefix,
    postfix,
    startsExpr
  }),
  bang: createToken("!", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  tilde: createToken("~", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  doubleCaret: createToken("^^", {
    startsExpr
  }),
  doubleAt: createToken("@@", {
    startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 1),
  logicalAND: createBinop("&&", 2),
  bitwiseOR: createBinop("|", 3),
  bitwiseXOR: createBinop("^", 4),
  bitwiseAND: createBinop("&", 5),
  equality: createBinop("==/!=/===/!==", 6),
  lt: createBinop("</>/<=/>=", 7),
  gt: createBinop("</>/<=/>=", 7),
  relational: createBinop("</>/<=/>=", 7),
  bitShift: createBinop("<</>>/>>>", 8),
  bitShiftL: createBinop("<</>>/>>>", 8),
  bitShiftR: createBinop("<</>>/>>>", 8),
  plusMin: createToken("+/-", {
    beforeExpr,
    binop: 9,
    prefix,
    startsExpr
  }),
  modulo: createToken("%", {
    binop: 10,
    startsExpr
  }),
  star: createToken("*", {
    binop: 10
  }),
  slash: createBinop("/", 10),
  exponent: createToken("**", {
    beforeExpr,
    binop: 11,
    rightAssociative: true
  }),
  _in: createKeyword("in", {
    beforeExpr,
    binop: 7
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr,
    binop: 7
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr
  }),
  _finally: createKeyword("finally"),
  _function: createKeyword("function", {
    startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr,
    startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _do: createKeyword("do", {
    isLoop,
    beforeExpr
  }),
  _for: createKeyword("for", {
    isLoop
  }),
  _while: createKeyword("while", {
    isLoop
  }),
  _as: createKeywordLike("as", {
    startsExpr
  }),
  _assert: createKeywordLike("assert", {
    startsExpr
  }),
  _async: createKeywordLike("async", {
    startsExpr
  }),
  _await: createKeywordLike("await", {
    startsExpr
  }),
  _defer: createKeywordLike("defer", {
    startsExpr
  }),
  _from: createKeywordLike("from", {
    startsExpr
  }),
  _get: createKeywordLike("get", {
    startsExpr
  }),
  _let: createKeywordLike("let", {
    startsExpr
  }),
  _meta: createKeywordLike("meta", {
    startsExpr
  }),
  _of: createKeywordLike("of", {
    startsExpr
  }),
  _sent: createKeywordLike("sent", {
    startsExpr
  }),
  _set: createKeywordLike("set", {
    startsExpr
  }),
  _source: createKeywordLike("source", {
    startsExpr
  }),
  _static: createKeywordLike("static", {
    startsExpr
  }),
  _using: createKeywordLike("using", {
    startsExpr
  }),
  _yield: createKeywordLike("yield", {
    startsExpr
  }),
  _asserts: createKeywordLike("asserts", {
    startsExpr
  }),
  _checks: createKeywordLike("checks", {
    startsExpr
  }),
  _exports: createKeywordLike("exports", {
    startsExpr
  }),
  _global: createKeywordLike("global", {
    startsExpr
  }),
  _implements: createKeywordLike("implements", {
    startsExpr
  }),
  _intrinsic: createKeywordLike("intrinsic", {
    startsExpr
  }),
  _infer: createKeywordLike("infer", {
    startsExpr
  }),
  _is: createKeywordLike("is", {
    startsExpr
  }),
  _mixins: createKeywordLike("mixins", {
    startsExpr
  }),
  _proto: createKeywordLike("proto", {
    startsExpr
  }),
  _require: createKeywordLike("require", {
    startsExpr
  }),
  _satisfies: createKeywordLike("satisfies", {
    startsExpr
  }),
  _keyof: createKeywordLike("keyof", {
    startsExpr
  }),
  _readonly: createKeywordLike("readonly", {
    startsExpr
  }),
  _unique: createKeywordLike("unique", {
    startsExpr
  }),
  _abstract: createKeywordLike("abstract", {
    startsExpr
  }),
  _declare: createKeywordLike("declare", {
    startsExpr
  }),
  _enum: createKeywordLike("enum", {
    startsExpr
  }),
  _module: createKeywordLike("module", {
    startsExpr
  }),
  _namespace: createKeywordLike("namespace", {
    startsExpr
  }),
  _interface: createKeywordLike("interface", {
    startsExpr
  }),
  _type: createKeywordLike("type", {
    startsExpr
  }),
  _opaque: createKeywordLike("opaque", {
    startsExpr
  }),
  name: createToken("name", {
    startsExpr
  }),
  string: createToken("string", {
    startsExpr
  }),
  num: createToken("num", {
    startsExpr
  }),
  bigint: createToken("bigint", {
    startsExpr
  }),
  decimal: createToken("decimal", {
    startsExpr
  }),
  regexp: createToken("regexp", {
    startsExpr
  }),
  privateName: createToken("#name", {
    startsExpr
  }),
  eof: createToken("eof"),
  jsxName: createToken("jsxName"),
  jsxText: createToken("jsxText", {
    beforeExpr: true
  }),
  jsxTagStart: createToken("jsxTagStart", {
    startsExpr: true
  }),
  jsxTagEnd: createToken("jsxTagEnd"),
  placeholder: createToken("%%", {
    startsExpr: true
  })
};
function tokenIsIdentifier(token2) {
  return token2 >= 93 && token2 <= 132;
}
function tokenKeywordOrIdentifierIsKeyword(token2) {
  return token2 <= 92;
}
function tokenIsKeywordOrIdentifier(token2) {
  return token2 >= 58 && token2 <= 132;
}
function tokenIsLiteralPropertyName(token2) {
  return token2 >= 58 && token2 <= 136;
}
function tokenComesBeforeExpression(token2) {
  return tokenBeforeExprs[token2];
}
function tokenCanStartExpression(token2) {
  return tokenStartsExprs[token2];
}
function tokenIsAssignment(token2) {
  return token2 >= 29 && token2 <= 33;
}
function tokenIsFlowInterfaceOrTypeOrOpaque(token2) {
  return token2 >= 129 && token2 <= 131;
}
function tokenIsLoop(token2) {
  return token2 >= 90 && token2 <= 92;
}
function tokenIsKeyword(token2) {
  return token2 >= 58 && token2 <= 92;
}
function tokenIsOperator(token2) {
  return token2 >= 39 && token2 <= 59;
}
function tokenIsPostfix(token2) {
  return token2 === 34;
}
function tokenIsPrefix(token2) {
  return tokenPrefixes[token2];
}
function tokenIsTSTypeOperator(token2) {
  return token2 >= 121 && token2 <= 123;
}
function tokenIsTSDeclarationStart(token2) {
  return token2 >= 124 && token2 <= 130;
}
function tokenLabelName(token2) {
  return tokenLabels[token2];
}
function tokenOperatorPrecedence(token2) {
  return tokenBinops[token2];
}
function tokenIsRightAssociative(token2) {
  return token2 === 57;
}
function tokenIsTemplate(token2) {
  return token2 >= 24 && token2 <= 25;
}
function getExportedToken(token2) {
  return tokenTypes$1[token2];
}
{
  tokenTypes$1[8].updateContext = (context) => {
    context.pop();
  };
  tokenTypes$1[5].updateContext = tokenTypes$1[7].updateContext = tokenTypes$1[23].updateContext = (context) => {
    context.push(types$1.brace);
  };
  tokenTypes$1[22].updateContext = (context) => {
    if (context[context.length - 1] === types$1.template) {
      context.pop();
    } else {
      context.push(types$1.template);
    }
  };
  tokenTypes$1[142].updateContext = (context) => {
    context.push(types$1.j_expr, types$1.j_oTag);
  };
}
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function isInAstralSet(code, set) {
  let pos = 65536;
  for (let i = 0, length = set.length;i < length; i += 2) {
    pos += set[i];
    if (pos > code)
      return false;
    pos += set[i + 1];
    if (pos >= code)
      return true;
  }
  return false;
}
function isIdentifierStart(code) {
  if (code < 65)
    return code === 36;
  if (code <= 90)
    return true;
  if (code < 97)
    return code === 95;
  if (code <= 122)
    return true;
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
  if (code < 48)
    return code === 36;
  if (code < 58)
    return true;
  if (code < 65)
    return false;
  if (code <= 90)
    return true;
  if (code < 97)
    return code === 95;
  if (code <= 122)
    return true;
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
  return keywords.has(word);
}
function isIteratorStart(current, next, next2) {
  return current === 64 && next === 64 && isIdentifierStart(next2);
}
var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function canBeReservedWord(word) {
  return reservedWordLikeSet.has(word);
}

class Scope {
  constructor(flags) {
    this.var = new Set;
    this.lexical = new Set;
    this.functions = new Set;
    this.flags = flags;
  }
}

class ScopeHandler {
  constructor(parser, inModule) {
    this.parser = undefined;
    this.scopeStack = [];
    this.inModule = undefined;
    this.undefinedExports = new Map;
    this.parser = parser;
    this.inModule = inModule;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const flags = this.currentThisScopeFlags();
    return (flags & 64) > 0 && (flags & 2) === 0;
  }
  get inStaticBlock() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];
      if (flags & 128) {
        return true;
      }
      if (flags & (387 | 64)) {
        return false;
      }
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(flags) {
    return new Scope(flags);
  }
  enter(flags) {
    this.scopeStack.push(this.createScope(flags));
  }
  exit() {
    const scope = this.scopeStack.pop();
    return scope.flags;
  }
  treatFunctionsAsVarInScope(scope) {
    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
  }
  declareName(name3, bindingType, loc) {
    let scope = this.currentScope();
    if (bindingType & 8 || bindingType & 16) {
      this.checkRedeclarationInScope(scope, name3, bindingType, loc);
      if (bindingType & 16) {
        scope.functions.add(name3);
      } else {
        scope.lexical.add(name3);
      }
      if (bindingType & 8) {
        this.maybeExportDefined(scope, name3);
      }
    } else if (bindingType & 4) {
      for (let i = this.scopeStack.length - 1;i >= 0; --i) {
        scope = this.scopeStack[i];
        this.checkRedeclarationInScope(scope, name3, bindingType, loc);
        scope.var.add(name3);
        this.maybeExportDefined(scope, name3);
        if (scope.flags & 387)
          break;
      }
    }
    if (this.parser.inModule && scope.flags & 1) {
      this.undefinedExports.delete(name3);
    }
  }
  maybeExportDefined(scope, name3) {
    if (this.parser.inModule && scope.flags & 1) {
      this.undefinedExports.delete(name3);
    }
  }
  checkRedeclarationInScope(scope, name3, bindingType, loc) {
    if (this.isRedeclaredInScope(scope, name3, bindingType)) {
      this.parser.raise(Errors.VarRedeclaration, {
        at: loc,
        identifierName: name3
      });
    }
  }
  isRedeclaredInScope(scope, name3, bindingType) {
    if (!(bindingType & 1))
      return false;
    if (bindingType & 8) {
      return scope.lexical.has(name3) || scope.functions.has(name3) || scope.var.has(name3);
    }
    if (bindingType & 16) {
      return scope.lexical.has(name3) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name3);
    }
    return scope.lexical.has(name3) && !(scope.flags & 8 && scope.lexical.values().next().value === name3) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name3);
  }
  checkLocalExport(id) {
    const {
      name: name3
    } = id;
    const topLevelScope = this.scopeStack[0];
    if (!topLevelScope.lexical.has(name3) && !topLevelScope.var.has(name3) && !topLevelScope.functions.has(name3)) {
      this.undefinedExports.set(name3, id.loc.start);
    }
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];
      if (flags & 387) {
        return flags;
      }
    }
  }
  currentThisScopeFlags() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];
      if (flags & (387 | 64) && !(flags & 4)) {
        return flags;
      }
    }
  }
}

class FlowScope extends Scope {
  constructor(...args) {
    super(...args);
    this.declareFunctions = new Set;
  }
}

class FlowScopeHandler extends ScopeHandler {
  createScope(flags) {
    return new FlowScope(flags);
  }
  declareName(name3, bindingType, loc) {
    const scope = this.currentScope();
    if (bindingType & 2048) {
      this.checkRedeclarationInScope(scope, name3, bindingType, loc);
      this.maybeExportDefined(scope, name3);
      scope.declareFunctions.add(name3);
      return;
    }
    super.declareName(name3, bindingType, loc);
  }
  isRedeclaredInScope(scope, name3, bindingType) {
    if (super.isRedeclaredInScope(scope, name3, bindingType))
      return true;
    if (bindingType & 2048) {
      return !scope.declareFunctions.has(name3) && (scope.lexical.has(name3) || scope.functions.has(name3));
    }
    return false;
  }
  checkLocalExport(id) {
    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
      super.checkLocalExport(id);
    }
  }
}

class BaseParser {
  constructor() {
    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }
  hasPlugin(pluginConfig) {
    if (typeof pluginConfig === "string") {
      return this.plugins.has(pluginConfig);
    } else {
      const [pluginName, pluginOptions] = pluginConfig;
      if (!this.hasPlugin(pluginName)) {
        return false;
      }
      const actualOptions = this.plugins.get(pluginName);
      for (const key of Object.keys(pluginOptions)) {
        if ((actualOptions == null ? undefined : actualOptions[key]) !== pluginOptions[key]) {
          return false;
        }
      }
      return true;
    }
  }
  getPluginOption(plugin, name3) {
    var _this$plugins$get;
    return (_this$plugins$get = this.plugins.get(plugin)) == null ? undefined : _this$plugins$get[name3];
  }
}
function setTrailingComments(node, comments) {
  if (node.trailingComments === undefined) {
    node.trailingComments = comments;
  } else {
    node.trailingComments.unshift(...comments);
  }
}
function setLeadingComments(node, comments) {
  if (node.leadingComments === undefined) {
    node.leadingComments = comments;
  } else {
    node.leadingComments.unshift(...comments);
  }
}
function setInnerComments(node, comments) {
  if (node.innerComments === undefined) {
    node.innerComments = comments;
  } else {
    node.innerComments.unshift(...comments);
  }
}
function adjustInnerComments(node, elements, commentWS) {
  let lastElement = null;
  let i = elements.length;
  while (lastElement === null && i > 0) {
    lastElement = elements[--i];
  }
  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments(node, commentWS.comments);
  } else {
    setTrailingComments(lastElement, commentWS.comments);
  }
}

class CommentsParser extends BaseParser {
  addComment(comment) {
    if (this.filename)
      comment.loc.filename = this.filename;
    this.state.comments.push(comment);
  }
  processComment(node) {
    const {
      commentStack
    } = this.state;
    const commentStackLength = commentStack.length;
    if (commentStackLength === 0)
      return;
    let i = commentStackLength - 1;
    const lastCommentWS = commentStack[i];
    if (lastCommentWS.start === node.end) {
      lastCommentWS.leadingNode = node;
      i--;
    }
    const {
      start: nodeStart
    } = node;
    for (;i >= 0; i--) {
      const commentWS = commentStack[i];
      const commentEnd = commentWS.end;
      if (commentEnd > nodeStart) {
        commentWS.containingNode = node;
        this.finalizeComment(commentWS);
        commentStack.splice(i, 1);
      } else {
        if (commentEnd === nodeStart) {
          commentWS.trailingNode = node;
        }
        break;
      }
    }
  }
  finalizeComment(commentWS) {
    const {
      comments
    } = commentWS;
    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
      if (commentWS.leadingNode !== null) {
        setTrailingComments(commentWS.leadingNode, comments);
      }
      if (commentWS.trailingNode !== null) {
        setLeadingComments(commentWS.trailingNode, comments);
      }
    } else {
      const {
        containingNode: node,
        start: commentStart
      } = commentWS;
      if (this.input.charCodeAt(commentStart - 1) === 44) {
        switch (node.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            adjustInnerComments(node, node.properties, commentWS);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            adjustInnerComments(node, node.arguments, commentWS);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            adjustInnerComments(node, node.params, commentWS);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            adjustInnerComments(node, node.elements, commentWS);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            adjustInnerComments(node, node.specifiers, commentWS);
            break;
          default: {
            setInnerComments(node, comments);
          }
        }
      } else {
        setInnerComments(node, comments);
      }
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack
    } = this.state;
    for (let i = commentStack.length - 1;i >= 0; i--) {
      this.finalizeComment(commentStack[i]);
    }
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(node) {
    const {
      commentStack
    } = this.state;
    const {
      length
    } = commentStack;
    if (length === 0)
      return;
    const commentWS = commentStack[length - 1];
    if (commentWS.leadingNode === node) {
      commentWS.leadingNode = null;
    }
  }
  resetPreviousIdentifierLeadingComments(node) {
    const {
      commentStack
    } = this.state;
    const {
      length
    } = commentStack;
    if (length === 0)
      return;
    if (commentStack[length - 1].trailingNode === node) {
      commentStack[length - 1].trailingNode = null;
    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
      commentStack[length - 2].trailingNode = null;
    }
  }
  takeSurroundingComments(node, start, end) {
    const {
      commentStack
    } = this.state;
    const commentStackLength = commentStack.length;
    if (commentStackLength === 0)
      return;
    let i = commentStackLength - 1;
    for (;i >= 0; i--) {
      const commentWS = commentStack[i];
      const commentEnd = commentWS.end;
      const commentStart = commentWS.start;
      if (commentStart === end) {
        commentWS.leadingNode = node;
      } else if (commentEnd === start) {
        commentWS.trailingNode = node;
      } else if (commentEnd < start) {
        break;
      }
    }
  }
}
var lineBreak = /\r\n?|[\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;
    default:
      return false;
  }
}
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function isWhitespace(code) {
  switch (code) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true;
    default:
      return false;
  }
}

class State2 {
  constructor() {
    this.strict = undefined;
    this.curLine = undefined;
    this.lineStart = undefined;
    this.startLoc = undefined;
    this.endLoc = undefined;
    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.maybeInArrowParameters = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.hasFlowComment = false;
    this.isAmbientContext = false;
    this.inAbstractClass = false;
    this.inDisallowConditionalTypesContext = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.labels = [];
    this.comments = [];
    this.commentStack = [];
    this.pos = 0;
    this.type = 139;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.context = [types$1.brace];
    this.canStartJSXElement = true;
    this.containsEsc = false;
    this.firstInvalidTemplateEscapePos = null;
    this.strictErrors = new Map;
    this.tokensLength = 0;
  }
  init({
    strictMode,
    sourceType,
    startLine,
    startColumn
  }) {
    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
    this.curLine = startLine;
    this.lineStart = -startColumn;
    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
  }
  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone(skipArrays) {
    const state = new State2;
    const keys = Object.keys(this);
    for (let i = 0, length = keys.length;i < length; i++) {
      const key = keys[i];
      let val = this[key];
      if (!skipArrays && Array.isArray(val)) {
        val = val.slice();
      }
      state[key] = val;
    }
    return state;
  }
}
var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};
var forbiddenNumericSeparatorSiblings = {
  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: new Set([46, 88, 95, 120])
};
var isAllowedNumericSeparatorSibling = {
  bin: (ch) => ch === 48 || ch === 49,
  oct: (ch) => ch >= 48 && ch <= 55,
  dec: (ch) => ch >= 48 && ch <= 57,
  hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
};
function readStringContents(type, input, pos, lineStart, curLine, errors2) {
  const initialPos = pos;
  const initialLineStart = lineStart;
  const initialCurLine = curLine;
  let out = "";
  let firstInvalidLoc = null;
  let chunkStart = pos;
  const {
    length
  } = input;
  for (;; ) {
    if (pos >= length) {
      errors2.unterminated(initialPos, initialLineStart, initialCurLine);
      out += input.slice(chunkStart, pos);
      break;
    }
    const ch = input.charCodeAt(pos);
    if (isStringEnd(type, ch, input, pos)) {
      out += input.slice(chunkStart, pos);
      break;
    }
    if (ch === 92) {
      out += input.slice(chunkStart, pos);
      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors2);
      if (res.ch === null && !firstInvalidLoc) {
        firstInvalidLoc = {
          pos,
          lineStart,
          curLine
        };
      } else {
        out += res.ch;
      }
      ({
        pos,
        lineStart,
        curLine
      } = res);
      chunkStart = pos;
    } else if (ch === 8232 || ch === 8233) {
      ++pos;
      ++curLine;
      lineStart = pos;
    } else if (ch === 10 || ch === 13) {
      if (type === "template") {
        out += input.slice(chunkStart, pos) + `
`;
        ++pos;
        if (ch === 13 && input.charCodeAt(pos) === 10) {
          ++pos;
        }
        ++curLine;
        chunkStart = lineStart = pos;
      } else {
        errors2.unterminated(initialPos, initialLineStart, initialCurLine);
      }
    } else {
      ++pos;
    }
  }
  return {
    pos,
    str: out,
    firstInvalidLoc,
    lineStart,
    curLine,
    containsInvalid: !!firstInvalidLoc
  };
}
function isStringEnd(type, ch, input, pos) {
  if (type === "template") {
    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
  }
  return ch === (type === "double" ? 34 : 39);
}
function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors2) {
  const throwOnInvalid = !inTemplate;
  pos++;
  const res = (ch2) => ({
    pos,
    ch: ch2,
    lineStart,
    curLine
  });
  const ch = input.charCodeAt(pos++);
  switch (ch) {
    case 110:
      return res(`
`);
    case 114:
      return res("\r");
    case 120: {
      let code;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors2));
      return res(code === null ? null : String.fromCharCode(code));
    }
    case 117: {
      let code;
      ({
        code,
        pos
      } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors2));
      return res(code === null ? null : String.fromCodePoint(code));
    }
    case 116:
      return res("\t");
    case 98:
      return res("\b");
    case 118:
      return res("\v");
    case 102:
      return res("\f");
    case 13:
      if (input.charCodeAt(pos) === 10) {
        ++pos;
      }
    case 10:
      lineStart = pos;
      ++curLine;
    case 8232:
    case 8233:
      return res("");
    case 56:
    case 57:
      if (inTemplate) {
        return res(null);
      } else {
        errors2.strictNumericEscape(pos - 1, lineStart, curLine);
      }
    default:
      if (ch >= 48 && ch <= 55) {
        const startPos = pos - 1;
        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
        let octalStr = match[0];
        let octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        pos += octalStr.length - 1;
        const next = input.charCodeAt(pos);
        if (octalStr !== "0" || next === 56 || next === 57) {
          if (inTemplate) {
            return res(null);
          } else {
            errors2.strictNumericEscape(startPos, lineStart, curLine);
          }
        }
        return res(String.fromCharCode(octal));
      }
      return res(String.fromCharCode(ch));
  }
}
function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors2) {
  const initialPos = pos;
  let n2;
  ({
    n: n2,
    pos
  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors2, !throwOnInvalid));
  if (n2 === null) {
    if (throwOnInvalid) {
      errors2.invalidEscapeSequence(initialPos, lineStart, curLine);
    } else {
      pos = initialPos - 1;
    }
  }
  return {
    code: n2,
    pos
  };
}
function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors2, bailOnError) {
  const start = pos;
  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
  let invalid = false;
  let total = 0;
  for (let i = 0, e2 = len == null ? Infinity : len;i < e2; ++i) {
    const code = input.charCodeAt(pos);
    let val;
    if (code === 95 && allowNumSeparator !== "bail") {
      const prev = input.charCodeAt(pos - 1);
      const next = input.charCodeAt(pos + 1);
      if (!allowNumSeparator) {
        if (bailOnError)
          return {
            n: null,
            pos
          };
        errors2.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
        if (bailOnError)
          return {
            n: null,
            pos
          };
        errors2.unexpectedNumericSeparator(pos, lineStart, curLine);
      }
      ++pos;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (_isDigit(code)) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      if (val <= 9 && bailOnError) {
        return {
          n: null,
          pos
        };
      } else if (val <= 9 && errors2.invalidDigit(pos, lineStart, curLine, radix)) {
        val = 0;
      } else if (forceLen) {
        val = 0;
        invalid = true;
      } else {
        break;
      }
    }
    ++pos;
    total = total * radix + val;
  }
  if (pos === start || len != null && pos - start !== len || invalid) {
    return {
      n: null,
      pos
    };
  }
  return {
    n: total,
    pos
  };
}
function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors2) {
  const ch = input.charCodeAt(pos);
  let code;
  if (ch === 123) {
    ++pos;
    ({
      code,
      pos
    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors2));
    ++pos;
    if (code !== null && code > 1114111) {
      if (throwOnInvalid) {
        errors2.invalidCodePoint(pos, lineStart, curLine);
      } else {
        return {
          code: null,
          pos
        };
      }
    }
  } else {
    ({
      code,
      pos
    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors2));
  }
  return {
    code,
    pos
  };
}
var _excluded = ["at"];
var _excluded2 = ["at"];
function buildPosition(pos, lineStart, curLine) {
  return new Position(curLine, pos - lineStart, pos);
}
var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);

class Token {
  constructor(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  }
}

class Tokenizer3 extends CommentsParser {
  constructor(options3, input) {
    super();
    this.isLookahead = undefined;
    this.tokens = [];
    this.errorHandlers_readInt = {
      invalidDigit: (pos, lineStart, curLine, radix) => {
        if (!this.options.errorRecovery)
          return false;
        this.raise(Errors.InvalidDigit, {
          at: buildPosition(pos, lineStart, curLine),
          radix
        });
        return true;
      },
      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
    };
    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
    });
    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (pos, lineStart, curLine) => {
        this.recordStrictModeErrors(Errors.StrictNumericEscape, {
          at: buildPosition(pos, lineStart, curLine)
        });
      },
      unterminated: (pos, lineStart, curLine) => {
        throw this.raise(Errors.UnterminatedString, {
          at: buildPosition(pos - 1, lineStart, curLine)
        });
      }
    });
    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
      unterminated: (pos, lineStart, curLine) => {
        throw this.raise(Errors.UnterminatedTemplate, {
          at: buildPosition(pos, lineStart, curLine)
        });
      }
    });
    this.state = new State2;
    this.state.init(options3);
    this.input = input;
    this.length = input.length;
    this.isLookahead = false;
  }
  pushToken(token2) {
    this.tokens.length = this.state.tokensLength;
    this.tokens.push(token2);
    ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes();
    if (this.options.tokens) {
      this.pushToken(new Token(this.state));
    }
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  }
  eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  }
  match(type) {
    return this.state.type === type;
  }
  createLookaheadState(state) {
    return {
      pos: state.pos,
      value: null,
      type: state.type,
      start: state.start,
      end: state.end,
      context: [this.curContext()],
      inType: state.inType,
      startLoc: state.startLoc,
      lastTokEndLoc: state.lastTokEndLoc,
      curLine: state.curLine,
      lineStart: state.lineStart,
      curPosition: state.curPosition
    };
  }
  lookahead() {
    const old = this.state;
    this.state = this.createLookaheadState(old);
    this.isLookahead = true;
    this.nextToken();
    this.isLookahead = false;
    const curr = this.state;
    this.state = old;
    return curr;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(pos) {
    skipWhiteSpace.lastIndex = pos;
    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(pos) {
    skipWhiteSpaceInLine.lastIndex = pos;
    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(pos) {
    let cp2 = this.input.charCodeAt(pos);
    if ((cp2 & 64512) === 55296 && ++pos < this.input.length) {
      const trail = this.input.charCodeAt(pos);
      if ((trail & 64512) === 56320) {
        cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023);
      }
    }
    return cp2;
  }
  setStrict(strict) {
    this.state.strict = strict;
    if (strict) {
      this.state.strictErrors.forEach(([toParseError, at2]) => this.raise(toParseError, {
        at: at2
      }));
      this.state.strictErrors.clear();
    }
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    this.skipSpace();
    this.state.start = this.state.pos;
    if (!this.isLookahead)
      this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.length) {
      this.finishToken(139);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(commentEnd) {
    let startLoc;
    if (!this.isLookahead)
      startLoc = this.state.curPosition();
    const start = this.state.pos;
    const end = this.input.indexOf(commentEnd, start + 2);
    if (end === -1) {
      throw this.raise(Errors.UnterminatedComment, {
        at: this.state.curPosition()
      });
    }
    this.state.pos = end + commentEnd.length;
    lineBreakG.lastIndex = start + 2;
    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
      ++this.state.curLine;
      this.state.lineStart = lineBreakG.lastIndex;
    }
    if (this.isLookahead)
      return;
    const comment = {
      type: "CommentBlock",
      value: this.input.slice(start + 2, end),
      start,
      end: end + commentEnd.length,
      loc: new SourceLocation(startLoc, this.state.curPosition())
    };
    if (this.options.tokens)
      this.pushToken(comment);
    return comment;
  }
  skipLineComment(startSkip) {
    const start = this.state.pos;
    let startLoc;
    if (!this.isLookahead)
      startLoc = this.state.curPosition();
    let ch = this.input.charCodeAt(this.state.pos += startSkip);
    if (this.state.pos < this.length) {
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
    }
    if (this.isLookahead)
      return;
    const end = this.state.pos;
    const value = this.input.slice(start + startSkip, end);
    const comment = {
      type: "CommentLine",
      value,
      start,
      end,
      loc: new SourceLocation(startLoc, this.state.curPosition())
    };
    if (this.options.tokens)
      this.pushToken(comment);
    return comment;
  }
  skipSpace() {
    const spaceStart = this.state.pos;
    const comments = [];
    loop:
      while (this.state.pos < this.length) {
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const comment = this.skipBlockComment("*/");
                if (comment !== undefined) {
                  this.addComment(comment);
                  if (this.options.attachComment)
                    comments.push(comment);
                }
                break;
              }
              case 47: {
                const comment = this.skipLineComment(2);
                if (comment !== undefined) {
                  this.addComment(comment);
                  if (this.options.attachComment)
                    comments.push(comment);
                }
                break;
              }
              default:
                break loop;
            }
            break;
          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else if (ch === 45 && !this.inModule && this.options.annexB) {
              const pos = this.state.pos;
              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                const comment = this.skipLineComment(3);
                if (comment !== undefined) {
                  this.addComment(comment);
                  if (this.options.attachComment)
                    comments.push(comment);
                }
              } else {
                break loop;
              }
            } else if (ch === 60 && !this.inModule && this.options.annexB) {
              const pos = this.state.pos;
              if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                const comment = this.skipLineComment(4);
                if (comment !== undefined) {
                  this.addComment(comment);
                  if (this.options.attachComment)
                    comments.push(comment);
                }
              } else {
                break loop;
              }
            } else {
              break loop;
            }
        }
      }
    if (comments.length > 0) {
      const end = this.state.pos;
      const commentWhitespace = {
        start: spaceStart,
        end,
        comments,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(commentWhitespace);
    }
  }
  finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    const prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;
    if (!this.isLookahead) {
      this.updateContext(prevType);
    }
  }
  replaceToken(type) {
    this.state.type = type;
    this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return;
    }
    const nextPos = this.state.pos + 1;
    const next = this.codePointAtPos(nextPos);
    if (next >= 48 && next <= 57) {
      throw this.raise(Errors.UnexpectedDigitAfterHash, {
        at: this.state.curPosition()
      });
    }
    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
      this.expectPlugin("recordAndTuple");
      if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
          at: this.state.curPosition()
        });
      }
      this.state.pos += 2;
      if (next === 123) {
        this.finishToken(7);
      } else {
        this.finishToken(1);
      }
    } else if (isIdentifierStart(next)) {
      ++this.state.pos;
      this.finishToken(138, this.readWord1(next));
    } else if (next === 92) {
      ++this.state.pos;
      this.finishToken(138, this.readWord1());
    } else {
      this.finishOp(27, 1);
    }
  }
  readToken_dot() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      this.readNumber(true);
      return;
    }
    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
      this.state.pos += 3;
      this.finishToken(21);
    } else {
      ++this.state.pos;
      this.finishToken(16);
    }
  }
  readToken_slash() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      this.finishOp(31, 2);
    } else {
      this.finishOp(56, 1);
    }
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return false;
    let ch = this.input.charCodeAt(this.state.pos + 1);
    if (ch !== 33)
      return false;
    const start = this.state.pos;
    this.state.pos += 1;
    while (!isNewLine(ch) && ++this.state.pos < this.length) {
      ch = this.input.charCodeAt(this.state.pos);
    }
    const value = this.input.slice(start + 2, this.state.pos);
    this.finishToken(28, value);
    return true;
  }
  readToken_mult_modulo(code) {
    let type = code === 42 ? 55 : 54;
    let width = 1;
    let next = this.input.charCodeAt(this.state.pos + 1);
    if (code === 42 && next === 42) {
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = 57;
    }
    if (next === 61 && !this.state.inType) {
      width++;
      type = code === 37 ? 33 : 30;
    }
    this.finishOp(type, width);
  }
  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(30, 3);
      } else {
        this.finishOp(code === 124 ? 41 : 42, 2);
      }
      return;
    }
    if (code === 124) {
      if (next === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && next === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        }
        this.state.pos += 2;
        this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && next === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        }
        this.state.pos += 2;
        this.finishToken(4);
        return;
      }
    }
    if (next === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(code === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61 && !this.state.inType) {
      this.finishOp(32, 2);
    } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }])) {
      this.finishOp(37, 2);
      const lookaheadCh = this.input.codePointAt(this.state.pos);
      if (lookaheadCh === 94) {
        this.unexpected();
      }
    } else {
      this.finishOp(44, 1);
    }
  }
  readToken_atSign() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }])) {
      this.finishOp(38, 2);
    } else {
      this.finishOp(26, 1);
    }
  }
  readToken_plus_min(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) {
      this.finishOp(34, 2);
      return;
    }
    if (next === 61) {
      this.finishOp(30, 2);
    } else {
      this.finishOp(53, 1);
    }
  }
  readToken_lt() {
    const {
      pos
    } = this.state;
    const next = this.input.charCodeAt(pos + 1);
    if (next === 60) {
      if (this.input.charCodeAt(pos + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (next === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos
    } = this.state;
    const next = this.input.charCodeAt(pos + 1);
    if (next === 62) {
      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(pos + size) === 61) {
        this.finishOp(30, size + 1);
        return;
      }
      this.finishOp(52, size);
      return;
    }
    if (next === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (code === 61 && next === 62) {
      this.state.pos += 2;
      this.finishToken(19);
      return;
    }
    this.finishOp(code === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const next = this.input.charCodeAt(this.state.pos + 1);
    const next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 63) {
      if (next2 === 61) {
        this.finishOp(30, 3);
      } else {
        this.finishOp(40, 2);
      }
    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
      this.state.pos += 2;
      this.finishToken(18);
    } else {
      ++this.state.pos;
      this.finishToken(17);
    }
  }
  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos;
        this.finishToken(10);
        return;
      case 41:
        ++this.state.pos;
        this.finishToken(11);
        return;
      case 59:
        ++this.state.pos;
        this.finishToken(13);
        return;
      case 44:
        ++this.state.pos;
        this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          this.finishToken(2);
        } else {
          ++this.state.pos;
          this.finishToken(0);
        }
        return;
      case 93:
        ++this.state.pos;
        this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          this.finishToken(6);
        } else {
          ++this.state.pos;
          this.finishToken(5);
        }
        return;
      case 125:
        ++this.state.pos;
        this.finishToken(8);
        return;
      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(15, 2);
        } else {
          ++this.state.pos;
          this.finishToken(14);
        }
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (next === 111 || next === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (next === 98 || next === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false);
        return;
      case 34:
      case 39:
        this.readString(code);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(code);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(code);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(code);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(code);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (isIdentifierStart(code)) {
          this.readWord(code);
          return;
        }
    }
    throw this.raise(Errors.InvalidOrUnexpectedToken, {
      at: this.state.curPosition(),
      unexpected: String.fromCodePoint(code)
    });
  }
  finishOp(type, size) {
    const str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    this.finishToken(type, str);
  }
  readRegexp() {
    const startLoc = this.state.startLoc;
    const start = this.state.start + 1;
    let escaped, inClass;
    let {
      pos
    } = this.state;
    for (;; ++pos) {
      if (pos >= this.length) {
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1)
        });
      }
      const ch = this.input.charCodeAt(pos);
      if (isNewLine(ch)) {
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1)
        });
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === 91) {
          inClass = true;
        } else if (ch === 93 && inClass) {
          inClass = false;
        } else if (ch === 47 && !inClass) {
          break;
        }
        escaped = ch === 92;
      }
    }
    const content = this.input.slice(start, pos);
    ++pos;
    let mods = "";
    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
    while (pos < this.length) {
      const cp2 = this.codePointAtPos(pos);
      const char = String.fromCharCode(cp2);
      if (VALID_REGEX_FLAGS.has(cp2)) {
        if (cp2 === 118) {
          if (mods.includes("u")) {
            this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos()
            });
          }
        } else if (cp2 === 117) {
          if (mods.includes("v")) {
            this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos()
            });
          }
        }
        if (mods.includes(char)) {
          this.raise(Errors.DuplicateRegExpFlags, {
            at: nextPos()
          });
        }
      } else if (isIdentifierChar(cp2) || cp2 === 92) {
        this.raise(Errors.MalformedRegExpFlags, {
          at: nextPos()
        });
      } else {
        break;
      }
      ++pos;
      mods += char;
    }
    this.state.pos = pos;
    this.finishToken(137, {
      pattern: content,
      flags: mods
    });
  }
  readInt(radix, len, forceLen = false, allowNumSeparator = true) {
    const {
      n: n2,
      pos
    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
    this.state.pos = pos;
    return n2;
  }
  readRadixNumber(radix) {
    const startLoc = this.state.curPosition();
    let isBigInt = false;
    this.state.pos += 2;
    const val = this.readInt(radix);
    if (val == null) {
      this.raise(Errors.InvalidDigit, {
        at: createPositionWithColumnOffset(startLoc, 2),
        radix
      });
    }
    const next = this.input.charCodeAt(this.state.pos);
    if (next === 110) {
      ++this.state.pos;
      isBigInt = true;
    } else if (next === 109) {
      throw this.raise(Errors.InvalidDecimal, {
        at: startLoc
      });
    }
    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition()
      });
    }
    if (isBigInt) {
      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(135, str);
      return;
    }
    this.finishToken(134, val);
  }
  readNumber(startsWithDot) {
    const start = this.state.pos;
    const startLoc = this.state.curPosition();
    let isFloat = false;
    let isBigInt = false;
    let isDecimal = false;
    let hasExponent = false;
    let isOctal = false;
    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(Errors.InvalidNumber, {
        at: this.state.curPosition()
      });
    }
    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (hasLeadingZero) {
      const integer = this.input.slice(start, this.state.pos);
      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
        at: startLoc
      });
      if (!this.state.strict) {
        const underscorePos = integer.indexOf("_");
        if (underscorePos > 0) {
          this.raise(Errors.ZeroDigitNumericSeparator, {
            at: createPositionWithColumnOffset(startLoc, underscorePos)
          });
        }
      }
      isOctal = hasLeadingZero && !/[89]/.test(integer);
    }
    let next = this.input.charCodeAt(this.state.pos);
    if (next === 46 && !isOctal) {
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if ((next === 69 || next === 101) && !isOctal) {
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) {
        ++this.state.pos;
      }
      if (this.readInt(10) === null) {
        this.raise(Errors.InvalidOrMissingExponent, {
          at: startLoc
        });
      }
      isFloat = true;
      hasExponent = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (next === 110) {
      if (isFloat || hasLeadingZero) {
        this.raise(Errors.InvalidBigIntLiteral, {
          at: startLoc
        });
      }
      ++this.state.pos;
      isBigInt = true;
    }
    if (next === 109) {
      this.expectPlugin("decimal", this.state.curPosition());
      if (hasExponent || hasLeadingZero) {
        this.raise(Errors.InvalidDecimal, {
          at: startLoc
        });
      }
      ++this.state.pos;
      isDecimal = true;
    }
    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition()
      });
    }
    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
    if (isBigInt) {
      this.finishToken(135, str);
      return;
    }
    if (isDecimal) {
      this.finishToken(136, str);
      return;
    }
    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    this.finishToken(134, val);
  }
  readCodePoint(throwOnInvalid) {
    const {
      code,
      pos
    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
    this.state.pos = pos;
    return code;
  }
  readString(quote) {
    const {
      str,
      pos,
      curLine,
      lineStart
    } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = pos + 1;
    this.state.lineStart = lineStart;
    this.state.curLine = curLine;
    this.finishToken(133, str);
  }
  readTemplateContinuation() {
    if (!this.match(8)) {
      this.unexpected(null, 8);
    }
    this.state.pos--;
    this.readTemplateToken();
  }
  readTemplateToken() {
    const opening = this.input[this.state.pos];
    const {
      str,
      firstInvalidLoc,
      pos,
      curLine,
      lineStart
    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = pos + 1;
    this.state.lineStart = lineStart;
    this.state.curLine = curLine;
    if (firstInvalidLoc) {
      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
    }
    if (this.input.codePointAt(pos) === 96) {
      this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
    } else {
      this.state.pos++;
      this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
    }
  }
  recordStrictModeErrors(toParseError, {
    at: at2
  }) {
    const index = at2.index;
    if (this.state.strict && !this.state.strictErrors.has(index)) {
      this.raise(toParseError, {
        at: at2
      });
    } else {
      this.state.strictErrors.set(index, [toParseError, at2]);
    }
  }
  readWord1(firstCode) {
    this.state.containsEsc = false;
    let word = "";
    const start = this.state.pos;
    let chunkStart = this.state.pos;
    if (firstCode !== undefined) {
      this.state.pos += firstCode <= 65535 ? 1 : 2;
    }
    while (this.state.pos < this.length) {
      const ch = this.codePointAtPos(this.state.pos);
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 65535 ? 1 : 2;
      } else if (ch === 92) {
        this.state.containsEsc = true;
        word += this.input.slice(chunkStart, this.state.pos);
        const escStart = this.state.curPosition();
        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(Errors.MissingUnicodeEscape, {
            at: this.state.curPosition()
          });
          chunkStart = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const esc = this.readCodePoint(true);
        if (esc !== null) {
          if (!identifierCheck(esc)) {
            this.raise(Errors.EscapedCharNotAnIdentifier, {
              at: escStart
            });
          }
          word += String.fromCodePoint(esc);
        }
        chunkStart = this.state.pos;
      } else {
        break;
      }
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  }
  readWord(firstCode) {
    const word = this.readWord1(firstCode);
    const type = keywords$1.get(word);
    if (type !== undefined) {
      this.finishToken(type, tokenLabelName(type));
    } else {
      this.finishToken(132, word);
    }
  }
  checkKeywordEscapes() {
    const {
      type
    } = this.state;
    if (tokenIsKeyword(type) && this.state.containsEsc) {
      this.raise(Errors.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: tokenLabelName(type)
      });
    }
  }
  raise(toParseError, raiseProperties) {
    const {
      at: at2
    } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
    const loc = at2 instanceof Position ? at2 : at2.loc.start;
    const error = toParseError({
      loc,
      details
    });
    if (!this.options.errorRecovery)
      throw error;
    if (!this.isLookahead)
      this.state.errors.push(error);
    return error;
  }
  raiseOverwrite(toParseError, raiseProperties) {
    const {
      at: at2
    } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
    const loc = at2 instanceof Position ? at2 : at2.loc.start;
    const pos = loc.index;
    const errors2 = this.state.errors;
    for (let i = errors2.length - 1;i >= 0; i--) {
      const error = errors2[i];
      if (error.loc.index === pos) {
        return errors2[i] = toParseError({
          loc,
          details
        });
      }
      if (error.loc.index < pos)
        break;
    }
    return this.raise(toParseError, raiseProperties);
  }
  updateContext(prevType) {}
  unexpected(loc, type) {
    throw this.raise(Errors.UnexpectedToken, {
      expected: type ? tokenLabelName(type) : null,
      at: loc != null ? loc : this.state.startLoc
    });
  }
  expectPlugin(pluginName, loc) {
    if (this.hasPlugin(pluginName)) {
      return true;
    }
    throw this.raise(Errors.MissingPlugin, {
      at: loc != null ? loc : this.state.startLoc,
      missingPlugin: [pluginName]
    });
  }
  expectOnePlugin(pluginNames) {
    if (!pluginNames.some((name3) => this.hasPlugin(name3))) {
      throw this.raise(Errors.MissingOneOfPlugins, {
        at: this.state.startLoc,
        missingPlugin: pluginNames
      });
    }
  }
  errorBuilder(error) {
    return (pos, lineStart, curLine) => {
      this.raise(error, {
        at: buildPosition(pos, lineStart, curLine)
      });
    };
  }
}

class ClassScope {
  constructor() {
    this.privateNames = new Set;
    this.loneAccessors = new Map;
    this.undefinedPrivateNames = new Map;
  }
}

class ClassScopeHandler {
  constructor(parser) {
    this.parser = undefined;
    this.stack = [];
    this.undefinedPrivateNames = new Map;
    this.parser = parser;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new ClassScope);
  }
  exit() {
    const oldClassScope = this.stack.pop();
    const current = this.current();
    for (const [name3, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
      if (current) {
        if (!current.undefinedPrivateNames.has(name3)) {
          current.undefinedPrivateNames.set(name3, loc);
        }
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, {
          at: loc,
          identifierName: name3
        });
      }
    }
  }
  declarePrivateName(name3, elementType, loc) {
    const {
      privateNames,
      loneAccessors,
      undefinedPrivateNames
    } = this.current();
    let redefined = privateNames.has(name3);
    if (elementType & 3) {
      const accessor = redefined && loneAccessors.get(name3);
      if (accessor) {
        const oldStatic = accessor & 4;
        const newStatic = elementType & 4;
        const oldKind = accessor & 3;
        const newKind = elementType & 3;
        redefined = oldKind === newKind || oldStatic !== newStatic;
        if (!redefined)
          loneAccessors.delete(name3);
      } else if (!redefined) {
        loneAccessors.set(name3, elementType);
      }
    }
    if (redefined) {
      this.parser.raise(Errors.PrivateNameRedeclaration, {
        at: loc,
        identifierName: name3
      });
    }
    privateNames.add(name3);
    undefinedPrivateNames.delete(name3);
  }
  usePrivateName(name3, loc) {
    let classScope;
    for (classScope of this.stack) {
      if (classScope.privateNames.has(name3))
        return;
    }
    if (classScope) {
      classScope.undefinedPrivateNames.set(name3, loc);
    } else {
      this.parser.raise(Errors.InvalidPrivateFieldResolution, {
        at: loc,
        identifierName: name3
      });
    }
  }
}

class ExpressionScope {
  constructor(type = 0) {
    this.type = type;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}

class ArrowHeadParsingScope extends ExpressionScope {
  constructor(type) {
    super(type);
    this.declarationErrors = new Map;
  }
  recordDeclarationError(ParsingErrorClass, {
    at: at2
  }) {
    const index = at2.index;
    this.declarationErrors.set(index, [ParsingErrorClass, at2]);
  }
  clearDeclarationError(index) {
    this.declarationErrors.delete(index);
  }
  iterateErrors(iterator) {
    this.declarationErrors.forEach(iterator);
  }
}

class ExpressionScopeHandler {
  constructor(parser) {
    this.parser = undefined;
    this.stack = [new ExpressionScope];
    this.parser = parser;
  }
  enter(scope) {
    this.stack.push(scope);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(toParseError, {
    at: node
  }) {
    const origin = {
      at: node.loc.start
    };
    const {
      stack
    } = this;
    let i = stack.length - 1;
    let scope = stack[i];
    while (!scope.isCertainlyParameterDeclaration()) {
      if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(toParseError, origin);
      } else {
        return;
      }
      scope = stack[--i];
    }
    this.parser.raise(toParseError, origin);
  }
  recordArrowParameterBindingError(error, {
    at: node
  }) {
    const {
      stack
    } = this;
    const scope = stack[stack.length - 1];
    const origin = {
      at: node.loc.start
    };
    if (scope.isCertainlyParameterDeclaration()) {
      this.parser.raise(error, origin);
    } else if (scope.canBeArrowParameterDeclaration()) {
      scope.recordDeclarationError(error, origin);
    } else {
      return;
    }
  }
  recordAsyncArrowParametersError({
    at: at2
  }) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
    let scope = stack[i];
    while (scope.canBeArrowParameterDeclaration()) {
      if (scope.type === 2) {
        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
          at: at2
        });
      }
      scope = stack[--i];
    }
  }
  validateAsPattern() {
    const {
      stack
    } = this;
    const currentScope = stack[stack.length - 1];
    if (!currentScope.canBeArrowParameterDeclaration())
      return;
    currentScope.iterateErrors(([toParseError, loc]) => {
      this.parser.raise(toParseError, {
        at: loc
      });
      let i = stack.length - 2;
      let scope = stack[i];
      while (scope.canBeArrowParameterDeclaration()) {
        scope.clearDeclarationError(loc.index);
        scope = stack[--i];
      }
    });
  }
}
function newParameterDeclarationScope() {
  return new ExpressionScope(3);
}
function newArrowHeadScope() {
  return new ArrowHeadParsingScope(1);
}
function newAsyncArrowScope() {
  return new ArrowHeadParsingScope(2);
}
function newExpressionScope() {
  return new ExpressionScope;
}
var PARAM = 0;
var PARAM_YIELD = 1;
var PARAM_AWAIT = 2;
var PARAM_RETURN = 4;
var PARAM_IN = 8;

class ProductionParameterHandler {
  constructor() {
    this.stacks = [];
  }
  enter(flags) {
    this.stacks.push(flags);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & PARAM_AWAIT) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & PARAM_YIELD) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & PARAM_RETURN) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & PARAM_IN) > 0;
  }
}
function functionFlags(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}

class UtilParser extends Tokenizer3 {
  addExtra(node, key, value, enumerable = true) {
    if (!node)
      return;
    const extra = node.extra = node.extra || {};
    if (enumerable) {
      extra[key] = value;
    } else {
      Object.defineProperty(extra, key, {
        enumerable,
        value
      });
    }
  }
  isContextual(token2) {
    return this.state.type === token2 && !this.state.containsEsc;
  }
  isUnparsedContextual(nameStart, name3) {
    const nameEnd = nameStart + name3.length;
    if (this.input.slice(nameStart, nameEnd) === name3) {
      const nextCh = this.input.charCodeAt(nameEnd);
      return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
    }
    return false;
  }
  isLookaheadContextual(name3) {
    const next = this.nextTokenStart();
    return this.isUnparsedContextual(next, name3);
  }
  eatContextual(token2) {
    if (this.isContextual(token2)) {
      this.next();
      return true;
    }
    return false;
  }
  expectContextual(token2, toParseError) {
    if (!this.eatContextual(token2)) {
      if (toParseError != null) {
        throw this.raise(toParseError, {
          at: this.state.startLoc
        });
      }
      this.unexpected(null, token2);
    }
  }
  canInsertSemicolon() {
    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
    return skipWhiteSpaceToLineBreak.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(allowAsi = true) {
    if (allowAsi ? this.isLineTerminator() : this.eat(13))
      return;
    this.raise(Errors.MissingSemicolon, {
      at: this.state.lastTokEndLoc
    });
  }
  expect(type, loc) {
    this.eat(type) || this.unexpected(loc, type);
  }
  tryParse(fn2, oldState = this.state.clone()) {
    const abortSignal = {
      node: null
    };
    try {
      const node = fn2((node2 = null) => {
        abortSignal.node = node2;
        throw abortSignal;
      });
      if (this.state.errors.length > oldState.errors.length) {
        const failState = this.state;
        this.state = oldState;
        this.state.tokensLength = failState.tokensLength;
        return {
          node,
          error: failState.errors[oldState.errors.length],
          thrown: false,
          aborted: false,
          failState
        };
      }
      return {
        node,
        error: null,
        thrown: false,
        aborted: false,
        failState: null
      };
    } catch (error) {
      const failState = this.state;
      this.state = oldState;
      if (error instanceof SyntaxError) {
        return {
          node: null,
          error,
          thrown: true,
          aborted: false,
          failState
        };
      }
      if (error === abortSignal) {
        return {
          node: abortSignal.node,
          error: null,
          thrown: false,
          aborted: true,
          failState
        };
      }
      throw error;
    }
  }
  checkExpressionErrors(refExpressionErrors, andThrow) {
    if (!refExpressionErrors)
      return false;
    const {
      shorthandAssignLoc,
      doubleProtoLoc,
      privateKeyLoc,
      optionalParametersLoc
    } = refExpressionErrors;
    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
    if (!andThrow) {
      return hasErrors;
    }
    if (shorthandAssignLoc != null) {
      this.raise(Errors.InvalidCoverInitializedName, {
        at: shorthandAssignLoc
      });
    }
    if (doubleProtoLoc != null) {
      this.raise(Errors.DuplicateProto, {
        at: doubleProtoLoc
      });
    }
    if (privateKeyLoc != null) {
      this.raise(Errors.UnexpectedPrivateField, {
        at: privateKeyLoc
      });
    }
    if (optionalParametersLoc != null) {
      this.unexpected(optionalParametersLoc);
    }
  }
  isLiteralPropertyName() {
    return tokenIsLiteralPropertyName(this.state.type);
  }
  isPrivateName(node) {
    return node.type === "PrivateName";
  }
  getPrivateNameSV(node) {
    return node.id.name;
  }
  hasPropertyAsPrivateName(node) {
    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
  }
  isObjectProperty(node) {
    return node.type === "ObjectProperty";
  }
  isObjectMethod(node) {
    return node.type === "ObjectMethod";
  }
  initializeScopes(inModule = this.options.sourceType === "module") {
    const oldLabels = this.state.labels;
    this.state.labels = [];
    const oldExportedIdentifiers = this.exportedIdentifiers;
    this.exportedIdentifiers = new Set;
    const oldInModule = this.inModule;
    this.inModule = inModule;
    const oldScope = this.scope;
    const ScopeHandler2 = this.getScopeHandler();
    this.scope = new ScopeHandler2(this, inModule);
    const oldProdParam = this.prodParam;
    this.prodParam = new ProductionParameterHandler;
    const oldClassScope = this.classScope;
    this.classScope = new ClassScopeHandler(this);
    const oldExpressionScope = this.expressionScope;
    this.expressionScope = new ExpressionScopeHandler(this);
    return () => {
      this.state.labels = oldLabels;
      this.exportedIdentifiers = oldExportedIdentifiers;
      this.inModule = oldInModule;
      this.scope = oldScope;
      this.prodParam = oldProdParam;
      this.classScope = oldClassScope;
      this.expressionScope = oldExpressionScope;
    };
  }
  enterInitialScopes() {
    let paramFlags = PARAM;
    if (this.inModule) {
      paramFlags |= PARAM_AWAIT;
    }
    this.scope.enter(1);
    this.prodParam.enter(paramFlags);
  }
  checkDestructuringPrivate(refExpressionErrors) {
    const {
      privateKeyLoc
    } = refExpressionErrors;
    if (privateKeyLoc !== null) {
      this.expectPlugin("destructuringPrivate", privateKeyLoc);
    }
  }
}

class ExpressionErrors {
  constructor() {
    this.shorthandAssignLoc = null;
    this.doubleProtoLoc = null;
    this.privateKeyLoc = null;
    this.optionalParametersLoc = null;
  }
}
var Node$5 = class Node2 {
  constructor(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser != null && parser.options.ranges)
      this.range = [pos, 0];
    if (parser != null && parser.filename)
      this.loc.filename = parser.filename;
  }
};
var NodePrototype = Node$5.prototype;
{
  NodePrototype.__clone = function() {
    const newNode = new Node$5(undefined, this.start, this.loc.start);
    const keys = Object.keys(this);
    for (let i = 0, length = keys.length;i < length; i++) {
      const key = keys[i];
      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
        newNode[key] = this[key];
      }
    }
    return newNode;
  };
}
function clonePlaceholder(node) {
  return cloneIdentifier(node);
}
function cloneIdentifier(node) {
  const {
    type,
    start,
    end,
    loc,
    range: range2,
    extra,
    name: name3
  } = node;
  const cloned = Object.create(NodePrototype);
  cloned.type = type;
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range2;
  cloned.extra = extra;
  cloned.name = name3;
  if (type === "Placeholder") {
    cloned.expectedNode = node.expectedNode;
  }
  return cloned;
}
function cloneStringLiteral(node) {
  const {
    type,
    start,
    end,
    loc,
    range: range2,
    extra
  } = node;
  if (type === "Placeholder") {
    return clonePlaceholder(node);
  }
  const cloned = Object.create(NodePrototype);
  cloned.type = type;
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range2;
  if (node.raw !== undefined) {
    cloned.raw = node.raw;
  } else {
    cloned.extra = extra;
  }
  cloned.value = node.value;
  return cloned;
}

class NodeUtils extends UtilParser {
  startNode() {
    return new Node$5(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(loc) {
    return new Node$5(this, loc.index, loc);
  }
  startNodeAtNode(type) {
    return this.startNodeAt(type.loc.start);
  }
  finishNode(node, type) {
    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
  }
  finishNodeAt(node, type, endLoc) {
    node.type = type;
    node.end = endLoc.index;
    node.loc.end = endLoc;
    if (this.options.ranges)
      node.range[1] = endLoc.index;
    if (this.options.attachComment)
      this.processComment(node);
    return node;
  }
  resetStartLocation(node, startLoc) {
    node.start = startLoc.index;
    node.loc.start = startLoc;
    if (this.options.ranges)
      node.range[0] = startLoc.index;
  }
  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
    node.end = endLoc.index;
    node.loc.end = endLoc;
    if (this.options.ranges)
      node.range[1] = endLoc.index;
  }
  resetStartLocationFromNode(node, locationNode) {
    this.resetStartLocation(node, locationNode.loc.start);
  }
}
var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
var FlowErrors = ParseErrorEnum`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType
  }) => `Cannot overwrite reserved type ${reservedType}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName,
    enumName
  }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
  EnumDuplicateMemberName: ({
    memberName,
    enumName
  }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
  EnumInconsistentMemberValues: ({
    enumName
  }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType,
    enumName
  }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName,
    memberName,
    explicitType
  }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName,
    memberName
  }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName,
    memberName
  }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
  EnumInvalidMemberName: ({
    enumName,
    memberName,
    suggestion
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName,
    memberName
  }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
  EnumStringMemberInconsistentlyInitialized: ({
    enumName
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType
  }) => `Unexpected reserved type ${reservedType}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind,
    suggestion
  }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}
function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}
var exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function partition2(list, test) {
  const list1 = [];
  const list2 = [];
  for (let i = 0;i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }
  return [list1, list2];
}
var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (superClass) => class FlowParserMixin extends superClass {
  constructor(...args) {
    super(...args);
    this.flowPragma = undefined;
  }
  getScopeHandler() {
    return FlowScopeHandler;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(type, val) {
    if (type !== 133 && type !== 13 && type !== 28) {
      if (this.flowPragma === undefined) {
        this.flowPragma = null;
      }
    }
    super.finishToken(type, val);
  }
  addComment(comment) {
    if (this.flowPragma === undefined) {
      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
      if (!matches)
        ;
      else if (matches[1] === "flow") {
        this.flowPragma = "flow";
      } else if (matches[1] === "noflow") {
        this.flowPragma = "noflow";
      } else {
        throw new Error("Unexpected flow pragma");
      }
    }
    super.addComment(comment);
  }
  flowParseTypeInitialiser(tok) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(tok || 14);
    const type = this.flowParseType();
    this.state.inType = oldInType;
    return type;
  }
  flowParsePredicate() {
    const node = this.startNode();
    const moduloLoc = this.state.startLoc;
    this.next();
    this.expectContextual(110);
    if (this.state.lastTokStart > moduloLoc.index + 1) {
      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
        at: moduloLoc
      });
    }
    if (this.eat(10)) {
      node.value = super.parseExpression();
      this.expect(11);
      return this.finishNode(node, "DeclaredPredicate");
    } else {
      return this.finishNode(node, "InferredPredicate");
    }
  }
  flowParseTypeAndPredicateInitialiser() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(14);
    let type = null;
    let predicate = null;
    if (this.match(54)) {
      this.state.inType = oldInType;
      predicate = this.flowParsePredicate();
    } else {
      type = this.flowParseType();
      this.state.inType = oldInType;
      if (this.match(54)) {
        predicate = this.flowParsePredicate();
      }
    }
    return [type, predicate];
  }
  flowParseDeclareClass(node) {
    this.next();
    this.flowParseInterfaceish(node, true);
    return this.finishNode(node, "DeclareClass");
  }
  flowParseDeclareFunction(node) {
    this.next();
    const id = node.id = this.parseIdentifier();
    const typeNode = this.startNode();
    const typeContainer = this.startNode();
    if (this.match(47)) {
      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }
    this.expect(10);
    const tmp = this.flowParseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    typeNode.this = tmp._this;
    this.expect(11);
    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
    this.resetEndLocation(id);
    this.semicolon();
    this.scope.declareName(node.id.name, 2048, node.id.loc.start);
    return this.finishNode(node, "DeclareFunction");
  }
  flowParseDeclare(node, insideModule) {
    if (this.match(80)) {
      return this.flowParseDeclareClass(node);
    } else if (this.match(68)) {
      return this.flowParseDeclareFunction(node);
    } else if (this.match(74)) {
      return this.flowParseDeclareVariable(node);
    } else if (this.eatContextual(127)) {
      if (this.match(16)) {
        return this.flowParseDeclareModuleExports(node);
      } else {
        if (insideModule) {
          this.raise(FlowErrors.NestedDeclareModule, {
            at: this.state.lastTokStartLoc
          });
        }
        return this.flowParseDeclareModule(node);
      }
    } else if (this.isContextual(130)) {
      return this.flowParseDeclareTypeAlias(node);
    } else if (this.isContextual(131)) {
      return this.flowParseDeclareOpaqueType(node);
    } else if (this.isContextual(129)) {
      return this.flowParseDeclareInterface(node);
    } else if (this.match(82)) {
      return this.flowParseDeclareExportDeclaration(node, insideModule);
    } else {
      this.unexpected();
    }
  }
  flowParseDeclareVariable(node) {
    this.next();
    node.id = this.flowParseTypeAnnotatableIdentifier(true);
    this.scope.declareName(node.id.name, 5, node.id.loc.start);
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  }
  flowParseDeclareModule(node) {
    this.scope.enter(0);
    if (this.match(133)) {
      node.id = super.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }
    const bodyNode = node.body = this.startNode();
    const body = bodyNode.body = [];
    this.expect(5);
    while (!this.match(8)) {
      let bodyNode2 = this.startNode();
      if (this.match(83)) {
        this.next();
        if (!this.isContextual(130) && !this.match(87)) {
          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
            at: this.state.lastTokStartLoc
          });
        }
        super.parseImport(bodyNode2);
      } else {
        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
        bodyNode2 = this.flowParseDeclare(bodyNode2, true);
      }
      body.push(bodyNode2);
    }
    this.scope.exit();
    this.expect(8);
    this.finishNode(bodyNode, "BlockStatement");
    let kind = null;
    let hasModuleExport = false;
    body.forEach((bodyElement) => {
      if (isEsModuleType(bodyElement)) {
        if (kind === "CommonJS") {
          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
            at: bodyElement
          });
        }
        kind = "ES";
      } else if (bodyElement.type === "DeclareModuleExports") {
        if (hasModuleExport) {
          this.raise(FlowErrors.DuplicateDeclareModuleExports, {
            at: bodyElement
          });
        }
        if (kind === "ES") {
          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
            at: bodyElement
          });
        }
        kind = "CommonJS";
        hasModuleExport = true;
      }
    });
    node.kind = kind || "CommonJS";
    return this.finishNode(node, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(node, insideModule) {
    this.expect(82);
    if (this.eat(65)) {
      if (this.match(68) || this.match(80)) {
        node.declaration = this.flowParseDeclare(this.startNode());
      } else {
        node.declaration = this.flowParseType();
        this.semicolon();
      }
      node.default = true;
      return this.finishNode(node, "DeclareExportDeclaration");
    } else {
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
        const label = this.state.value;
        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
          at: this.state.startLoc,
          unsupportedExportKind: label,
          suggestion: exportSuggestions[label]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
        node.declaration = this.flowParseDeclare(this.startNode());
        node.default = false;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
        node = this.parseExport(node, null);
        if (node.type === "ExportNamedDeclaration") {
          node.type = "ExportDeclaration";
          node.default = false;
          delete node.exportKind;
        }
        node.type = "Declare" + node.type;
        return node;
      }
    }
    this.unexpected();
  }
  flowParseDeclareModuleExports(node) {
    this.next();
    this.expectContextual(111);
    node.typeAnnotation = this.flowParseTypeAnnotation();
    this.semicolon();
    return this.finishNode(node, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(node) {
    this.next();
    const finished = this.flowParseTypeAlias(node);
    finished.type = "DeclareTypeAlias";
    return finished;
  }
  flowParseDeclareOpaqueType(node) {
    this.next();
    const finished = this.flowParseOpaqueType(node, true);
    finished.type = "DeclareOpaqueType";
    return finished;
  }
  flowParseDeclareInterface(node) {
    this.next();
    this.flowParseInterfaceish(node, false);
    return this.finishNode(node, "DeclareInterface");
  }
  flowParseInterfaceish(node, isClass) {
    node.id = this.flowParseRestrictedIdentifier(!isClass, true);
    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }
    node.extends = [];
    if (this.eat(81)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (!isClass && this.eat(12));
    }
    if (isClass) {
      node.implements = [];
      node.mixins = [];
      if (this.eatContextual(117)) {
        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      if (this.eatContextual(113)) {
        do {
          node.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
    }
    node.body = this.flowParseObjectType({
      allowStatic: isClass,
      allowExact: false,
      allowSpread: false,
      allowProto: isClass,
      allowInexact: false
    });
  }
  flowParseInterfaceExtends() {
    const node = this.startNode();
    node.id = this.flowParseQualifiedTypeIdentifier();
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }
    return this.finishNode(node, "InterfaceExtends");
  }
  flowParseInterface(node) {
    this.flowParseInterfaceish(node, false);
    return this.finishNode(node, "InterfaceDeclaration");
  }
  checkNotUnderscore(word) {
    if (word === "_") {
      this.raise(FlowErrors.UnexpectedReservedUnderscore, {
        at: this.state.startLoc
      });
    }
  }
  checkReservedType(word, startLoc, declaration) {
    if (!reservedTypes.has(word))
      return;
    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
      at: startLoc,
      reservedType: word
    });
  }
  flowParseRestrictedIdentifier(liberal, declaration) {
    this.checkReservedType(this.state.value, this.state.startLoc, declaration);
    return this.parseIdentifier(liberal);
  }
  flowParseTypeAlias(node) {
    node.id = this.flowParseRestrictedIdentifier(false, true);
    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }
    node.right = this.flowParseTypeInitialiser(29);
    this.semicolon();
    return this.finishNode(node, "TypeAlias");
  }
  flowParseOpaqueType(node, declare) {
    this.expectContextual(130);
    node.id = this.flowParseRestrictedIdentifier(true, true);
    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }
    node.supertype = null;
    if (this.match(14)) {
      node.supertype = this.flowParseTypeInitialiser(14);
    }
    node.impltype = null;
    if (!declare) {
      node.impltype = this.flowParseTypeInitialiser(29);
    }
    this.semicolon();
    return this.finishNode(node, "OpaqueType");
  }
  flowParseTypeParameter(requireDefault = false) {
    const nodeStartLoc = this.state.startLoc;
    const node = this.startNode();
    const variance = this.flowParseVariance();
    const ident2 = this.flowParseTypeAnnotatableIdentifier();
    node.name = ident2.name;
    node.variance = variance;
    node.bound = ident2.typeAnnotation;
    if (this.match(29)) {
      this.eat(29);
      node.default = this.flowParseType();
    } else {
      if (requireDefault) {
        this.raise(FlowErrors.MissingTypeParamDefault, {
          at: nodeStartLoc
        });
      }
    }
    return this.finishNode(node, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const oldInType = this.state.inType;
    const node = this.startNode();
    node.params = [];
    this.state.inType = true;
    if (this.match(47) || this.match(142)) {
      this.next();
    } else {
      this.unexpected();
    }
    let defaultRequired = false;
    do {
      const typeParameter = this.flowParseTypeParameter(defaultRequired);
      node.params.push(typeParameter);
      if (typeParameter.default) {
        defaultRequired = true;
      }
      if (!this.match(48)) {
        this.expect(12);
      }
    } while (!this.match(48));
    this.expect(48);
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expect(47);
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    this.state.noAnonFunctionType = false;
    while (!this.match(48)) {
      node.params.push(this.flowParseType());
      if (!this.match(48)) {
        this.expect(12);
      }
    }
    this.state.noAnonFunctionType = oldNoAnonFunctionType;
    this.expect(48);
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expect(47);
    while (!this.match(48)) {
      node.params.push(this.flowParseTypeOrImplicitInstantiation());
      if (!this.match(48)) {
        this.expect(12);
      }
    }
    this.expect(48);
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const node = this.startNode();
    this.expectContextual(129);
    node.extends = [];
    if (this.eat(81)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(12));
    }
    node.body = this.flowParseObjectType({
      allowStatic: false,
      allowExact: false,
      allowSpread: false,
      allowProto: false,
      allowInexact: false
    });
    return this.finishNode(node, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
  }
  flowParseObjectTypeIndexer(node, isStatic, variance) {
    node.static = isStatic;
    if (this.lookahead().type === 14) {
      node.id = this.flowParseObjectPropertyKey();
      node.key = this.flowParseTypeInitialiser();
    } else {
      node.id = null;
      node.key = this.flowParseType();
    }
    this.expect(3);
    node.value = this.flowParseTypeInitialiser();
    node.variance = variance;
    return this.finishNode(node, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(node, isStatic) {
    node.static = isStatic;
    node.id = this.flowParseObjectPropertyKey();
    this.expect(3);
    this.expect(3);
    if (this.match(47) || this.match(10)) {
      node.method = true;
      node.optional = false;
      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
    } else {
      node.method = false;
      if (this.eat(17)) {
        node.optional = true;
      }
      node.value = this.flowParseTypeInitialiser();
    }
    return this.finishNode(node, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;
    node.this = null;
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    this.expect(10);
    if (this.match(78)) {
      node.this = this.flowParseFunctionTypeParam(true);
      node.this.name = null;
      if (!this.match(11)) {
        this.expect(12);
      }
    }
    while (!this.match(11) && !this.match(21)) {
      node.params.push(this.flowParseFunctionTypeParam(false));
      if (!this.match(11)) {
        this.expect(12);
      }
    }
    if (this.eat(21)) {
      node.rest = this.flowParseFunctionTypeParam(false);
    }
    this.expect(11);
    node.returnType = this.flowParseTypeInitialiser();
    return this.finishNode(node, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(node, isStatic) {
    const valueNode = this.startNode();
    node.static = isStatic;
    node.value = this.flowParseObjectTypeMethodish(valueNode);
    return this.finishNode(node, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic,
    allowExact,
    allowSpread,
    allowProto,
    allowInexact
  }) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const nodeStart = this.startNode();
    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];
    nodeStart.internalSlots = [];
    let endDelim;
    let exact;
    let inexact = false;
    if (allowExact && this.match(6)) {
      this.expect(6);
      endDelim = 9;
      exact = true;
    } else {
      this.expect(5);
      endDelim = 8;
      exact = false;
    }
    nodeStart.exact = exact;
    while (!this.match(endDelim)) {
      let isStatic = false;
      let protoStartLoc = null;
      let inexactStartLoc = null;
      const node = this.startNode();
      if (allowProto && this.isContextual(118)) {
        const lookahead = this.lookahead();
        if (lookahead.type !== 14 && lookahead.type !== 17) {
          this.next();
          protoStartLoc = this.state.startLoc;
          allowStatic = false;
        }
      }
      if (allowStatic && this.isContextual(106)) {
        const lookahead = this.lookahead();
        if (lookahead.type !== 14 && lookahead.type !== 17) {
          this.next();
          isStatic = true;
        }
      }
      const variance = this.flowParseVariance();
      if (this.eat(0)) {
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (this.eat(0)) {
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
        } else {
          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
        }
      } else if (this.match(10) || this.match(47)) {
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (variance) {
          this.unexpected(variance.loc.start);
        }
        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
      } else {
        let kind = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          const lookahead = this.lookahead();
          if (tokenIsLiteralPropertyName(lookahead.type)) {
            kind = this.state.value;
            this.next();
          }
        }
        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
        if (propOrInexact === null) {
          inexact = true;
          inexactStartLoc = this.state.lastTokStartLoc;
        } else {
          nodeStart.properties.push(propOrInexact);
        }
      }
      this.flowObjectTypeSemicolon();
      if (inexactStartLoc && !this.match(8) && !this.match(9)) {
        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
          at: inexactStartLoc
        });
      }
    }
    this.expect(endDelim);
    if (allowSpread) {
      nodeStart.inexact = inexact;
    }
    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }
  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
    if (this.eat(21)) {
      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
      if (isInexactToken) {
        if (!allowSpread) {
          this.raise(FlowErrors.InexactInsideNonObject, {
            at: this.state.lastTokStartLoc
          });
        } else if (!allowInexact) {
          this.raise(FlowErrors.InexactInsideExact, {
            at: this.state.lastTokStartLoc
          });
        }
        if (variance) {
          this.raise(FlowErrors.InexactVariance, {
            at: variance
          });
        }
        return null;
      }
      if (!allowSpread) {
        this.raise(FlowErrors.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        });
      }
      if (protoStartLoc != null) {
        this.unexpected(protoStartLoc);
      }
      if (variance) {
        this.raise(FlowErrors.SpreadVariance, {
          at: variance
        });
      }
      node.argument = this.flowParseType();
      return this.finishNode(node, "ObjectTypeSpreadProperty");
    } else {
      node.key = this.flowParseObjectPropertyKey();
      node.static = isStatic;
      node.proto = protoStartLoc != null;
      node.kind = kind;
      let optional = false;
      if (this.match(47) || this.match(10)) {
        node.method = true;
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (variance) {
          this.unexpected(variance.loc.start);
        }
        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        if (kind === "get" || kind === "set") {
          this.flowCheckGetterSetterParams(node);
        }
        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            at: node.value.this
          });
        }
      } else {
        if (kind !== "init")
          this.unexpected();
        node.method = false;
        if (this.eat(17)) {
          optional = true;
        }
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
      }
      node.optional = optional;
      return this.finishNode(node, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(property) {
    const paramCount = property.kind === "get" ? 0 : 1;
    const length = property.value.params.length + (property.value.rest ? 1 : 0);
    if (property.value.this) {
      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
        at: property.value.this
      });
    }
    if (length !== paramCount) {
      this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
        at: property
      });
    }
    if (property.kind === "set" && property.value.rest) {
      this.raise(Errors.BadSetterRestParameter, {
        at: property
      });
    }
  }
  flowObjectTypeSemicolon() {
    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
      this.unexpected();
    }
  }
  flowParseQualifiedTypeIdentifier(startLoc, id) {
    var _startLoc;
    (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
    let node = id || this.flowParseRestrictedIdentifier(true);
    while (this.eat(16)) {
      const node2 = this.startNodeAt(startLoc);
      node2.qualification = node;
      node2.id = this.flowParseRestrictedIdentifier(true);
      node = this.finishNode(node2, "QualifiedTypeIdentifier");
    }
    return node;
  }
  flowParseGenericType(startLoc, id) {
    const node = this.startNodeAt(startLoc);
    node.typeParameters = null;
    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    }
    return this.finishNode(node, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const node = this.startNode();
    this.expect(87);
    node.argument = this.flowParsePrimaryType();
    return this.finishNode(node, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const node = this.startNode();
    node.types = [];
    this.expect(0);
    while (this.state.pos < this.length && !this.match(3)) {
      node.types.push(this.flowParseType());
      if (this.match(3))
        break;
      this.expect(12);
    }
    this.expect(3);
    return this.finishNode(node, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(first) {
    let name3 = null;
    let optional = false;
    let typeAnnotation = null;
    const node = this.startNode();
    const lh = this.lookahead();
    const isThis = this.state.type === 78;
    if (lh.type === 14 || lh.type === 17) {
      if (isThis && !first) {
        this.raise(FlowErrors.ThisParamMustBeFirst, {
          at: node
        });
      }
      name3 = this.parseIdentifier(isThis);
      if (this.eat(17)) {
        optional = true;
        if (isThis) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, {
            at: node
          });
        }
      }
      typeAnnotation = this.flowParseTypeInitialiser();
    } else {
      typeAnnotation = this.flowParseType();
    }
    node.name = name3;
    node.optional = optional;
    node.typeAnnotation = typeAnnotation;
    return this.finishNode(node, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(type) {
    const node = this.startNodeAt(type.loc.start);
    node.name = null;
    node.optional = false;
    node.typeAnnotation = type;
    return this.finishNode(node, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(params = []) {
    let rest = null;
    let _this = null;
    if (this.match(78)) {
      _this = this.flowParseFunctionTypeParam(true);
      _this.name = null;
      if (!this.match(11)) {
        this.expect(12);
      }
    }
    while (!this.match(11) && !this.match(21)) {
      params.push(this.flowParseFunctionTypeParam(false));
      if (!this.match(11)) {
        this.expect(12);
      }
    }
    if (this.eat(21)) {
      rest = this.flowParseFunctionTypeParam(false);
    }
    return {
      params,
      rest,
      _this
    };
  }
  flowIdentToTypeAnnotation(startLoc, node, id) {
    switch (id.name) {
      case "any":
        return this.finishNode(node, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(node, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(node, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(node, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(node, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(node, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(node, "SymbolTypeAnnotation");
      default:
        this.checkNotUnderscore(id.name);
        return this.flowParseGenericType(startLoc, id);
    }
  }
  flowParsePrimaryType() {
    const startLoc = this.state.startLoc;
    const node = this.startNode();
    let tmp;
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: true,
          allowProto: false,
          allowInexact: true
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: true,
          allowSpread: true,
          allowProto: false,
          allowInexact: false
        });
      case 0:
        this.state.noAnonFunctionType = false;
        type = this.flowParseTupleType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        return type;
      case 47:
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(10);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        node.this = tmp._this;
        this.expect(11);
        this.expect(19);
        node.returnType = this.flowParseType();
        return this.finishNode(node, "FunctionTypeAnnotation");
      case 10:
        this.next();
        if (!this.match(11) && !this.match(21)) {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            const token2 = this.lookahead().type;
            isGroupedType = token2 !== 17 && token2 !== 14;
          } else {
            isGroupedType = true;
          }
        }
        if (isGroupedType) {
          this.state.noAnonFunctionType = false;
          type = this.flowParseType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
            this.expect(11);
            return type;
          } else {
            this.eat(12);
          }
        }
        if (type) {
          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
        } else {
          tmp = this.flowParseFunctionTypeParams();
        }
        node.params = tmp.params;
        node.rest = tmp.rest;
        node.this = tmp._this;
        this.expect(11);
        this.expect(19);
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      case 133:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        node.value = this.match(85);
        this.next();
        return this.finishNode(node, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          this.next();
          if (this.match(134)) {
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
          }
          if (this.match(135)) {
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
          }
          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
            at: this.state.startLoc
          });
        }
        this.unexpected();
        return;
      case 134:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 135:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        this.next();
        return this.finishNode(node, "VoidTypeAnnotation");
      case 84:
        this.next();
        return this.finishNode(node, "NullLiteralTypeAnnotation");
      case 78:
        this.next();
        return this.finishNode(node, "ThisTypeAnnotation");
      case 55:
        this.next();
        return this.finishNode(node, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (tokenIsKeyword(this.state.type)) {
          const label = tokenLabelName(this.state.type);
          this.next();
          return super.createIdentifier(node, label);
        } else if (tokenIsIdentifier(this.state.type)) {
          if (this.isContextual(129)) {
            return this.flowParseInterfaceType();
          }
          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
        }
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const startLoc = this.state.startLoc;
    let type = this.flowParsePrimaryType();
    let seenOptionalIndexedAccess = false;
    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startLoc);
      const optional = this.eat(18);
      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
      this.expect(0);
      if (!optional && this.match(3)) {
        node.elementType = type;
        this.next();
        type = this.finishNode(node, "ArrayTypeAnnotation");
      } else {
        node.objectType = type;
        node.indexType = this.flowParseType();
        this.expect(3);
        if (seenOptionalIndexedAccess) {
          node.optional = optional;
          type = this.finishNode(node, "OptionalIndexedAccessType");
        } else {
          type = this.finishNode(node, "IndexedAccessType");
        }
      }
    }
    return type;
  }
  flowParsePrefixType() {
    const node = this.startNode();
    if (this.eat(17)) {
      node.typeAnnotation = this.flowParsePrefixType();
      return this.finishNode(node, "NullableTypeAnnotation");
    } else {
      return this.flowParsePostfixType();
    }
  }
  flowParseAnonFunctionWithoutParens() {
    const param = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const node = this.startNodeAt(param.loc.start);
      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
      node.rest = null;
      node.this = null;
      node.returnType = this.flowParseType();
      node.typeParameters = null;
      return this.finishNode(node, "FunctionTypeAnnotation");
    }
    return param;
  }
  flowParseIntersectionType() {
    const node = this.startNode();
    this.eat(45);
    const type = this.flowParseAnonFunctionWithoutParens();
    node.types = [type];
    while (this.eat(45)) {
      node.types.push(this.flowParseAnonFunctionWithoutParens());
    }
    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const node = this.startNode();
    this.eat(43);
    const type = this.flowParseIntersectionType();
    node.types = [type];
    while (this.eat(43)) {
      node.types.push(this.flowParseIntersectionType());
    }
    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
  }
  flowParseType() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const type = this.flowParseUnionType();
    this.state.inType = oldInType;
    return type;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      const startLoc = this.state.startLoc;
      const node = this.parseIdentifier();
      return this.flowParseGenericType(startLoc, node);
    } else {
      return this.flowParseType();
    }
  }
  flowParseTypeAnnotation() {
    const node = this.startNode();
    node.typeAnnotation = this.flowParseTypeInitialiser();
    return this.finishNode(node, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
    const ident2 = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    if (this.match(14)) {
      ident2.typeAnnotation = this.flowParseTypeAnnotation();
      this.resetEndLocation(ident2);
    }
    return ident2;
  }
  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
    return node.expression;
  }
  flowParseVariance() {
    let variance = null;
    if (this.match(53)) {
      variance = this.startNode();
      if (this.state.value === "+") {
        variance.kind = "plus";
      } else {
        variance.kind = "minus";
      }
      this.next();
      return this.finishNode(variance, "Variance");
    }
    return variance;
  }
  parseFunctionBody(node, allowExpressionBody, isMethod = false) {
    if (allowExpressionBody) {
      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
      return;
    }
    super.parseFunctionBody(node, false, isMethod);
  }
  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(14)) {
      const typeNode = this.startNode();
      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(node, type, isMethod);
  }
  parseStatementLike(flags) {
    if (this.state.strict && this.isContextual(129)) {
      const lookahead = this.lookahead();
      if (tokenIsKeywordOrIdentifier(lookahead.type)) {
        const node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      }
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      const node = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(node);
    }
    const stmt = super.parseStatementLike(flags);
    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
      this.flowPragma = null;
    }
    return stmt;
  }
  parseExpressionStatement(node, expr, decorators) {
    if (expr.type === "Identifier") {
      if (expr.name === "declare") {
        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
          return this.flowParseDeclare(node);
        }
      } else if (tokenIsIdentifier(this.state.type)) {
        if (expr.name === "interface") {
          return this.flowParseInterface(node);
        } else if (expr.name === "type") {
          return this.flowParseTypeAlias(node);
        } else if (expr.name === "opaque") {
          return this.flowParseOpaqueType(node, false);
        }
      }
    }
    return super.parseExpressionStatement(node, expr, decorators);
  }
  shouldParseExportDeclaration() {
    const {
      type
    } = this.state;
    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
      return !this.state.containsEsc;
    }
    return super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type
    } = this.state;
    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
      return this.state.containsEsc;
    }
    return super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(126)) {
      const node = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(node);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(expr, startLoc, refExpressionErrors) {
    if (!this.match(17))
      return expr;
    if (this.state.maybeInArrowParameters) {
      const nextCh = this.lookaheadCharCode();
      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
        this.setOptionalParametersError(refExpressionErrors);
        return expr;
      }
    }
    this.expect(17);
    const state = this.state.clone();
    const originalNoArrowAt = this.state.noArrowAt;
    const node = this.startNodeAt(startLoc);
    let {
      consequent,
      failed
    } = this.tryParseConditionalConsequent();
    let [valid, invalid] = this.getArrowLikeExpressions(consequent);
    if (failed || invalid.length > 0) {
      const noArrowAt = [...originalNoArrowAt];
      if (invalid.length > 0) {
        this.state = state;
        this.state.noArrowAt = noArrowAt;
        for (let i = 0;i < invalid.length; i++) {
          noArrowAt.push(invalid[i].start);
        }
        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
        [valid, invalid] = this.getArrowLikeExpressions(consequent);
      }
      if (failed && valid.length > 1) {
        this.raise(FlowErrors.AmbiguousConditionalArrow, {
          at: state.startLoc
        });
      }
      if (failed && valid.length === 1) {
        this.state = state;
        noArrowAt.push(valid[0].start);
        this.state.noArrowAt = noArrowAt;
        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
      }
    }
    this.getArrowLikeExpressions(consequent, true);
    this.state.noArrowAt = originalNoArrowAt;
    this.expect(14);
    node.test = expr;
    node.consequent = consequent;
    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));
    return this.finishNode(node, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const consequent = this.parseMaybeAssignAllowIn();
    const failed = !this.match(14);
    this.state.noArrowParamsConversionAt.pop();
    return {
      consequent,
      failed
    };
  }
  getArrowLikeExpressions(node, disallowInvalid) {
    const stack = [node];
    const arrows = [];
    while (stack.length !== 0) {
      const node2 = stack.pop();
      if (node2.type === "ArrowFunctionExpression") {
        if (node2.typeParameters || !node2.returnType) {
          this.finishArrowValidation(node2);
        } else {
          arrows.push(node2);
        }
        stack.push(node2.body);
      } else if (node2.type === "ConditionalExpression") {
        stack.push(node2.consequent);
        stack.push(node2.alternate);
      }
    }
    if (disallowInvalid) {
      arrows.forEach((node2) => this.finishArrowValidation(node2));
      return [arrows, []];
    }
    return partition2(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
  }
  finishArrowValidation(node) {
    var _node$extra;
    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? undefined : _node$extra.trailingCommaLoc, false);
    this.scope.enter(2 | 4);
    super.checkParams(node, false, true);
    this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(node, parse) {
    let result;
    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      result = parse();
      this.state.noArrowParamsConversionAt.pop();
    } else {
      result = parse();
    }
    return result;
  }
  parseParenItem(node, startLoc) {
    node = super.parseParenItem(node, startLoc);
    if (this.eat(17)) {
      node.optional = true;
      this.resetEndLocation(node);
    }
    if (this.match(14)) {
      const typeCastNode = this.startNodeAt(startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TypeCastExpression");
    }
    return node;
  }
  assertModuleNodeAllowed(node) {
    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
      return;
    }
    super.assertModuleNodeAllowed(node);
  }
  parseExportDeclaration(node) {
    if (this.isContextual(130)) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      if (this.match(5)) {
        node.specifiers = this.parseExportSpecifiers(true);
        super.parseExportFrom(node);
        return null;
      } else {
        return this.flowParseTypeAlias(declarationNode);
      }
    } else if (this.isContextual(131)) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseOpaqueType(declarationNode, false);
    } else if (this.isContextual(129)) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseInterface(declarationNode);
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      node.exportKind = "value";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseEnumDeclaration(declarationNode);
    } else {
      return super.parseExportDeclaration(node);
    }
  }
  eatExportStar(node) {
    if (super.eatExportStar(node))
      return true;
    if (this.isContextual(130) && this.lookahead().type === 55) {
      node.exportKind = "type";
      this.next();
      this.next();
      return true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(node) {
    const {
      startLoc
    } = this.state;
    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
    if (hasNamespace && node.exportKind === "type") {
      this.unexpected(startLoc);
    }
    return hasNamespace;
  }
  parseClassId(node, isStatement, optionalId) {
    super.parseClassId(node, isStatement, optionalId);
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
  }
  parseClassMember(classBody, member, state) {
    const {
      startLoc
    } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(classBody, member)) {
        return;
      }
      member.declare = true;
    }
    super.parseClassMember(classBody, member, state);
    if (member.declare) {
      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
        this.raise(FlowErrors.DeclareClassElement, {
          at: startLoc
        });
      } else if (member.value) {
        this.raise(FlowErrors.DeclareClassFieldInitializer, {
          at: member.value
        });
      }
    }
  }
  isIterator(word) {
    return word === "iterator" || word === "asyncIterator";
  }
  readIterator() {
    const word = super.readWord1();
    const fullWord = "@@" + word;
    if (!this.isIterator(word) || !this.state.inType) {
      this.raise(Errors.InvalidIdentifier, {
        at: this.state.curPosition(),
        identifierName: fullWord
      });
    }
    this.finishToken(132, fullWord);
  }
  getTokenFromCode(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (code === 123 && next === 124) {
      this.finishOp(6, 2);
    } else if (this.state.inType && (code === 62 || code === 60)) {
      this.finishOp(code === 62 ? 48 : 47, 1);
    } else if (this.state.inType && code === 63) {
      if (next === 46) {
        this.finishOp(18, 2);
      } else {
        this.finishOp(17, 1);
      }
    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
      this.state.pos += 2;
      this.readIterator();
    } else {
      super.getTokenFromCode(code);
    }
  }
  isAssignable(node, isBinding) {
    if (node.type === "TypeCastExpression") {
      return this.isAssignable(node.expression, isBinding);
    } else {
      return super.isAssignable(node, isBinding);
    }
  }
  toAssignable(node, isLHS = false) {
    if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
      node.left = this.typeCastToParameter(node.left);
    }
    super.toAssignable(node, isLHS);
  }
  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    for (let i = 0;i < exprList.length; i++) {
      const expr = exprList[i];
      if ((expr == null ? undefined : expr.type) === "TypeCastExpression") {
        exprList[i] = this.typeCastToParameter(expr);
      }
    }
    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
  }
  toReferencedList(exprList, isParenthesizedExpr) {
    for (let i = 0;i < exprList.length; i++) {
      var _expr$extra;
      const expr = exprList[i];
      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
        this.raise(FlowErrors.TypeCastInPattern, {
          at: expr.typeAnnotation
        });
      }
    }
    return exprList;
  }
  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
    if (canBePattern && !this.state.maybeInArrowParameters) {
      this.toReferencedList(node.elements);
    }
    return node;
  }
  isValidLVal(type, isParenthesized, binding) {
    return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
  }
  parseClassProperty(node) {
    if (this.match(14)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }
    return super.parseClassProperty(node);
  }
  parseClassPrivateProperty(node) {
    if (this.match(14)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }
    return super.parseClassPrivateProperty(node);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(method) {
    return !this.match(14) && super.isNonstaticConstructor(method);
  }
  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    if (method.variance) {
      this.unexpected(method.variance.loc.start);
    }
    delete method.variance;
    if (this.match(47)) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    if (method.params && isConstructor) {
      const params = method.params;
      if (params.length > 0 && this.isThisParam(params[0])) {
        this.raise(FlowErrors.ThisParamBannedInConstructor, {
          at: method
        });
      }
    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
      const params = method.value.params;
      if (params.length > 0 && this.isThisParam(params[0])) {
        this.raise(FlowErrors.ThisParamBannedInConstructor, {
          at: method
        });
      }
    }
  }
  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    if (method.variance) {
      this.unexpected(method.variance.loc.start);
    }
    delete method.variance;
    if (this.match(47)) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }
  parseClassSuper(node) {
    super.parseClassSuper(node);
    if (node.superClass && this.match(47)) {
      node.superTypeParameters = this.flowParseTypeParameterInstantiation();
    }
    if (this.isContextual(113)) {
      this.next();
      const implemented = node.implements = [];
      do {
        const node2 = this.startNode();
        node2.id = this.flowParseRestrictedIdentifier(true);
        if (this.match(47)) {
          node2.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node2.typeParameters = null;
        }
        implemented.push(this.finishNode(node2, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(method) {
    super.checkGetterSetterParams(method);
    const params = this.getObjectOrClassMethodParams(method);
    if (params.length > 0) {
      const param = params[0];
      if (this.isThisParam(param) && method.kind === "get") {
        this.raise(FlowErrors.GetterMayNotHaveThisParam, {
          at: param
        });
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.SetterMayNotHaveThisParam, {
          at: param
        });
      }
    }
  }
  parsePropertyNamePrefixOperator(node) {
    node.variance = this.flowParseVariance();
  }
  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    if (prop.variance) {
      this.unexpected(prop.variance.loc.start);
    }
    delete prop.variance;
    let typeParameters;
    if (this.match(47) && !isAccessor) {
      typeParameters = this.flowParseTypeParameterDeclaration();
      if (!this.match(10))
        this.unexpected();
    }
    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    if (typeParameters) {
      (result.value || result).typeParameters = typeParameters;
    }
    return result;
  }
  parseAssignableListItemTypes(param) {
    if (this.eat(17)) {
      if (param.type !== "Identifier") {
        this.raise(FlowErrors.PatternIsOptional, {
          at: param
        });
      }
      if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamMayNotBeOptional, {
          at: param
        });
      }
      param.optional = true;
    }
    if (this.match(14)) {
      param.typeAnnotation = this.flowParseTypeAnnotation();
    } else if (this.isThisParam(param)) {
      this.raise(FlowErrors.ThisParamAnnotationRequired, {
        at: param
      });
    }
    if (this.match(29) && this.isThisParam(param)) {
      this.raise(FlowErrors.ThisParamNoDefault, {
        at: param
      });
    }
    this.resetEndLocation(param);
    return param;
  }
  parseMaybeDefault(startLoc, left2) {
    const node = super.parseMaybeDefault(startLoc, left2);
    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(FlowErrors.TypeBeforeInitializer, {
        at: node.typeAnnotation
      });
    }
    return node;
  }
  checkImportReflection(node) {
    super.checkImportReflection(node);
    if (node.module && node.importKind !== "value") {
      this.raise(FlowErrors.ImportReflectionHasImportType, {
        at: node.specifiers[0].loc.start
      });
    }
  }
  parseImportSpecifierLocal(node, specifier, type) {
    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
    node.specifiers.push(this.finishImportSpecifier(specifier, type));
  }
  isPotentialImportPhase(isExport) {
    if (super.isPotentialImportPhase(isExport))
      return true;
    if (this.isContextual(130)) {
      if (!isExport)
        return true;
      const ch = this.lookaheadCharCode();
      return ch === 123 || ch === 42;
    }
    return !isExport && this.isContextual(87);
  }
  applyImportPhase(node, isExport, phase, loc) {
    super.applyImportPhase(node, isExport, phase, loc);
    if (isExport) {
      if (!phase && this.match(65)) {
        return;
      }
      node.exportKind = phase === "type" ? phase : "value";
    } else {
      if (phase === "type" && this.match(55))
        this.unexpected();
      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
  }
  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    const firstIdent = specifier.imported;
    let specifierTypeKind = null;
    if (firstIdent.type === "Identifier") {
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }
    }
    let isBinding = false;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);
      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = cloneIdentifier(as_ident);
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else {
      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
      } else {
        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, {
            at: specifier,
            importName: firstIdent.value
          });
        }
        specifier.imported = firstIdent;
        specifier.importKind = null;
      }
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        isBinding = true;
        specifier.local = cloneIdentifier(specifier.imported);
      }
    }
    const specifierIsTypeImport = hasTypeImportKind(specifier);
    if (isInTypeOnlyImport && specifierIsTypeImport) {
      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
        at: specifier
      });
    }
    if (isInTypeOnlyImport || specifierIsTypeImport) {
      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
    }
    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
    }
    return this.finishImportSpecifier(specifier, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(node, isConstructor) {
    const kind = node.kind;
    if (kind !== "get" && kind !== "set" && this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    super.parseFunctionParams(node, isConstructor);
  }
  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);
    if (this.match(14)) {
      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
      this.resetEndLocation(decl.id);
    }
  }
  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(14)) {
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true;
      node.returnType = this.flowParseTypeAnnotation();
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
    }
    return super.parseAsyncArrowFromCallExpression(node, call);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    var _jsx;
    let state = null;
    let jsx;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
      if (!jsx.error)
        return jsx.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];
      if (currentContext === types$1.j_oTag || currentContext === types$1.j_expr) {
        context.pop();
      }
    }
    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
      var _jsx2, _jsx3;
      state = state || this.state.clone();
      let typeParameters;
      const arrow = this.tryParse((abort) => {
        var _arrowExpression$extr;
        typeParameters = this.flowParseTypeParameterDeclaration();
        const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          this.resetStartLocationFromNode(result, typeParameters);
          return result;
        });
        if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
          abort();
        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
        if (expr.type !== "ArrowFunctionExpression")
          abort();
        expr.typeParameters = typeParameters;
        this.resetStartLocationFromNode(expr, typeParameters);
        return arrowExpression2;
      }, state);
      let arrowExpression = null;
      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
        if (!arrow.error && !arrow.aborted) {
          if (arrow.node.async) {
            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              at: typeParameters
            });
          }
          return arrow.node;
        }
        arrowExpression = arrow.node;
      }
      if ((_jsx2 = jsx) != null && _jsx2.node) {
        this.state = jsx.failState;
        return jsx.node;
      }
      if (arrowExpression) {
        this.state = arrow.failState;
        return arrowExpression;
      }
      if ((_jsx3 = jsx) != null && _jsx3.thrown)
        throw jsx.error;
      if (arrow.thrown)
        throw arrow.error;
      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
        at: typeParameters
      });
    }
    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
  }
  parseArrow(node) {
    if (this.match(14)) {
      const result = this.tryParse(() => {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        if (this.canInsertSemicolon())
          this.unexpected();
        if (!this.match(19))
          this.unexpected();
        return typeNode;
      });
      if (result.thrown)
        return null;
      if (result.error)
        this.state = result.failState;
      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(node);
  }
  shouldParseArrow(params) {
    return this.match(14) || super.shouldParseArrow(params);
  }
  setArrowFunctionParameters(node, params) {
    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      node.params = params;
    } else {
      super.setArrowFunctionParameters(node, params);
    }
  }
  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      return;
    }
    for (let i = 0;i < node.params.length; i++) {
      if (this.isThisParam(node.params[i]) && i > 0) {
        this.raise(FlowErrors.ThisParamMustBeFirst, {
          at: node.params[i]
        });
      }
    }
    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
  }
  parseParenAndDistinguishExpression(canBeArrow) {
    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(base, startLoc, noCalls) {
    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
      this.next();
      const node = this.startNodeAt(startLoc);
      node.callee = base;
      node.arguments = super.parseCallExpressionArguments(11, false);
      base = this.finishNode(node, "CallExpression");
    } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
      const state = this.state.clone();
      const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
      if (!arrow.error && !arrow.aborted)
        return arrow.node;
      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
      if (result.node && !result.error)
        return result.node;
      if (arrow.node) {
        this.state = arrow.failState;
        return arrow.node;
      }
      if (result.node) {
        this.state = result.failState;
        return result.node;
      }
      throw arrow.error || result.error;
    }
    return super.parseSubscripts(base, startLoc, noCalls);
  }
  parseSubscript(base, startLoc, noCalls, subscriptState) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      subscriptState.optionalChainMember = true;
      if (noCalls) {
        subscriptState.stop = true;
        return base;
      }
      this.next();
      const node = this.startNodeAt(startLoc);
      node.callee = base;
      node.typeArguments = this.flowParseTypeParameterInstantiation();
      this.expect(10);
      node.arguments = this.parseCallExpressionArguments(11, false);
      node.optional = true;
      return this.finishCallExpression(node, true);
    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
      const node = this.startNodeAt(startLoc);
      node.callee = base;
      const result = this.tryParse(() => {
        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
        this.expect(10);
        node.arguments = super.parseCallExpressionArguments(11, false);
        if (subscriptState.optionalChainMember) {
          node.optional = false;
        }
        return this.finishCallExpression(node, subscriptState.optionalChainMember);
      });
      if (result.node) {
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
    }
    return super.parseSubscript(base, startLoc, noCalls, subscriptState);
  }
  parseNewCallee(node) {
    super.parseNewCallee(node);
    let targs = null;
    if (this.shouldParseTypes() && this.match(47)) {
      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
    }
    node.typeArguments = targs;
  }
  parseAsyncArrowWithTypeParameters(startLoc) {
    const node = this.startNodeAt(startLoc);
    this.parseFunctionParams(node, false);
    if (!this.parseArrow(node))
      return;
    return super.parseArrowExpression(node, undefined, true);
  }
  readToken_mult_modulo(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (code === 42 && next === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = false;
      this.state.pos += 2;
      this.nextToken();
      return;
    }
    super.readToken_mult_modulo(code);
  }
  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (code === 124 && next === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(code);
  }
  parseTopLevel(file, program) {
    const fileNode = super.parseTopLevel(file, program);
    if (this.state.hasFlowComment) {
      this.raise(FlowErrors.UnterminatedFlowComment, {
        at: this.state.curPosition()
      });
    }
    return fileNode;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment) {
        throw this.raise(FlowErrors.NestedFlowComment, {
          at: this.state.startLoc
        });
      }
      this.hasFlowCommentCompletion();
      const commentSkip = this.skipFlowComment();
      if (commentSkip) {
        this.state.pos += commentSkip;
        this.state.hasFlowComment = true;
      }
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos
    } = this.state;
    let shiftToFirstNonWhiteSpace = 2;
    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
      shiftToFirstNonWhiteSpace++;
    }
    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
    if (ch2 === 58 && ch3 === 58) {
      return shiftToFirstNonWhiteSpace + 2;
    }
    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
      return shiftToFirstNonWhiteSpace + 12;
    }
    if (ch2 === 58 && ch3 !== 58) {
      return shiftToFirstNonWhiteSpace;
    }
    return false;
  }
  hasFlowCommentCompletion() {
    const end = this.input.indexOf("*/", this.state.pos);
    if (end === -1) {
      throw this.raise(Errors.UnterminatedComment, {
        at: this.state.curPosition()
      });
    }
  }
  flowEnumErrorBooleanMemberNotInitialized(loc, {
    enumName,
    memberName
  }) {
    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
      at: loc,
      memberName,
      enumName
    });
  }
  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
      at: loc
    }, enumContext));
  }
  flowEnumErrorNumberMemberNotInitialized(loc, {
    enumName,
    memberName
  }) {
    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
      at: loc,
      enumName,
      memberName
    });
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(node, {
    enumName
  }) {
    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
      at: node,
      enumName
    });
  }
  flowEnumMemberInit() {
    const startLoc = this.state.startLoc;
    const endOfInit = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 134: {
        const literal2 = this.parseNumericLiteral(this.state.value);
        if (endOfInit()) {
          return {
            type: "number",
            loc: literal2.loc.start,
            value: literal2
          };
        }
        return {
          type: "invalid",
          loc: startLoc
        };
      }
      case 133: {
        const literal2 = this.parseStringLiteral(this.state.value);
        if (endOfInit()) {
          return {
            type: "string",
            loc: literal2.loc.start,
            value: literal2
          };
        }
        return {
          type: "invalid",
          loc: startLoc
        };
      }
      case 85:
      case 86: {
        const literal2 = this.parseBooleanLiteral(this.match(85));
        if (endOfInit()) {
          return {
            type: "boolean",
            loc: literal2.loc.start,
            value: literal2
          };
        }
        return {
          type: "invalid",
          loc: startLoc
        };
      }
      default:
        return {
          type: "invalid",
          loc: startLoc
        };
    }
  }
  flowEnumMemberRaw() {
    const loc = this.state.startLoc;
    const id = this.parseIdentifier(true);
    const init = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc
    };
    return {
      id,
      init
    };
  }
  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
    const {
      explicitType
    } = context;
    if (explicitType === null) {
      return;
    }
    if (explicitType !== expectedType) {
      this.flowEnumErrorInvalidMemberInitializer(loc, context);
    }
  }
  flowEnumMembers({
    enumName,
    explicitType
  }) {
    const seenNames = new Set;
    const members = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let hasUnknownMembers = false;
    while (!this.match(8)) {
      if (this.eat(21)) {
        hasUnknownMembers = true;
        break;
      }
      const memberNode = this.startNode();
      const {
        id,
        init
      } = this.flowEnumMemberRaw();
      const memberName = id.name;
      if (memberName === "") {
        continue;
      }
      if (/^[a-z]/.test(memberName)) {
        this.raise(FlowErrors.EnumInvalidMemberName, {
          at: id,
          memberName,
          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
          enumName
        });
      }
      if (seenNames.has(memberName)) {
        this.raise(FlowErrors.EnumDuplicateMemberName, {
          at: id,
          memberName,
          enumName
        });
      }
      seenNames.add(memberName);
      const context = {
        enumName,
        explicitType,
        memberName
      };
      memberNode.id = id;
      switch (init.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
          memberNode.init = init.value;
          members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
          memberNode.init = init.value;
          members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
          memberNode.init = init.value;
          members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
          break;
        }
        case "invalid": {
          throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
        }
        case "none": {
          switch (explicitType) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
              break;
            default:
              members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
          }
        }
      }
      if (!this.match(8)) {
        this.expect(12);
      }
    }
    return {
      members,
      hasUnknownMembers
    };
  }
  flowEnumStringMembers(initializedMembers, defaultedMembers, {
    enumName
  }) {
    if (initializedMembers.length === 0) {
      return defaultedMembers;
    } else if (defaultedMembers.length === 0) {
      return initializedMembers;
    } else if (defaultedMembers.length > initializedMembers.length) {
      for (const member of initializedMembers) {
        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
          enumName
        });
      }
      return defaultedMembers;
    } else {
      for (const member of defaultedMembers) {
        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
          enumName
        });
      }
      return initializedMembers;
    }
  }
  flowEnumParseExplicitType({
    enumName
  }) {
    if (!this.eatContextual(102))
      return null;
    if (!tokenIsIdentifier(this.state.type)) {
      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
        at: this.state.startLoc,
        enumName
      });
    }
    const {
      value
    } = this.state;
    this.next();
    if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
      this.raise(FlowErrors.EnumInvalidExplicitType, {
        at: this.state.startLoc,
        enumName,
        invalidEnumType: value
      });
    }
    return value;
  }
  flowEnumBody(node, id) {
    const enumName = id.name;
    const nameLoc = id.loc.start;
    const explicitType = this.flowEnumParseExplicitType({
      enumName
    });
    this.expect(5);
    const {
      members,
      hasUnknownMembers
    } = this.flowEnumMembers({
      enumName,
      explicitType
    });
    node.hasUnknownMembers = hasUnknownMembers;
    switch (explicitType) {
      case "boolean":
        node.explicitType = true;
        node.members = members.booleanMembers;
        this.expect(8);
        return this.finishNode(node, "EnumBooleanBody");
      case "number":
        node.explicitType = true;
        node.members = members.numberMembers;
        this.expect(8);
        return this.finishNode(node, "EnumNumberBody");
      case "string":
        node.explicitType = true;
        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
          enumName
        });
        this.expect(8);
        return this.finishNode(node, "EnumStringBody");
      case "symbol":
        node.members = members.defaultedMembers;
        this.expect(8);
        return this.finishNode(node, "EnumSymbolBody");
      default: {
        const empty = () => {
          node.members = [];
          this.expect(8);
          return this.finishNode(node, "EnumStringBody");
        };
        node.explicitType = false;
        const boolsLen = members.booleanMembers.length;
        const numsLen = members.numberMembers.length;
        const strsLen = members.stringMembers.length;
        const defaultedLen = members.defaultedMembers.length;
        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
          return empty();
        } else if (!boolsLen && !numsLen) {
          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(8);
          return this.finishNode(node, "EnumStringBody");
        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
          for (const member of members.defaultedMembers) {
            this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
              enumName,
              memberName: member.id.name
            });
          }
          node.members = members.booleanMembers;
          this.expect(8);
          return this.finishNode(node, "EnumBooleanBody");
        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
          for (const member of members.defaultedMembers) {
            this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
              enumName,
              memberName: member.id.name
            });
          }
          node.members = members.numberMembers;
          this.expect(8);
          return this.finishNode(node, "EnumNumberBody");
        } else {
          this.raise(FlowErrors.EnumInconsistentMemberValues, {
            at: nameLoc,
            enumName
          });
          return empty();
        }
      }
    }
  }
  flowParseEnumDeclaration(node) {
    const id = this.parseIdentifier();
    node.id = id;
    node.body = this.flowEnumBody(this.startNode(), id);
    return this.finishNode(node, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const next = this.nextTokenStart();
    if (this.input.charCodeAt(next) === 60) {
      const afterNext = this.input.charCodeAt(next + 1);
      return afterNext !== 60 && afterNext !== 61;
    }
    return false;
  }
  maybeUnwrapTypeCastExpression(node) {
    return node.type === "TypeCastExpression" ? node.expression : node;
  }
};
var entities = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};
var JsxErrors = ParseErrorEnum`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName
  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected,
    HTMLEntity
  }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}
function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }
  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }
  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
  throw new Error("Node had unexpected type: " + object.type);
}
var jsx = (superClass) => class JSXParserMixin extends superClass {
  jsxReadToken() {
    let out = "";
    let chunkStart = this.state.pos;
    for (;; ) {
      if (this.state.pos >= this.length) {
        throw this.raise(JsxErrors.UnterminatedJsxContent, {
          at: this.state.startLoc
        });
      }
      const ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            if (ch === 60 && this.state.canStartJSXElement) {
              ++this.state.pos;
              this.finishToken(142);
            } else {
              super.getTokenFromCode(ch);
            }
            return;
          }
          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(141, out);
          return;
        case 38:
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(true);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
      }
    }
  }
  jsxReadNewLine(normalizeCRLF) {
    const ch = this.input.charCodeAt(this.state.pos);
    let out;
    ++this.state.pos;
    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
      ++this.state.pos;
      out = normalizeCRLF ? `
` : `\r
`;
    } else {
      out = String.fromCharCode(ch);
    }
    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  }
  jsxReadString(quote) {
    let out = "";
    let chunkStart = ++this.state.pos;
    for (;; ) {
      if (this.state.pos >= this.length) {
        throw this.raise(Errors.UnterminatedString, {
          at: this.state.startLoc
        });
      }
      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote)
        break;
      if (ch === 38) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadNewLine(false);
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    this.finishToken(133, out);
  }
  jsxReadEntity() {
    const startPos = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let radix = 10;
      if (this.codePointAtPos(this.state.pos) === 120) {
        radix = 16;
        ++this.state.pos;
      }
      const codePoint = this.readInt(radix, undefined, false, "bail");
      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
        ++this.state.pos;
        return String.fromCodePoint(codePoint);
      }
    } else {
      let count = 0;
      let semi = false;
      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
        ++this.state.pos;
      }
      if (semi) {
        const desc = this.input.slice(startPos, this.state.pos);
        const entity = entities[desc];
        ++this.state.pos;
        if (entity) {
          return entity;
        }
      }
    }
    this.state.pos = startPos;
    return "&";
  }
  jsxReadWord() {
    let ch;
    const start = this.state.pos;
    do {
      ch = this.input.charCodeAt(++this.state.pos);
    } while (isIdentifierChar(ch) || ch === 45);
    this.finishToken(140, this.input.slice(start, this.state.pos));
  }
  jsxParseIdentifier() {
    const node = this.startNode();
    if (this.match(140)) {
      node.name = this.state.value;
    } else if (tokenIsKeyword(this.state.type)) {
      node.name = tokenLabelName(this.state.type);
    } else {
      this.unexpected();
    }
    this.next();
    return this.finishNode(node, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const startLoc = this.state.startLoc;
    const name3 = this.jsxParseIdentifier();
    if (!this.eat(14))
      return name3;
    const node = this.startNodeAt(startLoc);
    node.namespace = name3;
    node.name = this.jsxParseIdentifier();
    return this.finishNode(node, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const startLoc = this.state.startLoc;
    let node = this.jsxParseNamespacedName();
    if (node.type === "JSXNamespacedName") {
      return node;
    }
    while (this.eat(16)) {
      const newNode = this.startNodeAt(startLoc);
      newNode.object = node;
      newNode.property = this.jsxParseIdentifier();
      node = this.finishNode(newNode, "JSXMemberExpression");
    }
    return node;
  }
  jsxParseAttributeValue() {
    let node;
    switch (this.state.type) {
      case 5:
        node = this.startNode();
        this.setContext(types$1.brace);
        this.next();
        node = this.jsxParseExpressionContainer(node, types$1.j_oTag);
        if (node.expression.type === "JSXEmptyExpression") {
          this.raise(JsxErrors.AttributeIsEmpty, {
            at: node
          });
        }
        return node;
      case 142:
      case 133:
        return this.parseExprAtom();
      default:
        throw this.raise(JsxErrors.UnsupportedJsxValue, {
          at: this.state.startLoc
        });
    }
  }
  jsxParseEmptyExpression() {
    const node = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(node) {
    this.next();
    node.expression = this.parseExpression();
    this.setContext(types$1.j_expr);
    this.state.canStartJSXElement = true;
    this.expect(8);
    return this.finishNode(node, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(node, previousContext) {
    if (this.match(8)) {
      node.expression = this.jsxParseEmptyExpression();
    } else {
      const expression = this.parseExpression();
      node.expression = expression;
    }
    this.setContext(previousContext);
    this.state.canStartJSXElement = true;
    this.expect(8);
    return this.finishNode(node, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const node = this.startNode();
    if (this.match(5)) {
      this.setContext(types$1.brace);
      this.next();
      this.expect(21);
      node.argument = this.parseMaybeAssignAllowIn();
      this.setContext(types$1.j_oTag);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node, "JSXSpreadAttribute");
    }
    node.name = this.jsxParseNamespacedName();
    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
    return this.finishNode(node, "JSXAttribute");
  }
  jsxParseOpeningElementAt(startLoc) {
    const node = this.startNodeAt(startLoc);
    if (this.eat(143)) {
      return this.finishNode(node, "JSXOpeningFragment");
    }
    node.name = this.jsxParseElementName();
    return this.jsxParseOpeningElementAfterName(node);
  }
  jsxParseOpeningElementAfterName(node) {
    const attributes = [];
    while (!this.match(56) && !this.match(143)) {
      attributes.push(this.jsxParseAttribute());
    }
    node.attributes = attributes;
    node.selfClosing = this.eat(56);
    this.expect(143);
    return this.finishNode(node, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(startLoc) {
    const node = this.startNodeAt(startLoc);
    if (this.eat(143)) {
      return this.finishNode(node, "JSXClosingFragment");
    }
    node.name = this.jsxParseElementName();
    this.expect(143);
    return this.finishNode(node, "JSXClosingElement");
  }
  jsxParseElementAt(startLoc) {
    const node = this.startNodeAt(startLoc);
    const children = [];
    const openingElement = this.jsxParseOpeningElementAt(startLoc);
    let closingElement = null;
    if (!openingElement.selfClosing) {
      contents:
        for (;; ) {
          switch (this.state.type) {
            case 142:
              startLoc = this.state.startLoc;
              this.next();
              if (this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startLoc);
                break contents;
              }
              children.push(this.jsxParseElementAt(startLoc));
              break;
            case 141:
              children.push(this.parseExprAtom());
              break;
            case 5: {
              const node2 = this.startNode();
              this.setContext(types$1.brace);
              this.next();
              if (this.match(21)) {
                children.push(this.jsxParseSpreadChild(node2));
              } else {
                children.push(this.jsxParseExpressionContainer(node2, types$1.j_expr));
              }
              break;
            }
            default:
              this.unexpected();
          }
        }
      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
        this.raise(JsxErrors.MissingClosingTagFragment, {
          at: closingElement
        });
      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
        this.raise(JsxErrors.MissingClosingTagElement, {
          at: closingElement,
          openingTagName: getQualifiedJSXName(openingElement.name)
        });
      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(JsxErrors.MissingClosingTagElement, {
            at: closingElement,
            openingTagName: getQualifiedJSXName(openingElement.name)
          });
        }
      }
    }
    if (isFragment(openingElement)) {
      node.openingFragment = openingElement;
      node.closingFragment = closingElement;
    } else {
      node.openingElement = openingElement;
      node.closingElement = closingElement;
    }
    node.children = children;
    if (this.match(47)) {
      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
        at: this.state.startLoc
      });
    }
    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
  }
  jsxParseElement() {
    const startLoc = this.state.startLoc;
    this.next();
    return this.jsxParseElementAt(startLoc);
  }
  setContext(newContext) {
    const {
      context
    } = this.state;
    context[context.length - 1] = newContext;
  }
  parseExprAtom(refExpressionErrors) {
    if (this.match(141)) {
      return this.parseLiteral(this.state.value, "JSXText");
    } else if (this.match(142)) {
      return this.jsxParseElement();
    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
      this.replaceToken(142);
      return this.jsxParseElement();
    } else {
      return super.parseExprAtom(refExpressionErrors);
    }
  }
  skipSpace() {
    const curContext = this.curContext();
    if (!curContext.preserveSpace)
      super.skipSpace();
  }
  getTokenFromCode(code) {
    const context = this.curContext();
    if (context === types$1.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (context === types$1.j_oTag || context === types$1.j_cTag) {
      if (isIdentifierStart(code)) {
        this.jsxReadWord();
        return;
      }
      if (code === 62) {
        ++this.state.pos;
        this.finishToken(143);
        return;
      }
      if ((code === 34 || code === 39) && context === types$1.j_oTag) {
        this.jsxReadString(code);
        return;
      }
    }
    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos;
      this.finishToken(142);
      return;
    }
    super.getTokenFromCode(code);
  }
  updateContext(prevType) {
    const {
      context,
      type
    } = this.state;
    if (type === 56 && prevType === 142) {
      context.splice(-2, 2, types$1.j_cTag);
      this.state.canStartJSXElement = false;
    } else if (type === 142) {
      context.push(types$1.j_oTag);
    } else if (type === 143) {
      const out = context[context.length - 1];
      if (out === types$1.j_oTag && prevType === 56 || out === types$1.j_cTag) {
        context.pop();
        this.state.canStartJSXElement = context[context.length - 1] === types$1.j_expr;
      } else {
        this.setContext(types$1.j_expr);
        this.state.canStartJSXElement = true;
      }
    } else {
      this.state.canStartJSXElement = tokenComesBeforeExpression(type);
    }
  }
};

class TypeScriptScope extends Scope {
  constructor(...args) {
    super(...args);
    this.types = new Set;
    this.enums = new Set;
    this.constEnums = new Set;
    this.classes = new Set;
    this.exportOnlyBindings = new Set;
  }
}

class TypeScriptScopeHandler extends ScopeHandler {
  constructor(...args) {
    super(...args);
    this.importsStack = [];
  }
  createScope(flags) {
    this.importsStack.push(new Set);
    return new TypeScriptScope(flags);
  }
  enter(flags) {
    if (flags == 256) {
      this.importsStack.push(new Set);
    }
    super.enter(flags);
  }
  exit() {
    const flags = super.exit();
    if (flags == 256) {
      this.importsStack.pop();
    }
    return flags;
  }
  hasImport(name3, allowShadow) {
    const len = this.importsStack.length;
    if (this.importsStack[len - 1].has(name3)) {
      return true;
    }
    if (!allowShadow && len > 1) {
      for (let i = 0;i < len - 1; i++) {
        if (this.importsStack[i].has(name3))
          return true;
      }
    }
    return false;
  }
  declareName(name3, bindingType, loc) {
    if (bindingType & 4096) {
      if (this.hasImport(name3, true)) {
        this.parser.raise(Errors.VarRedeclaration, {
          at: loc,
          identifierName: name3
        });
      }
      this.importsStack[this.importsStack.length - 1].add(name3);
      return;
    }
    const scope = this.currentScope();
    if (bindingType & 1024) {
      this.maybeExportDefined(scope, name3);
      scope.exportOnlyBindings.add(name3);
      return;
    }
    super.declareName(name3, bindingType, loc);
    if (bindingType & 2) {
      if (!(bindingType & 1)) {
        this.checkRedeclarationInScope(scope, name3, bindingType, loc);
        this.maybeExportDefined(scope, name3);
      }
      scope.types.add(name3);
    }
    if (bindingType & 256)
      scope.enums.add(name3);
    if (bindingType & 512) {
      scope.constEnums.add(name3);
    }
    if (bindingType & 128)
      scope.classes.add(name3);
  }
  isRedeclaredInScope(scope, name3, bindingType) {
    if (scope.enums.has(name3)) {
      if (bindingType & 256) {
        const isConst = !!(bindingType & 512);
        const wasConst = scope.constEnums.has(name3);
        return isConst !== wasConst;
      }
      return true;
    }
    if (bindingType & 128 && scope.classes.has(name3)) {
      if (scope.lexical.has(name3)) {
        return !!(bindingType & 1);
      } else {
        return false;
      }
    }
    if (bindingType & 2 && scope.types.has(name3)) {
      return true;
    }
    return super.isRedeclaredInScope(scope, name3, bindingType);
  }
  checkLocalExport(id) {
    const {
      name: name3
    } = id;
    if (this.hasImport(name3))
      return;
    const len = this.scopeStack.length;
    for (let i = len - 1;i >= 0; i--) {
      const scope = this.scopeStack[i];
      if (scope.types.has(name3) || scope.exportOnlyBindings.has(name3))
        return;
    }
    super.checkLocalExport(id);
  }
}
var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
var unwrapParenthesizedExpression = (node) => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node, isLHS = false) {
    var _node$extra, _node$extra3;
    let parenthesized = undefined;
    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
      parenthesized = unwrapParenthesizedExpression(node);
      if (isLHS) {
        if (parenthesized.type === "Identifier") {
          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
            at: node
          });
        } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
          this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node
          });
        }
      } else {
        this.raise(Errors.InvalidParenthesizedAssignment, {
          at: node
        });
      }
    }
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (let i = 0, length = node.properties.length, last = length - 1;i < length; i++) {
          var _node$extra2;
          const prop = node.properties[i];
          const isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, {
              at: node.extra.trailingCommaLoc
            });
          }
        }
        break;
      case "ObjectProperty": {
        const {
          key,
          value
        } = node;
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
        }
        this.toAssignable(value, isLHS);
        break;
      }
      case "SpreadElement": {
        throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
      }
      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? undefined : _node$extra3.trailingCommaLoc, isLHS);
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(Errors.MissingEqInAssignment, {
            at: node.left.loc.end
          });
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isLHS);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(parenthesized, isLHS);
        break;
    }
  }
  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    if (prop.type === "ObjectMethod") {
      this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
        at: prop.key
      });
    } else if (prop.type === "SpreadElement") {
      prop.type = "RestElement";
      const arg = prop.argument;
      this.checkToRestConversion(arg, false);
      this.toAssignable(arg, isLHS);
      if (!isLast) {
        this.raise(Errors.RestTrailingComma, {
          at: prop
        });
      }
    } else {
      this.toAssignable(prop, isLHS);
    }
  }
  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    const end = exprList.length - 1;
    for (let i = 0;i <= end; i++) {
      const elt = exprList[i];
      if (!elt)
        continue;
      if (elt.type === "SpreadElement") {
        elt.type = "RestElement";
        const arg = elt.argument;
        this.checkToRestConversion(arg, true);
        this.toAssignable(arg, isLHS);
      } else {
        this.toAssignable(elt, isLHS);
      }
      if (elt.type === "RestElement") {
        if (i < end) {
          this.raise(Errors.RestTrailingComma, {
            at: elt
          });
        } else if (trailingCommaLoc) {
          this.raise(Errors.RestTrailingComma, {
            at: trailingCommaLoc
          });
        }
      }
    }
  }
  isAssignable(node, isBinding) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return true;
      case "ObjectExpression": {
        const last = node.properties.length - 1;
        return node.properties.every((prop, i) => {
          return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
        });
      }
      case "ObjectProperty":
        return this.isAssignable(node.value);
      case "SpreadElement":
        return this.isAssignable(node.argument);
      case "ArrayExpression":
        return node.elements.every((element) => element === null || this.isAssignable(element));
      case "AssignmentExpression":
        return node.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(node.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !isBinding;
      default:
        return false;
    }
  }
  toReferencedList(exprList, isParenthesizedExpr) {
    return exprList;
  }
  toReferencedListDeep(exprList, isParenthesizedExpr) {
    this.toReferencedList(exprList, isParenthesizedExpr);
    for (const expr of exprList) {
      if ((expr == null ? undefined : expr.type) === "ArrayExpression") {
        this.toReferencedListDeep(expr.elements);
      }
    }
  }
  parseSpread(refExpressionErrors) {
    const node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
    return this.finishNode(node, "SpreadElement");
  }
  parseRestBinding() {
    const node = this.startNode();
    this.next();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(3, 93, 1);
        return this.finishNode(node, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, true);
    }
    return this.parseIdentifier();
  }
  parseBindingList(close, closeCharCode, flags) {
    const allowEmpty = flags & 1;
    const elts = [];
    let first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
      }
      if (allowEmpty && this.match(12)) {
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(21)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
        if (!this.checkCommaAfterRest(closeCharCode)) {
          this.expect(close);
          break;
        }
      } else {
        const decorators = [];
        if (this.match(26) && this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedParameterDecorator, {
            at: this.state.startLoc
          });
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
        elts.push(this.parseAssignableListItem(flags, decorators));
      }
    }
    return elts;
  }
  parseBindingRestProperty(prop) {
    this.next();
    prop.argument = this.parseIdentifier();
    this.checkCommaAfterRest(125);
    return this.finishNode(prop, "RestElement");
  }
  parseBindingProperty() {
    const prop = this.startNode();
    const {
      type,
      startLoc
    } = this.state;
    if (type === 21) {
      return this.parseBindingRestProperty(prop);
    } else if (type === 138) {
      this.expectPlugin("destructuringPrivate", startLoc);
      this.classScope.usePrivateName(this.state.value, startLoc);
      prop.key = this.parsePrivateName();
    } else {
      this.parsePropertyName(prop);
    }
    prop.method = false;
    return this.parseObjPropValue(prop, startLoc, false, false, true, false);
  }
  parseAssignableListItem(flags, decorators) {
    const left2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left2, flags);
    const elt = this.parseMaybeDefault(left2.loc.start, left2);
    if (decorators.length) {
      left2.decorators = decorators;
    }
    return elt;
  }
  parseAssignableListItemTypes(param, flags) {
    return param;
  }
  parseMaybeDefault(startLoc, left2) {
    var _startLoc, _left;
    (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
    left2 = (_left = left2) != null ? _left : this.parseBindingAtom();
    if (!this.eat(29))
      return left2;
    const node = this.startNodeAt(startLoc);
    node.left = left2;
    node.right = this.parseMaybeAssignAllowIn();
    return this.finishNode(node, "AssignmentPattern");
  }
  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    return getOwn$1({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, type);
  }
  isOptionalMemberExpression(expression) {
    return expression.type === "OptionalMemberExpression";
  }
  checkLVal(expression, {
    in: ancestor,
    binding = 64,
    checkClashes = false,
    strictModeChanged = false,
    hasParenthesizedAncestor = false
  }) {
    var _expression$extra;
    const type = expression.type;
    if (this.isObjectMethod(expression))
      return;
    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
    if (isOptionalMemberExpression || type === "MemberExpression") {
      if (isOptionalMemberExpression) {
        this.expectPlugin("optionalChainingAssign", expression.loc.start);
        if (ancestor.type !== "AssignmentExpression") {
          this.raise(Errors.InvalidLhsOptionalChaining, {
            at: expression,
            ancestor
          });
        }
      }
      if (binding !== 64) {
        this.raise(Errors.InvalidPropertyBindingPattern, {
          at: expression
        });
      }
      return;
    }
    if (type === "Identifier") {
      this.checkIdentifier(expression, binding, strictModeChanged);
      const {
        name: name3
      } = expression;
      if (checkClashes) {
        if (checkClashes.has(name3)) {
          this.raise(Errors.ParamDupe, {
            at: expression
          });
        } else {
          checkClashes.add(name3);
        }
      }
      return;
    }
    const validity2 = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
    if (validity2 === true)
      return;
    if (validity2 === false) {
      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
      this.raise(ParseErrorClass, {
        at: expression,
        ancestor
      });
      return;
    }
    const [key, isParenthesizedExpression] = Array.isArray(validity2) ? validity2 : [validity2, type === "ParenthesizedExpression"];
    const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
      type
    } : ancestor;
    for (const child of [].concat(expression[key])) {
      if (child) {
        this.checkLVal(child, {
          in: nextAncestor,
          binding,
          checkClashes,
          strictModeChanged,
          hasParenthesizedAncestor: isParenthesizedExpression
        });
      }
    }
  }
  checkIdentifier(at2, bindingType, strictModeChanged = false) {
    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name))) {
      if (bindingType === 64) {
        this.raise(Errors.StrictEvalArguments, {
          at: at2,
          referenceName: at2.name
        });
      } else {
        this.raise(Errors.StrictEvalArgumentsBinding, {
          at: at2,
          bindingName: at2.name
        });
      }
    }
    if (bindingType & 8192 && at2.name === "let") {
      this.raise(Errors.LetInLexicalBinding, {
        at: at2
      });
    }
    if (!(bindingType & 64)) {
      this.declareNameFromIdentifier(at2, bindingType);
    }
  }
  declareNameFromIdentifier(identifier, binding) {
    this.scope.declareName(identifier.name, binding, identifier.loc.start);
  }
  checkToRestConversion(node, allowPattern) {
    switch (node.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(node.expression, allowPattern);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (allowPattern)
          break;
      default:
        this.raise(Errors.InvalidRestAssignmentPattern, {
          at: node
        });
    }
  }
  checkCommaAfterRest(close) {
    if (!this.match(12)) {
      return false;
    }
    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
      at: this.state.startLoc
    });
    return true;
  }
}
var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
function nonNull(x2) {
  if (x2 == null) {
    throw new Error(`Unexpected ${x2} value.`);
  }
  return x2;
}
function assert$1(x2) {
  if (!x2) {
    throw new Error("Assert fail");
  }
}
var TSErrors = ParseErrorEnum`typescript`({
  AbstractMethodHasImplementation: ({
    methodName
  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName
  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind
  }) => `'declare' is not allowed in ${kind}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier
  }) => `Accessibility modifier already seen.`,
  DuplicateModifier: ({
    modifier
  }) => `Duplicate modifier: '${modifier}'.`,
  EmptyHeritageClauseType: ({
    token: token2
  }) => `'${token2}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers
  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier
  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier
  }) => `'${modifier}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier
  }) => `'${modifier}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier
  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers
  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier
  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName
  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
});
function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}
var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
  constructor(...args) {
    super(...args);
    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    });
    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    });
    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return TypeScriptScopeHandler;
  }
  tsIsIdentifier() {
    return tokenIsIdentifier(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    this.next();
    return this.tsTokenCanFollowModifier();
  }
  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
      return;
    }
    const modifier = this.state.value;
    if (allowedModifiers.indexOf(modifier) !== -1) {
      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
        return;
      }
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
        return modifier;
      }
    }
    return;
  }
  tsParseModifiers({
    allowedModifiers,
    disallowedModifiers,
    stopOnStartOfClassStaticBlock,
    errorTemplate = TSErrors.InvalidModifierOnTypeMember
  }, modified) {
    const enforceOrder = (loc, modifier, before, after) => {
      if (modifier === before && modified[after]) {
        this.raise(TSErrors.InvalidModifiersOrder, {
          at: loc,
          orderedModifiers: [before, after]
        });
      }
    };
    const incompatible = (loc, modifier, mod1, mod2) => {
      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
        this.raise(TSErrors.IncompatibleModifiers, {
          at: loc,
          modifiers: [mod1, mod2]
        });
      }
    };
    for (;; ) {
      const {
        startLoc
      } = this.state;
      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
      if (!modifier)
        break;
      if (tsIsAccessModifier(modifier)) {
        if (modified.accessibility) {
          this.raise(TSErrors.DuplicateAccessibilityModifier, {
            at: startLoc,
            modifier
          });
        } else {
          enforceOrder(startLoc, modifier, modifier, "override");
          enforceOrder(startLoc, modifier, modifier, "static");
          enforceOrder(startLoc, modifier, modifier, "readonly");
          modified.accessibility = modifier;
        }
      } else if (tsIsVarianceAnnotations(modifier)) {
        if (modified[modifier]) {
          this.raise(TSErrors.DuplicateModifier, {
            at: startLoc,
            modifier
          });
        }
        modified[modifier] = true;
        enforceOrder(startLoc, modifier, "in", "out");
      } else {
        if (Object.hasOwnProperty.call(modified, modifier)) {
          this.raise(TSErrors.DuplicateModifier, {
            at: startLoc,
            modifier
          });
        } else {
          enforceOrder(startLoc, modifier, "static", "readonly");
          enforceOrder(startLoc, modifier, "static", "override");
          enforceOrder(startLoc, modifier, "override", "readonly");
          enforceOrder(startLoc, modifier, "abstract", "override");
          incompatible(startLoc, modifier, "declare", "override");
          incompatible(startLoc, modifier, "static", "abstract");
        }
        modified[modifier] = true;
      }
      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
        this.raise(errorTemplate, {
          at: startLoc,
          modifier
        });
      }
    }
  }
  tsIsListTerminator(kind) {
    switch (kind) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(kind, parseElement) {
    const result = [];
    while (!this.tsIsListTerminator(kind)) {
      result.push(parseElement());
    }
    return result;
  }
  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
  }
  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
    const result = [];
    let trailingCommaPos = -1;
    for (;; ) {
      if (this.tsIsListTerminator(kind)) {
        break;
      }
      trailingCommaPos = -1;
      const element = parseElement();
      if (element == null) {
        return;
      }
      result.push(element);
      if (this.eat(12)) {
        trailingCommaPos = this.state.lastTokStart;
        continue;
      }
      if (this.tsIsListTerminator(kind)) {
        break;
      }
      if (expectSuccess) {
        this.expect(12);
      }
      return;
    }
    if (refTrailingCommaPos) {
      refTrailingCommaPos.value = trailingCommaPos;
    }
    return result;
  }
  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
    if (!skipFirstToken) {
      if (bracket) {
        this.expect(0);
      } else {
        this.expect(47);
      }
    }
    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
    if (bracket) {
      this.expect(3);
    } else {
      this.expect(48);
    }
    return result;
  }
  tsParseImportType() {
    const node = this.startNode();
    this.expect(83);
    this.expect(10);
    if (!this.match(133)) {
      this.raise(TSErrors.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      });
    }
    node.argument = super.parseExprAtom();
    this.expect(11);
    if (this.eat(16)) {
      node.qualifier = this.tsParseEntityName();
    }
    if (this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }
    return this.finishNode(node, "TSImportType");
  }
  tsParseEntityName(allowReservedWords = true) {
    let entity = this.parseIdentifier(allowReservedWords);
    while (this.eat(16)) {
      const node = this.startNodeAtNode(entity);
      node.left = entity;
      node.right = this.parseIdentifier(allowReservedWords);
      entity = this.finishNode(node, "TSQualifiedName");
    }
    return entity;
  }
  tsParseTypeReference() {
    const node = this.startNode();
    node.typeName = this.tsParseEntityName();
    if (!this.hasPrecedingLineBreak() && this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }
    return this.finishNode(node, "TSTypeReference");
  }
  tsParseThisTypePredicate(lhs) {
    this.next();
    const node = this.startNodeAtNode(lhs);
    node.parameterName = lhs;
    node.typeAnnotation = this.tsParseTypeAnnotation(false);
    node.asserts = false;
    return this.finishNode(node, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const node = this.startNode();
    this.next();
    return this.finishNode(node, "TSThisType");
  }
  tsParseTypeQuery() {
    const node = this.startNode();
    this.expect(87);
    if (this.match(83)) {
      node.exprName = this.tsParseImportType();
    } else {
      node.exprName = this.tsParseEntityName();
    }
    if (!this.hasPrecedingLineBreak() && this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }
    return this.finishNode(node, "TSTypeQuery");
  }
  tsParseTypeParameter(parseModifiers) {
    const node = this.startNode();
    parseModifiers(node);
    node.name = this.tsParseTypeParameterName();
    node.constraint = this.tsEatThenParseType(81);
    node.default = this.tsEatThenParseType(29);
    return this.finishNode(node, "TSTypeParameter");
  }
  tsTryParseTypeParameters(parseModifiers) {
    if (this.match(47)) {
      return this.tsParseTypeParameters(parseModifiers);
    }
  }
  tsParseTypeParameters(parseModifiers) {
    const node = this.startNode();
    if (this.match(47) || this.match(142)) {
      this.next();
    } else {
      this.unexpected();
    }
    const refTrailingCommaPos = {
      value: -1
    };
    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
    if (node.params.length === 0) {
      this.raise(TSErrors.EmptyTypeParameters, {
        at: node
      });
    }
    if (refTrailingCommaPos.value !== -1) {
      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
    }
    return this.finishNode(node, "TSTypeParameterDeclaration");
  }
  tsFillSignature(returnToken, signature) {
    const returnTokenRequired = returnToken === 19;
    const paramsKey = "parameters";
    const returnTypeKey = "typeAnnotation";
    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    this.expect(10);
    signature[paramsKey] = this.tsParseBindingListForSignature();
    if (returnTokenRequired) {
      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    } else if (this.match(returnToken)) {
      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
  }
  tsParseBindingListForSignature() {
    const list = super.parseBindingList(11, 41, 2);
    for (const pattern2 of list) {
      const {
        type
      } = pattern2;
      if (type === "AssignmentPattern" || type === "TSParameterProperty") {
        this.raise(TSErrors.UnsupportedSignatureParameterKind, {
          at: pattern2,
          type
        });
      }
    }
    return list;
  }
  tsParseTypeMemberSemicolon() {
    if (!this.eat(12) && !this.isLineTerminator()) {
      this.expect(13);
    }
  }
  tsParseSignatureMember(kind, node) {
    this.tsFillSignature(14, node);
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, kind);
  }
  tsIsUnambiguouslyIndexSignature() {
    this.next();
    if (tokenIsIdentifier(this.state.type)) {
      this.next();
      return this.match(14);
    }
    return false;
  }
  tsTryParseIndexSignature(node) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
      return;
    }
    this.expect(0);
    const id = this.parseIdentifier();
    id.typeAnnotation = this.tsParseTypeAnnotation();
    this.resetEndLocation(id);
    this.expect(3);
    node.parameters = [id];
    const type = this.tsTryParseTypeAnnotation();
    if (type)
      node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(17))
      node.optional = true;
    const nodeAny = node;
    if (this.match(10) || this.match(47)) {
      if (readonly) {
        this.raise(TSErrors.ReadonlyForMethodSignature, {
          at: node
        });
      }
      const method = nodeAny;
      if (method.kind && this.match(47)) {
        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        });
      }
      this.tsFillSignature(14, method);
      this.tsParseTypeMemberSemicolon();
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";
      if (method.kind === "get") {
        if (method[paramsKey].length > 0) {
          this.raise(Errors.BadGetterArity, {
            at: this.state.curPosition()
          });
          if (this.isThisParam(method[paramsKey][0])) {
            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            });
          }
        }
      } else if (method.kind === "set") {
        if (method[paramsKey].length !== 1) {
          this.raise(Errors.BadSetterArity, {
            at: this.state.curPosition()
          });
        } else {
          const firstParameter = method[paramsKey][0];
          if (this.isThisParam(firstParameter)) {
            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            });
          }
          if (firstParameter.type === "Identifier" && firstParameter.optional) {
            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
              at: this.state.curPosition()
            });
          }
          if (firstParameter.type === "RestElement") {
            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
              at: this.state.curPosition()
            });
          }
        }
        if (method[returnTypeKey]) {
          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
            at: method[returnTypeKey]
          });
        }
      } else {
        method.kind = "method";
      }
      return this.finishNode(method, "TSMethodSignature");
    } else {
      const property = nodeAny;
      if (readonly)
        property.readonly = true;
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        property.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(property, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const node = this.startNode();
    if (this.match(10) || this.match(47)) {
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
    }
    if (this.match(77)) {
      const id = this.startNode();
      this.next();
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
      } else {
        node.key = this.createIdentifier(id, "new");
        return this.tsParsePropertyOrMethodSignature(node, false);
      }
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, node);
    const idx = this.tsTryParseIndexSignature(node);
    if (idx) {
      return idx;
    }
    super.parsePropertyName(node);
    if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
      node.kind = node.key.name;
      super.parsePropertyName(node);
    }
    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
  }
  tsParseTypeLiteral() {
    const node = this.startNode();
    node.members = this.tsParseObjectTypeMembers();
    return this.finishNode(node, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    this.expect(8);
    return members;
  }
  tsIsStartOfMappedType() {
    this.next();
    if (this.eat(53)) {
      return this.isContextual(122);
    }
    if (this.isContextual(122)) {
      this.next();
    }
    if (!this.match(0)) {
      return false;
    }
    this.next();
    if (!this.tsIsIdentifier()) {
      return false;
    }
    this.next();
    return this.match(58);
  }
  tsParseMappedTypeParameter() {
    const node = this.startNode();
    node.name = this.tsParseTypeParameterName();
    node.constraint = this.tsExpectThenParseType(58);
    return this.finishNode(node, "TSTypeParameter");
  }
  tsParseMappedType() {
    const node = this.startNode();
    this.expect(5);
    if (this.match(53)) {
      node.readonly = this.state.value;
      this.next();
      this.expectContextual(122);
    } else if (this.eatContextual(122)) {
      node.readonly = true;
    }
    this.expect(0);
    node.typeParameter = this.tsParseMappedTypeParameter();
    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
    this.expect(3);
    if (this.match(53)) {
      node.optional = this.state.value;
      this.next();
      this.expect(17);
    } else if (this.eat(17)) {
      node.optional = true;
    }
    node.typeAnnotation = this.tsTryParseType();
    this.semicolon();
    this.expect(8);
    return this.finishNode(node, "TSMappedType");
  }
  tsParseTupleType() {
    const node = this.startNode();
    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let seenOptionalElement = false;
    node.elementTypes.forEach((elementNode) => {
      const {
        type
      } = elementNode;
      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
        this.raise(TSErrors.OptionalTypeBeforeRequired, {
          at: elementNode
        });
      }
      seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
    });
    return this.finishNode(node, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc
    } = this.state;
    const rest = this.eat(21);
    let labeled;
    let label;
    let optional;
    let type;
    const isWord = tokenIsKeywordOrIdentifier(this.state.type);
    const chAfterWord = isWord ? this.lookaheadCharCode() : null;
    if (chAfterWord === 58) {
      labeled = true;
      optional = false;
      label = this.parseIdentifier(true);
      this.expect(14);
      type = this.tsParseType();
    } else if (chAfterWord === 63) {
      optional = true;
      const startLoc2 = this.state.startLoc;
      const wordName = this.state.value;
      const typeOrLabel = this.tsParseNonArrayType();
      if (this.lookaheadCharCode() === 58) {
        labeled = true;
        label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
        this.expect(17);
        this.expect(14);
        type = this.tsParseType();
      } else {
        labeled = false;
        type = typeOrLabel;
        this.expect(17);
      }
    } else {
      type = this.tsParseType();
      optional = this.eat(17);
      labeled = this.eat(14);
    }
    if (labeled) {
      let labeledNode;
      if (label) {
        labeledNode = this.startNodeAtNode(label);
        labeledNode.optional = optional;
        labeledNode.label = label;
        labeledNode.elementType = type;
        if (this.eat(17)) {
          labeledNode.optional = true;
          this.raise(TSErrors.TupleOptionalAfterType, {
            at: this.state.lastTokStartLoc
          });
        }
      } else {
        labeledNode = this.startNodeAtNode(type);
        labeledNode.optional = optional;
        this.raise(TSErrors.InvalidTupleMemberLabel, {
          at: type
        });
        labeledNode.label = type;
        labeledNode.elementType = this.tsParseType();
      }
      type = this.finishNode(labeledNode, "TSNamedTupleMember");
    } else if (optional) {
      const optionalTypeNode = this.startNodeAtNode(type);
      optionalTypeNode.typeAnnotation = type;
      type = this.finishNode(optionalTypeNode, "TSOptionalType");
    }
    if (rest) {
      const restNode = this.startNodeAt(startLoc);
      restNode.typeAnnotation = type;
      type = this.finishNode(restNode, "TSRestType");
    }
    return type;
  }
  tsParseParenthesizedType() {
    const node = this.startNode();
    this.expect(10);
    node.typeAnnotation = this.tsParseType();
    this.expect(11);
    return this.finishNode(node, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(type, abstract) {
    const node = this.startNode();
    if (type === "TSConstructorType") {
      node.abstract = !!abstract;
      if (abstract)
        this.next();
      this.next();
    }
    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
    return this.finishNode(node, type);
  }
  tsParseLiteralTypeNode() {
    const node = this.startNode();
    switch (this.state.type) {
      case 134:
      case 135:
      case 133:
      case 85:
      case 86:
        node.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(node, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const node = this.startNode();
    node.literal = super.parseTemplate(false);
    return this.finishNode(node, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    if (this.state.inType)
      return this.tsParseType();
    return super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const thisKeyword = this.tsParseThisTypeNode();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
      return this.tsParseThisTypePredicate(thisKeyword);
    } else {
      return thisKeyword;
    }
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 133:
      case 134:
      case 135:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const node = this.startNode();
          const nextToken = this.lookahead();
          if (nextToken.type !== 134 && nextToken.type !== 135) {
            this.unexpected();
          }
          node.literal = this.parseMaybeUnary();
          return this.finishNode(node, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type) || type === 88 || type === 84) {
          const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
          if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, nodeType);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let type = this.tsParseNonArrayType();
    while (!this.hasPrecedingLineBreak() && this.eat(0)) {
      if (this.match(3)) {
        const node = this.startNodeAtNode(type);
        node.elementType = type;
        this.expect(3);
        type = this.finishNode(node, "TSArrayType");
      } else {
        const node = this.startNodeAtNode(type);
        node.objectType = type;
        node.indexType = this.tsParseType();
        this.expect(3);
        type = this.finishNode(node, "TSIndexedAccessType");
      }
    }
    return type;
  }
  tsParseTypeOperator() {
    const node = this.startNode();
    const operator = this.state.value;
    this.next();
    node.operator = operator;
    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
    if (operator === "readonly") {
      this.tsCheckTypeAnnotationForReadOnly(node);
    }
    return this.finishNode(node, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(node) {
    switch (node.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(TSErrors.UnexpectedReadonly, {
          at: node
        });
    }
  }
  tsParseInferType() {
    const node = this.startNode();
    this.expectContextual(115);
    const typeParameter = this.startNode();
    typeParameter.name = this.tsParseTypeParameterName();
    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
    return this.finishNode(node, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
        return constraint;
      }
    }
  }
  tsParseTypeOperatorOrHigher() {
    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    const node = this.startNode();
    const hasLeadingOperator = this.eat(operator);
    const types4 = [];
    do {
      types4.push(parseConstituentType());
    } while (this.eat(operator));
    if (types4.length === 1 && !hasLeadingOperator) {
      return types4[0];
    }
    node.types = types4;
    return this.finishNode(node, kind);
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    if (this.match(47)) {
      return true;
    }
    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
      this.next();
      return true;
    }
    if (this.match(5)) {
      const {
        errors: errors2
      } = this.state;
      const previousErrorCount = errors2.length;
      try {
        this.parseObjectLike(8, true);
        return errors2.length === previousErrorCount;
      } catch (_unused) {
        return false;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: errors2
      } = this.state;
      const previousErrorCount = errors2.length;
      try {
        super.parseBindingList(3, 93, 1);
        return errors2.length === previousErrorCount;
      } catch (_unused2) {
        return false;
      }
    }
    return false;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    this.next();
    if (this.match(11) || this.match(21)) {
      return true;
    }
    if (this.tsSkipParameterStart()) {
      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
        return true;
      }
      if (this.match(11)) {
        this.next();
        if (this.match(19)) {
          return true;
        }
      }
    }
    return false;
  }
  tsParseTypeOrTypePredicateAnnotation(returnToken) {
    return this.tsInType(() => {
      const t2 = this.startNode();
      this.expect(returnToken);
      const node = this.startNode();
      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (asserts && this.match(78)) {
        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
        if (thisTypePredicate.type === "TSThisType") {
          node.parameterName = thisTypePredicate;
          node.asserts = true;
          node.typeAnnotation = null;
          thisTypePredicate = this.finishNode(node, "TSTypePredicate");
        } else {
          this.resetStartLocationFromNode(thisTypePredicate, node);
          thisTypePredicate.asserts = true;
        }
        t2.typeAnnotation = thisTypePredicate;
        return this.finishNode(t2, "TSTypeAnnotation");
      }
      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!typePredicateVariable) {
        if (!asserts) {
          return this.tsParseTypeAnnotation(false, t2);
        }
        node.parameterName = this.parseIdentifier();
        node.asserts = asserts;
        node.typeAnnotation = null;
        t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t2, "TSTypeAnnotation");
      }
      const type = this.tsParseTypeAnnotation(false);
      node.parameterName = typePredicateVariable;
      node.typeAnnotation = type;
      node.asserts = asserts;
      t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
      return this.finishNode(t2, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14)) {
      return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14)) {
      return this.tsParseTypeAnnotation();
    }
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const id = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
      this.next();
      return id;
    }
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109) {
      return false;
    }
    const containsEsc = this.state.containsEsc;
    this.next();
    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
      return false;
    }
    if (containsEsc) {
      this.raise(Errors.InvalidEscapedReservedWord, {
        at: this.state.lastTokStartLoc,
        reservedWord: "asserts"
      });
    }
    return true;
  }
  tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
    this.tsInType(() => {
      if (eatColon)
        this.expect(14);
      t2.typeAnnotation = this.tsParseType();
    });
    return this.finishNode(t2, "TSTypeAnnotation");
  }
  tsParseType() {
    assert$1(this.state.inType);
    const type = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
      return type;
    }
    const node = this.startNodeAtNode(type);
    node.checkType = type;
    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
    this.expect(17);
    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
    this.expect(14);
    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
    return this.finishNode(node, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    if (this.tsIsStartOfFunctionType()) {
      return this.tsParseFunctionOrConstructorType("TSFunctionType");
    }
    if (this.match(77)) {
      return this.tsParseFunctionOrConstructorType("TSConstructorType");
    } else if (this.isAbstractConstructorSignature()) {
      return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
    }
    return this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
      this.raise(TSErrors.ReservedTypeAssertion, {
        at: this.state.startLoc
      });
    }
    const node = this.startNode();
    node.typeAnnotation = this.tsInType(() => {
      this.next();
      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
    });
    this.expect(48);
    node.expression = this.parseMaybeUnary();
    return this.finishNode(node, "TSTypeAssertion");
  }
  tsParseHeritageClause(token2) {
    const originalStartLoc = this.state.startLoc;
    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const node = this.startNode();
      node.expression = this.tsParseEntityName();
      if (this.match(47)) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSExpressionWithTypeArguments");
    });
    if (!delimitedList.length) {
      this.raise(TSErrors.EmptyHeritageClauseType, {
        at: originalStartLoc,
        token: token2
      });
    }
    return delimitedList;
  }
  tsParseInterfaceDeclaration(node, properties = {}) {
    if (this.hasFollowingLineBreak())
      return null;
    this.expectContextual(129);
    if (properties.declare)
      node.declare = true;
    if (tokenIsIdentifier(this.state.type)) {
      node.id = this.parseIdentifier();
      this.checkIdentifier(node.id, 130);
    } else {
      node.id = null;
      this.raise(TSErrors.MissingInterfaceName, {
        at: this.state.startLoc
      });
    }
    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    if (this.eat(81)) {
      node.extends = this.tsParseHeritageClause("extends");
    }
    const body = this.startNode();
    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
    node.body = this.finishNode(body, "TSInterfaceBody");
    return this.finishNode(node, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(node) {
    node.id = this.parseIdentifier();
    this.checkIdentifier(node.id, 2);
    node.typeAnnotation = this.tsInType(() => {
      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
      this.expect(29);
      if (this.isContextual(114) && this.lookahead().type !== 16) {
        const node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    });
    this.semicolon();
    return this.finishNode(node, "TSTypeAliasDeclaration");
  }
  tsInNoContext(cb) {
    const oldContext = this.state.context;
    this.state.context = [oldContext[0]];
    try {
      return cb();
    } finally {
      this.state.context = oldContext;
    }
  }
  tsInType(cb) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    try {
      return cb();
    } finally {
      this.state.inType = oldInType;
    }
  }
  tsInDisallowConditionalTypesContext(cb) {
    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = true;
    try {
      return cb();
    } finally {
      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    }
  }
  tsInAllowConditionalTypesContext(cb) {
    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = false;
    try {
      return cb();
    } finally {
      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    }
  }
  tsEatThenParseType(token2) {
    if (this.match(token2)) {
      return this.tsNextThenParseType();
    }
  }
  tsExpectThenParseType(token2) {
    return this.tsInType(() => {
      this.expect(token2);
      return this.tsParseType();
    });
  }
  tsNextThenParseType() {
    return this.tsInType(() => {
      this.next();
      return this.tsParseType();
    });
  }
  tsParseEnumMember() {
    const node = this.startNode();
    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
    if (this.eat(29)) {
      node.initializer = super.parseMaybeAssignAllowIn();
    }
    return this.finishNode(node, "TSEnumMember");
  }
  tsParseEnumDeclaration(node, properties = {}) {
    if (properties.const)
      node.const = true;
    if (properties.declare)
      node.declare = true;
    this.expectContextual(126);
    node.id = this.parseIdentifier();
    this.checkIdentifier(node.id, node.const ? 8971 : 8459);
    this.expect(5);
    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
    this.expect(8);
    return this.finishNode(node, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const node = this.startNode();
    this.scope.enter(0);
    this.expect(5);
    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
    this.scope.exit();
    return this.finishNode(node, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
    node.id = this.parseIdentifier();
    if (!nested) {
      this.checkIdentifier(node.id, 1024);
    }
    if (this.eat(16)) {
      const inner = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(inner, true);
      node.body = inner;
    } else {
      this.scope.enter(256);
      this.prodParam.enter(PARAM);
      node.body = this.tsParseModuleBlock();
      this.prodParam.exit();
      this.scope.exit();
    }
    return this.finishNode(node, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(node) {
    if (this.isContextual(112)) {
      node.global = true;
      node.id = this.parseIdentifier();
    } else if (this.match(133)) {
      node.id = super.parseStringLiteral(this.state.value);
    } else {
      this.unexpected();
    }
    if (this.match(5)) {
      this.scope.enter(256);
      this.prodParam.enter(PARAM);
      node.body = this.tsParseModuleBlock();
      this.prodParam.exit();
      this.scope.exit();
    } else {
      this.semicolon();
    }
    return this.finishNode(node, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
    node.isExport = isExport || false;
    node.id = maybeDefaultIdentifier || this.parseIdentifier();
    this.checkIdentifier(node.id, 4096);
    this.expect(29);
    const moduleReference = this.tsParseModuleReference();
    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
      this.raise(TSErrors.ImportAliasHasImportType, {
        at: moduleReference
      });
    }
    node.moduleReference = moduleReference;
    this.semicolon();
    return this.finishNode(node, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
  }
  tsParseExternalModuleReference() {
    const node = this.startNode();
    this.expectContextual(119);
    this.expect(10);
    if (!this.match(133)) {
      this.unexpected();
    }
    node.expression = super.parseExprAtom();
    this.expect(11);
    this.sawUnambiguousESM = true;
    return this.finishNode(node, "TSExternalModuleReference");
  }
  tsLookAhead(f) {
    const state = this.state.clone();
    const res = f();
    this.state = state;
    return res;
  }
  tsTryParseAndCatch(f) {
    const result = this.tryParse((abort) => f() || abort());
    if (result.aborted || !result.node)
      return;
    if (result.error)
      this.state = result.failState;
    return result.node;
  }
  tsTryParse(f) {
    const state = this.state.clone();
    const result = f();
    if (result !== undefined && result !== false) {
      return result;
    }
    this.state = state;
  }
  tsTryParseDeclare(nany) {
    if (this.isLineTerminator()) {
      return;
    }
    let startType = this.state.type;
    let kind;
    if (this.isContextual(100)) {
      startType = 74;
      kind = "let";
    }
    return this.tsInAmbientContext(() => {
      switch (startType) {
        case 68:
          nany.declare = true;
          return super.parseFunctionStatement(nany, false, false);
        case 80:
          nany.declare = true;
          return this.parseClass(nany, true, false);
        case 126:
          return this.tsParseEnumDeclaration(nany, {
            declare: true
          });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(nany);
        case 75:
        case 74:
          if (!this.match(75) || !this.isLookaheadContextual("enum")) {
            nany.declare = true;
            return this.parseVarStatement(nany, kind || this.state.value, true);
          }
          this.expect(75);
          return this.tsParseEnumDeclaration(nany, {
            const: true,
            declare: true
          });
        case 129: {
          const result = this.tsParseInterfaceDeclaration(nany, {
            declare: true
          });
          if (result)
            return result;
        }
        default:
          if (tokenIsIdentifier(startType)) {
            return this.tsParseDeclaration(nany, this.state.value, true, null);
          }
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
  }
  tsParseExpressionStatement(node, expr, decorators) {
    switch (expr.name) {
      case "declare": {
        const declaration = this.tsTryParseDeclare(node);
        if (declaration) {
          declaration.declare = true;
        }
        return declaration;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(PARAM);
          const mod = node;
          mod.global = true;
          mod.id = expr;
          mod.body = this.tsParseModuleBlock();
          this.scope.exit();
          this.prodParam.exit();
          return this.finishNode(mod, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(node, expr.name, false, decorators);
    }
  }
  tsParseDeclaration(node, value, next, decorators) {
    switch (value) {
      case "abstract":
        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
          return this.tsParseAbstractDeclaration(node, decorators);
        }
        break;
      case "module":
        if (this.tsCheckLineTerminator(next)) {
          if (this.match(133)) {
            return this.tsParseAmbientExternalModuleDeclaration(node);
          } else if (tokenIsIdentifier(this.state.type)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
          return this.tsParseModuleOrNamespaceDeclaration(node);
        }
        break;
      case "type":
        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
          return this.tsParseTypeAliasDeclaration(node);
        }
        break;
    }
  }
  tsCheckLineTerminator(next) {
    if (next) {
      if (this.hasFollowingLineBreak())
        return false;
      this.next();
      return true;
    }
    return !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(startLoc) {
    if (!this.match(47))
      return;
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = true;
    const res = this.tsTryParseAndCatch(() => {
      const node = this.startNodeAt(startLoc);
      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
      super.parseFunctionParams(node);
      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
      this.expect(19);
      return node;
    });
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    if (!res)
      return;
    return super.parseArrowExpression(res, null, true);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() !== 47)
      return;
    return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const node = this.startNode();
    node.params = this.tsInType(() => this.tsInNoContext(() => {
      this.expect(47);
      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
    }));
    if (node.params.length === 0) {
      this.raise(TSErrors.EmptyTypeArguments, {
        at: node
      });
    } else if (!this.state.inType && this.curContext() === types$1.brace) {
      this.reScan_lt_gt();
    }
    this.expect(48);
    return this.finishNode(node, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return tokenIsTSDeclarationStart(this.state.type);
  }
  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart())
      return false;
    return super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(flags, decorators) {
    const startLoc = this.state.startLoc;
    const modified = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, modified);
    const accessibility = modified.accessibility;
    const override = modified.override;
    const readonly = modified.readonly;
    if (!(flags & 4) && (accessibility || readonly || override)) {
      this.raise(TSErrors.UnexpectedParameterModifier, {
        at: startLoc
      });
    }
    const left2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left2, flags);
    const elt = this.parseMaybeDefault(left2.loc.start, left2);
    if (accessibility || readonly || override) {
      const pp2 = this.startNodeAt(startLoc);
      if (decorators.length) {
        pp2.decorators = decorators;
      }
      if (accessibility)
        pp2.accessibility = accessibility;
      if (readonly)
        pp2.readonly = readonly;
      if (override)
        pp2.override = override;
      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
        this.raise(TSErrors.UnsupportedParameterPropertyKind, {
          at: pp2
        });
      }
      pp2.parameter = elt;
      return this.finishNode(pp2, "TSParameterProperty");
    }
    if (decorators.length) {
      left2.decorators = decorators;
    }
    return elt;
  }
  isSimpleParameter(node) {
    return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
  }
  tsDisallowOptionalPattern(node) {
    for (const param of node.params) {
      if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
        this.raise(TSErrors.PatternIsOptional, {
          at: param
        });
      }
    }
  }
  setArrowFunctionParameters(node, params, trailingCommaLoc) {
    super.setArrowFunctionParameters(node, params, trailingCommaLoc);
    this.tsDisallowOptionalPattern(node);
  }
  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(14)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
      return this.finishNode(node, bodilessType);
    }
    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
      this.raise(TSErrors.DeclareFunctionHasImplementation, {
        at: node
      });
      if (node.declare) {
        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
      }
    }
    this.tsDisallowOptionalPattern(node);
    return super.parseFunctionBodyAndFinish(node, type, isMethod);
  }
  registerFunctionStatementId(node) {
    if (!node.body && node.id) {
      this.checkIdentifier(node.id, 1024);
    } else {
      super.registerFunctionStatementId(node);
    }
  }
  tsCheckForInvalidTypeCasts(items) {
    items.forEach((node) => {
      if ((node == null ? undefined : node.type) === "TSTypeCastExpression") {
        this.raise(TSErrors.UnexpectedTypeAnnotation, {
          at: node.typeAnnotation
        });
      }
    });
  }
  toReferencedList(exprList, isInParens) {
    this.tsCheckForInvalidTypeCasts(exprList);
    return exprList;
  }
  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
    if (node.type === "ArrayExpression") {
      this.tsCheckForInvalidTypeCasts(node.elements);
    }
    return node;
  }
  parseSubscript(base, startLoc, noCalls, state) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = false;
      this.next();
      const nonNullExpression = this.startNodeAt(startLoc);
      nonNullExpression.expression = base;
      return this.finishNode(nonNullExpression, "TSNonNullExpression");
    }
    let isOptionalCall = false;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (noCalls) {
        state.stop = true;
        return base;
      }
      state.optionalChainMember = isOptionalCall = true;
      this.next();
    }
    if (this.match(47) || this.match(51)) {
      let missingParenErrorLoc;
      const result = this.tsTryParseAndCatch(() => {
        if (!noCalls && this.atPossibleAsyncArrow(base)) {
          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
          if (asyncArrowFn) {
            return asyncArrowFn;
          }
        }
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (!typeArguments)
          return;
        if (isOptionalCall && !this.match(10)) {
          missingParenErrorLoc = this.state.curPosition();
          return;
        }
        if (tokenIsTemplate(this.state.type)) {
          const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
          result2.typeParameters = typeArguments;
          return result2;
        }
        if (!noCalls && this.eat(10)) {
          const node2 = this.startNodeAt(startLoc);
          node2.callee = base;
          node2.arguments = this.parseCallExpressionArguments(11, false);
          this.tsCheckForInvalidTypeCasts(node2.arguments);
          node2.typeParameters = typeArguments;
          if (state.optionalChainMember) {
            node2.optional = isOptionalCall;
          }
          return this.finishCallExpression(node2, state.optionalChainMember);
        }
        const tokenType = this.state.type;
        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
          return;
        }
        const node = this.startNodeAt(startLoc);
        node.expression = base;
        node.typeParameters = typeArguments;
        return this.finishNode(node, "TSInstantiationExpression");
      });
      if (missingParenErrorLoc) {
        this.unexpected(missingParenErrorLoc, 10);
      }
      if (result) {
        if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
            at: this.state.startLoc
          });
        }
        return result;
      }
    }
    return super.parseSubscript(base, startLoc, noCalls, state);
  }
  parseNewCallee(node) {
    var _callee$extra;
    super.parseNewCallee(node);
    const {
      callee
    } = node;
    if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
      node.typeParameters = callee.typeParameters;
      node.callee = callee.expression;
    }
  }
  parseExprOp(left2, leftStartLoc, minPrec) {
    let isSatisfies;
    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
      const node = this.startNodeAt(leftStartLoc);
      node.expression = left2;
      node.typeAnnotation = this.tsInType(() => {
        this.next();
        if (this.match(75)) {
          if (isSatisfies) {
            this.raise(Errors.UnexpectedKeyword, {
              at: this.state.startLoc,
              keyword: "const"
            });
          }
          return this.tsParseTypeReference();
        }
        return this.tsParseType();
      });
      this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
      this.reScan_lt_gt();
      return this.parseExprOp(node, leftStartLoc, minPrec);
    }
    return super.parseExprOp(left2, leftStartLoc, minPrec);
  }
  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (!this.state.isAmbientContext) {
      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
  }
  checkImportReflection(node) {
    super.checkImportReflection(node);
    if (node.module && node.importKind !== "value") {
      this.raise(TSErrors.ImportReflectionHasImportType, {
        at: node.specifiers[0].loc.start
      });
    }
  }
  checkDuplicateExports() {}
  isPotentialImportPhase(isExport) {
    if (super.isPotentialImportPhase(isExport))
      return true;
    if (this.isContextual(130)) {
      const ch = this.lookaheadCharCode();
      return isExport ? ch === 123 || ch === 42 : ch !== 61;
    }
    return !isExport && this.isContextual(87);
  }
  applyImportPhase(node, isExport, phase, loc) {
    super.applyImportPhase(node, isExport, phase, loc);
    if (isExport) {
      node.exportKind = phase === "type" ? "type" : "value";
    } else {
      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
  }
  parseImport(node) {
    if (this.match(133)) {
      node.importKind = "value";
      return super.parseImport(node);
    }
    let importNode;
    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
      node.importKind = "value";
      return this.tsParseImportEqualsDeclaration(node);
    } else if (this.isContextual(130)) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
      if (this.lookaheadCharCode() === 61) {
        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
      } else {
        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
      }
    } else {
      importNode = super.parseImport(node);
    }
    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
        at: importNode
      });
    }
    return importNode;
  }
  parseExport(node, decorators) {
    if (this.match(83)) {
      this.next();
      let maybeDefaultIdentifier = null;
      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
      } else {
        node.importKind = "value";
      }
      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
    } else if (this.eat(29)) {
      const assign = node;
      assign.expression = super.parseExpression();
      this.semicolon();
      this.sawUnambiguousESM = true;
      return this.finishNode(assign, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const decl = node;
      this.expectContextual(128);
      decl.id = this.parseIdentifier();
      this.semicolon();
      return this.finishNode(decl, "TSNamespaceExportDeclaration");
    } else {
      return super.parseExport(node, decorators);
    }
  }
  isAbstractClass() {
    return this.isContextual(124) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const cls = this.startNode();
      this.next();
      cls.abstract = true;
      return this.parseClass(cls, true, true);
    }
    if (this.match(129)) {
      const result = this.tsParseInterfaceDeclaration(this.startNode());
      if (result)
        return result;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(node, kind, allowMissingInitializer = false) {
    const {
      isAmbientContext
    } = this.state;
    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
    if (!isAmbientContext)
      return declaration;
    for (const {
      id,
      init
    } of declaration.declarations) {
      if (!init)
        continue;
      if (kind !== "const" || !!id.typeAnnotation) {
        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
          at: init
        });
      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
          at: init
        });
      }
    }
    return declaration;
  }
  parseStatementContent(flags, decorators) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const node = this.startNode();
      this.expect(75);
      return this.tsParseEnumDeclaration(node, {
        const: true
      });
    }
    if (this.isContextual(126)) {
      return this.tsParseEnumDeclaration(this.startNode());
    }
    if (this.isContextual(129)) {
      const result = this.tsParseInterfaceDeclaration(this.startNode());
      if (result)
        return result;
    }
    return super.parseStatementContent(flags, decorators);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(member, modifiers) {
    return modifiers.some((modifier) => {
      if (tsIsAccessModifier(modifier)) {
        return member.accessibility === modifier;
      }
      return !!member[modifier];
    });
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(classBody, member, state) {
    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: modifiers,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: true,
      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    }, member);
    const callParseClassMemberWithIsStatic = () => {
      if (this.tsIsStartOfStaticBlocks()) {
        this.next();
        this.next();
        if (this.tsHasSomeModifiers(member, modifiers)) {
          this.raise(TSErrors.StaticBlockCannotHaveModifier, {
            at: this.state.curPosition()
          });
        }
        super.parseClassStaticBlock(classBody, member);
      } else {
        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
      }
    };
    if (member.declare) {
      this.tsInAmbientContext(callParseClassMemberWithIsStatic);
    } else {
      callParseClassMemberWithIsStatic();
    }
  }
  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const idx = this.tsTryParseIndexSignature(member);
    if (idx) {
      classBody.body.push(idx);
      if (member.abstract) {
        this.raise(TSErrors.IndexSignatureHasAbstract, {
          at: member
        });
      }
      if (member.accessibility) {
        this.raise(TSErrors.IndexSignatureHasAccessibility, {
          at: member,
          modifier: member.accessibility
        });
      }
      if (member.declare) {
        this.raise(TSErrors.IndexSignatureHasDeclare, {
          at: member
        });
      }
      if (member.override) {
        this.raise(TSErrors.IndexSignatureHasOverride, {
          at: member
        });
      }
      return;
    }
    if (!this.state.inAbstractClass && member.abstract) {
      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
        at: member
      });
    }
    if (member.override) {
      if (!state.hadSuperClass) {
        this.raise(TSErrors.OverrideNotInSubClass, {
          at: member
        });
      }
    }
    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }
  parsePostMemberNameModifiers(methodOrProp) {
    const optional = this.eat(17);
    if (optional)
      methodOrProp.optional = true;
    if (methodOrProp.readonly && this.match(10)) {
      this.raise(TSErrors.ClassMethodHasReadonly, {
        at: methodOrProp
      });
    }
    if (methodOrProp.declare && this.match(10)) {
      this.raise(TSErrors.ClassMethodHasDeclare, {
        at: methodOrProp
      });
    }
  }
  parseExpressionStatement(node, expr, decorators) {
    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
    return decl || super.parseExpressionStatement(node, expr, decorators);
  }
  shouldParseExportDeclaration() {
    if (this.tsIsDeclarationStart())
      return true;
    return super.shouldParseExportDeclaration();
  }
  parseConditional(expr, startLoc, refExpressionErrors) {
    if (!this.state.maybeInArrowParameters || !this.match(17)) {
      return super.parseConditional(expr, startLoc, refExpressionErrors);
    }
    const result = this.tryParse(() => super.parseConditional(expr, startLoc));
    if (!result.node) {
      if (result.error) {
        super.setOptionalParametersError(refExpressionErrors, result.error);
      }
      return expr;
    }
    if (result.error)
      this.state = result.failState;
    return result.node;
  }
  parseParenItem(node, startLoc) {
    node = super.parseParenItem(node, startLoc);
    if (this.eat(17)) {
      node.optional = true;
      this.resetEndLocation(node);
    }
    if (this.match(14)) {
      const typeCastNode = this.startNodeAt(startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TSTypeCastExpression");
    }
    return node;
  }
  parseExportDeclaration(node) {
    if (!this.state.isAmbientContext && this.isContextual(125)) {
      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
    }
    const startLoc = this.state.startLoc;
    const isDeclare = this.eatContextual(125);
    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
        at: this.state.startLoc
      });
    }
    const isIdentifier = tokenIsIdentifier(this.state.type);
    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
    if (!declaration)
      return null;
    if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
      node.exportKind = "type";
    }
    if (isDeclare) {
      this.resetStartLocation(declaration, startLoc);
      declaration.declare = true;
    }
    return declaration;
  }
  parseClassId(node, isStatement, optionalId, bindingType) {
    if ((!isStatement || optionalId) && this.isContextual(113)) {
      return;
    }
    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    if (typeParameters)
      node.typeParameters = typeParameters;
  }
  parseClassPropertyAnnotation(node) {
    if (!node.optional) {
      if (this.eat(35)) {
        node.definite = true;
      } else if (this.eat(17)) {
        node.optional = true;
      }
    }
    const type = this.tsTryParseTypeAnnotation();
    if (type)
      node.typeAnnotation = type;
  }
  parseClassProperty(node) {
    this.parseClassPropertyAnnotation(node);
    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
      this.raise(TSErrors.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      });
    }
    if (node.abstract && this.match(29)) {
      const {
        key
      } = node;
      this.raise(TSErrors.AbstractPropertyHasInitializer, {
        at: this.state.startLoc,
        propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
      });
    }
    return super.parseClassProperty(node);
  }
  parseClassPrivateProperty(node) {
    if (node.abstract) {
      this.raise(TSErrors.PrivateElementHasAbstract, {
        at: node
      });
    }
    if (node.accessibility) {
      this.raise(TSErrors.PrivateElementHasAccessibility, {
        at: node,
        modifier: node.accessibility
      });
    }
    this.parseClassPropertyAnnotation(node);
    return super.parseClassPrivateProperty(node);
  }
  parseClassAccessorProperty(node) {
    this.parseClassPropertyAnnotation(node);
    if (node.optional) {
      this.raise(TSErrors.AccessorCannotBeOptional, {
        at: node
      });
    }
    return super.parseClassAccessorProperty(node);
  }
  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    if (typeParameters && isConstructor) {
      this.raise(TSErrors.ConstructorHasTypeParameters, {
        at: typeParameters
      });
    }
    const {
      declare = false,
      kind
    } = method;
    if (declare && (kind === "get" || kind === "set")) {
      this.raise(TSErrors.DeclareAccessor, {
        at: method,
        kind
      });
    }
    if (typeParameters)
      method.typeParameters = typeParameters;
    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
  }
  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    if (typeParameters)
      method.typeParameters = typeParameters;
    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }
  declareClassPrivateMethodInScope(node, kind) {
    if (node.type === "TSDeclareMethod")
      return;
    if (node.type === "MethodDefinition" && !node.value.body)
      return;
    super.declareClassPrivateMethodInScope(node, kind);
  }
  parseClassSuper(node) {
    super.parseClassSuper(node);
    if (node.superClass && (this.match(47) || this.match(51))) {
      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
    }
    if (this.eatContextual(113)) {
      node.implements = this.tsParseHeritageClause("implements");
    }
  }
  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    if (typeParameters)
      prop.typeParameters = typeParameters;
    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
  }
  parseFunctionParams(node, isConstructor) {
    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    if (typeParameters)
      node.typeParameters = typeParameters;
    super.parseFunctionParams(node, isConstructor);
  }
  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);
    if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
      decl.definite = true;
    }
    const type = this.tsTryParseTypeAnnotation();
    if (type) {
      decl.id.typeAnnotation = type;
      this.resetEndLocation(decl.id);
    }
  }
  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(14)) {
      node.returnType = this.tsParseTypeAnnotation();
    }
    return super.parseAsyncArrowFromCallExpression(node, call);
  }
  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
    let state;
    let jsx2;
    let typeCast;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      state = this.state.clone();
      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
      if (!jsx2.error)
        return jsx2.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];
      if (currentContext === types$1.j_oTag || currentContext === types$1.j_expr) {
        context.pop();
      }
    }
    if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    if (!state || state === this.state)
      state = this.state.clone();
    let typeParameters;
    const arrow = this.tryParse((abort) => {
      var _expr$extra, _typeParameters;
      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
        abort();
      }
      if (((_typeParameters = typeParameters) == null ? undefined : _typeParameters.params.length) !== 0) {
        this.resetStartLocationFromNode(expr, typeParameters);
      }
      expr.typeParameters = typeParameters;
      return expr;
    }, state);
    if (!arrow.error && !arrow.aborted) {
      if (typeParameters)
        this.reportReservedArrowTypeParam(typeParameters);
      return arrow.node;
    }
    if (!jsx2) {
      assert$1(!this.hasPlugin("jsx"));
      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
      if (!typeCast.error)
        return typeCast.node;
    }
    if ((_jsx2 = jsx2) != null && _jsx2.node) {
      this.state = jsx2.failState;
      return jsx2.node;
    }
    if (arrow.node) {
      this.state = arrow.failState;
      if (typeParameters)
        this.reportReservedArrowTypeParam(typeParameters);
      return arrow.node;
    }
    if ((_typeCast = typeCast) != null && _typeCast.node) {
      this.state = typeCast.failState;
      return typeCast.node;
    }
    throw ((_jsx3 = jsx2) == null ? undefined : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? undefined : _typeCast2.error);
  }
  reportReservedArrowTypeParam(node) {
    var _node$extra;
    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
      this.raise(TSErrors.ReservedArrowTypeParam, {
        at: node
      });
    }
  }
  parseMaybeUnary(refExpressionErrors, sawUnary) {
    if (!this.hasPlugin("jsx") && this.match(47)) {
      return this.tsParseTypeAssertion();
    }
    return super.parseMaybeUnary(refExpressionErrors, sawUnary);
  }
  parseArrow(node) {
    if (this.match(14)) {
      const result = this.tryParse((abort) => {
        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        if (this.canInsertSemicolon() || !this.match(19))
          abort();
        return returnType;
      });
      if (result.aborted)
        return;
      if (!result.thrown) {
        if (result.error)
          this.state = result.failState;
        node.returnType = result.node;
      }
    }
    return super.parseArrow(node);
  }
  parseAssignableListItemTypes(param, flags) {
    if (!(flags & 2))
      return param;
    if (this.eat(17)) {
      param.optional = true;
    }
    const type = this.tsTryParseTypeAnnotation();
    if (type)
      param.typeAnnotation = type;
    this.resetEndLocation(param);
    return param;
  }
  isAssignable(node, isBinding) {
    switch (node.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(node.expression, isBinding);
      case "TSParameterProperty":
        return true;
      default:
        return super.isAssignable(node, isBinding);
    }
  }
  toAssignable(node, isLHS = false) {
    switch (node.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(node, isLHS);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        if (isLHS) {
          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
            at: node
          });
        } else {
          this.raise(TSErrors.UnexpectedTypeCastInParameter, {
            at: node
          });
        }
        this.toAssignable(node.expression, isLHS);
        break;
      case "AssignmentExpression":
        if (!isLHS && node.left.type === "TSTypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
      default:
        super.toAssignable(node, isLHS);
    }
  }
  toAssignableParenthesizedExpression(node, isLHS) {
    switch (node.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isLHS);
        break;
      default:
        super.toAssignable(node, isLHS);
    }
  }
  checkToRestConversion(node, allowPattern) {
    switch (node.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(node.expression, false);
        break;
      default:
        super.checkToRestConversion(node, allowPattern);
    }
  }
  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    return getOwn({
      TSTypeCastExpression: true,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
  }
  parseBindingAtom() {
    if (this.state.type === 78) {
      return this.parseIdentifier(true);
    }
    return super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(expr) {
    if (this.match(47) || this.match(51)) {
      const typeArguments = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const call = super.parseMaybeDecoratorArguments(expr);
        call.typeParameters = typeArguments;
        return call;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(expr);
  }
  checkCommaAfterRest(close) {
    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
      this.next();
      return false;
    }
    return super.checkCommaAfterRest(close);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(startLoc, left2) {
    const node = super.parseMaybeDefault(startLoc, left2);
    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(TSErrors.TypeAnnotationAfterAssign, {
        at: node.typeAnnotation
      });
    }
    return node;
  }
  getTokenFromCode(code) {
    if (this.state.inType) {
      if (code === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (code === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(code);
  }
  reScan_lt_gt() {
    const {
      type
    } = this.state;
    if (type === 47) {
      this.state.pos -= 1;
      this.readToken_lt();
    } else if (type === 48) {
      this.state.pos -= 1;
      this.readToken_gt();
    }
  }
  reScan_lt() {
    const {
      type
    } = this.state;
    if (type === 51) {
      this.state.pos -= 2;
      this.finishOp(47, 1);
      return 47;
    }
    return type;
  }
  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    for (let i = 0;i < exprList.length; i++) {
      const expr = exprList[i];
      if ((expr == null ? undefined : expr.type) === "TSTypeCastExpression") {
        exprList[i] = this.typeCastToParameter(expr);
      }
    }
    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
  }
  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
    return node.expression;
  }
  shouldParseArrow(params) {
    if (this.match(14)) {
      return params.every((expr) => this.isAssignable(expr, true));
    }
    return super.shouldParseArrow(params);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(node) {
    if (this.match(47) || this.match(51)) {
      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      if (typeArguments)
        node.typeParameters = typeArguments;
    }
    return super.jsxParseOpeningElementAfterName(node);
  }
  getGetterSetterExpectedParamCount(method) {
    const baseCount = super.getGetterSetterExpectedParamCount(method);
    const params = this.getObjectOrClassMethodParams(method);
    const firstParam = params[0];
    const hasContextParam = firstParam && this.isThisParam(firstParam);
    return hasContextParam ? baseCount + 1 : baseCount;
  }
  parseCatchClauseParam() {
    const param = super.parseCatchClauseParam();
    const type = this.tsTryParseTypeAnnotation();
    if (type) {
      param.typeAnnotation = type;
      this.resetEndLocation(param);
    }
    return param;
  }
  tsInAmbientContext(cb) {
    const oldIsAmbientContext = this.state.isAmbientContext;
    this.state.isAmbientContext = true;
    try {
      return cb();
    } finally {
      this.state.isAmbientContext = oldIsAmbientContext;
    }
  }
  parseClass(node, isStatement, optionalId) {
    const oldInAbstractClass = this.state.inAbstractClass;
    this.state.inAbstractClass = !!node.abstract;
    try {
      return super.parseClass(node, isStatement, optionalId);
    } finally {
      this.state.inAbstractClass = oldInAbstractClass;
    }
  }
  tsParseAbstractDeclaration(node, decorators) {
    if (this.match(80)) {
      node.abstract = true;
      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
    } else if (this.isContextual(129)) {
      if (!this.hasFollowingLineBreak()) {
        node.abstract = true;
        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
          at: node
        });
        return this.tsParseInterfaceDeclaration(node);
      }
    } else {
      this.unexpected(null, 80);
    }
  }
  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
    if (method.abstract) {
      const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
      if (hasBody) {
        const {
          key
        } = method;
        this.raise(TSErrors.AbstractMethodHasImplementation, {
          at: method,
          methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
        });
      }
    }
    return method;
  }
  tsParseTypeParameterName() {
    const typeName = this.parseIdentifier();
    return typeName.name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    if (this.shouldParseAsAmbientContext()) {
      this.state.isAmbientContext = true;
    }
    return super.parse();
  }
  getExpression() {
    if (this.shouldParseAsAmbientContext()) {
      this.state.isAmbientContext = true;
    }
    return super.getExpression();
  }
  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
    if (!isString && isMaybeTypeOnly) {
      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
      return this.finishNode(node, "ExportSpecifier");
    }
    node.exportKind = "value";
    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
  }
  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    if (!importedIsString && isMaybeTypeOnly) {
      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
      return this.finishNode(specifier, "ImportSpecifier");
    }
    specifier.importKind = "value";
    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
  }
  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
    const leftOfAsKey = isImport ? "imported" : "local";
    const rightOfAsKey = isImport ? "local" : "exported";
    let leftOfAs = node[leftOfAsKey];
    let rightOfAs;
    let hasTypeSpecifier = false;
    let canParseAsKeyword = true;
    const loc = leftOfAs.loc.start;
    if (this.isContextual(93)) {
      const firstAs = this.parseIdentifier();
      if (this.isContextual(93)) {
        const secondAs = this.parseIdentifier();
        if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          canParseAsKeyword = false;
        } else {
          rightOfAs = secondAs;
          canParseAsKeyword = false;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        canParseAsKeyword = false;
        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
      } else {
        hasTypeSpecifier = true;
        leftOfAs = firstAs;
      }
    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
      hasTypeSpecifier = true;
      if (isImport) {
        leftOfAs = this.parseIdentifier(true);
        if (!this.isContextual(93)) {
          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
        }
      } else {
        leftOfAs = this.parseModuleExportName();
      }
    }
    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
        at: loc
      });
    }
    node[leftOfAsKey] = leftOfAs;
    node[rightOfAsKey] = rightOfAs;
    const kindKey = isImport ? "importKind" : "exportKind";
    node[kindKey] = hasTypeSpecifier ? "type" : "value";
    if (canParseAsKeyword && this.eatContextual(93)) {
      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
    }
    if (!node[rightOfAsKey]) {
      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
    }
    if (isImport) {
      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
    }
  }
};
function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression")
    return false;
  const {
    computed: computed3,
    property
  } = expression;
  if (computed3 && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
function isValidAmbientConstInitializer(expression, estree2) {
  var _expression$extra;
  const {
    type
  } = expression;
  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
    return false;
  }
  if (estree2) {
    if (type === "Literal") {
      const {
        value
      } = expression;
      if (typeof value === "string" || typeof value === "boolean") {
        return true;
      }
    }
  } else {
    if (type === "StringLiteral" || type === "BooleanLiteral") {
      return true;
    }
  }
  if (isNumber$12(expression, estree2) || isNegativeNumber(expression, estree2)) {
    return true;
  }
  if (type === "TemplateLiteral" && expression.expressions.length === 0) {
    return true;
  }
  if (isPossiblyLiteralEnum(expression)) {
    return true;
  }
  return false;
}
function isNumber$12(expression, estree2) {
  if (estree2) {
    return expression.type === "Literal" && (typeof expression.value === "number" || ("bigint" in expression));
  }
  return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
}
function isNegativeNumber(expression, estree2) {
  if (expression.type === "UnaryExpression") {
    const {
      operator,
      argument
    } = expression;
    if (operator === "-" && isNumber$12(argument, estree2)) {
      return true;
    }
  }
  return false;
}
function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier")
    return true;
  if (expression.type !== "MemberExpression" || expression.computed) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
var PlaceholderErrors = ParseErrorEnum`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
  parsePlaceholder(expectedNode) {
    if (this.match(144)) {
      const node = this.startNode();
      this.next();
      this.assertNoSpace();
      node.name = super.parseIdentifier(true);
      this.assertNoSpace();
      this.expect(144);
      return this.finishPlaceholder(node, expectedNode);
    }
  }
  finishPlaceholder(node, expectedNode) {
    const isFinished = !!(node.expectedNode && node.type === "Placeholder");
    node.expectedNode = expectedNode;
    return isFinished ? node : this.finishNode(node, "Placeholder");
  }
  getTokenFromCode(code) {
    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
      this.finishOp(144, 2);
    } else {
      super.getTokenFromCode(code);
    }
  }
  parseExprAtom(refExpressionErrors) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
  }
  parseIdentifier(liberal) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
  }
  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (word !== undefined) {
      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(type, isParenthesized, binding) {
    return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
  }
  toAssignable(node, isLHS) {
    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
      node.expectedNode = "Pattern";
    } else {
      super.toAssignable(node, isLHS);
    }
  }
  chStartsBindingIdentifier(ch, pos) {
    if (super.chStartsBindingIdentifier(ch, pos)) {
      return true;
    }
    const nextToken = this.lookahead();
    if (nextToken.type === 144) {
      return true;
    }
    return false;
  }
  verifyBreakContinue(node, isBreak) {
    if (node.label && node.label.type === "Placeholder")
      return;
    super.verifyBreakContinue(node, isBreak);
  }
  parseExpressionStatement(node, expr) {
    var _expr$extra;
    if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
      return super.parseExpressionStatement(node, expr);
    }
    if (this.match(14)) {
      const stmt = node;
      stmt.label = this.finishPlaceholder(expr, "Identifier");
      this.next();
      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
      return this.finishNode(stmt, "LabeledStatement");
    }
    this.semicolon();
    node.name = expr.name;
    return this.finishPlaceholder(node, "Statement");
  }
  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
  }
  parseFunctionId(requireId) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
  }
  parseClass(node, isStatement, optionalId) {
    const type = isStatement ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const oldStrict = this.state.strict;
    const placeholder = this.parsePlaceholder("Identifier");
    if (placeholder) {
      if (this.match(81) || this.match(144) || this.match(5)) {
        node.id = placeholder;
      } else if (optionalId || !isStatement) {
        node.id = null;
        node.body = this.finishPlaceholder(placeholder, "ClassBody");
        return this.finishNode(node, type);
      } else {
        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
          at: this.state.startLoc
        });
      }
    } else {
      this.parseClassId(node, isStatement, optionalId);
    }
    super.parseClassSuper(node);
    node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
    return this.finishNode(node, type);
  }
  parseExport(node, decorators) {
    const placeholder = this.parsePlaceholder("Identifier");
    if (!placeholder)
      return super.parseExport(node, decorators);
    if (!this.isContextual(98) && !this.match(12)) {
      node.specifiers = [];
      node.source = null;
      node.declaration = this.finishPlaceholder(placeholder, "Declaration");
      return this.finishNode(node, "ExportNamedDeclaration");
    }
    this.expectPlugin("exportDefaultFrom");
    const specifier = this.startNode();
    specifier.exported = placeholder;
    node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
    return super.parseExport(node, decorators);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const next = this.nextTokenStart();
      if (this.isUnparsedContextual(next, "from")) {
        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
          return true;
        }
      }
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
    var _specifiers;
    if ((_specifiers = node.specifiers) != null && _specifiers.length) {
      return true;
    }
    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
  }
  checkExport(node) {
    const {
      specifiers
    } = node;
    if (specifiers != null && specifiers.length) {
      node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
    }
    super.checkExport(node);
    node.specifiers = specifiers;
  }
  parseImport(node) {
    const placeholder = this.parsePlaceholder("Identifier");
    if (!placeholder)
      return super.parseImport(node);
    node.specifiers = [];
    if (!this.isContextual(98) && !this.match(12)) {
      node.source = this.finishPlaceholder(placeholder, "StringLiteral");
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
    const specifier = this.startNodeAtNode(placeholder);
    specifier.local = placeholder;
    node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
    if (this.eat(12)) {
      const hasStarImport = this.maybeParseStarImportSpecifier(node);
      if (!hasStarImport)
        this.parseNamedImportSpecifiers(node);
    }
    this.expectContextual(98);
    node.source = this.parseImportSource();
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    if (this.state.start > this.state.lastTokEndLoc.index) {
      this.raise(PlaceholderErrors.UnexpectedSpace, {
        at: this.state.lastTokEndLoc
      });
    }
  }
};
var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const v8IntrinsicStartLoc = this.state.startLoc;
      const node = this.startNode();
      this.next();
      if (tokenIsIdentifier(this.state.type)) {
        const name3 = this.parseIdentifierName();
        const identifier = this.createIdentifier(node, name3);
        identifier.type = "V8IntrinsicIdentifier";
        if (this.match(10)) {
          return identifier;
        }
      }
      this.unexpected(v8IntrinsicStartLoc);
    }
  }
  parseExprAtom(refExpressionErrors) {
    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
  }
};
function hasPlugin(plugins, expectedConfig) {
  const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
  const expectedKeys = Object.keys(expectedOptions);
  const expectedOptionsIsEmpty = expectedKeys.length === 0;
  return plugins.some((p2) => {
    if (typeof p2 === "string") {
      return expectedOptionsIsEmpty && p2 === expectedName;
    } else {
      const [pluginName, pluginOptions] = p2;
      if (pluginName !== expectedName) {
        return false;
      }
      for (const key of expectedKeys) {
        if (pluginOptions[key] !== expectedOptions[key]) {
          return false;
        }
      }
      return true;
    }
  });
}
function getPluginOption(plugins, name3, option2) {
  const plugin = plugins.find((plugin2) => {
    if (Array.isArray(plugin2)) {
      return plugin2[0] === name3;
    } else {
      return plugin2 === name3;
    }
  });
  if (plugin && Array.isArray(plugin) && plugin.length > 1) {
    return plugin[1][option2];
  }
  return null;
}
var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }
    const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    }
    const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
      throw new Error("'allowCallParenthesized' must be a boolean.");
    }
  }
  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }
  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }
  if (hasPlugin(plugins, "pipelineOperator")) {
    const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
    if (!PIPELINE_PROPOSALS.includes(proposal)) {
      const proposalList = PIPELINE_PROPOSALS.map((p2) => `"${p2}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
    }
    const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
      syntaxType: "hash"
    }]);
    if (proposal === "hack") {
      if (hasPlugin(plugins, "placeholders")) {
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      }
      if (hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      }
      const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
      if (!TOPIC_TOKENS.includes(topicToken)) {
        const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
      }
      if (topicToken === "#" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    } else if (proposal === "smart" && tupleSyntaxIsHash) {
      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
  }
  if (hasPlugin(plugins, "moduleAttributes")) {
    {
      if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      }
      const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
      if (moduleAttributesVersionPluginOption !== "may-2020") {
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
      }
    }
  }
  if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  }
  if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p2) => `'${p2}'`).join(", "));
  }
  if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
    const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    error.missingPlugins = "doExpressions";
    throw error;
  }
  if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is '2023-07'.");
  }
}
var mixinPlugins = {
  estree,
  jsx,
  flow,
  typescript,
  v8intrinsic,
  placeholders
};
var mixinPluginNames = Object.keys(mixinPlugins);
var defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowNewTargetOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createImportExpressions: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true,
  annexB: true
};
function getOptions(opts) {
  if (opts == null) {
    return Object.assign({}, defaultOptions);
  }
  if (opts.annexB != null && opts.annexB !== false) {
    throw new Error("The `annexB` option can only be set to `false`.");
  }
  const options3 = {};
  for (const key of Object.keys(defaultOptions)) {
    var _opts$key;
    options3[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
  }
  return options3;
}

class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return;
    }
    const key = prop.key;
    const name3 = key.type === "Identifier" ? key.name : key.value;
    if (name3 === "__proto__") {
      if (isRecord) {
        this.raise(Errors.RecordNoProto, {
          at: key
        });
        return;
      }
      if (protoRef.used) {
        if (refExpressionErrors) {
          if (refExpressionErrors.doubleProtoLoc === null) {
            refExpressionErrors.doubleProtoLoc = key.loc.start;
          }
        } else {
          this.raise(Errors.DuplicateProto, {
            at: key
          });
        }
      }
      protoRef.used = true;
    }
  }
  shouldExitDescending(expr, potentialArrowAt) {
    return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
  }
  getExpression() {
    this.enterInitialScopes();
    this.nextToken();
    const expr = this.parseExpression();
    if (!this.match(139)) {
      this.unexpected();
    }
    this.finalizeRemainingComments();
    expr.comments = this.state.comments;
    expr.errors = this.state.errors;
    if (this.options.tokens) {
      expr.tokens = this.tokens;
    }
    return expr;
  }
  parseExpression(disallowIn, refExpressionErrors) {
    if (disallowIn) {
      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
  }
  parseExpressionBase(refExpressionErrors) {
    const startLoc = this.state.startLoc;
    const expr = this.parseMaybeAssign(refExpressionErrors);
    if (this.match(12)) {
      const node = this.startNodeAt(startLoc);
      node.expressions = [expr];
      while (this.eat(12)) {
        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
      }
      this.toReferencedList(node.expressions);
      return this.finishNode(node, "SequenceExpression");
    }
    return expr;
  }
  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
  }
  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
  }
  setOptionalParametersError(refExpressionErrors, resultError) {
    var _resultError$loc;
    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? undefined : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
  }
  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    const startLoc = this.state.startLoc;
    if (this.isContextual(108)) {
      if (this.prodParam.hasYield) {
        let left3 = this.parseYield();
        if (afterLeftParse) {
          left3 = afterLeftParse.call(this, left3, startLoc);
        }
        return left3;
      }
    }
    let ownExpressionErrors;
    if (refExpressionErrors) {
      ownExpressionErrors = false;
    } else {
      refExpressionErrors = new ExpressionErrors;
      ownExpressionErrors = true;
    }
    const {
      type
    } = this.state;
    if (type === 10 || tokenIsIdentifier(type)) {
      this.state.potentialArrowAt = this.state.start;
    }
    let left2 = this.parseMaybeConditional(refExpressionErrors);
    if (afterLeftParse) {
      left2 = afterLeftParse.call(this, left2, startLoc);
    }
    if (tokenIsAssignment(this.state.type)) {
      const node = this.startNodeAt(startLoc);
      const operator = this.state.value;
      node.operator = operator;
      if (this.match(29)) {
        this.toAssignable(left2, true);
        node.left = left2;
        const startIndex = startLoc.index;
        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
          refExpressionErrors.doubleProtoLoc = null;
        }
        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
          refExpressionErrors.shorthandAssignLoc = null;
        }
        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
          this.checkDestructuringPrivate(refExpressionErrors);
          refExpressionErrors.privateKeyLoc = null;
        }
      } else {
        node.left = left2;
      }
      this.next();
      node.right = this.parseMaybeAssign();
      this.checkLVal(left2, {
        in: this.finishNode(node, "AssignmentExpression")
      });
      return node;
    } else if (ownExpressionErrors) {
      this.checkExpressionErrors(refExpressionErrors, true);
    }
    return left2;
  }
  parseMaybeConditional(refExpressionErrors) {
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprOps(refExpressionErrors);
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr;
    }
    return this.parseConditional(expr, startLoc, refExpressionErrors);
  }
  parseConditional(expr, startLoc, refExpressionErrors) {
    if (this.eat(17)) {
      const node = this.startNodeAt(startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssignAllowIn();
      this.expect(14);
      node.alternate = this.parseMaybeAssign();
      return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
  }
  parseMaybeUnaryOrPrivate(refExpressionErrors) {
    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
  }
  parseExprOps(refExpressionErrors) {
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr;
    }
    return this.parseExprOp(expr, startLoc, -1);
  }
  parseExprOp(left2, leftStartLoc, minPrec) {
    if (this.isPrivateName(left2)) {
      const value = this.getPrivateNameSV(left2);
      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(Errors.PrivateInExpectedIn, {
          at: left2,
          identifierName: value
        });
      }
      this.classScope.usePrivateName(value, left2.loc.start);
    }
    const op2 = this.state.type;
    if (tokenIsOperator(op2) && (this.prodParam.hasIn || !this.match(58))) {
      let prec = tokenOperatorPrecedence(op2);
      if (prec > minPrec) {
        if (op2 === 39) {
          this.expectPlugin("pipelineOperator");
          if (this.state.inFSharpPipelineDirectBody) {
            return left2;
          }
          this.checkPipelineAtInfixOperator(left2, leftStartLoc);
        }
        const node = this.startNodeAt(leftStartLoc);
        node.left = left2;
        node.operator = this.state.value;
        const logical = op2 === 41 || op2 === 42;
        const coalesce = op2 === 40;
        if (coalesce) {
          prec = tokenOperatorPrecedence(42);
        }
        this.next();
        if (op2 === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }])) {
          if (this.state.type === 96 && this.prodParam.hasAwait) {
            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          }
        }
        node.right = this.parseExprOpRightExpr(op2, prec);
        const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
        const nextOp = this.state.type;
        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
          throw this.raise(Errors.MixingCoalesceWithLogical, {
            at: this.state.startLoc
          });
        }
        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
      }
    }
    return left2;
  }
  parseExprOpRightExpr(op2, prec) {
    const startLoc = this.state.startLoc;
    switch (op2) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => {
              return this.parseHackPipeBody();
            });
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108)) {
                throw this.raise(Errors.PipeBodyIsTighter, {
                  at: this.state.startLoc
                });
              }
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op2, prec), startLoc);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => {
              return this.parseFSharpPipelineBody(prec);
            });
        }
      default:
        return this.parseExprOpBaseRightExpr(op2, prec);
    }
  }
  parseExprOpBaseRightExpr(op2, prec) {
    const startLoc = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op2) ? prec - 1 : prec);
  }
  parseHackPipeBody() {
    var _body$extra;
    const {
      startLoc
    } = this.state;
    const body = this.parseMaybeAssign();
    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
      this.raise(Errors.PipeUnparenthesizedBody, {
        at: startLoc,
        type: body.type
      });
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors.PipeTopicUnused, {
        at: startLoc
      });
    }
    return body;
  }
  checkExponentialAfterUnary(node) {
    if (this.match(57)) {
      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
        at: node.argument
      });
    }
  }
  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startLoc = this.state.startLoc;
    const isAwait = this.isContextual(96);
    if (isAwait && this.isAwaitAllowed()) {
      this.next();
      const expr2 = this.parseAwait(startLoc);
      if (!sawUnary)
        this.checkExponentialAfterUnary(expr2);
      return expr2;
    }
    const update = this.match(34);
    const node = this.startNode();
    if (tokenIsPrefix(this.state.type)) {
      node.operator = this.state.value;
      node.prefix = true;
      if (this.match(72)) {
        this.expectPlugin("throwExpressions");
      }
      const isDelete = this.match(89);
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refExpressionErrors, true);
      if (this.state.strict && isDelete) {
        const arg = node.argument;
        if (arg.type === "Identifier") {
          this.raise(Errors.StrictDelete, {
            at: node
          });
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(Errors.DeletePrivateField, {
            at: node
          });
        }
      }
      if (!update) {
        if (!sawUnary) {
          this.checkExponentialAfterUnary(node);
        }
        return this.finishNode(node, "UnaryExpression");
      }
    }
    const expr = this.parseUpdate(node, update, refExpressionErrors);
    if (isAwait) {
      const {
        type
      } = this.state;
      const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
      if (startsExpr2 && !this.isAmbiguousAwait()) {
        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
          at: startLoc
        });
        return this.parseAwait(startLoc);
      }
    }
    return expr;
  }
  parseUpdate(node, update, refExpressionErrors) {
    if (update) {
      const updateExpressionNode = node;
      this.checkLVal(updateExpressionNode.argument, {
        in: this.finishNode(updateExpressionNode, "UpdateExpression")
      });
      return node;
    }
    const startLoc = this.state.startLoc;
    let expr = this.parseExprSubscripts(refExpressionErrors);
    if (this.checkExpressionErrors(refExpressionErrors, false))
      return expr;
    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
      const node2 = this.startNodeAt(startLoc);
      node2.operator = this.state.value;
      node2.prefix = false;
      node2.argument = expr;
      this.next();
      this.checkLVal(expr, {
        in: expr = this.finishNode(node2, "UpdateExpression")
      });
    }
    return expr;
  }
  parseExprSubscripts(refExpressionErrors) {
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprAtom(refExpressionErrors);
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr;
    }
    return this.parseSubscripts(expr, startLoc);
  }
  parseSubscripts(base, startLoc, noCalls) {
    const state = {
      optionalChainMember: false,
      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
      stop: false
    };
    do {
      base = this.parseSubscript(base, startLoc, noCalls, state);
      state.maybeAsyncArrow = false;
    } while (!state.stop);
    return base;
  }
  parseSubscript(base, startLoc, noCalls, state) {
    const {
      type
    } = this.state;
    if (!noCalls && type === 15) {
      return this.parseBind(base, startLoc, noCalls, state);
    } else if (tokenIsTemplate(type)) {
      return this.parseTaggedTemplateExpression(base, startLoc, state);
    }
    let optional = false;
    if (type === 18) {
      if (noCalls) {
        this.raise(Errors.OptionalChainingNoNew, {
          at: this.state.startLoc
        });
        if (this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }
      }
      state.optionalChainMember = optional = true;
      this.next();
    }
    if (!noCalls && this.match(10)) {
      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
    } else {
      const computed3 = this.eat(0);
      if (computed3 || optional || this.eat(16)) {
        return this.parseMember(base, startLoc, state, computed3, optional);
      } else {
        state.stop = true;
        return base;
      }
    }
  }
  parseMember(base, startLoc, state, computed3, optional) {
    const node = this.startNodeAt(startLoc);
    node.object = base;
    node.computed = computed3;
    if (computed3) {
      node.property = this.parseExpression();
      this.expect(3);
    } else if (this.match(138)) {
      if (base.type === "Super") {
        this.raise(Errors.SuperPrivateField, {
          at: startLoc
        });
      }
      this.classScope.usePrivateName(this.state.value, this.state.startLoc);
      node.property = this.parsePrivateName();
    } else {
      node.property = this.parseIdentifier(true);
    }
    if (state.optionalChainMember) {
      node.optional = optional;
      return this.finishNode(node, "OptionalMemberExpression");
    } else {
      return this.finishNode(node, "MemberExpression");
    }
  }
  parseBind(base, startLoc, noCalls, state) {
    const node = this.startNodeAt(startLoc);
    node.object = base;
    this.next();
    node.callee = this.parseNoCallExpr();
    state.stop = true;
    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
  }
  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    let refExpressionErrors = null;
    this.state.maybeInArrowParameters = true;
    this.next();
    const node = this.startNodeAt(startLoc);
    node.callee = base;
    const {
      maybeAsyncArrow,
      optionalChainMember
    } = state;
    if (maybeAsyncArrow) {
      this.expressionScope.enter(newAsyncArrowScope());
      refExpressionErrors = new ExpressionErrors;
    }
    if (optionalChainMember) {
      node.optional = optional;
    }
    if (optional) {
      node.arguments = this.parseCallExpressionArguments(11);
    } else {
      node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
    }
    let finishedNode = this.finishCallExpression(node, optionalChainMember);
    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
      state.stop = true;
      this.checkDestructuringPrivate(refExpressionErrors);
      this.expressionScope.validateAsPattern();
      this.expressionScope.exit();
      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
    } else {
      if (maybeAsyncArrow) {
        this.checkExpressionErrors(refExpressionErrors, true);
        this.expressionScope.exit();
      }
      this.toReferencedArguments(finishedNode);
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    return finishedNode;
  }
  toReferencedArguments(node, isParenthesizedExpr) {
    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
  }
  parseTaggedTemplateExpression(base, startLoc, state) {
    const node = this.startNodeAt(startLoc);
    node.tag = base;
    node.quasi = this.parseTemplate(true);
    if (state.optionalChainMember) {
      this.raise(Errors.OptionalChainingNoTemplate, {
        at: startLoc
      });
    }
    return this.finishNode(node, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(base) {
    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    if (!this.hasPlugin("importAssertions")) {
      this.expectPlugin("importAttributes");
    }
  }
  finishCallExpression(node, optional) {
    if (node.callee.type === "Import") {
      if (node.arguments.length === 2) {
        {
          if (!this.hasPlugin("moduleAttributes")) {
            this.expectImportAttributesPlugin();
          }
        }
      }
      if (node.arguments.length === 0 || node.arguments.length > 2) {
        this.raise(Errors.ImportCallArity, {
          at: node,
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      } else {
        for (const arg of node.arguments) {
          if (arg.type === "SpreadElement") {
            this.raise(Errors.ImportCallSpreadArgument, {
              at: arg
            });
          }
        }
      }
    }
    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
    const elts = [];
    let first = true;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
        if (this.match(close)) {
          if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
            this.raise(Errors.ImportCallArgumentTrailingComma, {
              at: this.state.lastTokStartLoc
            });
          }
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra);
          }
          this.next();
          break;
        }
      }
      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
    }
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    return elts;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(node, call) {
    var _call$extra;
    this.resetPreviousNodeTrailingComments(call);
    this.expect(19);
    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? undefined : _call$extra.trailingCommaLoc);
    if (call.innerComments) {
      setInnerComments(node, call.innerComments);
    }
    if (call.callee.trailingComments) {
      setInnerComments(node, call.callee.trailingComments);
    }
    return node;
  }
  parseNoCallExpr() {
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
  }
  parseExprAtom(refExpressionErrors) {
    let node;
    let decorators = null;
    const {
      type
    } = this.state;
    switch (type) {
      case 79:
        return this.parseSuper();
      case 83:
        node = this.startNode();
        this.next();
        if (this.match(16)) {
          return this.parseImportMetaProperty(node);
        }
        if (this.match(10)) {
          if (this.options.createImportExpressions) {
            return this.parseImportCall(node);
          } else {
            return this.finishNode(node, "Import");
          }
        } else {
          this.raise(Errors.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          });
          return this.finishNode(node, "Import");
        }
      case 78:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");
      case 90: {
        return this.parseDo(this.startNode(), false);
      }
      case 56:
      case 31: {
        this.readRegexp();
        return this.parseRegExpLiteral(this.state.value);
      }
      case 134:
        return this.parseNumericLiteral(this.state.value);
      case 135:
        return this.parseBigIntLiteral(this.state.value);
      case 136:
        return this.parseDecimalLiteral(this.state.value);
      case 133:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(true);
      case 86:
        return this.parseBooleanLiteral(false);
      case 10: {
        const canBeArrow = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(canBeArrow);
      }
      case 2:
      case 1: {
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
      }
      case 0: {
        return this.parseArrayLike(3, true, false, refExpressionErrors);
      }
      case 6:
      case 7: {
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
      }
      case 5: {
        return this.parseObjectLike(8, false, false, refExpressionErrors);
      }
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        decorators = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(false);
      case 15: {
        node = this.startNode();
        this.next();
        node.object = null;
        const callee = node.callee = this.parseNoCallExpr();
        if (callee.type === "MemberExpression") {
          return this.finishNode(node, "BindExpression");
        } else {
          throw this.raise(Errors.UnsupportedBind, {
            at: callee
          });
        }
      }
      case 138: {
        this.raise(Errors.PrivateInExpectedIn, {
          at: this.state.startLoc,
          identifierName: this.state.value
        });
        return this.parsePrivateName();
      }
      case 33: {
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      }
      case 32: {
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      }
      case 37:
      case 38: {
        return this.parseTopicReference("hack");
      }
      case 44:
      case 54:
      case 27: {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          return this.parseTopicReference(pipeProposal);
        }
        this.unexpected();
        break;
      }
      case 47: {
        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
          this.expectOnePlugin(["jsx", "flow", "typescript"]);
        } else {
          this.unexpected();
        }
        break;
      }
      default:
        if (tokenIsIdentifier(type)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
            return this.parseModuleExpression();
          }
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          const containsEsc = this.state.containsEsc;
          const id = this.parseIdentifier();
          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: type2
            } = this.state;
            if (type2 === 68) {
              this.resetPreviousNodeTrailingComments(id);
              this.next();
              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
            } else if (tokenIsIdentifier(type2)) {
              if (this.lookaheadCharCode() === 61) {
                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
              } else {
                return id;
              }
            } else if (type2 === 90) {
              this.resetPreviousNodeTrailingComments(id);
              return this.parseDo(this.startNodeAtNode(id), true);
            }
          }
          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
          }
          return id;
        } else {
          this.unexpected();
        }
    }
  }
  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
    if (pipeProposal) {
      this.state.type = topicTokenType;
      this.state.value = topicTokenValue;
      this.state.pos--;
      this.state.end--;
      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
      return this.parseTopicReference(pipeProposal);
    } else {
      this.unexpected();
    }
  }
  parseTopicReference(pipeProposal) {
    const node = this.startNode();
    const startLoc = this.state.startLoc;
    const tokenType = this.state.type;
    this.next();
    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
  }
  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
      const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      if (!this.topicReferenceIsAllowedInCurrentContext()) {
        this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
          at: startLoc
        });
      }
      this.registerTopicReference();
      return this.finishNode(node, nodeType);
    } else {
      throw this.raise(Errors.PipeTopicUnconfiguredToken, {
        at: startLoc,
        token: tokenLabelName(tokenType)
      });
    }
  }
  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
    switch (pipeProposal) {
      case "hack": {
        return this.hasPlugin(["pipelineOperator", {
          topicToken: tokenLabelName(tokenType)
        }]);
      }
      case "smart":
        return tokenType === 27;
      default:
        throw this.raise(Errors.PipeTopicRequiresHackPipes, {
          at: startLoc
        });
    }
  }
  parseAsyncArrowUnaryFunction(node) {
    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
    const params = [this.parseIdentifier()];
    this.prodParam.exit();
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors.LineTerminatorBeforeArrow, {
        at: this.state.curPosition()
      });
    }
    this.expect(19);
    return this.parseArrowExpression(node, params, true);
  }
  parseDo(node, isAsync) {
    this.expectPlugin("doExpressions");
    if (isAsync) {
      this.expectPlugin("asyncDoExpressions");
    }
    node.async = isAsync;
    this.next();
    const oldLabels = this.state.labels;
    this.state.labels = [];
    if (isAsync) {
      this.prodParam.enter(PARAM_AWAIT);
      node.body = this.parseBlock();
      this.prodParam.exit();
    } else {
      node.body = this.parseBlock();
    }
    this.state.labels = oldLabels;
    return this.finishNode(node, "DoExpression");
  }
  parseSuper() {
    const node = this.startNode();
    this.next();
    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors.SuperNotAllowed, {
        at: node
      });
    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors.UnexpectedSuper, {
        at: node
      });
    }
    if (!this.match(10) && !this.match(0) && !this.match(16)) {
      this.raise(Errors.UnsupportedSuper, {
        at: node
      });
    }
    return this.finishNode(node, "Super");
  }
  parsePrivateName() {
    const node = this.startNode();
    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
    const name3 = this.state.value;
    this.next();
    node.id = this.createIdentifier(id, name3);
    return this.finishNode(node, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const node = this.startNode();
    this.next();
    if (this.prodParam.hasYield && this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
      this.next();
      if (this.match(103)) {
        this.expectPlugin("functionSent");
      } else if (!this.hasPlugin("functionSent")) {
        this.unexpected();
      }
      return this.parseMetaProperty(node, meta, "sent");
    }
    return this.parseFunction(node);
  }
  parseMetaProperty(node, meta, propertyName) {
    node.meta = meta;
    const containsEsc = this.state.containsEsc;
    node.property = this.parseIdentifier(true);
    if (node.property.name !== propertyName || containsEsc) {
      this.raise(Errors.UnsupportedMetaProperty, {
        at: node.property,
        target: meta.name,
        onlyValidPropertyName: propertyName
      });
    }
    return this.finishNode(node, "MetaProperty");
  }
  parseImportMetaProperty(node) {
    const id = this.createIdentifier(this.startNodeAtNode(node), "import");
    this.next();
    if (this.isContextual(101)) {
      if (!this.inModule) {
        this.raise(Errors.ImportMetaOutsideModule, {
          at: id
        });
      }
      this.sawUnambiguousESM = true;
    } else if (this.isContextual(105) || this.isContextual(97)) {
      const isSource = this.isContextual(105);
      if (!isSource)
        this.unexpected();
      this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
      if (!this.options.createImportExpressions) {
        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
          at: this.state.startLoc,
          phase: this.state.value
        });
      }
      this.next();
      node.phase = isSource ? "source" : "defer";
      return this.parseImportCall(node);
    }
    return this.parseMetaProperty(node, id, "meta");
  }
  parseLiteralAtNode(value, type, node) {
    this.addExtra(node, "rawValue", value);
    this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
    node.value = value;
    this.next();
    return this.finishNode(node, type);
  }
  parseLiteral(value, type) {
    const node = this.startNode();
    return this.parseLiteralAtNode(value, type, node);
  }
  parseStringLiteral(value) {
    return this.parseLiteral(value, "StringLiteral");
  }
  parseNumericLiteral(value) {
    return this.parseLiteral(value, "NumericLiteral");
  }
  parseBigIntLiteral(value) {
    return this.parseLiteral(value, "BigIntLiteral");
  }
  parseDecimalLiteral(value) {
    return this.parseLiteral(value, "DecimalLiteral");
  }
  parseRegExpLiteral(value) {
    const node = this.parseLiteral(value.value, "RegExpLiteral");
    node.pattern = value.pattern;
    node.flags = value.flags;
    return node;
  }
  parseBooleanLiteral(value) {
    const node = this.startNode();
    node.value = value;
    this.next();
    return this.finishNode(node, "BooleanLiteral");
  }
  parseNullLiteral() {
    const node = this.startNode();
    this.next();
    return this.finishNode(node, "NullLiteral");
  }
  parseParenAndDistinguishExpression(canBeArrow) {
    const startLoc = this.state.startLoc;
    let val;
    this.next();
    this.expressionScope.enter(newArrowHeadScope());
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true;
    this.state.inFSharpPipelineDirectBody = false;
    const innerStartLoc = this.state.startLoc;
    const exprList = [];
    const refExpressionErrors = new ExpressionErrors;
    let first = true;
    let spreadStartLoc;
    let optionalCommaStartLoc;
    while (!this.match(11)) {
      if (first) {
        first = false;
      } else {
        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
        if (this.match(11)) {
          optionalCommaStartLoc = this.state.startLoc;
          break;
        }
      }
      if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        spreadStartLoc = this.state.startLoc;
        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
        if (!this.checkCommaAfterRest(41)) {
          break;
        }
      } else {
        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
      }
    }
    const innerEndLoc = this.state.lastTokEndLoc;
    this.expect(11);
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    let arrowNode = this.startNodeAt(startLoc);
    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
      this.checkDestructuringPrivate(refExpressionErrors);
      this.expressionScope.validateAsPattern();
      this.expressionScope.exit();
      this.parseArrowExpression(arrowNode, exprList, false);
      return arrowNode;
    }
    this.expressionScope.exit();
    if (!exprList.length) {
      this.unexpected(this.state.lastTokStartLoc);
    }
    if (optionalCommaStartLoc)
      this.unexpected(optionalCommaStartLoc);
    if (spreadStartLoc)
      this.unexpected(spreadStartLoc);
    this.checkExpressionErrors(refExpressionErrors, true);
    this.toReferencedListDeep(exprList, true);
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartLoc);
      val.expressions = exprList;
      this.finishNode(val, "SequenceExpression");
      this.resetEndLocation(val, innerEndLoc);
    } else {
      val = exprList[0];
    }
    return this.wrapParenthesis(startLoc, val);
  }
  wrapParenthesis(startLoc, expression) {
    if (!this.options.createParenthesizedExpressions) {
      this.addExtra(expression, "parenthesized", true);
      this.addExtra(expression, "parenStart", startLoc.index);
      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
      return expression;
    }
    const parenExpression = this.startNodeAt(startLoc);
    parenExpression.expression = expression;
    return this.finishNode(parenExpression, "ParenthesizedExpression");
  }
  shouldParseArrow(params) {
    return !this.canInsertSemicolon();
  }
  parseArrow(node) {
    if (this.eat(19)) {
      return node;
    }
  }
  parseParenItem(node, startLoc) {
    return node;
  }
  parseNewOrNewTarget() {
    const node = this.startNode();
    this.next();
    if (this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
      this.next();
      const metaProp = this.parseMetaProperty(node, meta, "target");
      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
        this.raise(Errors.UnexpectedNewTarget, {
          at: metaProp
        });
      }
      return metaProp;
    }
    return this.parseNew(node);
  }
  parseNew(node) {
    this.parseNewCallee(node);
    if (this.eat(10)) {
      const args = this.parseExprList(11);
      this.toReferencedList(args);
      node.arguments = args;
    } else {
      node.arguments = [];
    }
    return this.finishNode(node, "NewExpression");
  }
  parseNewCallee(node) {
    const isImport = this.match(83);
    const callee = this.parseNoCallExpr();
    node.callee = callee;
    if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
      this.raise(Errors.ImportCallNotNewExpression, {
        at: callee
      });
    }
  }
  parseTemplateElement(isTagged) {
    const {
      start,
      startLoc,
      end,
      value
    } = this.state;
    const elemStart = start + 1;
    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
    if (value === null) {
      if (!isTagged) {
        this.raise(Errors.InvalidEscapeSequenceTemplate, {
          at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
        });
      }
    }
    const isTail = this.match(24);
    const endOffset = isTail ? -1 : -2;
    const elemEnd = end + endOffset;
    elem.value = {
      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, `
`),
      cooked: value === null ? null : value.slice(1, endOffset)
    };
    elem.tail = isTail;
    this.next();
    const finishedNode = this.finishNode(elem, "TemplateElement");
    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
    return finishedNode;
  }
  parseTemplate(isTagged) {
    const node = this.startNode();
    node.expressions = [];
    let curElt = this.parseTemplateElement(isTagged);
    node.quasis = [curElt];
    while (!curElt.tail) {
      node.expressions.push(this.parseTemplateSubstitution());
      this.readTemplateContinuation();
      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
    }
    return this.finishNode(node, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
    if (isRecord) {
      this.expectPlugin("recordAndTuple");
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const propHash = Object.create(null);
    let first = true;
    const node = this.startNode();
    node.properties = [];
    this.next();
    while (!this.match(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
        if (this.match(close)) {
          this.addTrailingCommaExtraToNode(node);
          break;
        }
      }
      let prop;
      if (isPattern) {
        prop = this.parseBindingProperty();
      } else {
        prop = this.parsePropertyDefinition(refExpressionErrors);
        this.checkProto(prop, isRecord, propHash, refExpressionErrors);
      }
      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
        this.raise(Errors.InvalidRecordProperty, {
          at: prop
        });
      }
      if (prop.shorthand) {
        this.addExtra(prop, "shorthand", true);
      }
      node.properties.push(prop);
    }
    this.next();
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    let type = "ObjectExpression";
    if (isPattern) {
      type = "ObjectPattern";
    } else if (isRecord) {
      type = "RecordExpression";
    }
    return this.finishNode(node, type);
  }
  addTrailingCommaExtraToNode(node) {
    this.addExtra(node, "trailingComma", this.state.lastTokStart);
    this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
  }
  maybeAsyncOrAccessorProp(prop) {
    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(refExpressionErrors) {
    let decorators = [];
    if (this.match(26)) {
      if (this.hasPlugin("decorators")) {
        this.raise(Errors.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        });
      }
      while (this.match(26)) {
        decorators.push(this.parseDecorator());
      }
    }
    const prop = this.startNode();
    let isAsync = false;
    let isAccessor = false;
    let startLoc;
    if (this.match(21)) {
      if (decorators.length)
        this.unexpected();
      return this.parseSpread();
    }
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }
    prop.method = false;
    if (refExpressionErrors) {
      startLoc = this.state.startLoc;
    }
    let isGenerator = this.eat(55);
    this.parsePropertyNamePrefixOperator(prop);
    const containsEsc = this.state.containsEsc;
    const key = this.parsePropertyName(prop, refExpressionErrors);
    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
      const keyName = key.name;
      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
        isAsync = true;
        this.resetPreviousNodeTrailingComments(key);
        isGenerator = this.eat(55);
        this.parsePropertyName(prop);
      }
      if (keyName === "get" || keyName === "set") {
        isAccessor = true;
        this.resetPreviousNodeTrailingComments(key);
        prop.kind = keyName;
        if (this.match(55)) {
          isGenerator = true;
          this.raise(Errors.AccessorIsGenerator, {
            at: this.state.curPosition(),
            kind: keyName
          });
          this.next();
        }
        this.parsePropertyName(prop);
      }
    }
    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
  }
  getGetterSetterExpectedParamCount(method) {
    return method.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(method) {
    return method.params;
  }
  checkGetterSetterParams(method) {
    var _params;
    const paramCount = this.getGetterSetterExpectedParamCount(method);
    const params = this.getObjectOrClassMethodParams(method);
    if (params.length !== paramCount) {
      this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
        at: method
      });
    }
    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? undefined : _params.type) === "RestElement") {
      this.raise(Errors.BadSetterRestParameter, {
        at: method
      });
    }
  }
  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
    if (isAccessor) {
      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
      this.checkGetterSetterParams(finishedProp);
      return finishedProp;
    }
    if (isAsync || isGenerator || this.match(10)) {
      if (isPattern)
        this.unexpected();
      prop.kind = "method";
      prop.method = true;
      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
    }
  }
  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
    prop.shorthand = false;
    if (this.eat(14)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
      return this.finishNode(prop, "ObjectProperty");
    }
    if (!prop.computed && prop.key.type === "Identifier") {
      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
      } else if (this.match(29)) {
        const shorthandAssignLoc = this.state.startLoc;
        if (refExpressionErrors != null) {
          if (refExpressionErrors.shorthandAssignLoc === null) {
            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
          }
        } else {
          this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          });
        }
        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
      } else {
        prop.value = cloneIdentifier(prop.key);
      }
      prop.shorthand = true;
      return this.finishNode(prop, "ObjectProperty");
    }
  }
  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
    if (!node)
      this.unexpected();
    return node;
  }
  parsePropertyName(prop, refExpressionErrors) {
    if (this.eat(0)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssignAllowIn();
      this.expect(3);
    } else {
      const {
        type,
        value
      } = this.state;
      let key;
      if (tokenIsKeywordOrIdentifier(type)) {
        key = this.parseIdentifier(true);
      } else {
        switch (type) {
          case 134:
            key = this.parseNumericLiteral(value);
            break;
          case 133:
            key = this.parseStringLiteral(value);
            break;
          case 135:
            key = this.parseBigIntLiteral(value);
            break;
          case 136:
            key = this.parseDecimalLiteral(value);
            break;
          case 138: {
            const privateKeyLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.privateKeyLoc === null) {
                refExpressionErrors.privateKeyLoc = privateKeyLoc;
              }
            } else {
              this.raise(Errors.UnexpectedPrivateField, {
                at: privateKeyLoc
              });
            }
            key = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      }
      prop.key = key;
      if (type !== 138) {
        prop.computed = false;
      }
    }
    return prop.key;
  }
  initFunction(node, isAsync) {
    node.id = null;
    node.generator = false;
    node.async = isAsync;
  }
  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    this.initFunction(node, isAsync);
    node.generator = isGenerator;
    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
    this.prodParam.enter(functionFlags(isAsync, node.generator));
    this.parseFunctionParams(node, isConstructor);
    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
    this.prodParam.exit();
    this.scope.exit();
    return finishedNode;
  }
  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    if (isTuple) {
      this.expectPlugin("recordAndTuple");
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const node = this.startNode();
    this.next();
    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
    this.scope.enter(2 | 4);
    let flags = functionFlags(isAsync, false);
    if (!this.match(5) && this.prodParam.hasIn) {
      flags |= PARAM_IN;
    }
    this.prodParam.enter(flags);
    this.initFunction(node, isAsync);
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    if (params) {
      this.state.maybeInArrowParameters = true;
      this.setArrowFunctionParameters(node, params, trailingCommaLoc);
    }
    this.state.maybeInArrowParameters = false;
    this.parseFunctionBody(node, true);
    this.prodParam.exit();
    this.scope.exit();
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    return this.finishNode(node, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(node, params, trailingCommaLoc) {
    this.toAssignableList(params, trailingCommaLoc, false);
    node.params = params;
  }
  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    this.parseFunctionBody(node, false, isMethod);
    return this.finishNode(node, type);
  }
  parseFunctionBody(node, allowExpression, isMethod = false) {
    const isExpression = allowExpression && !this.match(5);
    this.expressionScope.enter(newExpressionScope());
    if (isExpression) {
      node.body = this.parseMaybeAssign();
      this.checkParams(node, false, allowExpression, false);
    } else {
      const oldStrict = this.state.strict;
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
      node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
        const nonSimple = !this.isSimpleParamList(node.params);
        if (hasStrictModeDirective && nonSimple) {
          this.raise(Errors.IllegalLanguageModeDirective, {
            at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
          });
        }
        const strictModeChanged = !oldStrict && this.state.strict;
        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
        if (this.state.strict && node.id) {
          this.checkIdentifier(node.id, 65, strictModeChanged);
        }
      });
      this.prodParam.exit();
      this.state.labels = oldLabels;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(node) {
    return node.type === "Identifier";
  }
  isSimpleParamList(params) {
    for (let i = 0, len = params.length;i < len; i++) {
      if (!this.isSimpleParameter(params[i]))
        return false;
    }
    return true;
  }
  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    const checkClashes = !allowDuplicates && new Set;
    const formalParameters = {
      type: "FormalParameters"
    };
    for (const param of node.params) {
      this.checkLVal(param, {
        in: formalParameters,
        binding: 5,
        checkClashes,
        strictModeChanged
      });
    }
  }
  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
    const elts = [];
    let first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
        if (this.match(close)) {
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra);
          }
          this.next();
          break;
        }
      }
      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
    }
    return elts;
  }
  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    let elt;
    if (this.match(12)) {
      if (!allowEmpty) {
        this.raise(Errors.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ","
        });
      }
      elt = null;
    } else if (this.match(21)) {
      const spreadNodeStartLoc = this.state.startLoc;
      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication");
      if (!allowPlaceholder) {
        this.raise(Errors.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc
        });
      }
      const node = this.startNode();
      this.next();
      elt = this.finishNode(node, "ArgumentPlaceholder");
    } else {
      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
    }
    return elt;
  }
  parseIdentifier(liberal) {
    const node = this.startNode();
    const name3 = this.parseIdentifierName(liberal);
    return this.createIdentifier(node, name3);
  }
  createIdentifier(node, name3) {
    node.name = name3;
    node.loc.identifierName = name3;
    return this.finishNode(node, "Identifier");
  }
  parseIdentifierName(liberal) {
    let name3;
    const {
      startLoc,
      type
    } = this.state;
    if (tokenIsKeywordOrIdentifier(type)) {
      name3 = this.state.value;
    } else {
      this.unexpected();
    }
    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
    if (liberal) {
      if (tokenIsKeyword2) {
        this.replaceToken(132);
      }
    } else {
      this.checkReservedWord(name3, startLoc, tokenIsKeyword2, false);
    }
    this.next();
    return name3;
  }
  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (word.length > 10) {
      return;
    }
    if (!canBeReservedWord(word)) {
      return;
    }
    if (checkKeywords && isKeyword(word)) {
      this.raise(Errors.UnexpectedKeyword, {
        at: startLoc,
        keyword: word
      });
      return;
    }
    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
    if (reservedTest(word, this.inModule)) {
      this.raise(Errors.UnexpectedReservedWord, {
        at: startLoc,
        reservedWord: word
      });
      return;
    } else if (word === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(Errors.YieldBindingIdentifier, {
          at: startLoc
        });
        return;
      }
    } else if (word === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(Errors.AwaitBindingIdentifier, {
          at: startLoc
        });
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
          at: startLoc
        });
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError({
        at: startLoc
      });
    } else if (word === "arguments") {
      if (this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Errors.ArgumentsInClass, {
          at: startLoc
        });
        return;
      }
    }
  }
  isAwaitAllowed() {
    if (this.prodParam.hasAwait)
      return true;
    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
      return true;
    }
    return false;
  }
  parseAwait(startLoc) {
    const node = this.startNodeAt(startLoc);
    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
      at: node
    });
    if (this.eat(55)) {
      this.raise(Errors.ObsoleteAwaitStar, {
        at: node
      });
    }
    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
      if (this.isAmbiguousAwait()) {
        this.ambiguousScriptDifferentAst = true;
      } else {
        this.sawUnambiguousESM = true;
      }
    }
    if (!this.state.soloAwait) {
      node.argument = this.parseMaybeUnary(null, true);
    }
    return this.finishNode(node, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak())
      return true;
    const {
      type
    } = this.state;
    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
  }
  parseYield() {
    const node = this.startNode();
    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
      at: node
    });
    this.next();
    let delegating = false;
    let argument = null;
    if (!this.hasPrecedingLineBreak()) {
      delegating = this.eat(55);
      switch (this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!delegating)
            break;
        default:
          argument = this.parseMaybeAssign();
      }
    }
    node.delegate = delegating;
    node.argument = argument;
    return this.finishNode(node, "YieldExpression");
  }
  parseImportCall(node) {
    this.next();
    node.source = this.parseMaybeAssignAllowIn();
    if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
      node.options = null;
    }
    if (this.eat(12)) {
      this.expectImportAttributesPlugin();
      if (!this.match(11)) {
        node.options = this.parseMaybeAssignAllowIn();
        this.eat(12);
      }
    }
    this.expect(11);
    return this.finishNode(node, "ImportExpression");
  }
  checkPipelineAtInfixOperator(left2, leftStartLoc) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      if (left2.type === "SequenceExpression") {
        this.raise(Errors.PipelineHeadSequenceExpression, {
          at: leftStartLoc
        });
      }
    }
  }
  parseSmartPipelineBodyInStyle(childExpr, startLoc) {
    if (this.isSimpleReference(childExpr)) {
      const bodyNode = this.startNodeAt(startLoc);
      bodyNode.callee = childExpr;
      return this.finishNode(bodyNode, "PipelineBareFunction");
    } else {
      const bodyNode = this.startNodeAt(startLoc);
      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
      bodyNode.expression = childExpr;
      return this.finishNode(bodyNode, "PipelineTopicExpression");
    }
  }
  isSimpleReference(expression) {
    switch (expression.type) {
      case "MemberExpression":
        return !expression.computed && this.isSimpleReference(expression.object);
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
    if (this.match(19)) {
      throw this.raise(Errors.PipelineBodyNoArrow, {
        at: this.state.startLoc
      });
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors.PipelineTopicUnused, {
        at: startLoc
      });
    }
  }
  withTopicBindingContext(callback) {
    const outerContextTopicState = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return callback();
    } finally {
      this.state.topicContext = outerContextTopicState;
    }
  }
  withSmartMixTopicForbiddingContext(callback) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    } else {
      return callback();
    }
  }
  withSoloAwaitPermittingContext(callback) {
    const outerContextSoloAwaitState = this.state.soloAwait;
    this.state.soloAwait = true;
    try {
      return callback();
    } finally {
      this.state.soloAwait = outerContextSoloAwaitState;
    }
  }
  allowInAnd(callback) {
    const flags = this.prodParam.currentFlags();
    const prodParamToSet = PARAM_IN & ~flags;
    if (prodParamToSet) {
      this.prodParam.enter(flags | PARAM_IN);
      try {
        return callback();
      } finally {
        this.prodParam.exit();
      }
    }
    return callback();
  }
  disallowInAnd(callback) {
    const flags = this.prodParam.currentFlags();
    const prodParamToClear = PARAM_IN & flags;
    if (prodParamToClear) {
      this.prodParam.enter(flags & ~PARAM_IN);
      try {
        return callback();
      } finally {
        this.prodParam.exit();
      }
    }
    return callback();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(prec) {
    const startLoc = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    return ret;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const node = this.startNode();
    this.next();
    if (!this.match(5)) {
      this.unexpected(null, 5);
    }
    const program = this.startNodeAt(this.state.endLoc);
    this.next();
    const revertScopes = this.initializeScopes(true);
    this.enterInitialScopes();
    try {
      node.body = this.parseProgram(program, 8, "module");
    } finally {
      revertScopes();
    }
    return this.finishNode(node, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(prop) {}
}
var loopLabel = {
  kind: "loop"
};
var switchLabel = {
  kind: "switch"
};
var loneSurrogate = /[\uD800-\uDFFF]/u;
var keywordRelationalOperator = /in(?:stanceof)?/y;
function babel7CompatTokens(tokens, input) {
  for (let i = 0;i < tokens.length; i++) {
    const token2 = tokens[i];
    const {
      type
    } = token2;
    if (typeof type === "number") {
      {
        if (type === 138) {
          const {
            loc,
            start,
            value,
            end
          } = token2;
          const hashEndPos = start + 1;
          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
          tokens.splice(i, 1, new Token({
            type: getExportedToken(27),
            value: "#",
            start,
            end: hashEndPos,
            startLoc: loc.start,
            endLoc: hashEndLoc
          }), new Token({
            type: getExportedToken(132),
            value,
            start: hashEndPos,
            end,
            startLoc: hashEndLoc,
            endLoc: loc.end
          }));
          i++;
          continue;
        }
        if (tokenIsTemplate(type)) {
          const {
            loc,
            start,
            value,
            end
          } = token2;
          const backquoteEnd = start + 1;
          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
          let startToken;
          if (input.charCodeAt(start) === 96) {
            startToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            });
          } else {
            startToken = new Token({
              type: getExportedToken(8),
              value: "}",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            });
          }
          let templateValue, templateElementEnd, templateElementEndLoc, endToken;
          if (type === 24) {
            templateElementEnd = end - 1;
            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
            templateValue = value === null ? null : value.slice(1, -1);
            endToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            });
          } else {
            templateElementEnd = end - 2;
            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
            templateValue = value === null ? null : value.slice(1, -2);
            endToken = new Token({
              type: getExportedToken(23),
              value: "${",
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            });
          }
          tokens.splice(i, 1, startToken, new Token({
            type: getExportedToken(20),
            value: templateValue,
            start: backquoteEnd,
            end: templateElementEnd,
            startLoc: backquoteEndLoc,
            endLoc: templateElementEndLoc
          }), endToken);
          i += 2;
          continue;
        }
      }
      token2.type = getExportedToken(type);
    }
  }
  return tokens;
}

class StatementParser extends ExpressionParser {
  parseTopLevel(file, program) {
    file.program = this.parseProgram(program);
    file.comments = this.state.comments;
    if (this.options.tokens) {
      file.tokens = babel7CompatTokens(this.tokens, this.input);
    }
    return this.finishNode(file, "File");
  }
  parseProgram(program, end = 139, sourceType = this.options.sourceType) {
    program.sourceType = sourceType;
    program.interpreter = this.parseInterpreterDirective();
    this.parseBlockBody(program, true, true, end);
    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
      for (const [localName, at2] of Array.from(this.scope.undefinedExports)) {
        this.raise(Errors.ModuleExportUndefined, {
          at: at2,
          localName
        });
      }
    }
    let finishedProgram;
    if (end === 139) {
      finishedProgram = this.finishNode(program, "Program");
    } else {
      finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
    }
    return finishedProgram;
  }
  stmtToDirective(stmt) {
    const directive = stmt;
    directive.type = "Directive";
    directive.value = directive.expression;
    delete directive.expression;
    const directiveLiteral = directive.value;
    const expressionValue = directiveLiteral.value;
    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
    const val = directiveLiteral.value = raw.slice(1, -1);
    this.addExtra(directiveLiteral, "raw", raw);
    this.addExtra(directiveLiteral, "rawValue", val);
    this.addExtra(directiveLiteral, "expressionValue", expressionValue);
    directiveLiteral.type = "DirectiveLiteral";
    return directive;
  }
  parseInterpreterDirective() {
    if (!this.match(28)) {
      return null;
    }
    const node = this.startNode();
    node.value = this.state.value;
    this.next();
    return this.finishNode(node, "InterpreterDirective");
  }
  isLet() {
    if (!this.isContextual(100)) {
      return false;
    }
    return this.hasFollowingBindingAtom();
  }
  chStartsBindingIdentifier(ch, pos) {
    if (isIdentifierStart(ch)) {
      keywordRelationalOperator.lastIndex = pos;
      if (keywordRelationalOperator.test(this.input)) {
        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
        if (!isIdentifierChar(endCh) && endCh !== 92) {
          return false;
        }
      }
      return true;
    } else if (ch === 92) {
      return true;
    } else {
      return false;
    }
  }
  chStartsBindingPattern(ch) {
    return ch === 91 || ch === 123;
  }
  hasFollowingBindingAtom() {
    const next = this.nextTokenStart();
    const nextCh = this.codePointAtPos(next);
    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
  }
  hasInLineFollowingBindingIdentifier() {
    const next = this.nextTokenInLineStart();
    const nextCh = this.codePointAtPos(next);
    return this.chStartsBindingIdentifier(nextCh, next);
  }
  startsUsingForOf() {
    const {
      type,
      containsEsc
    } = this.lookahead();
    if (type === 102 && !containsEsc) {
      return false;
    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
      this.expectPlugin("explicitResourceManagement");
      return true;
    }
  }
  startsAwaitUsing() {
    let next = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(next, "using")) {
      next = this.nextTokenInLineStartSince(next + 5);
      const nextCh = this.codePointAtPos(next);
      if (this.chStartsBindingIdentifier(nextCh, next)) {
        this.expectPlugin("explicitResourceManagement");
        return true;
      }
    }
    return false;
  }
  parseModuleItem() {
    return this.parseStatementLike(1 | 2 | 4 | 8);
  }
  parseStatementListItem() {
    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
    let flags = 0;
    if (this.options.annexB && !this.state.strict) {
      flags |= 4;
      if (allowLabeledFunction) {
        flags |= 8;
      }
    }
    return this.parseStatementLike(flags);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(flags) {
    let decorators = null;
    if (this.match(26)) {
      decorators = this.parseDecorators(true);
    }
    return this.parseStatementContent(flags, decorators);
  }
  parseStatementContent(flags, decorators) {
    const starttype = this.state.type;
    const node = this.startNode();
    const allowDeclaration = !!(flags & 2);
    const allowFunctionDeclaration = !!(flags & 4);
    const topLevel = flags & 1;
    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);
      case 63:
        return this.parseBreakContinueStatement(node, false);
      case 64:
        return this.parseDebuggerStatement(node);
      case 90:
        return this.parseDoWhileStatement(node);
      case 91:
        return this.parseForStatement(node);
      case 68:
        if (this.lookaheadCharCode() === 46)
          break;
        if (!allowFunctionDeclaration) {
          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
            at: this.state.startLoc
          });
        }
        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
      case 80:
        if (!allowDeclaration)
          this.unexpected();
        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
      case 69:
        return this.parseIfStatement(node);
      case 70:
        return this.parseReturnStatement(node);
      case 71:
        return this.parseSwitchStatement(node);
      case 72:
        return this.parseThrowStatement(node);
      case 73:
        return this.parseTryStatement(node);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing()) {
          if (!this.isAwaitAllowed()) {
            this.raise(Errors.AwaitUsingNotInAsyncContext, {
              at: node
            });
          } else if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, {
              at: node
            });
          }
          this.next();
          return this.parseVarStatement(node, "await using");
        }
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
          break;
        }
        this.expectPlugin("explicitResourceManagement");
        if (!this.scope.inModule && this.scope.inTopLevel) {
          this.raise(Errors.UnexpectedUsingDeclaration, {
            at: this.state.startLoc
          });
        } else if (!allowDeclaration) {
          this.raise(Errors.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }
        return this.parseVarStatement(node, "using");
      case 100: {
        if (this.state.containsEsc) {
          break;
        }
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        if (nextCh !== 91) {
          if (!allowDeclaration && this.hasFollowingLineBreak())
            break;
          if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
            break;
          }
        }
      }
      case 75: {
        if (!allowDeclaration) {
          this.raise(Errors.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }
      }
      case 74: {
        const kind = this.state.value;
        return this.parseVarStatement(node, kind);
      }
      case 92:
        return this.parseWhileStatement(node);
      case 76:
        return this.parseWithStatement(node);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(node);
      case 83: {
        const nextTokenCharCode = this.lookaheadCharCode();
        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
          break;
        }
      }
      case 82: {
        if (!this.options.allowImportExportEverywhere && !topLevel) {
          this.raise(Errors.UnexpectedImportExport, {
            at: this.state.startLoc
          });
        }
        this.next();
        let result;
        if (starttype === 83) {
          result = this.parseImport(node);
          if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
            this.sawUnambiguousESM = true;
          }
        } else {
          result = this.parseExport(node, decorators);
          if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
            this.sawUnambiguousESM = true;
          }
        }
        this.assertModuleNodeAllowed(result);
        return result;
      }
      default: {
        if (this.isAsyncFunction()) {
          if (!allowDeclaration) {
            this.raise(Errors.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          this.next();
          return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
        }
      }
    }
    const maybeName = this.state.value;
    const expr = this.parseExpression();
    if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
      return this.parseLabeledStatement(node, maybeName, expr, flags);
    } else {
      return this.parseExpressionStatement(node, expr, decorators);
    }
  }
  assertModuleNodeAllowed(node) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(Errors.ImportOutsideModule, {
        at: node
      });
    }
  }
  decoratorsEnabledBeforeExport() {
    if (this.hasPlugin("decorators-legacy"))
      return true;
    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
  }
  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
    if (maybeDecorators) {
      if (classNode.decorators && classNode.decorators.length > 0) {
        if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
          this.raise(Errors.DecoratorsBeforeAfterExport, {
            at: classNode.decorators[0]
          });
        }
        classNode.decorators.unshift(...maybeDecorators);
      } else {
        classNode.decorators = maybeDecorators;
      }
      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
      if (exportNode)
        this.resetStartLocationFromNode(exportNode, classNode);
    }
    return classNode;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(allowExport) {
    const decorators = [];
    do {
      decorators.push(this.parseDecorator());
    } while (this.match(26));
    if (this.match(82)) {
      if (!allowExport) {
        this.unexpected();
      }
      if (!this.decoratorsEnabledBeforeExport()) {
        this.raise(Errors.DecoratorExportClass, {
          at: this.state.startLoc
        });
      }
    } else if (!this.canHaveLeadingDecorator()) {
      throw this.raise(Errors.UnexpectedLeadingDecorator, {
        at: this.state.startLoc
      });
    }
    return decorators;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const node = this.startNode();
    this.next();
    if (this.hasPlugin("decorators")) {
      const startLoc = this.state.startLoc;
      let expr;
      if (this.match(10)) {
        const startLoc2 = this.state.startLoc;
        this.next();
        expr = this.parseExpression();
        this.expect(11);
        expr = this.wrapParenthesis(startLoc2, expr);
        const paramsStartLoc = this.state.startLoc;
        node.expression = this.parseMaybeDecoratorArguments(expr);
        if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
            at: paramsStartLoc
          });
        }
      } else {
        expr = this.parseIdentifier(false);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.object = expr;
          if (this.match(138)) {
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node2.property = this.parsePrivateName();
          } else {
            node2.property = this.parseIdentifier(true);
          }
          node2.computed = false;
          expr = this.finishNode(node2, "MemberExpression");
        }
        node.expression = this.parseMaybeDecoratorArguments(expr);
      }
    } else {
      node.expression = this.parseExprSubscripts();
    }
    return this.finishNode(node, "Decorator");
  }
  parseMaybeDecoratorArguments(expr) {
    if (this.eat(10)) {
      const node = this.startNodeAtNode(expr);
      node.callee = expr;
      node.arguments = this.parseCallExpressionArguments(11, false);
      this.toReferencedList(node.arguments);
      return this.finishNode(node, "CallExpression");
    }
    return expr;
  }
  parseBreakContinueStatement(node, isBreak) {
    this.next();
    if (this.isLineTerminator()) {
      node.label = null;
    } else {
      node.label = this.parseIdentifier();
      this.semicolon();
    }
    this.verifyBreakContinue(node, isBreak);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(node, isBreak) {
    let i;
    for (i = 0;i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop"))
          break;
        if (node.label && isBreak)
          break;
      }
    }
    if (i === this.state.labels.length) {
      const type = isBreak ? "BreakStatement" : "ContinueStatement";
      this.raise(Errors.IllegalBreakContinue, {
        at: node,
        type
      });
    }
  }
  parseDebuggerStatement(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const val = this.parseExpression();
    this.expect(11);
    return val;
  }
  parseDoWhileStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    this.state.labels.pop();
    this.expect(92);
    node.test = this.parseHeaderExpression();
    this.eat(13);
    return this.finishNode(node, "DoWhileStatement");
  }
  parseForStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    let awaitAt = null;
    if (this.isAwaitAllowed() && this.eatContextual(96)) {
      awaitAt = this.state.lastTokStartLoc;
    }
    this.scope.enter(0);
    this.expect(10);
    if (this.match(13)) {
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, null);
    }
    const startsWithLet = this.isContextual(100);
    {
      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
      if (this.match(74) || this.match(75) || isLetOrUsing) {
        const initNode = this.startNode();
        let kind;
        if (startsWithAwaitUsing) {
          kind = "await using";
          if (!this.isAwaitAllowed()) {
            this.raise(Errors.AwaitUsingNotInAsyncContext, {
              at: this.state.startLoc
            });
          }
          this.next();
        } else {
          kind = this.state.value;
        }
        this.next();
        this.parseVar(initNode, true, kind);
        const init2 = this.finishNode(initNode, "VariableDeclaration");
        const isForIn = this.match(58);
        if (isForIn && starsWithUsingDeclaration) {
          this.raise(Errors.ForInUsing, {
            at: init2
          });
        }
        if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
          return this.parseForIn(node, init2, awaitAt);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      }
    }
    const startsWithAsync = this.isContextual(95);
    const refExpressionErrors = new ExpressionErrors;
    const init = this.parseExpression(true, refExpressionErrors);
    const isForOf = this.isContextual(102);
    if (isForOf) {
      if (startsWithLet) {
        this.raise(Errors.ForOfLet, {
          at: init
        });
      }
      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
        this.raise(Errors.ForOfAsync, {
          at: init
        });
      }
    }
    if (isForOf || this.match(58)) {
      this.checkDestructuringPrivate(refExpressionErrors);
      this.toAssignable(init, true);
      const type = isForOf ? "ForOfStatement" : "ForInStatement";
      this.checkLVal(init, {
        in: {
          type
        }
      });
      return this.parseForIn(node, init, awaitAt);
    } else {
      this.checkExpressionErrors(refExpressionErrors, true);
    }
    if (awaitAt !== null) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init);
  }
  parseFunctionStatement(node, isAsync, isHangingDeclaration) {
    this.next();
    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
  }
  parseIfStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
    return this.finishNode(node, "IfStatement");
  }
  parseReturnStatement(node) {
    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
      this.raise(Errors.IllegalReturn, {
        at: this.state.startLoc
      });
    }
    this.next();
    if (this.isLineTerminator()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
  }
  parseSwitchStatement(node) {
    this.next();
    node.discriminant = this.parseHeaderExpression();
    const cases = node.cases = [];
    this.expect(5);
    this.state.labels.push(switchLabel);
    this.scope.enter(0);
    let cur;
    for (let sawDefault;!this.match(8); ) {
      if (this.match(61) || this.match(65)) {
        const isCase = this.match(61);
        if (cur)
          this.finishNode(cur, "SwitchCase");
        cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raise(Errors.MultipleDefaultsInSwitch, {
              at: this.state.lastTokStartLoc
            });
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(14);
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatementListItem());
        } else {
          this.unexpected();
        }
      }
    }
    this.scope.exit();
    if (cur)
      this.finishNode(cur, "SwitchCase");
    this.next();
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  }
  parseThrowStatement(node) {
    this.next();
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc
      });
    }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const param = this.parseBindingAtom();
    this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
    this.checkLVal(param, {
      in: {
        type: "CatchClause"
      },
      binding: 9
    });
    return param;
  }
  parseTryStatement(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.match(62)) {
      const clause = this.startNode();
      this.next();
      if (this.match(10)) {
        this.expect(10);
        clause.param = this.parseCatchClauseParam();
        this.expect(11);
      } else {
        clause.param = null;
        this.scope.enter(0);
      }
      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
      this.scope.exit();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(67) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) {
      this.raise(Errors.NoCatchOrFinally, {
        at: node
      });
    }
    return this.finishNode(node, "TryStatement");
  }
  parseVarStatement(node, kind, allowMissingInitializer = false) {
    this.next();
    this.parseVar(node, false, kind, allowMissingInitializer);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }
  parseWhileStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    this.state.labels.push(loopLabel);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  }
  parseWithStatement(node) {
    if (this.state.strict) {
      this.raise(Errors.StrictWith, {
        at: this.state.startLoc
      });
    }
    this.next();
    node.object = this.parseHeaderExpression();
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    return this.finishNode(node, "WithStatement");
  }
  parseEmptyStatement(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  }
  parseLabeledStatement(node, maybeName, expr, flags) {
    for (const label of this.state.labels) {
      if (label.name === maybeName) {
        this.raise(Errors.LabelRedeclaration, {
          at: expr,
          labelName: maybeName
        });
      }
    }
    const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
    for (let i = this.state.labels.length - 1;i >= 0; i--) {
      const label = this.state.labels[i];
      if (label.statementStart === node.start) {
        label.statementStart = this.state.start;
        label.kind = kind;
      } else {
        break;
      }
    }
    this.state.labels.push({
      name: maybeName,
      kind,
      statementStart: this.state.start
    });
    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
    this.state.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  }
  parseExpressionStatement(node, expr, decorators) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  }
  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
    const node = this.startNode();
    if (allowDirectives) {
      this.state.strictErrors.clear();
    }
    this.expect(5);
    if (createNewLexicalScope) {
      this.scope.enter(0);
    }
    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
    if (createNewLexicalScope) {
      this.scope.exit();
    }
    return this.finishNode(node, "BlockStatement");
  }
  isValidDirective(stmt) {
    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
  }
  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
    const body = node.body = [];
    const directives2 = node.directives = [];
    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives2 : undefined, topLevel, end, afterBlockParse);
  }
  parseBlockOrModuleBlockBody(body, directives2, topLevel, end, afterBlockParse) {
    const oldStrict = this.state.strict;
    let hasStrictModeDirective = false;
    let parsedNonDirective = false;
    while (!this.match(end)) {
      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
      if (directives2 && !parsedNonDirective) {
        if (this.isValidDirective(stmt)) {
          const directive = this.stmtToDirective(stmt);
          directives2.push(directive);
          if (!hasStrictModeDirective && directive.value.value === "use strict") {
            hasStrictModeDirective = true;
            this.setStrict(true);
          }
          continue;
        }
        parsedNonDirective = true;
        this.state.strictErrors.clear();
      }
      body.push(stmt);
    }
    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
    if (!oldStrict) {
      this.setStrict(false);
    }
    this.next();
  }
  parseFor(node, init) {
    node.init = init;
    this.semicolon(false);
    node.test = this.match(13) ? null : this.parseExpression();
    this.semicolon(false);
    node.update = this.match(11) ? null : this.parseExpression();
    this.expect(11);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }
  parseForIn(node, init, awaitAt) {
    const isForIn = this.match(58);
    this.next();
    if (isForIn) {
      if (awaitAt !== null)
        this.unexpected(awaitAt);
    } else {
      node.await = awaitAt !== null;
    }
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(Errors.ForInOfLoopInitializer, {
        at: init,
        type: isForIn ? "ForInStatement" : "ForOfStatement"
      });
    }
    if (init.type === "AssignmentPattern") {
      this.raise(Errors.InvalidLhs, {
        at: init,
        ancestor: {
          type: "ForStatement"
        }
      });
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
    this.expect(11);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(node, isFor, kind, allowMissingInitializer = false) {
    const declarations = node.declarations = [];
    node.kind = kind;
    for (;; ) {
      const decl = this.startNode();
      this.parseVarId(decl, kind);
      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
      if (decl.init === null && !allowMissingInitializer) {
        if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
          this.raise(Errors.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: "destructuring"
          });
        } else if (kind === "const" && !(this.match(58) || this.isContextual(102))) {
          this.raise(Errors.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: "const"
          });
        }
      }
      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(12))
        break;
    }
    return node;
  }
  parseVarId(decl, kind) {
    const id = this.parseBindingAtom();
    this.checkLVal(id, {
      in: {
        type: "VariableDeclarator"
      },
      binding: kind === "var" ? 5 : 8201
    });
    decl.id = id;
  }
  parseAsyncFunctionExpression(node) {
    return this.parseFunction(node, 8);
  }
  parseFunction(node, flags = 0) {
    const hangingDeclaration = flags & 2;
    const isDeclaration = !!(flags & 1);
    const requireId = isDeclaration && !(flags & 4);
    const isAsync = !!(flags & 8);
    this.initFunction(node, isAsync);
    if (this.match(55)) {
      if (hangingDeclaration) {
        this.raise(Errors.GeneratorInSingleStatementContext, {
          at: this.state.startLoc
        });
      }
      this.next();
      node.generator = true;
    }
    if (isDeclaration) {
      node.id = this.parseFunctionId(requireId);
    }
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = false;
    this.scope.enter(2);
    this.prodParam.enter(functionFlags(isAsync, node.generator));
    if (!isDeclaration) {
      node.id = this.parseFunctionId();
    }
    this.parseFunctionParams(node, false);
    this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
    });
    this.prodParam.exit();
    this.scope.exit();
    if (isDeclaration && !hangingDeclaration) {
      this.registerFunctionStatementId(node);
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    return node;
  }
  parseFunctionId(requireId) {
    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(node, isConstructor) {
    this.expect(10);
    this.expressionScope.enter(newParameterDeclarationScope());
    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
    this.expressionScope.exit();
  }
  registerFunctionStatementId(node) {
    if (!node.id)
      return;
    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
  }
  parseClass(node, isStatement, optionalId) {
    this.next();
    const oldStrict = this.state.strict;
    this.state.strict = true;
    this.parseClassId(node, isStatement, optionalId);
    this.parseClassSuper(node);
    node.body = this.parseClassBody(!!node.superClass, oldStrict);
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }
  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter();
    const state = {
      hadConstructor: false,
      hadSuperClass
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(5);
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(Errors.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          }
          continue;
        }
        if (this.match(26)) {
          decorators.push(this.parseDecorator());
          continue;
        }
        const member = this.startNode();
        if (decorators.length) {
          member.decorators = decorators;
          this.resetStartLocationFromNode(member, decorators[0]);
          decorators = [];
        }
        this.parseClassMember(classBody, member, state);
        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
          this.raise(Errors.DecoratorConstructor, {
            at: member
          });
        }
      }
    });
    this.state.strict = oldStrict;
    this.next();
    if (decorators.length) {
      throw this.raise(Errors.TrailingDecorator, {
        at: this.state.startLoc
      });
    }
    this.classScope.exit();
    return this.finishNode(classBody, "ClassBody");
  }
  parseClassMemberFromModifier(classBody, member) {
    const key = this.parseIdentifier(true);
    if (this.isClassMethod()) {
      const method = member;
      method.kind = "method";
      method.computed = false;
      method.key = key;
      method.static = false;
      this.pushClassMethod(classBody, method, false, false, false, false);
      return true;
    } else if (this.isClassProperty()) {
      const prop = member;
      prop.computed = false;
      prop.key = key;
      prop.static = false;
      classBody.body.push(this.parseClassProperty(prop));
      return true;
    }
    this.resetPreviousNodeTrailingComments(key);
    return false;
  }
  parseClassMember(classBody, member, state) {
    const isStatic = this.isContextual(106);
    if (isStatic) {
      if (this.parseClassMemberFromModifier(classBody, member)) {
        return;
      }
      if (this.eat(5)) {
        this.parseClassStaticBlock(classBody, member);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }
  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const accessorProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;
    this.parsePropertyNamePrefixOperator(member);
    if (this.eat(55)) {
      method.kind = "method";
      const isPrivateName = this.match(138);
      this.parseClassElementName(method);
      if (isPrivateName) {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }
      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(Errors.ConstructorIsGenerator, {
          at: publicMethod.key
        });
      }
      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
      return;
    }
    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
    const isPrivate = this.match(138);
    const key = this.parseClassElementName(member);
    const maybeQuestionTokenStartLoc = this.state.startLoc;
    this.parsePostMemberNameModifiers(publicMember);
    if (this.isClassMethod()) {
      method.kind = "method";
      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }
      const isConstructor = this.isNonstaticConstructor(publicMethod);
      let allowsDirectSuper = false;
      if (isConstructor) {
        publicMethod.kind = "constructor";
        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(Errors.DuplicateConstructor, {
            at: key
          });
        }
        if (isConstructor && this.hasPlugin("typescript") && member.override) {
          this.raise(Errors.OverrideOnConstructor, {
            at: key
          });
        }
        state.hadConstructor = true;
        allowsDirectSuper = state.hadSuperClass;
      }
      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(key);
      const isGenerator = this.eat(55);
      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStartLoc);
      }
      method.kind = "method";
      const isPrivate2 = this.match(138);
      this.parseClassElementName(method);
      this.parsePostMemberNameModifiers(publicMember);
      if (isPrivate2) {
        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsAsync, {
            at: publicMethod.key
          });
        }
        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
      }
    } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(key);
      method.kind = key.name;
      const isPrivate2 = this.match(138);
      this.parseClassElementName(publicMethod);
      if (isPrivate2) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsAccessor, {
            at: publicMethod.key
          });
        }
        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
      }
      this.checkGetterSetterParams(publicMethod);
    } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors");
      this.resetPreviousNodeTrailingComments(key);
      const isPrivate2 = this.match(138);
      this.parseClassElementName(publicProp);
      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
    } else if (this.isLineTerminator()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else {
      this.unexpected();
    }
  }
  parseClassElementName(member) {
    const {
      type,
      value
    } = this.state;
    if ((type === 132 || type === 133) && member.static && value === "prototype") {
      this.raise(Errors.StaticPrototype, {
        at: this.state.startLoc
      });
    }
    if (type === 138) {
      if (value === "constructor") {
        this.raise(Errors.ConstructorClassPrivateField, {
          at: this.state.startLoc
        });
      }
      const key = this.parsePrivateName();
      member.key = key;
      return key;
    }
    return this.parsePropertyName(member);
  }
  parseClassStaticBlock(classBody, member) {
    var _member$decorators;
    this.scope.enter(64 | 128 | 16);
    const oldLabels = this.state.labels;
    this.state.labels = [];
    this.prodParam.enter(PARAM);
    const body = member.body = [];
    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
    this.prodParam.exit();
    this.scope.exit();
    this.state.labels = oldLabels;
    classBody.body.push(this.finishNode(member, "StaticBlock"));
    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
      this.raise(Errors.DecoratorStaticBlock, {
        at: member
      });
    }
  }
  pushClassProperty(classBody, prop) {
    if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
      this.raise(Errors.ConstructorClassField, {
        at: prop.key
      });
    }
    classBody.body.push(this.parseClassProperty(prop));
  }
  pushClassPrivateProperty(classBody, prop) {
    const node = this.parseClassPrivateProperty(prop);
    classBody.body.push(node);
    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
  }
  pushClassAccessorProperty(classBody, prop, isPrivate) {
    if (!isPrivate && !prop.computed) {
      const key = prop.key;
      if (key.name === "constructor" || key.value === "constructor") {
        this.raise(Errors.ConstructorClassField, {
          at: key
        });
      }
    }
    const node = this.parseClassAccessorProperty(prop);
    classBody.body.push(node);
    if (isPrivate) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
  }
  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
  }
  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
    classBody.body.push(node);
    const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(node, kind);
  }
  declareClassPrivateMethodInScope(node, kind) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
  }
  parsePostMemberNameModifiers(methodOrProp) {}
  parseClassPrivateProperty(node) {
    this.parseInitializer(node);
    this.semicolon();
    return this.finishNode(node, "ClassPrivateProperty");
  }
  parseClassProperty(node) {
    this.parseInitializer(node);
    this.semicolon();
    return this.finishNode(node, "ClassProperty");
  }
  parseClassAccessorProperty(node) {
    this.parseInitializer(node);
    this.semicolon();
    return this.finishNode(node, "ClassAccessorProperty");
  }
  parseInitializer(node) {
    this.scope.enter(64 | 16);
    this.expressionScope.enter(newExpressionScope());
    this.prodParam.enter(PARAM);
    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
    this.expressionScope.exit();
    this.prodParam.exit();
    this.scope.exit();
  }
  parseClassId(node, isStatement, optionalId, bindingType = 8331) {
    if (tokenIsIdentifier(this.state.type)) {
      node.id = this.parseIdentifier();
      if (isStatement) {
        this.declareNameFromIdentifier(node.id, bindingType);
      }
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        throw this.raise(Errors.MissingClassName, {
          at: this.state.startLoc
        });
      }
    }
  }
  parseClassSuper(node) {
    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(node, decorators) {
    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    const parseAfterDefault = !hasDefault || this.eat(12);
    const hasStar = parseAfterDefault && this.eatExportStar(node);
    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
    const isFromRequired = hasDefault || hasStar;
    if (hasStar && !hasNamespace) {
      if (hasDefault)
        this.unexpected();
      if (decorators) {
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: node
        });
      }
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
      this.unexpected(null, 5);
    }
    if (hasNamespace && parseAfterNamespace) {
      this.unexpected(null, 98);
    }
    let hasDeclaration;
    if (isFromRequired || hasSpecifiers) {
      hasDeclaration = false;
      if (decorators) {
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: node
        });
      }
      this.parseExportFrom(node, isFromRequired);
    } else {
      hasDeclaration = this.maybeParseExportDeclaration(node);
    }
    if (isFromRequired || hasSpecifiers || hasDeclaration) {
      var _node2$declaration;
      const node2 = node;
      this.checkExport(node2, true, false, !!node2.source);
      if (((_node2$declaration = node2.declaration) == null ? undefined : _node2$declaration.type) === "ClassDeclaration") {
        this.maybeTakeDecorators(decorators, node2.declaration, node2);
      } else if (decorators) {
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: node
        });
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const node2 = node;
      const decl = this.parseExportDefaultExpression();
      node2.declaration = decl;
      if (decl.type === "ClassDeclaration") {
        this.maybeTakeDecorators(decorators, decl, node2);
      } else if (decorators) {
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: node
        });
      }
      this.checkExport(node2, true, true);
      return this.finishNode(node2, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(node) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? undefined : maybeDefaultIdentifier.loc.start);
      const id = maybeDefaultIdentifier || this.parseIdentifier(true);
      const specifier = this.startNodeAtNode(id);
      specifier.exported = id;
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(node) {
    if (this.isContextual(93)) {
      if (!node.specifiers)
        node.specifiers = [];
      const specifier = this.startNodeAt(this.state.lastTokStartLoc);
      this.next();
      specifier.exported = this.parseModuleExportName();
      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
      return true;
    }
    return false;
  }
  maybeParseExportNamedSpecifiers(node) {
    if (this.match(5)) {
      if (!node.specifiers)
        node.specifiers = [];
      const isTypeExport = node.exportKind === "type";
      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
      node.source = null;
      node.declaration = null;
      if (this.hasPlugin("importAssertions")) {
        node.assertions = [];
      }
      return true;
    }
    return false;
  }
  maybeParseExportDeclaration(node) {
    if (this.shouldParseExportDeclaration()) {
      node.specifiers = [];
      node.source = null;
      if (this.hasPlugin("importAssertions")) {
        node.assertions = [];
      }
      node.declaration = this.parseExportDeclaration(node);
      return true;
    }
    return false;
  }
  isAsyncFunction() {
    if (!this.isContextual(95))
      return false;
    const next = this.nextTokenInLineStart();
    return this.isUnparsedContextual(next, "function");
  }
  parseExportDefaultExpression() {
    const expr = this.startNode();
    if (this.match(68)) {
      this.next();
      return this.parseFunction(expr, 1 | 4);
    } else if (this.isAsyncFunction()) {
      this.next();
      this.next();
      return this.parseFunction(expr, 1 | 4 | 8);
    }
    if (this.match(80)) {
      return this.parseClass(expr, true, true);
    }
    if (this.match(26)) {
      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
        this.raise(Errors.DecoratorBeforeExport, {
          at: this.state.startLoc
        });
      }
      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
    }
    if (this.match(75) || this.match(74) || this.isLet()) {
      throw this.raise(Errors.UnsupportedDefaultExport, {
        at: this.state.startLoc
      });
    }
    const res = this.parseMaybeAssignAllowIn();
    this.semicolon();
    return res;
  }
  parseExportDeclaration(node) {
    if (this.match(80)) {
      const node2 = this.parseClass(this.startNode(), true, false);
      return node2;
    }
    return this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type
    } = this.state;
    if (tokenIsIdentifier(type)) {
      if (type === 95 && !this.state.containsEsc || type === 100) {
        return false;
      }
      if ((type === 130 || type === 129) && !this.state.containsEsc) {
        const {
          type: nextType
        } = this.lookahead();
        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
          this.expectOnePlugin(["flow", "typescript"]);
          return false;
        }
      }
    } else if (!this.match(65)) {
      return false;
    }
    const next = this.nextTokenStart();
    const hasFrom = this.isUnparsedContextual(next, "from");
    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
      return true;
    }
    if (this.match(65) && hasFrom) {
      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
      return nextAfterFrom === 34 || nextAfterFrom === 39;
    }
    return false;
  }
  parseExportFrom(node, expect) {
    if (this.eatContextual(98)) {
      node.source = this.parseImportSource();
      this.checkExport(node);
      this.maybeParseImportAttributes(node);
      this.checkJSONModuleImport(node);
    } else if (expect) {
      this.unexpected();
    }
    this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type
    } = this.state;
    if (type === 26) {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      if (this.hasPlugin("decorators")) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
          this.raise(Errors.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        }
        return true;
      }
    }
    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      var _node$specifiers;
      if (isDefault) {
        this.checkDuplicateExports(node, "default");
        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;
          const declaration = node.declaration;
          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
            this.raise(Errors.ExportDefaultFromAsIdentifier, {
              at: declaration
            });
          }
        }
      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
        for (const specifier of node.specifiers) {
          const {
            exported
          } = specifier;
          const exportName = exported.type === "Identifier" ? exported.name : exported.value;
          this.checkDuplicateExports(specifier, exportName);
          if (!isFrom && specifier.local) {
            const {
              local
            } = specifier;
            if (local.type !== "Identifier") {
              this.raise(Errors.ExportBindingIsString, {
                at: specifier,
                localName: local.value,
                exportName
              });
            } else {
              this.checkReservedWord(local.name, local.loc.start, true, false);
              this.scope.checkLocalExport(local);
            }
          }
        }
      } else if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          const id = node.declaration.id;
          if (!id)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(node, id.name);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (const declaration of node.declaration.declarations) {
            this.checkDeclaration(declaration.id);
          }
        }
      }
    }
  }
  checkDeclaration(node) {
    if (node.type === "Identifier") {
      this.checkDuplicateExports(node, node.name);
    } else if (node.type === "ObjectPattern") {
      for (const prop of node.properties) {
        this.checkDeclaration(prop);
      }
    } else if (node.type === "ArrayPattern") {
      for (const elem of node.elements) {
        if (elem) {
          this.checkDeclaration(elem);
        }
      }
    } else if (node.type === "ObjectProperty") {
      this.checkDeclaration(node.value);
    } else if (node.type === "RestElement") {
      this.checkDeclaration(node.argument);
    } else if (node.type === "AssignmentPattern") {
      this.checkDeclaration(node.left);
    }
  }
  checkDuplicateExports(node, exportName) {
    if (this.exportedIdentifiers.has(exportName)) {
      if (exportName === "default") {
        this.raise(Errors.DuplicateDefaultExport, {
          at: node
        });
      } else {
        this.raise(Errors.DuplicateExport, {
          at: node,
          exportName
        });
      }
    }
    this.exportedIdentifiers.add(exportName);
  }
  parseExportSpecifiers(isInTypeExport) {
    const nodes = [];
    let first = true;
    this.expect(5);
    while (!this.eat(8)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
        if (this.eat(8))
          break;
      }
      const isMaybeTypeOnly = this.isContextual(130);
      const isString = this.match(133);
      const node = this.startNode();
      node.local = this.parseModuleExportName();
      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
    }
    return nodes;
  }
  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      node.exported = this.parseModuleExportName();
    } else if (isString) {
      node.exported = cloneStringLiteral(node.local);
    } else if (!node.exported) {
      node.exported = cloneIdentifier(node.local);
    }
    return this.finishNode(node, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(133)) {
      const result = this.parseStringLiteral(this.state.value);
      const surrogate = result.value.match(loneSurrogate);
      if (surrogate) {
        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
          at: result,
          surrogateCharCode: surrogate[0].charCodeAt(0)
        });
      }
      return result;
    }
    return this.parseIdentifier(true);
  }
  isJSONModuleImport(node) {
    if (node.assertions != null) {
      return node.assertions.some(({
        key,
        value
      }) => {
        return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
      });
    }
    return false;
  }
  checkImportReflection(node) {
    const {
      specifiers
    } = node;
    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
    if (node.phase === "source") {
      if (singleBindingType !== "ImportDefaultSpecifier") {
        this.raise(Errors.SourcePhaseImportRequiresDefault, {
          at: specifiers[0].loc.start
        });
      }
    } else if (node.phase === "defer") {
      if (singleBindingType !== "ImportNamespaceSpecifier") {
        this.raise(Errors.DeferImportRequiresNamespace, {
          at: specifiers[0].loc.start
        });
      }
    } else if (node.module) {
      var _node$assertions;
      if (singleBindingType !== "ImportDefaultSpecifier") {
        this.raise(Errors.ImportReflectionNotBinding, {
          at: specifiers[0].loc.start
        });
      }
      if (((_node$assertions = node.assertions) == null ? undefined : _node$assertions.length) > 0) {
        this.raise(Errors.ImportReflectionHasAssertion, {
          at: node.specifiers[0].loc.start
        });
      }
    }
  }
  checkJSONModuleImport(node) {
    if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
      const {
        specifiers
      } = node;
      if (specifiers != null) {
        const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
          let imported;
          if (specifier.type === "ExportSpecifier") {
            imported = specifier.local;
          } else if (specifier.type === "ImportSpecifier") {
            imported = specifier.imported;
          }
          if (imported !== undefined) {
            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
          }
        });
        if (nonDefaultNamedSpecifier !== undefined) {
          this.raise(Errors.ImportJSONBindingNotDefault, {
            at: nonDefaultNamedSpecifier.loc.start
          });
        }
      }
    }
  }
  isPotentialImportPhase(isExport) {
    if (isExport)
      return false;
    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
  }
  applyImportPhase(node, isExport, phase, loc) {
    if (isExport) {
      return;
    }
    if (phase === "module") {
      this.expectPlugin("importReflection", loc);
      node.module = true;
    } else if (this.hasPlugin("importReflection")) {
      node.module = false;
    }
    if (phase === "source") {
      this.expectPlugin("sourcePhaseImports", loc);
      node.phase = "source";
    } else if (phase === "defer") {
      this.expectPlugin("deferredImportEvaluation", loc);
      node.phase = "defer";
    } else if (this.hasPlugin("sourcePhaseImports")) {
      node.phase = null;
    }
  }
  parseMaybeImportPhase(node, isExport) {
    if (!this.isPotentialImportPhase(isExport)) {
      this.applyImportPhase(node, isExport, null);
      return null;
    }
    const phaseIdentifier = this.parseIdentifier(true);
    const {
      type
    } = this.state;
    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    if (isImportPhase) {
      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
      return null;
    } else {
      this.applyImportPhase(node, isExport, null);
      return phaseIdentifier;
    }
  }
  isPrecedingIdImportPhase(phase) {
    const {
      type
    } = this.state;
    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
  }
  parseImport(node) {
    if (this.match(133)) {
      return this.parseImportSourceAndAttributes(node);
    }
    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
  }
  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
    node.specifiers = [];
    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
    const parseNext = !hasDefault || this.eat(12);
    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
    if (parseNext && !hasStar)
      this.parseNamedImportSpecifiers(node);
    this.expectContextual(98);
    return this.parseImportSourceAndAttributes(node);
  }
  parseImportSourceAndAttributes(node) {
    var _node$specifiers2;
    (_node$specifiers2 = node.specifiers) != null || (node.specifiers = []);
    node.source = this.parseImportSource();
    this.maybeParseImportAttributes(node);
    this.checkImportReflection(node);
    this.checkJSONModuleImport(node);
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }
  parseImportSource() {
    if (!this.match(133))
      this.unexpected();
    return this.parseExprAtom();
  }
  parseImportSpecifierLocal(node, specifier, type) {
    specifier.local = this.parseIdentifier();
    node.specifiers.push(this.finishImportSpecifier(specifier, type));
  }
  finishImportSpecifier(specifier, type, bindingType = 8201) {
    this.checkLVal(specifier.local, {
      in: {
        type
      },
      binding: bindingType
    });
    return this.finishNode(specifier, type);
  }
  parseImportAttributes() {
    this.expect(5);
    const attrs = [];
    const attrNames = new Set;
    do {
      if (this.match(8)) {
        break;
      }
      const node = this.startNode();
      const keyName = this.state.value;
      if (attrNames.has(keyName)) {
        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: keyName
        });
      }
      attrNames.add(keyName);
      if (this.match(133)) {
        node.key = this.parseStringLiteral(keyName);
      } else {
        node.key = this.parseIdentifier(true);
      }
      this.expect(14);
      if (!this.match(133)) {
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      }
      node.value = this.parseStringLiteral(this.state.value);
      attrs.push(this.finishNode(node, "ImportAttribute"));
    } while (this.eat(12));
    this.expect(8);
    return attrs;
  }
  parseModuleAttributes() {
    const attrs = [];
    const attributes = new Set;
    do {
      const node = this.startNode();
      node.key = this.parseIdentifier(true);
      if (node.key.name !== "type") {
        this.raise(Errors.ModuleAttributeDifferentFromType, {
          at: node.key
        });
      }
      if (attributes.has(node.key.name)) {
        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
          at: node.key,
          key: node.key.name
        });
      }
      attributes.add(node.key.name);
      this.expect(14);
      if (!this.match(133)) {
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      }
      node.value = this.parseStringLiteral(this.state.value);
      attrs.push(this.finishNode(node, "ImportAttribute"));
    } while (this.eat(12));
    return attrs;
  }
  maybeParseImportAttributes(node) {
    let attributes;
    let useWith = false;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
        return;
      }
      this.next();
      {
        if (this.hasPlugin("moduleAttributes")) {
          attributes = this.parseModuleAttributes();
        } else {
          this.expectImportAttributesPlugin();
          attributes = this.parseImportAttributes();
        }
      }
      useWith = true;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
      if (this.hasPlugin("importAttributes")) {
        if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
          this.raise(Errors.ImportAttributesUseAssert, {
            at: this.state.startLoc
          });
        }
        this.addExtra(node, "deprecatedAssertSyntax", true);
      } else {
        this.expectOnePlugin(["importAttributes", "importAssertions"]);
      }
      this.next();
      attributes = this.parseImportAttributes();
    } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
      attributes = [];
    } else {
      if (this.hasPlugin("moduleAttributes")) {
        attributes = [];
      } else
        return;
    }
    if (!useWith && this.hasPlugin("importAssertions")) {
      node.assertions = attributes;
    } else {
      node.attributes = attributes;
    }
  }
  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
    if (maybeDefaultIdentifier) {
      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
      specifier.local = maybeDefaultIdentifier;
      node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
      return true;
    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
      return true;
    }
    return false;
  }
  maybeParseStarImportSpecifier(node) {
    if (this.match(55)) {
      const specifier = this.startNode();
      this.next();
      this.expectContextual(93);
      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
      return true;
    }
    return false;
  }
  parseNamedImportSpecifiers(node) {
    let first = true;
    this.expect(5);
    while (!this.eat(8)) {
      if (first) {
        first = false;
      } else {
        if (this.eat(14)) {
          throw this.raise(Errors.DestructureNamedImport, {
            at: this.state.startLoc
          });
        }
        this.expect(12);
        if (this.eat(8))
          break;
      }
      const specifier = this.startNode();
      const importedIsString = this.match(133);
      const isMaybeTypeOnly = this.isContextual(130);
      specifier.imported = this.parseModuleExportName();
      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
      node.specifiers.push(importSpecifier);
    }
  }
  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    if (this.eatContextual(93)) {
      specifier.local = this.parseIdentifier();
    } else {
      const {
        imported
      } = specifier;
      if (importedIsString) {
        throw this.raise(Errors.ImportBindingIsString, {
          at: specifier,
          importName: imported.value
        });
      }
      this.checkReservedWord(imported.name, specifier.loc.start, true, true);
      if (!specifier.local) {
        specifier.local = cloneIdentifier(imported);
      }
    }
    return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
  }
  isThisParam(param) {
    return param.type === "Identifier" && param.name === "this";
  }
}
var Parser$2 = class Parser3 extends StatementParser {
  constructor(options3, input) {
    options3 = getOptions(options3);
    super(options3, input);
    this.options = options3;
    this.initializeScopes();
    this.plugins = pluginsMap(this.options.plugins);
    this.filename = options3.sourceFilename;
  }
  getScopeHandler() {
    return ScopeHandler;
  }
  parse() {
    this.enterInitialScopes();
    const file = this.startNode();
    const program = this.startNode();
    this.nextToken();
    file.errors = null;
    this.parseTopLevel(file, program);
    file.errors = this.state.errors;
    return file;
  }
};
function pluginsMap(plugins) {
  const pluginMap = new Map;
  for (const plugin of plugins) {
    const [name3, options3] = Array.isArray(plugin) ? plugin : [plugin, {}];
    if (!pluginMap.has(name3))
      pluginMap.set(name3, options3 || {});
  }
  return pluginMap;
}
function parse$9(input, options3) {
  var _options;
  if (((_options = options3) == null ? undefined : _options.sourceType) === "unambiguous") {
    options3 = Object.assign({}, options3);
    try {
      options3.sourceType = "module";
      const parser = getParser(options3, input);
      const ast = parser.parse();
      if (parser.sawUnambiguousESM) {
        return ast;
      }
      if (parser.ambiguousScriptDifferentAst) {
        try {
          options3.sourceType = "script";
          return getParser(options3, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }
      return ast;
    } catch (moduleError) {
      try {
        options3.sourceType = "script";
        return getParser(options3, input).parse();
      } catch (_unused2) {}
      throw moduleError;
    }
  } else {
    return getParser(options3, input).parse();
  }
}
function parseExpression(input, options3) {
  const parser = getParser(options3, input);
  if (parser.options.strictMode) {
    parser.state.strict = true;
  }
  return parser.getExpression();
}
function generateExportedTokenTypes(internalTokenTypes) {
  const tokenTypes = {};
  for (const typeName of Object.keys(internalTokenTypes)) {
    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
  }
  return tokenTypes;
}
var tokTypes = generateExportedTokenTypes(tt);
function getParser(options3, input) {
  let cls = Parser$2;
  if (options3 != null && options3.plugins) {
    validatePlugins(options3.plugins);
    cls = getParserClass(options3.plugins);
  }
  return new cls(options3, input);
}
var parserClassCache = {};
function getParserClass(pluginsFromOptions) {
  const pluginList = mixinPluginNames.filter((name3) => hasPlugin(pluginsFromOptions, name3));
  const key = pluginList.join("/");
  let cls = parserClassCache[key];
  if (!cls) {
    cls = Parser$2;
    for (const plugin of pluginList) {
      cls = mixinPlugins[plugin](cls);
    }
    parserClassCache[key] = cls;
  }
  return cls;
}
var parse_1$1 = lib.parse = parse$9;
var parseExpression_1 = lib.parseExpression = parseExpression;
lib.tokTypes = tokTypes;
var isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
var isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate$1(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
var nonIdentifierRE = /^\d|[^\$\w]/;
var isSimpleIdentifier = (name3) => !nonIdentifierRE.test(name3);
var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
var isMemberExpressionBrowser = (path2) => {
  path2 = path2.trim().replace(whitespaceRE, (s2) => s2.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0;i < path2.length; i++) {
    const char = path2.charAt(i);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path2.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
var isMemberExpressionNode = (path2, context) => {
  try {
    let ret = parseExpression_1(path2, {
      plugins: context.expressionPlugins
    });
    if (ret.type === "TSAsExpression" || ret.type === "TSTypeAssertion") {
      ret = ret.expression;
    }
    return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier";
  } catch (e2) {
    return false;
  }
};
var isMemberExpression = isMemberExpressionNode;
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0;i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name3, allowEmpty = false) {
  for (let i = 0;i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString$2(name3) ? p2.name === name3 : name3.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node, name3, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0;i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (dynamicOnly)
        continue;
      if (p2.name === name3 && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name3)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name3) {
  return !!(arg && isStaticExp(arg) && arg.content === name3);
}
function hasDynamicKeyVBind(node) {
  return node.props.some((p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic));
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString$2(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString$2(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString$2(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString$2(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString$2(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
  }
  return result;
}
function toValidAssetId(name3, type) {
  return `_${type}_${name3.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name3.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0;i < node.props.length; i++) {
        const p2 = node.props[i];
        if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c3) => hasScopeRef(c3, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c3) => hasScopeRef(c3, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c3) => hasScopeRef(c3, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c3) => isObject$2(c3) && hasScopeRef(c3, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
var deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_PROP"]: {
    message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTER"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, context) {
  const config3 = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config3 && config3[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled2 = isCompatEnabled(key, context);
  if (enabled2) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled2;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link: link2 } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link2 ? `
  Details: ${link2}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap3 = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
var defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap3[p1]),
  onError: defaultOnError$1,
  onWarn: defaultOnWarn,
  comments: true
};
function baseParse(content, options3 = {}) {
  const context = createParserContext(content, options3);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options3 = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options3[key] = rawOptions[key] === undefined ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options: options3,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options3.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s2 = context.source;
    let node = undefined;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s2, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s2[0] === "<") {
        if (s2.length === 1) {
          emitError(context, 5, 1);
        } else if (s2[1] === "!") {
          if (startsWith(s2, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s2, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s2, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s2[1] === "/") {
          if (s2.length === 2) {
            emitError(context, 5, 2);
          } else if (s2[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s2[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s2[1])) {
          node = parseElement(context, ancestors);
        } else if (s2[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray$3(node)) {
      for (let i = 0;i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      if (node.type === 2) {
        if (!context.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else {
          node.content = node.content.replace(/\r\n/g, `
`);
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s2 = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s2.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s2.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
var isSpecialTemplateDirective = /* @__PURE__ */ makeMap$1(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p2) => p2.type === 7 && p2.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p2) => p2.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined
  };
}
function isComponent(tag, props, context) {
  const options3 = context.options;
  if (options3.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options3.isBuiltInComponent && options3.isBuiltInComponent(tag) || options3.isNativeTag && !options3.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0;i < props.length; i++) {
    const p2 = props[i];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        }
      }
    } else {
      if (p2.name === "is") {
        return true;
      } else if (p2.name === "bind" && isStaticArgOf(p2.arg, "is") && false) {}
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames2 = /* @__PURE__ */ new Set;
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames2);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  var _a3;
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name3 = match[0];
  if (nameSet.has(name3)) {
    emitError(context, 2);
  }
  nameSet.add(name3);
  if (name3[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern2 = /["'<]/g;
    let m2;
    while (m2 = pattern2.exec(name3)) {
      emitError(context, 17, m2.index);
    }
  }
  advanceBy(context, name3.length);
  let value = undefined;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name3)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name3);
    let isPropShorthand = startsWith(name3, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name3, ":") ? "bind" : startsWith(name3, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name3.lastIndexOf(match2[2], name3.length - (((_a3 = match2[3]) == null ? undefined : _a3.length) || 0));
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name3, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name: name3,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return;
    }
    const unexpectedChars = /["'<=`]/g;
    let m2;
    while (m2 = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m2.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0;i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs2) {
  return xs2[xs2.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s2 = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s2, "</")) {
        for (let i = ancestors.length - 1;i >= 0; --i) {
          if (startsWithEndTagOpen(s2, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s2, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s2, "]]>")) {
        return true;
      }
      break;
  }
  return !s2;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk$2(root, context, isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk$2(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0;i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ` /* HOISTED */`;
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk$2(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk$2(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0;i2 < child.branches.length; i2++) {
        walk$2(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray$3(node.codegenNode.children)) {
    const hoisted = context.hoist(createArrayExpression(node.codegenNode.children));
    if (context.hmr) {
      hoisted.content = `[...${hoisted.content}]`;
    }
    node.codegenNode.children = hoisted;
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== undefined) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0;i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0;i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0;i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0;i < node.children.length; i++) {
        const child = node.children[i];
        if (isString$2(child) || isSymbol$1(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      return 0;
  }
}
var allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString$2(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0;i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : undefined;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP$1,
  isCustomElement = NOOP$1,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError$1,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize$1(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root,
    helpers: /* @__PURE__ */ new Map,
    components: /* @__PURE__ */ new Set,
    directives: /* @__PURE__ */ new Set,
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap,
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    helper(name3) {
      const count = context.helpers.get(name3) || 0;
      context.helpers.set(name3, count + 1);
      return name3;
    },
    removeHelper(name3) {
      const count = context.helpers.get(name3);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name3);
        } else {
          context.helpers.set(name3, currentCount);
        }
      }
    },
    helperString(name3) {
      return `_${helperNameMap[context.helper(name3)]}`;
    },
    replaceNode(node) {
      {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {},
    addIdentifiers(exp) {
      {
        if (isString$2(exp)) {
          addId(exp);
        } else if (exp.identifiers) {
          exp.identifiers.forEach(addId);
        } else if (exp.type === 4) {
          addId(exp.content);
        }
      }
    },
    removeIdentifiers(exp) {
      {
        if (isString$2(exp)) {
          removeId(exp);
        } else if (exp.identifiers) {
          exp.identifiers.forEach(removeId);
        } else if (exp.type === 4) {
          removeId(exp.content);
        }
      }
    },
    hoist(exp) {
      if (isString$2(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  function addId(id) {
    const { identifiers } = context;
    if (identifiers[id] === undefined) {
      identifiers[id] = 0;
    }
    identifiers[id]++;
  }
  function removeId(id) {
    context.identifiers[id]--;
  }
  return context;
}
function transform$1(root, options3) {
  const context = createTransformContext(root, options3);
  traverseNode$1(root, context);
  if (options3.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options3.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c3) => c3.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ` /* ${patchFlagText} */`, undefined, undefined, true, undefined, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (;i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString$2(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode$1(child, context);
  }
}
function traverseNode$1(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0;i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray$3(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0;i2 < node.branches.length; i2++) {
        traverseNode$1(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name3, fn2) {
  const matches = isString$2(name3) ? (n2) => n2 === name3 : (n2) => name3.test(n2);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0;i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn2(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
var sourceMap$2 = {};
var sourceMapGenerator$1 = {};
var base64Vlq$1 = {};
var base64$3 = {};
var intToCharMap$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
base64$3.encode = function(number) {
  if (0 <= number && number < intToCharMap$1.length) {
    return intToCharMap$1[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};
base64$3.decode = function(charCode) {
  var bigA = 65;
  var bigZ = 90;
  var littleA = 97;
  var littleZ = 122;
  var zero = 48;
  var nine = 57;
  var plus = 43;
  var slash = 47;
  var littleOffset = 26;
  var numberOffset = 52;
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }
  if (charCode == plus) {
    return 62;
  }
  if (charCode == slash) {
    return 63;
  }
  return -1;
};
var base64$2 = base64$3;
var VLQ_BASE_SHIFT$1 = 5;
var VLQ_BASE$1 = 1 << VLQ_BASE_SHIFT$1;
var VLQ_BASE_MASK$1 = VLQ_BASE$1 - 1;
var VLQ_CONTINUATION_BIT$1 = VLQ_BASE$1;
function toVLQSigned$1(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
function fromVLQSigned$1(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
base64Vlq$1.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned$1(aValue);
  do {
    digit = vlq & VLQ_BASE_MASK$1;
    vlq >>>= VLQ_BASE_SHIFT$1;
    if (vlq > 0) {
      digit |= VLQ_CONTINUATION_BIT$1;
    }
    encoded += base64$2.encode(digit);
  } while (vlq > 0);
  return encoded;
};
base64Vlq$1.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;
  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }
    digit = base64$2.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }
    continuation = !!(digit & VLQ_CONTINUATION_BIT$1);
    digit &= VLQ_BASE_MASK$1;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT$1;
  } while (continuation);
  aOutParam.value = fromVLQSigned$1(result);
  aOutParam.rest = aIndex;
};
var util$c = {};
(function(exports) {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  function lruMemoize(f) {
    var cache = [];
    return function(input) {
      for (var i = 0;i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }
      var result = f(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  }
  var normalize2 = lruMemoize(function normalize(aPath) {
    var path2 = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path2 = url.path;
    }
    var isAbsolute2 = exports.isAbsolute(path2);
    var parts = [];
    var start = 0;
    var i = 0;
    while (true) {
      start = i;
      i = path2.indexOf("/", start);
      if (i === -1) {
        parts.push(path2.slice(start));
        break;
      } else {
        parts.push(path2.slice(start, i));
        while (i < path2.length && path2[i] === "/") {
          i++;
        }
      }
    }
    for (var part, up2 = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up2++;
      } else if (up2 > 0) {
        if (part === "") {
          parts.splice(i + 1, up2);
          up2 = 0;
        } else {
          parts.splice(i, 2);
          up2--;
        }
      }
    }
    path2 = parts.join("/");
    if (path2 === "") {
      path2 = isAbsolute2 ? "/" : ".";
    }
    if (url) {
      url.path = path2;
      return urlGenerate(url);
    }
    return path2;
  });
  exports.normalize = normalize2;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s2) {
    return s2;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s2) {
    if (!s2) {
      return false;
    }
    var length = s2.length;
    if (length < 9) {
      return false;
    }
    if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s2.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize2(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
})(util$c);
var arraySet$1 = {};
var util$b = util$c;
var has$1 = Object.prototype.hasOwnProperty;
var hasNativeMap$1 = typeof Map !== "undefined";
function ArraySet$5() {
  this._array = [];
  this._set = hasNativeMap$1 ? new Map : Object.create(null);
}
ArraySet$5.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$5;
  for (var i = 0, len = aArray.length;i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};
ArraySet$5.prototype.size = function ArraySet_size() {
  return hasNativeMap$1 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
ArraySet$5.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap$1 ? aStr : util$b.toSetString(aStr);
  var isDuplicate = hasNativeMap$1 ? this.has(aStr) : has$1.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap$1) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
ArraySet$5.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap$1) {
    return this._set.has(aStr);
  } else {
    var sStr = util$b.toSetString(aStr);
    return has$1.call(this._set, sStr);
  }
};
ArraySet$5.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap$1) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util$b.toSetString(aStr);
    if (has$1.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }
  throw new Error('"' + aStr + '" is not in the set.');
};
ArraySet$5.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error("No element indexed by " + aIdx);
};
ArraySet$5.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};
arraySet$1.ArraySet = ArraySet$5;
var mappingList$1 = {};
var util$a = util$c;
function generatedPositionAfter$1(mappingA, mappingB) {
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util$a.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
function MappingList$3() {
  this._array = [];
  this._sorted = true;
  this._last = { generatedLine: -1, generatedColumn: 0 };
}
MappingList$3.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
MappingList$3.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter$1(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};
MappingList$3.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$a.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};
mappingList$1.MappingList = MappingList$3;
var base64VLQ$3 = base64Vlq$1;
var util$9 = util$c;
var ArraySet$4 = arraySet$1.ArraySet;
var MappingList$2 = mappingList$1.MappingList;
function SourceMapGenerator$8(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util$9.getArg(aArgs, "file", null);
  this._sourceRoot = util$9.getArg(aArgs, "sourceRoot", null);
  this._skipValidation = util$9.getArg(aArgs, "skipValidation", false);
  this._sources = new ArraySet$4;
  this._names = new ArraySet$4;
  this._mappings = new MappingList$2;
  this._sourcesContents = null;
}
SourceMapGenerator$8.prototype._version = 3;
SourceMapGenerator$8.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator$8({
    file: aSourceMapConsumer.file,
    sourceRoot
  });
  aSourceMapConsumer.eachMapping(function(mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };
    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util$9.relative(sourceRoot, newMapping.source);
      }
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };
      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }
    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util$9.relative(sourceRoot, sourceFile);
    }
    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
SourceMapGenerator$8.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util$9.getArg(aArgs, "generated");
  var original = util$9.getArg(aArgs, "original", null);
  var source = util$9.getArg(aArgs, "source", null);
  var name3 = util$9.getArg(aArgs, "name", null);
  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name3);
  }
  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }
  if (name3 != null) {
    name3 = String(name3);
    if (!this._names.has(name3)) {
      this._names.add(name3);
    }
  }
  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source,
    name: name3
  });
};
SourceMapGenerator$8.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util$9.relative(this._sourceRoot, source);
  }
  if (aSourceContent != null) {
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util$9.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    delete this._sourcesContents[util$9.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
SourceMapGenerator$8.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + `or the source map's "file" property. Both were omitted.`);
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  if (sourceRoot != null) {
    sourceFile = util$9.relative(sourceRoot, sourceFile);
  }
  var newSources = new ArraySet$4;
  var newNames = new ArraySet$4;
  this._mappings.unsortedForEach(function(mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util$9.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util$9.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }
    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }
    var name3 = mapping.name;
    if (name3 != null && !newNames.has(name3)) {
      newNames.add(name3);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;
  aSourceMapConsumer.sources.forEach(function(sourceFile2) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile2 = util$9.join(aSourceMapPath, sourceFile2);
      }
      if (sourceRoot != null) {
        sourceFile2 = util$9.relative(sourceRoot, sourceFile2);
      }
      this.setSourceContent(sourceFile2, content);
    }
  }, this);
};
SourceMapGenerator$8.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
    throw new Error("original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.");
  }
  if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    return;
  } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    return;
  } else {
    throw new Error("Invalid mapping: " + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
SourceMapGenerator$8.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = "";
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;
  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length;i < len; i++) {
    mapping = mappings[i];
    next = "";
    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ";";
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util$9.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }
    }
    next += base64VLQ$3.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;
    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ$3.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;
      next += base64VLQ$3.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ$3.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;
      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ$3.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }
    result += next;
  }
  return result;
};
SourceMapGenerator$8.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function(source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util$9.relative(aSourceRoot, source);
    }
    var key = util$9.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
SourceMapGenerator$8.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map2 = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map2.file = this._file;
  }
  if (this._sourceRoot != null) {
    map2.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
  }
  return map2;
};
SourceMapGenerator$8.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};
sourceMapGenerator$1.SourceMapGenerator = SourceMapGenerator$8;
var sourceMapConsumer$1 = {};
var binarySearch$3 = {};
(function(exports) {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
})(binarySearch$3);
var quickSort$3 = {};
function SortTemplate(comparator) {
  function swap(ary, x2, y) {
    var temp = ary[x2];
    ary[x2] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator2, p2, r3) {
    if (p2 < r3) {
      var pivotIndex = randomIntInRange(p2, r3);
      var i = p2 - 1;
      swap(ary, pivotIndex, r3);
      var pivot = ary[r3];
      for (var j = p2;j < r3; j++) {
        if (comparator2(ary[j], pivot, false) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator2, p2, q - 1);
      doQuickSort(ary, comparator2, q + 1, r3);
    }
  }
  return doQuickSort;
}
function cloneSort(comparator) {
  let template = SortTemplate.toString();
  let templateFn = new Function(`return ${template}`)();
  return templateFn(comparator);
}
var sortCache = new WeakMap;
quickSort$3.quickSort = function(ary, comparator, start = 0) {
  let doQuickSort = sortCache.get(comparator);
  if (doQuickSort === undefined) {
    doQuickSort = cloneSort(comparator);
    sortCache.set(comparator, doQuickSort);
  }
  doQuickSort(ary, comparator, start, ary.length - 1);
};
var util$8 = util$c;
var binarySearch$2 = binarySearch$3;
var ArraySet$3 = arraySet$1.ArraySet;
var base64VLQ$2 = base64Vlq$1;
var quickSort$2 = quickSort$3.quickSort;
function SourceMapConsumer$6(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$8.parseSourceMapInput(aSourceMap);
  }
  return sourceMap.sections != null ? new IndexedSourceMapConsumer$1(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer$1(sourceMap, aSourceMapURL);
}
SourceMapConsumer$6.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer$1.fromSourceMap(aSourceMap, aSourceMapURL);
};
SourceMapConsumer$6.prototype._version = 3;
SourceMapConsumer$6.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer$6.prototype, "_generatedMappings", {
  configurable: true,
  enumerable: true,
  get: function() {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__generatedMappings;
  }
});
SourceMapConsumer$6.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer$6.prototype, "_originalMappings", {
  configurable: true,
  enumerable: true,
  get: function() {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__originalMappings;
  }
});
SourceMapConsumer$6.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c3 = aStr.charAt(index);
  return c3 === ";" || c3 === ",";
};
SourceMapConsumer$6.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer$6.GENERATED_ORDER = 1;
SourceMapConsumer$6.ORIGINAL_ORDER = 2;
SourceMapConsumer$6.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer$6.LEAST_UPPER_BOUND = 2;
SourceMapConsumer$6.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer$6.GENERATED_ORDER;
  var mappings;
  switch (order) {
    case SourceMapConsumer$6.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer$6.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var sourceRoot = this.sourceRoot;
  var boundCallback = aCallback.bind(context);
  var names = this._names;
  var sources = this._sources;
  var sourceMapURL = this._sourceMapURL;
  for (var i = 0, n2 = mappings.length;i < n2; i++) {
    var mapping = mappings[i];
    var source = mapping.source === null ? null : sources.at(mapping.source);
    source = util$8.computeSourceURL(sourceRoot, source, sourceMapURL);
    boundCallback({
      source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : names.at(mapping.name)
    });
  }
};
SourceMapConsumer$6.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util$8.getArg(aArgs, "line");
  var needle = {
    source: util$8.getArg(aArgs, "source"),
    originalLine: line,
    originalColumn: util$8.getArg(aArgs, "column", 0)
  };
  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }
  var mappings = [];
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$8.compareByOriginalPositions, binarySearch$2.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util$8.getArg(mapping, "generatedLine", null),
          column: util$8.getArg(mapping, "generatedColumn", null),
          lastColumn: util$8.getArg(mapping, "lastGeneratedColumn", null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util$8.getArg(mapping, "generatedLine", null),
          column: util$8.getArg(mapping, "generatedColumn", null),
          lastColumn: util$8.getArg(mapping, "lastGeneratedColumn", null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }
  return mappings;
};
sourceMapConsumer$1.SourceMapConsumer = SourceMapConsumer$6;
function BasicSourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$8.parseSourceMapInput(aSourceMap);
  }
  var version = util$8.getArg(sourceMap, "version");
  var sources = util$8.getArg(sourceMap, "sources");
  var names = util$8.getArg(sourceMap, "names", []);
  var sourceRoot = util$8.getArg(sourceMap, "sourceRoot", null);
  var sourcesContent = util$8.getArg(sourceMap, "sourcesContent", null);
  var mappings = util$8.getArg(sourceMap, "mappings");
  var file = util$8.getArg(sourceMap, "file", null);
  if (version != this._version) {
    throw new Error("Unsupported version: " + version);
  }
  if (sourceRoot) {
    sourceRoot = util$8.normalize(sourceRoot);
  }
  sources = sources.map(String).map(util$8.normalize).map(function(source) {
    return sourceRoot && util$8.isAbsolute(sourceRoot) && util$8.isAbsolute(source) ? util$8.relative(sourceRoot, source) : source;
  });
  this._names = ArraySet$3.fromArray(names.map(String), true);
  this._sources = ArraySet$3.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function(s2) {
    return util$8.computeSourceURL(sourceRoot, s2, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}
BasicSourceMapConsumer$1.prototype = Object.create(SourceMapConsumer$6.prototype);
BasicSourceMapConsumer$1.prototype.consumer = SourceMapConsumer$6;
BasicSourceMapConsumer$1.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util$8.relative(this.sourceRoot, relativeSource);
  }
  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }
  var i;
  for (i = 0;i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }
  return -1;
};
BasicSourceMapConsumer$1.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer$1.prototype);
  var names = smc._names = ArraySet$3.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet$3.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function(s2) {
    return util$8.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
  });
  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];
  for (var i = 0, length = generatedMappings.length;i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping$1;
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;
    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;
      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }
      destOriginalMappings.push(destMapping);
    }
    destGeneratedMappings.push(destMapping);
  }
  quickSort$2(smc.__originalMappings, util$8.compareByOriginalPositions);
  return smc;
};
BasicSourceMapConsumer$1.prototype._version = 3;
Object.defineProperty(BasicSourceMapConsumer$1.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function Mapping$1() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
var compareGenerated = util$8.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
  let l2 = array.length;
  let n2 = array.length - start;
  if (n2 <= 1) {
    return;
  } else if (n2 == 2) {
    let a = array[start];
    let b = array[start + 1];
    if (compareGenerated(a, b) > 0) {
      array[start] = b;
      array[start + 1] = a;
    }
  } else if (n2 < 20) {
    for (let i = start;i < l2; i++) {
      for (let j = i;j > start; j--) {
        let a = array[j - 1];
        let b = array[j];
        if (compareGenerated(a, b) <= 0) {
          break;
        }
        array[j - 1] = b;
        array[j] = a;
      }
    }
  } else {
    quickSort$2(array, compareGenerated, start);
  }
}
BasicSourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings2(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, segment, end, value;
  let subarrayStart = 0;
  while (index < length) {
    if (aStr.charAt(index) === ";") {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
      sortGenerated(generatedMappings, subarrayStart);
      subarrayStart = generatedMappings.length;
    } else if (aStr.charAt(index) === ",") {
      index++;
    } else {
      mapping = new Mapping$1;
      mapping.generatedLine = generatedLine;
      for (end = index;end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      aStr.slice(index, end);
      segment = [];
      while (index < end) {
        base64VLQ$2.decode(aStr, index, temp);
        value = temp.value;
        index = temp.rest;
        segment.push(value);
      }
      if (segment.length === 2) {
        throw new Error("Found a source, but no line and column");
      }
      if (segment.length === 3) {
        throw new Error("Found a source and line, but no column");
      }
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;
      if (segment.length > 1) {
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        mapping.originalLine += 1;
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;
        if (segment.length > 4) {
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }
      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === "number") {
        let currentSource = mapping.source;
        while (originalMappings.length <= currentSource) {
          originalMappings.push(null);
        }
        if (originalMappings[currentSource] === null) {
          originalMappings[currentSource] = [];
        }
        originalMappings[currentSource].push(mapping);
      }
    }
  }
  sortGenerated(generatedMappings, subarrayStart);
  this.__generatedMappings = generatedMappings;
  for (var i = 0;i < originalMappings.length; i++) {
    if (originalMappings[i] != null) {
      quickSort$2(originalMappings[i], util$8.compareByOriginalPositionsNoSource);
    }
  }
  this.__originalMappings = [].concat(...originalMappings);
};
BasicSourceMapConsumer$1.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
  }
  return binarySearch$2.search(aNeedle, aMappings, aComparator, aBias);
};
BasicSourceMapConsumer$1.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0;index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];
      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }
    mapping.lastGeneratedColumn = Infinity;
  }
};
BasicSourceMapConsumer$1.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util$8.getArg(aArgs, "line"),
    generatedColumn: util$8.getArg(aArgs, "column")
  };
  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$8.compareByGeneratedPositionsDeflated, util$8.getArg(aArgs, "bias", SourceMapConsumer$6.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._generatedMappings[index];
    if (mapping.generatedLine === needle.generatedLine) {
      var source = util$8.getArg(mapping, "source", null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util$8.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name3 = util$8.getArg(mapping, "name", null);
      if (name3 !== null) {
        name3 = this._names.at(name3);
      }
      return {
        source,
        line: util$8.getArg(mapping, "originalLine", null),
        column: util$8.getArg(mapping, "originalColumn", null),
        name: name3
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
BasicSourceMapConsumer$1.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc2) {
    return sc2 == null;
  });
};
BasicSourceMapConsumer$1.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }
  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util$8.relative(this.sourceRoot, relativeSource);
  }
  var url;
  if (this.sourceRoot != null && (url = util$8.urlParse(this.sourceRoot))) {
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }
    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
BasicSourceMapConsumer$1.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util$8.getArg(aArgs, "source");
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  var needle = {
    source,
    originalLine: util$8.getArg(aArgs, "line"),
    originalColumn: util$8.getArg(aArgs, "column")
  };
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$8.compareByOriginalPositions, util$8.getArg(aArgs, "bias", SourceMapConsumer$6.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (mapping.source === needle.source) {
      return {
        line: util$8.getArg(mapping, "generatedLine", null),
        column: util$8.getArg(mapping, "generatedColumn", null),
        lastColumn: util$8.getArg(mapping, "lastGeneratedColumn", null)
      };
    }
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
sourceMapConsumer$1.BasicSourceMapConsumer = BasicSourceMapConsumer$1;
function IndexedSourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$8.parseSourceMapInput(aSourceMap);
  }
  var version = util$8.getArg(sourceMap, "version");
  var sections = util$8.getArg(sourceMap, "sections");
  if (version != this._version) {
    throw new Error("Unsupported version: " + version);
  }
  this._sources = new ArraySet$3;
  this._names = new ArraySet$3;
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function(s2) {
    if (s2.url) {
      throw new Error("Support for url field in sections not implemented.");
    }
    var offset = util$8.getArg(s2, "offset");
    var offsetLine = util$8.getArg(offset, "line");
    var offsetColumn = util$8.getArg(offset, "column");
    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error("Section offsets must be ordered and non-overlapping.");
    }
    lastOffset = offset;
    return {
      generatedOffset: {
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer$6(util$8.getArg(s2, "map"), aSourceMapURL)
    };
  });
}
IndexedSourceMapConsumer$1.prototype = Object.create(SourceMapConsumer$6.prototype);
IndexedSourceMapConsumer$1.prototype.constructor = SourceMapConsumer$6;
IndexedSourceMapConsumer$1.prototype._version = 3;
Object.defineProperty(IndexedSourceMapConsumer$1.prototype, "sources", {
  get: function() {
    var sources = [];
    for (var i = 0;i < this._sections.length; i++) {
      for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});
IndexedSourceMapConsumer$1.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util$8.getArg(aArgs, "line"),
    generatedColumn: util$8.getArg(aArgs, "column")
  };
  var sectionIndex = binarySearch$2.search(needle, this._sections, function(needle2, section2) {
    var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }
    return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];
  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }
  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
IndexedSourceMapConsumer$1.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function(s2) {
    return s2.consumer.hasContentsOfAllSources();
  });
};
IndexedSourceMapConsumer$1.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
IndexedSourceMapConsumer$1.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    if (section.consumer._findSourceIndex(util$8.getArg(aArgs, "source")) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }
  return {
    line: null,
    column: null
  };
};
IndexedSourceMapConsumer$1.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0;j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];
      var source = section.consumer._sources.at(mapping.source);
      source = util$8.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);
      var name3 = null;
      if (mapping.name) {
        name3 = section.consumer._names.at(mapping.name);
        this._names.add(name3);
        name3 = this._names.indexOf(name3);
      }
      var adjustedMapping = {
        source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name3
      };
      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === "number") {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }
  quickSort$2(this.__generatedMappings, util$8.compareByGeneratedPositionsDeflated);
  quickSort$2(this.__originalMappings, util$8.compareByOriginalPositions);
};
sourceMapConsumer$1.IndexedSourceMapConsumer = IndexedSourceMapConsumer$1;
var sourceNode$1 = {};
var SourceMapGenerator$7 = sourceMapGenerator$1.SourceMapGenerator;
var util$7 = util$c;
var REGEX_NEWLINE$1 = /(\r?\n)/;
var NEWLINE_CODE$1 = 10;
var isSourceNode$1 = "$$$isSourceNode$$$";
function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode$1] = true;
  if (aChunks != null)
    this.add(aChunks);
}
SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  var node = new SourceNode$1;
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE$1);
  var remainingLinesIndex = 0;
  var shiftNextLine = function() {
    var lineContents = getNextLine();
    var newLine = getNextLine() || "";
    return lineContents + newLine;
    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };
  var lastGeneratedLine = 1, lastGeneratedColumn = 0;
  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function(mapping) {
    if (lastMapping !== null) {
      if (lastGeneratedLine < mapping.generatedLine) {
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
      } else {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        lastMapping = mapping;
        return;
      }
    }
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || "";
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util$7.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });
  return node;
  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util$7.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode$1(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function(chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode$1] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};
SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1;i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode$1] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};
SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length;i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode$1]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== "") {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
SourceNode$1.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0;i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};
SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode$1]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === "string") {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push("".replace(aPattern, aReplacement));
  }
  return this;
};
SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util$7.toSetString(aSourceFile)] = aSourceContent;
};
SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length;i < len; i++) {
    if (this.children[i][isSourceNode$1]) {
      this.children[i].walkSourceContents(aFn);
    }
  }
  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length;i < len; i++) {
    aFn(util$7.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
SourceNode$1.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function(chunk) {
    str += chunk;
  });
  return str;
};
SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map2 = new SourceMapGenerator$7(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function(chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map2.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map2.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length;idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE$1) {
        generated.line++;
        generated.column = 0;
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map2.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function(sourceFile, sourceContent) {
    map2.setSourceContent(sourceFile, sourceContent);
  });
  return { code: generated.code, map: map2 };
};
sourceNode$1.SourceNode = SourceNode$1;
var SourceMapGenerator$6 = sourceMap$2.SourceMapGenerator = sourceMapGenerator$1.SourceMapGenerator;
var SourceMapConsumer$5 = sourceMap$2.SourceMapConsumer = sourceMapConsumer$1.SourceMapConsumer;
sourceMap$2.SourceNode = sourceNode$1.SourceNode;
var PURE_ANNOTATION = `/*#__PURE__*/`;
var aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: undefined,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
      if (context.map) {
        if (node) {
          let name3;
          if (node.type === 4 && !node.isStatic) {
            const content = node.content.replace(/^_ctx\./, "");
            if (content !== node.content && isSimpleIdentifier(content)) {
              name3 = content;
            }
          }
          addMapping(node.loc.start, name3);
        }
        advancePositionWithMutation(context, code);
        if (node && node.loc !== locStub) {
          addMapping(node.loc.end);
        }
      }
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n2) {
    context.push(`
` + `  `.repeat(n2));
  }
  function addMapping(loc, name3) {
    context.map.addMapping({
      name: name3,
      source: context.filename,
      original: {
        line: loc.line,
        column: loc.column - 1
      },
      generated: {
        line: context.line,
        column: context.column - 1
      }
    });
  }
  if (sourceMap) {
    context.map = new SourceMapGenerator$6;
    context.map.setSourceContent(filename, context.source);
  }
  return context;
}
function generate$1(ast, options3 = {}) {
  const context = createCodegenContext(ast, options3);
  if (options3.onContextCreated)
    options3.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const genScopeId = scopeId != null && mode === "module";
  const isSetupInlined = !!options3.inline;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options3) : context;
  if (mode === "module") {
    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
  } else {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  if (options3.bindingMetadata && !options3.inline) {
    args.push("$props", "$setup", "$data", "$options");
  }
  const signature = options3.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
  if (isSetupInlined) {
    push(`(${signature}) => {`);
  } else {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0;i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    map: context.map ? context.map.toJSON() : undefined
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    if (prefixIdentifiers) {
      push(`const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`);
    } else {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  if (ast.ssrHelpers && ast.ssrHelpers.length) {
    push(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`);
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genModulePreamble(ast, context, genScopeId, inline) {
  const {
    push,
    newline,
    optimizeImports,
    runtimeModuleName,
    ssrRuntimeModuleName
  } = context;
  if (genScopeId && ast.hoists.length) {
    ast.helpers.add(PUSH_SCOPE_ID);
    ast.helpers.add(POP_SCOPE_ID);
  }
  if (ast.helpers.size) {
    const helpers = Array.from(ast.helpers);
    if (optimizeImports) {
      push(`import { ${helpers.map((s2) => helperNameMap[s2]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
      push(`
// Binding optimization for webpack code-split
const ${helpers.map((s2) => `_${helperNameMap[s2]} = ${helperNameMap[s2]}`).join(", ")}
`);
    } else {
      push(`import { ${helpers.map((s2) => `${helperNameMap[s2]} as _${helperNameMap[s2]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
    }
  }
  if (ast.ssrHelpers && ast.ssrHelpers.length) {
    push(`import { ${ast.ssrHelpers.map((s2) => `${helperNameMap[s2]} as _${helperNameMap[s2]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`);
  }
  if (ast.imports.length) {
    genImports(ast.imports, context);
    newline();
  }
  genHoists(ast.hoists, context);
  newline();
  if (!inline) {
    push(`export `);
  }
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0;i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  const genScopeId = scopeId != null && mode !== "function";
  newline();
  if (genScopeId) {
    push(`const _withScopeId = n => (${helper(PUSH_SCOPE_ID)}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`);
    newline();
  }
  for (let i = 0;i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      const needScopeIdWrapper = genScopeId && exp.type === 13;
      push(`const _hoisted_${i + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`);
      genNode(exp, context);
      if (needScopeIdWrapper) {
        push(`)`);
      }
      newline();
    }
  }
  context.pure = false;
}
function genImports(importsOptions, context) {
  if (!importsOptions.length) {
    return;
  }
  importsOptions.forEach((imports2) => {
    context.push(`import `);
    genNode(imports2.exp, context);
    context.push(` from '${imports2.path}'`);
    context.newline();
  });
}
function isText2(n2) {
  return isString$2(n2) || n2.type === 4 || n2.type === 2 || n2.type === 5 || n2.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n2) => isArray$3(n2) || !isText2(n2));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0;i < nodes.length; i++) {
    const node = nodes[i];
    if (isString$2(node)) {
      push(node);
    } else if (isArray$3(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString$2(node)) {
    context.push(node);
    return;
  }
  if (isSymbol$1(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      genTemplateLiteral(node, context);
      break;
    case 23:
      genIfStatement(node, context);
      break;
    case 24:
      genAssignmentExpression(node, context);
      break;
    case 25:
      genSequenceExpression(node, context);
      break;
    case 26:
      genReturnStatement(node, context);
      break;
    case 10:
      break;
    default: {
      assert(false, `unhandled codegen node type: ${node.type}`);
      const exhaustiveCheck = node;
      return exhaustiveCheck;
    }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0;i < node.children.length; i++) {
    const child = node.children[i];
    if (isString$2(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives: directives2,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  if (directives2) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives2) {
    push(`, `);
    genNode(directives2, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString$2(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0;i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray$3(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray$3(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function genTemplateLiteral(node, context) {
  const { push, indent, deindent } = context;
  push("`");
  const l2 = node.elements.length;
  const multilines = l2 > 3;
  for (let i = 0;i < l2; i++) {
    const e2 = node.elements[i];
    if (isString$2(e2)) {
      push(e2.replace(/(`|\$|\\)/g, "\\$1"));
    } else {
      push("${");
      if (multilines)
        indent();
      genNode(e2, context);
      if (multilines)
        deindent();
      push("}");
    }
  }
  push("`");
}
function genIfStatement(node, context) {
  const { push, indent, deindent } = context;
  const { test, consequent, alternate } = node;
  push(`if (`);
  genNode(test, context);
  push(`) {`);
  indent();
  genNode(consequent, context);
  deindent();
  push(`}`);
  if (alternate) {
    push(` else `);
    if (alternate.type === 23) {
      genIfStatement(alternate, context);
    } else {
      push(`{`);
      indent();
      genNode(alternate, context);
      deindent();
      push(`}`);
    }
  }
}
function genAssignmentExpression(node, context) {
  genNode(node.left, context);
  context.push(` = `);
  genNode(node.right, context);
}
function genSequenceExpression(node, context) {
  context.push(`(`);
  genNodeList(node.expressions, context);
  context.push(`)`);
}
function genReturnStatement({ returns }, context) {
  context.push(`return `);
  if (isArray$3(returns)) {
    genNodeListAsArray(returns, context);
  } else {
    genNode(returns, context);
  }
}

class WalkerBase {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  replace(parent, prop, index, node) {
    if (parent) {
      if (index !== null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  remove(parent, prop, index) {
    if (parent) {
      if (index !== null) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
}

class SyncWalker extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      for (const key in node) {
        const value = node[key];
        if (typeof value !== "object") {
          continue;
        } else if (Array.isArray(value)) {
          for (let i = 0;i < value.length; i += 1) {
            if (value[i] !== null && typeof value[i].type === "string") {
              if (!this.visit(value[i], node, key, i)) {
                i--;
              }
            }
          }
        } else if (value !== null && typeof value.type === "string") {
          this.visit(value, node, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
}
function walk$1(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  const rootExp = root.type === "Program" && root.body[0].type === "ExpressionStatement" && root.body[0].expression;
  walk$1(root, {
    enter(node, parent) {
      parent && parentStack.push(parent);
      if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
        return this.skip();
      }
      if (node.type === "Identifier") {
        const isLocal = !!knownIds[node.name];
        const isRefed = isReferencedIdentifier(node, parent, parentStack);
        if (includeAll || isRefed && !isLocal) {
          onIdentifier(node, parent, parentStack, isRefed, isLocal);
        }
      } else if (node.type === "ObjectProperty" && parent.type === "ObjectPattern") {
        node.inPattern = true;
      } else if (isFunctionType(node)) {
        walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
      } else if (node.type === "BlockStatement") {
        walkBlockDeclarations(node, (id) => markScopeIdentifier(node, id, knownIds));
      }
    },
    leave(node, parent) {
      parent && parentStack.pop();
      if (node !== rootExp && node.scopeIds) {
        for (const id of node.scopeIds) {
          knownIds[id]--;
          if (knownIds[id] === 0) {
            delete knownIds[id];
          }
        }
      }
    }
  });
}
function isReferencedIdentifier(id, parent, parentStack) {
  if (!parent) {
    return true;
  }
  if (id.name === "arguments") {
    return false;
  }
  if (isReferenced(id, parent)) {
    return true;
  }
  switch (parent.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return true;
    case "ObjectPattern":
    case "ArrayPattern":
      return isInDestructureAssignment(parent, parentStack);
  }
  return false;
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p2 = parentStack[i];
      if (p2.type === "AssignmentExpression") {
        return true;
      } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p2 of node.params) {
    for (const id of extractIdentifiers(p2)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function markScopeIdentifier(node, child, knownIds) {
  const { name: name3 } = child;
  if (node.scopeIds && node.scopeIds.has(name3)) {
    return;
  }
  if (name3 in knownIds) {
    knownIds[name3]++;
  } else {
    knownIds[name3] = 1;
  }
  (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set)).add(name3);
}
var isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }
      return parent.object === node;
    case "JSXMemberExpression":
      return parent.object === node;
    case "VariableDeclarator":
      return parent.init === node;
    case "ArrowFunctionExpression":
      return parent.body === node;
    case "PrivateName":
      return false;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return false;
    case "ObjectProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return !grandparent || grandparent.type !== "ObjectPattern";
    case "ClassProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
    case "ClassPrivateProperty":
      return parent.key !== node;
    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;
    case "AssignmentExpression":
      return parent.right === node;
    case "AssignmentPattern":
      return parent.right === node;
    case "LabeledStatement":
      return false;
    case "CatchClause":
      return false;
    case "RestElement":
      return false;
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;
    case "ExportSpecifier":
      if (grandparent == null ? undefined : grandparent.source) {
        return false;
      }
      return parent.local === node;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;
    case "ImportAttribute":
      return false;
    case "JSXAttribute":
      return false;
    case "ObjectPattern":
    case "ArrayPattern":
      return false;
    case "MetaProperty":
      return false;
    case "ObjectTypeProperty":
      return parent.key !== node;
    case "TSEnumMember":
      return parent.id !== node;
    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
  }
  return true;
}
var TS_NODE_TYPES = [
  "TSAsExpression",
  "TSTypeAssertion",
  "TSNonNullExpression",
  "TSInstantiationExpression",
  "TSSatisfiesExpression"
];
var isLiteralWhitelisted = /* @__PURE__ */ makeMap$1("true,false,null,this");
var constantBailRE = /\w\s*\(|\.[^\d]/;
var transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(node.content, context);
  } else if (node.type === 1) {
    for (let i = 0;i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(exp, context, dir.name === "slot");
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  if (!context.prefixIdentifiers || !node.content.trim()) {
    return node;
  }
  const { inline, bindingMetadata } = context;
  const rewriteIdentifier = (raw, parent, id) => {
    const type = hasOwn$1(bindingMetadata, raw) && bindingMetadata[raw];
    if (inline) {
      const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
      const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
      const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
      if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) {
        return raw;
      } else if (type === "setup-ref") {
        return `${raw}.value`;
      } else if (type === "setup-maybe-ref") {
        return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context.helperString(UNREF)}(${raw})`;
      } else if (type === "setup-let") {
        if (isAssignmentLVal) {
          const { right: rVal, operator } = parent;
          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
          const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds));
          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
        } else if (isUpdateArg) {
          id.start = parent.start;
          id.end = parent.end;
          const { prefix: isPrefix, operator } = parent;
          const prefix2 = isPrefix ? operator : ``;
          const postfix2 = isPrefix ? `` : operator;
          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix2}${raw}.value${postfix2} : ${prefix2}${raw}${postfix2}`;
        } else if (isDestructureAssignment) {
          return raw;
        } else {
          return `${context.helperString(UNREF)}(${raw})`;
        }
      } else if (type === "props") {
        return genPropsAccessExp(raw);
      } else if (type === "props-aliased") {
        return genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
      }
    } else {
      if (type && type.startsWith("setup") || type === "literal-const") {
        return `$setup.${raw}`;
      } else if (type === "props-aliased") {
        return `$props['${bindingMetadata.__propsAliases[raw]}']`;
      } else if (type) {
        return `$${type}.${raw}`;
      }
    }
    return `_ctx.${raw}`;
  };
  const rawExp = node.content;
  const bailConstant = constantBailRE.test(rawExp);
  if (isSimpleIdentifier(rawExp)) {
    const isScopeVarReference = context.identifiers[rawExp];
    const isAllowedGlobal = isGloballyAllowed(rawExp);
    const isLiteral = isLiteralWhitelisted(rawExp);
    if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
      if (isConst(bindingMetadata[rawExp])) {
        node.constType = 1;
      }
      node.content = rewriteIdentifier(rawExp);
    } else if (!isScopeVarReference) {
      if (isLiteral) {
        node.constType = 3;
      } else {
        node.constType = 2;
      }
    }
    return node;
  }
  let ast;
  const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
  try {
    ast = parse_1$1(source, {
      plugins: context.expressionPlugins
    }).program;
  } catch (e2) {
    context.onError(createCompilerError(45, node.loc, undefined, e2.message));
    return node;
  }
  const ids = [];
  const parentStack = [];
  const knownIds = Object.create(context.identifiers);
  walkIdentifiers(ast, (node2, parent, _, isReferenced2, isLocal) => {
    if (isStaticPropertyKey(node2, parent)) {
      return;
    }
    const needPrefix = isReferenced2 && canPrefix(node2);
    if (needPrefix && !isLocal) {
      if (isStaticProperty(parent) && parent.shorthand) {
        node2.prefix = `${node2.name}: `;
      }
      node2.name = rewriteIdentifier(node2.name, parent, node2);
      ids.push(node2);
    } else {
      if (!(needPrefix && isLocal) && !bailConstant) {
        node2.isConstant = true;
      }
      ids.push(node2);
    }
  }, true, parentStack, knownIds);
  const children = [];
  ids.sort((a, b) => a.start - b.start);
  ids.forEach((id, i) => {
    const start = id.start - 1;
    const end = id.end - 1;
    const last2 = ids[i - 1];
    const leadingText = rawExp.slice(last2 ? last2.end - 1 : 0, start);
    if (leadingText.length || id.prefix) {
      children.push(leadingText + (id.prefix || ``));
    }
    const source2 = rawExp.slice(start, end);
    children.push(createSimpleExpression(id.name, false, {
      source: source2,
      start: advancePositionWithClone(node.loc.start, source2, start),
      end: advancePositionWithClone(node.loc.start, source2, end)
    }, id.isConstant ? 3 : 0));
    if (i === ids.length - 1 && end < rawExp.length) {
      children.push(rawExp.slice(end));
    }
  });
  let ret;
  if (children.length) {
    ret = createCompoundExpression(children, node.loc);
  } else {
    ret = node;
    ret.constType = bailConstant ? 0 : 3;
  }
  ret.identifiers = Object.keys(knownIds);
  return ret;
}
function canPrefix(id) {
  if (isGloballyAllowed(id.name)) {
    return false;
  }
  if (id.name === "require") {
    return false;
  }
  return true;
}
function stringifyExpression(exp) {
  if (isString$2(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function isConst(type) {
  return type === "setup-const" || type === "literal-const";
}
var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
  return processIf(node, dir, context, (ifNode, branch, isRoot) => {
    const siblings = context.parent.children;
    let i = siblings.indexOf(ifNode);
    let key = 0;
    while (i-- >= 0) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 9) {
        key += sibling.branches.length;
      }
    }
    return () => {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        const parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
});
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (context.prefixIdentifiers && dir.exp) {
    dir.exp = processExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === undefined) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode$1(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? undefined : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
      '"v-if"',
      "true"
    ]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c3) => c3.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ` /* ${patchFlagText} */`, undefined, undefined, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
var transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
  const { helper, removeHelper } = context;
  return processFor(node, dir, context, (forNode) => {
    const renderExp = createCallExpression(helper(RENDER_LIST), [
      forNode.source
    ]);
    const isTemplate = isTemplateNode(node);
    const memo = findDir(node, "memo");
    const keyProp = findProp(node, `key`);
    const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
    if (isTemplate) {
      if (memo) {
        memo.exp = processExpression(memo.exp, context);
      }
      if (keyProperty && keyProp.type !== 6) {
        keyProperty.value = processExpression(keyProperty.value, context);
      }
    }
    const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
    const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag + ` /* ${PatchFlagNames[fragmentFlag]} */`, undefined, undefined, true, !isStableFragment, false, node.loc);
    return () => {
      let childBlock;
      const { children } = forNode;
      if (isTemplate) {
        node.children.some((c3) => {
          if (c3.type === 1) {
            const key = findProp(c3, "key");
            if (key) {
              context.onError(createCompilerError(33, key.loc));
              return true;
            }
          }
        });
      }
      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
      if (slotOutlet) {
        childBlock = slotOutlet.codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 + ` /* ${PatchFlagNames[64]} */`, undefined, undefined, true, undefined, false);
      } else {
        childBlock = children[0].codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        childBlock.isBlock = !isStableFragment;
        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
        }
      }
      if (memo) {
        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
          createSimpleExpression(`_cached`)
        ]));
        loop.body = createBlockStatement([
          createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
          createCompoundExpression([
            `if (_cached`,
            ...keyExp ? [` && _cached.key === `, keyExp] : [],
            ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
          ]),
          createCompoundExpression([`const _item = `, childBlock]),
          createSimpleExpression(`_item.memo = _memo`),
          createSimpleExpression(`return _item`)
        ]);
        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
      }
    };
  });
});
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  if (context.prefixIdentifiers) {
    value && addIdentifiers(value);
    key && addIdentifiers(key);
    index && addIdentifiers(index);
  }
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (context.prefixIdentifiers) {
      value && removeIdentifiers(value);
      key && removeIdentifiers(key);
      index && removeIdentifiers(index);
    }
    if (onExit)
      onExit();
  };
}
var forAliasRE$1 = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE$1);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: undefined,
    key: undefined,
    index: undefined
  };
  if (context.prefixIdentifiers) {
    result.source = processExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (context.prefixIdentifiers) {
        result.key = processExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (context.prefixIdentifiers) {
          result.index = processExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (context.prefixIdentifiers) {
      result.value = processExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range2, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range2, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
var defaultFallback = createSimpleExpression(`undefined`, false);
var trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      const slotProps = vSlot.exp;
      if (context.prefixIdentifiers) {
        slotProps && context.addIdentifiers(slotProps);
      }
      context.scopes.vSlot++;
      return () => {
        if (context.prefixIdentifiers) {
          slotProps && context.removeIdentifiers(slotProps);
        }
        context.scopes.vSlot--;
      };
    }
  }
};
var trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.parseResult = parseForExpression(vFor.exp, context);
    if (result) {
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
var buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  if (!context.ssr && context.prefixIdentifiers) {
    hasDynamicSlots = hasScopeRef(node, context.identifiers);
  }
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, undefined, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set;
  let conditionalBranchIndex = 0;
  for (let i = 0;i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor == null ? undefined : vFor.exp, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn2 = buildSlotFn(props, undefined, children2, loc);
      return createObjectProperty(`default`, fn2);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(undefined, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ` /* ${slotFlagsText[slotFlag]} */`, false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name3, fn2, index) {
  const props = [
    createObjectProperty(`name`, name3),
    createObjectProperty(`fn`, fn2)
  ];
  if (index != null) {
    props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0;i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
var directiveImportMap = /* @__PURE__ */ new WeakMap;
var transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject$2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
    if (props.length > 0) {
      const propsBuildResult = buildProps(node, context, undefined, isComponent2, isDynamicComponent);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives2 = propsBuildResult.directives;
      vnodeDirectives = directives2 && directives2.length ? createArrayExpression(directives2.map((dir) => buildDirectiveArgs(dir, context))) : undefined;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (node.children.length > 1) {
          context.onError(createCompilerError(46, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
      }
      const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      {
        if (patchFlag < 0) {
          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
        } else {
          const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n2) => n2 > 0 && patchFlag & n2).map((n2) => PatchFlagNames[n2]).join(`, `);
          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
        }
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || false) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    {
      context.onWarn(createCompilerError(52, isDir.loc));
    }
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  {
    const fromSetup = resolveSetupReference(tag, context);
    if (fromSetup) {
      return fromSetup;
    }
    const dotIndex = tag.indexOf(".");
    if (dotIndex > 0) {
      const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
      if (ns) {
        return ns + tag.slice(dotIndex);
      }
    }
  }
  if (context.selfName && capitalize$1(camelize(tag)) === context.selfName) {
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag + `__self`);
    return toValidAssetId(tag, `component`);
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function resolveSetupReference(name3, context) {
  const bindings = context.bindingMetadata;
  if (!bindings || bindings.__isScriptSetup === false) {
    return;
  }
  const camelName = camelize(name3);
  const PascalName = capitalize$1(camelName);
  const checkType = (type) => {
    if (bindings[name3] === type) {
      return name3;
    }
    if (bindings[camelName] === type) {
      return camelName;
    }
    if (bindings[PascalName] === type) {
      return PascalName;
    }
  };
  const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
  if (fromConst) {
    return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
  }
  const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
  if (fromMaybeRef) {
    return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
  }
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name3 = key.content;
      const isEventHandler = isOn$1(name3);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && name3.toLowerCase() !== "onclick" && name3 !== "onUpdate:modelValue" && !isReservedProp(name3)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name3)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name3 === "ref") {
        hasRef = true;
      } else if (name3 === "class") {
        hasClassBinding = true;
      } else if (name3 === "style") {
        hasStyleBinding = true;
      } else if (name3 !== "key" && !dynamicPropNames.includes(name3)) {
        dynamicPropNames.push(name3);
      }
      if (isComponent2 && (name3 === "class" || name3 === "style") && !dynamicPropNames.includes(name3)) {
        dynamicPropNames.push(name3);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0;i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name: name3, value } = prop;
      let isStatic = true;
      if (name3 === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
        if (value && context.inline) {
          const binding = context.bindingMetadata[value.content];
          if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
            isStatic = false;
            properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
          }
        }
      }
      if (name3 === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || false)) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name3, true, getInnerRange(loc, 0, name3.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name: name3, arg, exp, loc } = prop;
      const isVBind = name3 === "bind";
      const isVOn = name3 === "on";
      if (name3 === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name3 === "once" || name3 === "memo") {
        continue;
      }
      if (name3 === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || false)) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name3];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol$1(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name3)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = undefined;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0;i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map;
  const deduped = [];
  for (let i = 0;i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name3 = prop.key.content;
    const existing = knownProps.get(name3);
    if (existing) {
      if (name3 === "style" || name3 === "class" || isOn$1(name3)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name3, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    const fromSetup = resolveSetupReference("v-" + dir.name, context);
    if (fromSetup) {
      dirArgs.push(fromSetup);
    } else {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l2 = props.length;i < l2; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l2 - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
var transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = undefined;
  const nonNameProps = [];
  for (let i = 0;i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp)
          slotName = p2.exp;
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives: directives2 } = buildProps(node, context, nonNameProps, false, false);
    slotProps = props;
    if (directives2.length) {
      context.onError(createCompilerError(36, directives2[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
var transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vnode")) {
        context.onWarn(createCompilerError(51, arg.loc));
      }
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? toHandlerKey(camelize(rawName)) : `on:${rawName}`;
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = undefined;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content, context);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (context.prefixIdentifiers) {
      isInlineStatement && context.addIdentifiers(`$event`);
      exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
      isInlineStatement && context.removeIdentifiers(`$event`);
      shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
      if (shouldCache && isMemberExp) {
        if (exp.type === 4) {
          exp.content = `${exp.content} && ${exp.content}(...args)`;
        } else {
          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
        }
      }
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p2) => p2.key.isHandlerKey = true);
  return ret;
};
var transformBind = (dir, _node, context) => {
  const { exp, modifiers, loc } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
var injectPrefix = (arg, prefix2) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix2 + arg.content;
    } else {
      arg.content = `\`${prefix2}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix2}' + (`);
    arg.children.push(`)`);
  }
};
var transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = undefined;
      let hasText = false;
      for (let i = 0;i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1;j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression([child], child.loc);
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = undefined;
              break;
            }
          }
        }
      }
      if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p2) => p2.type === 7 && !context.directiveTransforms[p2.name]) && true)) {
        return;
      }
      for (let i = 0;i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(1 + ` /* ${PatchFlagNames[1]} */`);
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};
var seen$1 = /* @__PURE__ */ new WeakSet;
var transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true);
      }
    };
  }
};
var transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(createCompilerError(41, dir.loc));
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
  if (!expString.trim() || !isMemberExpression(expString, context) && !maybeRef) {
    context.onError(createCompilerError(42, exp.loc));
    return createTransformProps();
  }
  if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
    context.onError(createCompilerError(43, exp.loc));
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  if (maybeRef) {
    if (bindingType === "setup-ref") {
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event)`
      ]);
    } else {
      const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
      assignmentExp = createCompoundExpression([
        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event : ${altAssignment})`
      ]);
    }
  } else {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    createObjectProperty(propName, dir.exp),
    createObjectProperty(eventName, assignmentExp)
  ];
  if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
    props[1].value = context.cache(props[1].value);
  }
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m2) => (isSimpleIdentifier(m2) ? m2 : JSON.stringify(m2)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}
var seen = /* @__PURE__ */ new WeakSet;
var transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(undefined, codegenNode),
          `_cache`,
          String(context.cached++)
        ]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[],
      ...prefixIdentifiers ? [
        trackVForSlotScopes,
        transformExpression
      ] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile$2(template, options3 = {}) {
  const onError = options3.onError || defaultOnError$1;
  const isModuleMode = options3.mode === "module";
  const prefixIdentifiers = options3.prefixIdentifiers === true || isModuleMode;
  if (!prefixIdentifiers && options3.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options3.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const ast = isString$2(template) ? baseParse(template, options3) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
  if (options3.isTS) {
    const { expressionPlugins } = options3;
    if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
      options3.expressionPlugins = [...expressionPlugins || [], "typescript"];
    }
  }
  transform$1(ast, extend({}, options3, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options3.nodeTransforms || []
    ],
    directiveTransforms: extend({}, directiveTransforms, options3.directiveTransforms || {})
  }));
  return generate$1(ast, extend({}, options3, {
    prefixIdentifiers
  }));
}
var noopDirectiveTransform = () => ({ props: [] });
var V_MODEL_RADIO = Symbol(`vModelRadio`);
var V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
var V_MODEL_TEXT = Symbol(`vModelText`);
var V_MODEL_SELECT = Symbol(`vModelSelect`);
var V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
var V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
var V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
var V_SHOW = Symbol(`vShow`);
var TRANSITION = Symbol(`Transition`);
var TRANSITION_GROUP = Symbol(`TransitionGroup`);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
var namedCharacterReferences = {
  GT: ">",
  gt: ">",
  LT: "<",
  lt: "<",
  "ac;": "\u223E",
  "af;": "\u2061",
  AMP: "&",
  amp: "&",
  "ap;": "\u2248",
  "DD;": "\u2145",
  "dd;": "\u2146",
  deg: "\xB0",
  "ee;": "\u2147",
  "eg;": "\u2A9A",
  "el;": "\u2A99",
  ETH: "\xD0",
  eth: "\xF0",
  "gE;": "\u2267",
  "ge;": "\u2265",
  "Gg;": "\u22D9",
  "gg;": "\u226B",
  "gl;": "\u2277",
  "GT;": ">",
  "Gt;": "\u226B",
  "gt;": ">",
  "ic;": "\u2063",
  "ii;": "\u2148",
  "Im;": "\u2111",
  "in;": "\u2208",
  "it;": "\u2062",
  "lE;": "\u2266",
  "le;": "\u2264",
  "lg;": "\u2276",
  "Ll;": "\u22D8",
  "ll;": "\u226A",
  "LT;": "<",
  "Lt;": "\u226A",
  "lt;": "<",
  "mp;": "\u2213",
  "Mu;": "\u039C",
  "mu;": "\u03BC",
  "ne;": "\u2260",
  "ni;": "\u220B",
  not: "\xAC",
  "Nu;": "\u039D",
  "nu;": "\u03BD",
  "Or;": "\u2A54",
  "or;": "\u2228",
  "oS;": "\u24C8",
  "Pi;": "\u03A0",
  "pi;": "\u03C0",
  "pm;": "\xB1",
  "Pr;": "\u2ABB",
  "pr;": "\u227A",
  "Re;": "\u211C",
  REG: "\xAE",
  reg: "\xAE",
  "rx;": "\u211E",
  "Sc;": "\u2ABC",
  "sc;": "\u227B",
  shy: "\xAD",
  uml: "\xA8",
  "wp;": "\u2118",
  "wr;": "\u2240",
  "Xi;": "\u039E",
  "xi;": "\u03BE",
  yen: "\xA5",
  "acd;": "\u223F",
  "acE;": "\u223E\u0333",
  "Acy;": "\u0410",
  "acy;": "\u0430",
  "Afr;": "\uD835\uDD04",
  "afr;": "\uD835\uDD1E",
  "AMP;": "&",
  "amp;": "&",
  "And;": "\u2A53",
  "and;": "\u2227",
  "ang;": "\u2220",
  "apE;": "\u2A70",
  "ape;": "\u224A",
  "ast;": "*",
  Auml: "\xC4",
  auml: "\xE4",
  "Bcy;": "\u0411",
  "bcy;": "\u0431",
  "Bfr;": "\uD835\uDD05",
  "bfr;": "\uD835\uDD1F",
  "bne;": "=\u20E5",
  "bot;": "\u22A5",
  "Cap;": "\u22D2",
  "cap;": "\u2229",
  cent: "\xA2",
  "Cfr;": "\u212D",
  "cfr;": "\uD835\uDD20",
  "Chi;": "\u03A7",
  "chi;": "\u03C7",
  "cir;": "\u25CB",
  COPY: "\xA9",
  copy: "\xA9",
  "Cup;": "\u22D3",
  "cup;": "\u222A",
  "Dcy;": "\u0414",
  "dcy;": "\u0434",
  "deg;": "\xB0",
  "Del;": "\u2207",
  "Dfr;": "\uD835\uDD07",
  "dfr;": "\uD835\uDD21",
  "die;": "\xA8",
  "div;": "\xF7",
  "Dot;": "\xA8",
  "dot;": "\u02D9",
  "Ecy;": "\u042D",
  "ecy;": "\u044D",
  "Efr;": "\uD835\uDD08",
  "efr;": "\uD835\uDD22",
  "egs;": "\u2A96",
  "ell;": "\u2113",
  "els;": "\u2A95",
  "ENG;": "\u014A",
  "eng;": "\u014B",
  "Eta;": "\u0397",
  "eta;": "\u03B7",
  "ETH;": "\xD0",
  "eth;": "\xF0",
  Euml: "\xCB",
  euml: "\xEB",
  "Fcy;": "\u0424",
  "fcy;": "\u0444",
  "Ffr;": "\uD835\uDD09",
  "ffr;": "\uD835\uDD23",
  "gap;": "\u2A86",
  "Gcy;": "\u0413",
  "gcy;": "\u0433",
  "gEl;": "\u2A8C",
  "gel;": "\u22DB",
  "geq;": "\u2265",
  "ges;": "\u2A7E",
  "Gfr;": "\uD835\uDD0A",
  "gfr;": "\uD835\uDD24",
  "ggg;": "\u22D9",
  "gla;": "\u2AA5",
  "glE;": "\u2A92",
  "glj;": "\u2AA4",
  "gnE;": "\u2269",
  "gne;": "\u2A88",
  "Hat;": "^",
  "Hfr;": "\u210C",
  "hfr;": "\uD835\uDD25",
  "Icy;": "\u0418",
  "icy;": "\u0438",
  "iff;": "\u21D4",
  "Ifr;": "\u2111",
  "ifr;": "\uD835\uDD26",
  "Int;": "\u222C",
  "int;": "\u222B",
  Iuml: "\xCF",
  iuml: "\xEF",
  "Jcy;": "\u0419",
  "jcy;": "\u0439",
  "Jfr;": "\uD835\uDD0D",
  "jfr;": "\uD835\uDD27",
  "Kcy;": "\u041A",
  "kcy;": "\u043A",
  "Kfr;": "\uD835\uDD0E",
  "kfr;": "\uD835\uDD28",
  "lap;": "\u2A85",
  "lat;": "\u2AAB",
  "Lcy;": "\u041B",
  "lcy;": "\u043B",
  "lEg;": "\u2A8B",
  "leg;": "\u22DA",
  "leq;": "\u2264",
  "les;": "\u2A7D",
  "Lfr;": "\uD835\uDD0F",
  "lfr;": "\uD835\uDD29",
  "lgE;": "\u2A91",
  "lnE;": "\u2268",
  "lne;": "\u2A87",
  "loz;": "\u25CA",
  "lrm;": "\u200E",
  "Lsh;": "\u21B0",
  "lsh;": "\u21B0",
  macr: "\xAF",
  "Map;": "\u2905",
  "map;": "\u21A6",
  "Mcy;": "\u041C",
  "mcy;": "\u043C",
  "Mfr;": "\uD835\uDD10",
  "mfr;": "\uD835\uDD2A",
  "mho;": "\u2127",
  "mid;": "\u2223",
  "nap;": "\u2249",
  nbsp: "\xA0",
  "Ncy;": "\u041D",
  "ncy;": "\u043D",
  "Nfr;": "\uD835\uDD11",
  "nfr;": "\uD835\uDD2B",
  "ngE;": "\u2267\u0338",
  "nge;": "\u2271",
  "nGg;": "\u22D9\u0338",
  "nGt;": "\u226B\u20D2",
  "ngt;": "\u226F",
  "nis;": "\u22FC",
  "niv;": "\u220B",
  "nlE;": "\u2266\u0338",
  "nle;": "\u2270",
  "nLl;": "\u22D8\u0338",
  "nLt;": "\u226A\u20D2",
  "nlt;": "\u226E",
  "Not;": "\u2AEC",
  "not;": "\xAC",
  "npr;": "\u2280",
  "nsc;": "\u2281",
  "num;": "#",
  "Ocy;": "\u041E",
  "ocy;": "\u043E",
  "Ofr;": "\uD835\uDD12",
  "ofr;": "\uD835\uDD2C",
  "ogt;": "\u29C1",
  "ohm;": "\u03A9",
  "olt;": "\u29C0",
  "ord;": "\u2A5D",
  ordf: "\xAA",
  ordm: "\xBA",
  "orv;": "\u2A5B",
  Ouml: "\xD6",
  ouml: "\xF6",
  "par;": "\u2225",
  para: "\xB6",
  "Pcy;": "\u041F",
  "pcy;": "\u043F",
  "Pfr;": "\uD835\uDD13",
  "pfr;": "\uD835\uDD2D",
  "Phi;": "\u03A6",
  "phi;": "\u03C6",
  "piv;": "\u03D6",
  "prE;": "\u2AB3",
  "pre;": "\u2AAF",
  "Psi;": "\u03A8",
  "psi;": "\u03C8",
  "Qfr;": "\uD835\uDD14",
  "qfr;": "\uD835\uDD2E",
  QUOT: '"',
  quot: '"',
  "Rcy;": "\u0420",
  "rcy;": "\u0440",
  "REG;": "\xAE",
  "reg;": "\xAE",
  "Rfr;": "\u211C",
  "rfr;": "\uD835\uDD2F",
  "Rho;": "\u03A1",
  "rho;": "\u03C1",
  "rlm;": "\u200F",
  "Rsh;": "\u21B1",
  "rsh;": "\u21B1",
  "scE;": "\u2AB4",
  "sce;": "\u2AB0",
  "Scy;": "\u0421",
  "scy;": "\u0441",
  sect: "\xA7",
  "Sfr;": "\uD835\uDD16",
  "sfr;": "\uD835\uDD30",
  "shy;": "\xAD",
  "sim;": "\u223C",
  "smt;": "\u2AAA",
  "sol;": "/",
  "squ;": "\u25A1",
  "Sub;": "\u22D0",
  "sub;": "\u2282",
  "Sum;": "\u2211",
  "sum;": "\u2211",
  "Sup;": "\u22D1",
  "sup;": "\u2283",
  sup1: "\xB9",
  sup2: "\xB2",
  sup3: "\xB3",
  "Tab;": "\t",
  "Tau;": "\u03A4",
  "tau;": "\u03C4",
  "Tcy;": "\u0422",
  "tcy;": "\u0442",
  "Tfr;": "\uD835\uDD17",
  "tfr;": "\uD835\uDD31",
  "top;": "\u22A4",
  "Ucy;": "\u0423",
  "ucy;": "\u0443",
  "Ufr;": "\uD835\uDD18",
  "ufr;": "\uD835\uDD32",
  "uml;": "\xA8",
  Uuml: "\xDC",
  uuml: "\xFC",
  "Vcy;": "\u0412",
  "vcy;": "\u0432",
  "Vee;": "\u22C1",
  "vee;": "\u2228",
  "Vfr;": "\uD835\uDD19",
  "vfr;": "\uD835\uDD33",
  "Wfr;": "\uD835\uDD1A",
  "wfr;": "\uD835\uDD34",
  "Xfr;": "\uD835\uDD1B",
  "xfr;": "\uD835\uDD35",
  "Ycy;": "\u042B",
  "ycy;": "\u044B",
  "yen;": "\xA5",
  "Yfr;": "\uD835\uDD1C",
  "yfr;": "\uD835\uDD36",
  yuml: "\xFF",
  "Zcy;": "\u0417",
  "zcy;": "\u0437",
  "Zfr;": "\u2128",
  "zfr;": "\uD835\uDD37",
  "zwj;": "\u200D",
  Acirc: "\xC2",
  acirc: "\xE2",
  acute: "\xB4",
  AElig: "\xC6",
  aelig: "\xE6",
  "andd;": "\u2A5C",
  "andv;": "\u2A5A",
  "ange;": "\u29A4",
  "Aopf;": "\uD835\uDD38",
  "aopf;": "\uD835\uDD52",
  "apid;": "\u224B",
  "apos;": "'",
  Aring: "\xC5",
  aring: "\xE5",
  "Ascr;": "\uD835\uDC9C",
  "ascr;": "\uD835\uDCB6",
  "Auml;": "\xC4",
  "auml;": "\xE4",
  "Barv;": "\u2AE7",
  "bbrk;": "\u23B5",
  "Beta;": "\u0392",
  "beta;": "\u03B2",
  "beth;": "\u2136",
  "bNot;": "\u2AED",
  "bnot;": "\u2310",
  "Bopf;": "\uD835\uDD39",
  "bopf;": "\uD835\uDD53",
  "boxH;": "\u2550",
  "boxh;": "\u2500",
  "boxV;": "\u2551",
  "boxv;": "\u2502",
  "Bscr;": "\u212C",
  "bscr;": "\uD835\uDCB7",
  "bsim;": "\u223D",
  "bsol;": "\\",
  "bull;": "\u2022",
  "bump;": "\u224E",
  "caps;": "\u2229\uFE00",
  "Cdot;": "\u010A",
  "cdot;": "\u010B",
  cedil: "\xB8",
  "cent;": "\xA2",
  "CHcy;": "\u0427",
  "chcy;": "\u0447",
  "circ;": "\u02C6",
  "cirE;": "\u29C3",
  "cire;": "\u2257",
  "comp;": "\u2201",
  "cong;": "\u2245",
  "Copf;": "\u2102",
  "copf;": "\uD835\uDD54",
  "COPY;": "\xA9",
  "copy;": "\xA9",
  "Cscr;": "\uD835\uDC9E",
  "cscr;": "\uD835\uDCB8",
  "csub;": "\u2ACF",
  "csup;": "\u2AD0",
  "cups;": "\u222A\uFE00",
  "Darr;": "\u21A1",
  "dArr;": "\u21D3",
  "darr;": "\u2193",
  "dash;": "\u2010",
  "dHar;": "\u2965",
  "diam;": "\u22C4",
  "DJcy;": "\u0402",
  "djcy;": "\u0452",
  "Dopf;": "\uD835\uDD3B",
  "dopf;": "\uD835\uDD55",
  "Dscr;": "\uD835\uDC9F",
  "dscr;": "\uD835\uDCB9",
  "DScy;": "\u0405",
  "dscy;": "\u0455",
  "dsol;": "\u29F6",
  "dtri;": "\u25BF",
  "DZcy;": "\u040F",
  "dzcy;": "\u045F",
  "ecir;": "\u2256",
  Ecirc: "\xCA",
  ecirc: "\xEA",
  "Edot;": "\u0116",
  "eDot;": "\u2251",
  "edot;": "\u0117",
  "emsp;": "\u2003",
  "ensp;": "\u2002",
  "Eopf;": "\uD835\uDD3C",
  "eopf;": "\uD835\uDD56",
  "epar;": "\u22D5",
  "epsi;": "\u03B5",
  "Escr;": "\u2130",
  "escr;": "\u212F",
  "Esim;": "\u2A73",
  "esim;": "\u2242",
  "Euml;": "\xCB",
  "euml;": "\xEB",
  "euro;": "\u20AC",
  "excl;": "!",
  "flat;": "\u266D",
  "fnof;": "\u0192",
  "Fopf;": "\uD835\uDD3D",
  "fopf;": "\uD835\uDD57",
  "fork;": "\u22D4",
  "Fscr;": "\u2131",
  "fscr;": "\uD835\uDCBB",
  "Gdot;": "\u0120",
  "gdot;": "\u0121",
  "geqq;": "\u2267",
  "gesl;": "\u22DB\uFE00",
  "GJcy;": "\u0403",
  "gjcy;": "\u0453",
  "gnap;": "\u2A8A",
  "gneq;": "\u2A88",
  "Gopf;": "\uD835\uDD3E",
  "gopf;": "\uD835\uDD58",
  "Gscr;": "\uD835\uDCA2",
  "gscr;": "\u210A",
  "gsim;": "\u2273",
  "gtcc;": "\u2AA7",
  "gvnE;": "\u2269\uFE00",
  "half;": "\xBD",
  "hArr;": "\u21D4",
  "harr;": "\u2194",
  "hbar;": "\u210F",
  "Hopf;": "\u210D",
  "hopf;": "\uD835\uDD59",
  "Hscr;": "\u210B",
  "hscr;": "\uD835\uDCBD",
  Icirc: "\xCE",
  icirc: "\xEE",
  "Idot;": "\u0130",
  "IEcy;": "\u0415",
  "iecy;": "\u0435",
  iexcl: "\xA1",
  "imof;": "\u22B7",
  "IOcy;": "\u0401",
  "iocy;": "\u0451",
  "Iopf;": "\uD835\uDD40",
  "iopf;": "\uD835\uDD5A",
  "Iota;": "\u0399",
  "iota;": "\u03B9",
  "Iscr;": "\u2110",
  "iscr;": "\uD835\uDCBE",
  "isin;": "\u2208",
  "Iuml;": "\xCF",
  "iuml;": "\xEF",
  "Jopf;": "\uD835\uDD41",
  "jopf;": "\uD835\uDD5B",
  "Jscr;": "\uD835\uDCA5",
  "jscr;": "\uD835\uDCBF",
  "KHcy;": "\u0425",
  "khcy;": "\u0445",
  "KJcy;": "\u040C",
  "kjcy;": "\u045C",
  "Kopf;": "\uD835\uDD42",
  "kopf;": "\uD835\uDD5C",
  "Kscr;": "\uD835\uDCA6",
  "kscr;": "\uD835\uDCC0",
  "Lang;": "\u27EA",
  "lang;": "\u27E8",
  laquo: "\xAB",
  "Larr;": "\u219E",
  "lArr;": "\u21D0",
  "larr;": "\u2190",
  "late;": "\u2AAD",
  "lcub;": "{",
  "ldca;": "\u2936",
  "ldsh;": "\u21B2",
  "leqq;": "\u2266",
  "lesg;": "\u22DA\uFE00",
  "lHar;": "\u2962",
  "LJcy;": "\u0409",
  "ljcy;": "\u0459",
  "lnap;": "\u2A89",
  "lneq;": "\u2A87",
  "Lopf;": "\uD835\uDD43",
  "lopf;": "\uD835\uDD5D",
  "lozf;": "\u29EB",
  "lpar;": "(",
  "Lscr;": "\u2112",
  "lscr;": "\uD835\uDCC1",
  "lsim;": "\u2272",
  "lsqb;": "[",
  "ltcc;": "\u2AA6",
  "ltri;": "\u25C3",
  "lvnE;": "\u2268\uFE00",
  "macr;": "\xAF",
  "male;": "\u2642",
  "malt;": "\u2720",
  micro: "\xB5",
  "mlcp;": "\u2ADB",
  "mldr;": "\u2026",
  "Mopf;": "\uD835\uDD44",
  "mopf;": "\uD835\uDD5E",
  "Mscr;": "\u2133",
  "mscr;": "\uD835\uDCC2",
  "nang;": "\u2220\u20D2",
  "napE;": "\u2A70\u0338",
  "nbsp;": "\xA0",
  "ncap;": "\u2A43",
  "ncup;": "\u2A42",
  "ngeq;": "\u2271",
  "nges;": "\u2A7E\u0338",
  "ngtr;": "\u226F",
  "nGtv;": "\u226B\u0338",
  "nisd;": "\u22FA",
  "NJcy;": "\u040A",
  "njcy;": "\u045A",
  "nldr;": "\u2025",
  "nleq;": "\u2270",
  "nles;": "\u2A7D\u0338",
  "nLtv;": "\u226A\u0338",
  "nmid;": "\u2224",
  "Nopf;": "\u2115",
  "nopf;": "\uD835\uDD5F",
  "npar;": "\u2226",
  "npre;": "\u2AAF\u0338",
  "nsce;": "\u2AB0\u0338",
  "Nscr;": "\uD835\uDCA9",
  "nscr;": "\uD835\uDCC3",
  "nsim;": "\u2241",
  "nsub;": "\u2284",
  "nsup;": "\u2285",
  "ntgl;": "\u2279",
  "ntlg;": "\u2278",
  "nvap;": "\u224D\u20D2",
  "nvge;": "\u2265\u20D2",
  "nvgt;": ">\u20D2",
  "nvle;": "\u2264\u20D2",
  "nvlt;": "<\u20D2",
  "oast;": "\u229B",
  "ocir;": "\u229A",
  Ocirc: "\xD4",
  ocirc: "\xF4",
  "odiv;": "\u2A38",
  "odot;": "\u2299",
  "ogon;": "\u02DB",
  "oint;": "\u222E",
  "omid;": "\u29B6",
  "Oopf;": "\uD835\uDD46",
  "oopf;": "\uD835\uDD60",
  "opar;": "\u29B7",
  "ordf;": "\xAA",
  "ordm;": "\xBA",
  "oror;": "\u2A56",
  "Oscr;": "\uD835\uDCAA",
  "oscr;": "\u2134",
  "osol;": "\u2298",
  "Ouml;": "\xD6",
  "ouml;": "\xF6",
  "para;": "\xB6",
  "part;": "\u2202",
  "perp;": "\u22A5",
  "phiv;": "\u03D5",
  "plus;": "+",
  "Popf;": "\u2119",
  "popf;": "\uD835\uDD61",
  pound: "\xA3",
  "prap;": "\u2AB7",
  "prec;": "\u227A",
  "prnE;": "\u2AB5",
  "prod;": "\u220F",
  "prop;": "\u221D",
  "Pscr;": "\uD835\uDCAB",
  "pscr;": "\uD835\uDCC5",
  "qint;": "\u2A0C",
  "Qopf;": "\u211A",
  "qopf;": "\uD835\uDD62",
  "Qscr;": "\uD835\uDCAC",
  "qscr;": "\uD835\uDCC6",
  "QUOT;": '"',
  "quot;": '"',
  "race;": "\u223D\u0331",
  "Rang;": "\u27EB",
  "rang;": "\u27E9",
  raquo: "\xBB",
  "Rarr;": "\u21A0",
  "rArr;": "\u21D2",
  "rarr;": "\u2192",
  "rcub;": "}",
  "rdca;": "\u2937",
  "rdsh;": "\u21B3",
  "real;": "\u211C",
  "rect;": "\u25AD",
  "rHar;": "\u2964",
  "rhov;": "\u03F1",
  "ring;": "\u02DA",
  "Ropf;": "\u211D",
  "ropf;": "\uD835\uDD63",
  "rpar;": ")",
  "Rscr;": "\u211B",
  "rscr;": "\uD835\uDCC7",
  "rsqb;": "]",
  "rtri;": "\u25B9",
  "scap;": "\u2AB8",
  "scnE;": "\u2AB6",
  "sdot;": "\u22C5",
  "sect;": "\xA7",
  "semi;": ";",
  "sext;": "\u2736",
  "SHcy;": "\u0428",
  "shcy;": "\u0448",
  "sime;": "\u2243",
  "simg;": "\u2A9E",
  "siml;": "\u2A9D",
  "smid;": "\u2223",
  "smte;": "\u2AAC",
  "solb;": "\u29C4",
  "Sopf;": "\uD835\uDD4A",
  "sopf;": "\uD835\uDD64",
  "spar;": "\u2225",
  "Sqrt;": "\u221A",
  "squf;": "\u25AA",
  "Sscr;": "\uD835\uDCAE",
  "sscr;": "\uD835\uDCC8",
  "Star;": "\u22C6",
  "star;": "\u2606",
  "subE;": "\u2AC5",
  "sube;": "\u2286",
  "succ;": "\u227B",
  "sung;": "\u266A",
  "sup1;": "\xB9",
  "sup2;": "\xB2",
  "sup3;": "\xB3",
  "supE;": "\u2AC6",
  "supe;": "\u2287",
  szlig: "\xDF",
  "tbrk;": "\u23B4",
  "tdot;": "\u20DB",
  THORN: "\xDE",
  thorn: "\xFE",
  times: "\xD7",
  "tint;": "\u222D",
  "toea;": "\u2928",
  "Topf;": "\uD835\uDD4B",
  "topf;": "\uD835\uDD65",
  "tosa;": "\u2929",
  "trie;": "\u225C",
  "Tscr;": "\uD835\uDCAF",
  "tscr;": "\uD835\uDCC9",
  "TScy;": "\u0426",
  "tscy;": "\u0446",
  "Uarr;": "\u219F",
  "uArr;": "\u21D1",
  "uarr;": "\u2191",
  Ucirc: "\xDB",
  ucirc: "\xFB",
  "uHar;": "\u2963",
  "Uopf;": "\uD835\uDD4C",
  "uopf;": "\uD835\uDD66",
  "Upsi;": "\u03D2",
  "upsi;": "\u03C5",
  "Uscr;": "\uD835\uDCB0",
  "uscr;": "\uD835\uDCCA",
  "utri;": "\u25B5",
  "Uuml;": "\xDC",
  "uuml;": "\xFC",
  "vArr;": "\u21D5",
  "varr;": "\u2195",
  "Vbar;": "\u2AEB",
  "vBar;": "\u2AE8",
  "Vert;": "\u2016",
  "vert;": "|",
  "Vopf;": "\uD835\uDD4D",
  "vopf;": "\uD835\uDD67",
  "Vscr;": "\uD835\uDCB1",
  "vscr;": "\uD835\uDCCB",
  "Wopf;": "\uD835\uDD4E",
  "wopf;": "\uD835\uDD68",
  "Wscr;": "\uD835\uDCB2",
  "wscr;": "\uD835\uDCCC",
  "xcap;": "\u22C2",
  "xcup;": "\u22C3",
  "xmap;": "\u27FC",
  "xnis;": "\u22FB",
  "Xopf;": "\uD835\uDD4F",
  "xopf;": "\uD835\uDD69",
  "Xscr;": "\uD835\uDCB3",
  "xscr;": "\uD835\uDCCD",
  "xvee;": "\u22C1",
  "YAcy;": "\u042F",
  "yacy;": "\u044F",
  "YIcy;": "\u0407",
  "yicy;": "\u0457",
  "Yopf;": "\uD835\uDD50",
  "yopf;": "\uD835\uDD6A",
  "Yscr;": "\uD835\uDCB4",
  "yscr;": "\uD835\uDCCE",
  "YUcy;": "\u042E",
  "yucy;": "\u044E",
  "Yuml;": "\u0178",
  "yuml;": "\xFF",
  "Zdot;": "\u017B",
  "zdot;": "\u017C",
  "Zeta;": "\u0396",
  "zeta;": "\u03B6",
  "ZHcy;": "\u0416",
  "zhcy;": "\u0436",
  "Zopf;": "\u2124",
  "zopf;": "\uD835\uDD6B",
  "Zscr;": "\uD835\uDCB5",
  "zscr;": "\uD835\uDCCF",
  "zwnj;": "\u200C",
  Aacute: "\xC1",
  aacute: "\xE1",
  "Acirc;": "\xC2",
  "acirc;": "\xE2",
  "acute;": "\xB4",
  "AElig;": "\xC6",
  "aelig;": "\xE6",
  Agrave: "\xC0",
  agrave: "\xE0",
  "aleph;": "\u2135",
  "Alpha;": "\u0391",
  "alpha;": "\u03B1",
  "Amacr;": "\u0100",
  "amacr;": "\u0101",
  "amalg;": "\u2A3F",
  "angle;": "\u2220",
  "angrt;": "\u221F",
  "angst;": "\xC5",
  "Aogon;": "\u0104",
  "aogon;": "\u0105",
  "Aring;": "\xC5",
  "aring;": "\xE5",
  "asymp;": "\u2248",
  Atilde: "\xC3",
  atilde: "\xE3",
  "awint;": "\u2A11",
  "bcong;": "\u224C",
  "bdquo;": "\u201E",
  "bepsi;": "\u03F6",
  "blank;": "\u2423",
  "blk12;": "\u2592",
  "blk14;": "\u2591",
  "blk34;": "\u2593",
  "block;": "\u2588",
  "boxDL;": "\u2557",
  "boxDl;": "\u2556",
  "boxdL;": "\u2555",
  "boxdl;": "\u2510",
  "boxDR;": "\u2554",
  "boxDr;": "\u2553",
  "boxdR;": "\u2552",
  "boxdr;": "\u250C",
  "boxHD;": "\u2566",
  "boxHd;": "\u2564",
  "boxhD;": "\u2565",
  "boxhd;": "\u252C",
  "boxHU;": "\u2569",
  "boxHu;": "\u2567",
  "boxhU;": "\u2568",
  "boxhu;": "\u2534",
  "boxUL;": "\u255D",
  "boxUl;": "\u255C",
  "boxuL;": "\u255B",
  "boxul;": "\u2518",
  "boxUR;": "\u255A",
  "boxUr;": "\u2559",
  "boxuR;": "\u2558",
  "boxur;": "\u2514",
  "boxVH;": "\u256C",
  "boxVh;": "\u256B",
  "boxvH;": "\u256A",
  "boxvh;": "\u253C",
  "boxVL;": "\u2563",
  "boxVl;": "\u2562",
  "boxvL;": "\u2561",
  "boxvl;": "\u2524",
  "boxVR;": "\u2560",
  "boxVr;": "\u255F",
  "boxvR;": "\u255E",
  "boxvr;": "\u251C",
  "Breve;": "\u02D8",
  "breve;": "\u02D8",
  brvbar: "\xA6",
  "bsemi;": "\u204F",
  "bsime;": "\u22CD",
  "bsolb;": "\u29C5",
  "bumpE;": "\u2AAE",
  "bumpe;": "\u224F",
  "caret;": "\u2041",
  "caron;": "\u02C7",
  "ccaps;": "\u2A4D",
  Ccedil: "\xC7",
  ccedil: "\xE7",
  "Ccirc;": "\u0108",
  "ccirc;": "\u0109",
  "ccups;": "\u2A4C",
  "cedil;": "\xB8",
  "check;": "\u2713",
  "clubs;": "\u2663",
  "Colon;": "\u2237",
  "colon;": ":",
  "comma;": ",",
  "crarr;": "\u21B5",
  "Cross;": "\u2A2F",
  "cross;": "\u2717",
  "csube;": "\u2AD1",
  "csupe;": "\u2AD2",
  "ctdot;": "\u22EF",
  "cuepr;": "\u22DE",
  "cuesc;": "\u22DF",
  "cupor;": "\u2A45",
  curren: "\xA4",
  "cuvee;": "\u22CE",
  "cuwed;": "\u22CF",
  "cwint;": "\u2231",
  "Dashv;": "\u2AE4",
  "dashv;": "\u22A3",
  "dblac;": "\u02DD",
  "ddarr;": "\u21CA",
  "Delta;": "\u0394",
  "delta;": "\u03B4",
  "dharl;": "\u21C3",
  "dharr;": "\u21C2",
  "diams;": "\u2666",
  "disin;": "\u22F2",
  divide: "\xF7",
  "doteq;": "\u2250",
  "dtdot;": "\u22F1",
  "dtrif;": "\u25BE",
  "duarr;": "\u21F5",
  "duhar;": "\u296F",
  Eacute: "\xC9",
  eacute: "\xE9",
  "Ecirc;": "\xCA",
  "ecirc;": "\xEA",
  "eDDot;": "\u2A77",
  "efDot;": "\u2252",
  Egrave: "\xC8",
  egrave: "\xE8",
  "Emacr;": "\u0112",
  "emacr;": "\u0113",
  "empty;": "\u2205",
  "Eogon;": "\u0118",
  "eogon;": "\u0119",
  "eplus;": "\u2A71",
  "epsiv;": "\u03F5",
  "eqsim;": "\u2242",
  "Equal;": "\u2A75",
  "equiv;": "\u2261",
  "erarr;": "\u2971",
  "erDot;": "\u2253",
  "esdot;": "\u2250",
  "exist;": "\u2203",
  "fflig;": "\uFB00",
  "filig;": "\uFB01",
  "fjlig;": "fj",
  "fllig;": "\uFB02",
  "fltns;": "\u25B1",
  "forkv;": "\u2AD9",
  frac12: "\xBD",
  frac14: "\xBC",
  frac34: "\xBE",
  "frasl;": "\u2044",
  "frown;": "\u2322",
  "Gamma;": "\u0393",
  "gamma;": "\u03B3",
  "Gcirc;": "\u011C",
  "gcirc;": "\u011D",
  "gescc;": "\u2AA9",
  "gimel;": "\u2137",
  "gneqq;": "\u2269",
  "gnsim;": "\u22E7",
  "grave;": "`",
  "gsime;": "\u2A8E",
  "gsiml;": "\u2A90",
  "gtcir;": "\u2A7A",
  "gtdot;": "\u22D7",
  "Hacek;": "\u02C7",
  "harrw;": "\u21AD",
  "Hcirc;": "\u0124",
  "hcirc;": "\u0125",
  "hoarr;": "\u21FF",
  Iacute: "\xCD",
  iacute: "\xED",
  "Icirc;": "\xCE",
  "icirc;": "\xEE",
  "iexcl;": "\xA1",
  Igrave: "\xCC",
  igrave: "\xEC",
  "iiint;": "\u222D",
  "iiota;": "\u2129",
  "IJlig;": "\u0132",
  "ijlig;": "\u0133",
  "Imacr;": "\u012A",
  "imacr;": "\u012B",
  "image;": "\u2111",
  "imath;": "\u0131",
  "imped;": "\u01B5",
  "infin;": "\u221E",
  "Iogon;": "\u012E",
  "iogon;": "\u012F",
  "iprod;": "\u2A3C",
  iquest: "\xBF",
  "isinE;": "\u22F9",
  "isins;": "\u22F4",
  "isinv;": "\u2208",
  "Iukcy;": "\u0406",
  "iukcy;": "\u0456",
  "Jcirc;": "\u0134",
  "jcirc;": "\u0135",
  "jmath;": "\u0237",
  "Jukcy;": "\u0404",
  "jukcy;": "\u0454",
  "Kappa;": "\u039A",
  "kappa;": "\u03BA",
  "lAarr;": "\u21DA",
  "langd;": "\u2991",
  "laquo;": "\xAB",
  "larrb;": "\u21E4",
  "lates;": "\u2AAD\uFE00",
  "lBarr;": "\u290E",
  "lbarr;": "\u290C",
  "lbbrk;": "\u2772",
  "lbrke;": "\u298B",
  "lceil;": "\u2308",
  "ldquo;": "\u201C",
  "lescc;": "\u2AA8",
  "lhard;": "\u21BD",
  "lharu;": "\u21BC",
  "lhblk;": "\u2584",
  "llarr;": "\u21C7",
  "lltri;": "\u25FA",
  "lneqq;": "\u2268",
  "lnsim;": "\u22E6",
  "loang;": "\u27EC",
  "loarr;": "\u21FD",
  "lobrk;": "\u27E6",
  "lopar;": "\u2985",
  "lrarr;": "\u21C6",
  "lrhar;": "\u21CB",
  "lrtri;": "\u22BF",
  "lsime;": "\u2A8D",
  "lsimg;": "\u2A8F",
  "lsquo;": "\u2018",
  "ltcir;": "\u2A79",
  "ltdot;": "\u22D6",
  "ltrie;": "\u22B4",
  "ltrif;": "\u25C2",
  "mdash;": "\u2014",
  "mDDot;": "\u223A",
  "micro;": "\xB5",
  middot: "\xB7",
  "minus;": "\u2212",
  "mumap;": "\u22B8",
  "nabla;": "\u2207",
  "napid;": "\u224B\u0338",
  "napos;": "\u0149",
  "natur;": "\u266E",
  "nbump;": "\u224E\u0338",
  "ncong;": "\u2247",
  "ndash;": "\u2013",
  "neArr;": "\u21D7",
  "nearr;": "\u2197",
  "nedot;": "\u2250\u0338",
  "nesim;": "\u2242\u0338",
  "ngeqq;": "\u2267\u0338",
  "ngsim;": "\u2275",
  "nhArr;": "\u21CE",
  "nharr;": "\u21AE",
  "nhpar;": "\u2AF2",
  "nlArr;": "\u21CD",
  "nlarr;": "\u219A",
  "nleqq;": "\u2266\u0338",
  "nless;": "\u226E",
  "nlsim;": "\u2274",
  "nltri;": "\u22EA",
  "notin;": "\u2209",
  "notni;": "\u220C",
  "npart;": "\u2202\u0338",
  "nprec;": "\u2280",
  "nrArr;": "\u21CF",
  "nrarr;": "\u219B",
  "nrtri;": "\u22EB",
  "nsime;": "\u2244",
  "nsmid;": "\u2224",
  "nspar;": "\u2226",
  "nsubE;": "\u2AC5\u0338",
  "nsube;": "\u2288",
  "nsucc;": "\u2281",
  "nsupE;": "\u2AC6\u0338",
  "nsupe;": "\u2289",
  Ntilde: "\xD1",
  ntilde: "\xF1",
  "numsp;": "\u2007",
  "nvsim;": "\u223C\u20D2",
  "nwArr;": "\u21D6",
  "nwarr;": "\u2196",
  Oacute: "\xD3",
  oacute: "\xF3",
  "Ocirc;": "\xD4",
  "ocirc;": "\xF4",
  "odash;": "\u229D",
  "OElig;": "\u0152",
  "oelig;": "\u0153",
  "ofcir;": "\u29BF",
  Ograve: "\xD2",
  ograve: "\xF2",
  "ohbar;": "\u29B5",
  "olarr;": "\u21BA",
  "olcir;": "\u29BE",
  "oline;": "\u203E",
  "Omacr;": "\u014C",
  "omacr;": "\u014D",
  "Omega;": "\u03A9",
  "omega;": "\u03C9",
  "operp;": "\u29B9",
  "oplus;": "\u2295",
  "orarr;": "\u21BB",
  "order;": "\u2134",
  Oslash: "\xD8",
  oslash: "\xF8",
  Otilde: "\xD5",
  otilde: "\xF5",
  "ovbar;": "\u233D",
  "parsl;": "\u2AFD",
  "phone;": "\u260E",
  "plusb;": "\u229E",
  "pluse;": "\u2A72",
  plusmn: "\xB1",
  "pound;": "\xA3",
  "prcue;": "\u227C",
  "Prime;": "\u2033",
  "prime;": "\u2032",
  "prnap;": "\u2AB9",
  "prsim;": "\u227E",
  "quest;": "?",
  "rAarr;": "\u21DB",
  "radic;": "\u221A",
  "rangd;": "\u2992",
  "range;": "\u29A5",
  "raquo;": "\xBB",
  "rarrb;": "\u21E5",
  "rarrc;": "\u2933",
  "rarrw;": "\u219D",
  "ratio;": "\u2236",
  "RBarr;": "\u2910",
  "rBarr;": "\u290F",
  "rbarr;": "\u290D",
  "rbbrk;": "\u2773",
  "rbrke;": "\u298C",
  "rceil;": "\u2309",
  "rdquo;": "\u201D",
  "reals;": "\u211D",
  "rhard;": "\u21C1",
  "rharu;": "\u21C0",
  "rlarr;": "\u21C4",
  "rlhar;": "\u21CC",
  "rnmid;": "\u2AEE",
  "roang;": "\u27ED",
  "roarr;": "\u21FE",
  "robrk;": "\u27E7",
  "ropar;": "\u2986",
  "rrarr;": "\u21C9",
  "rsquo;": "\u2019",
  "rtrie;": "\u22B5",
  "rtrif;": "\u25B8",
  "sbquo;": "\u201A",
  "sccue;": "\u227D",
  "Scirc;": "\u015C",
  "scirc;": "\u015D",
  "scnap;": "\u2ABA",
  "scsim;": "\u227F",
  "sdotb;": "\u22A1",
  "sdote;": "\u2A66",
  "seArr;": "\u21D8",
  "searr;": "\u2198",
  "setmn;": "\u2216",
  "sharp;": "\u266F",
  "Sigma;": "\u03A3",
  "sigma;": "\u03C3",
  "simeq;": "\u2243",
  "simgE;": "\u2AA0",
  "simlE;": "\u2A9F",
  "simne;": "\u2246",
  "slarr;": "\u2190",
  "smile;": "\u2323",
  "smtes;": "\u2AAC\uFE00",
  "sqcap;": "\u2293",
  "sqcup;": "\u2294",
  "sqsub;": "\u228F",
  "sqsup;": "\u2290",
  "srarr;": "\u2192",
  "starf;": "\u2605",
  "strns;": "\xAF",
  "subnE;": "\u2ACB",
  "subne;": "\u228A",
  "supnE;": "\u2ACC",
  "supne;": "\u228B",
  "swArr;": "\u21D9",
  "swarr;": "\u2199",
  "szlig;": "\xDF",
  "Theta;": "\u0398",
  "theta;": "\u03B8",
  "thkap;": "\u2248",
  "THORN;": "\xDE",
  "thorn;": "\xFE",
  "Tilde;": "\u223C",
  "tilde;": "\u02DC",
  "times;": "\xD7",
  "TRADE;": "\u2122",
  "trade;": "\u2122",
  "trisb;": "\u29CD",
  "TSHcy;": "\u040B",
  "tshcy;": "\u045B",
  "twixt;": "\u226C",
  Uacute: "\xDA",
  uacute: "\xFA",
  "Ubrcy;": "\u040E",
  "ubrcy;": "\u045E",
  "Ucirc;": "\xDB",
  "ucirc;": "\xFB",
  "udarr;": "\u21C5",
  "udhar;": "\u296E",
  Ugrave: "\xD9",
  ugrave: "\xF9",
  "uharl;": "\u21BF",
  "uharr;": "\u21BE",
  "uhblk;": "\u2580",
  "ultri;": "\u25F8",
  "Umacr;": "\u016A",
  "umacr;": "\u016B",
  "Union;": "\u22C3",
  "Uogon;": "\u0172",
  "uogon;": "\u0173",
  "uplus;": "\u228E",
  "upsih;": "\u03D2",
  "UpTee;": "\u22A5",
  "Uring;": "\u016E",
  "uring;": "\u016F",
  "urtri;": "\u25F9",
  "utdot;": "\u22F0",
  "utrif;": "\u25B4",
  "uuarr;": "\u21C8",
  "varpi;": "\u03D6",
  "vBarv;": "\u2AE9",
  "VDash;": "\u22AB",
  "Vdash;": "\u22A9",
  "vDash;": "\u22A8",
  "vdash;": "\u22A2",
  "veeeq;": "\u225A",
  "vltri;": "\u22B2",
  "vnsub;": "\u2282\u20D2",
  "vnsup;": "\u2283\u20D2",
  "vprop;": "\u221D",
  "vrtri;": "\u22B3",
  "Wcirc;": "\u0174",
  "wcirc;": "\u0175",
  "Wedge;": "\u22C0",
  "wedge;": "\u2227",
  "xcirc;": "\u25EF",
  "xdtri;": "\u25BD",
  "xhArr;": "\u27FA",
  "xharr;": "\u27F7",
  "xlArr;": "\u27F8",
  "xlarr;": "\u27F5",
  "xodot;": "\u2A00",
  "xrArr;": "\u27F9",
  "xrarr;": "\u27F6",
  "xutri;": "\u25B3",
  Yacute: "\xDD",
  yacute: "\xFD",
  "Ycirc;": "\u0176",
  "ycirc;": "\u0177",
  "Aacute;": "\xC1",
  "aacute;": "\xE1",
  "Abreve;": "\u0102",
  "abreve;": "\u0103",
  "Agrave;": "\xC0",
  "agrave;": "\xE0",
  "andand;": "\u2A55",
  "angmsd;": "\u2221",
  "angsph;": "\u2222",
  "apacir;": "\u2A6F",
  "approx;": "\u2248",
  "Assign;": "\u2254",
  "Atilde;": "\xC3",
  "atilde;": "\xE3",
  "barvee;": "\u22BD",
  "Barwed;": "\u2306",
  "barwed;": "\u2305",
  "becaus;": "\u2235",
  "bernou;": "\u212C",
  "bigcap;": "\u22C2",
  "bigcup;": "\u22C3",
  "bigvee;": "\u22C1",
  "bkarow;": "\u290D",
  "bottom;": "\u22A5",
  "bowtie;": "\u22C8",
  "boxbox;": "\u29C9",
  "bprime;": "\u2035",
  "brvbar;": "\xA6",
  "bullet;": "\u2022",
  "Bumpeq;": "\u224E",
  "bumpeq;": "\u224F",
  "Cacute;": "\u0106",
  "cacute;": "\u0107",
  "capand;": "\u2A44",
  "capcap;": "\u2A4B",
  "capcup;": "\u2A47",
  "capdot;": "\u2A40",
  "Ccaron;": "\u010C",
  "ccaron;": "\u010D",
  "Ccedil;": "\xC7",
  "ccedil;": "\xE7",
  "circeq;": "\u2257",
  "cirmid;": "\u2AEF",
  "Colone;": "\u2A74",
  "colone;": "\u2254",
  "commat;": "@",
  "compfn;": "\u2218",
  "Conint;": "\u222F",
  "conint;": "\u222E",
  "coprod;": "\u2210",
  "copysr;": "\u2117",
  "cularr;": "\u21B6",
  "CupCap;": "\u224D",
  "cupcap;": "\u2A46",
  "cupcup;": "\u2A4A",
  "cupdot;": "\u228D",
  "curarr;": "\u21B7",
  "curren;": "\xA4",
  "cylcty;": "\u232D",
  "Dagger;": "\u2021",
  "dagger;": "\u2020",
  "daleth;": "\u2138",
  "Dcaron;": "\u010E",
  "dcaron;": "\u010F",
  "dfisht;": "\u297F",
  "divide;": "\xF7",
  "divonx;": "\u22C7",
  "dlcorn;": "\u231E",
  "dlcrop;": "\u230D",
  "dollar;": "$",
  "DotDot;": "\u20DC",
  "drcorn;": "\u231F",
  "drcrop;": "\u230C",
  "Dstrok;": "\u0110",
  "dstrok;": "\u0111",
  "Eacute;": "\xC9",
  "eacute;": "\xE9",
  "easter;": "\u2A6E",
  "Ecaron;": "\u011A",
  "ecaron;": "\u011B",
  "ecolon;": "\u2255",
  "Egrave;": "\xC8",
  "egrave;": "\xE8",
  "egsdot;": "\u2A98",
  "elsdot;": "\u2A97",
  "emptyv;": "\u2205",
  "emsp13;": "\u2004",
  "emsp14;": "\u2005",
  "eparsl;": "\u29E3",
  "eqcirc;": "\u2256",
  "equals;": "=",
  "equest;": "\u225F",
  "Exists;": "\u2203",
  "female;": "\u2640",
  "ffilig;": "\uFB03",
  "ffllig;": "\uFB04",
  "ForAll;": "\u2200",
  "forall;": "\u2200",
  "frac12;": "\xBD",
  "frac13;": "\u2153",
  "frac14;": "\xBC",
  "frac15;": "\u2155",
  "frac16;": "\u2159",
  "frac18;": "\u215B",
  "frac23;": "\u2154",
  "frac25;": "\u2156",
  "frac34;": "\xBE",
  "frac35;": "\u2157",
  "frac38;": "\u215C",
  "frac45;": "\u2158",
  "frac56;": "\u215A",
  "frac58;": "\u215D",
  "frac78;": "\u215E",
  "gacute;": "\u01F5",
  "Gammad;": "\u03DC",
  "gammad;": "\u03DD",
  "Gbreve;": "\u011E",
  "gbreve;": "\u011F",
  "Gcedil;": "\u0122",
  "gesdot;": "\u2A80",
  "gesles;": "\u2A94",
  "gtlPar;": "\u2995",
  "gtrarr;": "\u2978",
  "gtrdot;": "\u22D7",
  "gtrsim;": "\u2273",
  "hairsp;": "\u200A",
  "hamilt;": "\u210B",
  "HARDcy;": "\u042A",
  "hardcy;": "\u044A",
  "hearts;": "\u2665",
  "hellip;": "\u2026",
  "hercon;": "\u22B9",
  "homtht;": "\u223B",
  "horbar;": "\u2015",
  "hslash;": "\u210F",
  "Hstrok;": "\u0126",
  "hstrok;": "\u0127",
  "hybull;": "\u2043",
  "hyphen;": "\u2010",
  "Iacute;": "\xCD",
  "iacute;": "\xED",
  "Igrave;": "\xCC",
  "igrave;": "\xEC",
  "iiiint;": "\u2A0C",
  "iinfin;": "\u29DC",
  "incare;": "\u2105",
  "inodot;": "\u0131",
  "intcal;": "\u22BA",
  "iquest;": "\xBF",
  "isinsv;": "\u22F3",
  "Itilde;": "\u0128",
  "itilde;": "\u0129",
  "Jsercy;": "\u0408",
  "jsercy;": "\u0458",
  "kappav;": "\u03F0",
  "Kcedil;": "\u0136",
  "kcedil;": "\u0137",
  "kgreen;": "\u0138",
  "Lacute;": "\u0139",
  "lacute;": "\u013A",
  "lagran;": "\u2112",
  "Lambda;": "\u039B",
  "lambda;": "\u03BB",
  "langle;": "\u27E8",
  "larrfs;": "\u291D",
  "larrhk;": "\u21A9",
  "larrlp;": "\u21AB",
  "larrpl;": "\u2939",
  "larrtl;": "\u21A2",
  "lAtail;": "\u291B",
  "latail;": "\u2919",
  "lbrace;": "{",
  "lbrack;": "[",
  "Lcaron;": "\u013D",
  "lcaron;": "\u013E",
  "Lcedil;": "\u013B",
  "lcedil;": "\u013C",
  "ldquor;": "\u201E",
  "lesdot;": "\u2A7F",
  "lesges;": "\u2A93",
  "lfisht;": "\u297C",
  "lfloor;": "\u230A",
  "lharul;": "\u296A",
  "llhard;": "\u296B",
  "Lmidot;": "\u013F",
  "lmidot;": "\u0140",
  "lmoust;": "\u23B0",
  "loplus;": "\u2A2D",
  "lowast;": "\u2217",
  "lowbar;": "_",
  "lparlt;": "\u2993",
  "lrhard;": "\u296D",
  "lsaquo;": "\u2039",
  "lsquor;": "\u201A",
  "Lstrok;": "\u0141",
  "lstrok;": "\u0142",
  "lthree;": "\u22CB",
  "ltimes;": "\u22C9",
  "ltlarr;": "\u2976",
  "ltrPar;": "\u2996",
  "mapsto;": "\u21A6",
  "marker;": "\u25AE",
  "mcomma;": "\u2A29",
  "midast;": "*",
  "midcir;": "\u2AF0",
  "middot;": "\xB7",
  "minusb;": "\u229F",
  "minusd;": "\u2238",
  "mnplus;": "\u2213",
  "models;": "\u22A7",
  "mstpos;": "\u223E",
  "Nacute;": "\u0143",
  "nacute;": "\u0144",
  "nbumpe;": "\u224F\u0338",
  "Ncaron;": "\u0147",
  "ncaron;": "\u0148",
  "Ncedil;": "\u0145",
  "ncedil;": "\u0146",
  "nearhk;": "\u2924",
  "nequiv;": "\u2262",
  "nesear;": "\u2928",
  "nexist;": "\u2204",
  "nltrie;": "\u22EC",
  "notinE;": "\u22F9\u0338",
  "nparsl;": "\u2AFD\u20E5",
  "nprcue;": "\u22E0",
  "nrarrc;": "\u2933\u0338",
  "nrarrw;": "\u219D\u0338",
  "nrtrie;": "\u22ED",
  "nsccue;": "\u22E1",
  "nsimeq;": "\u2244",
  "Ntilde;": "\xD1",
  "ntilde;": "\xF1",
  "numero;": "\u2116",
  "nVDash;": "\u22AF",
  "nVdash;": "\u22AE",
  "nvDash;": "\u22AD",
  "nvdash;": "\u22AC",
  "nvHarr;": "\u2904",
  "nvlArr;": "\u2902",
  "nvrArr;": "\u2903",
  "nwarhk;": "\u2923",
  "nwnear;": "\u2927",
  "Oacute;": "\xD3",
  "oacute;": "\xF3",
  "Odblac;": "\u0150",
  "odblac;": "\u0151",
  "odsold;": "\u29BC",
  "Ograve;": "\xD2",
  "ograve;": "\xF2",
  "ominus;": "\u2296",
  "origof;": "\u22B6",
  "Oslash;": "\xD8",
  "oslash;": "\xF8",
  "Otilde;": "\xD5",
  "otilde;": "\xF5",
  "Otimes;": "\u2A37",
  "otimes;": "\u2297",
  "parsim;": "\u2AF3",
  "percnt;": "%",
  "period;": ".",
  "permil;": "\u2030",
  "phmmat;": "\u2133",
  "planck;": "\u210F",
  "plankv;": "\u210F",
  "plusdo;": "\u2214",
  "plusdu;": "\u2A25",
  "plusmn;": "\xB1",
  "preceq;": "\u2AAF",
  "primes;": "\u2119",
  "prnsim;": "\u22E8",
  "propto;": "\u221D",
  "prurel;": "\u22B0",
  "puncsp;": "\u2008",
  "qprime;": "\u2057",
  "Racute;": "\u0154",
  "racute;": "\u0155",
  "rangle;": "\u27E9",
  "rarrap;": "\u2975",
  "rarrfs;": "\u291E",
  "rarrhk;": "\u21AA",
  "rarrlp;": "\u21AC",
  "rarrpl;": "\u2945",
  "Rarrtl;": "\u2916",
  "rarrtl;": "\u21A3",
  "rAtail;": "\u291C",
  "ratail;": "\u291A",
  "rbrace;": "}",
  "rbrack;": "]",
  "Rcaron;": "\u0158",
  "rcaron;": "\u0159",
  "Rcedil;": "\u0156",
  "rcedil;": "\u0157",
  "rdquor;": "\u201D",
  "rfisht;": "\u297D",
  "rfloor;": "\u230B",
  "rharul;": "\u296C",
  "rmoust;": "\u23B1",
  "roplus;": "\u2A2E",
  "rpargt;": "\u2994",
  "rsaquo;": "\u203A",
  "rsquor;": "\u2019",
  "rthree;": "\u22CC",
  "rtimes;": "\u22CA",
  "Sacute;": "\u015A",
  "sacute;": "\u015B",
  "Scaron;": "\u0160",
  "scaron;": "\u0161",
  "Scedil;": "\u015E",
  "scedil;": "\u015F",
  "scnsim;": "\u22E9",
  "searhk;": "\u2925",
  "seswar;": "\u2929",
  "sfrown;": "\u2322",
  "SHCHcy;": "\u0429",
  "shchcy;": "\u0449",
  "sigmaf;": "\u03C2",
  "sigmav;": "\u03C2",
  "simdot;": "\u2A6A",
  "smashp;": "\u2A33",
  "SOFTcy;": "\u042C",
  "softcy;": "\u044C",
  "solbar;": "\u233F",
  "spades;": "\u2660",
  "sqcaps;": "\u2293\uFE00",
  "sqcups;": "\u2294\uFE00",
  "sqsube;": "\u2291",
  "sqsupe;": "\u2292",
  "Square;": "\u25A1",
  "square;": "\u25A1",
  "squarf;": "\u25AA",
  "ssetmn;": "\u2216",
  "ssmile;": "\u2323",
  "sstarf;": "\u22C6",
  "subdot;": "\u2ABD",
  "Subset;": "\u22D0",
  "subset;": "\u2282",
  "subsim;": "\u2AC7",
  "subsub;": "\u2AD5",
  "subsup;": "\u2AD3",
  "succeq;": "\u2AB0",
  "supdot;": "\u2ABE",
  "Supset;": "\u22D1",
  "supset;": "\u2283",
  "supsim;": "\u2AC8",
  "supsub;": "\u2AD4",
  "supsup;": "\u2AD6",
  "swarhk;": "\u2926",
  "swnwar;": "\u292A",
  "target;": "\u2316",
  "Tcaron;": "\u0164",
  "tcaron;": "\u0165",
  "Tcedil;": "\u0162",
  "tcedil;": "\u0163",
  "telrec;": "\u2315",
  "there4;": "\u2234",
  "thetav;": "\u03D1",
  "thinsp;": "\u2009",
  "thksim;": "\u223C",
  "timesb;": "\u22A0",
  "timesd;": "\u2A30",
  "topbot;": "\u2336",
  "topcir;": "\u2AF1",
  "tprime;": "\u2034",
  "tridot;": "\u25EC",
  "Tstrok;": "\u0166",
  "tstrok;": "\u0167",
  "Uacute;": "\xDA",
  "uacute;": "\xFA",
  "Ubreve;": "\u016C",
  "ubreve;": "\u016D",
  "Udblac;": "\u0170",
  "udblac;": "\u0171",
  "ufisht;": "\u297E",
  "Ugrave;": "\xD9",
  "ugrave;": "\xF9",
  "ulcorn;": "\u231C",
  "ulcrop;": "\u230F",
  "urcorn;": "\u231D",
  "urcrop;": "\u230E",
  "Utilde;": "\u0168",
  "utilde;": "\u0169",
  "vangrt;": "\u299C",
  "varphi;": "\u03D5",
  "varrho;": "\u03F1",
  "Vdashl;": "\u2AE6",
  "veebar;": "\u22BB",
  "vellip;": "\u22EE",
  "Verbar;": "\u2016",
  "verbar;": "|",
  "vsubnE;": "\u2ACB\uFE00",
  "vsubne;": "\u228A\uFE00",
  "vsupnE;": "\u2ACC\uFE00",
  "vsupne;": "\u228B\uFE00",
  "Vvdash;": "\u22AA",
  "wedbar;": "\u2A5F",
  "wedgeq;": "\u2259",
  "weierp;": "\u2118",
  "wreath;": "\u2240",
  "xoplus;": "\u2A01",
  "xotime;": "\u2A02",
  "xsqcup;": "\u2A06",
  "xuplus;": "\u2A04",
  "xwedge;": "\u22C0",
  "Yacute;": "\xDD",
  "yacute;": "\xFD",
  "Zacute;": "\u0179",
  "zacute;": "\u017A",
  "Zcaron;": "\u017D",
  "zcaron;": "\u017E",
  "zeetrf;": "\u2128",
  "alefsym;": "\u2135",
  "angrtvb;": "\u22BE",
  "angzarr;": "\u237C",
  "asympeq;": "\u224D",
  "backsim;": "\u223D",
  "Because;": "\u2235",
  "because;": "\u2235",
  "bemptyv;": "\u29B0",
  "between;": "\u226C",
  "bigcirc;": "\u25EF",
  "bigodot;": "\u2A00",
  "bigstar;": "\u2605",
  "bnequiv;": "\u2261\u20E5",
  "boxplus;": "\u229E",
  "Cayleys;": "\u212D",
  "Cconint;": "\u2230",
  "ccupssm;": "\u2A50",
  "Cedilla;": "\xB8",
  "cemptyv;": "\u29B2",
  "cirscir;": "\u29C2",
  "coloneq;": "\u2254",
  "congdot;": "\u2A6D",
  "cudarrl;": "\u2938",
  "cudarrr;": "\u2935",
  "cularrp;": "\u293D",
  "curarrm;": "\u293C",
  "dbkarow;": "\u290F",
  "ddagger;": "\u2021",
  "ddotseq;": "\u2A77",
  "demptyv;": "\u29B1",
  "Diamond;": "\u22C4",
  "diamond;": "\u22C4",
  "digamma;": "\u03DD",
  "dotplus;": "\u2214",
  "DownTee;": "\u22A4",
  "dwangle;": "\u29A6",
  "Element;": "\u2208",
  "Epsilon;": "\u0395",
  "epsilon;": "\u03B5",
  "eqcolon;": "\u2255",
  "equivDD;": "\u2A78",
  "gesdoto;": "\u2A82",
  "gtquest;": "\u2A7C",
  "gtrless;": "\u2277",
  "harrcir;": "\u2948",
  "Implies;": "\u21D2",
  "intprod;": "\u2A3C",
  "isindot;": "\u22F5",
  "larrbfs;": "\u291F",
  "larrsim;": "\u2973",
  "lbrksld;": "\u298F",
  "lbrkslu;": "\u298D",
  "ldrdhar;": "\u2967",
  "LeftTee;": "\u22A3",
  "lesdoto;": "\u2A81",
  "lessdot;": "\u22D6",
  "lessgtr;": "\u2276",
  "lesssim;": "\u2272",
  "lotimes;": "\u2A34",
  "lozenge;": "\u25CA",
  "ltquest;": "\u2A7B",
  "luruhar;": "\u2966",
  "maltese;": "\u2720",
  "minusdu;": "\u2A2A",
  "napprox;": "\u2249",
  "natural;": "\u266E",
  "nearrow;": "\u2197",
  "NewLine;": `
`,
  "nexists;": "\u2204",
  "NoBreak;": "\u2060",
  "notinva;": "\u2209",
  "notinvb;": "\u22F7",
  "notinvc;": "\u22F6",
  "NotLess;": "\u226E",
  "notniva;": "\u220C",
  "notnivb;": "\u22FE",
  "notnivc;": "\u22FD",
  "npolint;": "\u2A14",
  "npreceq;": "\u2AAF\u0338",
  "nsqsube;": "\u22E2",
  "nsqsupe;": "\u22E3",
  "nsubset;": "\u2282\u20D2",
  "nsucceq;": "\u2AB0\u0338",
  "nsupset;": "\u2283\u20D2",
  "nvinfin;": "\u29DE",
  "nvltrie;": "\u22B4\u20D2",
  "nvrtrie;": "\u22B5\u20D2",
  "nwarrow;": "\u2196",
  "olcross;": "\u29BB",
  "Omicron;": "\u039F",
  "omicron;": "\u03BF",
  "orderof;": "\u2134",
  "orslope;": "\u2A57",
  "OverBar;": "\u203E",
  "pertenk;": "\u2031",
  "planckh;": "\u210E",
  "pluscir;": "\u2A22",
  "plussim;": "\u2A26",
  "plustwo;": "\u2A27",
  "precsim;": "\u227E",
  "Product;": "\u220F",
  "quatint;": "\u2A16",
  "questeq;": "\u225F",
  "rarrbfs;": "\u2920",
  "rarrsim;": "\u2974",
  "rbrksld;": "\u298E",
  "rbrkslu;": "\u2990",
  "rdldhar;": "\u2969",
  "realine;": "\u211B",
  "rotimes;": "\u2A35",
  "ruluhar;": "\u2968",
  "searrow;": "\u2198",
  "simplus;": "\u2A24",
  "simrarr;": "\u2972",
  "subedot;": "\u2AC3",
  "submult;": "\u2AC1",
  "subplus;": "\u2ABF",
  "subrarr;": "\u2979",
  "succsim;": "\u227F",
  "supdsub;": "\u2AD8",
  "supedot;": "\u2AC4",
  "suphsol;": "\u27C9",
  "suphsub;": "\u2AD7",
  "suplarr;": "\u297B",
  "supmult;": "\u2AC2",
  "supplus;": "\u2AC0",
  "swarrow;": "\u2199",
  "topfork;": "\u2ADA",
  "triplus;": "\u2A39",
  "tritime;": "\u2A3B",
  "UpArrow;": "\u2191",
  "Uparrow;": "\u21D1",
  "uparrow;": "\u2191",
  "Upsilon;": "\u03A5",
  "upsilon;": "\u03C5",
  "uwangle;": "\u29A7",
  "vzigzag;": "\u299A",
  "zigrarr;": "\u21DD",
  "andslope;": "\u2A58",
  "angmsdaa;": "\u29A8",
  "angmsdab;": "\u29A9",
  "angmsdac;": "\u29AA",
  "angmsdad;": "\u29AB",
  "angmsdae;": "\u29AC",
  "angmsdaf;": "\u29AD",
  "angmsdag;": "\u29AE",
  "angmsdah;": "\u29AF",
  "angrtvbd;": "\u299D",
  "approxeq;": "\u224A",
  "awconint;": "\u2233",
  "backcong;": "\u224C",
  "barwedge;": "\u2305",
  "bbrktbrk;": "\u23B6",
  "bigoplus;": "\u2A01",
  "bigsqcup;": "\u2A06",
  "biguplus;": "\u2A04",
  "bigwedge;": "\u22C0",
  "boxminus;": "\u229F",
  "boxtimes;": "\u22A0",
  "bsolhsub;": "\u27C8",
  "capbrcup;": "\u2A49",
  "circledR;": "\xAE",
  "circledS;": "\u24C8",
  "cirfnint;": "\u2A10",
  "clubsuit;": "\u2663",
  "cupbrcap;": "\u2A48",
  "curlyvee;": "\u22CE",
  "cwconint;": "\u2232",
  "DDotrahd;": "\u2911",
  "doteqdot;": "\u2251",
  "DotEqual;": "\u2250",
  "dotminus;": "\u2238",
  "drbkarow;": "\u2910",
  "dzigrarr;": "\u27FF",
  "elinters;": "\u23E7",
  "emptyset;": "\u2205",
  "eqvparsl;": "\u29E5",
  "fpartint;": "\u2A0D",
  "geqslant;": "\u2A7E",
  "gesdotol;": "\u2A84",
  "gnapprox;": "\u2A8A",
  "hksearow;": "\u2925",
  "hkswarow;": "\u2926",
  "imagline;": "\u2110",
  "imagpart;": "\u2111",
  "infintie;": "\u29DD",
  "integers;": "\u2124",
  "Integral;": "\u222B",
  "intercal;": "\u22BA",
  "intlarhk;": "\u2A17",
  "laemptyv;": "\u29B4",
  "ldrushar;": "\u294B",
  "leqslant;": "\u2A7D",
  "lesdotor;": "\u2A83",
  "LessLess;": "\u2AA1",
  "llcorner;": "\u231E",
  "lnapprox;": "\u2A89",
  "lrcorner;": "\u231F",
  "lurdshar;": "\u294A",
  "mapstoup;": "\u21A5",
  "multimap;": "\u22B8",
  "naturals;": "\u2115",
  "ncongdot;": "\u2A6D\u0338",
  "NotEqual;": "\u2260",
  "notindot;": "\u22F5\u0338",
  "NotTilde;": "\u2241",
  "otimesas;": "\u2A36",
  "parallel;": "\u2225",
  "PartialD;": "\u2202",
  "plusacir;": "\u2A23",
  "pointint;": "\u2A15",
  "Precedes;": "\u227A",
  "precneqq;": "\u2AB5",
  "precnsim;": "\u22E8",
  "profalar;": "\u232E",
  "profline;": "\u2312",
  "profsurf;": "\u2313",
  "raemptyv;": "\u29B3",
  "realpart;": "\u211C",
  "RightTee;": "\u22A2",
  "rppolint;": "\u2A12",
  "rtriltri;": "\u29CE",
  "scpolint;": "\u2A13",
  "setminus;": "\u2216",
  "shortmid;": "\u2223",
  "smeparsl;": "\u29E4",
  "sqsubset;": "\u228F",
  "sqsupset;": "\u2290",
  "subseteq;": "\u2286",
  "Succeeds;": "\u227B",
  "succneqq;": "\u2AB6",
  "succnsim;": "\u22E9",
  "SuchThat;": "\u220B",
  "Superset;": "\u2283",
  "supseteq;": "\u2287",
  "thetasym;": "\u03D1",
  "thicksim;": "\u223C",
  "timesbar;": "\u2A31",
  "triangle;": "\u25B5",
  "triminus;": "\u2A3A",
  "trpezium;": "\u23E2",
  "Uarrocir;": "\u2949",
  "ulcorner;": "\u231C",
  "UnderBar;": "_",
  "urcorner;": "\u231D",
  "varkappa;": "\u03F0",
  "varsigma;": "\u03C2",
  "vartheta;": "\u03D1",
  "backprime;": "\u2035",
  "backsimeq;": "\u22CD",
  "Backslash;": "\u2216",
  "bigotimes;": "\u2A02",
  "CenterDot;": "\xB7",
  "centerdot;": "\xB7",
  "checkmark;": "\u2713",
  "CircleDot;": "\u2299",
  "complexes;": "\u2102",
  "Congruent;": "\u2261",
  "Coproduct;": "\u2210",
  "dotsquare;": "\u22A1",
  "DoubleDot;": "\xA8",
  "DownArrow;": "\u2193",
  "Downarrow;": "\u21D3",
  "downarrow;": "\u2193",
  "DownBreve;": "\u0311",
  "gtrapprox;": "\u2A86",
  "gtreqless;": "\u22DB",
  "gvertneqq;": "\u2269\uFE00",
  "heartsuit;": "\u2665",
  "HumpEqual;": "\u224F",
  "LeftArrow;": "\u2190",
  "Leftarrow;": "\u21D0",
  "leftarrow;": "\u2190",
  "LeftFloor;": "\u230A",
  "lesseqgtr;": "\u22DA",
  "LessTilde;": "\u2272",
  "lvertneqq;": "\u2268\uFE00",
  "Mellintrf;": "\u2133",
  "MinusPlus;": "\u2213",
  "ngeqslant;": "\u2A7E\u0338",
  "nleqslant;": "\u2A7D\u0338",
  "NotCupCap;": "\u226D",
  "NotExists;": "\u2204",
  "NotSubset;": "\u2282\u20D2",
  "nparallel;": "\u2226",
  "nshortmid;": "\u2224",
  "nsubseteq;": "\u2288",
  "nsupseteq;": "\u2289",
  "OverBrace;": "\u23DE",
  "pitchfork;": "\u22D4",
  "PlusMinus;": "\xB1",
  "rationals;": "\u211A",
  "spadesuit;": "\u2660",
  "subseteqq;": "\u2AC5",
  "subsetneq;": "\u228A",
  "supseteqq;": "\u2AC6",
  "supsetneq;": "\u228B",
  "Therefore;": "\u2234",
  "therefore;": "\u2234",
  "ThinSpace;": "\u2009",
  "triangleq;": "\u225C",
  "TripleDot;": "\u20DB",
  "UnionPlus;": "\u228E",
  "varpropto;": "\u221D",
  "Bernoullis;": "\u212C",
  "circledast;": "\u229B",
  "CirclePlus;": "\u2295",
  "complement;": "\u2201",
  "curlywedge;": "\u22CF",
  "eqslantgtr;": "\u2A96",
  "EqualTilde;": "\u2242",
  "Fouriertrf;": "\u2131",
  "gtreqqless;": "\u2A8C",
  "ImaginaryI;": "\u2148",
  "Laplacetrf;": "\u2112",
  "LeftVector;": "\u21BC",
  "lessapprox;": "\u2A85",
  "lesseqqgtr;": "\u2A8B",
  "Lleftarrow;": "\u21DA",
  "lmoustache;": "\u23B0",
  "longmapsto;": "\u27FC",
  "mapstodown;": "\u21A7",
  "mapstoleft;": "\u21A4",
  "nLeftarrow;": "\u21CD",
  "nleftarrow;": "\u219A",
  "NotElement;": "\u2209",
  "NotGreater;": "\u226F",
  "nsubseteqq;": "\u2AC5\u0338",
  "nsupseteqq;": "\u2AC6\u0338",
  "precapprox;": "\u2AB7",
  "Proportion;": "\u2237",
  "RightArrow;": "\u2192",
  "Rightarrow;": "\u21D2",
  "rightarrow;": "\u2192",
  "RightFloor;": "\u230B",
  "rmoustache;": "\u23B1",
  "sqsubseteq;": "\u2291",
  "sqsupseteq;": "\u2292",
  "subsetneqq;": "\u2ACB",
  "succapprox;": "\u2AB8",
  "supsetneqq;": "\u2ACC",
  "ThickSpace;": "\u205F\u200A",
  "TildeEqual;": "\u2243",
  "TildeTilde;": "\u2248",
  "UnderBrace;": "\u23DF",
  "UpArrowBar;": "\u2912",
  "UpTeeArrow;": "\u21A5",
  "upuparrows;": "\u21C8",
  "varepsilon;": "\u03F5",
  "varnothing;": "\u2205",
  "backepsilon;": "\u03F6",
  "blacksquare;": "\u25AA",
  "circledcirc;": "\u229A",
  "circleddash;": "\u229D",
  "CircleMinus;": "\u2296",
  "CircleTimes;": "\u2297",
  "curlyeqprec;": "\u22DE",
  "curlyeqsucc;": "\u22DF",
  "diamondsuit;": "\u2666",
  "eqslantless;": "\u2A95",
  "Equilibrium;": "\u21CC",
  "expectation;": "\u2130",
  "GreaterLess;": "\u2277",
  "LeftCeiling;": "\u2308",
  "LessGreater;": "\u2276",
  "MediumSpace;": "\u205F",
  "NotLessLess;": "\u226A\u0338",
  "NotPrecedes;": "\u2280",
  "NotSucceeds;": "\u2281",
  "NotSuperset;": "\u2283\u20D2",
  "nRightarrow;": "\u21CF",
  "nrightarrow;": "\u219B",
  "OverBracket;": "\u23B4",
  "preccurlyeq;": "\u227C",
  "precnapprox;": "\u2AB9",
  "quaternions;": "\u210D",
  "RightVector;": "\u21C0",
  "Rrightarrow;": "\u21DB",
  "RuleDelayed;": "\u29F4",
  "SmallCircle;": "\u2218",
  "SquareUnion;": "\u2294",
  "straightphi;": "\u03D5",
  "SubsetEqual;": "\u2286",
  "succcurlyeq;": "\u227D",
  "succnapprox;": "\u2ABA",
  "thickapprox;": "\u2248",
  "UpDownArrow;": "\u2195",
  "Updownarrow;": "\u21D5",
  "updownarrow;": "\u2195",
  "VerticalBar;": "\u2223",
  "blacklozenge;": "\u29EB",
  "DownArrowBar;": "\u2913",
  "DownTeeArrow;": "\u21A7",
  "ExponentialE;": "\u2147",
  "exponentiale;": "\u2147",
  "GreaterEqual;": "\u2265",
  "GreaterTilde;": "\u2273",
  "HilbertSpace;": "\u210B",
  "HumpDownHump;": "\u224E",
  "Intersection;": "\u22C2",
  "LeftArrowBar;": "\u21E4",
  "LeftTeeArrow;": "\u21A4",
  "LeftTriangle;": "\u22B2",
  "LeftUpVector;": "\u21BF",
  "NotCongruent;": "\u2262",
  "NotHumpEqual;": "\u224F\u0338",
  "NotLessEqual;": "\u2270",
  "NotLessTilde;": "\u2274",
  "Proportional;": "\u221D",
  "RightCeiling;": "\u2309",
  "risingdotseq;": "\u2253",
  "RoundImplies;": "\u2970",
  "ShortUpArrow;": "\u2191",
  "SquareSubset;": "\u228F",
  "triangledown;": "\u25BF",
  "triangleleft;": "\u25C3",
  "UnderBracket;": "\u23B5",
  "varsubsetneq;": "\u228A\uFE00",
  "varsupsetneq;": "\u228B\uFE00",
  "VerticalLine;": "|",
  "ApplyFunction;": "\u2061",
  "bigtriangleup;": "\u25B3",
  "blacktriangle;": "\u25B4",
  "DifferentialD;": "\u2146",
  "divideontimes;": "\u22C7",
  "DoubleLeftTee;": "\u2AE4",
  "DoubleUpArrow;": "\u21D1",
  "fallingdotseq;": "\u2252",
  "hookleftarrow;": "\u21A9",
  "leftarrowtail;": "\u21A2",
  "leftharpoonup;": "\u21BC",
  "LeftTeeVector;": "\u295A",
  "LeftVectorBar;": "\u2952",
  "LessFullEqual;": "\u2266",
  "LongLeftArrow;": "\u27F5",
  "Longleftarrow;": "\u27F8",
  "longleftarrow;": "\u27F5",
  "looparrowleft;": "\u21AB",
  "measuredangle;": "\u2221",
  "NotEqualTilde;": "\u2242\u0338",
  "NotTildeEqual;": "\u2244",
  "NotTildeTilde;": "\u2249",
  "ntriangleleft;": "\u22EA",
  "Poincareplane;": "\u210C",
  "PrecedesEqual;": "\u2AAF",
  "PrecedesTilde;": "\u227E",
  "RightArrowBar;": "\u21E5",
  "RightTeeArrow;": "\u21A6",
  "RightTriangle;": "\u22B3",
  "RightUpVector;": "\u21BE",
  "shortparallel;": "\u2225",
  "smallsetminus;": "\u2216",
  "SucceedsEqual;": "\u2AB0",
  "SucceedsTilde;": "\u227F",
  "SupersetEqual;": "\u2287",
  "triangleright;": "\u25B9",
  "UpEquilibrium;": "\u296E",
  "upharpoonleft;": "\u21BF",
  "varsubsetneqq;": "\u2ACB\uFE00",
  "varsupsetneqq;": "\u2ACC\uFE00",
  "VerticalTilde;": "\u2240",
  "VeryThinSpace;": "\u200A",
  "curvearrowleft;": "\u21B6",
  "DiacriticalDot;": "\u02D9",
  "doublebarwedge;": "\u2306",
  "DoubleRightTee;": "\u22A8",
  "downdownarrows;": "\u21CA",
  "DownLeftVector;": "\u21BD",
  "GreaterGreater;": "\u2AA2",
  "hookrightarrow;": "\u21AA",
  "HorizontalLine;": "\u2500",
  "InvisibleComma;": "\u2063",
  "InvisibleTimes;": "\u2062",
  "LeftDownVector;": "\u21C3",
  "leftleftarrows;": "\u21C7",
  "LeftRightArrow;": "\u2194",
  "Leftrightarrow;": "\u21D4",
  "leftrightarrow;": "\u2194",
  "leftthreetimes;": "\u22CB",
  "LessSlantEqual;": "\u2A7D",
  "LongRightArrow;": "\u27F6",
  "Longrightarrow;": "\u27F9",
  "longrightarrow;": "\u27F6",
  "looparrowright;": "\u21AC",
  "LowerLeftArrow;": "\u2199",
  "NestedLessLess;": "\u226A",
  "NotGreaterLess;": "\u2279",
  "NotLessGreater;": "\u2278",
  "NotSubsetEqual;": "\u2288",
  "NotVerticalBar;": "\u2224",
  "nshortparallel;": "\u2226",
  "ntriangleright;": "\u22EB",
  "OpenCurlyQuote;": "\u2018",
  "ReverseElement;": "\u220B",
  "rightarrowtail;": "\u21A3",
  "rightharpoonup;": "\u21C0",
  "RightTeeVector;": "\u295B",
  "RightVectorBar;": "\u2953",
  "ShortDownArrow;": "\u2193",
  "ShortLeftArrow;": "\u2190",
  "SquareSuperset;": "\u2290",
  "TildeFullEqual;": "\u2245",
  "trianglelefteq;": "\u22B4",
  "upharpoonright;": "\u21BE",
  "UpperLeftArrow;": "\u2196",
  "ZeroWidthSpace;": "\u200B",
  "bigtriangledown;": "\u25BD",
  "circlearrowleft;": "\u21BA",
  "CloseCurlyQuote;": "\u2019",
  "ContourIntegral;": "\u222E",
  "curvearrowright;": "\u21B7",
  "DoubleDownArrow;": "\u21D3",
  "DoubleLeftArrow;": "\u21D0",
  "downharpoonleft;": "\u21C3",
  "DownRightVector;": "\u21C1",
  "leftharpoondown;": "\u21BD",
  "leftrightarrows;": "\u21C6",
  "LeftRightVector;": "\u294E",
  "LeftTriangleBar;": "\u29CF",
  "LeftUpTeeVector;": "\u2960",
  "LeftUpVectorBar;": "\u2958",
  "LowerRightArrow;": "\u2198",
  "nLeftrightarrow;": "\u21CE",
  "nleftrightarrow;": "\u21AE",
  "NotGreaterEqual;": "\u2271",
  "NotGreaterTilde;": "\u2275",
  "NotHumpDownHump;": "\u224E\u0338",
  "NotLeftTriangle;": "\u22EA",
  "NotSquareSubset;": "\u228F\u0338",
  "ntrianglelefteq;": "\u22EC",
  "OverParenthesis;": "\u23DC",
  "RightDownVector;": "\u21C2",
  "rightleftarrows;": "\u21C4",
  "rightsquigarrow;": "\u219D",
  "rightthreetimes;": "\u22CC",
  "ShortRightArrow;": "\u2192",
  "straightepsilon;": "\u03F5",
  "trianglerighteq;": "\u22B5",
  "UpperRightArrow;": "\u2197",
  "vartriangleleft;": "\u22B2",
  "circlearrowright;": "\u21BB",
  "DiacriticalAcute;": "\xB4",
  "DiacriticalGrave;": "`",
  "DiacriticalTilde;": "\u02DC",
  "DoubleRightArrow;": "\u21D2",
  "DownArrowUpArrow;": "\u21F5",
  "downharpoonright;": "\u21C2",
  "EmptySmallSquare;": "\u25FB",
  "GreaterEqualLess;": "\u22DB",
  "GreaterFullEqual;": "\u2267",
  "LeftAngleBracket;": "\u27E8",
  "LeftUpDownVector;": "\u2951",
  "LessEqualGreater;": "\u22DA",
  "NonBreakingSpace;": "\xA0",
  "NotPrecedesEqual;": "\u2AAF\u0338",
  "NotRightTriangle;": "\u22EB",
  "NotSucceedsEqual;": "\u2AB0\u0338",
  "NotSucceedsTilde;": "\u227F\u0338",
  "NotSupersetEqual;": "\u2289",
  "ntrianglerighteq;": "\u22ED",
  "rightharpoondown;": "\u21C1",
  "rightrightarrows;": "\u21C9",
  "RightTriangleBar;": "\u29D0",
  "RightUpTeeVector;": "\u295C",
  "RightUpVectorBar;": "\u2954",
  "twoheadleftarrow;": "\u219E",
  "UnderParenthesis;": "\u23DD",
  "UpArrowDownArrow;": "\u21C5",
  "vartriangleright;": "\u22B3",
  "blacktriangledown;": "\u25BE",
  "blacktriangleleft;": "\u25C2",
  "DoubleUpDownArrow;": "\u21D5",
  "DoubleVerticalBar;": "\u2225",
  "DownLeftTeeVector;": "\u295E",
  "DownLeftVectorBar;": "\u2956",
  "FilledSmallSquare;": "\u25FC",
  "GreaterSlantEqual;": "\u2A7E",
  "LeftDoubleBracket;": "\u27E6",
  "LeftDownTeeVector;": "\u2961",
  "LeftDownVectorBar;": "\u2959",
  "leftrightharpoons;": "\u21CB",
  "LeftTriangleEqual;": "\u22B4",
  "NegativeThinSpace;": "\u200B",
  "NotGreaterGreater;": "\u226B\u0338",
  "NotLessSlantEqual;": "\u2A7D\u0338",
  "NotNestedLessLess;": "\u2AA1\u0338",
  "NotReverseElement;": "\u220C",
  "NotSquareSuperset;": "\u2290\u0338",
  "NotTildeFullEqual;": "\u2247",
  "RightAngleBracket;": "\u27E9",
  "rightleftharpoons;": "\u21CC",
  "RightUpDownVector;": "\u294F",
  "SquareSubsetEqual;": "\u2291",
  "twoheadrightarrow;": "\u21A0",
  "VerticalSeparator;": "\u2758",
  "blacktriangleright;": "\u25B8",
  "DownRightTeeVector;": "\u295F",
  "DownRightVectorBar;": "\u2957",
  "LongLeftRightArrow;": "\u27F7",
  "Longleftrightarrow;": "\u27FA",
  "longleftrightarrow;": "\u27F7",
  "NegativeThickSpace;": "\u200B",
  "NotLeftTriangleBar;": "\u29CF\u0338",
  "PrecedesSlantEqual;": "\u227C",
  "ReverseEquilibrium;": "\u21CB",
  "RightDoubleBracket;": "\u27E7",
  "RightDownTeeVector;": "\u295D",
  "RightDownVectorBar;": "\u2955",
  "RightTriangleEqual;": "\u22B5",
  "SquareIntersection;": "\u2293",
  "SucceedsSlantEqual;": "\u227D",
  "DoubleLongLeftArrow;": "\u27F8",
  "DownLeftRightVector;": "\u2950",
  "LeftArrowRightArrow;": "\u21C6",
  "leftrightsquigarrow;": "\u21AD",
  "NegativeMediumSpace;": "\u200B",
  "NotGreaterFullEqual;": "\u2267\u0338",
  "NotRightTriangleBar;": "\u29D0\u0338",
  "RightArrowLeftArrow;": "\u21C4",
  "SquareSupersetEqual;": "\u2292",
  "CapitalDifferentialD;": "\u2145",
  "DoubleLeftRightArrow;": "\u21D4",
  "DoubleLongRightArrow;": "\u27F9",
  "EmptyVerySmallSquare;": "\u25AB",
  "NestedGreaterGreater;": "\u226B",
  "NotDoubleVerticalBar;": "\u2226",
  "NotGreaterSlantEqual;": "\u2A7E\u0338",
  "NotLeftTriangleEqual;": "\u22EC",
  "NotSquareSubsetEqual;": "\u22E2",
  "OpenCurlyDoubleQuote;": "\u201C",
  "ReverseUpEquilibrium;": "\u296F",
  "CloseCurlyDoubleQuote;": "\u201D",
  "DoubleContourIntegral;": "\u222F",
  "FilledVerySmallSquare;": "\u25AA",
  "NegativeVeryThinSpace;": "\u200B",
  "NotPrecedesSlantEqual;": "\u22E0",
  "NotRightTriangleEqual;": "\u22ED",
  "NotSucceedsSlantEqual;": "\u22E1",
  "DiacriticalDoubleAcute;": "\u02DD",
  "NotSquareSupersetEqual;": "\u22E3",
  "NotNestedGreaterGreater;": "\u2AA2\u0338",
  "ClockwiseContourIntegral;": "\u2232",
  "DoubleLongLeftRightArrow;": "\u27FA",
  "CounterClockwiseContourIntegral;": "\u2233"
};
var maxCRNameLength;
var decodeHtml = (rawText, asAttr) => {
  let offset = 0;
  const end = rawText.length;
  let decodedText = "";
  function advance(length) {
    offset += length;
    rawText = rawText.slice(length);
  }
  while (offset < end) {
    const head = /&(?:#x?)?/i.exec(rawText);
    if (!head || offset + head.index >= end) {
      const remaining = end - offset;
      decodedText += rawText.slice(0, remaining);
      advance(remaining);
      break;
    }
    decodedText += rawText.slice(0, head.index);
    advance(head.index);
    if (head[0] === "&") {
      let name3 = "";
      let value = undefined;
      if (/[0-9a-z]/i.test(rawText[1])) {
        if (!maxCRNameLength) {
          maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name22) => Math.max(max, name22.length), 0);
        }
        for (let length = maxCRNameLength;!value && length > 0; --length) {
          name3 = rawText.slice(1, 1 + length);
          value = namedCharacterReferences[name3];
        }
        if (value) {
          const semi = name3.endsWith(";");
          if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name3.length + 1] || "")) {
            decodedText += "&" + name3;
            advance(1 + name3.length);
          } else {
            decodedText += value;
            advance(1 + name3.length);
          }
        } else {
          decodedText += "&" + name3;
          advance(1 + name3.length);
        }
      } else {
        decodedText += "&";
        advance(1);
      }
    } else {
      const hex = head[0] === "&#x";
      const pattern2 = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
      const body = pattern2.exec(rawText);
      if (!body) {
        decodedText += head[0];
        advance(head[0].length);
      } else {
        let cp2 = Number.parseInt(body[1], hex ? 16 : 10);
        if (cp2 === 0) {
          cp2 = 65533;
        } else if (cp2 > 1114111) {
          cp2 = 65533;
        } else if (cp2 >= 55296 && cp2 <= 57343) {
          cp2 = 65533;
        } else if (cp2 >= 64976 && cp2 <= 65007 || (cp2 & 65534) === 65534)
          ;
        else if (cp2 >= 1 && cp2 <= 8 || cp2 === 11 || cp2 >= 13 && cp2 <= 31 || cp2 >= 127 && cp2 <= 159) {
          cp2 = CCR_REPLACEMENTS[cp2] || cp2;
        }
        decodedText += String.fromCodePoint(cp2);
        advance(body[0].length);
      }
    }
  }
  return decodedText;
};
var CCR_REPLACEMENTS = {
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};
var isRawTextContainer = /* @__PURE__ */ makeMap$1("style,iframe,script,noscript", true);
var parserOptions = {
  isVoidTag: isVoidTag$1,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag$1(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtml,
  isBuiltInComponent: (tag) => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : 0;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  },
  getTextMode({ tag, ns }) {
    if (ns === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
var transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p2, i) => {
      if (p2.type === 6 && p2.name === "style" && p2.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p2.loc),
          exp: parseInlineCSS(p2.value.content, p2.loc),
          modifiers: [],
          loc: p2.loc
        };
      }
    });
  }
};
var parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle$1(cssText);
  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
};
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc, DOMErrorMessages);
}
var DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};
var transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(53, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(54, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
    ]
  };
};
var transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(55, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(56, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
    ]
  };
};
var transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(createDOMCompilerError(58, dir.arg.loc));
  }
  function checkDuplicatedValue() {
    const value = findProp(node, "value");
    if (value) {
      context.onError(createDOMCompilerError(60, value.loc));
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(createDOMCompilerError(59, dir.loc));
              break;
            default:
              checkDuplicatedValue();
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        checkDuplicatedValue();
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
      checkDuplicatedValue();
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(57, dir.loc));
  }
  baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
  return baseResult;
};
var isEventOptionModifier = /* @__PURE__ */ makeMap$1(`passive,once,capture`);
var isNonKeyModifier = /* @__PURE__ */ makeMap$1(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
var maybeKeyModifier = /* @__PURE__ */ makeMap$1("left,right");
var isKeyboardEvent = /* @__PURE__ */ makeMap$1(`onkeyup,onkeydown,onkeypress`, true);
var resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0;i < modifiers.length; i++) {
    const modifier = modifiers[i];
    if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
var transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
var transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize$1).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
var transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(61, loc));
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
var transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(createDOMCompilerError(62, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p2 of child.props) {
            if (p2.type === 7 && p2.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                value: undefined,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter((c3) => c3.type !== 3 && !(c3.type === 2 && !c3.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
var stringifyStatic = (children, context, parent) => {
  if (context.scopes.vSlot > 0) {
    return;
  }
  let nc2 = 0;
  let ec2 = 0;
  const currentChunk = [];
  const stringifyCurrentChunk = (currentIndex) => {
    if (nc2 >= 20 || ec2 >= 5) {
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(currentChunk.map((node) => stringifyNode(node, context)).join("")).replace(expReplaceRE, `" + $1 + "`),
        String(currentChunk.length)
      ]);
      replaceHoist(currentChunk[0], staticCall, context);
      if (currentChunk.length > 1) {
        for (let i2 = 1;i2 < currentChunk.length; i2++) {
          replaceHoist(currentChunk[i2], null, context);
        }
        const deleteCount = currentChunk.length - 1;
        children.splice(currentIndex - currentChunk.length + 1, deleteCount);
        return deleteCount;
      }
    }
    return 0;
  };
  let i = 0;
  for (;i < children.length; i++) {
    const child = children[i];
    const hoisted = getHoistedNode(child);
    if (hoisted) {
      const node = child;
      const result = analyzeNode(node);
      if (result) {
        nc2 += result[0];
        ec2 += result[1];
        currentChunk.push(node);
        continue;
      }
    }
    i -= stringifyCurrentChunk(i);
    nc2 = 0;
    ec2 = 0;
    currentChunk.length = 0;
  }
  stringifyCurrentChunk(i);
};
var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
var dataAriaRE = /^(data|aria)-/;
var isStringifiableAttr = (name3, ns) => {
  return (ns === 0 ? isKnownHtmlAttr(name3) : ns === 1 ? isKnownSvgAttr(name3) : false) || dataAriaRE.test(name3);
};
var replaceHoist = (node, replacement, context) => {
  const hoistToReplace = node.codegenNode.hoisted;
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
};
var isNonStringifiable = /* @__PURE__ */ makeMap$1(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
function analyzeNode(node) {
  if (node.type === 1 && isNonStringifiable(node.tag)) {
    return false;
  }
  if (node.type === 12) {
    return [1, 0];
  }
  let nc2 = 1;
  let ec2 = node.props.length > 0 ? 1 : 0;
  let bailed = false;
  const bail = () => {
    bailed = true;
    return false;
  };
  function walk(node2) {
    for (let i = 0;i < node2.props.length; i++) {
      const p2 = node2.props[i];
      if (p2.type === 6 && !isStringifiableAttr(p2.name, node2.ns)) {
        return bail();
      }
      if (p2.type === 7 && p2.name === "bind") {
        if (p2.arg && (p2.arg.type === 8 || p2.arg.isStatic && !isStringifiableAttr(p2.arg.content, node2.ns))) {
          return bail();
        }
        if (p2.exp && (p2.exp.type === 8 || p2.exp.constType < 3)) {
          return bail();
        }
      }
    }
    for (let i = 0;i < node2.children.length; i++) {
      nc2++;
      const child = node2.children[i];
      if (child.type === 1) {
        if (child.props.length > 0) {
          ec2++;
        }
        walk(child);
        if (bailed) {
          return false;
        }
      }
    }
    return true;
  }
  return walk(node) ? [nc2, ec2] : false;
}
function stringifyNode(node, context) {
  if (isString$2(node)) {
    return node;
  }
  if (isSymbol$1(node)) {
    return ``;
  }
  switch (node.type) {
    case 1:
      return stringifyElement(node, context);
    case 2:
      return escapeHtml$2(node.content);
    case 3:
      return `<!--${escapeHtml$2(node.content)}-->`;
    case 5:
      return escapeHtml$2(toDisplayString$1(evaluateConstant(node.content)));
    case 8:
      return escapeHtml$2(evaluateConstant(node));
    case 12:
      return stringifyNode(node.content, context);
    default:
      return "";
  }
}
function stringifyElement(node, context) {
  let res = `<${node.tag}`;
  let innerHTML = "";
  for (let i = 0;i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      res += ` ${p2.name}`;
      if (p2.value) {
        res += `="${escapeHtml$2(p2.value.content)}"`;
      }
    } else if (p2.type === 7) {
      if (p2.name === "bind") {
        const exp = p2.exp;
        if (exp.content[0] === "_") {
          res += ` ${p2.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
          continue;
        }
        if (isBooleanAttr$1(p2.arg.content) && exp.content === "false") {
          continue;
        }
        let evaluated = evaluateConstant(exp);
        if (evaluated != null) {
          const arg = p2.arg && p2.arg.content;
          if (arg === "class") {
            evaluated = normalizeClass$1(evaluated);
          } else if (arg === "style") {
            evaluated = stringifyStyle$1(normalizeStyle$1(evaluated));
          }
          res += ` ${p2.arg.content}="${escapeHtml$2(evaluated)}"`;
        }
      } else if (p2.name === "html") {
        innerHTML = evaluateConstant(p2.exp);
      } else if (p2.name === "text") {
        innerHTML = escapeHtml$2(toDisplayString$1(evaluateConstant(p2.exp)));
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`;
  }
  res += `>`;
  if (innerHTML) {
    res += innerHTML;
  } else {
    for (let i = 0;i < node.children.length; i++) {
      res += stringifyNode(node.children[i], context);
    }
  }
  if (!isVoidTag$1(node.tag)) {
    res += `</${node.tag}>`;
  }
  return res;
}
function evaluateConstant(exp) {
  if (exp.type === 4) {
    return new Function(`return (${exp.content})`)();
  } else {
    let res = ``;
    exp.children.forEach((c3) => {
      if (isString$2(c3) || isSymbol$1(c3)) {
        return;
      }
      if (c3.type === 2) {
        res += c3.content;
      } else if (c3.type === 5) {
        res += toDisplayString$1(evaluateConstant(c3.content));
      } else {
        res += evaluateConstant(c3);
      }
    });
    return res;
  }
}
var ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.onError(createDOMCompilerError(63, node.loc));
    context.removeNode();
  }
};
var DOMNodeTransforms = [
  transformStyle,
  ...[transformTransition]
];
var DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};
function compile$1$1(template, options3 = {}) {
  return baseCompile$2(template, extend({}, parserOptions, options3, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options3.nodeTransforms || []
    ],
    directiveTransforms: extend({}, DOMDirectiveTransforms, options3.directiveTransforms || {}),
    transformHoist: stringifyStatic
  }));
}
function parse$8(template, options3 = {}) {
  return baseParse(template, extend({}, parserOptions, options3));
}
var CompilerDOM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BASE_TRANSITION,
  CAMELIZE,
  CAPITALIZE,
  CREATE_BLOCK,
  CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE,
  CREATE_SLOTS,
  CREATE_STATIC,
  CREATE_TEXT,
  CREATE_VNODE,
  DOMDirectiveTransforms,
  DOMNodeTransforms,
  FRAGMENT,
  GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME,
  IS_REF,
  KEEP_ALIVE,
  MERGE_PROPS,
  NORMALIZE_CLASS,
  NORMALIZE_PROPS,
  NORMALIZE_STYLE,
  OPEN_BLOCK,
  POP_SCOPE_ID,
  PUSH_SCOPE_ID,
  RENDER_LIST,
  RENDER_SLOT,
  RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER,
  SET_BLOCK_TRACKING,
  SUSPENSE,
  TELEPORT,
  TO_DISPLAY_STRING,
  TO_HANDLERS,
  TO_HANDLER_KEY,
  TRANSITION,
  TRANSITION_GROUP,
  TS_NODE_TYPES,
  UNREF,
  V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC,
  V_MODEL_RADIO,
  V_MODEL_SELECT,
  V_MODEL_TEXT,
  V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS,
  V_SHOW,
  WITH_CTX,
  WITH_DIRECTIVES,
  WITH_MEMO,
  advancePositionWithClone,
  advancePositionWithMutation,
  assert,
  baseCompile: baseCompile$2,
  baseParse,
  buildDirectiveArgs,
  buildProps,
  buildSlots,
  checkCompatEnabled,
  compile: compile$1$1,
  convertToBlock,
  createArrayExpression,
  createAssignmentExpression,
  createBlockStatement,
  createCacheExpression,
  createCallExpression,
  createCompilerError,
  createCompoundExpression,
  createConditionalExpression,
  createDOMCompilerError,
  createForLoopParams,
  createFunctionExpression,
  createIfStatement,
  createInterpolation,
  createObjectExpression,
  createObjectProperty,
  createReturnStatement,
  createRoot,
  createSequenceExpression,
  createSimpleExpression,
  createStructuralDirectiveTransform,
  createTemplateLiteral,
  createTransformContext,
  createVNodeCall,
  extractIdentifiers,
  findDir,
  findProp,
  generate: generate$1,
  generateCodeFrame: generateCodeFrame$1,
  getBaseTransformPreset,
  getConstantType,
  getInnerRange,
  getMemoedVNodeCall,
  getVNodeBlockHelper,
  getVNodeHelper,
  hasDynamicKeyVBind,
  hasScopeRef,
  helperNameMap,
  injectProp,
  isBuiltInType,
  isCoreComponent,
  isFunctionType,
  isInDestructureAssignment,
  isMemberExpression,
  isMemberExpressionBrowser,
  isMemberExpressionNode,
  isReferencedIdentifier,
  isSimpleIdentifier,
  isSlotOutlet,
  isStaticArgOf,
  isStaticExp,
  isStaticProperty,
  isStaticPropertyKey,
  isTemplateNode,
  isText: isText$1,
  isVSlot,
  locStub,
  noopDirectiveTransform,
  parse: parse$8,
  parserOptions,
  processExpression,
  processFor,
  processIf,
  processSlotOutlet,
  registerRuntimeHelpers,
  resolveComponentType,
  stringifyExpression,
  toValidAssetId,
  trackSlotScopes,
  trackVForSlotScopes,
  transform: transform$1,
  transformBind,
  transformElement,
  transformExpression,
  transformModel: transformModel$1,
  transformOn: transformOn$1,
  transformStyle,
  traverseNode: traverseNode$1,
  walkBlockDeclarations,
  walkFunctionParams,
  walkIdentifiers,
  warnDeprecation
});
function normalizeArray(parts, allowAboveRoot) {
  var up2 = 0;
  for (var i = parts.length - 1;i >= 0; i--) {
    var last2 = parts[i];
    if (last2 === ".") {
      parts.splice(i, 1);
    } else if (last2 === "..") {
      parts.splice(i, 1);
      up2++;
    } else if (up2) {
      parts.splice(i, 1);
      up2--;
    }
  }
  if (allowAboveRoot) {
    for (;up2--; up2) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve$2() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    var path2 = i >= 0 ? arguments[i] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p2) {
    return !!p2;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize$1(path2) {
  var isPathAbsolute = isAbsolute$1(path2), trailingSlash = substr(path2, -1) === "/";
  path2 = normalizeArray(filter(path2.split("/"), function(p2) {
    return !!p2;
  }), !isPathAbsolute).join("/");
  if (!path2 && !isPathAbsolute) {
    path2 = ".";
  }
  if (path2 && trailingSlash) {
    path2 += "/";
  }
  return (isPathAbsolute ? "/" : "") + path2;
}
function isAbsolute$1(path2) {
  return path2.charAt(0) === "/";
}
function join$1() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize$1(filter(paths, function(p2, index) {
    if (typeof p2 !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p2;
  }).join("/"));
}
function relative$1(from, to) {
  from = resolve$2(from).substr(1);
  to = resolve$2(to).substr(1);
  function trim(arr) {
    var start = 0;
    for (;start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (;end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0;i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  var outputParts = [];
  for (var i = samePartsLength;i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep$1 = "/";
var delimiter$1 = ":";
function dirname$2(path2) {
  var result = splitPath(path2), root = result[0], dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
}
function basename(path2, ext) {
  var f = splitPath(path2)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}
function extname(path2) {
  return splitPath(path2)[3];
}
var path2 = {
  extname,
  basename,
  dirname: dirname$2,
  sep: sep$1,
  delimiter: delimiter$1,
  relative: relative$1,
  join: join$1,
  isAbsolute: isAbsolute$1,
  normalize: normalize$1,
  resolve: resolve$2
};
function filter(xs2, f) {
  if (xs2.filter)
    return xs2.filter(f);
  var res = [];
  for (var i = 0;i < xs2.length; i++) {
    if (f(xs2[i], i, xs2))
      res.push(xs2[i]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
  return str.substr(start, len);
} : function(str, start, len) {
  if (start < 0)
    start = str.length + start;
  return str.substr(start, len);
};
var _polyfillNode_path = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename,
  default: path2,
  delimiter: delimiter$1,
  dirname: dirname$2,
  extname,
  isAbsolute: isAbsolute$1,
  join: join$1,
  normalize: normalize$1,
  relative: relative$1,
  resolve: resolve$2,
  sep: sep$1
});
var UNKNOWN_TYPE = "Unknown";
function resolveObjectKey(node, computed3) {
  switch (node.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(node.value);
    case "Identifier":
      if (!computed3)
        return node.name;
  }
  return;
}
function concatStrings(strs) {
  return strs.filter((s2) => !!s2).join(", ");
}
function isLiteralNode(node) {
  return node.type.endsWith("Literal");
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCallOf(node, test) {
  return !!(node && test && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function toRuntimeTypeString(types4) {
  return types4.length > 1 ? `[${types4.join(", ")}]` : types4[0];
}
function getImportedName(specifier) {
  if (specifier.type === "ImportSpecifier")
    return specifier.imported.type === "Identifier" ? specifier.imported.name : specifier.imported.value;
  else if (specifier.type === "ImportNamespaceSpecifier")
    return "*";
  return "default";
}
function getId(node) {
  return node.type === "Identifier" ? node.name : node.type === "StringLiteral" ? node.value : null;
}
var normalize2 = (path2.posix || path2).normalize;
var windowsSlashRE = /\\/g;
function normalizePath(p2) {
  return normalize2(p2.replace(windowsSlashRE, "/"));
}
var joinPaths = (path2.posix || path2).join;
var escapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedKey(key) {
  return escapeSymbolsRE.test(key) ? JSON.stringify(key) : key;
}
function pad$1(hash, len) {
  while (hash.length < len) {
    hash = "0" + hash;
  }
  return hash;
}
function fold(hash, text) {
  var i;
  var chr;
  var len;
  if (text.length === 0) {
    return hash;
  }
  for (i = 0, len = text.length;i < len; i++) {
    chr = text.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash < 0 ? hash * -2 : hash;
}
function foldObject(hash, o2, seen2) {
  return Object.keys(o2).sort().reduce(foldKey, hash);
  function foldKey(hash2, key) {
    return foldValue(hash2, o2[key], key, seen2);
  }
}
function foldValue(input, value, key, seen2) {
  var hash = fold(fold(fold(input, key), toString$2(value)), typeof value);
  if (value === null) {
    return fold(hash, "null");
  }
  if (value === undefined) {
    return fold(hash, "undefined");
  }
  if (typeof value === "object" || typeof value === "function") {
    if (seen2.indexOf(value) !== -1) {
      return fold(hash, "[Circular]" + key);
    }
    seen2.push(value);
    var objHash = foldObject(hash, value, seen2);
    if (!("valueOf" in value) || typeof value.valueOf !== "function") {
      return objHash;
    }
    try {
      return fold(objHash, String(value.valueOf()));
    } catch (err) {
      return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
    }
  }
  return fold(hash, value.toString());
}
function toString$2(o2) {
  return Object.prototype.toString.call(o2);
}
function sum(o2) {
  return pad$1(foldValue(0, o2, "", []).toString(16), 8);
}
var hashSum = sum;
var hash = /* @__PURE__ */ getDefaultExportFromCjs2(hashSum);
var CSS_VARS_HELPER = `useCssVars`;
function genCssVarsFromList(vars, id, isProd, isSSR = false) {
  return `{
  ${vars.map((key) => `"${isSSR ? `--` : ``}${genVarName(id, key, isProd)}": (${key})`).join(`,
  `)}
}`;
}
function genVarName(id, raw, isProd) {
  if (isProd) {
    return hash(id + raw);
  } else {
    return `${id}-${raw.replace(escapeSymbolsRE, (s2) => `\\${s2}`)}`;
  }
}
function normalizeExpression(exp) {
  exp = exp.trim();
  if (exp[0] === `'` && exp[exp.length - 1] === `'` || exp[0] === `"` && exp[exp.length - 1] === `"`) {
    return exp.slice(1, -1);
  }
  return exp;
}
var vBindRE = /v-bind\s*\(/g;
function parseCssVars(sfc) {
  const vars = [];
  sfc.styles.forEach((style) => {
    let match;
    const content = style.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    while (match = vBindRE.exec(content)) {
      const start = match.index + match[0].length;
      const end = lexBinding(content, start);
      if (end !== null) {
        const variable = normalizeExpression(content.slice(start, end));
        if (!vars.includes(variable)) {
          vars.push(variable);
        }
      }
    }
  });
  return vars;
}
function lexBinding(content, start) {
  let state = 0;
  let parenDepth = 0;
  for (let i = start;i < content.length; i++) {
    const char = content.charAt(i);
    switch (state) {
      case 0:
        if (char === `'`) {
          state = 1;
        } else if (char === `"`) {
          state = 2;
        } else if (char === `(`) {
          parenDepth++;
        } else if (char === `)`) {
          if (parenDepth > 0) {
            parenDepth--;
          } else {
            return i;
          }
        }
        break;
      case 1:
        if (char === `'`) {
          state = 0;
        }
        break;
      case 2:
        if (char === `"`) {
          state = 0;
        }
        break;
    }
  }
  return null;
}
var cssVarsPlugin = (opts) => {
  const { id, isProd } = opts;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(decl) {
      const value = decl.value;
      if (vBindRE.test(value)) {
        vBindRE.lastIndex = 0;
        let transformed = "";
        let lastIndex = 0;
        let match;
        while (match = vBindRE.exec(value)) {
          const start = match.index + match[0].length;
          const end = lexBinding(value, start);
          if (end !== null) {
            const variable = normalizeExpression(value.slice(start, end));
            transformed += value.slice(lastIndex, match.index) + `var(--${genVarName(id, variable, isProd)})`;
            lastIndex = end + 1;
          }
        }
        decl.value = transformed + value.slice(lastIndex);
      }
    }
  };
};
cssVarsPlugin.postcss = true;
function genCssVarsCode(vars, bindings, id, isProd) {
  const varsExp = genCssVarsFromList(vars, id, isProd);
  const exp = createSimpleExpression(varsExp, false);
  const context = createTransformContext(createRoot([]), {
    prefixIdentifiers: true,
    inline: true,
    bindingMetadata: bindings.__isScriptSetup === false ? undefined : bindings
  });
  const transformed = processExpression(exp, context);
  const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c3) => {
    return typeof c3 === "string" ? c3 : c3.content;
  }).join("");
  return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
}
function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd, defaultVar) {
  return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(cssVars, bindings, id, isProd)}}
const __setup__ = ${defaultVar}.setup
${defaultVar}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1;i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version$1 = "";
var versions = {};
var release = {};
var config$1 = {};
function noop() {}
var on2 = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name3) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return new Date().getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 0.001;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date;
function uptime() {
  var currentTime = new Date;
  var dif = currentTime - startTime;
  return dif / 1000;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version: version$1,
  versions,
  on: on2,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config: config$1,
  uptime
};
function createCache(max = 500) {
  {
    return /* @__PURE__ */ new Map;
  }
}
function isImportUsed(local, sfc) {
  return new RegExp(`[^\\w$_]${local.replace(/\$/g, "\\$")}[^\\w$_]`).test(resolveTemplateUsageCheckString(sfc));
}
var templateUsageCheckCache = createCache();
function resolveTemplateUsageCheckString(sfc) {
  const { content, ast } = sfc.template;
  const cached = templateUsageCheckCache.get(content);
  if (cached) {
    return cached;
  }
  let code = "";
  transform$1(createRoot([ast]), {
    nodeTransforms: [
      (node) => {
        var _a3;
        if (node.type === 1) {
          if (!parserOptions.isNativeTag(node.tag) && !parserOptions.isBuiltInComponent(node.tag)) {
            code += `,${camelize(node.tag)},${capitalize$1(camelize(node.tag))}`;
          }
          for (let i = 0;i < node.props.length; i++) {
            const prop = node.props[i];
            if (prop.type === 7) {
              if (!isBuiltInDirective(prop.name)) {
                code += `,v${capitalize$1(camelize(prop.name))}`;
              }
              if (prop.arg && !prop.arg.isStatic) {
                code += `,${stripStrings(prop.arg.content)}`;
              }
              if (prop.exp) {
                code += `,${processExp(prop.exp.content, prop.name)}`;
              }
            }
            if (prop.type === 6 && prop.name === "ref" && ((_a3 = prop.value) == null ? undefined : _a3.content)) {
              code += `,${prop.value.content}`;
            }
          }
        } else if (node.type === 5) {
          code += `,${processExp(node.content.content)}`;
        }
      }
    ]
  });
  code += ";";
  templateUsageCheckCache.set(content, code);
  return code;
}
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
function processExp(exp, dir) {
  if (/ as\s+\w|<.*>|:/.test(exp)) {
    if (dir === "slot") {
      exp = `(${exp})=>{}`;
    } else if (dir === "on") {
      exp = `()=>{return ${exp}}`;
    } else if (dir === "for") {
      const inMatch = exp.match(forAliasRE);
      if (inMatch) {
        let [, LHS, RHS] = inMatch;
        LHS = LHS.trim().replace(/^\(|\)$/g, "");
        return processExp(`(${LHS})=>{}`) + processExp(RHS);
      }
    }
    let ret = "";
    const ast = parseExpression_1(exp, { plugins: ["typescript"] });
    walkIdentifiers(ast, (node) => {
      ret += `,` + node.name;
    });
    return ret;
  }
  return stripStrings(exp);
}
function stripStrings(exp) {
  return exp.replace(/'[^']*'|"[^"]*"/g, "").replace(/`[^`]+`/g, stripTemplateString);
}
function stripTemplateString(str) {
  const interpMatch = str.match(/\${[^}]+}/g);
  if (interpMatch) {
    return interpMatch.map((m2) => m2.slice(2, -1)).join(",");
  }
  return "";
}
var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => (key in obj) ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_FILENAME = "anonymous.vue";
var parseCache$1 = createCache();
function parse$7(source, {
  sourceMap = true,
  filename = DEFAULT_FILENAME,
  sourceRoot = "",
  pad = false,
  ignoreEmpty = true,
  compiler = CompilerDOM
} = {}) {
  const sourceKey = source + sourceMap + filename + sourceRoot + pad + compiler.parse;
  const cache = parseCache$1.get(sourceKey);
  if (cache) {
    return cache;
  }
  const descriptor = {
    filename,
    source,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: false,
    shouldForceReload: (prevImports) => hmrShouldReload(prevImports, descriptor)
  };
  const errors2 = [];
  const ast = compiler.parse(source, {
    isNativeTag: () => true,
    isPreTag: () => true,
    getTextMode: ({ tag, props }, parent) => {
      if (!parent && tag !== "template" || tag === "template" && props.some((p2) => p2.type === 6 && p2.name === "lang" && p2.value && p2.value.content && p2.value.content !== "html")) {
        return 2;
      } else {
        return 0;
      }
    },
    onError: (e2) => {
      errors2.push(e2);
    }
  });
  ast.children.forEach((node) => {
    if (node.type !== 1) {
      return;
    }
    if (ignoreEmpty && node.tag !== "template" && isEmpty(node) && !hasSrc(node)) {
      return;
    }
    switch (node.tag) {
      case "template":
        if (!descriptor.template) {
          const templateBlock = descriptor.template = createBlock(node, source, false);
          templateBlock.ast = node;
          if (templateBlock.attrs.functional) {
            const err = new SyntaxError(`<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.`);
            err.loc = node.props.find((p2) => p2.name === "functional").loc;
            errors2.push(err);
          }
        } else {
          errors2.push(createDuplicateBlockError(node));
        }
        break;
      case "script":
        const scriptBlock = createBlock(node, source, pad);
        const isSetup = !!scriptBlock.attrs.setup;
        if (isSetup && !descriptor.scriptSetup) {
          descriptor.scriptSetup = scriptBlock;
          break;
        }
        if (!isSetup && !descriptor.script) {
          descriptor.script = scriptBlock;
          break;
        }
        errors2.push(createDuplicateBlockError(node, isSetup));
        break;
      case "style":
        const styleBlock = createBlock(node, source, pad);
        if (styleBlock.attrs.vars) {
          errors2.push(new SyntaxError(`<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`));
        }
        descriptor.styles.push(styleBlock);
        break;
      default:
        descriptor.customBlocks.push(createBlock(node, source, pad));
        break;
    }
  });
  if (!descriptor.template && !descriptor.script && !descriptor.scriptSetup) {
    errors2.push(new SyntaxError(`At least one <template> or <script> is required in a single file component.`));
  }
  if (descriptor.scriptSetup) {
    if (descriptor.scriptSetup.src) {
      errors2.push(new SyntaxError(`<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`));
      descriptor.scriptSetup = null;
    }
    if (descriptor.script && descriptor.script.src) {
      errors2.push(new SyntaxError(`<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`));
      descriptor.script = null;
    }
  }
  if (sourceMap) {
    const genMap = (block) => {
      if (block && !block.src) {
        block.map = generateSourceMap(filename, source, block.content, sourceRoot, !pad || block.type === "template" ? block.loc.start.line - 1 : 0);
      }
    };
    genMap(descriptor.template);
    genMap(descriptor.script);
    descriptor.styles.forEach(genMap);
    descriptor.customBlocks.forEach(genMap);
  }
  descriptor.cssVars = parseCssVars(descriptor);
  const slottedRE = /(?:::v-|:)slotted\(/;
  descriptor.slotted = descriptor.styles.some((s2) => s2.scoped && slottedRE.test(s2.content));
  const result = {
    descriptor,
    errors: errors2
  };
  parseCache$1.set(sourceKey, result);
  return result;
}
function createDuplicateBlockError(node, isScriptSetup = false) {
  const err = new SyntaxError(`Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`);
  err.loc = node.loc;
  return err;
}
function createBlock(node, source, pad) {
  const type = node.tag;
  let { start, end } = node.loc;
  let content = "";
  if (node.children.length) {
    start = node.children[0].loc.start;
    end = node.children[node.children.length - 1].loc.end;
    content = source.slice(start.offset, end.offset);
  } else {
    const offset = node.loc.source.indexOf(`</`);
    if (offset > -1) {
      start = {
        line: start.line,
        column: start.column + offset,
        offset: start.offset + offset
      };
    }
    end = __spreadValues$a({}, start);
  }
  const loc = {
    source: content,
    start,
    end
  };
  const attrs = {};
  const block = {
    type,
    content,
    loc,
    attrs
  };
  if (pad) {
    block.content = padContent(source, block, pad) + block.content;
  }
  node.props.forEach((p2) => {
    if (p2.type === 6) {
      attrs[p2.name] = p2.value ? p2.value.content || true : true;
      if (p2.name === "lang") {
        block.lang = p2.value && p2.value.content;
      } else if (p2.name === "src") {
        block.src = p2.value && p2.value.content;
      } else if (type === "style") {
        if (p2.name === "scoped") {
          block.scoped = true;
        } else if (p2.name === "module") {
          block.module = attrs[p2.name];
        }
      } else if (type === "script" && p2.name === "setup") {
        block.setup = attrs.setup;
      }
    }
  });
  return block;
}
var splitRE = /\r?\n/g;
var emptyRE = /^(?:\/\/)?\s*$/;
var replaceRE = /./g;
function generateSourceMap(filename, source, generated, sourceRoot, lineOffset) {
  const map2 = new SourceMapGenerator$6({
    file: filename.replace(/\\/g, "/"),
    sourceRoot: sourceRoot.replace(/\\/g, "/")
  });
  map2.setSourceContent(filename, source);
  generated.split(splitRE).forEach((line, index) => {
    if (!emptyRE.test(line)) {
      const originalLine = index + 1 + lineOffset;
      const generatedLine = index + 1;
      for (let i = 0;i < line.length; i++) {
        if (!/\s/.test(line[i])) {
          map2.addMapping({
            source: filename,
            original: {
              line: originalLine,
              column: i
            },
            generated: {
              line: generatedLine,
              column: i
            }
          });
        }
      }
    }
  });
  return JSON.parse(map2.toString());
}
function padContent(content, block, pad) {
  content = content.slice(0, block.loc.start.offset);
  if (pad === "space") {
    return content.replace(replaceRE, " ");
  } else {
    const offset = content.split(splitRE).length;
    const padChar = block.type === "script" && !block.lang ? `//
` : `
`;
    return Array(offset).join(padChar);
  }
}
function hasSrc(node) {
  return node.props.some((p2) => {
    if (p2.type !== 6) {
      return false;
    }
    return p2.name === "src";
  });
}
function isEmpty(node) {
  for (let i = 0;i < node.children.length; i++) {
    const child = node.children[i];
    if (child.type !== 2 || child.content.trim() !== "") {
      return false;
    }
  }
  return true;
}
function hmrShouldReload(prevImports, next) {
  if (!next.scriptSetup || next.scriptSetup.lang !== "ts" && next.scriptSetup.lang !== "tsx") {
    return false;
  }
  for (const key in prevImports) {
    if (!prevImports[key].isUsedInTemplate && isImportUsed(key, next)) {
      return true;
    }
  }
  return false;
}
/*! https://mths.be/punycode v1.4.1 by @mathias */
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\x20-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors2 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors2[type]);
}
function map$1(array, fn2) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn2(array[length]);
  }
  return result;
}
function mapDomain(string, fn2) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map$1(labels, fn2).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output2 = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output2.push(value);
        counter--;
      }
    } else {
      output2.push(value);
    }
  }
  return output2;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (;delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode$1(input) {
  var n2, delta, handledCPCount, basicLength, bias, j, m2, q, k2, t2, currentValue, output2 = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n2 = initialN;
  delta = 0;
  bias = initialBias;
  for (j = 0;j < inputLength; ++j) {
    currentValue = input[j];
    if (currentValue < 128) {
      output2.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output2.length;
  if (basicLength) {
    output2.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m2 = maxInt, j = 0;j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (j = 0;j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < n2 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        for (q = delta, k2 = base;; k2 += base) {
          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q < t2) {
            break;
          }
          qMinusT = q - t2;
          baseMinusT = base - t2;
          output2.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q = floor(qMinusT / baseMinusT);
        }
        output2.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output2.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode$1(string) : string;
  });
}
var lookup2 = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length;i < len; ++i) {
    lookup2[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup[45] = 62;
  revLookup[95] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0;i < l2; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start;i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output2 = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes;i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output2 += lookup2[tmp >> 2];
    output2 += lookup2[tmp << 4 & 63];
    output2 += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output2 += lookup2[tmp >> 10];
    output2 += lookup2[tmp >> 4 & 63];
    output2 += lookup2[tmp << 2 & 63];
    output2 += "=";
  }
  parts.push(output2);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer[offset + i];
  i += d;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (;nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (;nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c3 = Math.pow(2, -e2)) < 1) {
      e2--;
      c3 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c3;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c3 >= 2) {
      e2++;
      c3 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c3 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (;mLen >= 8; buffer[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {}
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (;eLen > 0; buffer[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s2 * 128;
}
var toString$1 = {}.toString;
var isArray$2 = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer$1(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer$1(arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer$1.poolSize = 8192;
Buffer$1._augment = function(arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
Buffer$1.from = function(value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$1[Symbol.species] === Buffer$1)
    ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer$1(that, size);
  }
  if (fill !== undefined) {
    return typeof encoding === "string" ? createBuffer$1(that, size).fill(fill, encoding) : createBuffer$1(that, size).fill(fill);
  }
  return createBuffer$1(that, size);
}
Buffer$1.alloc = function(size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer$1(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0;i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer$1.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer$1.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer$1(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer$1(that, length);
  for (var i = 0;i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer$1(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer$1(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer$1.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a === b)
    return 0;
  var x2 = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x2, y);i < len; ++i) {
    if (a[i] !== b[i]) {
      x2 = a[i];
      y = b[i];
      break;
    }
  }
  if (x2 < y)
    return -1;
  if (y < x2)
    return 1;
  return 0;
};
Buffer$1.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$1.concat = function concat3(list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$1.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0;i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0;i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case undefined:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.prototype._isBuffer = true;
function swap$1(b, n2, m2) {
  var i = b[n2];
  b[n2] = b[m2];
  b[m2] = i;
}
Buffer$1.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0;i < len; i += 2) {
    swap$1(this, i, i + 1);
  }
  return this;
};
Buffer$1.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0;i < len; i += 4) {
    swap$1(this, i, i + 3);
    swap$1(this, i + 1, i + 2);
  }
  return this;
};
Buffer$1.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0;i < len; i += 8) {
    swap$1(this, i, i + 7);
    swap$1(this, i + 1, i + 6);
    swap$1(this, i + 2, i + 5);
    swap$1(this, i + 3, i + 4);
  }
  return this;
};
Buffer$1.prototype.toString = function toString2() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer$1.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer$1.compare(this, b) === 0;
};
Buffer$1.prototype.inspect = function inspect() {
  var str = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$1.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x2 = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x2, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0;i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x2 = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x2 < y)
    return -1;
  if (y < x2)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$1.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset;i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset;i >= 0; i--) {
      var found = true;
      for (var j = 0;j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0;i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer$1.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined)
        encoding = "utf8";
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$1.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start;i < end; ++i) {
    out += toHex2(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes2 = buf.slice(start, end);
  var res = "";
  for (var i = 0;i < bytes2.length; i += 2) {
    res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
  }
  return res;
}
Buffer$1.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0;i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i = byteLength2;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2);i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4);i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1;i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i = 0;i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start;i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes2 = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes2.length;
    for (i = 0;i < end - start; ++i) {
      this[i + start] = bytes2[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex2(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes2 = [];
  for (var i = 0;i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c3, hi2, lo;
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c3 = str.charCodeAt(i);
    hi2 = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi2);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src2, dst, offset, length) {
  for (var i = 0;i < length; ++i) {
    if (i + offset >= dst.length || i >= src2.length)
      break;
    dst[i + offset] = src2[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor;
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0;i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
function format$1$1(f) {
  if (!isString$1$1(f)) {
    var objects2 = [];
    for (var i = 0;i < arguments.length; i++) {
      objects2.push(inspect2(arguments[i]));
    }
    return objects2.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x3) {
    if (x3 === "%%")
      return "%";
    if (i >= len)
      return x3;
    switch (x3) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x3;
    }
  });
  for (var x2 = args[i];i < len; x2 = args[++i]) {
    if (isNull(x2) || !isObject$1$1(x2)) {
      str += " " + x2;
    } else {
      str += " " + inspect2(x2);
    }
  }
  return str;
}
function deprecate(fn2, msg) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn2, msg).apply(this, arguments);
    };
  }
  if (browser$1.noDeprecation === true) {
    return fn2;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn2.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format$1$1.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean$1(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect2.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
inspect2.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash2 = {};
  array.forEach(function(val, idx) {
    hash2[val] = true;
  });
  return hash2;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction$2(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString$1$1(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys.length === 0) {
    if (isFunction$2(value)) {
      var name3 = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name3 + "]", "special");
    }
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate$1(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base2 = "", array = false, braces = ["{", "}"];
  if (isArray$1$1(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction$2(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base2 = " [Function" + n2 + "]";
  }
  if (isRegExp$1(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate$1(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output2;
  if (array) {
    output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output2 = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output2, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString$1$1(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$2(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean$1(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output2 = [];
  for (var i = 0, l2 = value.length;i < l2; ++i) {
    if (hasOwnProperty$2(value, String(i))) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output2.push("");
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output2;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name3, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty$2(visibleKeys, key)) {
    name3 = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf(`
`) > -1) {
        if (array) {
          str = str.split(`
`).map(function(line) {
            return "  " + line;
          }).join(`
`).substr(2);
        } else {
          str = `
` + str.split(`
`).map(function(line) {
            return "   " + line;
          }).join(`
`);
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name3)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name3 = JSON.stringify("" + key);
    if (name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name3 = name3.substr(1, name3.length - 2);
      name3 = ctx.stylize(name3, "name");
    } else {
      name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name3 = ctx.stylize(name3, "string");
    }
  }
  return name3 + ": " + str;
}
function reduceToSingleString(output2, base2, braces) {
  var length = output2.reduce(function(prev, cur) {
    if (cur.indexOf(`
`) >= 0)
      ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + `
 `) + " " + output2.join(`,
  `) + " " + braces[1];
  }
  return braces[0] + base2 + " " + output2.join(", ") + " " + braces[1];
}
function isArray$1$1(ar2) {
  return Array.isArray(ar2);
}
function isBoolean$1(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber$2(arg) {
  return typeof arg === "number";
}
function isString$1$1(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === undefined;
}
function isRegExp$1(re2) {
  return isObject$1$1(re2) && objectToString$2(re2) === "[object RegExp]";
}
function isObject$1$1(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate$1(d) {
  return isObject$1$1(d) && objectToString$2(d) === "[object Date]";
}
function isError(e2) {
  return isObject$1$1(e2) && (objectToString$2(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction$2(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer(maybeBuf) {
  return Buffer$1.isBuffer(maybeBuf);
}
function objectToString$2(o2) {
  return Object.prototype.toString.call(o2);
}
function pad(n2) {
  return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d = new Date;
  var time2 = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return [d.getDate(), months[d.getMonth()], time2].join(" ");
}
function log3() {
  console.log("%s - %s", timestamp(), format$1$1.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject$1$1(add))
    return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty$2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn2 = original[kCustomPromisifiedSymbol];
    if (typeof fn2 !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn2;
  }
  function fn2() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve2, reject) {
      promiseResolve = resolve2;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0;i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function(err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });
    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }
    return promise;
  }
  Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol)
    Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  return Object.defineProperties(fn2, getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i = 0;i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(function(ret) {
      browser$1.nextTick(cb.bind(null, null, ret));
    }, function(rej) {
      browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
var _polyfillNode_util = {
  inherits: inherits$1,
  _extend,
  log: log3,
  isBuffer,
  isPrimitive,
  isFunction: isFunction$2,
  isError,
  isDate: isDate$1,
  isObject: isObject$1$1,
  isRegExp: isRegExp$1,
  isUndefined,
  isSymbol,
  isString: isString$1$1,
  isNumber: isNumber$2,
  isNullOrUndefined,
  isNull,
  isBoolean: isBoolean$1,
  isArray: isArray$1$1,
  inspect: inspect2,
  deprecate,
  format: format$1$1,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate,
  format: format$1$1,
  inherits: inherits$1,
  inspect: inspect2,
  isArray: isArray$1$1,
  isBoolean: isBoolean$1,
  isBuffer,
  isDate: isDate$1,
  isError,
  isFunction: isFunction$2,
  isNull,
  isNullOrUndefined,
  isNumber: isNumber$2,
  isObject: isObject$1$1,
  isPrimitive,
  isRegExp: isRegExp$1,
  isString: isString$1$1,
  isSymbol,
  isUndefined,
  log: log3,
  promisify
});
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray$4 = Array.isArray || function(xs2) {
  return Object.prototype.toString.call(xs2) === "[object Array]";
};
function stringifyPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
}
function stringify$5(obj, sep2, eq, name3) {
  sep2 = sep2 || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = undefined;
  }
  if (typeof obj === "object") {
    return map2(objectKeys(obj), function(k2) {
      var ks2 = encodeURIComponent(stringifyPrimitive(k2)) + eq;
      if (isArray$4(obj[k2])) {
        return map2(obj[k2], function(v) {
          return ks2 + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep2);
      } else {
        return ks2 + encodeURIComponent(stringifyPrimitive(obj[k2]));
      }
    }).join(sep2);
  }
  if (!name3)
    return "";
  return encodeURIComponent(stringifyPrimitive(name3)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map2(xs2, f) {
  if (xs2.map)
    return xs2.map(f);
  var res = [];
  for (var i = 0;i < xs2.length; i++) {
    res.push(f(xs2[i], i));
  }
  return res;
}
var objectKeys = Object.keys || function(obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
      res.push(key);
  }
  return res;
};
function parse$6(qs2, sep2, eq, options3) {
  sep2 = sep2 || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs2 !== "string" || qs2.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs2 = qs2.split(sep2);
  var maxKeys = 1000;
  if (options3 && typeof options3.maxKeys === "number") {
    maxKeys = options3.maxKeys;
  }
  var len = qs2.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i = 0;i < len; ++i) {
    var x2 = qs2[i].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k2 = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty$1(obj, k2)) {
      obj[k2] = v;
    } else if (isArray$4(obj[k2])) {
      obj[k2].push(v);
    } else {
      obj[k2] = [obj[k2], v];
    }
  }
  return obj;
}
var URL$1 = global$1.URL;
var URLSearchParams2 = global$1.URLSearchParams;
var _polyfillNode_url = {
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  Url,
  URL: URL$1,
  URLSearchParams: URLSearchParams2
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", `
`, "\t"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var unsafeProtocol = {
  javascript: true,
  "javascript:": true
};
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject$1$1(url) && url instanceof Url)
    return url;
  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  return parse$5(this, url, parseQueryString, slashesDenoteHost);
};
function parse$5(self2, url, parseQueryString, slashesDenoteHost) {
  if (!isString$1$1(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse$6(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i, hec, l2, p2;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0;i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i = 0;i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i = 0, l2 = hostparts.length;i < l2; i++) {
        var part = hostparts[i];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k2 = part.length;j < k2; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p2 = self2.port ? ":" + self2.port : "";
    var h8 = self2.hostname || "";
    self2.host = h8 + p2;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i = 0, l2 = autoEscape.length;i < l2; i++) {
      var ae2 = autoEscape[i];
      if (rest.indexOf(ae2) === -1)
        continue;
      var esc = encodeURIComponent(ae2);
      if (esc === ae2) {
        esc = escape(ae2);
      }
      rest = rest.split(ae2).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    self2.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse$6(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p2 = self2.pathname || "";
    var s2 = self2.search || "";
    self2.path = p2 + s2;
  }
  self2.href = format$2(self2);
  return self2;
}
function urlFileURLToPath(path3) {
  if (typeof path3 === "string")
    path3 = new Url().parse(path3);
  else if (!(path3 instanceof Url))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path3 + String(path3));
  if (path3.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return getPathFromURLPosix(path3);
}
function getPathFromURLPosix(url) {
  const pathname = url.pathname;
  for (let n2 = 0;n2 < pathname.length; n2++) {
    if (pathname[n2] === "%") {
      const third = pathname.codePointAt(n2 + 2) | 32;
      if (pathname[n2 + 1] === "2" && third === 102) {
        throw new TypeError("must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function urlFormat(obj) {
  if (isString$1$1(obj))
    obj = parse$5({}, obj);
  return format$2(obj);
}
function format$2(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash2 = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject$1$1(self2.query) && Object.keys(self2.query).length) {
    query = stringify$5(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#")
    hash2 = "#" + hash2;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
}
Url.prototype.format = function() {
  return format$2(this);
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
  if (isString$1$1(relative)) {
    var rel = new Url;
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url;
  var tkeys = Object.keys(this);
  for (var tk = 0;tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0;rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0;v < keys.length; v++) {
        var k2 = keys[v];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative.pathname && relative.pathname.split("/") || [];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  var authInHost;
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash2 = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up2 = 0;
  for (var i = srcPath.length;i >= 0; i--) {
    last2 = srcPath[i];
    if (last2 === ".") {
      srcPath.splice(i, 1);
    } else if (last2 === "..") {
      srcPath.splice(i, 1);
      up2++;
    } else if (up2) {
      srcPath.splice(i, 1);
      up2--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (;up2--; up2) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash2 && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
    authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute2) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  return parseHost(this);
};
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
var _polyfillNode_url$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  URL: URL$1,
  URLSearchParams: URLSearchParams2,
  Url,
  default: _polyfillNode_url,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject
});
function isRelativeUrl(url) {
  const firstChar = url.charAt(0);
  return firstChar === "." || firstChar === "~" || firstChar === "@";
}
var externalRE = /^(https?:)?\/\//;
function isExternalUrl(url) {
  return externalRE.test(url);
}
var dataUrlRE = /^\s*data:/i;
function isDataUrl(url) {
  return dataUrlRE.test(url);
}
function parseUrl2(url) {
  const firstChar = url.charAt(0);
  if (firstChar === "~") {
    const secondChar = url.charAt(1);
    url = url.slice(secondChar === "/" ? 2 : 1);
  }
  return parseUriParts(url);
}
function parseUriParts(urlString) {
  return urlParse(isString$2(urlString) ? urlString : "", false, true);
}
var __defProp$9 = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => (key in obj) ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
var defaultAssetUrlOptions = {
  base: null,
  includeAbsolute: false,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
};
var normalizeOptions = (options3) => {
  if (Object.keys(options3).some((key) => isArray$3(options3[key]))) {
    return __spreadProps$9(__spreadValues$9({}, defaultAssetUrlOptions), {
      tags: options3
    });
  }
  return __spreadValues$9(__spreadValues$9({}, defaultAssetUrlOptions), options3);
};
var createAssetUrlTransformWithOptions = (options3) => {
  return (node, context) => transformAssetUrl(node, context, options3);
};
var transformAssetUrl = (node, context, options3 = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (!node.props.length) {
      return;
    }
    const tags = options3.tags || defaultAssetUrlOptions.tags;
    const attrs = tags[node.tag];
    const wildCardAttrs = tags["*"];
    if (!attrs && !wildCardAttrs) {
      return;
    }
    const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
    node.props.forEach((attr, index) => {
      if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options3.includeAbsolute && !isRelativeUrl(attr.value.content)) {
        return;
      }
      const url = parseUrl2(attr.value.content);
      if (options3.base && attr.value.content[0] === ".") {
        const base2 = parseUrl2(options3.base);
        const protocol = base2.protocol || "";
        const host = base2.host ? protocol + "//" + base2.host : "";
        const basePath = base2.path || "/";
        attr.value.content = host + (path2.posix || path2).join(basePath, url.path + (url.hash || ""));
        return;
      }
      const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context);
      node.props[index] = {
        type: 7,
        name: "bind",
        arg: createSimpleExpression(attr.name, true, attr.loc),
        exp,
        modifiers: [],
        loc: attr.loc
      };
    });
  }
};
function getImportsExpressionExp(path22, hash2, loc, context) {
  if (path22) {
    let name3;
    let exp;
    const existingIndex = context.imports.findIndex((i) => i.path === path22);
    if (existingIndex > -1) {
      name3 = `_imports_${existingIndex}`;
      exp = context.imports[existingIndex].exp;
    } else {
      name3 = `_imports_${context.imports.length}`;
      exp = createSimpleExpression(name3, false, loc, 3);
      context.imports.push({
        exp,
        path: decodeURIComponent(path22)
      });
    }
    if (!hash2) {
      return exp;
    }
    const hashExp = `${name3} + '${hash2}'`;
    const finalExp = createSimpleExpression(hashExp, false, loc, 3);
    if (!context.hoistStatic) {
      return finalExp;
    }
    const existingHoistIndex = context.hoists.findIndex((h8) => {
      return h8 && h8.type === 4 && !h8.isStatic && h8.content === hashExp;
    });
    if (existingHoistIndex > -1) {
      return createSimpleExpression(`_hoisted_${existingHoistIndex + 1}`, false, loc, 3);
    }
    return context.hoist(finalExp);
  } else {
    return createSimpleExpression(`''`, false, loc, 3);
  }
}
var srcsetTags = ["img", "source"];
var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
var createSrcsetTransformWithOptions = (options3) => {
  return (node, context) => transformSrcset(node, context, options3);
};
var transformSrcset = (node, context, options3 = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (srcsetTags.includes(node.tag) && node.props.length) {
      node.props.forEach((attr, index) => {
        if (attr.name === "srcset" && attr.type === 6) {
          if (!attr.value)
            return;
          const value = attr.value.content;
          if (!value)
            return;
          const imageCandidates = value.split(",").map((s2) => {
            const [url, descriptor] = s2.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
            return { url, descriptor };
          });
          for (let i = 0;i < imageCandidates.length; i++) {
            const { url } = imageCandidates[i];
            if (isDataUrl(url)) {
              imageCandidates[i + 1].url = url + "," + imageCandidates[i + 1].url;
              imageCandidates.splice(i, 1);
            }
          }
          const shouldProcessUrl = (url) => {
            return !isExternalUrl(url) && !isDataUrl(url) && (options3.includeAbsolute || isRelativeUrl(url));
          };
          if (!imageCandidates.some(({ url }) => shouldProcessUrl(url))) {
            return;
          }
          if (options3.base) {
            const base2 = options3.base;
            const set = [];
            let needImportTransform = false;
            imageCandidates.forEach((candidate) => {
              let { url, descriptor } = candidate;
              descriptor = descriptor ? ` ${descriptor}` : ``;
              if (url[0] === ".") {
                candidate.url = (path2.posix || path2).join(base2, url);
                set.push(candidate.url + descriptor);
              } else if (shouldProcessUrl(url)) {
                needImportTransform = true;
              } else {
                set.push(url + descriptor);
              }
            });
            if (!needImportTransform) {
              attr.value.content = set.join(", ");
              return;
            }
          }
          const compoundExpression = createCompoundExpression([], attr.loc);
          imageCandidates.forEach(({ url, descriptor }, index2) => {
            if (shouldProcessUrl(url)) {
              const { path: path22 } = parseUrl2(url);
              let exp2;
              if (path22) {
                const existingImportsIndex = context.imports.findIndex((i) => i.path === path22);
                if (existingImportsIndex > -1) {
                  exp2 = createSimpleExpression(`_imports_${existingImportsIndex}`, false, attr.loc, 3);
                } else {
                  exp2 = createSimpleExpression(`_imports_${context.imports.length}`, false, attr.loc, 3);
                  context.imports.push({ exp: exp2, path: path22 });
                }
                compoundExpression.children.push(exp2);
              }
            } else {
              const exp2 = createSimpleExpression(`"${url}"`, false, attr.loc, 3);
              compoundExpression.children.push(exp2);
            }
            const isNotLast = imageCandidates.length - 1 > index2;
            if (descriptor && isNotLast) {
              compoundExpression.children.push(` + ' ${descriptor}, ' + `);
            } else if (descriptor) {
              compoundExpression.children.push(` + ' ${descriptor}'`);
            } else if (isNotLast) {
              compoundExpression.children.push(` + ', ' + `);
            }
          });
          let exp = compoundExpression;
          if (context.hoistStatic) {
            exp = context.hoist(compoundExpression);
            exp.constType = 3;
          }
          node.props[index] = {
            type: 7,
            name: "bind",
            arg: createSimpleExpression("srcset", true, attr.loc),
            exp,
            modifiers: [],
            loc: attr.loc
          };
        }
      });
    }
  }
};
var SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
var SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
var SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
var SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
var SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);
var SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
var SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
var SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
var SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
var SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
var SSR_RENDER_LIST = Symbol(`ssrRenderList`);
var SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);
var SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
var SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
var SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
var SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
var SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
var SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
var SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);
var ssrHelpers = {
  [SSR_INTERPOLATE]: `ssrInterpolate`,
  [SSR_RENDER_VNODE]: `ssrRenderVNode`,
  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
  [SSR_RENDER_SLOT]: `ssrRenderSlot`,
  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,
  [SSR_RENDER_CLASS]: `ssrRenderClass`,
  [SSR_RENDER_STYLE]: `ssrRenderStyle`,
  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
  [SSR_RENDER_ATTR]: `ssrRenderAttr`,
  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
  [SSR_RENDER_LIST]: `ssrRenderList`,
  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,
  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,
  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`
};
registerRuntimeHelpers(ssrHelpers);
var ssrTransformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, processIf);
function ssrProcessIf(node, context, disableNestedFragments = false) {
  const [rootBranch] = node.branches;
  const ifStatement = createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));
  context.pushStatement(ifStatement);
  let currentIf = ifStatement;
  for (let i = 1;i < node.branches.length; i++) {
    const branch = node.branches[i];
    const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);
    if (branch.condition) {
      currentIf = currentIf.alternate = createIfStatement(branch.condition, branchBlockStatement);
    } else {
      currentIf.alternate = branchBlockStatement;
    }
  }
  if (!currentIf.alternate) {
    currentIf.alternate = createBlockStatement([
      createCallExpression(`_push`, ["`<!---->`"])
    ]);
  }
}
function processIfBranch(branch, context, disableNestedFragments = false) {
  const { children } = branch;
  const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && !(children.length === 1 && children[0].type === 11);
  return processChildrenAsStatement(branch, context, needFragmentWrapper);
}
var ssrTransformFor = createStructuralDirectiveTransform("for", processFor);
function ssrProcessFor(node, context, disableNestedFragments = false) {
  const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);
  const renderLoop = createFunctionExpression(createForLoopParams(node.parseResult));
  renderLoop.body = processChildrenAsStatement(node, context, needFragmentWrapper);
  if (!disableNestedFragments) {
    context.pushStringPart(`<!--[-->`);
  }
  context.pushStatement(createCallExpression(context.helper(SSR_RENDER_LIST), [
    node.source,
    renderLoop
  ]));
  if (!disableNestedFragments) {
    context.pushStringPart(`<!--]-->`);
  }
}
var ssrTransformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const args = [
      `_ctx.$slots`,
      slotName,
      slotProps || `{}`,
      `null`,
      `_push`,
      `_parent`
    ];
    if (context.scopeId && context.slotted !== false) {
      args.push(`"${context.scopeId}-s"`);
    }
    let method = SSR_RENDER_SLOT;
    const parent = context.parent;
    if (parent && parent.type === 1 && parent.tagType === 1 && resolveComponentType(parent, context, true) === TRANSITION && parent.children.filter((c3) => c3.type === 1).length === 1) {
      method = SSR_RENDER_SLOT_INNER;
      if (!(context.scopeId && context.slotted !== false)) {
        args.push("null");
      }
      args.push("true");
    }
    node.ssrCodegenNode = createCallExpression(context.helper(method), args);
  }
};
function ssrProcessSlotOutlet(node, context) {
  const renderCall = node.ssrCodegenNode;
  if (node.children.length) {
    const fallbackRenderFn = createFunctionExpression([]);
    fallbackRenderFn.body = processChildrenAsStatement(node, context);
    renderCall.arguments[3] = fallbackRenderFn;
  }
  if (context.withSlotScopeId) {
    const slotScopeId = renderCall.arguments[6];
    renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
  }
  context.pushStatement(node.ssrCodegenNode);
}
function createSSRCompilerError(code, loc) {
  return createCompilerError(code, loc, SSRErrorMessages);
}
var SSRErrorMessages = {
  [65]: `Unsafe attribute name for SSR.`,
  [66]: `Missing the 'to' prop on teleport element.`,
  [67]: `Invalid AST node during SSR transform.`
};
function ssrProcessTeleport(node, context) {
  const targetProp = findProp(node, "to");
  if (!targetProp) {
    context.onError(createSSRCompilerError(66, node.loc));
    return;
  }
  let target;
  if (targetProp.type === 6) {
    target = targetProp.value && createSimpleExpression(targetProp.value.content, true);
  } else {
    target = targetProp.exp;
  }
  if (!target) {
    context.onError(createSSRCompilerError(66, targetProp.loc));
    return;
  }
  const disabledProp = findProp(node, "disabled", false, true);
  const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
  const contentRenderFn = createFunctionExpression([`_push`], undefined, true, false, node.loc);
  contentRenderFn.body = processChildrenAsStatement(node, context);
  context.pushStatement(createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
    `_push`,
    contentRenderFn,
    target,
    disabled,
    `_parent`
  ]));
}
var wipMap$3 = /* @__PURE__ */ new WeakMap;
function ssrTransformSuspense(node, context) {
  return () => {
    if (node.children.length) {
      const wipEntry = {
        slotsExp: null,
        wipSlots: []
      };
      wipMap$3.set(node, wipEntry);
      wipEntry.slotsExp = buildSlots(node, context, (_props, _vForExp, children, loc) => {
        const fn2 = createFunctionExpression([], undefined, true, false, loc);
        wipEntry.wipSlots.push({
          fn: fn2,
          children
        });
        return fn2;
      }).slots;
    }
  };
}
function ssrProcessSuspense(node, context) {
  const wipEntry = wipMap$3.get(node);
  if (!wipEntry) {
    return;
  }
  const { slotsExp, wipSlots } = wipEntry;
  for (let i = 0;i < wipSlots.length; i++) {
    const slot = wipSlots[i];
    slot.fn.body = processChildrenAsStatement(slot, context);
  }
  context.pushStatement(createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
    `_push`,
    slotsExp
  ]));
}
var rawChildrenMap = /* @__PURE__ */ new WeakMap;
var ssrTransformElement = (node, context) => {
  if (node.type !== 1 || node.tagType !== 0) {
    return;
  }
  return function ssrPostTransformElement() {
    const openTag = [`<${node.tag}`];
    const needTagForRuntime = node.tag === "textarea" || node.tag.indexOf("-") > 0;
    const hasDynamicVBind = hasDynamicKeyVBind(node);
    const hasCustomDir = node.props.some((p2) => p2.type === 7 && !isBuiltInDirective(p2.name));
    const needMergeProps = hasDynamicVBind || hasCustomDir;
    if (needMergeProps) {
      const { props, directives: directives2 } = buildProps(node, context, node.props, false, false, true);
      if (props || directives2.length) {
        const mergedProps = buildSSRProps(props, directives2, context);
        const propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [mergedProps]);
        if (node.tag === "textarea") {
          const existingText = node.children[0];
          if (!existingText || existingText.type !== 5) {
            const tempId = `_temp${context.temps++}`;
            propsExp.arguments = [
              createAssignmentExpression(createSimpleExpression(tempId, false), mergedProps)
            ];
            rawChildrenMap.set(node, createCallExpression(context.helper(SSR_INTERPOLATE), [
              createConditionalExpression(createSimpleExpression(`"value" in ${tempId}`, false), createSimpleExpression(`${tempId}.value`, false), createSimpleExpression(existingText ? existingText.content : ``, true), false)
            ]));
          }
        } else if (node.tag === "input") {
          const vModel = findVModel(node);
          if (vModel) {
            const tempId = `_temp${context.temps++}`;
            const tempExp = createSimpleExpression(tempId, false);
            propsExp.arguments = [
              createSequenceExpression([
                createAssignmentExpression(tempExp, mergedProps),
                createCallExpression(context.helper(MERGE_PROPS), [
                  tempExp,
                  createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                    tempExp,
                    vModel.exp
                  ])
                ])
              ])
            ];
          }
        }
        if (needTagForRuntime) {
          propsExp.arguments.push(`"${node.tag}"`);
        }
        openTag.push(propsExp);
      }
    }
    let dynamicClassBinding = undefined;
    let staticClassBinding = undefined;
    let dynamicStyleBinding = undefined;
    for (let i = 0;i < node.props.length; i++) {
      const prop = node.props[i];
      if (node.tag === "input" && isTrueFalseValue(prop)) {
        continue;
      }
      if (prop.type === 7) {
        if (prop.name === "html" && prop.exp) {
          rawChildrenMap.set(node, prop.exp);
        } else if (prop.name === "text" && prop.exp) {
          node.children = [createInterpolation(prop.exp, prop.loc)];
        } else if (prop.name === "slot") {
          context.onError(createCompilerError(40, prop.loc));
        } else if (isTextareaWithValue(node, prop) && prop.exp) {
          if (!needMergeProps) {
            node.children = [createInterpolation(prop.exp, prop.loc)];
          }
        } else if (!needMergeProps && prop.name !== "on") {
          const directiveTransform = context.directiveTransforms[prop.name];
          if (directiveTransform) {
            const { props, ssrTagParts } = directiveTransform(prop, node, context);
            if (ssrTagParts) {
              openTag.push(...ssrTagParts);
            }
            for (let j = 0;j < props.length; j++) {
              const { key, value } = props[j];
              if (isStaticExp(key)) {
                let attrName = key.content;
                if (attrName === "key" || attrName === "ref") {
                  continue;
                }
                if (attrName === "class") {
                  openTag.push(` class="`, dynamicClassBinding = createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `"`);
                } else if (attrName === "style") {
                  if (dynamicStyleBinding) {
                    mergeCall(dynamicStyleBinding, value);
                  } else {
                    openTag.push(` style="`, dynamicStyleBinding = createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `"`);
                  }
                } else {
                  attrName = node.tag.indexOf("-") > 0 ? attrName : propsToAttrMap$1[attrName] || attrName.toLowerCase();
                  if (isBooleanAttr$1(attrName)) {
                    openTag.push(createConditionalExpression(createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), createSimpleExpression(" " + attrName, true), createSimpleExpression("", true), false));
                  } else if (isSSRSafeAttrName$1(attrName)) {
                    openTag.push(createCallExpression(context.helper(SSR_RENDER_ATTR), [
                      key,
                      value
                    ]));
                  } else {
                    context.onError(createSSRCompilerError(65, key.loc));
                  }
                }
              } else {
                const args = [key, value];
                if (needTagForRuntime) {
                  args.push(`"${node.tag}"`);
                }
                openTag.push(createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
              }
            }
          }
        }
      } else {
        if (node.tag === "textarea" && prop.name === "value" && prop.value) {
          rawChildrenMap.set(node, escapeHtml$2(prop.value.content));
        } else if (!needMergeProps) {
          if (prop.name === "key" || prop.name === "ref") {
            continue;
          }
          if (prop.name === "class" && prop.value) {
            staticClassBinding = JSON.stringify(prop.value.content);
          }
          openTag.push(` ${prop.name}` + (prop.value ? `="${escapeHtml$2(prop.value.content)}"` : ``));
        }
      }
    }
    if (dynamicClassBinding && staticClassBinding) {
      mergeCall(dynamicClassBinding, staticClassBinding);
      removeStaticBinding(openTag, "class");
    }
    if (context.scopeId) {
      openTag.push(` ${context.scopeId}`);
    }
    node.ssrCodegenNode = createTemplateLiteral(openTag);
  };
};
function buildSSRProps(props, directives2, context) {
  let mergePropsArgs = [];
  if (props) {
    if (props.type === 14) {
      mergePropsArgs = props.arguments;
    } else {
      mergePropsArgs.push(props);
    }
  }
  if (directives2.length) {
    for (const dir of directives2) {
      mergePropsArgs.push(createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [
        `_ctx`,
        ...buildDirectiveArgs(dir, context).elements
      ]));
    }
  }
  return mergePropsArgs.length > 1 ? createCallExpression(context.helper(MERGE_PROPS), mergePropsArgs) : mergePropsArgs[0];
}
function isTrueFalseValue(prop) {
  if (prop.type === 7) {
    return prop.name === "bind" && prop.arg && isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
  } else {
    return prop.name === "true-value" || prop.name === "false-value";
  }
}
function isTextareaWithValue(node, prop) {
  return !!(node.tag === "textarea" && prop.name === "bind" && isStaticArgOf(prop.arg, "value"));
}
function mergeCall(call, arg) {
  const existing = call.arguments[0];
  if (existing.type === 17) {
    existing.elements.push(arg);
  } else {
    call.arguments[0] = createArrayExpression([existing, arg]);
  }
}
function removeStaticBinding(tag, binding2) {
  const regExp = new RegExp(`^ ${binding2}=".+"$`);
  const i = tag.findIndex((e2) => typeof e2 === "string" && regExp.test(e2));
  if (i > -1) {
    tag.splice(i, 1);
  }
}
function findVModel(node) {
  return node.props.find((p2) => p2.type === 7 && p2.name === "model" && p2.exp);
}
function ssrProcessElement(node, context) {
  const isVoidTag = context.options.isVoidTag || NO;
  const elementsToAdd = node.ssrCodegenNode.elements;
  for (let j = 0;j < elementsToAdd.length; j++) {
    context.pushStringPart(elementsToAdd[j]);
  }
  if (context.withSlotScopeId) {
    context.pushStringPart(createSimpleExpression(`_scopeId`, false));
  }
  context.pushStringPart(`>`);
  const rawChildren = rawChildrenMap.get(node);
  if (rawChildren) {
    context.pushStringPart(rawChildren);
  } else if (node.children.length) {
    processChildren(node, context);
  }
  if (!isVoidTag(node.tag)) {
    context.pushStringPart(`</${node.tag}>`);
  }
}
var wipMap$2 = /* @__PURE__ */ new WeakMap;
function ssrTransformTransitionGroup(node, context) {
  return () => {
    const tag = findProp(node, "tag");
    if (tag) {
      const otherProps = node.props.filter((p2) => p2 !== tag);
      const { props, directives: directives2 } = buildProps(node, context, otherProps, true, false, true);
      let propsExp = null;
      if (props || directives2.length) {
        propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [
          buildSSRProps(props, directives2, context)
        ]);
      }
      wipMap$2.set(node, {
        tag,
        propsExp,
        scopeId: context.scopeId || null
      });
    }
  };
}
function ssrProcessTransitionGroup(node, context) {
  const entry = wipMap$2.get(node);
  if (entry) {
    const { tag, propsExp, scopeId } = entry;
    if (tag.type === 7) {
      context.pushStringPart(`<`);
      context.pushStringPart(tag.exp);
      if (propsExp) {
        context.pushStringPart(propsExp);
      }
      if (scopeId) {
        context.pushStringPart(` ${scopeId}`);
      }
      context.pushStringPart(`>`);
      processChildren(node, context, false, true);
      context.pushStringPart(`</`);
      context.pushStringPart(tag.exp);
      context.pushStringPart(`>`);
    } else {
      context.pushStringPart(`<${tag.value.content}`);
      if (propsExp) {
        context.pushStringPart(propsExp);
      }
      if (scopeId) {
        context.pushStringPart(` ${scopeId}`);
      }
      context.pushStringPart(`>`);
      processChildren(node, context, false, true);
      context.pushStringPart(`</${tag.value.content}>`);
    }
  } else {
    processChildren(node, context, true, true);
  }
}
var wipMap$1 = /* @__PURE__ */ new WeakMap;
function ssrTransformTransition(node, context) {
  return () => {
    const appear = findProp(node, "appear", false, true);
    wipMap$1.set(node, !!appear);
  };
}
function ssrProcessTransition(node, context) {
  node.children = node.children.filter((c3) => c3.type !== 3);
  const appear = wipMap$1.get(node);
  if (appear) {
    context.pushStringPart(`<template>`);
    processChildren(node, context, false, true);
    context.pushStringPart(`</template>`);
  } else {
    processChildren(node, context, false, true);
  }
}
var __defProp$8 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => (key in obj) ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
var wipMap = /* @__PURE__ */ new WeakMap;
var WIP_SLOT = Symbol();
var componentTypeMap = /* @__PURE__ */ new WeakMap;
var ssrTransformComponent = (node, context) => {
  if (node.type !== 1 || node.tagType !== 1) {
    return;
  }
  const component = resolveComponentType(node, context, true);
  const isDynamicComponent = isObject$2(component) && component.callee === RESOLVE_DYNAMIC_COMPONENT;
  componentTypeMap.set(node, component);
  if (isSymbol$1(component)) {
    if (component === SUSPENSE) {
      return ssrTransformSuspense(node, context);
    } else if (component === TRANSITION_GROUP) {
      return ssrTransformTransitionGroup(node, context);
    } else if (component === TRANSITION) {
      return ssrTransformTransition(node);
    }
    return;
  }
  const vnodeBranches = [];
  const clonedNode = clone(node);
  return function ssrPostTransformComponent() {
    if (clonedNode.children.length) {
      buildSlots(clonedNode, context, (props, vFor, children) => {
        vnodeBranches.push(createVNodeSlotBranch(props, vFor, children, context));
        return createFunctionExpression(undefined);
      });
    }
    let propsExp = `null`;
    if (node.props.length) {
      const { props, directives: directives2 } = buildProps(node, context, undefined, true, isDynamicComponent);
      if (props || directives2.length) {
        propsExp = buildSSRProps(props, directives2, context);
      }
    }
    const wipEntries = [];
    wipMap.set(node, wipEntries);
    const buildSSRSlotFn = (props, _vForExp, children, loc) => {
      const param0 = props && stringifyExpression(props) || `_`;
      const fn2 = createFunctionExpression([param0, `_push`, `_parent`, `_scopeId`], undefined, true, true, loc);
      wipEntries.push({
        type: WIP_SLOT,
        fn: fn2,
        children,
        vnodeBranch: vnodeBranches[wipEntries.length]
      });
      return fn2;
    };
    const slots = node.children.length ? buildSlots(node, context, buildSSRSlotFn).slots : `null`;
    if (typeof component !== "string") {
      node.ssrCodegenNode = createCallExpression(context.helper(SSR_RENDER_VNODE), [
        `_push`,
        createCallExpression(context.helper(CREATE_VNODE), [
          component,
          propsExp,
          slots
        ]),
        `_parent`
      ]);
    } else {
      node.ssrCodegenNode = createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, propsExp, slots, `_parent`]);
    }
  };
};
function ssrProcessComponent(node, context, parent) {
  const component = componentTypeMap.get(node);
  if (!node.ssrCodegenNode) {
    if (component === TELEPORT) {
      return ssrProcessTeleport(node, context);
    } else if (component === SUSPENSE) {
      return ssrProcessSuspense(node, context);
    } else if (component === TRANSITION_GROUP) {
      return ssrProcessTransitionGroup(node, context);
    } else {
      if (parent.type === WIP_SLOT) {
        context.pushStringPart(``);
      }
      if (component === TRANSITION) {
        return ssrProcessTransition(node, context);
      }
      processChildren(node, context);
    }
  } else {
    const wipEntries = wipMap.get(node) || [];
    for (let i = 0;i < wipEntries.length; i++) {
      const { fn: fn2, vnodeBranch } = wipEntries[i];
      fn2.body = createIfStatement(createSimpleExpression(`_push`, false), processChildrenAsStatement(wipEntries[i], context, false, true), vnodeBranch);
    }
    if (context.withSlotScopeId) {
      node.ssrCodegenNode.arguments.push(`_scopeId`);
    }
    if (typeof component === "string") {
      context.pushStatement(createCallExpression(`_push`, [node.ssrCodegenNode]));
    } else {
      context.pushStatement(node.ssrCodegenNode);
    }
  }
}
var rawOptionsMap = /* @__PURE__ */ new WeakMap;
var [baseNodeTransforms, baseDirectiveTransforms] = getBaseTransformPreset(true);
var vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms];
var vnodeDirectiveTransforms = __spreadValues$8(__spreadValues$8({}, baseDirectiveTransforms), DOMDirectiveTransforms);
function createVNodeSlotBranch(props, vForExp, children, parentContext) {
  const rawOptions = rawOptionsMap.get(parentContext.root);
  const subOptions = __spreadProps$8(__spreadValues$8({}, rawOptions), {
    nodeTransforms: [
      ...vnodeNodeTransforms,
      ...rawOptions.nodeTransforms || []
    ],
    directiveTransforms: __spreadValues$8(__spreadValues$8({}, vnodeDirectiveTransforms), rawOptions.directiveTransforms || {})
  });
  const wrapperNode = {
    type: 1,
    ns: 0,
    tag: "template",
    tagType: 3,
    isSelfClosing: false,
    props: [
      {
        type: 7,
        name: "slot",
        exp: props,
        arg: undefined,
        modifiers: [],
        loc: locStub
      },
      {
        type: 7,
        name: "for",
        exp: vForExp,
        arg: undefined,
        modifiers: [],
        loc: locStub
      }
    ],
    children,
    loc: locStub,
    codegenNode: undefined
  };
  subTransform(wrapperNode, subOptions, parentContext);
  return createReturnStatement(children);
}
function subTransform(node, options3, parentContext) {
  const childRoot = createRoot([node]);
  const childContext = createTransformContext(childRoot, options3);
  childContext.ssr = false;
  childContext.scopes = __spreadValues$8({}, parentContext.scopes);
  childContext.identifiers = __spreadValues$8({}, parentContext.identifiers);
  childContext.imports = parentContext.imports;
  traverseNode$1(childRoot, childContext);
  ["helpers", "components", "directives"].forEach((key) => {
    childContext[key].forEach((value, helperKey) => {
      if (key === "helpers") {
        const parentCount = parentContext.helpers.get(helperKey);
        if (parentCount === undefined) {
          parentContext.helpers.set(helperKey, value);
        } else {
          parentContext.helpers.set(helperKey, value + parentCount);
        }
      } else {
        parentContext[key].add(value);
      }
    });
  });
}
function clone(v) {
  if (isArray$3(v)) {
    return v.map(clone);
  } else if (isObject$2(v)) {
    const res = {};
    for (const key in v) {
      res[key] = clone(v[key]);
    }
    return res;
  } else {
    return v;
  }
}
function ssrCodegenTransform(ast, options3) {
  const context = createSSRTransformContext(ast, options3);
  if (options3.ssrCssVars) {
    const cssContext = createTransformContext(createRoot([]), options3);
    const varsExp = processExpression(createSimpleExpression(options3.ssrCssVars, false), cssContext);
    context.body.push(createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));
    Array.from(cssContext.helpers.keys()).forEach((helper) => {
      ast.helpers.add(helper);
    });
  }
  const isFragment2 = ast.children.length > 1 && ast.children.some((c3) => !isText$1(c3));
  processChildren(ast, context, isFragment2);
  ast.codegenNode = createBlockStatement(context.body);
  ast.ssrHelpers = Array.from(/* @__PURE__ */ new Set([
    ...Array.from(ast.helpers).filter((h8) => (h8 in ssrHelpers)),
    ...context.helpers
  ]));
  ast.helpers = new Set(Array.from(ast.helpers).filter((h8) => !(h8 in ssrHelpers)));
}
function createSSRTransformContext(root, options3, helpers = /* @__PURE__ */ new Set, withSlotScopeId = false) {
  const body = [];
  let currentString = null;
  return {
    root,
    options: options3,
    body,
    helpers,
    withSlotScopeId,
    onError: options3.onError || ((e2) => {
      throw e2;
    }),
    helper(name3) {
      helpers.add(name3);
      return name3;
    },
    pushStringPart(part) {
      if (!currentString) {
        const currentCall = createCallExpression(`_push`);
        body.push(currentCall);
        currentString = createTemplateLiteral([]);
        currentCall.arguments.push(currentString);
      }
      const bufferedElements = currentString.elements;
      const lastItem = bufferedElements[bufferedElements.length - 1];
      if (isString$2(part) && isString$2(lastItem)) {
        bufferedElements[bufferedElements.length - 1] += part;
      } else {
        bufferedElements.push(part);
      }
    },
    pushStatement(statement) {
      currentString = null;
      body.push(statement);
    }
  };
}
function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
  return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
}
function processChildren(parent, context, asFragment = false, disableNestedFragments = false) {
  if (asFragment) {
    context.pushStringPart(`<!--[-->`);
  }
  const { children } = parent;
  for (let i = 0;i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        switch (child.tagType) {
          case 0:
            ssrProcessElement(child, context);
            break;
          case 1:
            ssrProcessComponent(child, context, parent);
            break;
          case 2:
            ssrProcessSlotOutlet(child, context);
            break;
          case 3:
            break;
          default:
            context.onError(createSSRCompilerError(67, child.loc));
            const exhaustiveCheck2 = child;
            return exhaustiveCheck2;
        }
        break;
      case 2:
        context.pushStringPart(escapeHtml$2(child.content));
        break;
      case 3:
        context.pushStringPart(`<!--${child.content}-->`);
        break;
      case 5:
        context.pushStringPart(createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));
        break;
      case 9:
        ssrProcessIf(child, context, disableNestedFragments);
        break;
      case 11:
        ssrProcessFor(child, context, disableNestedFragments);
        break;
      case 10:
        break;
      case 12:
      case 8:
        break;
      default:
        context.onError(createSSRCompilerError(67, child.loc));
        const exhaustiveCheck = child;
        return exhaustiveCheck;
    }
  }
  if (asFragment) {
    context.pushStringPart(`<!--]-->`);
  }
}
function processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
  const childContext = createChildContext(parentContext, withSlotScopeId);
  processChildren(parent, childContext, asFragment);
  return createBlockStatement(childContext.body);
}
var ssrTransformModel = (dir, node, context) => {
  const model = dir.exp;
  function checkDuplicatedValue() {
    const value = findProp(node, "value");
    if (value) {
      context.onError(createDOMCompilerError(60, value.loc));
    }
  }
  function processOption(plainNode) {
    if (plainNode.tag === "option") {
      if (plainNode.props.findIndex((p2) => p2.name === "selected") === -1) {
        const value = findValueBinding(plainNode);
        plainNode.ssrCodegenNode.elements.push(createConditionalExpression(createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [
          createConditionalExpression(createCallExpression(`Array.isArray`, [model]), createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
            model,
            value
          ]), createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
            model,
            value
          ]))
        ]), createSimpleExpression(" selected", true), createSimpleExpression("", true), false));
      }
    } else if (plainNode.tag === "optgroup") {
      plainNode.children.forEach((option2) => processOption(option2));
    }
  }
  if (node.tagType === 0) {
    const res = { props: [] };
    const defaultProps = [
      createObjectProperty(`value`, model)
    ];
    if (node.tag === "input") {
      const type = findProp(node, "type");
      if (type) {
        const value = findValueBinding(node);
        if (type.type === 7) {
          res.ssrTagParts = [
            createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
              type.exp,
              model,
              value
            ])
          ];
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              res.props = [
                createObjectProperty(`checked`, createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                  model,
                  value
                ]))
              ];
              break;
            case "checkbox":
              const trueValueBinding = findProp(node, "true-value");
              if (trueValueBinding) {
                const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                res.props = [
                  createObjectProperty(`checked`, createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                    model,
                    trueValue
                  ]))
                ];
              } else {
                res.props = [
                  createObjectProperty(`checked`, createConditionalExpression(createCallExpression(`Array.isArray`, [model]), createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                    model,
                    value
                  ]), model))
                ];
              }
              break;
            case "file":
              context.onError(createDOMCompilerError(59, dir.loc));
              break;
            default:
              checkDuplicatedValue();
              res.props = defaultProps;
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node))
        ;
      else {
        checkDuplicatedValue();
        res.props = defaultProps;
      }
    } else if (node.tag === "textarea") {
      checkDuplicatedValue();
      node.children = [createInterpolation(model, model.loc)];
    } else if (node.tag === "select") {
      node.children.forEach((child) => {
        if (child.type === 1) {
          processOption(child);
        }
      });
    } else {
      context.onError(createDOMCompilerError(57, dir.loc));
    }
    return res;
  } else {
    return transformModel$1(dir, node, context);
  }
};
function findValueBinding(node) {
  const valueBinding = findProp(node, "value");
  return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : createSimpleExpression(valueBinding.value.content, true) : createSimpleExpression(`null`, false);
}
var ssrTransformShow = (dir, node, context) => {
  if (!dir.exp) {
    context.onError(createDOMCompilerError(61));
  }
  return {
    props: [
      createObjectProperty(`style`, createConditionalExpression(dir.exp, createSimpleExpression(`null`, false), createObjectExpression([
        createObjectProperty(`display`, createSimpleExpression(`none`, true))
      ]), false))
    ]
  };
};
var filterChild = (node) => node.children.filter((n2) => n2.type !== 3);
var hasSingleChild = (node) => filterChild(node).length === 1;
var ssrInjectFallthroughAttrs = (node, context) => {
  if (node.type === 0) {
    context.identifiers._attrs = 1;
  }
  if (node.type === 1 && node.tagType === 1 && (isBuiltInType(node.tag, "Transition") || isBuiltInType(node.tag, "KeepAlive"))) {
    const rootChildren = filterChild(context.root);
    if (rootChildren.length === 1 && rootChildren[0] === node) {
      if (hasSingleChild(node)) {
        injectFallthroughAttrs(node.children[0]);
      }
      return;
    }
  }
  const parent = context.parent;
  if (!parent || parent.type !== 0) {
    return;
  }
  if (node.type === 10 && hasSingleChild(node)) {
    let hasEncounteredIf = false;
    for (const c3 of filterChild(parent)) {
      if (c3.type === 9 || c3.type === 1 && findDir(c3, "if")) {
        if (hasEncounteredIf)
          return;
        hasEncounteredIf = true;
      } else if (!hasEncounteredIf || !(c3.type === 1 && findDir(c3, /else/, true))) {
        return;
      }
    }
    injectFallthroughAttrs(node.children[0]);
  } else if (hasSingleChild(parent)) {
    injectFallthroughAttrs(node);
  }
};
function injectFallthroughAttrs(node) {
  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !findDir(node, "for")) {
    node.props.push({
      type: 7,
      name: "bind",
      arg: undefined,
      exp: createSimpleExpression(`_attrs`, false),
      modifiers: [],
      loc: locStub
    });
  }
}
var ssrInjectCssVars = (node, context) => {
  if (!context.ssrCssVars) {
    return;
  }
  if (node.type === 0) {
    context.identifiers._cssVars = 1;
  }
  const parent = context.parent;
  if (!parent || parent.type !== 0) {
    return;
  }
  if (node.type === 10) {
    for (const child of node.children) {
      injectCssVars(child);
    }
  } else {
    injectCssVars(node);
  }
};
function injectCssVars(node) {
  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !findDir(node, "for")) {
    if (isBuiltInType(node.tag, "Suspense")) {
      for (const child of node.children) {
        if (child.type === 1 && child.tagType === 3) {
          child.children.forEach(injectCssVars);
        } else {
          injectCssVars(child);
        }
      }
    } else {
      node.props.push({
        type: 7,
        name: "bind",
        arg: undefined,
        exp: createSimpleExpression(`_cssVars`, false),
        modifiers: [],
        loc: locStub
      });
    }
  }
}
var __defProp$7 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => (key in obj) ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
function compile$2(template, options3 = {}) {
  options3 = __spreadProps$7(__spreadValues$7(__spreadValues$7({}, options3), parserOptions), {
    ssr: true,
    inSSR: true,
    scopeId: options3.mode === "function" ? null : options3.scopeId,
    prefixIdentifiers: true,
    cacheHandlers: false,
    hoistStatic: false
  });
  const ast = baseParse(template, options3);
  rawOptionsMap.set(ast, options3);
  transform$1(ast, __spreadProps$7(__spreadValues$7({}, options3), {
    hoistStatic: false,
    nodeTransforms: [
      ssrTransformIf,
      ssrTransformFor,
      trackVForSlotScopes,
      transformExpression,
      ssrTransformSlotOutlet,
      ssrInjectFallthroughAttrs,
      ssrInjectCssVars,
      ssrTransformElement,
      ssrTransformComponent,
      trackSlotScopes,
      transformStyle,
      ...options3.nodeTransforms || []
    ],
    directiveTransforms: __spreadValues$7({
      bind: transformBind,
      on: transformOn$1,
      model: ssrTransformModel,
      show: ssrTransformShow,
      cloak: noopDirectiveTransform,
      once: noopDirectiveTransform,
      memo: noopDirectiveTransform
    }, options3.directiveTransforms || {})
  }));
  ssrCodegenTransform(ast, options3);
  return generate$1(ast, options3);
}
var CompilerSSR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compile: compile$2
});
var _polyfillNode_fs = {};
var _polyfillNode_fs$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: _polyfillNode_fs
});
var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_fs$1);
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_path);
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_util$1);
var hasWarned$1 = {};
function warnOnce$4(msg) {
  const isNodeProd = typeof process !== "undefined" && false;
  if (!isNodeProd && true && !hasWarned$1[msg]) {
    hasWarned$1[msg] = true;
    warn$1(msg);
  }
}
function warn$1(msg) {
  console.warn(`\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${msg}\x1B[0m
`);
}
var __defProp$6 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => (key in obj) ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
function preprocess$1({ source, filename, preprocessOptions }, preprocessor) {
  let res = "";
  let err = null;
  preprocessor.render(source, __spreadValues$6({ filename }, preprocessOptions), (_err, _res) => {
    if (_err)
      err = _err;
    res = _res;
  });
  if (err)
    throw err;
  return res;
}
function compileTemplate(options3) {
  const { preprocessLang, preprocessCustomRequire } = options3;
  if (preprocessLang && !preprocessCustomRequire) {
    throw new Error(`[@vue/compiler-sfc] Template preprocessing in the browser build must provide the \`preprocessCustomRequire\` option to return the in-browser version of the preprocessor in the shape of { render(): string }.`);
  }
  const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : undefined : false;
  if (preprocessor) {
    try {
      return doCompileTemplate(__spreadProps$6(__spreadValues$6({}, options3), {
        source: preprocess$1(options3, preprocessor)
      }));
    } catch (e2) {
      return {
        code: `export default function render() {}`,
        source: options3.source,
        tips: [],
        errors: [e2]
      };
    }
  } else if (preprocessLang) {
    return {
      code: `export default function render() {}`,
      source: options3.source,
      tips: [
        `Component ${options3.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
      ],
      errors: [
        `Component ${options3.filename} uses lang ${preprocessLang} for template, however it is not installed.`
      ]
    };
  } else {
    return doCompileTemplate(options3);
  }
}
function doCompileTemplate({
  filename,
  id,
  scoped,
  slotted,
  inMap,
  source,
  ssr = false,
  ssrCssVars,
  isProd = false,
  compiler = ssr ? CompilerSSR : CompilerDOM,
  compilerOptions = {},
  transformAssetUrls
}) {
  const errors3 = [];
  const warnings = [];
  let nodeTransforms = [];
  if (isObject$2(transformAssetUrls)) {
    const assetOptions = normalizeOptions(transformAssetUrls);
    nodeTransforms = [
      createAssetUrlTransformWithOptions(assetOptions),
      createSrcsetTransformWithOptions(assetOptions)
    ];
  } else if (transformAssetUrls !== false) {
    nodeTransforms = [transformAssetUrl, transformSrcset];
  }
  if (ssr && !ssrCssVars) {
    warnOnce$4(`compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.\`.`);
  }
  if (!id) {
    warnOnce$4(`compileTemplate now requires the \`id\` option.\`.`);
    id = "";
  }
  const shortId = id.replace(/^data-v-/, "");
  const longId = `data-v-${shortId}`;
  let { code, ast, preamble, map: map3 } = compiler.compile(source, __spreadProps$6(__spreadValues$6({
    mode: "module",
    prefixIdentifiers: true,
    hoistStatic: true,
    cacheHandlers: true,
    ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd, true) : "",
    scopeId: scoped ? longId : undefined,
    slotted,
    sourceMap: true
  }, compilerOptions), {
    hmr: !isProd,
    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
    filename,
    onError: (e2) => errors3.push(e2),
    onWarn: (w) => warnings.push(w)
  }));
  if (inMap) {
    if (map3) {
      map3 = mapLines(inMap, map3);
    }
    if (errors3.length) {
      patchErrors(errors3, source, inMap);
    }
  }
  const tips = warnings.map((w) => {
    let msg = w.message;
    if (w.loc) {
      msg += `
${generateCodeFrame$1(source, w.loc.start.offset, w.loc.end.offset)}`;
    }
    return msg;
  });
  return { code, ast, preamble, source, errors: errors3, tips, map: map3 };
}
function mapLines(oldMap, newMap) {
  if (!oldMap)
    return newMap;
  if (!newMap)
    return oldMap;
  const oldMapConsumer = new SourceMapConsumer$5(oldMap);
  const newMapConsumer = new SourceMapConsumer$5(newMap);
  const mergedMapGenerator = new SourceMapGenerator$6;
  newMapConsumer.eachMapping((m2) => {
    if (m2.originalLine == null) {
      return;
    }
    const origPosInOldMap = oldMapConsumer.originalPositionFor({
      line: m2.originalLine,
      column: m2.originalColumn
    });
    if (origPosInOldMap.source == null) {
      return;
    }
    mergedMapGenerator.addMapping({
      generated: {
        line: m2.generatedLine,
        column: m2.generatedColumn
      },
      original: {
        line: origPosInOldMap.line,
        column: m2.originalColumn
      },
      source: origPosInOldMap.source,
      name: origPosInOldMap.name
    });
  });
  const generator = mergedMapGenerator;
  oldMapConsumer.sources.forEach((sourceFile) => {
    generator._sources.add(sourceFile);
    const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
    if (sourceContent != null) {
      mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
    }
  });
  generator._sourceRoot = oldMap.sourceRoot;
  generator._file = oldMap.file;
  return generator.toJSON();
}
function patchErrors(errors3, source, inMap) {
  const originalSource = inMap.sourcesContent[0];
  const offset = originalSource.indexOf(source);
  const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
  errors3.forEach((err) => {
    if (err.loc) {
      err.loc.start.line += lineOffset;
      err.loc.start.offset += offset;
      if (err.loc.end !== err.loc.start) {
        err.loc.end.line += lineOffset;
        err.loc.end.offset += offset;
      }
    }
  });
}
var picocolors = { exports: {} };
function isatty() {
  return false;
}
function ReadStream() {
  throw new Error("tty.ReadStream is not implemented");
}
function WriteStream() {
  throw new Error("tty.ReadStream is not implemented");
}
var _polyfillNode_tty = {
  isatty,
  ReadStream,
  WriteStream
};
var _polyfillNode_tty$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ReadStream,
  WriteStream,
  default: _polyfillNode_tty,
  isatty
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_tty$1);
var tty = require$$0;
var isColorSupported = !(("NO_COLOR" in {}) || browser$1.argv.includes("--no-color")) && (("FORCE_COLOR" in {}) || browser$1.argv.includes("--color") || false || tty.isatty(1) && browser$1.env.TERM !== "dumb" || ("CI" in {}));
var formatter = (open, close, replace = open) => (input) => {
  let string = "" + input;
  let index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
};
var replaceClose = (string, close, replace, index) => {
  let start = string.substring(0, index) + replace;
  let end = string.substring(index + close.length);
  let nextIndex = end.indexOf(close);
  return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
var createColors = (enabled2 = isColorSupported) => ({
  isColorSupported: enabled2,
  reset: enabled2 ? (s2) => `\x1B[0m${s2}\x1B[0m` : String,
  bold: enabled2 ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
  dim: enabled2 ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
  italic: enabled2 ? formatter("\x1B[3m", "\x1B[23m") : String,
  underline: enabled2 ? formatter("\x1B[4m", "\x1B[24m") : String,
  inverse: enabled2 ? formatter("\x1B[7m", "\x1B[27m") : String,
  hidden: enabled2 ? formatter("\x1B[8m", "\x1B[28m") : String,
  strikethrough: enabled2 ? formatter("\x1B[9m", "\x1B[29m") : String,
  black: enabled2 ? formatter("\x1B[30m", "\x1B[39m") : String,
  red: enabled2 ? formatter("\x1B[31m", "\x1B[39m") : String,
  green: enabled2 ? formatter("\x1B[32m", "\x1B[39m") : String,
  yellow: enabled2 ? formatter("\x1B[33m", "\x1B[39m") : String,
  blue: enabled2 ? formatter("\x1B[34m", "\x1B[39m") : String,
  magenta: enabled2 ? formatter("\x1B[35m", "\x1B[39m") : String,
  cyan: enabled2 ? formatter("\x1B[36m", "\x1B[39m") : String,
  white: enabled2 ? formatter("\x1B[37m", "\x1B[39m") : String,
  gray: enabled2 ? formatter("\x1B[90m", "\x1B[39m") : String,
  bgBlack: enabled2 ? formatter("\x1B[40m", "\x1B[49m") : String,
  bgRed: enabled2 ? formatter("\x1B[41m", "\x1B[49m") : String,
  bgGreen: enabled2 ? formatter("\x1B[42m", "\x1B[49m") : String,
  bgYellow: enabled2 ? formatter("\x1B[43m", "\x1B[49m") : String,
  bgBlue: enabled2 ? formatter("\x1B[44m", "\x1B[49m") : String,
  bgMagenta: enabled2 ? formatter("\x1B[45m", "\x1B[49m") : String,
  bgCyan: enabled2 ? formatter("\x1B[46m", "\x1B[49m") : String,
  bgWhite: enabled2 ? formatter("\x1B[47m", "\x1B[49m") : String
});
picocolors.exports = createColors();
picocolors.exports.createColors = createColors;
var picocolorsExports = picocolors.exports;
var SINGLE_QUOTE = 39;
var DOUBLE_QUOTE = 34;
var BACKSLASH = 92;
var SLASH = 47;
var NEWLINE = 10;
var SPACE = 32;
var FEED = 12;
var TAB = 9;
var CR = 13;
var OPEN_SQUARE = 91;
var CLOSE_SQUARE = 93;
var OPEN_PARENTHESES = 40;
var CLOSE_PARENTHESES = 41;
var OPEN_CURLY = 123;
var CLOSE_CURLY = 125;
var SEMICOLON = 59;
var ASTERISK = 42;
var COLON = 58;
var AT = 64;
var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
var RE_HEX_ESCAPE = /[\da-f]/i;
var tokenize$1 = function tokenizer2(input, options3 = {}) {
  let css2 = input.css.valueOf();
  let ignore = options3.ignoreErrors;
  let code, next, quote, content, escape3;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css2.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length)
      return returned.pop();
    if (pos >= length)
      return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css2.charCodeAt(pos);
    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos;
        do {
          next += 1;
          code = css2.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
        currentToken = ["space", css2.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css2.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
          next = pos;
          do {
            escaped = false;
            next = css2.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css2.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css2.indexOf(")", pos + 1);
          content = css2.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css2.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT: {
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css2);
        if (RE_AT_END.lastIndex === 0) {
          next = css2.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }
        currentToken = ["at-word", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH: {
        next = pos;
        escape3 = true;
        while (css2.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape3 = !escape3;
        }
        code = css2.charCodeAt(next + 1);
        if (escape3 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;
          if (RE_HEX_ESCAPE.test(css2.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css2.charAt(next + 1))) {
              next += 1;
            }
            if (css2.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
          next = css2.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css2.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css2.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css2);
          if (RE_WORD_END.lastIndex === 0) {
            next = css2.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }
          currentToken = ["word", css2.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token2) {
    returned.push(token2);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
var pico$1 = picocolorsExports;
var tokenizer$12 = tokenize$1;
var Input$5;
function registerInput(dependant) {
  Input$5 = dependant;
}
var HIGHLIGHT_THEME = {
  ";": pico$1.yellow,
  ":": pico$1.yellow,
  "(": pico$1.cyan,
  ")": pico$1.cyan,
  "[": pico$1.yellow,
  "]": pico$1.yellow,
  "{": pico$1.yellow,
  "}": pico$1.yellow,
  "at-word": pico$1.cyan,
  brackets: pico$1.cyan,
  call: pico$1.cyan,
  class: pico$1.yellow,
  comment: pico$1.gray,
  hash: pico$1.magenta,
  string: pico$1.green
};
function getTokenType([type, value], processor) {
  if (type === "word") {
    if (value[0] === ".") {
      return "class";
    }
    if (value[0] === "#") {
      return "hash";
    }
  }
  if (!processor.endOfFile()) {
    let next = processor.nextToken();
    processor.back(next);
    if (next[0] === "brackets" || next[0] === "(")
      return "call";
  }
  return type;
}
function terminalHighlight$2(css2) {
  let processor = tokenizer$12(new Input$5(css2), { ignoreErrors: true });
  let result = "";
  while (!processor.endOfFile()) {
    let token2 = processor.nextToken();
    let color = HIGHLIGHT_THEME[getTokenType(token2, processor)];
    if (color) {
      result += token2[1].split(/\r?\n/).map((i) => color(i)).join(`
`);
    } else {
      result += token2[1];
    }
  }
  return result;
}
terminalHighlight$2.registerInput = registerInput;
var terminalHighlight_1 = terminalHighlight$2;
var pico = picocolorsExports;
var terminalHighlight$1 = terminalHighlight_1;
var CssSyntaxError$3 = class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin) {
      this.plugin = plugin;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source)
      return "";
    let css2 = this.source;
    if (color == null)
      color = pico.isColorSupported;
    if (terminalHighlight$1) {
      if (color)
        css2 = terminalHighlight$1(css2);
    }
    let lines = css2.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold: bold3, gray: gray2, red: red2 } = pico.createColors(true);
      mark = (text) => bold3(red2(text));
      aside = (text) => gray2(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index) => {
      let number = start + 1 + index;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + `
 ` + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join(`
`);
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = `

` + code + `
`;
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError = CssSyntaxError$3;
CssSyntaxError$3.default = CssSyntaxError$3;
var symbols = {};
symbols.isClean = Symbol("isClean");
symbols.my = Symbol("my");
var DEFAULT_RAW = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize$2(str) {
  return str[0].toUpperCase() + str.slice(1);
}
var Stringifier$2 = class Stringifier {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node, semicolon) {
    let name3 = "@" + node.name;
    let params = node.params ? this.rawValue(node, "params") : "";
    if (typeof node.raws.afterName !== "undefined") {
      name3 += node.raws.afterName;
    } else if (params) {
      name3 += " ";
    }
    if (node.nodes) {
      this.block(node, name3 + params);
    } else {
      let end = (node.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name3 + params + end, node);
    }
  }
  beforeAfter(node, detect) {
    let value;
    if (node.type === "decl") {
      value = this.raw(node, null, "beforeDecl");
    } else if (node.type === "comment") {
      value = this.raw(node, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node, null, "beforeRule");
    } else {
      value = this.raw(node, null, "beforeClose");
    }
    let buf = node.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes(`
`)) {
      let indent = this.raw(node, null, "indent");
      if (indent.length) {
        for (let step = 0;step < depth; step++)
          value += indent;
      }
    }
    return value;
  }
  block(node, start) {
    let between = this.raw(node, "between", "beforeOpen");
    this.builder(start + between + "{", node, "start");
    let after;
    if (node.nodes && node.nodes.length) {
      this.body(node);
      after = this.raw(node, "after");
    } else {
      after = this.raw(node, "after", "emptyBody");
    }
    if (after)
      this.builder(after);
    this.builder("}", node, "end");
  }
  body(node) {
    let last2 = node.nodes.length - 1;
    while (last2 > 0) {
      if (node.nodes[last2].type !== "comment")
        break;
      last2 -= 1;
    }
    let semicolon = this.raw(node, "semicolon");
    for (let i = 0;i < node.nodes.length; i++) {
      let child = node.nodes[i];
      let before = this.raw(child, "before");
      if (before)
        this.builder(before);
      this.stringify(child, last2 !== i || semicolon);
    }
  }
  comment(node) {
    let left2 = this.raw(node, "left", "commentLeft");
    let right2 = this.raw(node, "right", "commentRight");
    this.builder("/*" + left2 + node.text + right2 + "*/", node);
  }
  decl(node, semicolon) {
    let between = this.raw(node, "between", "colon");
    let string = node.prop + between + this.rawValue(node, "value");
    if (node.important) {
      string += node.raws.important || " !important";
    }
    if (semicolon)
      string += ";";
    this.builder(string, node);
  }
  document(node) {
    this.body(node);
  }
  raw(node, own, detect) {
    let value;
    if (!detect)
      detect = own;
    if (own) {
      value = node.raws[own];
      if (typeof value !== "undefined")
        return value;
    }
    let parent = node.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent)
      return DEFAULT_RAW[detect];
    let root = node.root();
    if (!root.rawCache)
      root.rawCache = {};
    if (typeof root.rawCache[detect] !== "undefined") {
      return root.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node, detect);
    } else {
      let method = "raw" + capitalize$2(detect);
      if (this[method]) {
        value = this[method](root, node);
      } else {
        root.walk((i) => {
          value = i.raws[own];
          if (typeof value !== "undefined")
            return false;
        });
      }
    }
    if (typeof value === "undefined")
      value = DEFAULT_RAW[detect];
    root.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root) {
    let value;
    root.walk((i) => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== "undefined") {
          value = i.raws.after;
          if (value.includes(`
`)) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value)
      value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root, node) {
    let value;
    root.walkComments((i) => {
      if (typeof i.raws.before !== "undefined") {
        value = i.raws.before;
        if (value.includes(`
`)) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root, node) {
    let value;
    root.walkDecls((i) => {
      if (typeof i.raws.before !== "undefined") {
        value = i.raws.before;
        if (value.includes(`
`)) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root) {
    let value;
    root.walk((i) => {
      if (i.type !== "decl") {
        value = i.raws.between;
        if (typeof value !== "undefined")
          return false;
      }
    });
    return value;
  }
  rawBeforeRule(root) {
    let value;
    root.walk((i) => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== "undefined") {
          value = i.raws.before;
          if (value.includes(`
`)) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value)
      value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root) {
    let value;
    root.walkDecls((i) => {
      if (typeof i.raws.between !== "undefined") {
        value = i.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root) {
    let value;
    root.walk((i) => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after;
        if (typeof value !== "undefined")
          return false;
      }
    });
    return value;
  }
  rawIndent(root) {
    if (root.raws.indent)
      return root.raws.indent;
    let value;
    root.walk((i) => {
      let p2 = i.parent;
      if (p2 && p2 !== root && p2.parent && p2.parent === root) {
        if (typeof i.raws.before !== "undefined") {
          let parts = i.raws.before.split(`
`);
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root) {
    let value;
    root.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl") {
        value = i.raws.semicolon;
        if (typeof value !== "undefined")
          return false;
      }
    });
    return value;
  }
  rawValue(node, prop) {
    let value = node[prop];
    let raw = node.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node) {
    this.body(node);
    if (node.raws.after)
      this.builder(node.raws.after);
  }
  rule(node) {
    this.block(node, this.rawValue(node, "selector"));
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, "end");
    }
  }
  stringify(node, semicolon) {
    if (!this[node.type]) {
      throw new Error("Unknown AST node type " + node.type + ". " + "Maybe you need to change PostCSS stringifier.");
    }
    this[node.type](node, semicolon);
  }
};
var stringifier = Stringifier$2;
Stringifier$2.default = Stringifier$2;
var Stringifier$1 = stringifier;
function stringify$4(node, builder) {
  let str = new Stringifier$1(builder);
  str.stringify(node);
}
var stringify_1 = stringify$4;
stringify$4.default = stringify$4;
var { isClean: isClean$2, my: my$2 } = symbols;
var CssSyntaxError$2 = cssSyntaxError;
var Stringifier2 = stringifier;
var stringify$3 = stringify_1;
function cloneNode2(obj, parent) {
  let cloned = new obj.constructor;
  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      continue;
    }
    if (i === "proxyCache")
      continue;
    let value = obj[i];
    let type = typeof value;
    if (i === "parent" && type === "object") {
      if (parent)
        cloned[i] = parent;
    } else if (i === "source") {
      cloned[i] = value;
    } else if (Array.isArray(value)) {
      cloned[i] = value.map((j) => cloneNode2(j, cloned));
    } else {
      if (type === "object" && value !== null)
        value = cloneNode2(value);
      cloned[i] = value;
    }
  }
  return cloned;
}
var Node$4 = class Node3 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2] = false;
    this[my$2] = true;
    for (let name3 in defaults) {
      if (name3 === "nodes") {
        this.nodes = [];
        for (let node of defaults[name3]) {
          if (typeof node.clone === "function") {
            this.append(node.clone());
          } else {
            this.append(node);
          }
        }
      } else {
        this[name3] = defaults[name3];
      }
    }
  }
  addToError(error2) {
    error2.postcssNode = this;
    if (error2.stack && this.source && /\n\s{4}at /.test(error2.stack)) {
      let s2 = this.source;
      error2.stack = error2.stack.replace(/\n\s{4}at /, `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`);
    }
    return error2;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name3 in overrides) {
      this[name3] = overrides[name3];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween)
      delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode2(this);
    for (let name3 in overrides) {
      cloned[name3] = overrides[name3];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(message, { column: start.column, line: start.line }, { column: end.column, line: end.line }, opts);
    }
    return new CssSyntaxError$2(message);
  }
  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === "proxyOf") {
          return node;
        } else if (prop === "root") {
          return () => node.root().toProxy();
        } else {
          return node[prop];
        }
      },
      set(node, prop, value) {
        if (node[prop] === value)
          return true;
        node[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
          node.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2]) {
      this[isClean$2] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2] = false;
      }
    }
  }
  next() {
    if (!this.parent)
      return;
    let index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1)
        pos = this.positionInside(index, stringRepresentation);
    }
    return pos;
  }
  positionInside(index, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i = 0;i < index; i++) {
      if (string[i] === `
`) {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent)
      return;
    let index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1) {
        start = this.positionInside(index, stringRepresentation);
        end = this.positionInside(index + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (opts.endIndex) {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier2;
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = undefined;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node);
          bookmark = node;
        } else {
          this.parent.insertBefore(bookmark, node);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result = this;
    while (result.parent && result.parent.type !== "document") {
      result = result.parent;
    }
    return result;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || new Map;
    let inputsNextIndex = 0;
    for (let name3 in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name3)) {
        continue;
      }
      if (name3 === "parent" || name3 === "proxyCache")
        continue;
      let value = this[name3];
      if (Array.isArray(value)) {
        fixed[name3] = value.map((i) => {
          if (typeof i === "object" && i.toJSON) {
            return i.toJSON(null, inputs);
          } else {
            return i;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name3] = value.toJSON(null, inputs);
      } else if (name3 === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name3] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name3] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3) {
    if (stringifier2.stringify)
      stringifier2 = stringifier2.stringify;
    let result = "";
    stringifier2(this, (i) => {
      result += i;
    });
    return result;
  }
  warn(result, text, opts) {
    let data = { node: this };
    for (let i in opts)
      data[i] = opts[i];
    return result.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node$2 = Node$4;
Node$4.default = Node$4;
var Node$3 = node$2;
var Declaration$4 = class Declaration extends Node$3 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration = Declaration$4;
Declaration$4.default = Declaration$4;
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_url$1);
var urlAlphabet2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var nanoid$1 = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet2[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure = { nanoid: nanoid$1, customAlphabet };
var { SourceMapConsumer: SourceMapConsumer$4, SourceMapGenerator: SourceMapGenerator$5 } = sourceMap$2;
var { existsSync, readFileSync } = require$$0$2;
var { dirname: dirname$1, join: join$2 } = require$$2$1;
function fromBase642(str) {
  if (Buffer$1) {
    return Buffer$1.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
var PreviousMap$2 = class PreviousMap {
  constructor(css2, opts) {
    if (opts.map === false)
      return;
    this.loadAnnotation(css2);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : undefined;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile)
      this.root = dirname$1(this.mapFile);
    if (text)
      this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$4(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase642(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map3) {
    if (typeof map3 !== "object")
      return false;
    return typeof map3.mappings === "string" || typeof map3._mappings === "string" || Array.isArray(map3.sections);
  }
  loadAnnotation(css2) {
    let comments = css2.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments)
      return;
    let start = css2.lastIndexOf(comments.pop());
    let end = css2.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css2.substring(start, end));
    }
  }
  loadFile(path3) {
    this.root = dirname$1(path3);
    if (existsSync(path3)) {
      this.mapFile = path3;
      return readFileSync(path3, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false)
      return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map3 = this.loadFile(prevPath);
          if (!map3) {
            throw new Error("Unable to load previous source map: " + prevPath.toString());
          }
          return map3;
        }
      } else if (prev instanceof SourceMapConsumer$4) {
        return SourceMapGenerator$5.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$5) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error("Unsupported previous source map format: " + prev.toString());
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map3 = this.annotation;
      if (file)
        map3 = join$2(dirname$1(file), map3);
      return this.loadFile(map3);
    }
  }
  startWith(string, start) {
    if (!string)
      return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap = PreviousMap$2;
PreviousMap$2.default = PreviousMap$2;
var { SourceMapConsumer: SourceMapConsumer$3, SourceMapGenerator: SourceMapGenerator$4 } = sourceMap$2;
var { fileURLToPath: fileURLToPath2, pathToFileURL: pathToFileURL$1 } = require$$2;
var { isAbsolute: isAbsolute2, resolve: resolve$1 } = require$$2$1;
var { nanoid: nanoid2 } = nonSecure;
var terminalHighlight = terminalHighlight_1;
var CssSyntaxError$1 = cssSyntaxError;
var PreviousMap$1 = previousMap;
var fromOffsetCache = Symbol("fromOffsetCache");
var sourceMapAvailable$1 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$4);
var pathAvailable$1 = Boolean(resolve$1 && isAbsolute2);
var Input$4 = class Input {
  constructor(css2, opts = {}) {
    if (css2 === null || typeof css2 === "undefined" || typeof css2 === "object" && !css2.toString) {
      throw new Error(`PostCSS received ${css2} instead of CSS string`);
    }
    this.css = css2.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute2(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1(opts.from);
      }
    }
    if (pathAvailable$1 && sourceMapAvailable$1) {
      let map3 = new PreviousMap$1(this.css, opts);
      if (map3.text) {
        this.map = map3;
        let file = map3.consumer().file;
        if (!this.file && file)
          this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid2(6) + ">";
    }
    if (this.map)
      this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result = new CssSyntaxError$1(message, origin.endLine === undefined ? origin.line : { column: origin.column, line: origin.line }, origin.endLine === undefined ? origin.column : { column: origin.endColumn, line: origin.endLine }, origin.source, origin.file, opts.plugin);
    } else {
      result = new CssSyntaxError$1(message, endLine === undefined ? line : { column, line }, endLine === undefined ? column : { column: endColumn, line: endLine }, this.css, this.file, opts.plugin);
    }
    result.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1) {
        result.input.url = pathToFileURL$1(this.file).toString();
      }
      result.input.file = this.file;
    }
    return result;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split(`
`);
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i = 0, l2 = lines.length;i < l2; i++) {
        lineToIndex[i] = prevIndex;
        prevIndex += lines[i].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map)
      return false;
    let consumer = this.map.consumer();
    let from2 = consumer.originalPositionFor({ column, line });
    if (!from2.source)
      return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute2(from2.source)) {
      fromUrl = pathToFileURL$1(from2.source);
    } else {
      fromUrl = new URL(from2.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));
    }
    let result = {
      column: from2.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from2.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath2) {
        result.file = fileURLToPath2(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from2.source);
    if (source)
      result.source = source;
    return result;
  }
  toJSON() {
    let json = {};
    for (let name3 of ["hasBOM", "css", "file", "id"]) {
      if (this[name3] != null) {
        json[name3] = this[name3];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input = Input$4;
Input$4.default = Input$4;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input$4);
}
var { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$3 } = sourceMap$2;
var { dirname: dirname2, relative, resolve: resolve2, sep: sep2 } = require$$2$1;
var { pathToFileURL: pathToFileURL2 } = require$$2;
var Input$3 = input;
var sourceMapAvailable = Boolean(SourceMapConsumer$2 && SourceMapGenerator$3);
var pathAvailable = Boolean(dirname2 && resolve2 && relative && sep2);
var MapGenerator$2 = class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
    this.css = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = new Map;
    this.memoizedPaths = new Map;
    this.memoizedURLs = new Map;
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = `
`;
    if (this.css.includes(`\r
`))
      eol = `\r
`;
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from2 = this.toUrl(this.path(prev.file));
      let root = prev.root || dirname2(prev.file);
      let map3;
      if (this.mapOpts.sourcesContent === false) {
        map3 = new SourceMapConsumer$2(prev.text);
        if (map3.sourcesContent) {
          map3.sourcesContent = map3.sourcesContent.map(() => null);
        }
      } else {
        map3 = prev.consumer();
      }
      this.map.applySourceMap(map3, from2, this.toUrl(this.path(root)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false)
      return;
    if (this.root) {
      let node;
      for (let i = this.root.nodes.length - 1;i >= 0; i--) {
        node = this.root.nodes[i];
        if (node.type !== "comment")
          continue;
        if (node.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result = "";
      this.stringify(this.root, (i) => {
        result += i;
      });
      return [result];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator$3.fromSourceMap(prev);
    } else {
      this.map = new SourceMapGenerator$3({ file: this.outputFile() });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent())
      this.setSourcesContent();
    if (this.root && this.previous().length > 0)
      this.applyPrevMaps();
    if (this.isAnnotation())
      this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator$3({ file: this.outputFile() });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last2;
    this.stringify(this.root, (str, node, type) => {
      this.css += str;
      if (node && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node);
          mapping.original.line = node.source.start.line;
          mapping.original.column = node.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last2 = str.lastIndexOf(`
`);
        column = str.length - last2;
      } else {
        column += str.length;
      }
      if (node && type !== "start") {
        let p2 = node.parent || { raws: {} };
        let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
        if (!childless || node !== p2.last || p2.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node);
            mapping.original.line = node.source.end.line;
            mapping.original.column = node.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i) => i.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i) => i.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i) => i.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute)
      return file;
    if (file.charCodeAt(0) === 60)
      return file;
    if (/^\w+:\/\//.test(file))
      return file;
    let cached = this.memoizedPaths.get(file);
    if (cached)
      return cached;
    let from2 = this.opts.to ? dirname2(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from2 = dirname2(resolve2(from2, this.mapOpts.annotation));
    }
    let path3 = relative(from2, file);
    this.memoizedPaths.set(file, path3);
    return path3;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node) => {
          if (node.source && node.source.input.map) {
            let map3 = node.source.input.map;
            if (!this.previousMaps.includes(map3)) {
              this.previousMaps.push(map3);
            }
          }
        });
      } else {
        let input2 = new Input$3(this.css, this.opts);
        if (input2.map)
          this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node) => {
        if (node.source) {
          let from2 = node.source.input.from;
          if (from2 && !already[from2]) {
            already[from2] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from2) : this.toUrl(this.path(from2));
            this.map.setSourceContent(fromUrl, node.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from2, this.css);
    }
  }
  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from);
    } else {
      return this.toUrl(this.path(node.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer$1) {
      return Buffer$1.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path3) {
    let cached = this.memoizedFileURLs.get(path3);
    if (cached)
      return cached;
    if (pathToFileURL2) {
      let fileURL = pathToFileURL2(path3).toString();
      this.memoizedFileURLs.set(path3, fileURL);
      return fileURL;
    } else {
      throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
  }
  toUrl(path3) {
    let cached = this.memoizedURLs.get(path3);
    if (cached)
      return cached;
    if (sep2 === "\\") {
      path3 = path3.replace(/\\/g, "/");
    }
    let url = encodeURI(path3).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path3, url);
    return url;
  }
};
var mapGenerator = MapGenerator$2;
var Node$2 = node$2;
var Comment$4 = class Comment2 extends Node$2 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment$3 = Comment$4;
Comment$4.default = Comment$4;
var { isClean: isClean$1, my: my$1 } = symbols;
var Declaration$3 = declaration;
var Comment$3 = comment$3;
var Node$1 = node$2;
var parse$4;
var Rule$4;
var AtRule$4;
var Root$6;
function cleanSource(nodes) {
  return nodes.map((i) => {
    if (i.nodes)
      i.nodes = cleanSource(i.nodes);
    delete i.source;
    return i;
  });
}
function markDirtyUp(node) {
  node[isClean$1] = false;
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markDirtyUp(i);
    }
  }
}
var Container$7 = class Container extends Node$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node of nodes)
        this.proxyOf.nodes.push(node);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node of this.nodes)
        node.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes)
      return;
    let iterator = this.getIterator();
    let index, result;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator];
      result = callback(this.proxyOf.nodes[index], index);
      if (result === false)
        break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach)
      this.lastEach = 0;
    if (!this.indexes)
      this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === "proxyOf") {
          return node;
        } else if (!node[prop]) {
          return node[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node[prop](...args.map((i) => {
              if (typeof i === "function") {
                return (child, index) => i(child.toProxy(), index);
              } else {
                return i;
              }
            }));
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
          };
        } else if (prop === "root") {
          return () => node.root().toProxy();
        } else if (prop === "nodes") {
          return node.nodes.map((i) => i.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node[prop].toProxy();
        } else {
          return node[prop];
        }
      },
      set(node, prop, value) {
        if (node[prop] === value)
          return true;
        node[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number")
      return child;
    if (child.proxyOf)
      child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node of nodes)
      this.proxyOf.nodes.splice(existIndex + 1, 0, node);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node of nodes)
      this.proxyOf.nodes.splice(existIndex, 0, node);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource(parse$4(nodes).nodes);
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i of nodes) {
        if (i.parent)
          i.parent.removeChild(i, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i of nodes) {
        if (i.parent)
          i.parent.removeChild(i, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i) => {
      if (!i[my$1])
        Container.rebuild(i);
      i = i.proxyOf;
      if (i.parent)
        i.parent.removeChild(i);
      if (i[isClean$1])
        markDirtyUp(i);
      if (typeof i.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i.parent = this.proxyOf;
      return i;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node of nodes)
        this.proxyOf.nodes.unshift(node);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node of this.proxyOf.nodes)
      node.parent = undefined;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = undefined;
    this.proxyOf.nodes.splice(child, 1);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern2, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop))
        return;
      if (opts.fast && !decl.value.includes(opts.fast))
        return;
      decl.value = decl.value.replace(pattern2, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i) => {
      let result;
      try {
        result = callback(child, i);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result !== false && child.walk) {
        result = child.walk(callback);
      }
      return result;
    });
  }
  walkAtRules(name3, callback) {
    if (!callback) {
      callback = name3;
      return this.walk((child, i) => {
        if (child.type === "atrule") {
          return callback(child, i);
        }
      });
    }
    if (name3 instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === "atrule" && name3.test(child.name)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === "atrule" && child.name === name3) {
        return callback(child, i);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === "comment") {
        return callback(child, i);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i) => {
        if (child.type === "decl") {
          return callback(child, i);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i) => {
        if (child.type === "rule") {
          return callback(child, i);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes)
      return;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes)
      return;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7.registerParse = (dependant) => {
  parse$4 = dependant;
};
Container$7.registerRule = (dependant) => {
  Rule$4 = dependant;
};
Container$7.registerAtRule = (dependant) => {
  AtRule$4 = dependant;
};
Container$7.registerRoot = (dependant) => {
  Root$6 = dependant;
};
var container$1 = Container$7;
Container$7.default = Container$7;
Container$7.rebuild = (node) => {
  if (node.type === "atrule") {
    Object.setPrototypeOf(node, AtRule$4.prototype);
  } else if (node.type === "rule") {
    Object.setPrototypeOf(node, Rule$4.prototype);
  } else if (node.type === "decl") {
    Object.setPrototypeOf(node, Declaration$3.prototype);
  } else if (node.type === "comment") {
    Object.setPrototypeOf(node, Comment$3.prototype);
  } else if (node.type === "root") {
    Object.setPrototypeOf(node, Root$6.prototype);
  }
  node[my$1] = true;
  if (node.nodes) {
    node.nodes.forEach((child) => {
      Container$7.rebuild(child);
    });
  }
};
var Container$6 = container$1;
var LazyResult$4;
var Processor$3;
var Document$3 = class Document2 extends Container$6 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4(new Processor$3, this, opts);
    return lazy.stringify();
  }
};
Document$3.registerLazyResult = (dependant) => {
  LazyResult$4 = dependant;
};
Document$3.registerProcessor = (dependant) => {
  Processor$3 = dependant;
};
var document2 = Document$3;
Document$3.default = Document$3;
var printed = {};
var warnOnce$3 = function warnOnce(message) {
  if (printed[message])
    return;
  printed[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
var Warning$2 = class Warning {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range2 = opts.node.rangeBy(opts);
      this.line = range2.start.line;
      this.column = range2.start.column;
      this.endLine = range2.end.line;
      this.endColumn = range2.end.column;
    }
    for (let opt in opts)
      this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning = Warning$2;
Warning$2.default = Warning$2;
var Warning$1 = warning;
var Result$3 = class Result {
  constructor(processor, root, opts) {
    this.processor = processor;
    this.messages = [];
    this.root = root;
    this.opts = opts;
    this.css = undefined;
    this.map = undefined;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i) => i.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result = Result$3;
Result$3.default = Result$3;
var Container$5 = container$1;
var AtRule$3 = class AtRule extends Container$5 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes)
      this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes)
      this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule = AtRule$3;
AtRule$3.default = AtRule$3;
Container$5.registerAtRule(AtRule$3);
var Container$4 = container$1;
var LazyResult$3;
var Processor$2;
var Root$5 = class Root2 extends Container$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes)
      this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index = this.index(child);
    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3(new Processor$2, this, opts);
    return lazy.stringify();
  }
};
Root$5.registerLazyResult = (dependant) => {
  LazyResult$3 = dependant;
};
Root$5.registerProcessor = (dependant) => {
  Processor$2 = dependant;
};
var root$2 = Root$5;
Root$5.default = Root$5;
Container$4.registerRoot(Root$5);
var list$2 = {
  comma(string) {
    return list$2.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", `
`, "\t"];
    return list$2.split(string, spaces);
  },
  split(string, separators, last2) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape3 = false;
    for (let letter of string) {
      if (escape3) {
        escape3 = false;
      } else if (letter === "\\") {
        escape3 = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0)
          func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter))
          split = true;
      }
      if (split) {
        if (current !== "")
          array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last2 || current !== "")
      array.push(current.trim());
    return array;
  }
};
var list_1 = list$2;
list$2.default = list$2;
var Container$3 = container$1;
var list$1 = list_1;
var Rule$3 = class Rule extends Container$3 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes)
      this.nodes = [];
  }
  get selectors() {
    return list$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep3 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep3);
  }
};
var rule = Rule$3;
Rule$3.default = Rule$3;
Container$3.registerRule(Rule$3);
var Declaration$2 = declaration;
var tokenizer3 = tokenize$1;
var Comment$2 = comment$3;
var AtRule$2 = atRule;
var Root$4 = root$2;
var Rule$2 = rule;
var SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1;i >= 0; i--) {
    let token2 = tokens[i];
    let pos = token2[3] || token2[2];
    if (pos)
      return pos;
  }
}
var Parser$12 = class Parser4 {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4;
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.customProperty = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token2) {
    let node = new AtRule$2;
    node.name = token2[1].slice(1);
    if (node.name === "") {
      this.unnamedAtrule(node, token2);
    }
    this.init(node, token2[2]);
    let type;
    let prev;
    let shift;
    let last2 = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token2 = this.tokenizer.nextToken();
      type = token2[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node.source.end = this.getPosition(token2[2]);
          node.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2]);
              node.source.end.offset++;
            }
          }
          this.end(token2);
          break;
        } else {
          params.push(token2);
        }
      } else {
        params.push(token2);
      }
      if (this.tokenizer.endOfFile()) {
        last2 = true;
        break;
      }
    }
    node.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node, "params", params);
      if (last2) {
        token2 = params[params.length - 1];
        node.source.end = this.getPosition(token2[3] || token2[2]);
        node.source.end.offset++;
        this.spaces = node.raws.between;
        node.raws.between = "";
      }
    } else {
      node.raws.afterName = "";
      node.params = "";
    }
    if (open) {
      node.nodes = [];
      this.current = node;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false)
      return;
    let founded = 0;
    let token2;
    for (let j = colon - 1;j >= 0; j--) {
      token2 = tokens[j];
      if (token2[0] !== "space") {
        founded += 1;
        if (founded === 2)
          break;
      }
    }
    throw this.input.error("Missed semicolon", token2[0] === "word" ? token2[3] + 1 : token2[2]);
  }
  colon(tokens) {
    let brackets = 0;
    let token2, type, prev;
    for (let [i, element] of tokens.entries()) {
      token2 = element;
      type = token2[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token2);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i;
        }
      }
      prev = token2;
    }
    return false;
  }
  comment(token2) {
    let node = new Comment$2;
    this.init(node, token2[2]);
    node.source.end = this.getPosition(token2[3] || token2[2]);
    node.source.end.offset++;
    let text = token2[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node.text = "";
      node.raws.left = text;
      node.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node.text = match[2];
      node.raws.left = match[1];
      node.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer3(this.input);
  }
  decl(tokens, customProperty) {
    let node = new Declaration$2;
    this.init(node, tokens[0][2]);
    let last2 = tokens[tokens.length - 1];
    if (last2[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node.source.end = this.getPosition(last2[3] || last2[2] || findLastWithPosition(tokens));
    node.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1)
        this.unknownWord(tokens);
      node.raws.before += tokens.shift()[1];
    }
    node.source.start = this.getPosition(tokens[0][2]);
    node.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node.prop += tokens.shift()[1];
    }
    node.raws.between = "";
    let token2;
    while (tokens.length) {
      token2 = tokens.shift();
      if (token2[0] === ":") {
        node.raws.between += token2[1];
        break;
      } else {
        if (token2[0] === "word" && /\w/.test(token2[1])) {
          this.unknownWord([token2]);
        }
        node.raws.between += token2[1];
      }
    }
    if (node.prop[0] === "_" || node.prop[0] === "*") {
      node.raws.before += node.prop[0];
      node.prop = node.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment")
        break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i = tokens.length - 1;i >= 0; i--) {
      token2 = tokens[i];
      if (token2[1].toLowerCase() === "!important") {
        node.important = true;
        let string = this.stringFrom(tokens, i);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important")
          node.raws.important = string;
        break;
      } else if (token2[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i;j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node.important = true;
          node.raws.important = str;
          tokens = cache;
        }
      }
      if (token2[0] !== "space" && token2[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
    if (hasWord) {
      node.raws.between += firstSpaces.map((i) => i[1]).join("");
      firstSpaces = [];
    }
    this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
    if (node.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token2) {
    throw this.input.error("Double colon", { offset: token2[2] }, { offset: token2[2] + token2[1].length });
  }
  emptyRule(token2) {
    let node = new Rule$2;
    this.init(node, token2[2]);
    node.selector = "";
    node.raws.between = "";
    this.current = node;
  }
  end(token2) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token2[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token2);
    }
  }
  endFile() {
    if (this.current.parent)
      this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token2) {
    this.spaces += token2[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node, offset) {
    this.current.push(node);
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node.raws.before = this.spaces;
    this.spaces = "";
    if (node.type !== "comment")
      this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token2 = start;
    while (token2) {
      type = token2[0];
      tokens.push(token2);
      if (type === "(" || type === "[") {
        if (!bracket)
          bracket = token2;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket)
          bracket = token2;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0)
          bracket = null;
      }
      token2 = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile())
      end = true;
    if (brackets.length > 0)
      this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token2 = tokens[tokens.length - 1][0];
          if (token2 !== "space" && token2 !== "comment")
            break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token2;
    while (!this.tokenizer.endOfFile()) {
      token2 = this.tokenizer.nextToken();
      switch (token2[0]) {
        case "space":
          this.spaces += token2[1];
          break;
        case ";":
          this.freeSemicolon(token2);
          break;
        case "}":
          this.end(token2);
          break;
        case "comment":
          this.comment(token2);
          break;
        case "at-word":
          this.atrule(token2);
          break;
        case "{":
          this.emptyRule(token2);
          break;
        default:
          this.other(token2);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {}
  raw(node, prop, tokens, customProperty) {
    let token2, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i = 0;i < length; i += 1) {
      token2 = tokens[i];
      type = token2[0];
      if (type === "space" && i === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
        next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token2[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token2[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all2, i) => all2 + i[1], "");
      node.raws[prop] = { raw, value };
    }
    node[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node = new Rule$2;
    this.init(node, tokens[0][2]);
    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node, "selector", tokens);
    this.current = node;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment")
        break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment")
        break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space")
        break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from2) {
    let result2 = "";
    for (let i = from2;i < tokens.length; i++) {
      result2 += tokens[i][1];
    }
    tokens.splice(from2, tokens.length - from2);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
  }
  unexpectedClose(token2) {
    throw this.input.error("Unexpected }", { offset: token2[2] }, { offset: token2[2] + 1 });
  }
  unknownWord(tokens) {
    throw this.input.error("Unknown word", { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
  }
  unnamedAtrule(node, token2) {
    throw this.input.error("At-rule without name", { offset: token2[2] }, { offset: token2[2] + token2[1].length });
  }
};
var parser$1 = Parser$12;
var Container$2 = container$1;
var Parser5 = parser$1;
var Input$2 = input;
function parse$3(css2, opts) {
  let input2 = new Input$2(css2, opts);
  let parser = new Parser5(input2);
  try {
    parser.parse();
  } catch (e2) {
    if (browser$1.env.NODE_ENV !== "production") {
      if (e2.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e2.message += `
You tried to parse SCSS with ` + "the standard CSS parser; " + "try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e2.message += `
You tried to parse Sass with ` + "the standard CSS parser; " + "try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e2.message += `
You tried to parse Less with ` + "the standard CSS parser; " + "try again with the postcss-less parser";
        }
      }
    }
    throw e2;
  }
  return parser.root;
}
var parse_1 = parse$3;
parse$3.default = parse$3;
Container$2.registerParse(parse$3);
var { isClean, my } = symbols;
var MapGenerator$1 = mapGenerator;
var stringify$2 = stringify_1;
var Container$1 = container$1;
var Document$2 = document2;
var warnOnce$2 = warnOnce$3;
var Result$2 = result;
var parse$2 = parse_1;
var Root$3 = root$2;
var TYPE_TO_CLASS_NAME = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
var PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
var NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
var CHILDREN = 0;
function isPromise$2(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents(node) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME[node.type];
  if (node.type === "decl") {
    key = node.prop.toLowerCase();
  } else if (node.type === "atrule") {
    key = node.name.toLowerCase();
  }
  if (key && node.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node.append) {
    return [type, CHILDREN, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack(node) {
  let events;
  if (node.type === "document") {
    events = ["Document", CHILDREN, "DocumentExit"];
  } else if (node.type === "root") {
    events = ["Root", CHILDREN, "RootExit"];
  } else {
    events = getEvents(node);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node) {
  node[isClean] = false;
  if (node.nodes)
    node.nodes.forEach((i) => cleanMarks(i));
  return node;
}
var postcss$2 = {};
var LazyResult$2 = class LazyResult {
  constructor(processor, css2, opts) {
    this.stringified = false;
    this.processed = false;
    let root;
    if (typeof css2 === "object" && css2 !== null && (css2.type === "root" || css2.type === "document")) {
      root = cleanMarks(css2);
    } else if (css2 instanceof LazyResult || css2 instanceof Result$2) {
      root = cleanMarks(css2.root);
      if (css2.map) {
        if (typeof opts.map === "undefined")
          opts.map = {};
        if (!opts.map.inline)
          opts.map.inline = false;
        opts.map.prev = css2.map;
      }
    } else {
      let parser = parse$2;
      if (opts.syntax)
        parser = opts.syntax.parse;
      if (opts.parser)
        parser = opts.parser;
      if (parser.parse)
        parser = parser.parse;
      try {
        root = parser(css2, opts);
      } catch (error2) {
        this.processed = true;
        this.error = error2;
      }
      if (root && !root[my]) {
        Container$1.rebuild(root);
      }
    }
    this.result = new Result$2(processor, root, opts);
    this.helpers = { ...postcss$2, postcss: postcss$2, result: this.result };
    this.plugins = this.processor.plugins.map((plugin) => {
      if (typeof plugin === "object" && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) };
      } else {
        return plugin;
      }
    });
  }
  async() {
    if (this.error)
      return Promise.reject(this.error);
    if (this.processed)
      return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error2, node) {
    let plugin = this.result.lastPlugin;
    try {
      if (node)
        node.addToError(error2);
      this.error = error2;
      if (error2.name === "CssSyntaxError" && !error2.plugin) {
        error2.plugin = plugin.postcssPlugin;
        error2.setMessage();
      } else if (plugin.postcssVersion) {
        if (browser$1.env.NODE_ENV !== "production") {
          let pluginName = plugin.postcssPlugin;
          let pluginVer = plugin.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            console.error("Unknown error from PostCSS plugin. Your current PostCSS " + "version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
          }
        }
      }
    } catch (err) {
      if (console && console.error)
        console.error(err);
    }
    return error2;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin, type, cb) => {
      if (!this.listeners[type])
        this.listeners[type] = [];
      this.listeners[type].push([plugin, cb]);
    };
    for (let plugin of this.plugins) {
      if (typeof plugin === "object") {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === "object") {
              for (let filter2 in plugin[event]) {
                if (filter2 === "*") {
                  add(plugin, event, plugin[event][filter2]);
                } else {
                  add(plugin, event + "-" + filter2.toLowerCase(), plugin[event][filter2]);
                }
              }
            } else if (typeof plugin[event] === "function") {
              add(plugin, event, plugin[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i = 0;i < this.plugins.length; i++) {
      let plugin = this.plugins[i];
      let promise = this.runOnRoot(plugin);
      if (isPromise$2(promise)) {
        try {
          await promise;
        } catch (error2) {
          throw this.handleError(error2);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root = this.result.root;
      while (!root[isClean]) {
        root[isClean] = true;
        let stack = [toStack(root)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise$2(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node = stack[stack.length - 1].node;
              throw this.handleError(e2, node);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin;
          try {
            if (root.type === "document") {
              let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
              await Promise.all(roots);
            } else {
              await visitor(root, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin) {
    this.result.lastPlugin = plugin;
    try {
      if (typeof plugin === "object" && plugin.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
          if (isPromise$2(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin.Once(this.result.root, this.helpers);
      } else if (typeof plugin === "function") {
        return plugin(this.result.root, this.result);
      }
    } catch (error2) {
      throw this.handleError(error2);
    }
  }
  stringify() {
    if (this.error)
      throw this.error;
    if (this.stringified)
      return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2;
    if (opts.syntax)
      str = opts.syntax.stringify;
    if (opts.stringifier)
      str = opts.stringifier;
    if (str.stringify)
      str = str.stringify;
    let map3 = new MapGenerator$1(str, this.result.root, this.result.opts);
    let data = map3.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error)
      throw this.error;
    if (this.processed)
      return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin);
      if (isPromise$2(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root = this.result.root;
      while (!root[isClean]) {
        root[isClean] = true;
        this.walkSync(root);
      }
      if (this.listeners.OnceExit) {
        if (root.type === "document") {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (browser$1.env.NODE_ENV !== "production") {
      if (!("from" in this.opts)) {
        warnOnce$2("Without `from` option PostCSS could generate wrong source map " + "and will not find Browserslist config. Set it to CSS file path " + "or to `undefined` to prevent this warning.");
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin;
      let promise;
      try {
        promise = visitor(node, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node.proxyOf);
      }
      if (node.type !== "root" && node.type !== "document" && !node.parent) {
        return true;
      }
      if (isPromise$2(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit = stack[stack.length - 1];
    let { node, visitors } = visit;
    if (node.type !== "root" && node.type !== "document" && !node.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex];
      visit.visitorIndex += 1;
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = [];
        visit.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin;
      try {
        return visitor(node.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node);
      }
    }
    if (visit.iterator !== 0) {
      let iterator = visit.iterator;
      let child;
      while (child = node.nodes[node.indexes[iterator]]) {
        node.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit.iterator = 0;
      delete node.indexes[iterator];
    }
    let events = visit.events;
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex];
      visit.eventIndex += 1;
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true;
          visit.iterator = node.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node) {
    node[isClean] = true;
    let events = getEvents(node);
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each((child) => {
            if (!child[isClean])
              this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy()))
            return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2.registerPostcss = (dependant) => {
  postcss$2 = dependant;
};
var lazyResult = LazyResult$2;
LazyResult$2.default = LazyResult$2;
Root$3.registerLazyResult(LazyResult$2);
Document$2.registerLazyResult(LazyResult$2);
var MapGenerator2 = mapGenerator;
var stringify$1 = stringify_1;
var warnOnce$1 = warnOnce$3;
var parse$1 = parse_1;
var Result$1 = result;
var NoWorkResult$1 = class NoWorkResult {
  constructor(processor, css2, opts) {
    css2 = css2.toString();
    this.stringified = false;
    this._processor = processor;
    this._css = css2;
    this._opts = opts;
    this._map = undefined;
    let root;
    let str = stringify$1;
    this.result = new Result$1(this._processor, root, this._opts);
    this.result.css = css2;
    let self2 = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self2.root;
      }
    });
    let map3 = new MapGenerator2(str, root, this._opts, css2);
    if (map3.isMap()) {
      let [generatedCSS, generatedMap] = map3.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    }
  }
  async() {
    if (this.error)
      return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error)
      throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (browser$1.env.NODE_ENV !== "production") {
      if (!("from" in this._opts)) {
        warnOnce$1("Without `from` option PostCSS could generate wrong source map " + "and will not find Browserslist config. Set it to CSS file path " + "or to `undefined` to prevent this warning.");
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root;
    let parser = parse$1;
    try {
      root = parser(this._css, this._opts);
    } catch (error2) {
      this.error = error2;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root;
      return root;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult = NoWorkResult$1;
NoWorkResult$1.default = NoWorkResult$1;
var NoWorkResult2 = noWorkResult;
var LazyResult$1 = lazyResult;
var Document$1 = document2;
var Root$2 = root$2;
var Processor$1 = class Processor {
  constructor(plugins = []) {
    this.version = "8.4.31";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i();
      } else if (i.postcss) {
        i = i.postcss;
      }
      if (typeof i === "object" && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === "object" && i.postcssPlugin) {
        normalized.push(i);
      } else if (typeof i === "function") {
        normalized.push(i);
      } else if (typeof i === "object" && (i.parse || i.stringify)) {
        if (browser$1.env.NODE_ENV !== "production") {
          throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use " + "one of the syntax/parser/stringifier options as outlined " + "in your PostCSS runner documentation.");
        }
      } else {
        throw new Error(i + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css2, opts = {}) {
    if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
      return new NoWorkResult2(this, css2, opts);
    } else {
      return new LazyResult$1(this, css2, opts);
    }
  }
  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  }
};
var processor$1 = Processor$1;
Processor$1.default = Processor$1;
Root$2.registerProcessor(Processor$1);
Document$1.registerProcessor(Processor$1);
var Declaration$1 = declaration;
var PreviousMap2 = previousMap;
var Comment$12 = comment$3;
var AtRule$1 = atRule;
var Input$1 = input;
var Root$1 = root$2;
var Rule$1 = rule;
function fromJSON$1(json, inputs) {
  if (Array.isArray(json))
    return json.map((n2) => fromJSON$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap2.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$12(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1 = fromJSON$1;
fromJSON$1.default = fromJSON$1;
var CssSyntaxError2 = cssSyntaxError;
var Declaration2 = declaration;
var LazyResult2 = lazyResult;
var Container2 = container$1;
var Processor2 = processor$1;
var stringify = stringify_1;
var fromJSON = fromJSON_1;
var Document3 = document2;
var Warning2 = warning;
var Comment3 = comment$3;
var AtRule2 = atRule;
var Result2 = result;
var Input2 = input;
var parse$a = parse_1;
var list = list_1;
var Rule2 = rule;
var Root3 = root$2;
var Node4 = node$2;
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor2(plugins);
}
postcss.plugin = function plugin(name3, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(name3 + `: postcss.plugin was deprecated. Migration guide:
` + "https://evilmartians.com/chronicles/postcss-8-plugin-migration");
      if (browser$1.env.LANG && browser$1.env.LANG.startsWith("cn")) {
        console.warn(name3 + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
` + "https://www.w3ctech.com/topic/2226");
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name3;
    transformer.postcssVersion = new Processor2().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache)
        cache = creator();
      return cache;
    }
  });
  creator.process = function(css2, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css2, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse$a;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = (defaults) => new Comment3(defaults);
postcss.atRule = (defaults) => new AtRule2(defaults);
postcss.decl = (defaults) => new Declaration2(defaults);
postcss.rule = (defaults) => new Rule2(defaults);
postcss.root = (defaults) => new Root3(defaults);
postcss.document = (defaults) => new Document3(defaults);
postcss.CssSyntaxError = CssSyntaxError2;
postcss.Declaration = Declaration2;
postcss.Container = Container2;
postcss.Processor = Processor2;
postcss.Document = Document3;
postcss.Comment = Comment3;
postcss.Warning = Warning2;
postcss.AtRule = AtRule2;
postcss.Result = Result2;
postcss.Input = Input2;
postcss.Rule = Rule2;
postcss.Root = Root3;
postcss.Node = Node4;
LazyResult2.registerPostcss(postcss);
var postcss_1 = postcss;
postcss.default = postcss;
var postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs2(postcss_1);
postcss$1.stringify;
postcss$1.fromJSON;
postcss$1.plugin;
postcss$1.parse;
postcss$1.list;
postcss$1.document;
postcss$1.comment;
postcss$1.atRule;
postcss$1.rule;
postcss$1.decl;
postcss$1.root;
postcss$1.CssSyntaxError;
postcss$1.Declaration;
postcss$1.Container;
postcss$1.Processor;
postcss$1.Document;
postcss$1.Comment;
postcss$1.Warning;
postcss$1.AtRule;
postcss$1.Result;
postcss$1.Input;
postcss$1.Rule;
postcss$1.Root;
postcss$1.Node;
var trimPlugin = () => {
  return {
    postcssPlugin: "vue-sfc-trim",
    Once(root) {
      root.walk(({ type, raws }) => {
        if (type === "rule" || type === "atrule") {
          if (raws.before)
            raws.before = `
`;
          if ("after" in raws && raws.after)
            raws.after = `
`;
        }
      });
    }
  };
};
trimPlugin.postcss = true;
var trimPlugin$1 = trimPlugin;
var dist = { exports: {} };
var processor = { exports: {} };
var parser = { exports: {} };
var root$1 = { exports: {} };
var container = { exports: {} };
var node$1 = { exports: {} };
var util$6 = {};
var unesc = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = unesc2;
  function gobbleHex(str) {
    var lower = str.toLowerCase();
    var hex = "";
    var spaceTerminated = false;
    for (var i = 0;i < 6 && lower[i] !== undefined; i++) {
      var code = lower.charCodeAt(i);
      var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
      spaceTerminated = code === 32;
      if (!valid) {
        break;
      }
      hex += lower[i];
    }
    if (hex.length === 0) {
      return;
    }
    var codePoint = parseInt(hex, 16);
    var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
    if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
      return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
    }
    return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
  }
  var CONTAINS_ESCAPE = /\\/;
  function unesc2(str) {
    var needToProcess = CONTAINS_ESCAPE.test(str);
    if (!needToProcess) {
      return str;
    }
    var ret = "";
    for (var i = 0;i < str.length; i++) {
      if (str[i] === "\\") {
        var gobbled = gobbleHex(str.slice(i + 1, i + 7));
        if (gobbled !== undefined) {
          ret += gobbled[0];
          i += gobbled[1];
          continue;
        }
        if (str[i + 1] === "\\") {
          ret += "\\";
          i++;
          continue;
        }
        if (str.length === i + 1) {
          ret += str[i];
        }
        continue;
      }
      ret += str[i];
    }
    return ret;
  }
  module.exports = exports.default;
})(unesc, unesc.exports);
var unescExports = unesc.exports;
var getProp = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = getProp2;
  function getProp2(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }
    while (props.length > 0) {
      var prop = props.shift();
      if (!obj[prop]) {
        return;
      }
      obj = obj[prop];
    }
    return obj;
  }
  module.exports = exports.default;
})(getProp, getProp.exports);
var getPropExports = getProp.exports;
var ensureObject = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = ensureObject2;
  function ensureObject2(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }
    while (props.length > 0) {
      var prop = props.shift();
      if (!obj[prop]) {
        obj[prop] = {};
      }
      obj = obj[prop];
    }
  }
  module.exports = exports.default;
})(ensureObject, ensureObject.exports);
var ensureObjectExports = ensureObject.exports;
var stripComments = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = stripComments2;
  function stripComments2(str) {
    var s2 = "";
    var commentStart = str.indexOf("/*");
    var lastEnd = 0;
    while (commentStart >= 0) {
      s2 = s2 + str.slice(lastEnd, commentStart);
      var commentEnd = str.indexOf("*/", commentStart + 2);
      if (commentEnd < 0) {
        return s2;
      }
      lastEnd = commentEnd + 2;
      commentStart = str.indexOf("/*", lastEnd);
    }
    s2 = s2 + str.slice(lastEnd);
    return s2;
  }
  module.exports = exports.default;
})(stripComments, stripComments.exports);
var stripCommentsExports = stripComments.exports;
util$6.__esModule = true;
util$6.unesc = util$6.stripComments = util$6.getProp = util$6.ensureObject = undefined;
var _unesc = _interopRequireDefault$1(unescExports);
util$6.unesc = _unesc["default"];
var _getProp = _interopRequireDefault$1(getPropExports);
util$6.getProp = _getProp["default"];
var _ensureObject = _interopRequireDefault$1(ensureObjectExports);
util$6.ensureObject = _ensureObject["default"];
var _stripComments = _interopRequireDefault$1(stripCommentsExports);
util$6.stripComments = _stripComments["default"];
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _util = util$6;
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var cloneNode3 = function cloneNode(obj, parent) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var cloned = new obj.constructor;
    for (var i in obj) {
      if (!obj.hasOwnProperty(i)) {
        continue;
      }
      var value = obj[i];
      var type = typeof value;
      if (i === "parent" && type === "object") {
        if (parent) {
          cloned[i] = parent;
        }
      } else if (value instanceof Array) {
        cloned[i] = value.map(function(j) {
          return cloneNode(j, cloned);
        });
      } else {
        cloned[i] = cloneNode(value, cloned);
      }
    }
    return cloned;
  };
  var Node5 = /* @__PURE__ */ function() {
    function Node6(opts) {
      if (opts === undefined) {
        opts = {};
      }
      Object.assign(this, opts);
      this.spaces = this.spaces || {};
      this.spaces.before = this.spaces.before || "";
      this.spaces.after = this.spaces.after || "";
    }
    var _proto = Node6.prototype;
    _proto.remove = function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this.parent = undefined;
      return this;
    };
    _proto.replaceWith = function replaceWith() {
      if (this.parent) {
        for (var index in arguments) {
          this.parent.insertBefore(this, arguments[index]);
        }
        this.remove();
      }
      return this;
    };
    _proto.next = function next() {
      return this.parent.at(this.parent.index(this) + 1);
    };
    _proto.prev = function prev() {
      return this.parent.at(this.parent.index(this) - 1);
    };
    _proto.clone = function clone(overrides) {
      if (overrides === undefined) {
        overrides = {};
      }
      var cloned = cloneNode3(this);
      for (var name3 in overrides) {
        cloned[name3] = overrides[name3];
      }
      return cloned;
    };
    _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name3, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }
      var originalValue = this[name3];
      var originalEscaped = this.raws[name3];
      this[name3] = originalValue + value;
      if (originalEscaped || valueEscaped !== value) {
        this.raws[name3] = (originalEscaped || originalValue) + valueEscaped;
      } else {
        delete this.raws[name3];
      }
    };
    _proto.setPropertyAndEscape = function setPropertyAndEscape(name3, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }
      this[name3] = value;
      this.raws[name3] = valueEscaped;
    };
    _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name3, value) {
      this[name3] = value;
      if (this.raws) {
        delete this.raws[name3];
      }
    };
    _proto.isAtPosition = function isAtPosition(line, column) {
      if (this.source && this.source.start && this.source.end) {
        if (this.source.start.line > line) {
          return false;
        }
        if (this.source.end.line < line) {
          return false;
        }
        if (this.source.start.line === line && this.source.start.column > column) {
          return false;
        }
        if (this.source.end.line === line && this.source.end.column < column) {
          return false;
        }
        return true;
      }
      return;
    };
    _proto.stringifyProperty = function stringifyProperty(name3) {
      return this.raws && this.raws[name3] || this[name3];
    };
    _proto.valueToString = function valueToString() {
      return String(this.stringifyProperty("value"));
    };
    _proto.toString = function toString() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    };
    _createClass(Node6, [{
      key: "rawSpaceBefore",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
        if (rawSpace === undefined) {
          rawSpace = this.spaces && this.spaces.before;
        }
        return rawSpace || "";
      },
      set: function set(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.before = raw;
      }
    }, {
      key: "rawSpaceAfter",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
        if (rawSpace === undefined) {
          rawSpace = this.spaces.after;
        }
        return rawSpace || "";
      },
      set: function set(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.after = raw;
      }
    }]);
    return Node6;
  }();
  exports["default"] = Node5;
  module.exports = exports.default;
})(node$1, node$1.exports);
var nodeExports = node$1.exports;
var types4 = {};
types4.__esModule = true;
types4.UNIVERSAL = types4.TAG = types4.STRING = types4.SELECTOR = types4.ROOT = types4.PSEUDO = types4.NESTING = types4.ID = types4.COMMENT = types4.COMBINATOR = types4.CLASS = types4.ATTRIBUTE = undefined;
var TAG = "tag";
types4.TAG = TAG;
var STRING = "string";
types4.STRING = STRING;
var SELECTOR = "selector";
types4.SELECTOR = SELECTOR;
var ROOT = "root";
types4.ROOT = ROOT;
var PSEUDO = "pseudo";
types4.PSEUDO = PSEUDO;
var NESTING = "nesting";
types4.NESTING = NESTING;
var ID = "id";
types4.ID = ID;
var COMMENT = "comment";
types4.COMMENT = COMMENT;
var COMBINATOR = "combinator";
types4.COMBINATOR = COMBINATOR;
var CLASS = "class";
types4.CLASS = CLASS;
var ATTRIBUTE = "attribute";
types4.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = "universal";
types4.UNIVERSAL = UNIVERSAL;
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var types$12 = _interopRequireWildcard(types4);
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
    if (it2)
      return (it2 = it2.call(o2)).next.bind(it2);
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i = 0;
      return function() {
        if (i >= o2.length)
          return { done: true };
        return { done: false, value: o2[i++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Container3 = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Container4, _Node);
    function Container4(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      if (!_this.nodes) {
        _this.nodes = [];
      }
      return _this;
    }
    var _proto = Container4.prototype;
    _proto.append = function append(selector) {
      selector.parent = this;
      this.nodes.push(selector);
      return this;
    };
    _proto.prepend = function prepend(selector) {
      selector.parent = this;
      this.nodes.unshift(selector);
      return this;
    };
    _proto.at = function at(index) {
      return this.nodes[index];
    };
    _proto.index = function index(child) {
      if (typeof child === "number") {
        return child;
      }
      return this.nodes.indexOf(child);
    };
    _proto.removeChild = function removeChild(child) {
      child = this.index(child);
      this.at(child).parent = undefined;
      this.nodes.splice(child, 1);
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }
      return this;
    };
    _proto.removeAll = function removeAll() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step;!(_step = _iterator()).done; ) {
        var node = _step.value;
        node.parent = undefined;
      }
      this.nodes = [];
      return this;
    };
    _proto.empty = function empty() {
      return this.removeAll();
    };
    _proto.insertAfter = function insertAfter(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex + 1, 0, newNode);
      newNode.parent = this;
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (oldIndex <= index) {
          this.indexes[id] = index + 1;
        }
      }
      return this;
    };
    _proto.insertBefore = function insertBefore(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex, 0, newNode);
      newNode.parent = this;
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (index <= oldIndex) {
          this.indexes[id] = index + 1;
        }
      }
      return this;
    };
    _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
      var found = undefined;
      this.each(function(node) {
        if (node.atPosition) {
          var foundChild = node.atPosition(line, col);
          if (foundChild) {
            found = foundChild;
            return false;
          }
        } else if (node.isAtPosition(line, col)) {
          found = node;
          return false;
        }
      });
      return found;
    };
    _proto.atPosition = function atPosition(line, col) {
      if (this.isAtPosition(line, col)) {
        return this._findChildAtPosition(line, col) || this;
      } else {
        return;
      }
    };
    _proto._inferEndPosition = function _inferEndPosition() {
      if (this.last && this.last.source && this.last.source.end) {
        this.source = this.source || {};
        this.source.end = this.source.end || {};
        Object.assign(this.source.end, this.last.source.end);
      }
    };
    _proto.each = function each(callback) {
      if (!this.lastEach) {
        this.lastEach = 0;
      }
      if (!this.indexes) {
        this.indexes = {};
      }
      this.lastEach++;
      var id = this.lastEach;
      this.indexes[id] = 0;
      if (!this.length) {
        return;
      }
      var index, result2;
      while (this.indexes[id] < this.length) {
        index = this.indexes[id];
        result2 = callback(this.at(index), index);
        if (result2 === false) {
          break;
        }
        this.indexes[id] += 1;
      }
      delete this.indexes[id];
      if (result2 === false) {
        return false;
      }
    };
    _proto.walk = function walk(callback) {
      return this.each(function(node, i) {
        var result2 = callback(node, i);
        if (result2 !== false && node.length) {
          result2 = node.walk(callback);
        }
        if (result2 === false) {
          return false;
        }
      });
    };
    _proto.walkAttributes = function walkAttributes(callback) {
      var _this2 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.ATTRIBUTE) {
          return callback.call(_this2, selector);
        }
      });
    };
    _proto.walkClasses = function walkClasses(callback) {
      var _this3 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.CLASS) {
          return callback.call(_this3, selector);
        }
      });
    };
    _proto.walkCombinators = function walkCombinators(callback) {
      var _this4 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.COMBINATOR) {
          return callback.call(_this4, selector);
        }
      });
    };
    _proto.walkComments = function walkComments(callback) {
      var _this5 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.COMMENT) {
          return callback.call(_this5, selector);
        }
      });
    };
    _proto.walkIds = function walkIds(callback) {
      var _this6 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.ID) {
          return callback.call(_this6, selector);
        }
      });
    };
    _proto.walkNesting = function walkNesting(callback) {
      var _this7 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.NESTING) {
          return callback.call(_this7, selector);
        }
      });
    };
    _proto.walkPseudos = function walkPseudos(callback) {
      var _this8 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.PSEUDO) {
          return callback.call(_this8, selector);
        }
      });
    };
    _proto.walkTags = function walkTags(callback) {
      var _this9 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.TAG) {
          return callback.call(_this9, selector);
        }
      });
    };
    _proto.walkUniversals = function walkUniversals(callback) {
      var _this10 = this;
      return this.walk(function(selector) {
        if (selector.type === types$12.UNIVERSAL) {
          return callback.call(_this10, selector);
        }
      });
    };
    _proto.split = function split(callback) {
      var _this11 = this;
      var current = [];
      return this.reduce(function(memo, node, index) {
        var split = callback.call(_this11, node);
        current.push(node);
        if (split) {
          memo.push(current);
          current = [];
        } else if (index === _this11.length - 1) {
          memo.push(current);
        }
        return memo;
      }, []);
    };
    _proto.map = function map(callback) {
      return this.nodes.map(callback);
    };
    _proto.reduce = function reduce(callback, memo) {
      return this.nodes.reduce(callback, memo);
    };
    _proto.every = function every(callback) {
      return this.nodes.every(callback);
    };
    _proto.some = function some(callback) {
      return this.nodes.some(callback);
    };
    _proto.filter = function filter(callback) {
      return this.nodes.filter(callback);
    };
    _proto.sort = function sort(callback) {
      return this.nodes.sort(callback);
    };
    _proto.toString = function toString() {
      return this.map(String).join("");
    };
    _createClass(Container4, [{
      key: "first",
      get: function get() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function get() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function get() {
        return this.nodes.length;
      }
    }]);
    return Container4;
  }(_node["default"]);
  exports["default"] = Container3;
  module.exports = exports.default;
})(container, container.exports);
var containerExports = container.exports;
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _container = _interopRequireDefault(containerExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Root4 = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Root5, _Container);
    function Root5(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.ROOT;
      return _this;
    }
    var _proto = Root5.prototype;
    _proto.toString = function toString() {
      var str = this.reduce(function(memo, selector) {
        memo.push(String(selector));
        return memo;
      }, []).join(",");
      return this.trailingComma ? str + "," : str;
    };
    _proto.error = function error(message, options3) {
      if (this._error) {
        return this._error(message, options3);
      } else {
        return new Error(message);
      }
    };
    _createClass(Root5, [{
      key: "errorGenerator",
      set: function set(handler) {
        this._error = handler;
      }
    }]);
    return Root5;
  }(_container["default"]);
  exports["default"] = Root4;
  module.exports = exports.default;
})(root$1, root$1.exports);
var rootExports = root$1.exports;
var selector$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _container = _interopRequireDefault(containerExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Selector = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Selector2, _Container);
    function Selector2(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.SELECTOR;
      return _this;
    }
    return Selector2;
  }(_container["default"]);
  exports["default"] = Selector;
  module.exports = exports.default;
})(selector$1, selector$1.exports);
var selectorExports = selector$1.exports;
var className$1 = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var object = {};
var hasOwnProperty$4 = object.hasOwnProperty;
var merge$2 = function merge2(options3, defaults) {
  if (!options3) {
    return defaults;
  }
  var result2 = {};
  for (var key in defaults) {
    result2[key] = hasOwnProperty$4.call(options3, key) ? options3[key] : defaults[key];
  }
  return result2;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
var cssesc = function cssesc2(string, options3) {
  options3 = merge$2(options3, cssesc2.options);
  if (options3.quotes != "single" && options3.quotes != "double") {
    options3.quotes = "single";
  }
  var quote = options3.quotes == "double" ? '"' : "'";
  var isIdentifier = options3.isIdentifier;
  var firstChar = string.charAt(0);
  var output2 = "";
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = undefined;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
        } else {
          counter--;
        }
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else {
      if (options3.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = "\\" + character;
      } else {
        value = character;
      }
    }
    output2 += value;
  }
  if (isIdentifier) {
    if (/^-[-\d]/.test(output2)) {
      output2 = "\\-" + output2.slice(1);
    } else if (/\d/.test(firstChar)) {
      output2 = "\\3" + firstChar + " " + output2.slice(1);
    }
  }
  output2 = output2.replace(regexExcessiveSpaces, function($02, $1, $2) {
    if ($1 && $1.length % 2) {
      return $02;
    }
    return ($1 || "") + $2;
  });
  if (!isIdentifier && options3.wrap) {
    return quote + output2 + quote;
  }
  return output2;
};
cssesc.options = {
  escapeEverything: false,
  isIdentifier: false,
  quotes: "single",
  wrap: false
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _cssesc = _interopRequireDefault(cssesc_1);
  var _util = util$6;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var ClassName = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(ClassName2, _Node);
    function ClassName2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.CLASS;
      _this._constructed = true;
      return _this;
    }
    var _proto = ClassName2.prototype;
    _proto.valueToString = function valueToString() {
      return "." + _Node.prototype.valueToString.call(this);
    };
    _createClass(ClassName2, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(v) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });
          if (escaped !== v) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.value = escaped;
          } else if (this.raws) {
            delete this.raws.value;
          }
        }
        this._value = v;
      }
    }]);
    return ClassName2;
  }(_node["default"]);
  exports["default"] = ClassName;
  module.exports = exports.default;
})(className$1, className$1.exports);
var classNameExports = className$1.exports;
var comment$2 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Comment4 = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Comment5, _Node);
    function Comment5(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.COMMENT;
      return _this;
    }
    return Comment5;
  }(_node["default"]);
  exports["default"] = Comment4;
  module.exports = exports.default;
})(comment$2, comment$2.exports);
var commentExports = comment$2.exports;
var id$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var ID2 = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(ID3, _Node);
    function ID3(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.ID;
      return _this;
    }
    var _proto = ID3.prototype;
    _proto.valueToString = function valueToString() {
      return "#" + _Node.prototype.valueToString.call(this);
    };
    return ID3;
  }(_node["default"]);
  exports["default"] = ID2;
  module.exports = exports.default;
})(id$1, id$1.exports);
var idExports = id$1.exports;
var tag$1 = { exports: {} };
var namespace = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _cssesc = _interopRequireDefault(cssesc_1);
  var _util = util$6;
  var _node = _interopRequireDefault(nodeExports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Namespace = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Namespace2, _Node);
    function Namespace2() {
      return _Node.apply(this, arguments) || this;
    }
    var _proto = Namespace2.prototype;
    _proto.qualifiedName = function qualifiedName(value) {
      if (this.namespace) {
        return this.namespaceString + "|" + value;
      } else {
        return value;
      }
    };
    _proto.valueToString = function valueToString() {
      return this.qualifiedName(_Node.prototype.valueToString.call(this));
    };
    _createClass(Namespace2, [{
      key: "namespace",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace2) {
        if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
          this._namespace = namespace2;
          if (this.raws) {
            delete this.raws.namespace;
          }
          return;
        }
        var escaped = (0, _cssesc["default"])(namespace2, {
          isIdentifier: true
        });
        this._namespace = namespace2;
        if (escaped !== namespace2) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.namespace = escaped;
        } else if (this.raws) {
          delete this.raws.namespace;
        }
      }
    }, {
      key: "ns",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace2) {
        this.namespace = namespace2;
      }
    }, {
      key: "namespaceString",
      get: function get() {
        if (this.namespace) {
          var ns = this.stringifyProperty("namespace");
          if (ns === true) {
            return "";
          } else {
            return ns;
          }
        } else {
          return "";
        }
      }
    }]);
    return Namespace2;
  }(_node["default"]);
  exports["default"] = Namespace;
  module.exports = exports.default;
})(namespace, namespace.exports);
var namespaceExports = namespace.exports;
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _namespace = _interopRequireDefault(namespaceExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Tag2 = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Tag3, _Namespace);
    function Tag3(opts) {
      var _this;
      _this = _Namespace.call(this, opts) || this;
      _this.type = _types.TAG;
      return _this;
    }
    return Tag3;
  }(_namespace["default"]);
  exports["default"] = Tag2;
  module.exports = exports.default;
})(tag$1, tag$1.exports);
var tagExports = tag$1.exports;
var string$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var String2 = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(String3, _Node);
    function String3(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.STRING;
      return _this;
    }
    return String3;
  }(_node["default"]);
  exports["default"] = String2;
  module.exports = exports.default;
})(string$1, string$1.exports);
var stringExports = string$1.exports;
var pseudo$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _container = _interopRequireDefault(containerExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Pseudo = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Pseudo2, _Container);
    function Pseudo2(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.PSEUDO;
      return _this;
    }
    var _proto = Pseudo2.prototype;
    _proto.toString = function toString() {
      var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
    };
    return Pseudo2;
  }(_container["default"]);
  exports["default"] = Pseudo;
  module.exports = exports.default;
})(pseudo$1, pseudo$1.exports);
var pseudoExports = pseudo$1.exports;
var attribute$1 = {};
var node = require$$0$1.deprecate;
(function(exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  exports.unescapeValue = unescapeValue;
  var _cssesc = _interopRequireDefault(cssesc_1);
  var _unesc2 = _interopRequireDefault(unescExports);
  var _namespace = _interopRequireDefault(namespaceExports);
  var _types = types4;
  var _CSSESC_QUOTE_OPTIONS;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var deprecate2 = node;
  var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
  var warnOfDeprecatedValueAssignment = deprecate2(function() {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
  var warnOfDeprecatedQuotedAssignment = deprecate2(function() {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
  var warnOfDeprecatedConstructor = deprecate2(function() {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function unescapeValue(value) {
    var deprecatedUsage = false;
    var quoteMark = null;
    var unescaped = value;
    var m2 = unescaped.match(WRAPPED_IN_QUOTES);
    if (m2) {
      quoteMark = m2[1];
      unescaped = m2[2];
    }
    unescaped = (0, _unesc2["default"])(unescaped);
    if (unescaped !== value) {
      deprecatedUsage = true;
    }
    return {
      deprecatedUsage,
      unescaped,
      quoteMark
    };
  }
  function handleDeprecatedContructorOpts(opts) {
    if (opts.quoteMark !== undefined) {
      return opts;
    }
    if (opts.value === undefined) {
      return opts;
    }
    warnOfDeprecatedConstructor();
    var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
    if (!opts.raws) {
      opts.raws = {};
    }
    if (opts.raws.value === undefined) {
      opts.raws.value = opts.value;
    }
    opts.value = unescaped;
    opts.quoteMark = quoteMark;
    return opts;
  }
  var Attribute2 = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Attribute3, _Namespace);
    function Attribute3(opts) {
      var _this;
      if (opts === undefined) {
        opts = {};
      }
      _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
      _this.type = _types.ATTRIBUTE;
      _this.raws = _this.raws || {};
      Object.defineProperty(_this.raws, "unquoted", {
        get: deprecate2(function() {
          return _this.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: deprecate2(function() {
          return _this.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      });
      _this._constructed = true;
      return _this;
    }
    var _proto = Attribute3.prototype;
    _proto.getQuotedValue = function getQuotedValue(options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      var quoteMark = this._determineQuoteMark(options3);
      var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
      var escaped = (0, _cssesc["default"])(this._value, cssescopts);
      return escaped;
    };
    _proto._determineQuoteMark = function _determineQuoteMark(options3) {
      return options3.smart ? this.smartQuoteMark(options3) : this.preferredQuoteMark(options3);
    };
    _proto.setValue = function setValue(value, options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      this._value = value;
      this._quoteMark = this._determineQuoteMark(options3);
      this._syncRawValue();
    };
    _proto.smartQuoteMark = function smartQuoteMark(options3) {
      var v = this.value;
      var numSingleQuotes = v.replace(/[^']/g, "").length;
      var numDoubleQuotes = v.replace(/[^"]/g, "").length;
      if (numSingleQuotes + numDoubleQuotes === 0) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });
        if (escaped === v) {
          return Attribute3.NO_QUOTE;
        } else {
          var pref = this.preferredQuoteMark(options3);
          if (pref === Attribute3.NO_QUOTE) {
            var quote = this.quoteMark || options3.quoteMark || Attribute3.DOUBLE_QUOTE;
            var opts = CSSESC_QUOTE_OPTIONS[quote];
            var quoteValue = (0, _cssesc["default"])(v, opts);
            if (quoteValue.length < escaped.length) {
              return quote;
            }
          }
          return pref;
        }
      } else if (numDoubleQuotes === numSingleQuotes) {
        return this.preferredQuoteMark(options3);
      } else if (numDoubleQuotes < numSingleQuotes) {
        return Attribute3.DOUBLE_QUOTE;
      } else {
        return Attribute3.SINGLE_QUOTE;
      }
    };
    _proto.preferredQuoteMark = function preferredQuoteMark(options3) {
      var quoteMark = options3.preferCurrentQuoteMark ? this.quoteMark : options3.quoteMark;
      if (quoteMark === undefined) {
        quoteMark = options3.preferCurrentQuoteMark ? options3.quoteMark : this.quoteMark;
      }
      if (quoteMark === undefined) {
        quoteMark = Attribute3.DOUBLE_QUOTE;
      }
      return quoteMark;
    };
    _proto._syncRawValue = function _syncRawValue() {
      var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
      if (rawValue === this._value) {
        if (this.raws) {
          delete this.raws.value;
        }
      } else {
        this.raws.value = rawValue;
      }
    };
    _proto._handleEscapes = function _handleEscapes(prop, value) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(value, {
          isIdentifier: true
        });
        if (escaped !== value) {
          this.raws[prop] = escaped;
        } else {
          delete this.raws[prop];
        }
      }
    };
    _proto._spacesFor = function _spacesFor(name3) {
      var attrSpaces = {
        before: "",
        after: ""
      };
      var spaces = this.spaces[name3] || {};
      var rawSpaces = this.raws.spaces && this.raws.spaces[name3] || {};
      return Object.assign(attrSpaces, spaces, rawSpaces);
    };
    _proto._stringFor = function _stringFor(name3, spaceName, concat4) {
      if (spaceName === undefined) {
        spaceName = name3;
      }
      if (concat4 === undefined) {
        concat4 = defaultAttrConcat;
      }
      var attrSpaces = this._spacesFor(spaceName);
      return concat4(this.stringifyProperty(name3), attrSpaces);
    };
    _proto.offsetOf = function offsetOf(name3) {
      var count = 1;
      var attributeSpaces = this._spacesFor("attribute");
      count += attributeSpaces.before.length;
      if (name3 === "namespace" || name3 === "ns") {
        return this.namespace ? count : -1;
      }
      if (name3 === "attributeNS") {
        return count;
      }
      count += this.namespaceString.length;
      if (this.namespace) {
        count += 1;
      }
      if (name3 === "attribute") {
        return count;
      }
      count += this.stringifyProperty("attribute").length;
      count += attributeSpaces.after.length;
      var operatorSpaces = this._spacesFor("operator");
      count += operatorSpaces.before.length;
      var operator = this.stringifyProperty("operator");
      if (name3 === "operator") {
        return operator ? count : -1;
      }
      count += operator.length;
      count += operatorSpaces.after.length;
      var valueSpaces = this._spacesFor("value");
      count += valueSpaces.before.length;
      var value = this.stringifyProperty("value");
      if (name3 === "value") {
        return value ? count : -1;
      }
      count += value.length;
      count += valueSpaces.after.length;
      var insensitiveSpaces = this._spacesFor("insensitive");
      count += insensitiveSpaces.before.length;
      if (name3 === "insensitive") {
        return this.insensitive ? count : -1;
      }
      return -1;
    };
    _proto.toString = function toString() {
      var _this2 = this;
      var selector = [this.rawSpaceBefore, "["];
      selector.push(this._stringFor("qualifiedAttribute", "attribute"));
      if (this.operator && (this.value || this.value === "")) {
        selector.push(this._stringFor("operator"));
        selector.push(this._stringFor("value"));
        selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
          if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
            attrSpaces.before = " ";
          }
          return defaultAttrConcat(attrValue, attrSpaces);
        }));
      }
      selector.push("]");
      selector.push(this.rawSpaceAfter);
      return selector.join("");
    };
    _createClass(Attribute3, [{
      key: "quoted",
      get: function get() {
        var qm = this.quoteMark;
        return qm === "'" || qm === '"';
      },
      set: function set(value) {
        warnOfDeprecatedQuotedAssignment();
      }
    }, {
      key: "quoteMark",
      get: function get() {
        return this._quoteMark;
      },
      set: function set(quoteMark) {
        if (!this._constructed) {
          this._quoteMark = quoteMark;
          return;
        }
        if (this._quoteMark !== quoteMark) {
          this._quoteMark = quoteMark;
          this._syncRawValue();
        }
      }
    }, {
      key: "qualifiedAttribute",
      get: function get() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function get() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(v) {
        if (this._constructed) {
          var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
          if (deprecatedUsage) {
            warnOfDeprecatedValueAssignment();
          }
          if (unescaped === this._value && quoteMark === this._quoteMark) {
            return;
          }
          this._value = unescaped;
          this._quoteMark = quoteMark;
          this._syncRawValue();
        } else {
          this._value = v;
        }
      }
    }, {
      key: "insensitive",
      get: function get() {
        return this._insensitive;
      },
      set: function set(insensitive) {
        if (!insensitive) {
          this._insensitive = false;
          if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
            this.raws.insensitiveFlag = undefined;
          }
        }
        this._insensitive = insensitive;
      }
    }, {
      key: "attribute",
      get: function get() {
        return this._attribute;
      },
      set: function set(name3) {
        this._handleEscapes("attribute", name3);
        this._attribute = name3;
      }
    }]);
    return Attribute3;
  }(_namespace["default"]);
  exports["default"] = Attribute2;
  Attribute2.NO_QUOTE = null;
  Attribute2.SINGLE_QUOTE = "'";
  Attribute2.DOUBLE_QUOTE = '"';
  var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
    "'": {
      quotes: "single",
      wrap: true
    },
    '"': {
      quotes: "double",
      wrap: true
    }
  }, _CSSESC_QUOTE_OPTIONS[null] = {
    isIdentifier: true
  }, _CSSESC_QUOTE_OPTIONS);
  function defaultAttrConcat(attrValue, attrSpaces) {
    return "" + attrSpaces.before + attrValue + attrSpaces.after;
  }
})(attribute$1);
var universal$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _namespace = _interopRequireDefault(namespaceExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Universal = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Universal2, _Namespace);
    function Universal2(opts) {
      var _this;
      _this = _Namespace.call(this, opts) || this;
      _this.type = _types.UNIVERSAL;
      _this.value = "*";
      return _this;
    }
    return Universal2;
  }(_namespace["default"]);
  exports["default"] = Universal;
  module.exports = exports.default;
})(universal$1, universal$1.exports);
var universalExports = universal$1.exports;
var combinator$2 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Combinator = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Combinator2, _Node);
    function Combinator2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.COMBINATOR;
      return _this;
    }
    return Combinator2;
  }(_node["default"]);
  exports["default"] = Combinator;
  module.exports = exports.default;
})(combinator$2, combinator$2.exports);
var combinatorExports = combinator$2.exports;
var nesting$1 = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _node = _interopRequireDefault(nodeExports);
  var _types = types4;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  var Nesting = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Nesting2, _Node);
    function Nesting2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.NESTING;
      _this.value = "&";
      return _this;
    }
    return Nesting2;
  }(_node["default"]);
  exports["default"] = Nesting;
  module.exports = exports.default;
})(nesting$1, nesting$1.exports);
var nestingExports = nesting$1.exports;
var sortAscending = { exports: {} };
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = sortAscending2;
  function sortAscending2(list2) {
    return list2.sort(function(a, b) {
      return a - b;
    });
  }
  module.exports = exports.default;
})(sortAscending, sortAscending.exports);
var sortAscendingExports = sortAscending.exports;
var tokenize = {};
var tokenTypes = {};
tokenTypes.__esModule = true;
tokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = undefined;
var ampersand = 38;
tokenTypes.ampersand = ampersand;
var asterisk = 42;
tokenTypes.asterisk = asterisk;
var at2 = 64;
tokenTypes.at = at2;
var comma$1 = 44;
tokenTypes.comma = comma$1;
var colon = 58;
tokenTypes.colon = colon;
var semicolon$1 = 59;
tokenTypes.semicolon = semicolon$1;
var openParenthesis = 40;
tokenTypes.openParenthesis = openParenthesis;
var closeParenthesis = 41;
tokenTypes.closeParenthesis = closeParenthesis;
var openSquare = 91;
tokenTypes.openSquare = openSquare;
var closeSquare = 93;
tokenTypes.closeSquare = closeSquare;
var dollar = 36;
tokenTypes.dollar = dollar;
var tilde = 126;
tokenTypes.tilde = tilde;
var caret = 94;
tokenTypes.caret = caret;
var plus = 43;
tokenTypes.plus = plus;
var equals2 = 61;
tokenTypes.equals = equals2;
var pipe = 124;
tokenTypes.pipe = pipe;
var greaterThan = 62;
tokenTypes.greaterThan = greaterThan;
var space = 32;
tokenTypes.space = space;
var singleQuote = 39;
tokenTypes.singleQuote = singleQuote;
var doubleQuote = 34;
tokenTypes.doubleQuote = doubleQuote;
var slash = 47;
tokenTypes.slash = slash;
var bang = 33;
tokenTypes.bang = bang;
var backslash = 92;
tokenTypes.backslash = backslash;
var cr2 = 13;
tokenTypes.cr = cr2;
var feed = 12;
tokenTypes.feed = feed;
var newline = 10;
tokenTypes.newline = newline;
var tab = 9;
tokenTypes.tab = tab;
var str = singleQuote;
tokenTypes.str = str;
var comment$1 = -1;
tokenTypes.comment = comment$1;
var word = -2;
tokenTypes.word = word;
var combinator$1 = -3;
tokenTypes.combinator = combinator$1;
(function(exports) {
  exports.__esModule = true;
  exports.FIELDS = undefined;
  exports["default"] = tokenize2;
  var t2 = _interopRequireWildcard(tokenTypes);
  var _unescapable, _wordDelimiters;
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var unescapable = (_unescapable = {}, _unescapable[t2.tab] = true, _unescapable[t2.newline] = true, _unescapable[t2.cr] = true, _unescapable[t2.feed] = true, _unescapable);
  var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t2.space] = true, _wordDelimiters[t2.tab] = true, _wordDelimiters[t2.newline] = true, _wordDelimiters[t2.cr] = true, _wordDelimiters[t2.feed] = true, _wordDelimiters[t2.ampersand] = true, _wordDelimiters[t2.asterisk] = true, _wordDelimiters[t2.bang] = true, _wordDelimiters[t2.comma] = true, _wordDelimiters[t2.colon] = true, _wordDelimiters[t2.semicolon] = true, _wordDelimiters[t2.openParenthesis] = true, _wordDelimiters[t2.closeParenthesis] = true, _wordDelimiters[t2.openSquare] = true, _wordDelimiters[t2.closeSquare] = true, _wordDelimiters[t2.singleQuote] = true, _wordDelimiters[t2.doubleQuote] = true, _wordDelimiters[t2.plus] = true, _wordDelimiters[t2.pipe] = true, _wordDelimiters[t2.tilde] = true, _wordDelimiters[t2.greaterThan] = true, _wordDelimiters[t2.equals] = true, _wordDelimiters[t2.dollar] = true, _wordDelimiters[t2.caret] = true, _wordDelimiters[t2.slash] = true, _wordDelimiters);
  var hex = {};
  var hexChars = "0123456789abcdefABCDEF";
  for (var i = 0;i < hexChars.length; i++) {
    hex[hexChars.charCodeAt(i)] = true;
  }
  function consumeWord(css2, start) {
    var next = start;
    var code;
    do {
      code = css2.charCodeAt(next);
      if (wordDelimiters[code]) {
        return next - 1;
      } else if (code === t2.backslash) {
        next = consumeEscape(css2, next) + 1;
      } else {
        next++;
      }
    } while (next < css2.length);
    return next - 1;
  }
  function consumeEscape(css2, start) {
    var next = start;
    var code = css2.charCodeAt(next + 1);
    if (unescapable[code])
      ;
    else if (hex[code]) {
      var hexDigits = 0;
      do {
        next++;
        hexDigits++;
        code = css2.charCodeAt(next + 1);
      } while (hex[code] && hexDigits < 6);
      if (hexDigits < 6 && code === t2.space) {
        next++;
      }
    } else {
      next++;
    }
    return next;
  }
  var FIELDS = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  exports.FIELDS = FIELDS;
  function tokenize2(input2) {
    var tokens = [];
    var css2 = input2.css.valueOf();
    var _css = css2, length = _css.length;
    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;
    var code, content, endColumn, endLine, escaped, escapePos, last2, lines, next, nextLine, nextOffset, quote, tokenType;
    function unclosed(what, fix) {
      if (input2.safe) {
        css2 += fix;
        next = css2.length - 1;
      } else {
        throw input2.error("Unclosed " + what, line, start - offset, start);
      }
    }
    while (start < length) {
      code = css2.charCodeAt(start);
      if (code === t2.newline) {
        offset = start;
        line += 1;
      }
      switch (code) {
        case t2.space:
        case t2.tab:
        case t2.newline:
        case t2.cr:
        case t2.feed:
          next = start;
          do {
            next += 1;
            code = css2.charCodeAt(next);
            if (code === t2.newline) {
              offset = next;
              line += 1;
            }
          } while (code === t2.space || code === t2.newline || code === t2.tab || code === t2.cr || code === t2.feed);
          tokenType = t2.space;
          endLine = line;
          endColumn = next - offset - 1;
          end = next;
          break;
        case t2.plus:
        case t2.greaterThan:
        case t2.tilde:
        case t2.pipe:
          next = start;
          do {
            next += 1;
            code = css2.charCodeAt(next);
          } while (code === t2.plus || code === t2.greaterThan || code === t2.tilde || code === t2.pipe);
          tokenType = t2.combinator;
          endLine = line;
          endColumn = start - offset;
          end = next;
          break;
        case t2.asterisk:
        case t2.ampersand:
        case t2.bang:
        case t2.comma:
        case t2.equals:
        case t2.dollar:
        case t2.caret:
        case t2.openSquare:
        case t2.closeSquare:
        case t2.colon:
        case t2.semicolon:
        case t2.openParenthesis:
        case t2.closeParenthesis:
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;
        case t2.singleQuote:
        case t2.doubleQuote:
          quote = code === t2.singleQuote ? "'" : '"';
          next = start;
          do {
            escaped = false;
            next = css2.indexOf(quote, next + 1);
            if (next === -1) {
              unclosed("quote", quote);
            }
            escapePos = next;
            while (css2.charCodeAt(escapePos - 1) === t2.backslash) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          tokenType = t2.str;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;
        default:
          if (code === t2.slash && css2.charCodeAt(start + 1) === t2.asterisk) {
            next = css2.indexOf("*/", start + 2) + 1;
            if (next === 0) {
              unclosed("comment", "*/");
            }
            content = css2.slice(start, next + 1);
            lines = content.split(`
`);
            last2 = lines.length - 1;
            if (last2 > 0) {
              nextLine = line + last2;
              nextOffset = next - lines[last2].length;
            } else {
              nextLine = line;
              nextOffset = offset;
            }
            tokenType = t2.comment;
            line = nextLine;
            endLine = nextLine;
            endColumn = next - nextOffset;
          } else if (code === t2.slash) {
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
          } else {
            next = consumeWord(css2, start);
            tokenType = t2.word;
            endLine = line;
            endColumn = next - offset;
          }
          end = next + 1;
          break;
      }
      tokens.push([
        tokenType,
        line,
        start - offset,
        endLine,
        endColumn,
        start,
        end
      ]);
      if (nextOffset) {
        offset = nextOffset;
        nextOffset = null;
      }
      start = end;
    }
    return tokens;
  }
})(tokenize);
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _root = _interopRequireDefault(rootExports);
  var _selector = _interopRequireDefault(selectorExports);
  var _className = _interopRequireDefault(classNameExports);
  var _comment = _interopRequireDefault(commentExports);
  var _id = _interopRequireDefault(idExports);
  var _tag = _interopRequireDefault(tagExports);
  var _string = _interopRequireDefault(stringExports);
  var _pseudo = _interopRequireDefault(pseudoExports);
  var _attribute = _interopRequireWildcard(attribute$1);
  var _universal = _interopRequireDefault(universalExports);
  var _combinator = _interopRequireDefault(combinatorExports);
  var _nesting = _interopRequireDefault(nestingExports);
  var _sortAscending = _interopRequireDefault(sortAscendingExports);
  var _tokenize = _interopRequireWildcard(tokenize);
  var tokens = _interopRequireWildcard(tokenTypes);
  var types$12 = _interopRequireWildcard(types4);
  var _util = util$6;
  var _WHITESPACE_TOKENS, _Object$assign;
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
  var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
  function tokenStart(token2) {
    return {
      line: token2[_tokenize.FIELDS.START_LINE],
      column: token2[_tokenize.FIELDS.START_COL]
    };
  }
  function tokenEnd(token2) {
    return {
      line: token2[_tokenize.FIELDS.END_LINE],
      column: token2[_tokenize.FIELDS.END_COL]
    };
  }
  function getSource(startLine, startColumn, endLine, endColumn) {
    return {
      start: {
        line: startLine,
        column: startColumn
      },
      end: {
        line: endLine,
        column: endColumn
      }
    };
  }
  function getTokenSource(token2) {
    return getSource(token2[_tokenize.FIELDS.START_LINE], token2[_tokenize.FIELDS.START_COL], token2[_tokenize.FIELDS.END_LINE], token2[_tokenize.FIELDS.END_COL]);
  }
  function getTokenSourceSpan(startToken, endToken) {
    if (!startToken) {
      return;
    }
    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
  }
  function unescapeProp(node2, prop) {
    var value = node2[prop];
    if (typeof value !== "string") {
      return;
    }
    if (value.indexOf("\\") !== -1) {
      (0, _util.ensureObject)(node2, "raws");
      node2[prop] = (0, _util.unesc)(value);
      if (node2.raws[prop] === undefined) {
        node2.raws[prop] = value;
      }
    }
    return node2;
  }
  function indexesOf(array, item) {
    var i = -1;
    var indexes = [];
    while ((i = array.indexOf(item, i + 1)) !== -1) {
      indexes.push(i);
    }
    return indexes;
  }
  function uniqs() {
    var list2 = Array.prototype.concat.apply([], arguments);
    return list2.filter(function(item, i) {
      return i === list2.indexOf(item);
    });
  }
  var Parser6 = /* @__PURE__ */ function() {
    function Parser7(rule2, options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      this.rule = rule2;
      this.options = Object.assign({
        lossy: false,
        safe: false
      }, options3);
      this.position = 0;
      this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
      this.tokens = (0, _tokenize["default"])({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new _root["default"]({
        source: rootSource
      });
      this.root.errorGenerator = this._errorGenerator();
      var selector = new _selector["default"]({
        source: {
          start: {
            line: 1,
            column: 1
          }
        }
      });
      this.root.append(selector);
      this.current = selector;
      this.loop();
    }
    var _proto = Parser7.prototype;
    _proto._errorGenerator = function _errorGenerator() {
      var _this = this;
      return function(message, errorOptions) {
        if (typeof _this.rule === "string") {
          return new Error(message);
        }
        return _this.rule.error(message, errorOptions);
      };
    };
    _proto.attribute = function attribute() {
      var attr = [];
      var startingToken = this.currToken;
      this.position++;
      while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        attr.push(this.currToken);
        this.position++;
      }
      if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      }
      var len = attr.length;
      var node2 = {
        source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
        sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
      };
      if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
        return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
      }
      var pos = 0;
      var spaceBefore = "";
      var commentBefore = "";
      var lastAdded = null;
      var spaceAfterMeaningfulToken = false;
      while (pos < len) {
        var token2 = attr[pos];
        var content = this.content(token2);
        var next = attr[pos + 1];
        switch (token2[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            spaceAfterMeaningfulToken = true;
            if (this.options.lossy) {
              break;
            }
            if (lastAdded) {
              (0, _util.ensureObject)(node2, "spaces", lastAdded);
              var prevContent = node2.spaces[lastAdded].after || "";
              node2.spaces[lastAdded].after = prevContent + content;
              var existingComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || null;
              if (existingComment) {
                node2.raws.spaces[lastAdded].after = existingComment + content;
              }
            } else {
              spaceBefore = spaceBefore + content;
              commentBefore = commentBefore + content;
            }
            break;
          case tokens.asterisk:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node2.operator = content;
              lastAdded = "operator";
            } else if ((!node2.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
              if (spaceBefore) {
                (0, _util.ensureObject)(node2, "spaces", "attribute");
                node2.spaces.attribute.before = spaceBefore;
                spaceBefore = "";
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                node2.raws.spaces.attribute.before = spaceBefore;
                commentBefore = "";
              }
              node2.namespace = (node2.namespace || "") + content;
              var rawValue = (0, _util.getProp)(node2, "raws", "namespace") || null;
              if (rawValue) {
                node2.raws.namespace += content;
              }
              lastAdded = "namespace";
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.dollar:
            if (lastAdded === "value") {
              var oldRawValue = (0, _util.getProp)(node2, "raws", "value");
              node2.value += "$";
              if (oldRawValue) {
                node2.raws.value = oldRawValue + "$";
              }
              break;
            }
          case tokens.caret:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node2.operator = content;
              lastAdded = "operator";
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.combinator:
            if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node2.operator = content;
              lastAdded = "operator";
            }
            if (content !== "|") {
              spaceAfterMeaningfulToken = false;
              break;
            }
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node2.operator = content;
              lastAdded = "operator";
            } else if (!node2.namespace && !node2.attribute) {
              node2.namespace = true;
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.word:
            if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node2.operator && !node2.namespace) {
              node2.namespace = content;
              lastAdded = "namespace";
            } else if (!node2.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
              if (spaceBefore) {
                (0, _util.ensureObject)(node2, "spaces", "attribute");
                node2.spaces.attribute.before = spaceBefore;
                spaceBefore = "";
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                node2.raws.spaces.attribute.before = commentBefore;
                commentBefore = "";
              }
              node2.attribute = (node2.attribute || "") + content;
              var _rawValue = (0, _util.getProp)(node2, "raws", "attribute") || null;
              if (_rawValue) {
                node2.raws.attribute += content;
              }
              lastAdded = "attribute";
            } else if (!node2.value && node2.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node2.quoteMark)) {
              var _unescaped = (0, _util.unesc)(content);
              var _oldRawValue = (0, _util.getProp)(node2, "raws", "value") || "";
              var oldValue = node2.value || "";
              node2.value = oldValue + _unescaped;
              node2.quoteMark = null;
              if (_unescaped !== content || _oldRawValue) {
                (0, _util.ensureObject)(node2, "raws");
                node2.raws.value = (_oldRawValue || oldValue) + content;
              }
              lastAdded = "value";
            } else {
              var insensitive = content === "i" || content === "I";
              if ((node2.value || node2.value === "") && (node2.quoteMark || spaceAfterMeaningfulToken)) {
                node2.insensitive = insensitive;
                if (!insensitive || content === "I") {
                  (0, _util.ensureObject)(node2, "raws");
                  node2.raws.insensitiveFlag = content;
                }
                lastAdded = "insensitive";
                if (spaceBefore) {
                  (0, _util.ensureObject)(node2, "spaces", "insensitive");
                  node2.spaces.insensitive.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node2, "raws", "spaces", "insensitive");
                  node2.raws.spaces.insensitive.before = commentBefore;
                  commentBefore = "";
                }
              } else if (node2.value || node2.value === "") {
                lastAdded = "value";
                node2.value += content;
                if (node2.raws.value) {
                  node2.raws.value += content;
                }
              }
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.str:
            if (!node2.attribute || !node2.operator) {
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: token2[_tokenize.FIELDS.START_POS]
              });
            }
            var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
            node2.value = unescaped;
            node2.quoteMark = quoteMark;
            lastAdded = "value";
            (0, _util.ensureObject)(node2, "raws");
            node2.raws.value = content;
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.equals:
            if (!node2.attribute) {
              return this.expected("attribute", token2[_tokenize.FIELDS.START_POS], content);
            }
            if (node2.value) {
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: token2[_tokenize.FIELDS.START_POS]
              });
            }
            node2.operator = node2.operator ? node2.operator + content : content;
            lastAdded = "operator";
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.comment:
            if (lastAdded) {
              if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                var lastComment = (0, _util.getProp)(node2, "spaces", lastAdded, "after") || "";
                var rawLastComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || lastComment;
                (0, _util.ensureObject)(node2, "raws", "spaces", lastAdded);
                node2.raws.spaces[lastAdded].after = rawLastComment + content;
              } else {
                var lastValue = node2[lastAdded] || "";
                var rawLastValue = (0, _util.getProp)(node2, "raws", lastAdded) || lastValue;
                (0, _util.ensureObject)(node2, "raws");
                node2.raws[lastAdded] = rawLastValue + content;
              }
            } else {
              commentBefore = commentBefore + content;
            }
            break;
          default:
            return this.error('Unexpected "' + content + '" found.', {
              index: token2[_tokenize.FIELDS.START_POS]
            });
        }
        pos++;
      }
      unescapeProp(node2, "attribute");
      unescapeProp(node2, "namespace");
      this.newNode(new _attribute["default"](node2));
      this.position++;
    };
    _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
      if (stopPosition < 0) {
        stopPosition = this.tokens.length;
      }
      var startPosition = this.position;
      var nodes = [];
      var space2 = "";
      var lastComment = undefined;
      do {
        if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          if (!this.options.lossy) {
            space2 += this.content();
          }
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
          var spaces = {};
          if (space2) {
            spaces.before = space2;
            space2 = "";
          }
          lastComment = new _comment["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            spaces
          });
          nodes.push(lastComment);
        }
      } while (++this.position < stopPosition);
      if (space2) {
        if (lastComment) {
          lastComment.spaces.after = space2;
        } else if (!this.options.lossy) {
          var firstToken = this.tokens[startPosition];
          var lastToken = this.tokens[this.position - 1];
          nodes.push(new _string["default"]({
            value: "",
            source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces: {
              before: space2,
              after: ""
            }
          }));
        }
      }
      return nodes;
    };
    _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
      var _this2 = this;
      if (requiredSpace === undefined) {
        requiredSpace = false;
      }
      var space2 = "";
      var rawSpace = "";
      nodes.forEach(function(n2) {
        var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
        var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
        space2 += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
        rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
      });
      if (rawSpace === space2) {
        rawSpace = undefined;
      }
      var result2 = {
        space: space2,
        rawSpace
      };
      return result2;
    };
    _proto.isNamedCombinator = function isNamedCombinator(position) {
      if (position === undefined) {
        position = this.position;
      }
      return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
    };
    _proto.namedCombinator = function namedCombinator() {
      if (this.isNamedCombinator()) {
        var nameRaw = this.content(this.tokens[this.position + 1]);
        var name3 = (0, _util.unesc)(nameRaw).toLowerCase();
        var raws = {};
        if (name3 !== nameRaw) {
          raws.value = "/" + nameRaw + "/";
        }
        var node2 = new _combinator["default"]({
          value: "/" + name3 + "/",
          source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          raws
        });
        this.position = this.position + 3;
        return node2;
      } else {
        this.unexpected();
      }
    };
    _proto.combinator = function combinator() {
      var _this3 = this;
      if (this.content() === "|") {
        return this.namespace();
      }
      var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
      if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
        var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        if (nodes.length > 0) {
          var last2 = this.current.last;
          if (last2) {
            var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
            if (rawSpace !== undefined) {
              last2.rawSpaceAfter += rawSpace;
            }
            last2.spaces.after += space2;
          } else {
            nodes.forEach(function(n2) {
              return _this3.newNode(n2);
            });
          }
        }
        return;
      }
      var firstToken = this.currToken;
      var spaceOrDescendantSelectorNodes = undefined;
      if (nextSigTokenPos > this.position) {
        spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
      }
      var node2;
      if (this.isNamedCombinator()) {
        node2 = this.namedCombinator();
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
        node2 = new _combinator["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
        });
        this.position++;
      } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]])
        ;
      else if (!spaceOrDescendantSelectorNodes) {
        this.unexpected();
      }
      if (node2) {
        if (spaceOrDescendantSelectorNodes) {
          var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
          node2.spaces.before = _space;
          node2.rawSpaceBefore = _rawSpace;
        }
      } else {
        var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
        if (!_rawSpace2) {
          _rawSpace2 = _space2;
        }
        var spaces = {};
        var raws = {
          spaces: {}
        };
        if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
          spaces.before = _space2.slice(0, _space2.length - 1);
          raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
        } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
          spaces.after = _space2.slice(1);
          raws.spaces.after = _rawSpace2.slice(1);
        } else {
          raws.value = _rawSpace2;
        }
        node2 = new _combinator["default"]({
          value: " ",
          source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces,
          raws
        });
      }
      if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
        node2.spaces.after = this.optionalSpace(this.content());
        this.position++;
      }
      return this.newNode(node2);
    };
    _proto.comma = function comma() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true;
        this.position++;
        return;
      }
      this.current._inferEndPosition();
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position + 1])
        }
      });
      this.current.parent.append(selector);
      this.current = selector;
      this.position++;
    };
    _proto.comment = function comment() {
      var current = this.currToken;
      this.newNode(new _comment["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.error = function error(message, opts) {
      throw this.root.error(message, opts);
    };
    _proto.missingBackslash = function missingBackslash() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[_tokenize.FIELDS.START_POS]
      });
    };
    _proto.missingParenthesis = function missingParenthesis() {
      return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.missingSquareBracket = function missingSquareBracket() {
      return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.unexpected = function unexpected() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.unexpectedPipe = function unexpectedPipe() {
      return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.namespace = function namespace() {
      var before = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.position++;
        return this.word(before);
      } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
        this.position++;
        return this.universal(before);
      }
      this.unexpectedPipe();
    };
    _proto.nesting = function nesting() {
      if (this.nextToken) {
        var nextContent = this.content(this.nextToken);
        if (nextContent === "|") {
          this.position++;
          return;
        }
      }
      var current = this.currToken;
      this.newNode(new _nesting["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.parentheses = function parentheses() {
      var last2 = this.current.last;
      var unbalanced = 1;
      this.position++;
      if (last2 && last2.type === types$12.PSEUDO) {
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position - 1])
          }
        });
        var cache = this.current;
        last2.append(selector);
        this.current = selector;
        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }
          if (unbalanced) {
            this.parse();
          } else {
            this.current.source.end = tokenEnd(this.currToken);
            this.current.parent.source.end = tokenEnd(this.currToken);
            this.position++;
          }
        }
        this.current = cache;
      } else {
        var parenStart = this.currToken;
        var parenValue = "(";
        var parenEnd;
        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }
          parenEnd = this.currToken;
          parenValue += this.parseParenthesisToken(this.currToken);
          this.position++;
        }
        if (last2) {
          last2.appendToPropertyAndEscape("value", parenValue, parenValue);
        } else {
          this.newNode(new _string["default"]({
            value: parenValue,
            source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
            sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
          }));
        }
      }
      if (unbalanced) {
        return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };
    _proto.pseudo = function pseudo() {
      var _this4 = this;
      var pseudoStr = "";
      var startingToken = this.currToken;
      while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
        pseudoStr += this.content();
        this.position++;
      }
      if (!this.currToken) {
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      }
      if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.splitWord(false, function(first, length) {
          pseudoStr += first;
          _this4.newNode(new _pseudo["default"]({
            value: pseudoStr,
            source: getTokenSourceSpan(startingToken, _this4.currToken),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          }));
          if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            _this4.error("Misplaced parenthesis.", {
              index: _this4.nextToken[_tokenize.FIELDS.START_POS]
            });
          }
        });
      } else {
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };
    _proto.space = function space() {
      var content = this.content();
      if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node2) {
        return node2.type === "comment";
      })) {
        this.spaces = this.optionalSpace(content);
        this.position++;
      } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
        this.current.last.spaces.after = this.optionalSpace(content);
        this.position++;
      } else {
        this.combinator();
      }
    };
    _proto.string = function string() {
      var current = this.currToken;
      this.newNode(new _string["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.universal = function universal(namespace2) {
      var nextToken = this.nextToken;
      if (nextToken && this.content(nextToken) === "|") {
        this.position++;
        return this.namespace();
      }
      var current = this.currToken;
      this.newNode(new _universal["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }), namespace2);
      this.position++;
    };
    _proto.splitWord = function splitWord(namespace2, firstCallback) {
      var _this5 = this;
      var nextToken = this.nextToken;
      var word2 = this.content();
      while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
        this.position++;
        var current = this.content();
        word2 += current;
        if (current.lastIndexOf("\\") === current.length - 1) {
          var next = this.nextToken;
          if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
            word2 += this.requiredSpace(this.content(next));
            this.position++;
          }
        }
        nextToken = this.nextToken;
      }
      var hasClass = indexesOf(word2, ".").filter(function(i) {
        var escapedDot = word2[i - 1] === "\\";
        var isKeyframesPercent = /^\d+\.\d+%$/.test(word2);
        return !escapedDot && !isKeyframesPercent;
      });
      var hasId = indexesOf(word2, "#").filter(function(i) {
        return word2[i - 1] !== "\\";
      });
      var interpolations = indexesOf(word2, "#{");
      if (interpolations.length) {
        hasId = hasId.filter(function(hashIndex) {
          return !~interpolations.indexOf(hashIndex);
        });
      }
      var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
      indices.forEach(function(ind, i) {
        var index = indices[i + 1] || word2.length;
        var value = word2.slice(ind, index);
        if (i === 0 && firstCallback) {
          return firstCallback.call(_this5, value, indices.length);
        }
        var node2;
        var current2 = _this5.currToken;
        var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
        var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
        if (~hasClass.indexOf(ind)) {
          var classNameOpts = {
            value: value.slice(1),
            source,
            sourceIndex
          };
          node2 = new _className["default"](unescapeProp(classNameOpts, "value"));
        } else if (~hasId.indexOf(ind)) {
          var idOpts = {
            value: value.slice(1),
            source,
            sourceIndex
          };
          node2 = new _id["default"](unescapeProp(idOpts, "value"));
        } else {
          var tagOpts = {
            value,
            source,
            sourceIndex
          };
          unescapeProp(tagOpts, "value");
          node2 = new _tag["default"](tagOpts);
        }
        _this5.newNode(node2, namespace2);
        namespace2 = null;
      });
      this.position++;
    };
    _proto.word = function word(namespace2) {
      var nextToken = this.nextToken;
      if (nextToken && this.content(nextToken) === "|") {
        this.position++;
        return this.namespace();
      }
      return this.splitWord(namespace2);
    };
    _proto.loop = function loop() {
      while (this.position < this.tokens.length) {
        this.parse(true);
      }
      this.current._inferEndPosition();
      return this.root;
    };
    _proto.parse = function parse(throwOnParenthesis) {
      switch (this.currToken[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          this.space();
          break;
        case tokens.comment:
          this.comment();
          break;
        case tokens.openParenthesis:
          this.parentheses();
          break;
        case tokens.closeParenthesis:
          if (throwOnParenthesis) {
            this.missingParenthesis();
          }
          break;
        case tokens.openSquare:
          this.attribute();
          break;
        case tokens.dollar:
        case tokens.caret:
        case tokens.equals:
        case tokens.word:
          this.word();
          break;
        case tokens.colon:
          this.pseudo();
          break;
        case tokens.comma:
          this.comma();
          break;
        case tokens.asterisk:
          this.universal();
          break;
        case tokens.ampersand:
          this.nesting();
          break;
        case tokens.slash:
        case tokens.combinator:
          this.combinator();
          break;
        case tokens.str:
          this.string();
          break;
        case tokens.closeSquare:
          this.missingSquareBracket();
        case tokens.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    };
    _proto.expected = function expected(description, index, found) {
      if (Array.isArray(description)) {
        var last2 = description.pop();
        description = description.join(", ") + " or " + last2;
      }
      var an2 = /^[aeiou]/.test(description[0]) ? "an" : "a";
      if (!found) {
        return this.error("Expected " + an2 + " " + description + ".", {
          index
        });
      }
      return this.error("Expected " + an2 + " " + description + ', found "' + found + '" instead.', {
        index
      });
    };
    _proto.requiredSpace = function requiredSpace(space2) {
      return this.options.lossy ? " " : space2;
    };
    _proto.optionalSpace = function optionalSpace(space2) {
      return this.options.lossy ? "" : space2;
    };
    _proto.lossySpace = function lossySpace(space2, required) {
      if (this.options.lossy) {
        return required ? " " : "";
      } else {
        return space2;
      }
    };
    _proto.parseParenthesisToken = function parseParenthesisToken(token2) {
      var content = this.content(token2);
      if (token2[_tokenize.FIELDS.TYPE] === tokens.space) {
        return this.requiredSpace(content);
      } else {
        return content;
      }
    };
    _proto.newNode = function newNode(node2, namespace2) {
      if (namespace2) {
        if (/^ +$/.test(namespace2)) {
          if (!this.options.lossy) {
            this.spaces = (this.spaces || "") + namespace2;
          }
          namespace2 = true;
        }
        node2.namespace = namespace2;
        unescapeProp(node2, "namespace");
      }
      if (this.spaces) {
        node2.spaces.before = this.spaces;
        this.spaces = "";
      }
      return this.current.append(node2);
    };
    _proto.content = function content(token2) {
      if (token2 === undefined) {
        token2 = this.currToken;
      }
      return this.css.slice(token2[_tokenize.FIELDS.START_POS], token2[_tokenize.FIELDS.END_POS]);
    };
    _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
      if (startPosition === undefined) {
        startPosition = this.position + 1;
      }
      var searchPosition = startPosition;
      while (searchPosition < this.tokens.length) {
        if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
          searchPosition++;
          continue;
        } else {
          return searchPosition;
        }
      }
      return -1;
    };
    _createClass(Parser7, [{
      key: "currToken",
      get: function get() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function get() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function get() {
        return this.tokens[this.position - 1];
      }
    }]);
    return Parser7;
  }();
  exports["default"] = Parser6;
  module.exports = exports.default;
})(parser, parser.exports);
var parserExports = parser.exports;
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _parser = _interopRequireDefault(parserExports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Processor3 = /* @__PURE__ */ function() {
    function Processor4(func, options3) {
      this.func = func || function noop() {};
      this.funcRes = null;
      this.options = options3;
    }
    var _proto = Processor4.prototype;
    _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      var merged = Object.assign({}, this.options, options3);
      if (merged.updateSelector === false) {
        return false;
      } else {
        return typeof rule2 !== "string";
      }
    };
    _proto._isLossy = function _isLossy(options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      var merged = Object.assign({}, this.options, options3);
      if (merged.lossless === false) {
        return true;
      } else {
        return false;
      }
    };
    _proto._root = function _root(rule2, options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      var parser2 = new _parser["default"](rule2, this._parseOptions(options3));
      return parser2.root;
    };
    _proto._parseOptions = function _parseOptions(options3) {
      return {
        lossy: this._isLossy(options3)
      };
    };
    _proto._run = function _run(rule2, options3) {
      var _this = this;
      if (options3 === undefined) {
        options3 = {};
      }
      return new Promise(function(resolve3, reject) {
        try {
          var root = _this._root(rule2, options3);
          Promise.resolve(_this.func(root)).then(function(transform2) {
            var string = undefined;
            if (_this._shouldUpdateSelector(rule2, options3)) {
              string = root.toString();
              rule2.selector = string;
            }
            return {
              transform: transform2,
              root,
              string
            };
          }).then(resolve3, reject);
        } catch (e2) {
          reject(e2);
          return;
        }
      });
    };
    _proto._runSync = function _runSync(rule2, options3) {
      if (options3 === undefined) {
        options3 = {};
      }
      var root = this._root(rule2, options3);
      var transform2 = this.func(root);
      if (transform2 && typeof transform2.then === "function") {
        throw new Error("Selector processor returned a promise to a synchronous call.");
      }
      var string = undefined;
      if (options3.updateSelector && typeof rule2 !== "string") {
        string = root.toString();
        rule2.selector = string;
      }
      return {
        transform: transform2,
        root,
        string
      };
    };
    _proto.ast = function ast(rule2, options3) {
      return this._run(rule2, options3).then(function(result2) {
        return result2.root;
      });
    };
    _proto.astSync = function astSync(rule2, options3) {
      return this._runSync(rule2, options3).root;
    };
    _proto.transform = function transform(rule2, options3) {
      return this._run(rule2, options3).then(function(result2) {
        return result2.transform;
      });
    };
    _proto.transformSync = function transformSync(rule2, options3) {
      return this._runSync(rule2, options3).transform;
    };
    _proto.process = function process(rule2, options3) {
      return this._run(rule2, options3).then(function(result2) {
        return result2.string || result2.root.toString();
      });
    };
    _proto.processSync = function processSync(rule2, options3) {
      var result2 = this._runSync(rule2, options3);
      return result2.string || result2.root.toString();
    };
    return Processor4;
  }();
  exports["default"] = Processor3;
  module.exports = exports.default;
})(processor, processor.exports);
var processorExports = processor.exports;
var selectors = {};
var constructors = {};
constructors.__esModule = true;
constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = undefined;
var _attribute = _interopRequireDefault(attribute$1);
var _className = _interopRequireDefault(classNameExports);
var _combinator = _interopRequireDefault(combinatorExports);
var _comment = _interopRequireDefault(commentExports);
var _id = _interopRequireDefault(idExports);
var _nesting = _interopRequireDefault(nestingExports);
var _pseudo = _interopRequireDefault(pseudoExports);
var _root = _interopRequireDefault(rootExports);
var _selector = _interopRequireDefault(selectorExports);
var _string = _interopRequireDefault(stringExports);
var _tag = _interopRequireDefault(tagExports);
var _universal = _interopRequireDefault(universalExports);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var attribute2 = function attribute3(opts) {
  return new _attribute["default"](opts);
};
constructors.attribute = attribute2;
var className = function className2(opts) {
  return new _className["default"](opts);
};
constructors.className = className;
var combinator = function combinator2(opts) {
  return new _combinator["default"](opts);
};
constructors.combinator = combinator;
var comment = function comment2(opts) {
  return new _comment["default"](opts);
};
constructors.comment = comment;
var id = function id2(opts) {
  return new _id["default"](opts);
};
constructors.id = id;
var nesting = function nesting2(opts) {
  return new _nesting["default"](opts);
};
constructors.nesting = nesting;
var pseudo = function pseudo2(opts) {
  return new _pseudo["default"](opts);
};
constructors.pseudo = pseudo;
var root = function root2(opts) {
  return new _root["default"](opts);
};
constructors.root = root;
var selector = function selector2(opts) {
  return new _selector["default"](opts);
};
constructors.selector = selector;
var string = function string3(opts) {
  return new _string["default"](opts);
};
constructors.string = string;
var tag = function tag2(opts) {
  return new _tag["default"](opts);
};
constructors.tag = tag;
var universal = function universal2(opts) {
  return new _universal["default"](opts);
};
constructors.universal = universal;
var guards = {};
guards.__esModule = true;
guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = undefined;
guards.isContainer = isContainer;
guards.isIdentifier = undefined;
guards.isNamespace = isNamespace;
guards.isNesting = undefined;
guards.isNode = isNode;
guards.isPseudo = undefined;
guards.isPseudoClass = isPseudoClass;
guards.isPseudoElement = isPseudoElement;
guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = undefined;
var _types = types4;
var _IS_TYPE;
var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
function isNode(node2) {
  return typeof node2 === "object" && IS_TYPE[node2.type];
}
function isNodeType(type, node2) {
  return isNode(node2) && node2.type === type;
}
var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
guards.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
guards.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
guards.isCombinator = isCombinator;
var isComment2 = isNodeType.bind(null, _types.COMMENT);
guards.isComment = isComment2;
var isIdentifier = isNodeType.bind(null, _types.ID);
guards.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
guards.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
guards.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
guards.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
guards.isSelector = isSelector;
var isString$3 = isNodeType.bind(null, _types.STRING);
guards.isString = isString$3;
var isTag2 = isNodeType.bind(null, _types.TAG);
guards.isTag = isTag2;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
guards.isUniversal = isUniversal;
function isPseudoElement(node2) {
  return isPseudo(node2) && node2.value && (node2.value.startsWith("::") || node2.value.toLowerCase() === ":before" || node2.value.toLowerCase() === ":after" || node2.value.toLowerCase() === ":first-letter" || node2.value.toLowerCase() === ":first-line");
}
function isPseudoClass(node2) {
  return isPseudo(node2) && !isPseudoElement(node2);
}
function isContainer(node2) {
  return !!(isNode(node2) && node2.walk);
}
function isNamespace(node2) {
  return isAttribute(node2) || isTag2(node2);
}
(function(exports) {
  exports.__esModule = true;
  var _types2 = types4;
  Object.keys(_types2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _types2[key])
      return;
    exports[key] = _types2[key];
  });
  var _constructors = constructors;
  Object.keys(_constructors).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _constructors[key])
      return;
    exports[key] = _constructors[key];
  });
  var _guards = guards;
  Object.keys(_guards).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _guards[key])
      return;
    exports[key] = _guards[key];
  });
})(selectors);
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = undefined;
  var _processor = _interopRequireDefault2(processorExports);
  var selectors$1 = _interopRequireWildcard(selectors);
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var parser2 = function parser(processor2) {
    return new _processor["default"](processor2);
  };
  Object.assign(parser2, selectors$1);
  delete parser2.__esModule;
  var _default = parser2;
  exports["default"] = _default;
  module.exports = exports.default;
})(dist, dist.exports);
var distExports = dist.exports;
var selectorParser = /* @__PURE__ */ getDefaultExportFromCjs2(distExports);
var animationNameRE = /^(-\w+-)?animation-name$/;
var animationRE = /^(-\w+-)?animation$/;
var scopedPlugin = (id3 = "") => {
  const keyframes = /* @__PURE__ */ Object.create(null);
  const shortId = id3.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(rule2) {
      processRule(id3, rule2);
    },
    AtRule(node2) {
      if (/-?keyframes$/.test(node2.name) && !node2.params.endsWith(`-${shortId}`)) {
        keyframes[node2.params] = node2.params = node2.params + "-" + shortId;
      }
    },
    OnceExit(root3) {
      if (Object.keys(keyframes).length) {
        root3.walkDecls((decl) => {
          if (animationNameRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => keyframes[v.trim()] || v.trim()).join(",");
          }
          if (animationRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => {
              const vals = v.trim().split(/\s+/);
              const i = vals.findIndex((val) => keyframes[val]);
              if (i !== -1) {
                vals.splice(i, 1, keyframes[vals[i]]);
                return vals.join(" ");
              } else {
                return v;
              }
            }).join(",");
          }
        });
      }
    }
  };
};
var processedRules = /* @__PURE__ */ new WeakSet;
function processRule(id3, rule2) {
  if (processedRules.has(rule2) || rule2.parent && rule2.parent.type === "atrule" && /-?keyframes$/.test(rule2.parent.name)) {
    return;
  }
  processedRules.add(rule2);
  rule2.selector = selectorParser((selectorRoot) => {
    selectorRoot.each((selector3) => {
      rewriteSelector(id3, selector3, selectorRoot);
    });
  }).processSync(rule2.selector);
}
function rewriteSelector(id3, selector3, selectorRoot, slotted = false) {
  let node2 = null;
  let shouldInject = true;
  selector3.each((n2) => {
    if (n2.type === "combinator" && (n2.value === ">>>" || n2.value === "/deep/")) {
      n2.value = " ";
      n2.spaces.before = n2.spaces.after = "";
      warn$1(`the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`);
      return false;
    }
    if (n2.type === "pseudo") {
      const { value } = n2;
      if (value === ":deep" || value === "::v-deep") {
        if (n2.nodes.length) {
          let last2 = n2;
          n2.nodes[0].each((ss) => {
            selector3.insertAfter(last2, ss);
            last2 = ss;
          });
          const prev = selector3.at(selector3.index(n2) - 1);
          if (!prev || !isSpaceCombinator(prev)) {
            selector3.insertAfter(n2, selectorParser.combinator({
              value: " "
            }));
          }
          selector3.removeChild(n2);
        } else {
          warn$1(`${value} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${value} <inner-selector>.`);
          const prev = selector3.at(selector3.index(n2) - 1);
          if (prev && isSpaceCombinator(prev)) {
            selector3.removeChild(prev);
          }
          selector3.removeChild(n2);
        }
        return false;
      }
      if (value === ":slotted" || value === "::v-slotted") {
        rewriteSelector(id3, n2.nodes[0], selectorRoot, true);
        let last2 = n2;
        n2.nodes[0].each((ss) => {
          selector3.insertAfter(last2, ss);
          last2 = ss;
        });
        selector3.removeChild(n2);
        shouldInject = false;
        return false;
      }
      if (value === ":global" || value === "::v-global") {
        selectorRoot.insertAfter(selector3, n2.nodes[0]);
        selectorRoot.removeChild(selector3);
        return false;
      }
    }
    if (n2.type !== "pseudo" && n2.type !== "combinator") {
      node2 = n2;
    }
  });
  if (node2) {
    node2.spaces.after = "";
  } else {
    selector3.first.spaces.before = "";
  }
  if (shouldInject) {
    const idToAdd = slotted ? id3 + "-s" : id3;
    selector3.insertAfter(node2, selectorParser.attribute({
      attribute: idToAdd,
      value: idToAdd,
      raws: {},
      quoteMark: `"`
    }));
  }
}
function isSpaceCombinator(node2) {
  return node2.type === "combinator" && /^\s+$/.test(node2.value);
}
scopedPlugin.postcss = true;
var scopedPlugin$1 = scopedPlugin;
var sourceMap$1 = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64$1 = {};
var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
base64$1.encode = function(number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};
base64$1.decode = function(charCode) {
  var bigA = 65;
  var bigZ = 90;
  var littleA = 97;
  var littleZ = 122;
  var zero = 48;
  var nine = 57;
  var plus2 = 43;
  var slash2 = 47;
  var littleOffset = 26;
  var numberOffset = 52;
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }
  if (charCode == plus2) {
    return 62;
  }
  if (charCode == slash2) {
    return 63;
  }
  return -1;
};
var base642 = base64$1;
var VLQ_BASE_SHIFT = 5;
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
var VLQ_BASE_MASK = VLQ_BASE - 1;
var VLQ_CONTINUATION_BIT = VLQ_BASE;
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
base64Vlq.encode = function base64VLQ_encode2(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);
  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base642.encode(digit);
  } while (vlq > 0);
  return encoded;
};
base64Vlq.decode = function base64VLQ_decode2(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result2 = 0;
  var shift = 0;
  var continuation, digit;
  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }
    digit = base642.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }
    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result2 = result2 + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);
  aOutParam.value = fromVLQSigned(result2);
  aOutParam.rest = aIndex;
};
var util$5 = {};
(function(exports) {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse2(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse2;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;
  function normalize3(aPath) {
    var path3 = aPath;
    var url = urlParse2(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path3 = url.path;
    }
    var isAbsolute3 = exports.isAbsolute(path3);
    var parts = path3.split(/\/+/);
    for (var part, up2 = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up2++;
      } else if (up2 > 0) {
        if (part === "") {
          parts.splice(i + 1, up2);
          up2 = 0;
        } else {
          parts.splice(i, 2);
          up2--;
        }
      }
    }
    path3 = parts.join("/");
    if (path3 === "") {
      path3 = isAbsolute3 ? "/" : ".";
    }
    if (url) {
      url.path = path3;
      return urlGenerate(url);
    }
    return path3;
  }
  exports.normalize = normalize3;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse2(aPath);
    var aRootUrl = urlParse2(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize3(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative2(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative2;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s2) {
    return s2;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s2) {
    if (!s2) {
      return false;
    }
    var length = s2.length;
    if (length < 9) {
      return false;
    }
    if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s2.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str2) {
    return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse2(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize3(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
})(util$5);
var arraySet = {};
var util$4 = util$5;
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
function ArraySet$2() {
  this._array = [];
  this._set = hasNativeMap ? new Map : Object.create(null);
}
ArraySet$2.fromArray = function ArraySet_fromArray2(aArray, aAllowDuplicates) {
  var set = new ArraySet$2;
  for (var i = 0, len = aArray.length;i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};
ArraySet$2.prototype.size = function ArraySet_size2() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
ArraySet$2.prototype.add = function ArraySet_add2(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
ArraySet$2.prototype.has = function ArraySet_has2(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$4.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
ArraySet$2.prototype.indexOf = function ArraySet_indexOf2(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util$4.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }
  throw new Error('"' + aStr + '" is not in the set.');
};
ArraySet$2.prototype.at = function ArraySet_at2(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error("No element indexed by " + aIdx);
};
ArraySet$2.prototype.toArray = function ArraySet_toArray2() {
  return this._array.slice();
};
arraySet.ArraySet = ArraySet$2;
var mappingList = {};
var util$3 = util$5;
function generatedPositionAfter(mappingA, mappingB) {
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  this._last = { generatedLine: -1, generatedColumn: 0 };
}
MappingList$1.prototype.unsortedForEach = function MappingList_forEach2(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
MappingList$1.prototype.add = function MappingList_add2(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};
MappingList$1.prototype.toArray = function MappingList_toArray2() {
  if (!this._sorted) {
    this._array.sort(util$3.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};
mappingList.MappingList = MappingList$1;
var base64VLQ$1 = base64Vlq;
var util$2 = util$5;
var ArraySet$1 = arraySet.ArraySet;
var MappingList = mappingList.MappingList;
function SourceMapGenerator$2(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util$2.getArg(aArgs, "file", null);
  this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
  this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
  this._sources = new ArraySet$1;
  this._names = new ArraySet$1;
  this._mappings = new MappingList;
  this._sourcesContents = null;
}
SourceMapGenerator$2.prototype._version = 3;
SourceMapGenerator$2.fromSourceMap = function SourceMapGenerator_fromSourceMap2(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator$2({
    file: aSourceMapConsumer.file,
    sourceRoot
  });
  aSourceMapConsumer.eachMapping(function(mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };
    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util$2.relative(sourceRoot, newMapping.source);
      }
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };
      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }
    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util$2.relative(sourceRoot, sourceFile);
    }
    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
SourceMapGenerator$2.prototype.addMapping = function SourceMapGenerator_addMapping2(aArgs) {
  var generated = util$2.getArg(aArgs, "generated");
  var original = util$2.getArg(aArgs, "original", null);
  var source = util$2.getArg(aArgs, "source", null);
  var name3 = util$2.getArg(aArgs, "name", null);
  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name3);
  }
  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }
  if (name3 != null) {
    name3 = String(name3);
    if (!this._names.has(name3)) {
      this._names.add(name3);
    }
  }
  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source,
    name: name3
  });
};
SourceMapGenerator$2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent2(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util$2.relative(this._sourceRoot, source);
  }
  if (aSourceContent != null) {
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    delete this._sourcesContents[util$2.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
SourceMapGenerator$2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap2(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + `or the source map's "file" property. Both were omitted.`);
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  if (sourceRoot != null) {
    sourceFile = util$2.relative(sourceRoot, sourceFile);
  }
  var newSources = new ArraySet$1;
  var newNames = new ArraySet$1;
  this._mappings.unsortedForEach(function(mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util$2.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util$2.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }
    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }
    var name3 = mapping.name;
    if (name3 != null && !newNames.has(name3)) {
      newNames.add(name3);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;
  aSourceMapConsumer.sources.forEach(function(sourceFile2) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile2 = util$2.join(aSourceMapPath, sourceFile2);
      }
      if (sourceRoot != null) {
        sourceFile2 = util$2.relative(sourceRoot, sourceFile2);
      }
      this.setSourceContent(sourceFile2, content);
    }
  }, this);
};
SourceMapGenerator$2.prototype._validateMapping = function SourceMapGenerator_validateMapping2(aGenerated, aOriginal, aSource, aName) {
  if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
    throw new Error("original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.");
  }
  if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    return;
  } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    return;
  } else {
    throw new Error("Invalid mapping: " + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
SourceMapGenerator$2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings2() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result2 = "";
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;
  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length;i < len; i++) {
    mapping = mappings[i];
    next = "";
    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ";";
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }
    }
    next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;
    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ$1.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;
      next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;
      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ$1.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }
    result2 += next;
  }
  return result2;
};
SourceMapGenerator$2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent2(aSources, aSourceRoot) {
  return aSources.map(function(source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util$2.relative(aSourceRoot, source);
    }
    var key = util$2.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
SourceMapGenerator$2.prototype.toJSON = function SourceMapGenerator_toJSON2() {
  var map3 = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map3.file = this._file;
  }
  if (this._sourceRoot != null) {
    map3.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map3.sourcesContent = this._generateSourcesContent(map3.sources, map3.sourceRoot);
  }
  return map3;
};
SourceMapGenerator$2.prototype.toString = function SourceMapGenerator_toString2() {
  return JSON.stringify(this.toJSON());
};
sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$2;
var sourceMapConsumer = {};
var binarySearch$1 = {};
(function(exports) {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
})(binarySearch$1);
var quickSort$1 = {};
function swap(ary, x2, y) {
  var temp = ary[x2];
  ary[x2] = ary[y];
  ary[y] = temp;
}
function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
function doQuickSort(ary, comparator, p2, r3) {
  if (p2 < r3) {
    var pivotIndex = randomIntInRange(p2, r3);
    var i = p2 - 1;
    swap(ary, pivotIndex, r3);
    var pivot = ary[r3];
    for (var j = p2;j < r3; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }
    swap(ary, i + 1, j);
    var q = i + 1;
    doQuickSort(ary, comparator, p2, q - 1);
    doQuickSort(ary, comparator, q + 1, r3);
  }
}
quickSort$1.quickSort = function(ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};
var util$1 = util$5;
var binarySearch = binarySearch$1;
var ArraySet = arraySet.ArraySet;
var base64VLQ = base64Vlq;
var quickSort = quickSort$1.quickSort;
function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$1.parseSourceMapInput(aSourceMap);
  }
  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
SourceMapConsumer$1.prototype._version = 3;
SourceMapConsumer$1.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", {
  configurable: true,
  enumerable: true,
  get: function() {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__generatedMappings;
  }
});
SourceMapConsumer$1.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", {
  configurable: true,
  enumerable: true,
  get: function() {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__originalMappings;
  }
});
SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator2(aStr, index) {
  var c3 = aStr.charAt(index);
  return c3 === ";" || c3 === ",";
};
SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings3(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer$1.GENERATED_ORDER = 1;
SourceMapConsumer$1.ORIGINAL_ORDER = 2;
SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping2(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
  var mappings;
  switch (order) {
    case SourceMapConsumer$1.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer$1.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var sourceRoot = this.sourceRoot;
  mappings.map(function(mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util$1.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor2(aArgs) {
  var line = util$1.getArg(aArgs, "line");
  var needle = {
    source: util$1.getArg(aArgs, "source"),
    originalLine: line,
    originalColumn: util$1.getArg(aArgs, "column", 0)
  };
  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }
  var mappings = [];
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util$1.getArg(mapping, "generatedLine", null),
          column: util$1.getArg(mapping, "generatedColumn", null),
          lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util$1.getArg(mapping, "generatedLine", null),
          column: util$1.getArg(mapping, "generatedColumn", null),
          lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }
  return mappings;
};
sourceMapConsumer.SourceMapConsumer = SourceMapConsumer$1;
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$1.parseSourceMapInput(aSourceMap);
  }
  var version = util$1.getArg(sourceMap, "version");
  var sources = util$1.getArg(sourceMap, "sources");
  var names = util$1.getArg(sourceMap, "names", []);
  var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
  var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
  var mappings = util$1.getArg(sourceMap, "mappings");
  var file = util$1.getArg(sourceMap, "file", null);
  if (version != this._version) {
    throw new Error("Unsupported version: " + version);
  }
  if (sourceRoot) {
    sourceRoot = util$1.normalize(sourceRoot);
  }
  sources = sources.map(String).map(util$1.normalize).map(function(source) {
    return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
  });
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function(s2) {
    return util$1.computeSourceURL(sourceRoot, s2, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util$1.relative(this.sourceRoot, relativeSource);
  }
  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }
  var i;
  for (i = 0;i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }
  return -1;
};
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap2(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function(s2) {
    return util$1.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
  });
  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];
  for (var i = 0, length = generatedMappings.length;i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping;
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;
    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;
      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }
      destOriginalMappings.push(destMapping);
    }
    destGeneratedMappings.push(destMapping);
  }
  quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
  return smc;
};
BasicSourceMapConsumer.prototype._version = 3;
Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings4(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str2, segment, end, value;
  while (index < length) {
    if (aStr.charAt(index) === ";") {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ",") {
      index++;
    } else {
      mapping = new Mapping;
      mapping.generatedLine = generatedLine;
      for (end = index;end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str2 = aStr.slice(index, end);
      segment = cachedSegments[str2];
      if (segment) {
        index += str2.length;
      } else {
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }
        if (segment.length === 2) {
          throw new Error("Found a source, but no line and column");
        }
        if (segment.length === 3) {
          throw new Error("Found a source and line, but no column");
        }
        cachedSegments[str2] = segment;
      }
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;
      if (segment.length > 1) {
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        mapping.originalLine += 1;
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;
        if (segment.length > 4) {
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }
      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === "number") {
        originalMappings.push(mapping);
      }
    }
  }
  quickSort(generatedMappings, util$1.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util$1.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping2(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
  }
  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans2() {
  for (var index = 0;index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];
      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }
    mapping.lastGeneratedColumn = Infinity;
  }
};
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor2(aArgs) {
  var needle = {
    generatedLine: util$1.getArg(aArgs, "line"),
    generatedColumn: util$1.getArg(aArgs, "column")
  };
  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._generatedMappings[index];
    if (mapping.generatedLine === needle.generatedLine) {
      var source = util$1.getArg(mapping, "source", null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name3 = util$1.getArg(mapping, "name", null);
      if (name3 !== null) {
        name3 = this._names.at(name3);
      }
      return {
        source,
        line: util$1.getArg(mapping, "originalLine", null),
        column: util$1.getArg(mapping, "originalColumn", null),
        name: name3
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources2() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc2) {
    return sc2 == null;
  });
};
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor2(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }
  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util$1.relative(this.sourceRoot, relativeSource);
  }
  var url;
  if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }
    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor2(aArgs) {
  var source = util$1.getArg(aArgs, "source");
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  var needle = {
    source,
    originalLine: util$1.getArg(aArgs, "line"),
    originalColumn: util$1.getArg(aArgs, "column")
  };
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (mapping.source === needle.source) {
      return {
        line: util$1.getArg(mapping, "generatedLine", null),
        column: util$1.getArg(mapping, "generatedColumn", null),
        lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
      };
    }
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === "string") {
    sourceMap = util$1.parseSourceMapInput(aSourceMap);
  }
  var version = util$1.getArg(sourceMap, "version");
  var sections = util$1.getArg(sourceMap, "sections");
  if (version != this._version) {
    throw new Error("Unsupported version: " + version);
  }
  this._sources = new ArraySet;
  this._names = new ArraySet;
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function(s2) {
    if (s2.url) {
      throw new Error("Support for url field in sections not implemented.");
    }
    var offset = util$1.getArg(s2, "offset");
    var offsetLine = util$1.getArg(offset, "line");
    var offsetColumn = util$1.getArg(offset, "column");
    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error("Section offsets must be ordered and non-overlapping.");
    }
    lastOffset = offset;
    return {
      generatedOffset: {
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer$1(util$1.getArg(s2, "map"), aSourceMapURL)
    };
  });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
IndexedSourceMapConsumer.prototype._version = 3;
Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
  get: function() {
    var sources = [];
    for (var i = 0;i < this._sections.length; i++) {
      for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor2(aArgs) {
  var needle = {
    generatedLine: util$1.getArg(aArgs, "line"),
    generatedColumn: util$1.getArg(aArgs, "column")
  };
  var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
    var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }
    return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];
  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }
  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources2() {
  return this._sections.every(function(s2) {
    return s2.consumer.hasContentsOfAllSources();
  });
};
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor2(aSource, nullOnMissing) {
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor2(aArgs) {
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }
  return {
    line: null,
    column: null
  };
};
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings2(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0;i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0;j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];
      var source = section.consumer._sources.at(mapping.source);
      source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);
      var name3 = null;
      if (mapping.name) {
        name3 = section.consumer._names.at(mapping.name);
        this._names.add(name3);
        name3 = this._names.indexOf(name3);
      }
      var adjustedMapping = {
        source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name3
      };
      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === "number") {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }
  quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
};
sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
var sourceNode = {};
var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
var util = util$5;
var REGEX_NEWLINE = /(\r?\n)/;
var NEWLINE_CODE = 10;
var isSourceNode = "$$$isSourceNode$$$";
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null)
    this.add(aChunks);
}
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap2(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  var node2 = new SourceNode;
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function() {
    var lineContents = getNextLine();
    var newLine = getNextLine() || "";
    return lineContents + newLine;
    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };
  var lastGeneratedLine = 1, lastGeneratedColumn = 0;
  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function(mapping) {
    if (lastMapping !== null) {
      if (lastGeneratedLine < mapping.generatedLine) {
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
      } else {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        lastMapping = mapping;
        return;
      }
    }
    while (lastGeneratedLine < mapping.generatedLine) {
      node2.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || "";
      node2.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    node2.add(remainingLines.splice(remainingLinesIndex).join(""));
  }
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }
      node2.setSourceContent(sourceFile, content);
    }
  });
  return node2;
  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node2.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node2.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
SourceNode.prototype.add = function SourceNode_add2(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function(chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};
SourceNode.prototype.prepend = function SourceNode_prepend2(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1;i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};
SourceNode.prototype.walk = function SourceNode_walk2(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length;i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== "") {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
SourceNode.prototype.join = function SourceNode_join2(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0;i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};
SourceNode.prototype.replaceRight = function SourceNode_replaceRight2(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === "string") {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push("".replace(aPattern, aReplacement));
  }
  return this;
};
SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent2(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents2(aFn) {
  for (var i = 0, len = this.children.length;i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }
  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length;i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
SourceNode.prototype.toString = function SourceNode_toString2() {
  var str2 = "";
  this.walk(function(chunk) {
    str2 += chunk;
  });
  return str2;
};
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap2(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map3 = new SourceMapGenerator$1(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function(chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map3.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map3.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length;idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map3.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function(sourceFile, sourceContent) {
    map3.setSourceContent(sourceFile, sourceContent);
  });
  return { code: generated.code, map: map3 };
};
sourceNode.SourceNode = SourceNode;
sourceMap$1.SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
sourceMap$1.SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
sourceMap$1.SourceNode = sourceNode.SourceNode;
var sourceMap = sourceMap$1;
var SourceMapConsumer = sourceMap.SourceMapConsumer;
var SourceMapGenerator = sourceMap.SourceMapGenerator;
var mergeSourceMap = merge3;
function merge3(oldMap, newMap) {
  if (!oldMap)
    return newMap;
  if (!newMap)
    return oldMap;
  var oldMapConsumer = new SourceMapConsumer(oldMap);
  var newMapConsumer = new SourceMapConsumer(newMap);
  var mergedMapGenerator = new SourceMapGenerator;
  newMapConsumer.eachMapping(function(m2) {
    if (m2.originalLine == null)
      return;
    var origPosInOldMap = oldMapConsumer.originalPositionFor({
      line: m2.originalLine,
      column: m2.originalColumn
    });
    if (origPosInOldMap.source == null)
      return;
    mergedMapGenerator.addMapping({
      original: {
        line: origPosInOldMap.line,
        column: origPosInOldMap.column
      },
      generated: {
        line: m2.generatedLine,
        column: m2.generatedColumn
      },
      source: origPosInOldMap.source,
      name: origPosInOldMap.name
    });
  });
  var consumers = [oldMapConsumer, newMapConsumer];
  consumers.forEach(function(consumer) {
    consumer.sources.forEach(function(sourceFile) {
      mergedMapGenerator._sources.add(sourceFile);
      var sourceContent = consumer.sourceContentFor(sourceFile);
      if (sourceContent != null) {
        mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
      }
    });
  });
  mergedMapGenerator._sourceRoot = oldMap.sourceRoot;
  mergedMapGenerator._file = oldMap.file;
  return JSON.parse(mergedMapGenerator.toString());
}
var merge$1 = /* @__PURE__ */ getDefaultExportFromCjs2(mergeSourceMap);
var __defProp$5 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => (key in obj) ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
var scss = (source, map3, options3, load = __require) => {
  const nodeSass = load("sass");
  const finalOptions = __spreadProps$5(__spreadValues$5({}, options3), {
    data: getSource(source, options3.filename, options3.additionalData),
    file: options3.filename,
    outFile: options3.filename,
    sourceMap: !!map3
  });
  try {
    const result2 = nodeSass.renderSync(finalOptions);
    const dependencies = result2.stats.includedFiles;
    if (map3) {
      return {
        code: result2.css.toString(),
        map: merge$1(map3, JSON.parse(result2.map.toString())),
        errors: [],
        dependencies
      };
    }
    return { code: result2.css.toString(), errors: [], dependencies };
  } catch (e2) {
    return { code: "", errors: [e2], dependencies: [] };
  }
};
var sass = (source, map3, options3, load) => scss(source, map3, __spreadProps$5(__spreadValues$5({}, options3), {
  indentedSyntax: true
}), load);
var less = (source, map3, options3, load = __require) => {
  const nodeLess = load("less");
  let result2;
  let error2 = null;
  nodeLess.render(getSource(source, options3.filename, options3.additionalData), __spreadProps$5(__spreadValues$5({}, options3), { syncImport: true }), (err, output2) => {
    error2 = err;
    result2 = output2;
  });
  if (error2)
    return { code: "", errors: [error2], dependencies: [] };
  const dependencies = result2.imports;
  if (map3) {
    return {
      code: result2.css.toString(),
      map: merge$1(map3, result2.map),
      errors: [],
      dependencies
    };
  }
  return {
    code: result2.css.toString(),
    errors: [],
    dependencies
  };
};
var styl = (source, map3, options3, load = __require) => {
  const nodeStylus = load("stylus");
  try {
    const ref3 = nodeStylus(source, options3);
    if (map3)
      ref3.set("sourcemap", { inline: false, comment: false });
    const result2 = ref3.render();
    const dependencies = ref3.deps();
    if (map3) {
      return {
        code: result2,
        map: merge$1(map3, ref3.sourcemap),
        errors: [],
        dependencies
      };
    }
    return { code: result2, errors: [], dependencies };
  } catch (e2) {
    return { code: "", errors: [e2], dependencies: [] };
  }
};
function getSource(source, filename, additionalData) {
  if (!additionalData)
    return source;
  if (isFunction$1$1(additionalData)) {
    return additionalData(source, filename);
  }
  return additionalData + source;
}
var processors = {
  less,
  sass,
  scss,
  styl,
  stylus: styl
};
var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => (key in obj) ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
function compileStyle(options3) {
  return doCompileStyle(__spreadProps$4(__spreadValues$4({}, options3), {
    isAsync: false
  }));
}
function doCompileStyle(options3) {
  const {
    filename,
    id: id3,
    scoped = false,
    trim = true,
    isProd = false,
    modules = false,
    modulesOptions = {},
    preprocessLang,
    postcssOptions,
    postcssPlugins
  } = options3;
  const preprocessor = preprocessLang && processors[preprocessLang];
  const preProcessedSource = preprocessor && preprocess2(options3, preprocessor);
  const map3 = preProcessedSource ? preProcessedSource.map : options3.inMap || options3.map;
  const source = preProcessedSource ? preProcessedSource.code : options3.source;
  const shortId = id3.replace(/^data-v-/, "");
  const longId = `data-v-${shortId}`;
  const plugins = (postcssPlugins || []).slice();
  plugins.unshift(cssVarsPlugin({ id: shortId, isProd }));
  if (trim) {
    plugins.push(trimPlugin$1());
  }
  if (scoped) {
    plugins.push(scopedPlugin$1(longId));
  }
  let cssModules;
  if (modules) {
    {
      throw new Error("[@vue/compiler-sfc] `modules` option is not supported in the browser build.");
    }
  }
  const postCSSOptions = __spreadProps$4(__spreadValues$4({}, postcssOptions), {
    to: filename,
    from: filename
  });
  if (map3) {
    postCSSOptions.map = {
      inline: false,
      annotation: false,
      prev: map3
    };
  }
  let result2;
  let code;
  let outMap;
  const dependencies = new Set(preProcessedSource ? preProcessedSource.dependencies : []);
  dependencies.delete(filename);
  const errors3 = [];
  if (preProcessedSource && preProcessedSource.errors.length) {
    errors3.push(...preProcessedSource.errors);
  }
  const recordPlainCssDependencies = (messages) => {
    messages.forEach((msg) => {
      if (msg.type === "dependency") {
        dependencies.add(msg.file);
      }
    });
    return dependencies;
  };
  try {
    result2 = postcss$1(plugins).process(source, postCSSOptions);
    if (options3.isAsync) {
      return result2.then((result22) => ({
        code: result22.css || "",
        map: result22.map && result22.map.toJSON(),
        errors: errors3,
        modules: cssModules,
        rawResult: result22,
        dependencies: recordPlainCssDependencies(result22.messages)
      })).catch((error2) => ({
        code: "",
        map: undefined,
        errors: [...errors3, error2],
        rawResult: undefined,
        dependencies
      }));
    }
    recordPlainCssDependencies(result2.messages);
    code = result2.css;
    outMap = result2.map;
  } catch (e2) {
    errors3.push(e2);
  }
  return {
    code: code || ``,
    map: outMap && outMap.toJSON(),
    errors: errors3,
    rawResult: result2,
    dependencies
  };
}
function preprocess2(options3, preprocessor) {
  if (!options3.preprocessCustomRequire) {
    throw new Error(`[@vue/compiler-sfc] Style preprocessing in the browser build must provide the \`preprocessCustomRequire\` option to return the in-browser version of the preprocessor.`);
  }
  return preprocessor(options3.source, options3.inMap || options3.map, __spreadValues$4({
    filename: options3.filename
  }, options3.preprocessOptions), options3.preprocessCustomRequire);
}
var comma = 44;
var semicolon = 59;
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0;i < chars2.length; i++) {
  const c3 = chars2.charCodeAt(i);
  intToChar[i] = c3;
  charToInt[c3] = i;
}
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0;i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode3(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i = 0;i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0;j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

class BitSet {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
}

class Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn2) {
    let chunk = this;
    while (chunk) {
      fn2(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn2) {
    let chunk = this;
    while (chunk) {
      fn2(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", undefined, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", undefined, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", undefined, true);
      }
      return true;
    } else {
      this.edit("", undefined, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
}
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str2) => window.btoa(unescape(encodeURIComponent(str2)));
  } else if (typeof Buffer === "function") {
    return (str2) => Buffer.from(str2, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa2 = /* @__PURE__ */ getBtoa();

class SourceMap {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode3(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
  }
}
function guessIndent(code) {
  const lines = code.split(`
`);
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "\t";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from2, to) {
  const fromParts = from2.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString3 = Object.prototype.toString;
function isObject$3(thing) {
  return toString3.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split(`
`);
  const lineOffsets = [];
  for (let i = 0, pos = 0;i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m2 = i + j >> 1;
      if (index < lineOffsets[m2]) {
        j = m2;
      } else {
        i = m2 + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;

class Mappings {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      let contentLineEnd = content.indexOf(`
`, 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf(`
`, contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === "boundary") {
          if (wordRegex.test(original[originalCharIndex])) {
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === `
`) {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str2) {
    if (!str2)
      return;
    const lines = str2.split(`
`);
    if (lines.length > 1) {
      for (let i = 0;i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
}
var n2 = `
`;
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};

class MagicString {
  constructor(string4, options3 = {}) {
    const chunk = new Chunk(0, string4.length, string4);
    Object.defineProperties(this, {
      original: { writable: true, value: string4 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options3.filename },
      indentExclusionRanges: { writable: true, value: options3.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: undefined },
      ignoreList: { writable: true, value: options3.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string4.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options3) {
    options3 = options3 || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options3.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options3.file ? options3.file.split(/[/\\]/).pop() : undefined,
      sources: [
        options3.source ? getRelativePath(options3.file || "", options3.source) : options3.file || ""
      ],
      sourcesContent: options3.includeContent ? [this.original] : undefined,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined
    };
  }
  generateMap(options3) {
    return new SourceMap(this.generateDecodedMap(options3));
  }
  _ensureindentStr() {
    if (this.indentStr === undefined) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "\t" : this.indentStr;
  }
  indent(indentStr, options3) {
    const pattern2 = /^[^\r\n]/gm;
    if (isObject$3(indentStr)) {
      options3 = indentStr;
      indentStr = undefined;
    }
    if (indentStr === undefined) {
      this._ensureindentStr();
      indentStr = this.indentStr || "\t";
    }
    if (indentStr === "")
      return this;
    options3 = options3 || {};
    const isExcluded = {};
    if (options3.exclude) {
      const exclusions = typeof options3.exclude[0] === "number" ? [options3.exclude] : options3.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0];i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options3.indentStart !== false;
    const replacer2 = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern2, replacer2);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern2, replacer2);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === `
`;
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === `
`) {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern2, replacer2);
    return this;
  }
  insert() {
    throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last2 = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last2.next;
    const newRight = this.byStart[index];
    if (!newRight && last2 === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last2;
    if (!first.previous)
      this.firstChunk = last2.next;
    if (!last2.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last2.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last2;
    return this;
  }
  overwrite(start, end, content, options3) {
    options3 = options3 || {};
    return this.update(start, end, content, { ...options3, overwrite: !options3.contentOnly });
  }
  update(start, end, content, options3) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
    this._split(start);
    this._split(end);
    if (options3 === true) {
      if (!warned.storeName) {
        console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
        warned.storeName = true;
      }
      options3 = { storeName: true };
    }
    const storeName = options3 !== undefined ? options3.storeName : false;
    const overwrite = options3 !== undefined ? options3.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last2 = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last2) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last2.next = newChunk;
      newChunk.previous = last2;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n2);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n2);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n2);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n2);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n2);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result2 = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result2;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result2 += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result2 += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result2 += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result2;
  }
  snip(start, end) {
    const clone2 = this.clone();
    clone2.remove(0, start);
    clone2.remove(end, clone2.original.length);
    return clone2;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`);
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str2 = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str2 += chunk.toString();
      chunk = chunk.next;
    }
    return str2 + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str2) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str2, match.groups);
      }
    }
    function matchAll(re2, str2) {
      let match;
      const matches = [];
      while (match = re2.exec(str2)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null)
          this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));
    }
    return this;
  }
  _replaceString(string4, replacement) {
    const { original } = this;
    const index = original.indexOf(string4);
    if (index !== -1) {
      this.overwrite(index, index + string4.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string4, replacement) {
    const { original } = this;
    const stringLength = string4.length;
    for (let index = original.indexOf(string4);index !== -1; index = original.indexOf(string4, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
    }
    return this._replaceRegexp(searchValue, replacement);
  }
}
var CONVERT_SYMBOL = "$";
var ESCAPE_SYMBOL = "$$";
var IMPORT_SOURCE = "vue/macros";
var shorthands = ["ref", "computed", "shallowRef", "toRef", "customRef"];
var transformCheckRE = /[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\<)/;
function shouldTransform(src2) {
  return transformCheckRE.test(src2);
}
function transformAST(ast, s2, offset = 0, knownRefs, knownProps) {
  warnExperimental();
  const userImports = /* @__PURE__ */ Object.create(null);
  for (const node2 of ast.body) {
    if (node2.type !== "ImportDeclaration")
      continue;
    walkImportDeclaration(node2);
  }
  let convertSymbol;
  let escapeSymbol;
  for (const { local, imported, source, specifier } of Object.values(userImports)) {
    if (source === IMPORT_SOURCE) {
      if (imported === ESCAPE_SYMBOL) {
        escapeSymbol = local;
      } else if (imported === CONVERT_SYMBOL) {
        convertSymbol = local;
      } else if (imported !== local) {
        error2(`macro imports for ref-creating methods do not support aliasing.`, specifier);
      }
    }
  }
  if (!convertSymbol && !userImports[CONVERT_SYMBOL]) {
    convertSymbol = CONVERT_SYMBOL;
  }
  if (!escapeSymbol && !userImports[ESCAPE_SYMBOL]) {
    escapeSymbol = ESCAPE_SYMBOL;
  }
  const importedHelpers = /* @__PURE__ */ new Set;
  const rootScope = {};
  const scopeStack = [rootScope];
  let currentScope = rootScope;
  let escapeScope;
  const excludedIds = /* @__PURE__ */ new WeakSet;
  const parentStack = [];
  const propsLocalToPublicMap = /* @__PURE__ */ Object.create(null);
  if (knownRefs) {
    for (const key of knownRefs) {
      rootScope[key] = {};
    }
  }
  if (knownProps) {
    for (const key in knownProps) {
      const { local, isConst: isConst2 } = knownProps[key];
      rootScope[local] = {
        isProp: true,
        isConst: !!isConst2
      };
      propsLocalToPublicMap[local] = key;
    }
  }
  function walkImportDeclaration(node2) {
    const source = node2.source.value;
    if (source === IMPORT_SOURCE) {
      s2.remove(node2.start + offset, node2.end + offset);
    }
    for (const specifier of node2.specifiers) {
      const local = specifier.local.name;
      const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name || "default";
      userImports[local] = {
        source,
        local,
        imported,
        specifier
      };
    }
  }
  function isRefCreationCall(callee) {
    if (!convertSymbol || currentScope[convertSymbol] !== undefined) {
      return false;
    }
    if (callee === convertSymbol) {
      return convertSymbol;
    }
    if (callee[0] === "$" && shorthands.includes(callee.slice(1))) {
      return callee;
    }
    return false;
  }
  function error2(msg, node2) {
    const e2 = new Error(msg);
    e2.node = node2;
    throw e2;
  }
  function helper(msg) {
    importedHelpers.add(msg);
    return `_${msg}`;
  }
  function registerBinding(id3, binding2) {
    excludedIds.add(id3);
    if (currentScope) {
      currentScope[id3.name] = binding2 ? binding2 : false;
    } else {
      error2("registerBinding called without active scope, something is wrong.", id3);
    }
  }
  const registerRefBinding = (id3, isConst2 = false) => registerBinding(id3, { isConst: isConst2 });
  let tempVarCount = 0;
  function genTempVar() {
    return `__$temp_${++tempVarCount}`;
  }
  function snip(node2) {
    return s2.original.slice(node2.start + offset, node2.end + offset);
  }
  function walkScope(node2, isRoot2 = false) {
    for (const stmt of node2.body) {
      if (stmt.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt, isRoot2);
      } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
        if (stmt.declare || !stmt.id)
          continue;
        registerBinding(stmt.id);
      } else if ((stmt.type === "ForOfStatement" || stmt.type === "ForInStatement") && stmt.left.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.left);
      } else if (stmt.type === "ExportNamedDeclaration" && stmt.declaration && stmt.declaration.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.declaration, isRoot2);
      } else if (stmt.type === "LabeledStatement" && stmt.body.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.body, isRoot2);
      }
    }
  }
  function walkVariableDeclaration(stmt, isRoot2 = false) {
    if (stmt.declare) {
      return;
    }
    for (const decl of stmt.declarations) {
      let refCall;
      const isCall = decl.init && decl.init.type === "CallExpression" && decl.init.callee.type === "Identifier";
      if (isCall && (refCall = isRefCreationCall(decl.init.callee.name))) {
        processRefDeclaration(refCall, decl.id, decl.init, stmt.kind === "const");
      } else {
        const isProps = isRoot2 && isCall && decl.init.callee.name === "defineProps";
        for (const id3 of extractIdentifiers(decl.id)) {
          if (isProps) {
            excludedIds.add(id3);
          } else {
            registerBinding(id3);
          }
        }
      }
    }
  }
  function processRefDeclaration(method, id3, call, isConst2) {
    excludedIds.add(call.callee);
    if (method === convertSymbol) {
      s2.remove(call.callee.start + offset, call.callee.end + offset);
      if (id3.type === "Identifier") {
        registerRefBinding(id3, isConst2);
      } else if (id3.type === "ObjectPattern") {
        processRefObjectPattern(id3, call, isConst2);
      } else if (id3.type === "ArrayPattern") {
        processRefArrayPattern(id3, call, isConst2);
      }
    } else {
      if (id3.type === "Identifier") {
        registerRefBinding(id3, isConst2);
        s2.overwrite(call.start + offset, call.start + method.length + offset, helper(method.slice(1)));
      } else {
        error2(`${method}() cannot be used with destructure patterns.`, call);
      }
    }
  }
  function processRefObjectPattern(pattern2, call, isConst2, tempVar, path3 = []) {
    if (!tempVar) {
      tempVar = genTempVar();
      s2.overwrite(pattern2.start + offset, pattern2.end + offset, tempVar);
    }
    let nameId;
    for (const p2 of pattern2.properties) {
      let key;
      let defaultValue;
      if (p2.type === "ObjectProperty") {
        if (p2.key.start === p2.value.start) {
          nameId = p2.key;
          if (p2.value.type === "Identifier") {
            excludedIds.add(p2.value);
          } else if (p2.value.type === "AssignmentPattern" && p2.value.left.type === "Identifier") {
            excludedIds.add(p2.value.left);
            defaultValue = p2.value.right;
          }
        } else {
          key = p2.computed ? p2.key : p2.key.name;
          if (p2.value.type === "Identifier") {
            nameId = p2.value;
          } else if (p2.value.type === "ObjectPattern") {
            processRefObjectPattern(p2.value, call, isConst2, tempVar, [
              ...path3,
              key
            ]);
          } else if (p2.value.type === "ArrayPattern") {
            processRefArrayPattern(p2.value, call, isConst2, tempVar, [
              ...path3,
              key
            ]);
          } else if (p2.value.type === "AssignmentPattern") {
            if (p2.value.left.type === "Identifier") {
              nameId = p2.value.left;
              defaultValue = p2.value.right;
            } else if (p2.value.left.type === "ObjectPattern") {
              processRefObjectPattern(p2.value.left, call, isConst2, tempVar, [
                ...path3,
                [key, p2.value.right]
              ]);
            } else if (p2.value.left.type === "ArrayPattern") {
              processRefArrayPattern(p2.value.left, call, isConst2, tempVar, [
                ...path3,
                [key, p2.value.right]
              ]);
            } else
              ;
          }
        }
      } else {
        error2(`reactivity destructure does not support rest elements.`, p2);
      }
      if (nameId) {
        registerRefBinding(nameId, isConst2);
        const source = pathToString(tempVar, path3);
        const keyStr = isString$2(key) ? `'${key}'` : key ? snip(key) : `'${nameId.name}'`;
        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;
        s2.appendLeft(call.end + offset, `,
  ${nameId.name} = ${helper("toRef")}(${source}, ${keyStr}${defaultStr})`);
      }
    }
    if (nameId) {
      s2.appendLeft(call.end + offset, ";");
    }
  }
  function processRefArrayPattern(pattern2, call, isConst2, tempVar, path3 = []) {
    if (!tempVar) {
      tempVar = genTempVar();
      s2.overwrite(pattern2.start + offset, pattern2.end + offset, tempVar);
    }
    let nameId;
    for (let i = 0;i < pattern2.elements.length; i++) {
      const e2 = pattern2.elements[i];
      if (!e2)
        continue;
      let defaultValue;
      if (e2.type === "Identifier") {
        nameId = e2;
      } else if (e2.type === "AssignmentPattern") {
        nameId = e2.left;
        defaultValue = e2.right;
      } else if (e2.type === "RestElement") {
        error2(`reactivity destructure does not support rest elements.`, e2);
      } else if (e2.type === "ObjectPattern") {
        processRefObjectPattern(e2, call, isConst2, tempVar, [...path3, i]);
      } else if (e2.type === "ArrayPattern") {
        processRefArrayPattern(e2, call, isConst2, tempVar, [...path3, i]);
      }
      if (nameId) {
        registerRefBinding(nameId, isConst2);
        const source = pathToString(tempVar, path3);
        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;
        s2.appendLeft(call.end + offset, `,
  ${nameId.name} = ${helper("toRef")}(${source}, ${i}${defaultStr})`);
      }
    }
    if (nameId) {
      s2.appendLeft(call.end + offset, ";");
    }
  }
  function pathToString(source, path3) {
    if (path3.length) {
      for (const seg of path3) {
        if (isArray$3(seg)) {
          source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`;
        } else {
          source += segToString(seg);
        }
      }
    }
    return source;
  }
  function segToString(seg) {
    if (typeof seg === "number") {
      return `[${seg}]`;
    } else if (typeof seg === "string") {
      return `.${seg}`;
    } else {
      return snip(seg);
    }
  }
  function rewriteId(scope, id3, parent, parentStack2) {
    if (hasOwn$1(scope, id3.name)) {
      const binding2 = scope[id3.name];
      if (binding2) {
        if (binding2.isConst && (parent.type === "AssignmentExpression" && id3 === parent.left || parent.type === "UpdateExpression")) {
          error2(`Assignment to constant variable.`, id3);
        }
        const { isProp } = binding2;
        if (isStaticProperty(parent) && parent.shorthand) {
          if (!parent.inPattern || isInDestructureAssignment(parent, parentStack2)) {
            if (isProp) {
              if (escapeScope) {
                registerEscapedPropBinding(id3);
                s2.appendLeft(id3.end + offset, `: __props_${propsLocalToPublicMap[id3.name]}`);
              } else {
                s2.appendLeft(id3.end + offset, `: ${genPropsAccessExp(propsLocalToPublicMap[id3.name])}`);
              }
            } else {
              s2.appendLeft(id3.end + offset, `: ${id3.name}.value`);
            }
          }
        } else {
          if (isProp) {
            if (escapeScope) {
              registerEscapedPropBinding(id3);
              s2.overwrite(id3.start + offset, id3.end + offset, `__props_${propsLocalToPublicMap[id3.name]}`);
            } else {
              s2.overwrite(id3.start + offset, id3.end + offset, genPropsAccessExp(propsLocalToPublicMap[id3.name]));
            }
          } else {
            s2.appendLeft(id3.end + offset, ".value");
          }
        }
      }
      return true;
    }
    return false;
  }
  const propBindingRefs = {};
  function registerEscapedPropBinding(id3) {
    if (!propBindingRefs.hasOwnProperty(id3.name)) {
      propBindingRefs[id3.name] = true;
      const publicKey = propsLocalToPublicMap[id3.name];
      s2.prependRight(offset, `const __props_${publicKey} = ${helper(`toRef`)}(__props, '${publicKey}');
`);
    }
  }
  walkScope(ast, true);
  walk$1(ast, {
    enter(node2, parent) {
      parent && parentStack.push(parent);
      if (isFunctionType(node2)) {
        scopeStack.push(currentScope = {});
        walkFunctionParams(node2, registerBinding);
        if (node2.body.type === "BlockStatement") {
          walkScope(node2.body);
        }
        return;
      }
      if (node2.type === "CatchClause") {
        scopeStack.push(currentScope = {});
        if (node2.param && node2.param.type === "Identifier") {
          registerBinding(node2.param);
        }
        walkScope(node2.body);
        return;
      }
      if (node2.type === "BlockStatement" && !isFunctionType(parent)) {
        scopeStack.push(currentScope = {});
        walkScope(node2);
        return;
      }
      if (parent && parent.type.startsWith("TS") && parent.type !== "TSAsExpression" && parent.type !== "TSNonNullExpression" && parent.type !== "TSTypeAssertion") {
        return this.skip();
      }
      if (node2.type === "Identifier") {
        const binding2 = rootScope[node2.name];
        if (!(escapeScope && (!binding2 || !binding2.isProp)) && isReferencedIdentifier(node2, parent, parentStack) && !excludedIds.has(node2)) {
          let i = scopeStack.length;
          while (i--) {
            if (rewriteId(scopeStack[i], node2, parent, parentStack)) {
              return;
            }
          }
        }
      }
      if (node2.type === "CallExpression" && node2.callee.type === "Identifier") {
        const callee = node2.callee.name;
        const refCall = isRefCreationCall(callee);
        if (refCall && (!parent || parent.type !== "VariableDeclarator")) {
          return error2(`${refCall} can only be used as the initializer of a variable declaration.`, node2);
        }
        if (escapeSymbol && currentScope[escapeSymbol] === undefined && callee === escapeSymbol) {
          escapeScope = node2;
          s2.remove(node2.callee.start + offset, node2.callee.end + offset);
          if ((parent == null ? undefined : parent.type) === "ExpressionStatement") {
            let i = (node2.leadingComments ? node2.leadingComments[0].start : node2.start) + offset;
            while (i--) {
              const char = s2.original.charAt(i);
              if (char === `
`) {
                s2.prependRight(node2.start + offset, ";");
                break;
              } else if (!/\s/.test(char)) {
                break;
              }
            }
          }
        }
      }
    },
    leave(node2, parent) {
      parent && parentStack.pop();
      if (node2.type === "BlockStatement" && !isFunctionType(parent) || isFunctionType(node2)) {
        scopeStack.pop();
        currentScope = scopeStack[scopeStack.length - 1] || null;
      }
      if (node2 === escapeScope) {
        escapeScope = undefined;
      }
    }
  });
  return {
    rootRefs: Object.keys(rootScope).filter((key) => {
      const binding2 = rootScope[key];
      return binding2 && !binding2.isProp;
    }),
    importedHelpers: [...importedHelpers]
  };
}
var hasWarned$2 = {};
function warnExperimental() {
  if (typeof window !== "undefined") {
    return;
  }
  warnOnce$5(`Reactivity Transform was an experimental feature and has now been deprecated. It will be removed from Vue core in 3.4. If you intend to continue using it, switch to https://vue-macros.sxzz.moe/features/reactivity-transform.html.
See reason for deprecation here: https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028`);
}
function warnOnce$5(msg) {
  const isNodeProd = typeof process !== "undefined" && false;
  if (!isNodeProd && true && !hasWarned$2[msg]) {
    hasWarned$2[msg] = true;
    warn$2(msg);
  }
}
function warn$2(msg) {
  console.warn(`\x1B[1m\x1B[33m[@vue/reactivity-transform]\x1B[0m\x1B[33m ${msg}\x1B[0m
`);
}
function analyzeScriptBindings(ast) {
  for (const node2 of ast) {
    if (node2.type === "ExportDefaultDeclaration" && node2.declaration.type === "ObjectExpression") {
      return analyzeBindingsFromOptions(node2.declaration);
    }
  }
  return {};
}
function analyzeBindingsFromOptions(node2) {
  const bindings = {};
  Object.defineProperty(bindings, "__isScriptSetup", {
    enumerable: false,
    value: false
  });
  for (const property of node2.properties) {
    if (property.type === "ObjectProperty" && !property.computed && property.key.type === "Identifier") {
      if (property.key.name === "props") {
        for (const key of getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = "props";
        }
      } else if (property.key.name === "inject") {
        for (const key of getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = "options";
        }
      } else if (property.value.type === "ObjectExpression" && (property.key.name === "computed" || property.key.name === "methods")) {
        for (const key of getObjectExpressionKeys(property.value)) {
          bindings[key] = "options";
        }
      }
    } else if (property.type === "ObjectMethod" && property.key.type === "Identifier" && (property.key.name === "setup" || property.key.name === "data")) {
      for (const bodyItem of property.body.body) {
        if (bodyItem.type === "ReturnStatement" && bodyItem.argument && bodyItem.argument.type === "ObjectExpression") {
          for (const key of getObjectExpressionKeys(bodyItem.argument)) {
            bindings[key] = property.key.name === "setup" ? "setup-maybe-ref" : "data";
          }
        }
      }
    }
  }
  return bindings;
}
function getObjectExpressionKeys(node2) {
  const keys = [];
  for (const prop of node2.properties) {
    if (prop.type === "SpreadElement")
      continue;
    const key = resolveObjectKey(prop.key, prop.computed);
    if (key)
      keys.push(String(key));
  }
  return keys;
}
function getArrayExpressionKeys(node2) {
  const keys = [];
  for (const element of node2.elements) {
    if (element && element.type === "StringLiteral") {
      keys.push(element.value);
    }
  }
  return keys;
}
function getObjectOrArrayExpressionKeys(value) {
  if (value.type === "ArrayExpression") {
    return getArrayExpressionKeys(value);
  }
  if (value.type === "ObjectExpression") {
    return getObjectExpressionKeys(value);
  }
  return [];
}
function rewriteDefaultAST(ast, s2, as) {
  if (!hasDefaultExport(ast)) {
    s2.append(`
const ${as} = {}`);
    return;
  }
  ast.forEach((node2) => {
    if (node2.type === "ExportDefaultDeclaration") {
      if (node2.declaration.type === "ClassDeclaration" && node2.declaration.id) {
        let start = node2.declaration.decorators && node2.declaration.decorators.length > 0 ? node2.declaration.decorators[node2.declaration.decorators.length - 1].end : node2.start;
        s2.overwrite(start, node2.declaration.id.start, ` class `);
        s2.append(`
const ${as} = ${node2.declaration.id.name}`);
      } else {
        s2.overwrite(node2.start, node2.declaration.start, `const ${as} = `);
      }
    } else if (node2.type === "ExportNamedDeclaration") {
      for (const specifier of node2.specifiers) {
        if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === "default") {
          if (node2.source) {
            if (specifier.local.name === "default") {
              s2.prepend(`import { default as __VUE_DEFAULT__ } from '${node2.source.value}'
`);
              const end2 = specifierEnd(s2, specifier.local.end, node2.end);
              s2.remove(specifier.start, end2);
              s2.append(`
const ${as} = __VUE_DEFAULT__`);
              continue;
            } else {
              s2.prepend(`import { ${s2.slice(specifier.local.start, specifier.local.end)} as __VUE_DEFAULT__ } from '${node2.source.value}'
`);
              const end2 = specifierEnd(s2, specifier.exported.end, node2.end);
              s2.remove(specifier.start, end2);
              s2.append(`
const ${as} = __VUE_DEFAULT__`);
              continue;
            }
          }
          const end = specifierEnd(s2, specifier.end, node2.end);
          s2.remove(specifier.start, end);
          s2.append(`
const ${as} = ${specifier.local.name}`);
        }
      }
    }
  });
}
function hasDefaultExport(ast) {
  for (const stmt of ast) {
    if (stmt.type === "ExportDefaultDeclaration") {
      return true;
    } else if (stmt.type === "ExportNamedDeclaration" && stmt.specifiers.some((spec) => spec.exported.name === "default")) {
      return true;
    }
  }
  return false;
}
function specifierEnd(s2, end, nodeEnd) {
  let hasCommas = false;
  let oldEnd = end;
  while (end < nodeEnd) {
    if (/\s/.test(s2.slice(end, end + 1))) {
      end++;
    } else if (s2.slice(end, end + 1) === ",") {
      end++;
      hasCommas = true;
      break;
    } else if (s2.slice(end, end + 1) === "}") {
      break;
    }
  }
  return hasCommas ? end : oldEnd;
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => (key in obj) ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var normalScriptDefaultVar = `__default__`;
function processNormalScript(ctx, scopeId) {
  var _a3;
  const script = ctx.descriptor.script;
  if (script.lang && !ctx.isJS && !ctx.isTS) {
    return script;
  }
  try {
    let content = script.content;
    let map3 = script.map;
    const scriptAst = ctx.scriptAst;
    const bindings = analyzeScriptBindings(scriptAst.body);
    const { source, filename, cssVars } = ctx.descriptor;
    const { sourceMap: sourceMap2, genDefaultAs, isProd } = ctx.options;
    if (ctx.options.reactivityTransform && shouldTransform(content)) {
      const s2 = new MagicString(source);
      const startOffset = script.loc.start.offset;
      const endOffset = script.loc.end.offset;
      const { importedHelpers } = transformAST(scriptAst, s2, startOffset);
      if (importedHelpers.length) {
        s2.prepend(`import { ${importedHelpers.map((h8) => `${h8} as _${h8}`).join(", ")} } from 'vue'
`);
      }
      s2.remove(0, startOffset);
      s2.remove(endOffset, source.length);
      content = s2.toString();
      if (sourceMap2 !== false) {
        map3 = s2.generateMap({
          source: filename,
          hires: true,
          includeContent: true
        });
      }
    }
    if (cssVars.length || genDefaultAs) {
      const defaultVar = genDefaultAs || normalScriptDefaultVar;
      const s2 = new MagicString(content);
      rewriteDefaultAST(scriptAst.body, s2, defaultVar);
      content = s2.toString();
      if (cssVars.length && !((_a3 = ctx.options.templateOptions) == null ? undefined : _a3.ssr)) {
        content += genNormalScriptCssVarsCode(cssVars, bindings, scopeId, !!isProd, defaultVar);
      }
      if (!genDefaultAs) {
        content += `
export default ${defaultVar}`;
      }
    }
    return __spreadProps$2(__spreadValues$2({}, script), {
      content,
      map: map3,
      bindings,
      scriptAst: scriptAst.body
    });
  } catch (e2) {
    return script;
  }
}
var _a3;
var _b2;

class ScriptCompileContext {
  constructor(descriptor, options3) {
    this.descriptor = descriptor;
    this.options = options3;
    this.source = this.descriptor.source;
    this.filename = this.descriptor.filename;
    this.s = new MagicString(this.source);
    this.startOffset = (_a3 = this.descriptor.scriptSetup) == null ? undefined : _a3.loc.start.offset;
    this.endOffset = (_b2 = this.descriptor.scriptSetup) == null ? undefined : _b2.loc.end.offset;
    this.userImports = /* @__PURE__ */ Object.create(null);
    this.hasDefinePropsCall = false;
    this.hasDefineEmitCall = false;
    this.hasDefineExposeCall = false;
    this.hasDefaultExportName = false;
    this.hasDefaultExportRender = false;
    this.hasDefineOptionsCall = false;
    this.hasDefineSlotsCall = false;
    this.hasDefineModelCall = false;
    this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null);
    this.modelDecls = /* @__PURE__ */ Object.create(null);
    this.bindingMetadata = {};
    this.helperImports = /* @__PURE__ */ new Set;
    const { script, scriptSetup } = descriptor;
    const scriptLang = script && script.lang;
    const scriptSetupLang = scriptSetup && scriptSetup.lang;
    this.isJS = scriptLang === "js" || scriptLang === "jsx" || scriptSetupLang === "js" || scriptSetupLang === "jsx";
    this.isTS = scriptLang === "ts" || scriptLang === "tsx" || scriptSetupLang === "ts" || scriptSetupLang === "tsx";
    const plugins = resolveParserPlugins(scriptLang || scriptSetupLang, options3.babelParserPlugins);
    function parse(input2, offset) {
      try {
        return parse_1$1(input2, {
          plugins,
          sourceType: "module"
        }).program;
      } catch (e2) {
        e2.message = `[vue/compiler-sfc] ${e2.message}

${descriptor.filename}
${generateCodeFrame$1(descriptor.source, e2.pos + offset, e2.pos + offset + 1)}`;
        throw e2;
      }
    }
    this.scriptAst = descriptor.script && parse(descriptor.script.content, descriptor.script.loc.start.offset);
    this.scriptSetupAst = descriptor.scriptSetup && parse(descriptor.scriptSetup.content, this.startOffset);
  }
  helper(key) {
    this.helperImports.add(key);
    return `_${key}`;
  }
  getString(node2, scriptSetup = true) {
    const block = scriptSetup ? this.descriptor.scriptSetup : this.descriptor.script;
    return block.content.slice(node2.start, node2.end);
  }
  error(msg, node2, scope) {
    const offset = scope ? scope.offset : this.startOffset;
    throw new Error(`[@vue/compiler-sfc] ${msg}

${(scope || this.descriptor).filename}
${generateCodeFrame$1((scope || this.descriptor).source, node2.start + offset, node2.end + offset)}`);
  }
}
function resolveParserPlugins(lang, userPlugins, dts = false) {
  const plugins = [];
  if (lang === "jsx" || lang === "tsx") {
    plugins.push("jsx");
  } else if (userPlugins) {
    userPlugins = userPlugins.filter((p2) => p2 !== "jsx");
  }
  if (lang === "ts" || lang === "tsx") {
    plugins.push(["typescript", { dts }]);
    if (!plugins.includes("decorators")) {
      plugins.push("decorators-legacy");
    }
  }
  if (userPlugins) {
    plugins.push(...userPlugins);
  }
  return plugins;
}
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => (key in obj) ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));

class TypeScope {
  constructor(filename, source, offset = 0, imports2 = /* @__PURE__ */ Object.create(null), types5 = /* @__PURE__ */ Object.create(null), declares = /* @__PURE__ */ Object.create(null)) {
    this.filename = filename;
    this.source = source;
    this.offset = offset;
    this.imports = imports2;
    this.types = types5;
    this.declares = declares;
    this.resolvedImportSources = /* @__PURE__ */ Object.create(null);
    this.exportedTypes = /* @__PURE__ */ Object.create(null);
    this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function resolveTypeElements(ctx, node2, scope) {
  if (node2._resolvedElements) {
    return node2._resolvedElements;
  }
  return node2._resolvedElements = innerResolveTypeElements(ctx, node2, node2._ownerScope || scope || ctxToScope(ctx));
}
function innerResolveTypeElements(ctx, node2, scope) {
  var _a4, _b3;
  switch (node2.type) {
    case "TSTypeLiteral":
      return typeElementsToMap(ctx, node2.members, scope);
    case "TSInterfaceDeclaration":
      return resolveInterfaceMembers(ctx, node2, scope);
    case "TSTypeAliasDeclaration":
    case "TSParenthesizedType":
      return resolveTypeElements(ctx, node2.typeAnnotation, scope);
    case "TSFunctionType": {
      return { props: {}, calls: [node2] };
    }
    case "TSUnionType":
    case "TSIntersectionType":
      return mergeElements(node2.types.map((t2) => resolveTypeElements(ctx, t2, scope)), node2.type);
    case "TSMappedType":
      return resolveMappedType(ctx, node2, scope);
    case "TSIndexedAccessType": {
      const types5 = resolveIndexType(ctx, node2, scope);
      return mergeElements(types5.map((t2) => resolveTypeElements(ctx, t2, t2._ownerScope)), "TSUnionType");
    }
    case "TSExpressionWithTypeArguments":
    case "TSTypeReference": {
      const typeName = getReferenceName(node2);
      if ((typeName === "ExtractPropTypes" || typeName === "ExtractPublicPropTypes") && node2.typeParameters && ((_a4 = scope.imports[typeName]) == null ? undefined : _a4.source) === "vue") {
        return resolveExtractPropTypes(resolveTypeElements(ctx, node2.typeParameters.params[0], scope), scope);
      }
      const resolved = resolveTypeReference(ctx, node2, scope);
      if (resolved) {
        return resolveTypeElements(ctx, resolved, resolved._ownerScope);
      } else {
        if (typeof typeName === "string") {
          if (SupportedBuiltinsSet.has(typeName)) {
            return resolveBuiltin(ctx, node2, typeName, scope);
          } else if (typeName === "ReturnType" && node2.typeParameters) {
            const ret = resolveReturnType(ctx, node2.typeParameters.params[0], scope);
            if (ret) {
              return resolveTypeElements(ctx, ret, scope);
            }
          }
        }
        return ctx.error(`Unresolvable type reference or unsupported built-in utility type`, node2, scope);
      }
    }
    case "TSImportType": {
      if (getId(node2.argument) === "vue" && ((_b3 = node2.qualifier) == null ? undefined : _b3.type) === "Identifier" && node2.qualifier.name === "ExtractPropTypes" && node2.typeParameters) {
        return resolveExtractPropTypes(resolveTypeElements(ctx, node2.typeParameters.params[0], scope), scope);
      }
      const sourceScope = importSourceToScope(ctx, node2.argument, scope, node2.argument.value);
      const resolved = resolveTypeReference(ctx, node2, sourceScope);
      if (resolved) {
        return resolveTypeElements(ctx, resolved, resolved._ownerScope);
      }
      break;
    }
    case "TSTypeQuery":
      {
        const resolved = resolveTypeReference(ctx, node2, scope);
        if (resolved) {
          return resolveTypeElements(ctx, resolved, resolved._ownerScope);
        }
      }
      break;
  }
  return ctx.error(`Unresolvable type: ${node2.type}`, node2, scope);
}
function typeElementsToMap(ctx, elements, scope = ctxToScope(ctx)) {
  const res = { props: {} };
  for (const e2 of elements) {
    if (e2.type === "TSPropertySignature" || e2.type === "TSMethodSignature") {
      e2._ownerScope = scope;
      const name3 = getId(e2.key);
      if (name3 && !e2.computed) {
        res.props[name3] = e2;
      } else if (e2.key.type === "TemplateLiteral") {
        for (const key of resolveTemplateKeys(ctx, e2.key, scope)) {
          res.props[key] = e2;
        }
      } else {
        ctx.error(`Unsupported computed key in type referenced by a macro`, e2.key, scope);
      }
    } else if (e2.type === "TSCallSignatureDeclaration") {
      (res.calls || (res.calls = [])).push(e2);
    }
  }
  return res;
}
function mergeElements(maps, type) {
  if (maps.length === 1)
    return maps[0];
  const res = { props: {} };
  const { props: baseProps } = res;
  for (const { props, calls } of maps) {
    for (const key in props) {
      if (!hasOwn$1(baseProps, key)) {
        baseProps[key] = props[key];
      } else {
        baseProps[key] = createProperty(baseProps[key].key, {
          type,
          types: [baseProps[key], props[key]]
        }, baseProps[key]._ownerScope, baseProps[key].optional || props[key].optional);
      }
    }
    if (calls) {
      (res.calls || (res.calls = [])).push(...calls);
    }
  }
  return res;
}
function createProperty(key, typeAnnotation, scope, optional) {
  return {
    type: "TSPropertySignature",
    key,
    kind: "get",
    optional,
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation
    },
    _ownerScope: scope
  };
}
function resolveInterfaceMembers(ctx, node2, scope) {
  const base2 = typeElementsToMap(ctx, node2.body.body, node2._ownerScope);
  if (node2.extends) {
    for (const ext of node2.extends) {
      if (ext.leadingComments && ext.leadingComments.some((c3) => c3.value.includes("@vue-ignore"))) {
        continue;
      }
      try {
        const { props } = resolveTypeElements(ctx, ext, scope);
        for (const key in props) {
          if (!hasOwn$1(base2.props, key)) {
            base2.props[key] = props[key];
          }
        }
      } catch (e2) {
        ctx.error(`Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`, ext);
      }
    }
  }
  return base2;
}
function resolveMappedType(ctx, node2, scope) {
  const res = { props: {} };
  const keys = resolveStringType(ctx, node2.typeParameter.constraint, scope);
  for (const key of keys) {
    res.props[key] = createProperty({
      type: "Identifier",
      name: key
    }, node2.typeAnnotation, scope, !!node2.optional);
  }
  return res;
}
function resolveIndexType(ctx, node2, scope) {
  var _a4, _b3;
  if (node2.indexType.type === "TSNumberKeyword") {
    return resolveArrayElementType(ctx, node2.objectType, scope);
  }
  const { indexType, objectType } = node2;
  const types5 = [];
  let keys;
  let resolved;
  if (indexType.type === "TSStringKeyword") {
    resolved = resolveTypeElements(ctx, objectType, scope);
    keys = Object.keys(resolved.props);
  } else {
    keys = resolveStringType(ctx, indexType, scope);
    resolved = resolveTypeElements(ctx, objectType, scope);
  }
  for (const key of keys) {
    const targetType = (_b3 = (_a4 = resolved.props[key]) == null ? undefined : _a4.typeAnnotation) == null ? undefined : _b3.typeAnnotation;
    if (targetType) {
      targetType._ownerScope = resolved.props[key]._ownerScope;
      types5.push(targetType);
    }
  }
  return types5;
}
function resolveArrayElementType(ctx, node2, scope) {
  if (node2.type === "TSArrayType") {
    return [node2.elementType];
  }
  if (node2.type === "TSTupleType") {
    return node2.elementTypes.map((t2) => t2.type === "TSNamedTupleMember" ? t2.elementType : t2);
  }
  if (node2.type === "TSTypeReference") {
    if (getReferenceName(node2) === "Array" && node2.typeParameters) {
      return node2.typeParameters.params;
    } else {
      const resolved = resolveTypeReference(ctx, node2, scope);
      if (resolved) {
        return resolveArrayElementType(ctx, resolved, scope);
      }
    }
  }
  return ctx.error("Failed to resolve element type from target type", node2, scope);
}
function resolveStringType(ctx, node2, scope) {
  switch (node2.type) {
    case "StringLiteral":
      return [node2.value];
    case "TSLiteralType":
      return resolveStringType(ctx, node2.literal, scope);
    case "TSUnionType":
      return node2.types.map((t2) => resolveStringType(ctx, t2, scope)).flat();
    case "TemplateLiteral": {
      return resolveTemplateKeys(ctx, node2, scope);
    }
    case "TSTypeReference": {
      const resolved = resolveTypeReference(ctx, node2, scope);
      if (resolved) {
        return resolveStringType(ctx, resolved, scope);
      }
      if (node2.typeName.type === "Identifier") {
        const getParam = (index = 0) => resolveStringType(ctx, node2.typeParameters.params[index], scope);
        switch (node2.typeName.name) {
          case "Extract":
            return getParam(1);
          case "Exclude": {
            const excluded = getParam(1);
            return getParam().filter((s2) => !excluded.includes(s2));
          }
          case "Uppercase":
            return getParam().map((s2) => s2.toUpperCase());
          case "Lowercase":
            return getParam().map((s2) => s2.toLowerCase());
          case "Capitalize":
            return getParam().map(capitalize$1);
          case "Uncapitalize":
            return getParam().map((s2) => s2[0].toLowerCase() + s2.slice(1));
          default:
            ctx.error("Unsupported type when resolving index type", node2.typeName, scope);
        }
      }
    }
  }
  return ctx.error("Failed to resolve index type into finite keys", node2, scope);
}
function resolveTemplateKeys(ctx, node2, scope) {
  if (!node2.expressions.length) {
    return [node2.quasis[0].value.raw];
  }
  const res = [];
  const e2 = node2.expressions[0];
  const q = node2.quasis[0];
  const leading = q ? q.value.raw : ``;
  const resolved = resolveStringType(ctx, e2, scope);
  const restResolved = resolveTemplateKeys(ctx, __spreadProps$1(__spreadValues$1({}, node2), {
    expressions: node2.expressions.slice(1),
    quasis: q ? node2.quasis.slice(1) : node2.quasis
  }), scope);
  for (const r3 of resolved) {
    for (const rr of restResolved) {
      res.push(leading + r3 + rr);
    }
  }
  return res;
}
var SupportedBuiltinsSet = /* @__PURE__ */ new Set([
  "Partial",
  "Required",
  "Readonly",
  "Pick",
  "Omit"
]);
function resolveBuiltin(ctx, node2, name3, scope) {
  const t2 = resolveTypeElements(ctx, node2.typeParameters.params[0], scope);
  switch (name3) {
    case "Partial": {
      const res2 = { props: {}, calls: t2.calls };
      Object.keys(t2.props).forEach((key) => {
        res2.props[key] = __spreadProps$1(__spreadValues$1({}, t2.props[key]), { optional: true });
      });
      return res2;
    }
    case "Required": {
      const res2 = { props: {}, calls: t2.calls };
      Object.keys(t2.props).forEach((key) => {
        res2.props[key] = __spreadProps$1(__spreadValues$1({}, t2.props[key]), { optional: false });
      });
      return res2;
    }
    case "Readonly":
      return t2;
    case "Pick": {
      const picked = resolveStringType(ctx, node2.typeParameters.params[1], scope);
      const res2 = { props: {}, calls: t2.calls };
      for (const key of picked) {
        res2.props[key] = t2.props[key];
      }
      return res2;
    }
    case "Omit":
      const omitted = resolveStringType(ctx, node2.typeParameters.params[1], scope);
      const res = { props: {}, calls: t2.calls };
      for (const key in t2.props) {
        if (!omitted.includes(key)) {
          res.props[key] = t2.props[key];
        }
      }
      return res;
  }
}
function resolveTypeReference(ctx, node2, scope, name3, onlyExported = false) {
  if (node2._resolvedReference) {
    return node2._resolvedReference;
  }
  return node2._resolvedReference = innerResolveTypeReference(ctx, scope || ctxToScope(ctx), name3 || getReferenceName(node2), node2, onlyExported);
}
function innerResolveTypeReference(ctx, scope, name3, node2, onlyExported) {
  if (typeof name3 === "string") {
    if (scope.imports[name3]) {
      return resolveTypeFromImport(ctx, node2, name3, scope);
    } else {
      const lookupSource = node2.type === "TSTypeQuery" ? onlyExported ? scope.exportedDeclares : scope.declares : onlyExported ? scope.exportedTypes : scope.types;
      if (lookupSource[name3]) {
        return lookupSource[name3];
      } else {
        const globalScopes = resolveGlobalScope(ctx);
        if (globalScopes) {
          for (const s2 of globalScopes) {
            const src2 = node2.type === "TSTypeQuery" ? s2.declares : s2.types;
            if (src2[name3]) {
              (ctx.deps || (ctx.deps = /* @__PURE__ */ new Set)).add(s2.filename);
              return src2[name3];
            }
          }
        }
      }
    }
  } else {
    let ns = innerResolveTypeReference(ctx, scope, name3[0], node2, onlyExported);
    if (ns) {
      if (ns.type !== "TSModuleDeclaration") {
        ns = ns._ns;
      }
      if (ns) {
        const childScope = moduleDeclToScope(ctx, ns, ns._ownerScope || scope);
        return innerResolveTypeReference(ctx, childScope, name3.length > 2 ? name3.slice(1) : name3[name3.length - 1], node2, !ns.declare);
      }
    }
  }
}
function getReferenceName(node2) {
  const ref3 = node2.type === "TSTypeReference" ? node2.typeName : node2.type === "TSExpressionWithTypeArguments" ? node2.expression : node2.type === "TSImportType" ? node2.qualifier : node2.exprName;
  if ((ref3 == null ? undefined : ref3.type) === "Identifier") {
    return ref3.name;
  } else if ((ref3 == null ? undefined : ref3.type) === "TSQualifiedName") {
    return qualifiedNameToPath(ref3);
  } else {
    return "default";
  }
}
function qualifiedNameToPath(node2) {
  if (node2.type === "Identifier") {
    return [node2.name];
  } else {
    return [...qualifiedNameToPath(node2.left), node2.right.name];
  }
}
function resolveGlobalScope(ctx) {
  if (ctx.options.globalTypeFiles) {
    const fs = resolveFS(ctx);
    if (!fs) {
      throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
    }
    return ctx.options.globalTypeFiles.map((file) => fileToScope(ctx, normalizePath(file), true));
  }
}
function resolveFS(ctx) {
  if (ctx.fs) {
    return ctx.fs;
  }
  const fs = ctx.options.fs || undefined;
  if (!fs) {
    return;
  }
  return ctx.fs = {
    fileExists(file) {
      if (file.endsWith(".vue.ts")) {
        file = file.replace(/\.ts$/, "");
      }
      return fs.fileExists(file);
    },
    readFile(file) {
      if (file.endsWith(".vue.ts")) {
        file = file.replace(/\.ts$/, "");
      }
      return fs.readFile(file);
    }
  };
}
function resolveTypeFromImport(ctx, node2, name3, scope) {
  const { source, imported } = scope.imports[name3];
  const sourceScope = importSourceToScope(ctx, node2, scope, source);
  return resolveTypeReference(ctx, node2, sourceScope, imported, true);
}
function importSourceToScope(ctx, node2, scope, source) {
  const fs = resolveFS(ctx);
  if (!fs) {
    return ctx.error(`No fs option provided to \`compileScript\` in non-Node environment. File system access is required for resolving imported types.`, node2, scope);
  }
  let resolved = scope.resolvedImportSources[source];
  if (!resolved) {
    if (source.startsWith(".")) {
      const filename = joinPaths(dirname$2(scope.filename), source);
      resolved = resolveExt(filename, fs);
    } else {
      {
        return ctx.error(`Type import from non-relative sources is not supported in the browser build.`, node2, scope);
      }
    }
    if (resolved) {
      resolved = scope.resolvedImportSources[source] = normalizePath(resolved);
    }
  }
  if (resolved) {
    (ctx.deps || (ctx.deps = /* @__PURE__ */ new Set)).add(resolved);
    return fileToScope(ctx, resolved);
  } else {
    return ctx.error(`Failed to resolve import source ${JSON.stringify(source)}.`, node2, scope);
  }
}
function resolveExt(filename, fs) {
  filename = filename.replace(/\.js$/, "");
  const tryResolve = (filename2) => {
    if (fs.fileExists(filename2))
      return filename2;
  };
  return tryResolve(filename) || tryResolve(filename + `.ts`) || tryResolve(filename + `.d.ts`) || tryResolve(joinPaths(filename, `index.ts`)) || tryResolve(joinPaths(filename, `index.d.ts`));
}
var fileToScopeCache = createCache();
function fileToScope(ctx, filename, asGlobal = false) {
  const cached = fileToScopeCache.get(filename);
  if (cached) {
    return cached;
  }
  const fs = resolveFS(ctx);
  const source = fs.readFile(filename) || "";
  const body = parseFile(filename, source, ctx.options.babelParserPlugins);
  const scope = new TypeScope(filename, source, 0, recordImports(body));
  recordTypes(ctx, body, scope, asGlobal);
  fileToScopeCache.set(filename, scope);
  return scope;
}
function parseFile(filename, content, parserPlugins) {
  const ext = extname(filename);
  if (ext === ".ts" || ext === ".tsx") {
    return parse_1$1(content, {
      plugins: resolveParserPlugins(ext.slice(1), parserPlugins, filename.endsWith(".d.ts")),
      sourceType: "module"
    }).program.body;
  } else if (ext === ".vue") {
    const {
      descriptor: { script, scriptSetup }
    } = parse$7(content);
    if (!script && !scriptSetup) {
      return [];
    }
    const scriptOffset = script ? script.loc.start.offset : Infinity;
    const scriptSetupOffset = scriptSetup ? scriptSetup.loc.start.offset : Infinity;
    const firstBlock = scriptOffset < scriptSetupOffset ? script : scriptSetup;
    const secondBlock = scriptOffset < scriptSetupOffset ? scriptSetup : script;
    let scriptContent = " ".repeat(Math.min(scriptOffset, scriptSetupOffset)) + firstBlock.content;
    if (secondBlock) {
      scriptContent += " ".repeat(secondBlock.loc.start.offset - script.loc.end.offset) + secondBlock.content;
    }
    const lang = (script == null ? undefined : script.lang) || (scriptSetup == null ? undefined : scriptSetup.lang);
    return parse_1$1(scriptContent, {
      plugins: resolveParserPlugins(lang, parserPlugins),
      sourceType: "module"
    }).program.body;
  }
  return [];
}
function ctxToScope(ctx) {
  if (ctx.scope) {
    return ctx.scope;
  }
  const body = "ast" in ctx ? ctx.ast : ctx.scriptAst ? [...ctx.scriptAst.body, ...ctx.scriptSetupAst.body] : ctx.scriptSetupAst.body;
  const scope = new TypeScope(ctx.filename, ctx.source, "startOffset" in ctx ? ctx.startOffset : 0, "userImports" in ctx ? Object.create(ctx.userImports) : recordImports(body));
  recordTypes(ctx, body, scope);
  return ctx.scope = scope;
}
function moduleDeclToScope(ctx, node2, parentScope) {
  if (node2._resolvedChildScope) {
    return node2._resolvedChildScope;
  }
  const scope = new TypeScope(parentScope.filename, parentScope.source, parentScope.offset, Object.create(parentScope.imports), Object.create(parentScope.types), Object.create(parentScope.declares));
  if (node2.body.type === "TSModuleDeclaration") {
    const decl = node2.body;
    decl._ownerScope = scope;
    const id3 = getId(decl.id);
    scope.types[id3] = scope.exportedTypes[id3] = decl;
  } else {
    recordTypes(ctx, node2.body.body, scope);
  }
  return node2._resolvedChildScope = scope;
}
var importExportRE = /^Import|^Export/;
function recordTypes(ctx, body, scope, asGlobal = false) {
  const { types: types5, declares, exportedTypes, exportedDeclares, imports: imports2 } = scope;
  const isAmbient = asGlobal ? !body.some((s2) => importExportRE.test(s2.type)) : false;
  for (const stmt of body) {
    if (asGlobal) {
      if (isAmbient) {
        if (stmt.declare) {
          recordType(stmt, types5, declares);
        }
      } else if (stmt.type === "TSModuleDeclaration" && stmt.global) {
        for (const s2 of stmt.body.body) {
          recordType(s2, types5, declares);
        }
      }
    } else {
      recordType(stmt, types5, declares);
    }
  }
  if (!asGlobal) {
    for (const stmt of body) {
      if (stmt.type === "ExportNamedDeclaration") {
        if (stmt.declaration) {
          recordType(stmt.declaration, types5, declares);
          recordType(stmt.declaration, exportedTypes, exportedDeclares);
        } else {
          for (const spec of stmt.specifiers) {
            if (spec.type === "ExportSpecifier") {
              const local = spec.local.name;
              const exported = getId(spec.exported);
              if (stmt.source) {
                imports2[exported] = {
                  source: stmt.source.value,
                  imported: local
                };
                exportedTypes[exported] = {
                  type: "TSTypeReference",
                  typeName: {
                    type: "Identifier",
                    name: local
                  },
                  _ownerScope: scope
                };
              } else if (types5[local]) {
                exportedTypes[exported] = types5[local];
              }
            }
          }
        }
      } else if (stmt.type === "ExportAllDeclaration") {
        const sourceScope = importSourceToScope(ctx, stmt.source, scope, stmt.source.value);
        Object.assign(scope.exportedTypes, sourceScope.exportedTypes);
      } else if (stmt.type === "ExportDefaultDeclaration" && stmt.declaration) {
        if (stmt.declaration.type !== "Identifier") {
          recordType(stmt.declaration, types5, declares, "default");
          recordType(stmt.declaration, exportedTypes, exportedDeclares, "default");
        } else if (types5[stmt.declaration.name]) {
          exportedTypes["default"] = types5[stmt.declaration.name];
        }
      }
    }
  }
  for (const key of Object.keys(types5)) {
    const node2 = types5[key];
    node2._ownerScope = scope;
    if (node2._ns)
      node2._ns._ownerScope = scope;
  }
  for (const key of Object.keys(declares)) {
    declares[key]._ownerScope = scope;
  }
}
function recordType(node2, types5, declares, overwriteId) {
  switch (node2.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const id3 = overwriteId || getId(node2.id);
      let existing = types5[id3];
      if (existing) {
        if (node2.type === "TSModuleDeclaration") {
          if (existing.type === "TSModuleDeclaration") {
            mergeNamespaces(existing, node2);
          } else {
            attachNamespace(existing, node2);
          }
          break;
        }
        if (existing.type === "TSModuleDeclaration") {
          types5[id3] = node2;
          attachNamespace(node2, existing);
          break;
        }
        if (existing.type !== node2.type) {
          break;
        }
        if (node2.type === "TSInterfaceDeclaration") {
          existing.body.body.push(...node2.body.body);
        } else {
          existing.members.push(...node2.members);
        }
      } else {
        types5[id3] = node2;
      }
      break;
    }
    case "ClassDeclaration":
      if (overwriteId || node2.id)
        types5[overwriteId || getId(node2.id)] = node2;
      break;
    case "TSTypeAliasDeclaration":
      types5[node2.id.name] = node2.typeAnnotation;
      break;
    case "TSDeclareFunction":
      if (node2.id)
        declares[node2.id.name] = node2;
      break;
    case "VariableDeclaration": {
      if (node2.declare) {
        for (const decl of node2.declarations) {
          if (decl.id.type === "Identifier" && decl.id.typeAnnotation) {
            declares[decl.id.name] = decl.id.typeAnnotation.typeAnnotation;
          }
        }
      }
      break;
    }
  }
}
function mergeNamespaces(to, from2) {
  const toBody = to.body;
  const fromBody = from2.body;
  if (toBody.type === "TSModuleDeclaration") {
    if (fromBody.type === "TSModuleDeclaration") {
      mergeNamespaces(toBody, fromBody);
    } else {
      fromBody.body.push({
        type: "ExportNamedDeclaration",
        declaration: toBody,
        exportKind: "type",
        specifiers: []
      });
    }
  } else if (fromBody.type === "TSModuleDeclaration") {
    toBody.body.push({
      type: "ExportNamedDeclaration",
      declaration: fromBody,
      exportKind: "type",
      specifiers: []
    });
  } else {
    toBody.body.push(...fromBody.body);
  }
}
function attachNamespace(to, ns) {
  if (!to._ns) {
    to._ns = ns;
  } else {
    mergeNamespaces(to._ns, ns);
  }
}
function recordImports(body) {
  const imports2 = /* @__PURE__ */ Object.create(null);
  for (const s2 of body) {
    recordImport(s2, imports2);
  }
  return imports2;
}
function recordImport(node2, imports2) {
  if (node2.type !== "ImportDeclaration") {
    return;
  }
  for (const s2 of node2.specifiers) {
    imports2[s2.local.name] = {
      imported: getImportedName(s2),
      source: node2.source.value
    };
  }
}
function inferRuntimeType(ctx, node2, scope = node2._ownerScope || ctxToScope(ctx)) {
  try {
    switch (node2.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const types5 = /* @__PURE__ */ new Set;
        const members = node2.type === "TSTypeLiteral" ? node2.members : node2.body.body;
        for (const m2 of members) {
          if (m2.type === "TSCallSignatureDeclaration" || m2.type === "TSConstructSignatureDeclaration") {
            types5.add("Function");
          } else {
            types5.add("Object");
          }
        }
        return types5.size ? Array.from(types5) : ["Object"];
      }
      case "TSPropertySignature":
        if (node2.typeAnnotation) {
          return inferRuntimeType(ctx, node2.typeAnnotation.typeAnnotation, scope);
        }
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (node2.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [UNKNOWN_TYPE];
        }
      case "TSTypeReference": {
        const resolved = resolveTypeReference(ctx, node2, scope);
        if (resolved) {
          return inferRuntimeType(ctx, resolved, resolved._ownerScope);
        }
        if (node2.typeName.type === "Identifier") {
          switch (node2.typeName.name) {
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
            case "Error":
              return [node2.typeName.name];
            case "Partial":
            case "Required":
            case "Readonly":
            case "Record":
            case "Pick":
            case "Omit":
            case "InstanceType":
              return ["Object"];
            case "Uppercase":
            case "Lowercase":
            case "Capitalize":
            case "Uncapitalize":
              return ["String"];
            case "Parameters":
            case "ConstructorParameters":
              return ["Array"];
            case "NonNullable":
              if (node2.typeParameters && node2.typeParameters.params[0]) {
                return inferRuntimeType(ctx, node2.typeParameters.params[0], scope).filter((t2) => t2 !== "null");
              }
              break;
            case "Extract":
              if (node2.typeParameters && node2.typeParameters.params[1]) {
                return inferRuntimeType(ctx, node2.typeParameters.params[1], scope);
              }
              break;
            case "Exclude":
            case "OmitThisParameter":
              if (node2.typeParameters && node2.typeParameters.params[0]) {
                return inferRuntimeType(ctx, node2.typeParameters.params[0], scope);
              }
              break;
          }
        }
        break;
      }
      case "TSParenthesizedType":
        return inferRuntimeType(ctx, node2.typeAnnotation, scope);
      case "TSUnionType":
        return flattenTypes(ctx, node2.types, scope);
      case "TSIntersectionType": {
        return flattenTypes(ctx, node2.types, scope).filter((t2) => t2 !== UNKNOWN_TYPE);
      }
      case "TSEnumDeclaration":
        return inferEnumType(node2);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType": {
        const types5 = resolveIndexType(ctx, node2, scope);
        return flattenTypes(ctx, types5, scope);
      }
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const sourceScope = importSourceToScope(ctx, node2.argument, scope, node2.argument.value);
        const resolved = resolveTypeReference(ctx, node2, sourceScope);
        if (resolved) {
          return inferRuntimeType(ctx, resolved, resolved._ownerScope);
        }
        break;
      }
      case "TSTypeQuery": {
        const id3 = node2.exprName;
        if (id3.type === "Identifier") {
          const matched = scope.declares[id3.name];
          if (matched) {
            return inferRuntimeType(ctx, matched, matched._ownerScope);
          }
        }
        break;
      }
    }
  } catch (e2) {}
  return [UNKNOWN_TYPE];
}
function flattenTypes(ctx, types5, scope) {
  if (types5.length === 1) {
    return inferRuntimeType(ctx, types5[0], scope);
  }
  return [
    ...new Set([].concat(...types5.map((t2) => inferRuntimeType(ctx, t2, scope))))
  ];
}
function inferEnumType(node2) {
  const types5 = /* @__PURE__ */ new Set;
  for (const m2 of node2.members) {
    if (m2.initializer) {
      switch (m2.initializer.type) {
        case "StringLiteral":
          types5.add("String");
          break;
        case "NumericLiteral":
          types5.add("Number");
          break;
      }
    }
  }
  return types5.size ? [...types5] : ["Number"];
}
function resolveExtractPropTypes({ props }, scope) {
  const res = { props: {} };
  for (const key in props) {
    const raw = props[key];
    res.props[key] = reverseInferType(raw.key, raw.typeAnnotation.typeAnnotation, scope);
  }
  return res;
}
function reverseInferType(key, node2, scope, optional = true, checkObjectSyntax = true) {
  if (checkObjectSyntax && node2.type === "TSTypeLiteral") {
    const typeType = findStaticPropertyType(node2, "type");
    if (typeType) {
      const requiredType = findStaticPropertyType(node2, "required");
      const optional2 = requiredType && requiredType.type === "TSLiteralType" && requiredType.literal.type === "BooleanLiteral" ? !requiredType.literal.value : true;
      return reverseInferType(key, typeType, scope, optional2, false);
    }
  } else if (node2.type === "TSTypeReference" && node2.typeName.type === "Identifier") {
    if (node2.typeName.name.endsWith("Constructor")) {
      return createProperty(key, ctorToType(node2.typeName.name), scope, optional);
    } else if (node2.typeName.name === "PropType" && node2.typeParameters) {
      return createProperty(key, node2.typeParameters.params[0], scope, optional);
    }
  }
  if ((node2.type === "TSTypeReference" || node2.type === "TSImportType") && node2.typeParameters) {
    for (const t2 of node2.typeParameters.params) {
      const inferred = reverseInferType(key, t2, scope, optional);
      if (inferred)
        return inferred;
    }
  }
  return createProperty(key, { type: `TSNullKeyword` }, scope, optional);
}
function ctorToType(ctorType) {
  const ctor = ctorType.slice(0, -11);
  switch (ctor) {
    case "String":
    case "Number":
    case "Boolean":
      return { type: `TS${ctor}Keyword` };
    case "Array":
    case "Function":
    case "Object":
    case "Set":
    case "Map":
    case "WeakSet":
    case "WeakMap":
    case "Date":
    case "Promise":
      return {
        type: "TSTypeReference",
        typeName: { type: "Identifier", name: ctor }
      };
  }
  return { type: `TSNullKeyword` };
}
function findStaticPropertyType(node2, key) {
  const prop = node2.members.find((m2) => m2.type === "TSPropertySignature" && !m2.computed && getId(m2.key) === key && m2.typeAnnotation);
  return prop && prop.typeAnnotation.typeAnnotation;
}
function resolveReturnType(ctx, arg, scope) {
  var _a4;
  let resolved = arg;
  if (arg.type === "TSTypeReference" || arg.type === "TSTypeQuery" || arg.type === "TSImportType") {
    resolved = resolveTypeReference(ctx, arg, scope);
  }
  if (!resolved)
    return;
  if (resolved.type === "TSFunctionType") {
    return (_a4 = resolved.typeAnnotation) == null ? undefined : _a4.typeAnnotation;
  }
  if (resolved.type === "TSDeclareFunction") {
    return resolved.returnType;
  }
}
function resolveUnionType(ctx, node2, scope) {
  if (node2.type === "TSTypeReference") {
    const resolved = resolveTypeReference(ctx, node2, scope);
    if (resolved)
      node2 = resolved;
  }
  let types5;
  if (node2.type === "TSUnionType") {
    types5 = node2.types.flatMap((node22) => resolveUnionType(ctx, node22, scope));
  } else {
    types5 = [node2];
  }
  return types5;
}
var DEFINE_MODEL = "defineModel";
function processDefineModel(ctx, node2, declId) {
  if (!isCallOf(node2, DEFINE_MODEL)) {
    return false;
  }
  if (!ctx.options.defineModel) {
    warnOnce$4(`defineModel() is an experimental feature and disabled by default.
To enable it, follow the RFC at https://github.com/vuejs/rfcs/discussions/503.`);
    return false;
  }
  warnOnce$4(`This project is using defineModel(), which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.
To stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/503.`);
  ctx.hasDefineModelCall = true;
  const type = node2.typeParameters && node2.typeParameters.params[0] || undefined;
  let modelName;
  let options3;
  const arg0 = node2.arguments[0] && unwrapTSNode(node2.arguments[0]);
  if (arg0 && arg0.type === "StringLiteral") {
    modelName = arg0.value;
    options3 = node2.arguments[1];
  } else {
    modelName = "modelValue";
    options3 = arg0;
  }
  if (ctx.modelDecls[modelName]) {
    ctx.error(`duplicate model name ${JSON.stringify(modelName)}`, node2);
  }
  const optionsString = options3 && ctx.getString(options3);
  ctx.modelDecls[modelName] = {
    type,
    options: optionsString,
    identifier: declId && declId.type === "Identifier" ? declId.name : undefined
  };
  ctx.bindingMetadata[modelName] = "props";
  let runtimeOptions = "";
  if (options3) {
    if (options3.type === "ObjectExpression") {
      const local = options3.properties.find((p2) => p2.type === "ObjectProperty" && (p2.key.type === "Identifier" && p2.key.name === "local" || p2.key.type === "StringLiteral" && p2.key.value === "local"));
      if (local) {
        runtimeOptions = `{ ${ctx.getString(local)} }`;
      } else {
        for (const p2 of options3.properties) {
          if (p2.type === "SpreadElement" || p2.computed) {
            runtimeOptions = optionsString;
            break;
          }
        }
      }
    } else {
      runtimeOptions = optionsString;
    }
  }
  ctx.s.overwrite(ctx.startOffset + node2.start, ctx.startOffset + node2.end, `${ctx.helper("useModel")}(__props, ${JSON.stringify(modelName)}${runtimeOptions ? `, ${runtimeOptions}` : ``})`);
  return true;
}
function genModelProps(ctx) {
  if (!ctx.hasDefineModelCall)
    return;
  const isProd = !!ctx.options.isProd;
  let modelPropsDecl = "";
  for (const [name3, { type, options: options3 }] of Object.entries(ctx.modelDecls)) {
    let skipCheck = false;
    let runtimeTypes = type && inferRuntimeType(ctx, type);
    if (runtimeTypes) {
      const hasUnknownType = runtimeTypes.includes(UNKNOWN_TYPE);
      runtimeTypes = runtimeTypes.filter((el) => {
        if (el === UNKNOWN_TYPE)
          return false;
        return isProd ? el === "Boolean" || el === "Function" && options3 : true;
      });
      skipCheck = !isProd && hasUnknownType && runtimeTypes.length > 0;
    }
    let runtimeType = runtimeTypes && runtimeTypes.length > 0 && toRuntimeTypeString(runtimeTypes) || undefined;
    const codegenOptions = concatStrings([
      runtimeType && `type: ${runtimeType}`,
      skipCheck && "skipCheck: true"
    ]);
    let decl;
    if (runtimeType && options3) {
      decl = ctx.isTS ? `{ ${codegenOptions}, ...${options3} }` : `Object.assign({ ${codegenOptions} }, ${options3})`;
    } else {
      decl = options3 || (runtimeType ? `{ ${codegenOptions} }` : "{}");
    }
    modelPropsDecl += `
    ${JSON.stringify(name3)}: ${decl},`;
  }
  return `{${modelPropsDecl}
  }`;
}
var DEFINE_PROPS = "defineProps";
var WITH_DEFAULTS = "withDefaults";
function processDefineProps(ctx, node2, declId) {
  if (!isCallOf(node2, DEFINE_PROPS)) {
    return processWithDefaults(ctx, node2, declId);
  }
  if (ctx.hasDefinePropsCall) {
    ctx.error(`duplicate ${DEFINE_PROPS}() call`, node2);
  }
  ctx.hasDefinePropsCall = true;
  ctx.propsRuntimeDecl = node2.arguments[0];
  if (ctx.propsRuntimeDecl) {
    for (const key of getObjectOrArrayExpressionKeys(ctx.propsRuntimeDecl)) {
      if (!(key in ctx.bindingMetadata)) {
        ctx.bindingMetadata[key] = "props";
      }
    }
  }
  if (node2.typeParameters) {
    if (ctx.propsRuntimeDecl) {
      ctx.error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node2);
    }
    ctx.propsTypeDecl = node2.typeParameters.params[0];
  }
  if (declId && declId.type === "ObjectPattern") {
    processPropsDestructure(ctx, declId);
  }
  ctx.propsCall = node2;
  ctx.propsDecl = declId;
  return true;
}
function processWithDefaults(ctx, node2, declId) {
  if (!isCallOf(node2, WITH_DEFAULTS)) {
    return false;
  }
  if (!processDefineProps(ctx, node2.arguments[0], declId)) {
    ctx.error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node2.arguments[0] || node2);
  }
  if (ctx.propsRuntimeDecl) {
    ctx.error(`${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`, node2);
  }
  if (ctx.propsDestructureDecl) {
    ctx.error(`${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`, node2.callee);
  }
  ctx.propsRuntimeDefaults = node2.arguments[1];
  if (!ctx.propsRuntimeDefaults) {
    ctx.error(`The 2nd argument of ${WITH_DEFAULTS} is required.`, node2);
  }
  ctx.propsCall = node2;
  return true;
}
function genRuntimeProps(ctx) {
  let propsDecls;
  if (ctx.propsRuntimeDecl) {
    propsDecls = ctx.getString(ctx.propsRuntimeDecl).trim();
    if (ctx.propsDestructureDecl) {
      const defaults = [];
      for (const key in ctx.propsDestructuredBindings) {
        const d = genDestructuredDefaultValue(ctx, key);
        const finalKey = getEscapedKey(key);
        if (d)
          defaults.push(`${finalKey}: ${d.valueString}${d.needSkipFactory ? `, __skip_${finalKey}: true` : ``}`);
      }
      if (defaults.length) {
        propsDecls = `${ctx.helper(`mergeDefaults`)}(${propsDecls}, {
  ${defaults.join(`,
  `)}
})`;
      }
    }
  } else if (ctx.propsTypeDecl) {
    propsDecls = genRuntimePropsFromTypes(ctx);
  }
  const modelsDecls = genModelProps(ctx);
  if (propsDecls && modelsDecls) {
    return `${ctx.helper("mergeModels")}(${propsDecls}, ${modelsDecls})`;
  } else {
    return modelsDecls || propsDecls;
  }
}
function genRuntimePropsFromTypes(ctx) {
  const props = resolveRuntimePropsFromType(ctx, ctx.propsTypeDecl);
  if (!props.length) {
    return;
  }
  const propStrings = [];
  const hasStaticDefaults = hasStaticWithDefaults(ctx);
  for (const prop of props) {
    propStrings.push(genRuntimePropFromType(ctx, prop, hasStaticDefaults));
    if (!(prop.key in ctx.bindingMetadata)) {
      ctx.bindingMetadata[prop.key] = "props";
    }
  }
  let propsDecls = `{
    ${propStrings.join(`,
    `)}
  }`;
  if (ctx.propsRuntimeDefaults && !hasStaticDefaults) {
    propsDecls = `${ctx.helper("mergeDefaults")}(${propsDecls}, ${ctx.getString(ctx.propsRuntimeDefaults)})`;
  }
  return propsDecls;
}
function resolveRuntimePropsFromType(ctx, node2) {
  const props = [];
  const elements = resolveTypeElements(ctx, node2);
  for (const key in elements.props) {
    const e2 = elements.props[key];
    let type = inferRuntimeType(ctx, e2);
    let skipCheck = false;
    if (type.includes(UNKNOWN_TYPE)) {
      if (type.includes("Boolean") || type.includes("Function")) {
        type = type.filter((t2) => t2 !== UNKNOWN_TYPE);
        skipCheck = true;
      } else {
        type = ["null"];
      }
    }
    props.push({
      key,
      required: !e2.optional,
      type: type || [`null`],
      skipCheck
    });
  }
  return props;
}
function genRuntimePropFromType(ctx, { key, required, type, skipCheck }, hasStaticDefaults) {
  let defaultString;
  const destructured = genDestructuredDefaultValue(ctx, key, type);
  if (destructured) {
    defaultString = `default: ${destructured.valueString}${destructured.needSkipFactory ? `, skipFactory: true` : ``}`;
  } else if (hasStaticDefaults) {
    const prop = ctx.propsRuntimeDefaults.properties.find((node2) => {
      if (node2.type === "SpreadElement")
        return false;
      return resolveObjectKey(node2.key, node2.computed) === key;
    });
    if (prop) {
      if (prop.type === "ObjectProperty") {
        defaultString = `default: ${ctx.getString(prop.value)}`;
      } else {
        defaultString = `${prop.async ? "async " : ""}${prop.kind !== "method" ? `${prop.kind} ` : ""}default() ${ctx.getString(prop.body)}`;
      }
    }
  }
  const finalKey = getEscapedKey(key);
  if (!ctx.options.isProd) {
    return `${finalKey}: { ${concatStrings([
      `type: ${toRuntimeTypeString(type)}`,
      `required: ${required}`,
      skipCheck && "skipCheck: true",
      defaultString
    ])} }`;
  } else if (type.some((el) => el === "Boolean" || (!hasStaticDefaults || defaultString) && el === "Function")) {
    return `${finalKey}: { ${concatStrings([
      `type: ${toRuntimeTypeString(type)}`,
      defaultString
    ])} }`;
  } else {
    return `${finalKey}: ${defaultString ? `{ ${defaultString} }` : `{}`}`;
  }
}
function hasStaticWithDefaults(ctx) {
  return !!(ctx.propsRuntimeDefaults && ctx.propsRuntimeDefaults.type === "ObjectExpression" && ctx.propsRuntimeDefaults.properties.every((node2) => node2.type !== "SpreadElement" && (!node2.computed || node2.key.type.endsWith("Literal"))));
}
function genDestructuredDefaultValue(ctx, key, inferredType) {
  const destructured = ctx.propsDestructuredBindings[key];
  const defaultVal = destructured && destructured.default;
  if (defaultVal) {
    const value = ctx.getString(defaultVal);
    const unwrapped = unwrapTSNode(defaultVal);
    if (inferredType && inferredType.length && !inferredType.includes("null")) {
      const valueType = inferValueType(unwrapped);
      if (valueType && !inferredType.includes(valueType)) {
        ctx.error(`Default value of prop "${key}" does not match declared type.`, unwrapped);
      }
    }
    const needSkipFactory = !inferredType && (isFunctionType(unwrapped) || unwrapped.type === "Identifier");
    const needFactoryWrap = !needSkipFactory && !isLiteralNode(unwrapped) && !(inferredType == null ? undefined : inferredType.includes("Function"));
    return {
      valueString: needFactoryWrap ? `() => (${value})` : value,
      needSkipFactory
    };
  }
}
function inferValueType(node2) {
  switch (node2.type) {
    case "StringLiteral":
      return "String";
    case "NumericLiteral":
      return "Number";
    case "BooleanLiteral":
      return "Boolean";
    case "ObjectExpression":
      return "Object";
    case "ArrayExpression":
      return "Array";
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return "Function";
  }
}
function processPropsDestructure(ctx, declId) {
  if (!ctx.options.propsDestructure && !ctx.options.reactivityTransform) {
    return;
  }
  warnOnce$4(`This project is using reactive props destructure, which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.
To stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/502.`);
  ctx.propsDestructureDecl = declId;
  const registerBinding = (key, local, defaultValue) => {
    ctx.propsDestructuredBindings[key] = { local, default: defaultValue };
    if (local !== key) {
      ctx.bindingMetadata[local] = "props-aliased";
      (ctx.bindingMetadata.__propsAliases || (ctx.bindingMetadata.__propsAliases = {}))[local] = key;
    }
  };
  for (const prop of declId.properties) {
    if (prop.type === "ObjectProperty") {
      const propKey = resolveObjectKey(prop.key, prop.computed);
      if (!propKey) {
        ctx.error(`${DEFINE_PROPS}() destructure cannot use computed key.`, prop.key);
      }
      if (prop.value.type === "AssignmentPattern") {
        const { left: left2, right: right2 } = prop.value;
        if (left2.type !== "Identifier") {
          ctx.error(`${DEFINE_PROPS}() destructure does not support nested patterns.`, left2);
        }
        registerBinding(propKey, left2.name, right2);
      } else if (prop.value.type === "Identifier") {
        registerBinding(propKey, prop.value.name);
      } else {
        ctx.error(`${DEFINE_PROPS}() destructure does not support nested patterns.`, prop.value);
      }
    } else {
      ctx.propsDestructureRestId = prop.argument.name;
      ctx.bindingMetadata[ctx.propsDestructureRestId] = "setup-reactive-const";
    }
  }
}
function transformDestructuredProps(ctx, vueImportAliases) {
  if (!ctx.options.propsDestructure && !ctx.options.reactivityTransform) {
    return;
  }
  const rootScope = {};
  const scopeStack = [rootScope];
  let currentScope = rootScope;
  const excludedIds = /* @__PURE__ */ new WeakSet;
  const parentStack = [];
  const propsLocalToPublicMap = /* @__PURE__ */ Object.create(null);
  for (const key in ctx.propsDestructuredBindings) {
    const { local } = ctx.propsDestructuredBindings[key];
    rootScope[local] = true;
    propsLocalToPublicMap[local] = key;
  }
  function pushScope() {
    scopeStack.push(currentScope = Object.create(currentScope));
  }
  function popScope() {
    scopeStack.pop();
    currentScope = scopeStack[scopeStack.length - 1] || null;
  }
  function registerLocalBinding(id3) {
    excludedIds.add(id3);
    if (currentScope) {
      currentScope[id3.name] = false;
    } else {
      ctx.error("registerBinding called without active scope, something is wrong.", id3);
    }
  }
  function walkScope(node2, isRoot2 = false) {
    for (const stmt of node2.body) {
      if (stmt.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt, isRoot2);
      } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
        if (stmt.declare || !stmt.id)
          continue;
        registerLocalBinding(stmt.id);
      } else if ((stmt.type === "ForOfStatement" || stmt.type === "ForInStatement") && stmt.left.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.left);
      } else if (stmt.type === "ExportNamedDeclaration" && stmt.declaration && stmt.declaration.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.declaration, isRoot2);
      } else if (stmt.type === "LabeledStatement" && stmt.body.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.body, isRoot2);
      }
    }
  }
  function walkVariableDeclaration(stmt, isRoot2 = false) {
    if (stmt.declare) {
      return;
    }
    for (const decl of stmt.declarations) {
      const isDefineProps = isRoot2 && decl.init && isCallOf(unwrapTSNode(decl.init), "defineProps");
      for (const id3 of extractIdentifiers(decl.id)) {
        if (isDefineProps) {
          excludedIds.add(id3);
        } else {
          registerLocalBinding(id3);
        }
      }
    }
  }
  function rewriteId(id3, parent, parentStack2) {
    if (parent.type === "AssignmentExpression" && id3 === parent.left || parent.type === "UpdateExpression") {
      ctx.error(`Cannot assign to destructured props as they are readonly.`, id3);
    }
    if (isStaticProperty(parent) && parent.shorthand) {
      if (!parent.inPattern || isInDestructureAssignment(parent, parentStack2)) {
        ctx.s.appendLeft(id3.end + ctx.startOffset, `: ${genPropsAccessExp(propsLocalToPublicMap[id3.name])}`);
      }
    } else {
      ctx.s.overwrite(id3.start + ctx.startOffset, id3.end + ctx.startOffset, genPropsAccessExp(propsLocalToPublicMap[id3.name]));
    }
  }
  function checkUsage(node2, method, alias = method) {
    if (isCallOf(node2, alias)) {
      const arg = unwrapTSNode(node2.arguments[0]);
      if (arg.type === "Identifier" && currentScope[arg.name]) {
        ctx.error(`"${arg.name}" is a destructured prop and should not be passed directly to ${method}(). Pass a getter () => ${arg.name} instead.`, arg);
      }
    }
  }
  const ast = ctx.scriptSetupAst;
  walkScope(ast, true);
  walk$1(ast, {
    enter(node2, parent) {
      parent && parentStack.push(parent);
      if (parent && parent.type.startsWith("TS") && parent.type !== "TSAsExpression" && parent.type !== "TSNonNullExpression" && parent.type !== "TSTypeAssertion") {
        return this.skip();
      }
      checkUsage(node2, "watch", vueImportAliases.watch);
      checkUsage(node2, "toRef", vueImportAliases.toRef);
      if (isFunctionType(node2)) {
        pushScope();
        walkFunctionParams(node2, registerLocalBinding);
        if (node2.body.type === "BlockStatement") {
          walkScope(node2.body);
        }
        return;
      }
      if (node2.type === "CatchClause") {
        pushScope();
        if (node2.param && node2.param.type === "Identifier") {
          registerLocalBinding(node2.param);
        }
        walkScope(node2.body);
        return;
      }
      if (node2.type === "BlockStatement" && !isFunctionType(parent)) {
        pushScope();
        walkScope(node2);
        return;
      }
      if (node2.type === "Identifier") {
        if (isReferencedIdentifier(node2, parent, parentStack) && !excludedIds.has(node2)) {
          if (currentScope[node2.name]) {
            rewriteId(node2, parent, parentStack);
          }
        }
      }
    },
    leave(node2, parent) {
      parent && parentStack.pop();
      if (node2.type === "BlockStatement" && !isFunctionType(parent) || isFunctionType(node2)) {
        popScope();
      }
    }
  });
}
var DEFINE_EMITS = "defineEmits";
function processDefineEmits(ctx, node2, declId) {
  if (!isCallOf(node2, DEFINE_EMITS)) {
    return false;
  }
  if (ctx.hasDefineEmitCall) {
    ctx.error(`duplicate ${DEFINE_EMITS}() call`, node2);
  }
  ctx.hasDefineEmitCall = true;
  ctx.emitsRuntimeDecl = node2.arguments[0];
  if (node2.typeParameters) {
    if (ctx.emitsRuntimeDecl) {
      ctx.error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node2);
    }
    ctx.emitsTypeDecl = node2.typeParameters.params[0];
  }
  ctx.emitDecl = declId;
  return true;
}
function genRuntimeEmits(ctx) {
  let emitsDecl = "";
  if (ctx.emitsRuntimeDecl) {
    emitsDecl = ctx.getString(ctx.emitsRuntimeDecl).trim();
  } else if (ctx.emitsTypeDecl) {
    const typeDeclaredEmits = extractRuntimeEmits(ctx);
    emitsDecl = typeDeclaredEmits.size ? `[${Array.from(typeDeclaredEmits).map((k2) => JSON.stringify(k2)).join(", ")}]` : ``;
  }
  if (ctx.hasDefineModelCall) {
    let modelEmitsDecl = `[${Object.keys(ctx.modelDecls).map((n3) => JSON.stringify(`update:${n3}`)).join(", ")}]`;
    emitsDecl = emitsDecl ? `${ctx.helper("mergeModels")}(${emitsDecl}, ${modelEmitsDecl})` : modelEmitsDecl;
  }
  return emitsDecl;
}
function extractRuntimeEmits(ctx) {
  const emits = /* @__PURE__ */ new Set;
  const node2 = ctx.emitsTypeDecl;
  if (node2.type === "TSFunctionType") {
    extractEventNames(ctx, node2.parameters[0], emits);
    return emits;
  }
  const { props, calls } = resolveTypeElements(ctx, node2);
  let hasProperty = false;
  for (const key in props) {
    emits.add(key);
    hasProperty = true;
  }
  if (calls) {
    if (hasProperty) {
      ctx.error(`defineEmits() type cannot mixed call signature and property syntax.`, node2);
    }
    for (const call of calls) {
      extractEventNames(ctx, call.parameters[0], emits);
    }
  }
  return emits;
}
function extractEventNames(ctx, eventName, emits) {
  if (eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
    const types5 = resolveUnionType(ctx, eventName.typeAnnotation.typeAnnotation);
    for (const type of types5) {
      if (type.type === "TSLiteralType") {
        if (type.literal.type !== "UnaryExpression" && type.literal.type !== "TemplateLiteral") {
          emits.add(String(type.literal.value));
        }
      }
    }
  }
}
var DEFINE_EXPOSE = "defineExpose";
function processDefineExpose(ctx, node2) {
  if (isCallOf(node2, DEFINE_EXPOSE)) {
    if (ctx.hasDefineExposeCall) {
      ctx.error(`duplicate ${DEFINE_EXPOSE}() call`, node2);
    }
    ctx.hasDefineExposeCall = true;
    return true;
  }
  return false;
}
var DEFINE_SLOTS = "defineSlots";
function processDefineSlots(ctx, node2, declId) {
  if (!isCallOf(node2, DEFINE_SLOTS)) {
    return false;
  }
  if (ctx.hasDefineSlotsCall) {
    ctx.error(`duplicate ${DEFINE_SLOTS}() call`, node2);
  }
  ctx.hasDefineSlotsCall = true;
  if (node2.arguments.length > 0) {
    ctx.error(`${DEFINE_SLOTS}() cannot accept arguments`, node2);
  }
  if (declId) {
    ctx.s.overwrite(ctx.startOffset + node2.start, ctx.startOffset + node2.end, `${ctx.helper("useSlots")}()`);
  }
  return true;
}
var DEFINE_OPTIONS = "defineOptions";
function processDefineOptions(ctx, node2) {
  if (!isCallOf(node2, DEFINE_OPTIONS)) {
    return false;
  }
  if (ctx.hasDefineOptionsCall) {
    ctx.error(`duplicate ${DEFINE_OPTIONS}() call`, node2);
  }
  if (node2.typeParameters) {
    ctx.error(`${DEFINE_OPTIONS}() cannot accept type arguments`, node2);
  }
  if (!node2.arguments[0])
    return true;
  ctx.hasDefineOptionsCall = true;
  ctx.optionsRuntimeDecl = unwrapTSNode(node2.arguments[0]);
  let propsOption = undefined;
  let emitsOption = undefined;
  let exposeOption = undefined;
  let slotsOption = undefined;
  if (ctx.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const prop of ctx.optionsRuntimeDecl.properties) {
      if ((prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier") {
        if (prop.key.name === "props")
          propsOption = prop;
        if (prop.key.name === "emits")
          emitsOption = prop;
        if (prop.key.name === "expose")
          exposeOption = prop;
        if (prop.key.name === "slots")
          slotsOption = prop;
      }
    }
  }
  if (propsOption) {
    ctx.error(`${DEFINE_OPTIONS}() cannot be used to declare props. Use ${DEFINE_PROPS}() instead.`, propsOption);
  }
  if (emitsOption) {
    ctx.error(`${DEFINE_OPTIONS}() cannot be used to declare emits. Use ${DEFINE_EMITS}() instead.`, emitsOption);
  }
  if (exposeOption) {
    ctx.error(`${DEFINE_OPTIONS}() cannot be used to declare expose. Use ${DEFINE_EXPOSE}() instead.`, exposeOption);
  }
  if (slotsOption) {
    ctx.error(`${DEFINE_OPTIONS}() cannot be used to declare slots. Use ${DEFINE_SLOTS}() instead.`, slotsOption);
  }
  return true;
}
function processAwait(ctx, node2, needSemi, isStatement) {
  const argumentStart = node2.argument.extra && node2.argument.extra.parenthesized ? node2.argument.extra.parenStart : node2.argument.start;
  const startOffset = ctx.startOffset;
  const argumentStr = ctx.descriptor.source.slice(argumentStart + startOffset, node2.argument.end + startOffset);
  const containsNestedAwait = /\bawait\b/.test(argumentStr);
  ctx.s.overwrite(node2.start + startOffset, argumentStart + startOffset, `${needSemi ? `;` : ``}(
  ([__temp,__restore] = ${ctx.helper(`withAsyncContext`)}(${containsNestedAwait ? `async ` : ``}() => `);
  ctx.s.appendLeft(node2.end + startOffset, `)),
  ${isStatement ? `` : `__temp = `}await __temp,
  __restore()${isStatement ? `` : `,
  __temp`}
)`);
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function compileScript(sfc, options3) {
  var _a4;
  if (!options3.id) {
    warnOnce$4(`compileScript now requires passing the \`id\` option.
Upgrade your vite or vue-loader version for compatibility with the latest experimental proposals.`);
  }
  const ctx = new ScriptCompileContext(sfc, options3);
  const { script, scriptSetup, source, filename } = sfc;
  const hoistStatic2 = options3.hoistStatic !== false && !script;
  const scopeId = options3.id ? options3.id.replace(/^data-v-/, "") : "";
  const scriptLang = script && script.lang;
  const scriptSetupLang = scriptSetup && scriptSetup.lang;
  const enableReactivityTransform = !!options3.reactivityTransform;
  let refBindings;
  if (!scriptSetup) {
    if (!script) {
      throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);
    }
    return processNormalScript(ctx, scopeId);
  }
  if (script && scriptLang !== scriptSetupLang) {
    throw new Error(`[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`);
  }
  if (scriptSetupLang && !ctx.isJS && !ctx.isTS) {
    return scriptSetup;
  }
  const scriptBindings = /* @__PURE__ */ Object.create(null);
  const setupBindings = /* @__PURE__ */ Object.create(null);
  let defaultExport;
  let hasAwait = false;
  let hasInlinedSsrRenderFn = false;
  const startOffset = ctx.startOffset;
  const endOffset = ctx.endOffset;
  const scriptStartOffset = script && script.loc.start.offset;
  const scriptEndOffset = script && script.loc.end.offset;
  function hoistNode(node2) {
    const start = node2.start + startOffset;
    let end = node2.end + startOffset;
    if (node2.trailingComments && node2.trailingComments.length > 0) {
      const lastCommentNode = node2.trailingComments[node2.trailingComments.length - 1];
      end = lastCommentNode.end + startOffset;
    }
    while (end <= source.length) {
      if (!/\s/.test(source.charAt(end))) {
        break;
      }
      end++;
    }
    ctx.s.move(start, end, 0);
  }
  function registerUserImport(source2, local, imported, isType, isFromSetup, needTemplateUsageCheck) {
    let isUsedInTemplate = needTemplateUsageCheck;
    if (needTemplateUsageCheck && ctx.isTS && sfc.template && !sfc.template.src && !sfc.template.lang) {
      isUsedInTemplate = isImportUsed(local, sfc);
    }
    ctx.userImports[local] = {
      isType,
      imported,
      local,
      source: source2,
      isFromSetup,
      isUsedInTemplate
    };
  }
  function checkInvalidScopeReference(node2, method) {
    if (!node2)
      return;
    walkIdentifiers(node2, (id3) => {
      const binding2 = setupBindings[id3.name];
      if (binding2 && binding2 !== "literal-const") {
        ctx.error(`\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`, id3);
      }
    });
  }
  const scriptAst = ctx.scriptAst;
  const scriptSetupAst = ctx.scriptSetupAst;
  if (scriptAst) {
    for (const node2 of scriptAst.body) {
      if (node2.type === "ImportDeclaration") {
        for (const specifier of node2.specifiers) {
          const imported = getImportedName(specifier);
          registerUserImport(node2.source.value, specifier.local.name, imported, node2.importKind === "type" || specifier.type === "ImportSpecifier" && specifier.importKind === "type", false, !options3.inlineTemplate);
        }
      }
    }
  }
  for (const node2 of scriptSetupAst.body) {
    if (node2.type === "ImportDeclaration") {
      hoistNode(node2);
      let removed = 0;
      const removeSpecifier = (i) => {
        const removeLeft = i > removed;
        removed++;
        const current = node2.specifiers[i];
        const next = node2.specifiers[i + 1];
        ctx.s.remove(removeLeft ? node2.specifiers[i - 1].end + startOffset : current.start + startOffset, next && !removeLeft ? next.start + startOffset : current.end + startOffset);
      };
      for (let i = 0;i < node2.specifiers.length; i++) {
        const specifier = node2.specifiers[i];
        const local = specifier.local.name;
        const imported = getImportedName(specifier);
        const source2 = node2.source.value;
        const existing = ctx.userImports[local];
        if (source2 === "vue" && (imported === DEFINE_PROPS || imported === DEFINE_EMITS || imported === DEFINE_EXPOSE)) {
          warnOnce$4(`\`${imported}\` is a compiler macro and no longer needs to be imported.`);
          removeSpecifier(i);
        } else if (existing) {
          if (existing.source === source2 && existing.imported === imported) {
            removeSpecifier(i);
          } else {
            ctx.error(`different imports aliased to same local name.`, specifier);
          }
        } else {
          registerUserImport(source2, local, imported, node2.importKind === "type" || specifier.type === "ImportSpecifier" && specifier.importKind === "type", true, !options3.inlineTemplate);
        }
      }
      if (node2.specifiers.length && removed === node2.specifiers.length) {
        ctx.s.remove(node2.start + startOffset, node2.end + startOffset);
      }
    }
  }
  const vueImportAliases = {};
  for (const key in ctx.userImports) {
    const { source: source2, imported, local } = ctx.userImports[key];
    if (source2 === "vue")
      vueImportAliases[imported] = local;
  }
  if (script && scriptAst) {
    for (const node2 of scriptAst.body) {
      if (node2.type === "ExportDefaultDeclaration") {
        defaultExport = node2;
        let optionProperties;
        if (defaultExport.declaration.type === "ObjectExpression") {
          optionProperties = defaultExport.declaration.properties;
        } else if (defaultExport.declaration.type === "CallExpression" && defaultExport.declaration.arguments[0] && defaultExport.declaration.arguments[0].type === "ObjectExpression") {
          optionProperties = defaultExport.declaration.arguments[0].properties;
        }
        if (optionProperties) {
          for (const p2 of optionProperties) {
            if (p2.type === "ObjectProperty" && p2.key.type === "Identifier" && p2.key.name === "name") {
              ctx.hasDefaultExportName = true;
            }
            if ((p2.type === "ObjectMethod" || p2.type === "ObjectProperty") && p2.key.type === "Identifier" && p2.key.name === "render") {
              ctx.hasDefaultExportRender = true;
            }
          }
        }
        const start = node2.start + scriptStartOffset;
        const end = node2.declaration.start + scriptStartOffset;
        ctx.s.overwrite(start, end, `const ${normalScriptDefaultVar} = `);
      } else if (node2.type === "ExportNamedDeclaration") {
        const defaultSpecifier = node2.specifiers.find((s2) => s2.exported.type === "Identifier" && s2.exported.name === "default");
        if (defaultSpecifier) {
          defaultExport = node2;
          if (node2.specifiers.length > 1) {
            ctx.s.remove(defaultSpecifier.start + scriptStartOffset, defaultSpecifier.end + scriptStartOffset);
          } else {
            ctx.s.remove(node2.start + scriptStartOffset, node2.end + scriptStartOffset);
          }
          if (node2.source) {
            ctx.s.prepend(`import { ${defaultSpecifier.local.name} as ${normalScriptDefaultVar} } from '${node2.source.value}'
`);
          } else {
            ctx.s.appendLeft(scriptEndOffset, `
const ${normalScriptDefaultVar} = ${defaultSpecifier.local.name}
`);
          }
        }
        if (node2.declaration) {
          walkDeclaration("script", node2.declaration, scriptBindings, vueImportAliases, hoistStatic2);
        }
      } else if ((node2.type === "VariableDeclaration" || node2.type === "FunctionDeclaration" || node2.type === "ClassDeclaration" || node2.type === "TSEnumDeclaration") && !node2.declare) {
        walkDeclaration("script", node2, scriptBindings, vueImportAliases, hoistStatic2);
      }
    }
    if (enableReactivityTransform && shouldTransform(script.content)) {
      const { rootRefs, importedHelpers } = transformAST(scriptAst, ctx.s, scriptStartOffset);
      refBindings = rootRefs;
      for (const h8 of importedHelpers) {
        ctx.helperImports.add(h8);
      }
    }
    if (scriptStartOffset > startOffset) {
      if (!/\n$/.test(script.content.trim())) {
        ctx.s.appendLeft(scriptEndOffset, `
`);
      }
      ctx.s.move(scriptStartOffset, scriptEndOffset, 0);
    }
  }
  for (const node2 of scriptSetupAst.body) {
    if (node2.type === "ExpressionStatement") {
      const expr = unwrapTSNode(node2.expression);
      if (processDefineProps(ctx, expr) || processDefineEmits(ctx, expr) || processDefineOptions(ctx, expr) || processDefineSlots(ctx, expr)) {
        ctx.s.remove(node2.start + startOffset, node2.end + startOffset);
      } else if (processDefineExpose(ctx, expr)) {
        const callee = expr.callee;
        ctx.s.overwrite(callee.start + startOffset, callee.end + startOffset, "__expose");
      } else {
        processDefineModel(ctx, expr);
      }
    }
    if (node2.type === "VariableDeclaration" && !node2.declare) {
      const total = node2.declarations.length;
      let left2 = total;
      let lastNonRemoved;
      for (let i = 0;i < total; i++) {
        const decl = node2.declarations[i];
        const init2 = decl.init && unwrapTSNode(decl.init);
        if (init2) {
          if (processDefineOptions(ctx, init2)) {
            ctx.error(`${DEFINE_OPTIONS}() has no returning value, it cannot be assigned.`, node2);
          }
          const isDefineProps = processDefineProps(ctx, init2, decl.id);
          const isDefineEmits = !isDefineProps && processDefineEmits(ctx, init2, decl.id);
          !isDefineEmits && (processDefineSlots(ctx, init2, decl.id) || processDefineModel(ctx, init2, decl.id));
          if (isDefineProps && !ctx.propsDestructureRestId && ctx.propsDestructureDecl) {
            if (left2 === 1) {
              ctx.s.remove(node2.start + startOffset, node2.end + startOffset);
            } else {
              let start = decl.start + startOffset;
              let end = decl.end + startOffset;
              if (i === total - 1) {
                start = node2.declarations[lastNonRemoved].end + startOffset;
              } else {
                end = node2.declarations[i + 1].start + startOffset;
              }
              ctx.s.remove(start, end);
              left2--;
            }
          } else if (isDefineEmits) {
            ctx.s.overwrite(startOffset + init2.start, startOffset + init2.end, "__emit");
          } else {
            lastNonRemoved = i;
          }
        }
      }
    }
    let isAllLiteral = false;
    if ((node2.type === "VariableDeclaration" || node2.type === "FunctionDeclaration" || node2.type === "ClassDeclaration" || node2.type === "TSEnumDeclaration") && !node2.declare) {
      isAllLiteral = walkDeclaration("scriptSetup", node2, setupBindings, vueImportAliases, hoistStatic2);
    }
    if (hoistStatic2 && isAllLiteral) {
      hoistNode(node2);
    }
    if (node2.type === "VariableDeclaration" && !node2.declare || node2.type.endsWith("Statement")) {
      const scope = [scriptSetupAst.body];
      walk$1(node2, {
        enter(child, parent) {
          if (isFunctionType(child)) {
            this.skip();
          }
          if (child.type === "BlockStatement") {
            scope.push(child.body);
          }
          if (child.type === "AwaitExpression") {
            hasAwait = true;
            const currentScope = scope[scope.length - 1];
            const needsSemi = currentScope.some((n3, i) => {
              return (scope.length === 1 || i > 0) && n3.type === "ExpressionStatement" && n3.start === child.start;
            });
            processAwait(ctx, child, needsSemi, parent.type === "ExpressionStatement");
          }
        },
        exit(node22) {
          if (node22.type === "BlockStatement")
            scope.pop();
        }
      });
    }
    if (node2.type === "ExportNamedDeclaration" && node2.exportKind !== "type" || node2.type === "ExportAllDeclaration" || node2.type === "ExportDefaultDeclaration") {
      ctx.error(`<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`, node2);
    }
    if (ctx.isTS) {
      if (node2.type.startsWith("TS") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "VariableDeclaration" && node2.declare) {
        if (node2.type !== "TSEnumDeclaration") {
          hoistNode(node2);
        }
      }
    }
  }
  if (ctx.propsDestructureDecl) {
    transformDestructuredProps(ctx, vueImportAliases);
  }
  if (enableReactivityTransform && (refBindings || shouldTransform(scriptSetup.content))) {
    const { rootRefs, importedHelpers } = transformAST(scriptSetupAst, ctx.s, startOffset, refBindings);
    refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs;
    for (const h8 of importedHelpers) {
      ctx.helperImports.add(h8);
    }
  }
  checkInvalidScopeReference(ctx.propsRuntimeDecl, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.propsRuntimeDefaults, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.propsDestructureDecl, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.emitsRuntimeDecl, DEFINE_EMITS);
  checkInvalidScopeReference(ctx.optionsRuntimeDecl, DEFINE_OPTIONS);
  if (script) {
    if (startOffset < scriptStartOffset) {
      ctx.s.remove(0, startOffset);
      ctx.s.remove(endOffset, scriptStartOffset);
      ctx.s.remove(scriptEndOffset, source.length);
    } else {
      ctx.s.remove(0, scriptStartOffset);
      ctx.s.remove(scriptEndOffset, startOffset);
      ctx.s.remove(endOffset, source.length);
    }
  } else {
    ctx.s.remove(0, startOffset);
    ctx.s.remove(endOffset, source.length);
  }
  if (scriptAst) {
    Object.assign(ctx.bindingMetadata, analyzeScriptBindings(scriptAst.body));
  }
  for (const [key, { isType, imported, source: source2 }] of Object.entries(ctx.userImports)) {
    if (isType)
      continue;
    ctx.bindingMetadata[key] = imported === "*" || imported === "default" && source2.endsWith(".vue") || source2 === "vue" ? "setup-const" : "setup-maybe-ref";
  }
  for (const key in scriptBindings) {
    ctx.bindingMetadata[key] = scriptBindings[key];
  }
  for (const key in setupBindings) {
    ctx.bindingMetadata[key] = setupBindings[key];
  }
  if (refBindings) {
    for (const key of refBindings) {
      ctx.bindingMetadata[key] = "setup-ref";
    }
  }
  if (sfc.cssVars.length && !((_a4 = options3.templateOptions) == null ? undefined : _a4.ssr)) {
    ctx.helperImports.add(CSS_VARS_HELPER);
    ctx.helperImports.add("unref");
    ctx.s.prependLeft(startOffset, `
${genCssVarsCode(sfc.cssVars, ctx.bindingMetadata, scopeId, !!options3.isProd)}
`);
  }
  let args = `__props`;
  if (ctx.propsTypeDecl) {
    args += `: any`;
  }
  if (ctx.propsDecl) {
    if (ctx.propsDestructureRestId) {
      ctx.s.overwrite(startOffset + ctx.propsCall.start, startOffset + ctx.propsCall.end, `${ctx.helper(`createPropsRestProxy`)}(__props, ${JSON.stringify(Object.keys(ctx.propsDestructuredBindings))})`);
      ctx.s.overwrite(startOffset + ctx.propsDestructureDecl.start, startOffset + ctx.propsDestructureDecl.end, ctx.propsDestructureRestId);
    } else if (!ctx.propsDestructureDecl) {
      ctx.s.overwrite(startOffset + ctx.propsCall.start, startOffset + ctx.propsCall.end, "__props");
    }
  }
  if (hasAwait) {
    const any = ctx.isTS ? `: any` : ``;
    ctx.s.prependLeft(startOffset, `
let __temp${any}, __restore${any}
`);
  }
  const destructureElements = ctx.hasDefineExposeCall || !options3.inlineTemplate ? [`expose: __expose`] : [];
  if (ctx.emitDecl) {
    destructureElements.push(`emit: __emit`);
  }
  if (destructureElements.length) {
    args += `, { ${destructureElements.join(", ")} }`;
  }
  let returned;
  if (!options3.inlineTemplate || !sfc.template && ctx.hasDefaultExportRender) {
    const allBindings = __spreadValues(__spreadValues({}, scriptBindings), setupBindings);
    for (const key in ctx.userImports) {
      if (!ctx.userImports[key].isType && ctx.userImports[key].isUsedInTemplate) {
        allBindings[key] = true;
      }
    }
    returned = `{ `;
    for (const key in allBindings) {
      if (allBindings[key] === true && ctx.userImports[key].source !== "vue" && !ctx.userImports[key].source.endsWith(".vue")) {
        returned += `get ${key}() { return ${key} }, `;
      } else if (ctx.bindingMetadata[key] === "setup-let") {
        const setArg = key === "v" ? `_v` : `v`;
        returned += `get ${key}() { return ${key} }, set ${key}(${setArg}) { ${key} = ${setArg} }, `;
      } else {
        returned += `${key}, `;
      }
    }
    returned = returned.replace(/, $/, "") + ` }`;
  } else {
    if (sfc.template && !sfc.template.src) {
      if (options3.templateOptions && options3.templateOptions.ssr) {
        hasInlinedSsrRenderFn = true;
      }
      const { code, ast, preamble, tips, errors: errors3 } = compileTemplate(__spreadProps(__spreadValues({
        filename,
        source: sfc.template.content,
        inMap: sfc.template.map
      }, options3.templateOptions), {
        id: scopeId,
        scoped: sfc.styles.some((s2) => s2.scoped),
        isProd: options3.isProd,
        ssrCssVars: sfc.cssVars,
        compilerOptions: __spreadProps(__spreadValues({}, options3.templateOptions && options3.templateOptions.compilerOptions), {
          inline: true,
          isTS: ctx.isTS,
          bindingMetadata: ctx.bindingMetadata
        })
      }));
      if (tips.length) {
        tips.forEach(warnOnce$4);
      }
      const err = errors3[0];
      if (typeof err === "string") {
        throw new Error(err);
      } else if (err) {
        if (err.loc) {
          err.message += `

` + sfc.filename + `
` + generateCodeFrame$1(source, err.loc.start.offset, err.loc.end.offset) + `
`;
        }
        throw err;
      }
      if (preamble) {
        ctx.s.prepend(preamble);
      }
      if (ast && ast.helpers.has(UNREF)) {
        ctx.helperImports.delete("unref");
      }
      returned = code;
    } else {
      returned = `() => {}`;
    }
  }
  if (!options3.inlineTemplate && true) {
    ctx.s.appendRight(endOffset, `
const __returned__ = ${returned}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
  } else {
    ctx.s.appendRight(endOffset, `
return ${returned}
}

`);
  }
  const genDefaultAs = options3.genDefaultAs ? `const ${options3.genDefaultAs} =` : `export default`;
  let runtimeOptions = ``;
  if (!ctx.hasDefaultExportName && filename && filename !== DEFAULT_FILENAME) {
    const match = filename.match(/([^/\\]+)\.\w+$/);
    if (match) {
      runtimeOptions += `
  __name: '${match[1]}',`;
    }
  }
  if (hasInlinedSsrRenderFn) {
    runtimeOptions += `
  __ssrInlineRender: true,`;
  }
  const propsDecl = genRuntimeProps(ctx);
  if (propsDecl)
    runtimeOptions += `
  props: ${propsDecl},`;
  const emitsDecl = genRuntimeEmits(ctx);
  if (emitsDecl)
    runtimeOptions += `
  emits: ${emitsDecl},`;
  let definedOptions = "";
  if (ctx.optionsRuntimeDecl) {
    definedOptions = scriptSetup.content.slice(ctx.optionsRuntimeDecl.start, ctx.optionsRuntimeDecl.end).trim();
  }
  const exposeCall = ctx.hasDefineExposeCall || options3.inlineTemplate ? `` : `  __expose();
`;
  if (ctx.isTS) {
    const def = (defaultExport ? `
  ...${normalScriptDefaultVar},` : ``) + (definedOptions ? `
  ...${definedOptions},` : "");
    ctx.s.prependLeft(startOffset, `
${genDefaultAs} /*#__PURE__*/${ctx.helper(`defineComponent`)}({${def}${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
    ctx.s.appendRight(endOffset, `})`);
  } else {
    if (defaultExport || definedOptions) {
      ctx.s.prependLeft(startOffset, `
${genDefaultAs} /*#__PURE__*/Object.assign(${defaultExport ? `${normalScriptDefaultVar}, ` : ""}${definedOptions ? `${definedOptions}, ` : ""}{${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
      ctx.s.appendRight(endOffset, `})`);
    } else {
      ctx.s.prependLeft(startOffset, `
${genDefaultAs} {${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
      ctx.s.appendRight(endOffset, `}`);
    }
  }
  if (ctx.helperImports.size > 0) {
    ctx.s.prepend(`import { ${[...ctx.helperImports].map((h8) => `${h8} as _${h8}`).join(", ")} } from 'vue'
`);
  }
  ctx.s.trim();
  return __spreadProps(__spreadValues({}, scriptSetup), {
    bindings: ctx.bindingMetadata,
    imports: ctx.userImports,
    content: ctx.s.toString(),
    map: options3.sourceMap !== false ? ctx.s.generateMap({
      source: filename,
      hires: true,
      includeContent: true
    }) : undefined,
    scriptAst: scriptAst == null ? undefined : scriptAst.body,
    scriptSetupAst: scriptSetupAst == null ? undefined : scriptSetupAst.body,
    deps: ctx.deps ? [...ctx.deps] : undefined
  });
}
function registerBinding(bindings, node2, type) {
  bindings[node2.name] = type;
}
function walkDeclaration(from2, node2, bindings, userImportAliases, hoistStatic2) {
  let isAllLiteral = false;
  if (node2.type === "VariableDeclaration") {
    const isConst2 = node2.kind === "const";
    isAllLiteral = isConst2 && node2.declarations.every((decl) => decl.id.type === "Identifier" && isStaticNode(decl.init));
    for (const { id: id3, init: _init } of node2.declarations) {
      const init2 = _init && unwrapTSNode(_init);
      const isDefineCall = !!(isConst2 && isCallOf(init2, (c3) => c3 === DEFINE_PROPS || c3 === DEFINE_EMITS || c3 === WITH_DEFAULTS));
      if (id3.type === "Identifier") {
        let bindingType;
        const userReactiveBinding = userImportAliases["reactive"];
        if ((hoistStatic2 || from2 === "script") && (isAllLiteral || isConst2 && isStaticNode(init2))) {
          bindingType = "literal-const";
        } else if (isCallOf(init2, userReactiveBinding)) {
          bindingType = isConst2 ? "setup-reactive-const" : "setup-let";
        } else if (isDefineCall || isConst2 && canNeverBeRef(init2, userReactiveBinding)) {
          bindingType = isCallOf(init2, DEFINE_PROPS) ? "setup-reactive-const" : "setup-const";
        } else if (isConst2) {
          if (isCallOf(init2, (m2) => m2 === userImportAliases["ref"] || m2 === userImportAliases["computed"] || m2 === userImportAliases["shallowRef"] || m2 === userImportAliases["customRef"] || m2 === userImportAliases["toRef"] || m2 === DEFINE_MODEL)) {
            bindingType = "setup-ref";
          } else {
            bindingType = "setup-maybe-ref";
          }
        } else {
          bindingType = "setup-let";
        }
        registerBinding(bindings, id3, bindingType);
      } else {
        if (isCallOf(init2, DEFINE_PROPS)) {
          continue;
        }
        if (id3.type === "ObjectPattern") {
          walkObjectPattern(id3, bindings, isConst2, isDefineCall);
        } else if (id3.type === "ArrayPattern") {
          walkArrayPattern(id3, bindings, isConst2, isDefineCall);
        }
      }
    }
  } else if (node2.type === "TSEnumDeclaration") {
    isAllLiteral = node2.members.every((member) => !member.initializer || isStaticNode(member.initializer));
    bindings[node2.id.name] = isAllLiteral ? "literal-const" : "setup-const";
  } else if (node2.type === "FunctionDeclaration" || node2.type === "ClassDeclaration") {
    bindings[node2.id.name] = "setup-const";
  }
  return isAllLiteral;
}
function walkObjectPattern(node2, bindings, isConst2, isDefineCall = false) {
  for (const p2 of node2.properties) {
    if (p2.type === "ObjectProperty") {
      if (p2.key.type === "Identifier" && p2.key === p2.value) {
        const type = isDefineCall ? "setup-const" : isConst2 ? "setup-maybe-ref" : "setup-let";
        registerBinding(bindings, p2.key, type);
      } else {
        walkPattern(p2.value, bindings, isConst2, isDefineCall);
      }
    } else {
      const type = isConst2 ? "setup-const" : "setup-let";
      registerBinding(bindings, p2.argument, type);
    }
  }
}
function walkArrayPattern(node2, bindings, isConst2, isDefineCall = false) {
  for (const e2 of node2.elements) {
    e2 && walkPattern(e2, bindings, isConst2, isDefineCall);
  }
}
function walkPattern(node2, bindings, isConst2, isDefineCall = false) {
  if (node2.type === "Identifier") {
    const type = isDefineCall ? "setup-const" : isConst2 ? "setup-maybe-ref" : "setup-let";
    registerBinding(bindings, node2, type);
  } else if (node2.type === "RestElement") {
    const type = isConst2 ? "setup-const" : "setup-let";
    registerBinding(bindings, node2.argument, type);
  } else if (node2.type === "ObjectPattern") {
    walkObjectPattern(node2, bindings, isConst2);
  } else if (node2.type === "ArrayPattern") {
    walkArrayPattern(node2, bindings, isConst2);
  } else if (node2.type === "AssignmentPattern") {
    if (node2.left.type === "Identifier") {
      const type = isDefineCall ? "setup-const" : isConst2 ? "setup-maybe-ref" : "setup-let";
      registerBinding(bindings, node2.left, type);
    } else {
      walkPattern(node2.left, bindings, isConst2);
    }
  }
}
function canNeverBeRef(node2, userReactiveImport) {
  if (isCallOf(node2, userReactiveImport)) {
    return true;
  }
  switch (node2.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return true;
    case "SequenceExpression":
      return canNeverBeRef(node2.expressions[node2.expressions.length - 1], userReactiveImport);
    default:
      if (isLiteralNode(node2)) {
        return true;
      }
      return false;
  }
}
function isStaticNode(node2) {
  node2 = unwrapTSNode(node2);
  switch (node2.type) {
    case "UnaryExpression":
      return isStaticNode(node2.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticNode(node2.left) && isStaticNode(node2.right);
    case "ConditionalExpression": {
      return isStaticNode(node2.test) && isStaticNode(node2.consequent) && isStaticNode(node2.alternate);
    }
    case "SequenceExpression":
    case "TemplateLiteral":
      return node2.expressions.every((expr) => isStaticNode(expr));
    case "ParenthesizedExpression":
      return isStaticNode(node2.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return true;
  }
  return false;
}
function makeMap(str2, expectsLowerCase) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const list2 = str2.split(",");
  for (let i = 0;i < list2.length; i++) {
    map3[list2[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map3[val.toLowerCase()] : (val) => !!map3[val];
}
Object.freeze({});
Object.freeze([]);
var NOOP = () => {};
var onRE = /^on[^a-z]/;
var isOn = (key) => onRE.test(key);
var isArray$1 = Array.isArray;
var isFunction$1 = (val) => typeof val === "function";
var isString$1 = (val) => typeof val === "string";
var isObject$12 = (val) => val !== null && typeof val === "object";
var isPromise$1 = (val) => {
  return (isObject$12(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
var cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str2) => {
    const hit = cache[str2];
    return hit || (cache[str2] = fn2(str2));
  };
};
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str2) => str2.replace(hyphenateRE, "-$1").toLowerCase());
var _globalThis$1;
var getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0;i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$12(value)) {
    return value;
  }
}
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:([^]+)/;
var styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles2) {
  let ret = "";
  if (!styles2 || isString$1(styles2)) {
    return ret;
  }
  for (const key in styles2) {
    const value = styles2[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString$1(value) || typeof value === "number") {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0;i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$12(value)) {
    for (const name3 in value) {
      if (value[name3]) {
        res += name3 + " ";
      }
    }
  }
  return res.trim();
}
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache = {};
function isSSRSafeAttrName(name3) {
  if (attrValidationCache.hasOwnProperty(name3)) {
    return attrValidationCache[name3];
  }
  const isUnsafe = unsafeAttrCharRE.test(name3);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name3}`);
  }
  return attrValidationCache[name3] = !isUnsafe;
}
var propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
var escapeRE = /["'&<>]/;
function escapeHtml$1(string4) {
  const str2 = "" + string4;
  const match = escapeRE.exec(str2);
  if (!match) {
    return str2;
  }
  let html2 = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index;index < str2.length; index++) {
    switch (str2.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html2 += str2.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html2 += escaped;
  }
  return lastIndex !== index ? html2 + str2.slice(lastIndex, index) : html2;
}
var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src2) {
  return src2.replace(commentStripRE, "");
}
var shouldIgnoreProp = makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);
function ssrRenderAttrs(props, tag3) {
  let ret = "";
  for (const key in props) {
    if (shouldIgnoreProp(key) || isOn(key) || tag3 === "textarea" && key === "value") {
      continue;
    }
    const value = props[key];
    if (key === "class") {
      ret += ` class="${ssrRenderClass(value)}"`;
    } else if (key === "style") {
      ret += ` style="${ssrRenderStyle(value)}"`;
    } else {
      ret += ssrRenderDynamicAttr(key, value, tag3);
    }
  }
  return ret;
}
function ssrRenderDynamicAttr(key, value, tag3) {
  if (!isRenderableValue(value)) {
    return ``;
  }
  const attrKey = tag3 && (tag3.indexOf("-") > 0 || isSVGTag(tag3)) ? key : propsToAttrMap[key] || key.toLowerCase();
  if (isBooleanAttr(attrKey)) {
    return includeBooleanAttr(value) ? ` ${attrKey}` : ``;
  } else if (isSSRSafeAttrName(attrKey)) {
    return value === "" ? ` ${attrKey}` : ` ${attrKey}="${escapeHtml$1(value)}"`;
  } else {
    console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);
    return ``;
  }
}
function isRenderableValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}
function ssrRenderClass(raw) {
  return escapeHtml$1(normalizeClass(raw));
}
function ssrRenderStyle(raw) {
  if (!raw) {
    return "";
  }
  if (isString$1(raw)) {
    return escapeHtml$1(raw);
  }
  const styles2 = normalizeStyle(raw);
  return escapeHtml$1(stringifyStyle(styles2));
}
function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
  parentPush("<!--teleport start-->");
  const context = parentComponent.appContext.provides[exports_vue.ssrContextKey];
  const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
  const bufferIndex = targetBuffer.length;
  let teleportContent;
  if (disabled) {
    contentRenderFn(parentPush);
    teleportContent = `<!--teleport anchor-->`;
  } else {
    const { getBuffer, push } = createBuffer();
    contentRenderFn(push);
    push(`<!--teleport anchor-->`);
    teleportContent = getBuffer();
  }
  targetBuffer.splice(bufferIndex, 0, teleportContent);
  parentPush("<!--teleport end-->");
}
Symbol("iterate");
Symbol("Map key iterate");
var globalCurrentInstanceSetters;
var settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis$1()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis$1()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => i);
}
function ssrCompile(template, instance) {
  {
    throw new Error(`On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.`);
  }
}
var {
  createComponentInstance,
  setCurrentRenderingInstance,
  setupComponent,
  renderComponentRoot,
  normalizeVNode
} = exports_vue.ssrUtils;
function createBuffer() {
  let appendable = false;
  const buffer = [];
  return {
    getBuffer() {
      return buffer;
    },
    push(item) {
      const isStringItem = isString$1(item);
      if (appendable && isStringItem) {
        buffer[buffer.length - 1] += item;
      } else {
        buffer.push(item);
      }
      appendable = isStringItem;
      if (isPromise$1(item) || isArray$1(item) && item.hasAsync) {
        buffer.hasAsync = true;
      }
    }
  };
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
  const instance = createComponentInstance(vnode, parentComponent, null);
  const res = setupComponent(instance, true);
  const hasAsyncSetup = isPromise$1(res);
  const prefetches = instance.sp;
  if (hasAsyncSetup || prefetches) {
    let p2 = hasAsyncSetup ? res : Promise.resolve();
    if (prefetches) {
      p2 = p2.then(() => Promise.all(prefetches.map((prefetch) => prefetch.call(instance.proxy)))).catch(() => {});
    }
    return p2.then(() => renderComponentSubTree(instance, slotScopeId));
  } else {
    return renderComponentSubTree(instance, slotScopeId);
  }
}
function renderComponentSubTree(instance, slotScopeId) {
  const comp = instance.type;
  const { getBuffer, push } = createBuffer();
  if (isFunction$1(comp)) {
    let root3 = renderComponentRoot(instance);
    if (!comp.props) {
      for (const key in instance.attrs) {
        if (key.startsWith(`data-v-`)) {
          (root3.props || (root3.props = {}))[key] = ``;
        }
      }
    }
    renderVNode(push, instance.subTree = root3, instance, slotScopeId);
  } else {
    if ((!instance.render || instance.render === NOOP) && !instance.ssrRender && !comp.ssrRender && isString$1(comp.template)) {
      comp.ssrRender = ssrCompile(comp.template);
    }
    for (const e2 of instance.scope.effects) {
      if (e2.computed)
        e2.computed._cacheable = true;
    }
    const ssrRender = instance.ssrRender || comp.ssrRender;
    if (ssrRender) {
      let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;
      let hasCloned = false;
      let cur = instance;
      while (true) {
        const scopeId = cur.vnode.scopeId;
        if (scopeId) {
          if (!hasCloned) {
            attrs = { ...attrs };
            hasCloned = true;
          }
          attrs[scopeId] = "";
        }
        const parent = cur.parent;
        if (parent && parent.subTree && parent.subTree === cur.vnode) {
          cur = parent;
        } else {
          break;
        }
      }
      if (slotScopeId) {
        if (!hasCloned)
          attrs = { ...attrs };
        attrs[slotScopeId.trim()] = "";
      }
      const prev = setCurrentRenderingInstance(instance);
      try {
        ssrRender(instance.proxy, push, instance, attrs, instance.props, instance.setupState, instance.data, instance.ctx);
      } finally {
        setCurrentRenderingInstance(prev);
      }
    } else if (instance.render && instance.render !== NOOP) {
      renderVNode(push, instance.subTree = renderComponentRoot(instance), instance, slotScopeId);
    } else {
      const componentName = comp.name || comp.__file || `<Anonymous>`;
      exports_vue.warn(`Component ${componentName} is missing template or render function.`);
      push(`<!---->`);
    }
  }
  return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
  const { type, shapeFlag, children } = vnode;
  switch (type) {
    case exports_vue.Text:
      push(escapeHtml$1(children));
      break;
    case exports_vue.Comment:
      push(children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`);
      break;
    case exports_vue.Static:
      push(children);
      break;
    case exports_vue.Fragment:
      if (vnode.slotScopeIds) {
        slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
      }
      push(`<!--[-->`);
      renderVNodeChildren(push, children, parentComponent, slotScopeId);
      push(`<!--]-->`);
      break;
    default:
      if (shapeFlag & 1) {
        renderElementVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 6) {
        push(renderComponentVNode(vnode, parentComponent, slotScopeId));
      } else if (shapeFlag & 64) {
        renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 128) {
        renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
      } else {
        exports_vue.warn("[@vue/server-renderer] Invalid VNode type:", type, `(${typeof type})`);
      }
  }
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
  for (let i = 0;i < children.length; i++) {
    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
  }
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
  const tag3 = vnode.type;
  let { props, children, shapeFlag, scopeId, dirs } = vnode;
  let openTag = `<${tag3}`;
  if (dirs) {
    props = applySSRDirectives(vnode, props, dirs);
  }
  if (props) {
    openTag += ssrRenderAttrs(props, tag3);
  }
  if (scopeId) {
    openTag += ` ${scopeId}`;
  }
  let curParent = parentComponent;
  let curVnode = vnode;
  while (curParent && curVnode === curParent.subTree) {
    curVnode = curParent.vnode;
    if (curVnode.scopeId) {
      openTag += ` ${curVnode.scopeId}`;
    }
    curParent = curParent.parent;
  }
  if (slotScopeId) {
    openTag += ` ${slotScopeId}`;
  }
  push(openTag + `>`);
  if (!isVoidTag(tag3)) {
    let hasChildrenOverride = false;
    if (props) {
      if (props.innerHTML) {
        hasChildrenOverride = true;
        push(props.innerHTML);
      } else if (props.textContent) {
        hasChildrenOverride = true;
        push(escapeHtml$1(props.textContent));
      } else if (tag3 === "textarea" && props.value) {
        hasChildrenOverride = true;
        push(escapeHtml$1(props.value));
      }
    }
    if (!hasChildrenOverride) {
      if (shapeFlag & 8) {
        push(escapeHtml$1(children));
      } else if (shapeFlag & 16) {
        renderVNodeChildren(push, children, parentComponent, slotScopeId);
      }
    }
    push(`</${tag3}>`);
  }
}
function applySSRDirectives(vnode, rawProps, dirs) {
  const toMerge = [];
  for (let i = 0;i < dirs.length; i++) {
    const binding2 = dirs[i];
    const {
      dir: { getSSRProps }
    } = binding2;
    if (getSSRProps) {
      const props = getSSRProps(binding2, vnode);
      if (props)
        toMerge.push(props);
    }
  }
  return exports_vue.mergeProps(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
  const target = vnode.props && vnode.props.to;
  const disabled = vnode.props && vnode.props.disabled;
  if (!target) {
    if (!disabled) {
      exports_vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);
    }
    return [];
  }
  if (!isString$1(target)) {
    exports_vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);
    return [];
  }
  ssrRenderTeleport(push, (push2) => {
    renderVNodeChildren(push2, vnode.children, parentComponent, slotScopeId);
  }, target, disabled || disabled === "", parentComponent);
}
var { isVNode: isVNode$1 } = exports_vue.ssrUtils;
async function unrollBuffer$1(buffer) {
  if (buffer.hasAsync) {
    let ret = "";
    for (let i = 0;i < buffer.length; i++) {
      let item = buffer[i];
      if (isPromise$1(item)) {
        item = await item;
      }
      if (isString$1(item)) {
        ret += item;
      } else {
        ret += await unrollBuffer$1(item);
      }
    }
    return ret;
  } else {
    return unrollBufferSync$1(buffer);
  }
}
function unrollBufferSync$1(buffer) {
  let ret = "";
  for (let i = 0;i < buffer.length; i++) {
    let item = buffer[i];
    if (isString$1(item)) {
      ret += item;
    } else {
      ret += unrollBufferSync$1(item);
    }
  }
  return ret;
}
async function renderToString2(input2, context = {}) {
  if (isVNode$1(input2)) {
    return renderToString2(exports_vue.createApp({ render: () => input2 }), context);
  }
  const vnode = exports_vue.createVNode(input2._component, input2._props);
  vnode.appContext = input2._context;
  input2.provide(exports_vue.ssrContextKey, context);
  const buffer = await renderComponentVNode(vnode);
  const result2 = await unrollBuffer$1(buffer);
  await resolveTeleports(context);
  if (context.__watcherHandles) {
    for (const unwatch of context.__watcherHandles) {
      unwatch();
    }
  }
  return result2;
}
async function resolveTeleports(context) {
  if (context.__teleportBuffers) {
    context.teleports = context.teleports || {};
    for (const key in context.__teleportBuffers) {
      context.teleports[key] = await unrollBuffer$1(await Promise.all([context.__teleportBuffers[key]]));
    }
  }
}
exports_vue.initDirectivesForSSR();
/*!
  * shared v9.9.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
var inBrowser = typeof window !== "undefined";
var mark;
var measure;
if (true) {
  const perf = inBrowser && window.performance;
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = (tag3) => {
      perf.mark(tag3);
    };
    measure = (name3, startTag, endTag) => {
      perf.measure(name3, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    };
  }
}
var RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message, ...args) {
  if (args.length === 1 && isObject2(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
var makeSymbol = (name3, shareable = false) => !shareable ? Symbol(name3) : Symbol.for(name3);
var generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
var friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
var isNumber2 = (val) => typeof val === "number" && isFinite(val);
var isDate = (val) => toTypeString(val) === "[object Date]";
var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
var isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
var assign = Object.assign;
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
var isArray = Array.isArray;
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isBoolean = (val) => typeof val === "boolean";
var isObject2 = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject2(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var isPlainObject = (val) => {
  if (!isObject2(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
var toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join(items, separator = "") {
  return items.reduce((str2, item, index) => index === 0 ? str2 + item : str2 + separator + item, "");
}
var RANGE = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i = 0;i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (let j = i - RANGE;j <= i + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i) {
          const pad2 = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
          res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join(`
`);
}
function incrementer(code) {
  let current = code;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
var hasWarned = {};
function warnOnce2(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function createEmitter() {
  const events = new Map;
  const emitter = {
    events,
    on(event, handler) {
      const handlers = events.get(event);
      const added = handlers && handlers.push(handler);
      if (!added) {
        events.set(event, [handler]);
      }
    },
    off(event, handler) {
      const handlers = events.get(event);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },
    emit(event, payload) {
      (events.get(event) || []).slice().map((handler) => handler(payload));
      (events.get("*") || []).slice().map((handler) => handler(event, payload));
    }
  };
  return emitter;
}
var isNotObjectOrIsArray = (val) => !isObject2(val) || isArray(val);
function deepCopy(src2, des) {
  if (isNotObjectOrIsArray(src2) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src: src2, des }];
  while (stack.length) {
    const { src: src3, des: des2 } = stack.pop();
    Object.keys(src3).forEach((key) => {
      if (isNotObjectOrIsArray(src3[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src3[key];
      } else {
        stack.push({ src: src3[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.9.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
var CompileErrorCodes = {
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  __EXTEND_POINT__: 17
};
var errorMessages$2 = {
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code, loc, options3 = {}) {
  const { domain, messages, args } = options3;
  const msg = format$1((messages || errorMessages$2)[code] || "", ...args || []);
  const error2 = new SyntaxError(String(msg));
  error2.code = code;
  if (loc) {
    error2.location = loc;
  }
  error2.domain = domain;
  return error2;
}
function defaultOnError(error2) {
  throw error2;
}
var RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
var detectHtmlTag = (source) => RE_HTML_TAG.test(source);
var CHAR_SP = " ";
var CHAR_CR = "\r";
var CHAR_LF = `
`;
var CHAR_LS = String.fromCharCode(8232);
var CHAR_PS = String.fromCharCode(8233);
function createScanner(str2) {
  const _buf = str2;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset2() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset: reset2,
    resetPeek,
    skipToPeek
  };
}
var EOF = undefined;
var DOT = ".";
var LITERAL_DELIMITER = "'";
var ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options3 = {}) {
  const location = options3.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options3;
  function emitError2(code, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token2 = { type };
    if (location) {
      token2.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token2.value = value;
    }
    return token2;
  }
  const getEndToken = (context2) => getToken(context2, 14);
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError2(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart2(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc2 = ch.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || cc2 >= 65 && cc2 <= 90 || cc2 === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc2 = ch.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart2(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart2(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn2 = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart2(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn2();
      } else {
        return isIdentifierStart2(ch);
      }
    };
    const ret = fn2();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset2 = true) {
    const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn2(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn2(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn2(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn2();
    reset2 && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn2) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn2(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function takeIdentifierChar(scnr) {
    const closure = (ch) => {
      const cc2 = ch.charCodeAt(0);
      return cc2 >= 97 && cc2 <= 122 || cc2 >= 65 && cc2 <= 90 || cc2 >= 48 && cc2 <= 57 || cc2 === 95 || cc2 === 36;
    };
    return takeChar(scnr, closure);
  }
  function takeDigit(scnr) {
    const closure = (ch) => {
      const cc2 = ch.charCodeAt(0);
      return cc2 >= 48 && cc2 <= 57;
    };
    return takeChar(scnr, closure);
  }
  function takeHexDigit(scnr) {
    const closure = (ch) => {
      const cc2 = ch.charCodeAt(0);
      return cc2 >= 48 && cc2 <= 57 || cc2 >= 65 && cc2 <= 70 || cc2 >= 97 && cc2 <= 102;
    };
    return takeChar(scnr, closure);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError2(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name3 = "";
    while (ch = takeIdentifierChar(scnr)) {
      name3 += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name3;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal2 = "";
    const fn2 = (x2) => x2 !== LITERAL_DELIMITER && x2 !== CHAR_LF;
    while (ch = takeChar(scnr, fn2)) {
      if (ch === "\\") {
        literal2 += readEscapeSequence(scnr);
      } else {
        literal2 += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError2(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal2;
    }
    eat(scnr, `'`);
    return literal2;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError2(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode2, digits) {
    eat(scnr, unicode2);
    let sequence = "";
    for (let i = 0;i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError2(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode2}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode2}${sequence}`;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    const closure = (ch2) => ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
    while (ch = takeChar(scnr, closure)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name3 = "";
    while (ch = takeIdentifierChar(scnr)) {
      name3 += ch;
    }
    return name3;
  }
  function readLinkedRefer(scnr) {
    const fn2 = (detect = false, buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn2(detect, buf);
      } else {
        buf += ch;
        scnr.next();
        return fn2(true, buf);
      }
    };
    return fn2(false, "");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(scnr, "|");
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token2 = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError2(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(context2, 2, "{");
        skipSpaces(scnr);
        context2.braceNest++;
        return token2;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError2(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token2 = getToken(context2, 3, "}");
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token2;
      case "@":
        if (context2.braceNest > 0) {
          emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token2 = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token2;
      default:
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token2 = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token2 = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token2;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token2 = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError2(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token2.value);
          skipSpaces(scnr);
          return token2;
        }
        break;
    }
    return token2;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token2 = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError2(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token2 = getToken(context2, 8, "@");
        context2.inLinked = true;
        return token2;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(context2, 9, ".");
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(context2, 10, ":");
      default:
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token2;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError2(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token2 = { type: 14 };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError2(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(context2, 3, "}");
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default:
        if (isPluralStart(scnr)) {
          token2 = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token2;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
    }
    return token2;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(_context, 14);
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
var ERROR_DOMAIN$2 = "parser";
var KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "\uFFFD";
    }
  }
}
function createParser(options3 = {}) {
  const location = options3.location !== false;
  const { onError } = options3;
  function emitError2(tokenzer, code, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location ? createLocation(start, end) : null;
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function startNode(type, offset, loc) {
    const node2 = { type };
    if (location) {
      node2.start = offset;
      node2.end = offset;
      node2.loc = { start: loc, end: loc };
    }
    return node2;
  }
  function endNode(node2, offset, pos, type) {
    if (type) {
      node2.type = type;
    }
    if (location) {
      node2.end = offset;
      if (node2.loc) {
        node2.loc.end = pos;
      }
    }
  }
  function parseText2(tokenizer4, value) {
    const context = tokenizer4.context();
    const node2 = startNode(3, context.offset, context.startLoc);
    node2.value = value;
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseList(tokenizer4, index) {
    const context = tokenizer4.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node2 = startNode(5, offset, loc);
    node2.index = parseInt(index, 10);
    tokenizer4.nextToken();
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseNamed(tokenizer4, key) {
    const context = tokenizer4.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node2 = startNode(4, offset, loc);
    node2.key = key;
    tokenizer4.nextToken();
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseLiteral(tokenizer4, value) {
    const context = tokenizer4.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node2 = startNode(9, offset, loc);
    node2.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer4.nextToken();
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseLinkedModifier(tokenizer4) {
    const token2 = tokenizer4.nextToken();
    const context = tokenizer4.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node2 = startNode(8, offset, loc);
    if (token2.type !== 12) {
      emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node2.value = "";
      endNode(node2, offset, loc);
      return {
        nextConsumeToken: token2,
        node: node2
      };
    }
    if (token2.value == null) {
      emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    node2.value = token2.value || "";
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return {
      node: node2
    };
  }
  function parseLinkedKey(tokenizer4, value) {
    const context = tokenizer4.context();
    const node2 = startNode(7, context.offset, context.startLoc);
    node2.value = value;
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseLinked(tokenizer4) {
    const context = tokenizer4.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token2 = tokenizer4.nextToken();
    if (token2.type === 9) {
      const parsed = parseLinkedModifier(tokenizer4);
      linkedNode.modifier = parsed.node;
      token2 = parsed.nextConsumeToken || tokenizer4.nextToken();
    }
    if (token2.type !== 10) {
      emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
    }
    token2 = tokenizer4.nextToken();
    if (token2.type === 2) {
      token2 = tokenizer4.nextToken();
    }
    switch (token2.type) {
      case 11:
        if (token2.value == null) {
          emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLinkedKey(tokenizer4, token2.value || "");
        break;
      case 5:
        if (token2.value == null) {
          emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseNamed(tokenizer4, token2.value || "");
        break;
      case 6:
        if (token2.value == null) {
          emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseList(tokenizer4, token2.value || "");
        break;
      case 7:
        if (token2.value == null) {
          emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
        }
        linkedNode.key = parseLiteral(tokenizer4, token2.value || "");
        break;
      default:
        emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer4.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token2,
          node: linkedNode
        };
    }
    endNode(linkedNode, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer4) {
    const context = tokenizer4.context();
    const startOffset = context.currentType === 1 ? tokenizer4.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node2 = startNode(2, startOffset, startLoc);
    node2.items = [];
    let nextToken = null;
    do {
      const token2 = nextToken || tokenizer4.nextToken();
      nextToken = null;
      switch (token2.type) {
        case 0:
          if (token2.value == null) {
            emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node2.items.push(parseText2(tokenizer4, token2.value || ""));
          break;
        case 6:
          if (token2.value == null) {
            emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node2.items.push(parseList(tokenizer4, token2.value || ""));
          break;
        case 5:
          if (token2.value == null) {
            emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node2.items.push(parseNamed(tokenizer4, token2.value || ""));
          break;
        case 7:
          if (token2.value == null) {
            emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          node2.items.push(parseLiteral(tokenizer4, token2.value || ""));
          break;
        case 8:
          const parsed = parseLinked(tokenizer4);
          node2.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer4.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer4.currentPosition();
    endNode(node2, endOffset, endLoc);
    return node2;
  }
  function parsePlural(tokenizer4, offset, loc, msgNode) {
    const context = tokenizer4.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node2 = startNode(1, offset, loc);
    node2.cases = [];
    node2.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer4);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node2.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError2(tokenizer4, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  function parseResource(tokenizer4) {
    const context = tokenizer4.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer4);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer4, offset, startLoc, msgNode);
    }
  }
  function parse(source) {
    const tokenizer4 = createTokenizer(source, assign({}, options3));
    const context = tokenizer4.context();
    const node2 = startNode(0, context.offset, context.startLoc);
    if (location && node2.loc) {
      node2.loc.source = source;
    }
    node2.body = parseResource(tokenizer4);
    if (options3.onCacheKey) {
      node2.cacheKey = options3.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError2(tokenizer4, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node2, tokenizer4.currentOffset(), tokenizer4.currentPosition());
    return node2;
  }
  return { parse };
}
function getTokenCaption(token2) {
  if (token2.type === 14) {
    return "EOF";
  }
  const name3 = (token2.value || "").replace(/\r?\n/gu, "\\n");
  return name3.length > 10 ? name3.slice(0, 9) + "\u2026" : name3;
}
function createTransformer(ast, options3 = {}) {
  const _context = {
    ast,
    helpers: new Set
  };
  const context = () => _context;
  const helper = (name3) => {
    _context.helpers.add(name3);
    return name3;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0;i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node2, transformer) {
  switch (node2.type) {
    case 1:
      traverseNodes(node2.cases, transformer);
      transformer.helper("plural");
      break;
    case 2:
      traverseNodes(node2.items, transformer);
      break;
    case 6:
      const linked = node2;
      traverseNode(linked.key, transformer);
      transformer.helper("linked");
      transformer.helper("type");
      break;
    case 5:
      transformer.helper("interpolate");
      transformer.helper("list");
      break;
    case 4:
      transformer.helper("interpolate");
      transformer.helper("named");
      break;
  }
}
function transform2(ast, options3 = {}) {
  const transformer = createTransformer(ast);
  transformer.helper("normalize");
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c3) => optimizeMessageNode(c3));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0;i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join(values);
      for (let i = 0;i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
var ERROR_DOMAIN$1 = "minifier";
function minify(node2) {
  node2.t = node2.type;
  switch (node2.type) {
    case 0:
      const resource = node2;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    case 1:
      const plural = node2;
      const cases = plural.cases;
      for (let i = 0;i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    case 2:
      const message = node2;
      const items = message.items;
      for (let i = 0;i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    case 3:
    case 9:
    case 8:
    case 7:
      const valueNode = node2;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    case 6:
      const linked = node2;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    case 5:
      const list2 = node2;
      list2.i = list2.index;
      delete list2.index;
      break;
    case 4:
      const named = node2;
      named.k = named.key;
      delete named.key;
      break;
    default:
      if (true) {
        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: ERROR_DOMAIN$1,
          args: [node2.type]
        });
      }
  }
  delete node2.type;
}
var ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options3) {
  const { sourceMap: sourceMap2, filename, breakLineCode, needIndent: _needIndent } = options3;
  const location = options3.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: undefined,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code, node2) {
    _context.code += code;
  }
  function _newline(n3, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n3) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline2() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline: newline2,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node2) {
  const { helper } = generator;
  generator.push(`${helper("linked")}(`);
  generateNode(generator, node2.key);
  if (node2.modifier) {
    generator.push(`, `);
    generateNode(generator, node2.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node2) {
  const { helper, needIndent } = generator;
  generator.push(`${helper("normalize")}([`);
  generator.indent(needIndent());
  const length = node2.items.length;
  for (let i = 0;i < length; i++) {
    generateNode(generator, node2.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node2) {
  const { helper, needIndent } = generator;
  if (node2.cases.length > 1) {
    generator.push(`${helper("plural")}([`);
    generator.indent(needIndent());
    const length = node2.cases.length;
    for (let i = 0;i < length; i++) {
      generateNode(generator, node2.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node2) {
  if (node2.body) {
    generateNode(generator, node2.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node2) {
  const { helper } = generator;
  switch (node2.type) {
    case 0:
      generateResource(generator, node2);
      break;
    case 1:
      generatePluralNode(generator, node2);
      break;
    case 2:
      generateMessageNode(generator, node2);
      break;
    case 6:
      generateLinkedNode(generator, node2);
      break;
    case 8:
      generator.push(JSON.stringify(node2.value), node2);
      break;
    case 7:
      generator.push(JSON.stringify(node2.value), node2);
      break;
    case 5:
      generator.push(`${helper("interpolate")}(${helper("list")}(${node2.index}))`, node2);
      break;
    case 4:
      generator.push(`${helper("interpolate")}(${helper("named")}(${JSON.stringify(node2.key)}))`, node2);
      break;
    case 9:
      generator.push(JSON.stringify(node2.value), node2);
      break;
    case 3:
      generator.push(JSON.stringify(node2.value), node2);
      break;
    default:
      if (true) {
        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: ERROR_DOMAIN,
          args: [node2.type]
        });
      }
  }
}
var generate = (ast, options3 = {}) => {
  const mode = isString(options3.mode) ? options3.mode : "normal";
  const filename = isString(options3.filename) ? options3.filename : "message.intl";
  const sourceMap2 = !!options3.sourceMap;
  const breakLineCode = options3.breakLineCode != null ? options3.breakLineCode : mode === "arrow" ? ";" : `
`;
  const needIndent = options3.needIndent ? options3.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap: sourceMap2,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code, map: map3 } = generator.context();
  return {
    ast,
    code,
    map: map3 ? map3.toJSON() : undefined
  };
};
function baseCompile$1(source, options3 = {}) {
  const assignedOptions = assign({}, options3);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser2 = createParser(assignedOptions);
  const ast = parser2.parse(source);
  if (!jit) {
    transform2(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.9.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
var pathStateMachine = [];
pathStateMachine[0] = {
  ["w"]: [0],
  ["i"]: [3, 0],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[1] = {
  ["w"]: [1],
  ["."]: [2],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[2] = {
  ["w"]: [2],
  ["i"]: [3, 0],
  ["0"]: [3, 0]
};
pathStateMachine[3] = {
  ["i"]: [3, 0],
  ["0"]: [3, 0],
  ["w"]: [1, 1],
  ["."]: [2, 1],
  ["["]: [4, 1],
  ["o"]: [7, 1]
};
pathStateMachine[4] = {
  ["'"]: [5, 0],
  ['"']: [6, 0],
  ["["]: [
    4,
    2
  ],
  ["]"]: [1, 3],
  ["o"]: 8,
  ["l"]: [4, 0]
};
pathStateMachine[5] = {
  ["'"]: [4, 0],
  ["o"]: 8,
  ["l"]: [5, 0]
};
pathStateMachine[6] = {
  ['"']: [4, 0],
  ["o"]: 8,
  ["l"]: [6, 0]
};
var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str2) {
  const a = str2.charCodeAt(0);
  const b = str2.charCodeAt(str2.length - 1);
  return a === b && (a === 34 || a === 39) ? str2.slice(1, -1) : str2;
}
function getPathCharType(ch) {
  if (ch === undefined || ch === null) {
    return "o";
  }
  const code = ch.charCodeAt(0);
  switch (code) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path3) {
  const trimmed = path3.trim();
  if (path3.charAt(0) === "0" && isNaN(parseInt(path3))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path3) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c3;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[0] = () => {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[1] = () => {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };
  actions[2] = () => {
    actions[0]();
    subPathDepth++;
  };
  actions[3] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[0]();
    } else {
      subPathDepth = 0;
      if (key === undefined) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[1]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path3[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[0]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c3 = path3[index];
    if (c3 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c3);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap["l"] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== undefined) {
      action = actions[transition[1]];
      if (action) {
        newChar = c3;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
var cache = new Map;
function resolveWithKeyValue(obj, path3) {
  return isObject2(obj) ? obj[path3] : null;
}
function resolveValue(obj, path3) {
  if (!isObject2(obj)) {
    return null;
  }
  let hit = cache.get(path3);
  if (!hit) {
    hit = parse(path3);
    if (hit) {
      cache.set(path3, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last2 = obj;
  let i = 0;
  while (i < len) {
    const val = last2[hit[i]];
    if (val === undefined) {
      return null;
    }
    if (isFunction(last2)) {
      return null;
    }
    last2 = val;
    i++;
  }
  return last2;
}
var DEFAULT_MODIFIER = (str2) => str2;
var DEFAULT_MESSAGE = (ctx) => "";
var DEFAULT_MESSAGE_DATA_TYPE = "text";
var DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
var DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice2, choicesLength) {
  choice2 = Math.abs(choice2);
  if (choicesLength === 2) {
    return choice2 ? choice2 > 1 ? 1 : 0 : 1;
  }
  return choice2 ? Math.min(choice2, 2) : 0;
}
function getPluralIndex(options3) {
  const index = isNumber2(options3.pluralIndex) ? options3.pluralIndex : -1;
  return options3.named && (isNumber2(options3.named.count) || isNumber2(options3.named.n)) ? isNumber2(options3.named.count) ? options3.named.count : isNumber2(options3.named.n) ? options3.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options3 = {}) {
  const locale = options3.locale;
  const pluralIndex = getPluralIndex(options3);
  const pluralRule = isObject2(options3.pluralRules) && isString(locale) && isFunction(options3.pluralRules[locale]) ? options3.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject2(options3.pluralRules) && isString(locale) && isFunction(options3.pluralRules[locale]) ? pluralDefault : undefined;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options3.list || [];
  const list2 = (index) => _list[index];
  const _named = options3.named || {};
  isNumber2(options3.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options3.messages) ? options3.messages(key) : isObject2(options3.messages) ? options3.messages[key] : false;
    return !msg ? options3.parent ? options3.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name3) => options3.modifiers ? options3.modifiers[name3] : DEFAULT_MODIFIER;
  const normalize3 = isPlainObject(options3.processor) && isFunction(options3.processor.normalize) ? options3.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options3.processor) && isFunction(options3.processor.interpolate) ? options3.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options3.processor) && isString(options3.processor.type) ? options3.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject2(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret;
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    ["list"]: list2,
    ["named"]: named,
    ["plural"]: plural,
    ["linked"]: linked,
    ["message"]: message,
    ["type"]: type,
    ["interpolate"]: interpolate,
    ["normalize"]: normalize3,
    ["values"]: assign({}, _list, _named)
  };
  return ctx;
}
var devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version,
    meta
  });
}
var translateDevTools = /* @__PURE__ */ createDevToolsHook("function:translate");
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
var CoreWarnCodes = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7,
  __EXTEND_POINT__: 8
};
var warnMessages$1 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage$1(code, ...args) {
  return format$1(warnMessages$1[code], ...args);
}
var code$2 = CompileErrorCodes.__EXTEND_POINT__;
var inc$2 = incrementer(code$2);
var CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  INVALID_DATE_ARGUMENT: inc$2(),
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  __EXTEND_POINT__: inc$2()
};
function createCoreError(code) {
  return createCompileError(code, null, { messages: errorMessages$1 });
}
var errorMessages$1 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object." + "Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options3) {
  return options3.locale != null ? resolveLocale(options3.locale) : resolveLocale(context.locale);
}
var _resolveLocale;
function resolveLocale(locale) {
  if (isString(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve3 = locale();
        if (isPromise(resolve3)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve3;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [...new Set([
    start,
    ...isArray(fallback) ? fallback : isObject2(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = new Map;
  }
  let chain2 = context.__localeChainCache.get(startLocale);
  if (!chain2) {
    chain2 = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain2, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain2, block, false);
    }
    context.__localeChainCache.set(startLocale, chain2);
  }
  return chain2;
}
function appendBlockToChain(chain2, block, blocks) {
  let follow = true;
  for (let i = 0;i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString(locale)) {
      follow = appendLocaleToChain(chain2, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain2, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain2, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain2, target, blocks) {
  let follow = false;
  if (!chain2.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain2.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
var VERSION$1 = "9.9.1";
var NOT_REOSLVED = -1;
var DEFAULT_LOCALE = "en-US";
var MISSING_RESOLVE_VALUE = "";
var capitalize = (str2) => `${str2.charAt(0).toLocaleUpperCase()}${str2.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject2(val) && ("__v_isVNode" in val) ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject2(val) && ("__v_isVNode" in val) ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString(val) ? capitalize(val) : type === "vnode" && isObject2(val) && ("__v_isVNode" in val) ? capitalize(val.children) : val;
    }
  };
}
var _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
var _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
var _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
var _additionalMeta = null;
var setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
var getAdditionalMeta = () => _additionalMeta;
var _fallbackContext = null;
var setFallbackContext = (context) => {
  _fallbackContext = context;
};
var getFallbackContext = () => _fallbackContext;
var _cid = 0;
function createCoreContext(options3 = {}) {
  const onWarn = isFunction(options3.onWarn) ? options3.onWarn : warn;
  const version = isString(options3.version) ? options3.version : VERSION$1;
  const locale = isString(options3.locale) || isFunction(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || isString(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale;
  const messages = isPlainObject(options3.messages) ? options3.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale]: {} };
  const modifiers = assign({}, options3.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options3.pluralRules || {};
  const missing = isFunction(options3.missing) ? options3.missing : null;
  const missingWarn = isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const fallbackWarn = isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const fallbackFormat = !!options3.fallbackFormat;
  const unresolving = !!options3.unresolving;
  const postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  const processor2 = isPlainObject(options3.processor) ? options3.processor : null;
  const warnHtmlMessage = isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const escapeParameter = !!options3.escapeParameter;
  const messageCompiler = isFunction(options3.messageCompiler) ? options3.messageCompiler : _compiler;
  if (isFunction(options3.messageCompiler)) {
    warnOnce2(getWarnMessage$1(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction(options3.messageResolver) ? options3.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options3.localeFallbacker) ? options3.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject2(options3.fallbackContext) ? options3.fallbackContext : undefined;
  const internalOptions = options3;
  const __datetimeFormatters = isObject2(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map;
  const __numberFormatters = isObject2(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map;
  const __meta = isObject2(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor: processor2,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (true) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : undefined;
  }
  if (true) {
    initI18nDevTools(context, version, __meta);
  }
  return context;
}
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (true) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString(ret) ? ret : key;
  } else {
    if (isTranslateMissingWarn(missingWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key, locale }));
    }
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = new Map;
  ctx.localeFallbacker(ctx, fallback, locale);
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages, c3) => [
      ...messages,
      formatMessageParts(ctx, c3)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node2) {
  const _static = node2.s || node2.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages = (node2.i || node2.items).reduce((acm, c3) => [...acm, formatMessagePart(ctx, c3)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node2) {
  const type = node2.t || node2.type;
  switch (type) {
    case 3:
      const text = node2;
      return text.v || text.value;
    case 9:
      const literal2 = node2;
      return literal2.v || literal2.value;
    case 4:
      const named = node2;
      return ctx.interpolate(ctx.named(named.k || named.key));
    case 5:
      const list2 = node2;
      return ctx.interpolate(ctx.list(list2.i != null ? list2.i : list2.index));
    case 6:
      const linked = node2;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : undefined, ctx.type);
    case 7:
      const linkedKey = node2;
      return linkedKey.v || linkedKey.value;
    case 8:
      const linkedModifier = node2;
      return linkedModifier.v || linkedModifier.value;
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
var WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn(format$1(WARN_MESSAGE, { source }));
  }
}
var defaultOnCacheKey = (message) => message;
var compileCache = Object.create(null);
var isMessageAST = (val) => isObject2(val) && (val.t === 0 || val.type === 0) && (("b" in val) || ("body" in val));
function baseCompile(message, options3 = {}) {
  let detectError = false;
  const onError = options3.onError || defaultOnError;
  options3.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options3), detectError };
}
var compileToFunction = (message, context) => {
  if (!isString(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile$12(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString(message)) {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: true,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (!isMessageAST(message)) {
      warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message;
    }
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
var NOOP_MESSAGE_FUNCTION = () => "";
var isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options3] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options3.escapeParameter) ? options3.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options3.resolvedMessage;
  const defaultMsgOrKey = isString(options3.default) || isBoolean(options3.default) ? !isBoolean(options3.default) ? options3.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options3);
  escapeParameter && escapeParams(options3);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (isString(format2) && context.messageCompiler == null) {
    warn(`The message format compilation is not supported in this build. ` + `Because message compiler isn't included. ` + `You need to pre-compilation all message format. ` + `So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options3);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (true) {
    const payloads = {
      timestamp: Date.now(),
      key: isString(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options3) {
  if (isArray(options3.list)) {
    options3.list = options3.list.map((item) => isString(item) ? escapeHtml(item) : item);
  } else if (isObject2(options3.named)) {
    Object.keys(options3.named).forEach((key) => {
      if (isString(options3.named[key])) {
        options3.named[key] = escapeHtml(options3.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  let from2 = locale;
  let to = null;
  const type = "translate";
  for (let i = 0;i < locales.length; i++) {
    targetLocale = to = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from: from2,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    message = messages[targetLocale] || {};
    let start = null;
    let startTag;
    let endTag;
    if (inBrowser) {
      start = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (inBrowser) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start && format2) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format2,
          time: end - start,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);
    if (missingRet !== key) {
      format2 = missingRet;
    }
    from2 = to;
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format2,
        time: end - start,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options3 = {};
  if (!isString(arg1) && !isNumber2(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber2(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber2(arg2)) {
    options3.plural = arg2;
  } else if (isString(arg2)) {
    options3.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options3.named = arg2;
  } else if (isArray(arg2)) {
    options3.list = arg2;
  }
  if (isNumber2(arg3)) {
    options3.plural = arg3;
  } else if (isString(arg3)) {
    options3.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign(options3, arg3);
  }
  return [key, options3];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      if (true) {
        const _source = getSourceForCodeFrame(source);
        const message = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message}
${codeFrame}` : message);
      } else {}
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getSourceForCodeFrame(source) {
  if (isString(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
function getMessageContextOptions(context, locale, message, options3) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options3.list) {
    ctxOptions.list = options3.list;
  }
  if (options3.named) {
    ctxOptions.named = options3.named;
  }
  if (isNumber2(options3.plural)) {
    ctxOptions.pluralIndex = options3.plural;
  }
  return ctxOptions;
}
var intlDefined = typeof Intl !== "undefined";
var Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (!Availabilities.dateTimeFormat) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options3, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale = getLocale(context, options3);
  const locales = localeFallbacker(context, fallbackLocale, locale);
  if (!isString(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  let from2 = locale;
  let to = null;
  const type = "datetime format";
  for (let i = 0;i < locales.length; i++) {
    targetLocale = to = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from: from2,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from2 = to;
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter2 = __datetimeFormatters.get(id3);
  if (!formatter2) {
    formatter2 = new Intl.DateTimeFormat(targetLocale, assign({}, format2, overrides));
    __datetimeFormatters.set(id3, formatter2);
  }
  return !part ? formatter2.format(value) : formatter2.formatToParts(value);
}
var DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  let value;
  if (isString(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber2(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value, options3, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id3)) {
      continue;
    }
    context.__datetimeFormatters.delete(id3);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (!Availabilities.numberFormat) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options3, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale = getLocale(context, options3);
  const locales = localeFallbacker(context, fallbackLocale, locale);
  if (!isString(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  let from2 = locale;
  let to = null;
  const type = "number format";
  for (let i = 0;i < locales.length; i++) {
    targetLocale = to = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from: from2,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from2 = to;
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter2 = __numberFormatters.get(id3);
  if (!formatter2) {
    formatter2 = new Intl.NumberFormat(targetLocale, assign({}, format2, overrides));
    __numberFormatters.set(id3, formatter2);
  }
  return !part ? formatter2.format(value) : formatter2.formatToParts(value);
}
var NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  if (!isNumber2(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value, options3, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id3)) {
      continue;
    }
    context.__numberFormatters.delete(id3);
  }
}
{
  initFeatureFlags$1();
}
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
var isProxyAvailable = typeof Proxy === "function";
var HOOK_SETUP = "devtools-plugin:setup";
var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
var supported;
var perf;
function isPerformanceSupported() {
  var _a4;
  if (supported !== undefined) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a4 = global.perf_hooks) === null || _a4 === undefined ? undefined : _a4.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id3 in plugin2.settings) {
        const item = plugin2.settings[id3];
        defaultSettings[id3] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e2) {}
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {}
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {}
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve3) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve3
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list2 = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list2.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * vue-i18n v9.9.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
var VERSION = "9.9.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
var code$1 = CoreWarnCodes.__EXTEND_POINT__;
var inc$1 = incrementer(code$1);
var I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  NOT_SUPPORTED_PRESERVE: inc$1(),
  NOT_SUPPORTED_FORMATTER: inc$1(),
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  IGNORE_OBJ_FLATTEN: inc$1(),
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1()
};
var warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see \uD83D\uDC49 https://tinyurl.com/2p97mcze`
};
function getWarnMessage(code, ...args) {
  return format$1(warnMessages[code], ...args);
}
var code = CoreErrorCodes.__EXTEND_POINT__;
var inc = incrementer(code);
var I18nErrorCodes = {
  UNEXPECTED_RETURN_TYPE: code,
  INVALID_ARGUMENT: inc(),
  MUST_BE_CALL_SETUP_TOP: inc(),
  NOT_INSTALLED: inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  REQUIRED_VALUE: inc(),
  INVALID_VALUE: inc(),
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  UNEXPECTED_ERROR: inc(),
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  __EXTEND_POINT__: inc()
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, { messages: errorMessages, args });
}
var errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define \u2018i18n\u2019 option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
var TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
var DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
var NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
var EnableEmitter = /* @__PURE__ */ makeSymbol("__enableEmitter");
var DisableEmitter = /* @__PURE__ */ makeSymbol("__disableEmitter");
var SetPluralRulesSymbol = makeSymbol("__setPluralRules");
var InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
var DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject2(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject2(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0;i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject2(currentObj[subKeys[i]])) {
          warn(getWarnMessage(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {
            key: subKeys[i]
          }));
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject2(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options3) {
  const { messages, __i18n, messageResolver, flatJson } = options3;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? {} : { [locale]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options3, componentOptions) {
  let messages = isObject2(options3.messages) ? options3.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject2(options3.datetimeFormats)) {
      const locales2 = Object.keys(options3.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options3.datetimeFormats[locale]);
        });
      }
    }
    if (isObject2(options3.numberFormats)) {
      const locales2 = Object.keys(options3.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options3.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return exports_vue.createVNode(exports_vue.Text, null, key, 0);
}
var DEVTOOLS_META = "__INTLIFY_META__";
var NOOP_RETURN_ARRAY = () => [];
var NOOP_RETURN_FALSE = () => false;
var composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, exports_vue.getCurrentInstance() || undefined, type);
  };
}
var getMetaInfo = () => {
  const instance = exports_vue.getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options3 = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options3;
  const _isGlobal = __root === undefined;
  const flatJson = options3.flatJson;
  const _ref = inBrowser ? exports_vue.ref : exports_vue.shallowRef;
  let _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : true;
  const _locale = _ref(__root && _inheritLocale ? __root.locale.value : isString(options3.locale) ? options3.locale : DEFAULT_LOCALE);
  const _fallbackLocale = _ref(__root && _inheritLocale ? __root.fallbackLocale.value : isString(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value);
  const _messages = _ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = _ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  let _fallbackFormat = !!options3.fallbackFormat;
  let _missing = isFunction(options3.missing) ? options3.missing : null;
  let _runtimeMissing = isFunction(options3.missing) ? defineCoreMissingHandler(options3.missing) : null;
  let _postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  let _escapeParameter = !!options3.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  let _pluralRules = options3.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? undefined : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? undefined : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options3.messageResolver,
      messageCompiler: options3.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : undefined;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : undefined;
    }
    if (true) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : undefined;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = exports_vue.computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = exports_vue.computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = exports_vue.computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ exports_vue.computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ exports_vue.computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (true) {
        setAdditionalMeta(getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : undefined;
      }
      ret = fn2(_context);
    } finally {
      if (true)
        ;
      if (!_isGlobal) {
        _context.fallbackContext = undefined;
      }
    }
    if (warnType !== "translate exists" && isNumber2(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (__root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (true) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root3) => Reflect.apply(root3.t, root3, [...args]), (key) => key, (val) => isString(val));
  }
  function rt2(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject2(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root3) => Reflect.apply(root3.d, root3, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function n3(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root3) => Reflect.apply(root3.n, root3, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function normalize3(values) {
    return values.map((val) => isString(val) || isNumber2(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor2 = {
    normalize: normalize3,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps((context) => {
      let ret;
      const _context2 = context;
      try {
        _context2.processor = processor2;
        ret = Reflect.apply(translate, null, [_context2, ...args]);
      } finally {
        _context2.processor = null;
      }
      return ret;
    }, () => parseTranslateArgs(...args), "translate", (root3) => root3[TranslateVNodeSymbol](...args), (key) => [createTextNode(key)], (val) => isArray(val));
  }
  function numberParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root3) => root3[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString(val) || isArray(val));
  }
  function datetimeParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root3) => root3[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString(val) || isArray(val));
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te2(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return isMessageAST(resolved) || isMessageFunction(resolved) || isString(resolved);
    }, () => [key], "translate exists", (root3) => {
      return Reflect.apply(root3.te, root3, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0;i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    exports_vue.watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    exports_vue.watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt2;
    composer.te = te2;
    composer.tm = tm;
    composer.d = d;
    composer.n = n3;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (true) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = undefined;
    };
  }
  return composer;
}
function convertComposerOptions(options3) {
  const locale = isString(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : locale;
  const missing = isFunction(options3.missing) ? options3.missing : undefined;
  const missingWarn = isBoolean(options3.silentTranslationWarn) || isRegExp(options3.silentTranslationWarn) ? !options3.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options3.silentFallbackWarn) || isRegExp(options3.silentFallbackWarn) ? !options3.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const fallbackFormat = !!options3.formatFallbackMessages;
  const modifiers = isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const pluralizationRules = options3.pluralizationRules;
  const postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : undefined;
  const warnHtmlMessage = isString(options3.warnHtmlInMessage) ? options3.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options3.escapeParameterHtml;
  const inheritLocale = isBoolean(options3.sync) ? options3.sync : true;
  if (options3.formatter) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (options3.preserveDirectiveContent) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages = options3.messages;
  if (isPlainObject(options3.sharedMessages)) {
    const sharedMessages = options3.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options3;
  const datetimeFormats = options3.datetimeFormats;
  const numberFormats = options3.numberFormats;
  const flatJson = options3.flatJson;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options3.messageResolver,
    inheritLocale,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options3 = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options3));
    const { __extender } = options3;
    const vueI18n = {
      id: composer.id,
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      get messages() {
        return composer.messages.value;
      },
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      get numberFormats() {
        return composer.numberFormats.value;
      },
      get availableLocales() {
        return composer.availableLocales;
      },
      get formatter() {
        warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
        warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
      },
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      get modifiers() {
        return composer.modifiers;
      },
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      get preserveDirectiveContent() {
        warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
        return true;
      },
      set preserveDirectiveContent(val) {
        warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      __composer: composer,
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options4 = {};
        let list2 = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options4.locale = arg2;
        } else if (isArray(arg2)) {
          list2 = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list2 = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list2 || named || {},
          options4
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options4 = { plural: 1 };
        let list2 = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options4.locale = arg2;
        } else if (isNumber2(arg2)) {
          options4.plural = arg2;
        } else if (isArray(arg2)) {
          list2 = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options4.locale = arg3;
        } else if (isArray(arg3)) {
          list2 = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list2 || named || {},
          options4
        ]);
      },
      te(key, locale) {
        return composer.te(key, locale);
      },
      tm(key) {
        return composer.tm(key);
      },
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      getChoiceIndex(choice2, choicesLength) {
        warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX));
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (true) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
var baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        ...current.type === exports_vue.Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag3) {
  return exports_vue.Fragment;
}
var TranslationImpl = /* @__PURE__ */ exports_vue.defineComponent({
  name: "i18n-t",
  props: assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      validator: (val) => isNumber2(val) || !isNaN(val)
    }
  }, baseFormatProps),
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options3 = {};
      if (props.locale) {
        options3.locale = props.locale;
      }
      if (props.plural !== undefined) {
        options3.plural = isString(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options3);
      const assignedAttrs = assign({}, attrs);
      const tag3 = isString(props.tag) || isObject2(props.tag) ? props.tag : getFragmentableTag();
      return exports_vue.h(tag3, assignedAttrs, children);
    };
  }
});
var Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options3 = { part: true };
    let overrides = {};
    if (props.locale) {
      options3.locale = props.locale;
    }
    if (isString(props.format)) {
      options3.key = props.format;
    } else if (isObject2(props.format)) {
      if (isString(props.format.key)) {
        options3.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options4, prop) => {
        return slotKeys.includes(prop) ? assign({}, options4, { [prop]: props.format[prop] }) : options4;
      }, {});
    }
    const parts = partFormatter(...[props.value, options3, overrides]);
    let children = [options3.key];
    if (isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node2 = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node2)) {
          node2[0].key = `${part.type}-${index}`;
        }
        return node2;
      });
    } else if (isString(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign({}, attrs);
    const tag3 = isString(props.tag) || isObject2(props.tag) ? props.tag : getFragmentableTag();
    return exports_vue.h(tag3, assignedAttrs, children);
  };
}
var NumberFormatImpl = /* @__PURE__ */ exports_vue.defineComponent({
  name: "i18n-n",
  props: assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: "parent",
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => i18n[NumberPartsSymbol](...args));
  }
});
var NumberFormat = NumberFormatImpl;
var DatetimeFormatImpl = /* @__PURE__ */ exports_vue.defineComponent({
  name: "i18n-d",
  props: assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: "parent",
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => i18n[DatetimePartsSymbol](...args));
  }
});
var DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding2) => {
    const { instance, modifiers, value } = binding2;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    if (modifiers.preserve) {
      warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding2) => {
    const [textContent, composer] = _process(binding2);
    if (inBrowser && i18n.global === composer) {
      el.__i18nWatcher = exports_vue.watch(composer.locale, () => {
        binding2.instance && binding2.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = undefined;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = undefined;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding2) => {
    const [textContent] = _process(binding2);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path: path3, locale, args, choice: choice2, plural } = value;
  const options3 = {};
  const named = args || {};
  if (isString(locale)) {
    options3.locale = locale;
  }
  if (isNumber2(choice2)) {
    options3.plural = choice2;
  }
  if (isNumber2(plural)) {
    options3.plural = plural;
  }
  return [path3, named, options3];
}
function apply(app, i18n, ...options3) {
  const pluginOptions = isPlainObject(options3[0]) ? options3[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall && useI18nComponentName) {
    warn(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name3) => app.component(name3, Translation));
    [NumberFormat.name, "I18nN"].forEach((name3) => app.component(name3, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name3) => app.component(name3, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
var VueDevToolsLabels = {
  ["vue-devtools-plugin-vue-i18n"]: "Vue I18n devtools",
  ["vue-i18n-resource-inspector"]: "I18n Resources",
  ["vue-i18n-timeline"]: "Vue I18n"
};
var VueDevToolsPlaceholders = {
  ["vue-i18n-resource-inspector"]: "Search for scopes ..."
};
var VueDevToolsTimelineColors = {
  ["vue-i18n-timeline"]: 16764185
};
var VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
var devtoolsApi;
async function enableDevTools(app, i18n) {
  return new Promise((resolve3, reject) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n",
        label: VueDevToolsLabels["vue-devtools-plugin-vue-i18n"],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app
      }, (api) => {
        devtoolsApi = api;
        api.on.visitComponentTree(({ componentInstance, treeNode }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n);
        });
        api.on.inspectComponent(({ componentInstance, instanceData }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n.mode === "legacy") {
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api.addInspector({
          id: "vue-i18n-resource-inspector",
          label: VueDevToolsLabels["vue-i18n-resource-inspector"],
          icon: "language",
          treeFilterPlaceholder: VueDevToolsPlaceholders["vue-i18n-resource-inspector"]
        });
        api.on.getInspectorTree((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            registerScope(payload, i18n);
          }
        });
        const roots = new Map;
        api.on.getInspectorState(async (payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            api.unhighlightElement();
            inspectScope(payload, i18n);
            if (payload.nodeId === "global") {
              if (!roots.has(payload.app)) {
                const [root3] = await api.getComponentInstances(payload.app);
                roots.set(payload.app, root3);
              }
              api.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n);
              instance && api.highlightElement(instance);
            }
          }
        });
        api.on.editInspectorState((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            editScope(payload, i18n);
          }
        });
        api.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: VueDevToolsLabels["vue-i18n-timeline"],
          color: VueDevToolsTimelineColors["vue-i18n-timeline"]
        });
        resolve3(true);
      });
    } catch (e2) {
      console.error(e2);
      reject(false);
    }
  });
}
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
function updateComponentTreeTags(instance, treeNode, i18n) {
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag3 = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag3);
    }
  }
}
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
function getLocaleMessageValue(messages) {
  const value = {};
  Object.keys(messages).forEach((key) => {
    const v = messages[key];
    if (isFunction(v) && "source" in v) {
      value[key] = getMessageFunctionDetails(v);
    } else if (isMessageAST(v) && v.loc && v.loc.source) {
      value[key] = v.loc.source;
    } else if (isObject2(v)) {
      value[key] = getLocaleMessageValue(v);
    } else {
      value[key] = v;
    }
  });
  return value;
}
var ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape$1(s2) {
  return s2.replace(/[<>"&]/g, escapeChar);
}
function escapeChar(a) {
  return ESC[a] || a;
}
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape$1(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span>\u0192</span> ${argString}`
    }
  };
}
function registerScope(payload, i18n) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  for (const [keyInstance, instance] of i18n.__instances) {
    const composer = i18n.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
function getComponentInstance(nodeId, i18n) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component, composer] of i18n.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }
  return instance;
}
function getComposer$1(nodeId, i18n) {
  if (nodeId === "global") {
    return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  } else {
    const instance = Array.from(i18n.__instances.values()).find((item) => item.id.toString() === nodeId);
    if (instance) {
      return i18n.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
function inspectScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
function addTimelineEvent(event, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event === "compile-error" ? "error" : event === "fallback" || event === "missing" ? "warning" : "default"
      }
    });
  }
}
function editScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    const [field] = payload.path;
    if (field === "locale" && isString(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === "fallbackLocale" && (isString(payload.state.value) || isArray(payload.state.value) || isObject2(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = exports_vue.getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options3 = this.$options;
      if (options3.i18n) {
        const optionsI18n = options3.i18n;
        if (options3.__i18n) {
          optionsI18n.__i18n = options3.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options3.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options3);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options3.__i18n,
            __injectWithOption: true,
            __extender: i18n.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options3.__i18nGlobal) {
        adjustI18nResources(composer, options3, options3);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (this.$el && this.$i18n) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = exports_vue.getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (this.$el && this.$el.__VUE_I18N__) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g2, options3) {
  g2.locale = options3.locale || g2.locale;
  g2.fallbackLocale = options3.fallbackLocale || g2.fallbackLocale;
  g2.missing = options3.missing || g2.missing;
  g2.silentTranslationWarn = options3.silentTranslationWarn || g2.silentFallbackWarn;
  g2.silentFallbackWarn = options3.silentFallbackWarn || g2.silentFallbackWarn;
  g2.formatFallbackMessages = options3.formatFallbackMessages || g2.formatFallbackMessages;
  g2.postTranslation = options3.postTranslation || g2.postTranslation;
  g2.warnHtmlInMessage = options3.warnHtmlInMessage || g2.warnHtmlInMessage;
  g2.escapeParameterHtml = options3.escapeParameterHtml || g2.escapeParameterHtml;
  g2.sync = options3.sync || g2.sync;
  g2.__composer[SetPluralRulesSymbol](options3.pluralizationRules || g2.pluralizationRules);
  const messages = getLocaleMessages(g2.locale, {
    messages: options3.messages,
    __i18n: options3.__i18n
  });
  Object.keys(messages).forEach((locale) => g2.mergeLocaleMessage(locale, messages[locale]));
  if (options3.datetimeFormats) {
    Object.keys(options3.datetimeFormats).forEach((locale) => g2.mergeDateTimeFormat(locale, options3.datetimeFormats[locale]));
  }
  if (options3.numberFormats) {
    Object.keys(options3.numberFormats).forEach((locale) => g2.mergeNumberFormat(locale, options3.numberFormats[locale]));
  }
  return g2;
}
var I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options3 = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options3.legacy) ? options3.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options3.globalInjection) ? options3.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options3.allowComposition : true;
  const __instances = new Map;
  const [globalScope, __global] = createGlobal(options3, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("vue-i18n");
  if (true) {
    if (__legacyMode && __allowComposition && true) {
      warn(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      get allowComposition() {
        return __allowComposition;
      },
      async install(app, ...options4) {
        if (true) {
          app.__VUE_I18N__ = i18n;
        }
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject(options4[0])) {
          const opts = options4[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options4);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
        if (true) {
          const ret = await enableDevTools(app, i18n);
          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      __instances,
      __getInstance,
      __setInstance,
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options3 = {}) {
  const instance = exports_vue.getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options3, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n.mode === "legacy" && !options3.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options3);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options3, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options3.__useComponent);
    if (composer2 == null) {
      if (true) {
        warn(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options3);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options3, legacyMode, VueI18nLegacy) {
  const scope = exports_vue.effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options3)) : scope.run(() => createComposer(options3));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = exports_vue.inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options3, componentOptions) {
  return isEmptyObject(options3) ? "__i18n" in componentOptions ? "local" : "global" : !options3.useScope ? "local" : options3.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root3 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root3 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  let emitter = null;
  {
    exports_vue.onMounted(() => {
      if (target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    exports_vue.onUnmounted(() => {
      const _composer = composer;
      if (target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root3, options3 = {}) {
  const isLocalScope = scope === "local";
  const _composer = exports_vue.shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : !isString(options3.locale);
  const _locale = exports_vue.ref(!isLocalScope || _inheritLocale ? root3.locale.value : isString(options3.locale) ? options3.locale : DEFAULT_LOCALE);
  const _fallbackLocale = exports_vue.ref(!isLocalScope || _inheritLocale ? root3.fallbackLocale.value : isString(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value);
  const _messages = exports_vue.ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = exports_vue.ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = exports_vue.ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root3.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root3.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root3.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const _fallbackFormat = !!options3.fallbackFormat;
  const _missing = isFunction(options3.missing) ? options3.missing : null;
  const _postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root3.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const _escapeParameter = !!options3.escapeParameter;
  const _modifiers = isLocalScope ? root3.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const _pluralRules = options3.pluralRules || isLocalScope && root3.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = exports_vue.computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = exports_vue.computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = exports_vue.computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = exports_vue.computed(() => _datetimeFormats.value);
  const numberFormats = exports_vue.computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn2) {
    trackReactivityValues();
    return fn2();
  }
  function t2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt2(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n3(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te2(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t2,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt: rt2,
    d,
    n: n3,
    tm,
    te: te2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  exports_vue.onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
var globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
var globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = exports_vue.isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile$12);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (true) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (true)
  ;
globalThis.__VUE_PROD_DEVTOOLS__ = false;
var components2 = {
  EBody,
  EHead,
  EHeading,
  EButton,
  ECodeBlock,
  ECodeInline,
  EColumn,
  EContainer,
  EFont,
  EHr,
  EHtml,
  EImg,
  ELink,
  EMarkdown,
  EPreview,
  ERow,
  ESection,
  ETailwind,
  EText
};
async function templateRender(name3, code2, options3, config3) {
  try {
    const verbose = config3?.verbose || false;
    const hasI18n = options3?.i18n?.defaultLocale || config3?.options?.i18n?.defaultLocale || options3?.i18n?.translations || config3?.options?.i18n?.translations;
    const props = options3?.props || config3?.options?.props;
    name3 = correctName(name3);
    const component = await loadComponent(name3, code2.source, verbose);
    if (verbose)
      console.warn(`${lightGreen("\uD83D\uDC8C")} ${bold2(blue("Generating output"))}`);
    if (!component)
      throw new Error(`Component ${name3} not found`);
    const app = exports_vue.createApp(component, props);
    app.use(VueEmailPlugin, config3?.options);
    if (config3 && config3.vueCompilerOptions)
      app.config.compilerOptions = config3.vueCompilerOptions;
    app.config.performance = true;
    if (code2.components && code2.components.length > 0) {
      for (const emailComponent of code2.components) {
        const componentName = correctName(emailComponent.name);
        const componentCode = await loadComponent(componentName, emailComponent.source, verbose);
        if (componentCode) {
          app.component(componentName, {
            ...componentCode,
            components: components2
          });
        }
      }
    }
    if (hasI18n) {
      const i18nOptions = {
        defaultLocale: options3?.i18n?.defaultLocale || config3?.options?.i18n?.defaultLocale || "en",
        translations: options3?.i18n?.translations || config3?.options?.i18n?.translations
      };
      const locale = i18nOptions.defaultLocale;
      if (locale) {
        if (verbose)
          console.warn(`${lightGreen("\uD83C\uDF0E")} ${bold2(blue("Injecting translations"))}`);
        const i18n = createI18n({
          locale,
          fallbackLocale: i18nOptions.defaultLocale,
          messages: i18nOptions.translations,
          silentFallbackWarn: !verbose,
          silentTranslationWarn: !verbose,
          warnHtmlInMessage: "off"
        });
        app.use(i18n);
      }
    }
    if (verbose)
      console.warn(`${lightGreen("\uD83C\uDF89")} ${bold2(blue("Rendering template"))} ${bold2(lightGreen(name3))}`);
    const markup = await renderToString2(app);
    const text = htmlToText(markup);
    const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
    const html2 = `${doctype}${cleanup(markup)}`;
    return {
      html: html2,
      text
    };
  } catch (error2) {
    throw new Error(`Error rendering template ${name3}: ${error2}`);
  }
}
function correctName(name3) {
  return pascalCase2(name3.replaceAll(":", "-").replace(".vue", ""));
}
async function loadComponent(name3, source, verbose = false) {
  try {
    name3 = correctName(name3);
    const compiledComponent = compile2(name3, source, verbose);
    const componentCode = (await x(compiledComponent)).default;
    return componentCode;
  } catch (error2) {
    console.error("Error loading component", error2);
  }
  return null;
}
function compile2(filename, source, verbose = false) {
  let styles2 = null;
  let script = null;
  const scriptIdentifier = "_sfc_main";
  if (verbose)
    console.warn(`${lightGreen("\uD83D\uDEA7")} ${bold2(blue("Compiling"))} ${bold2(lightGreen(filename))} ${bold2(blue("file"))}`);
  const { descriptor, errors: errors3 } = parse$7(source, {
    filename
  });
  if (errors3.length)
    throw new Error(errors3.join(`
`));
  if (descriptor.script || descriptor.scriptSetup) {
    script = compileScript(descriptor, {
      id: descriptor.filename,
      genDefaultAs: scriptIdentifier
    });
  }
  if (descriptor.styles && descriptor.styles.length) {
    styles2 = compileStyle({
      id: descriptor.filename,
      filename,
      source: descriptor.styles[0].content,
      scoped: descriptor.styles.some((s2) => s2.scoped)
    });
  }
  const template = compileTemplate({
    filename,
    id: descriptor.filename,
    source: descriptor.template.content,
    compilerOptions: script ? {
      bindingMetadata: script.bindings
    } : {}
  });
  const output2 = `
  ${template.code}

  ${script ? script.content : ""}
  ${styles2 ? `const styles = \`${styles2.code}\`` : ""}
  ${script ? `${scriptIdentifier}.render = render` : `const ${scriptIdentifier} = { render }`}
  ${styles2 ? `${scriptIdentifier}.style = styles` : ""}
  ${scriptIdentifier}.__file = ${JSON.stringify(descriptor.filename)}
  ${script ? `export default ${scriptIdentifier}` : `export default { render }`}
  `;
  return output2;
}
var config3 = (dir, config22 = {}) => {
  const defaultConfig = createInitConfig(config22);
  const components3 = getAllVueComponents(dir);
  return {
    render: (name3, options3) => {
      const path3 = dir ? resolve$3(dir, name3) : name3;
      const source = readFile(path3);
      return templateRender(name3, { source, components: components3 }, options3, defaultConfig);
    }
  };
};
function readFile(path3) {
  return readFileSync$1(path3, "utf-8").toString();
}
function getAllVueComponents(emailsPath, basePath = "") {
  const result2 = [];
  const files = readdirSync(emailsPath);
  files.forEach((file) => {
    const filePath = join$3(emailsPath, file);
    const relativePath = join$3(basePath, file);
    if (statSync(filePath).isDirectory()) {
      result2.push(...getAllVueComponents(filePath, relativePath));
    } else if (extname$1(file) === ".vue") {
      result2.push({
        name: relativePath.replace(/\\/g, ":"),
        source: readFileSync$1(filePath, "utf8")
      });
    }
  });
  return result2;
}

// ../email/src/template.ts
async function template(path3, options3) {
  const templatePath = path3.endsWith(".vue") ? path3 : `${path3}.vue`;
  const email = config3(resourcesPath("emails"), {
    verbose: !!process3.env.DEBUG
  });
  return await email.render(templatePath, options3);
}

// ../email/src/drivers/base.ts
import { log as log5 } from "@stacksjs/logging";

class BaseEmailDriver {
  config;
  constructor(config4) {
    this.config = {
      maxRetries: config4?.maxRetries || 3,
      retryTimeout: config4?.retryTimeout || 1000,
      ...config4
    };
  }
  configure(config4) {
    this.config = { ...this.config, ...config4 };
  }
  validateMessage(message) {
    if (!message.from?.address && !this.config.email.from?.address) {
      throw new Error("Email sender address is required either in message or config");
    }
    if (!message.to || Array.isArray(message.to) && message.to.length === 0) {
      throw new Error("At least one recipient is required");
    }
    if (!message.subject) {
      throw new Error("Email subject is required");
    }
    return true;
  }
  formatAddresses(addresses) {
    if (!addresses)
      return [];
    if (typeof addresses === "string") {
      return [addresses];
    }
    return addresses.map((addr) => {
      if (typeof addr === "string")
        return addr;
      return addr.name ? `${addr.name} <${addr.address}>` : addr.address;
    });
  }
  async handleError(error2, message) {
    const err = error2 instanceof Error ? error2 : new Error(String(error2));
    log5.error(`[${this.name}] Email sending failed`, {
      error: err.message,
      stack: err.stack,
      to: message.to,
      subject: message.subject
    });
    let result2 = {
      message: `Email sending failed: ${err.message}`,
      success: false,
      provider: this.name
    };
    if (message.onError) {
      const customResult = message.onError(err);
      const handlerResult = customResult instanceof Promise ? await customResult : customResult;
      result2 = {
        ...result2,
        ...handlerResult,
        success: false,
        provider: this.name
      };
    }
    return result2;
  }
  async handleSuccess(message, messageId) {
    let result2 = {
      message: "Email sent successfully",
      success: true,
      provider: this.name,
      messageId
    };
    try {
      if (message.handle) {
        const customResult = message.handle();
        const handlerResult = customResult instanceof Promise ? await customResult : customResult;
        result2 = {
          ...result2,
          ...handlerResult,
          success: true,
          provider: this.name,
          messageId
        };
      }
      if (message.onSuccess) {
        const successResult = message.onSuccess();
        const handlerResult = successResult instanceof Promise ? await successResult : successResult;
        result2 = {
          ...result2,
          ...handlerResult,
          success: true,
          provider: this.name,
          messageId
        };
      }
    } catch (error2) {
      return this.handleError(error2, message);
    }
    return result2;
  }
}

// ../email/src/drivers/mailgun.ts
class MailgunDriver extends BaseEmailDriver {
  name = "mailgun";
  apiKey = null;
  domain = null;
  endpoint = null;
  getConfig() {
    if (!this.apiKey || !this.domain || !this.endpoint) {
      this.apiKey = config4.services.mailgun?.apiKey ?? "";
      this.domain = config4.services.mailgun?.domain ?? "";
      this.endpoint = config4.services.mailgun?.endpoint ?? "api.mailgun.net";
    }
    return {
      apiKey: this.apiKey,
      domain: this.domain,
      endpoint: this.endpoint
    };
  }
  async send(message, options3) {
    const { domain } = this.getConfig();
    const logContext = {
      provider: this.name,
      to: message.to,
      subject: message.subject,
      domain
    };
    log6.info("Sending email via Mailgun...", logContext);
    try {
      this.validateMessage(message);
      let htmlContent;
      if (message.template) {
        const templ = await template(message.template, options3);
        if (templ && "html" in templ) {
          htmlContent = templ.html;
        }
      }
      const formData = new FormData;
      const fromAddress = {
        address: message.from?.address || config4.email.from?.address || "",
        name: message.from?.name || config4.email.from?.name
      };
      formData.append("from", this.formatMailgunAddress(fromAddress));
      this.formatMailgunAddresses(message.to).forEach((to) => formData.append("to", to));
      if (message.cc)
        this.formatMailgunAddresses(message.cc).forEach((cc2) => formData.append("cc", cc2));
      if (message.bcc)
        this.formatMailgunAddresses(message.bcc).forEach((bcc) => formData.append("bcc", bcc));
      formData.append("subject", message.subject);
      if (htmlContent) {
        formData.append("html", htmlContent);
      }
      if (message.text)
        formData.append("text", message.text);
      if (message.attachments) {
        message.attachments.forEach((attachment) => {
          const content = typeof attachment.content === "string" ? attachment.content : this.arrayBufferToBase64(attachment.content);
          formData.append("attachment", new Blob([content], { type: attachment.contentType }), attachment.filename);
        });
      }
      const response = await this.sendWithRetry(formData);
      return this.handleSuccess(message, response.id);
    } catch (error2) {
      return this.handleError(error2, message);
    }
  }
  formatMailgunAddress(address) {
    return address.name ? `${address.name} <${address.address}>` : address.address;
  }
  formatMailgunAddresses(addresses) {
    if (!addresses)
      return [];
    if (typeof addresses === "string")
      return [addresses];
    return addresses.map((addr) => {
      if (typeof addr === "string")
        return addr;
      return addr.name ? `${addr.name} <${addr.address}>` : addr.address;
    });
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes2 = new Uint8Array(buffer);
    const len = bytes2.byteLength;
    for (let i = 0;i < len; i++) {
      binary += String.fromCharCode(bytes2[i]);
    }
    return typeof btoa === "function" ? btoa(binary) : Buffer3.from(binary).toString("base64");
  }
  async sendWithRetry(formData, attempt = 1) {
    const { apiKey, domain, endpoint } = this.getConfig();
    const url = `https://${endpoint}/v3/${domain}/messages`;
    const auth = Buffer3.from(`api:${apiKey}`).toString("base64");
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Basic ${auth}`
        },
        body: formData
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Mailgun API error: ${response.status} - ${JSON.stringify(errorData)}`);
      }
      const data = await response.json();
      log6.info(`[${this.name}] Email sent successfully`, { attempt, messageId: data.id });
      return data;
    } catch (error2) {
      if (attempt < (config4.services.mailgun?.maxRetries ?? 3)) {
        const retryTimeout = config4.services.mailgun?.retryTimeout ?? 1000;
        log6.warn(`[${this.name}] Email send failed, retrying (${attempt}/${config4.services.mailgun?.maxRetries ?? 3})`);
        await new Promise((resolve3) => setTimeout(resolve3, retryTimeout));
        return this.sendWithRetry(formData, attempt + 1);
      }
      throw error2;
    }
  }
}
// ../email/src/drivers/mailtrap.ts
import { Buffer as Buffer4 } from "buffer";
import { config as config5 } from "@stacksjs/config";
import { log as log7 } from "@stacksjs/logging";
class MailtrapDriver extends BaseEmailDriver {
  name = "mailtrap";
  host = null;
  token = null;
  inboxId = null;
  getConfig() {
    if (!this.host || !this.token || !this.inboxId) {
      this.host = config5.services.mailtrap?.host ?? "https://sandbox.api.mailtrap.io/api/send";
      this.token = config5.services.mailtrap?.token ?? "";
      this.inboxId = config5.services.mailtrap?.inboxId ? Number(config5.services.mailtrap.inboxId) : undefined;
    }
    return {
      host: this.host,
      token: this.token,
      inboxId: this.inboxId
    };
  }
  async send(message, options3) {
    const { inboxId } = this.getConfig();
    const logContext = {
      provider: this.name,
      to: message.to,
      subject: message.subject,
      inboxId
    };
    log7.info("Sending email via Mailtrap...", logContext);
    try {
      this.validateMessage(message);
      let templ;
      if (message.template)
        templ = await template(message.template, options3);
      const mailtrapPayload = {
        from: {
          email: message.from?.address || config5.email.from?.address || "",
          name: message.from?.name || config5.email.from?.name
        },
        to: this.formatMailtrapAddresses(message.to),
        ...message.cc && { cc: this.formatMailtrapAddresses(message.cc) },
        ...message.bcc && { bcc: this.formatMailtrapAddresses(message.bcc) },
        subject: message.subject,
        ...templ?.html && { html: templ.html },
        ...message.text && { text: message.text },
        ...message.attachments && {
          attachments: message.attachments.map((attachment) => ({
            filename: attachment.filename,
            content: typeof attachment.content === "string" ? attachment.content : this.arrayBufferToBase64(attachment.content),
            type: attachment.contentType || "application/octet-stream"
          }))
        }
      };
      const response = await this.sendWithRetry(mailtrapPayload);
      return this.handleSuccess(message, response.message_ids?.[0]);
    } catch (error2) {
      return this.handleError(error2, message);
    }
  }
  formatMailtrapAddresses(addresses) {
    if (!addresses)
      return [];
    if (typeof addresses === "string") {
      return [{ email: addresses }];
    }
    return addresses.map((addr) => {
      if (typeof addr === "string")
        return { email: addr };
      return { email: addr.address, ...addr.name && { name: addr.name } };
    });
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes2 = new Uint8Array(buffer);
    const len = bytes2.byteLength;
    for (let i = 0;i < len; i++) {
      binary += String.fromCharCode(bytes2[i]);
    }
    return typeof btoa === "function" ? btoa(binary) : Buffer4.from(binary).toString("base64");
  }
  async sendWithRetry(payload, attempt = 1) {
    const { host, token: token2, inboxId } = this.getConfig();
    if (!inboxId) {
      throw new Error("Mailtrap inbox ID is required but not provided. Please set MAILTRAP_INBOX_ID in your environment variables.");
    }
    const endpoint = `${host}/${inboxId}`;
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Mailtrap API error: ${response.status} - ${JSON.stringify(errorData)}`);
      }
      const data = await response.json();
      log7.info(`[${this.name}] Email sent successfully`, { attempt, messageId: data.message_ids?.[0] });
      return data;
    } catch (error2) {
      if (attempt < (config5.services.mailtrap?.maxRetries ?? 3)) {
        const retryTimeout = config5.services.mailtrap?.retryTimeout ?? 1000;
        log7.warn(`[${this.name}] Email send failed, retrying (${attempt}/${config5.services.mailtrap?.maxRetries ?? 3})`);
        await new Promise((resolve3) => setTimeout(resolve3, retryTimeout));
        return this.sendWithRetry(payload, attempt + 1);
      }
      throw error2;
    }
  }
}
// ../email/src/drivers/sendgrid.ts
import { Buffer as Buffer5 } from "buffer";
import { config as config6 } from "@stacksjs/config";
import { log as log8 } from "@stacksjs/logging";
class SendGridDriver extends BaseEmailDriver {
  name = "sendgrid";
  apiKey = null;
  getApiKey() {
    if (!this.apiKey) {
      this.apiKey = config6.services.sendgrid?.apiKey ?? "";
    }
    return this.apiKey;
  }
  async send(message, options3) {
    const logContext = {
      provider: this.name,
      to: message.to,
      subject: message.subject
    };
    log8.info("Sending email via SendGrid...", logContext);
    try {
      this.validateMessage(message);
      let htmlContent;
      if (message.template) {
        const templ = await template(message.template, options3);
        if (templ && "html" in templ) {
          htmlContent = templ.html;
        }
      }
      const content = [];
      if (htmlContent) {
        content.push({
          type: "text/html",
          value: htmlContent
        });
      }
      if (message.text) {
        content.push({
          type: "text/plain",
          value: message.text
        });
      }
      if (content.length === 0) {
        throw new Error("Email must have either HTML or text content");
      }
      const sendgridPayload = {
        personalizations: [
          {
            to: this.formatSendGridAddresses(message.to),
            ...message.cc && { cc: this.formatSendGridAddresses(message.cc) },
            ...message.bcc && { bcc: this.formatSendGridAddresses(message.bcc) },
            subject: message.subject
          }
        ],
        from: {
          email: message.from?.address || config6.email.from?.address || "",
          name: message.from?.name || config6.email.from?.name
        },
        content,
        ...message.attachments && {
          attachments: message.attachments.map((attachment) => ({
            filename: attachment.filename,
            content: typeof attachment.content === "string" ? attachment.content : this.arrayBufferToBase64(attachment.content),
            type: attachment.contentType,
            disposition: "attachment"
          }))
        }
      };
      const response = await this.sendWithRetry(sendgridPayload);
      return this.handleSuccess(message, response.headers?.["x-message-id"]);
    } catch (error2) {
      return this.handleError(error2, message);
    }
  }
  formatSendGridAddresses(addresses) {
    if (!addresses)
      return [];
    if (typeof addresses === "string") {
      return [{ email: addresses }];
    }
    return addresses.map((addr) => {
      if (typeof addr === "string")
        return { email: addr };
      return { email: addr.address, ...addr.name && { name: addr.name } };
    });
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes2 = new Uint8Array(buffer);
    const len = bytes2.byteLength;
    for (let i = 0;i < len; i++) {
      binary += String.fromCharCode(bytes2[i]);
    }
    return typeof btoa === "function" ? btoa(binary) : Buffer5.from(binary).toString("base64");
  }
  async sendWithRetry(payload, attempt = 1) {
    try {
      const response = await fetch("https://api.sendgrid.com/v3/mail/send", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${this.getApiKey()}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`SendGrid API error: ${response.status} - ${JSON.stringify(errorData)}`);
      }
      log8.info(`[${this.name}] Email sent successfully`, { attempt });
      return response;
    } catch (error2) {
      if (attempt < (config6.services.sendgrid?.maxRetries ?? 3)) {
        const retryTimeout = config6.services.sendgrid?.retryTimeout ?? 1000;
        log8.warn(`[${this.name}] Email send failed, retrying (${attempt}/${config6.services.sendgrid?.maxRetries ?? 3})`);
        await new Promise((resolve3) => setTimeout(resolve3, retryTimeout));
        return this.sendWithRetry(payload, attempt + 1);
      }
      throw error2;
    }
  }
}
// ../../../../node_modules/@aws-sdk/client-ses/dist-es/SESClient.js
var import_core4 = __toESM(require_dist_cjs(), 1);

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/auth/httpAuthSchemeProvider.js
var import_core = __toESM(require_dist_cjs3(), 1);
var defaultSESHttpAuthSchemeParametersProvider = async (config7, context, input2) => {
  return {
    operation: getSmithyContext(context).operation,
    region: await normalizeProvider(config7.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "ses",
      region: authParameters.region
    },
    propertiesExtractor: (config7, context) => ({
      signingProperties: {
        config: config7,
        context
      }
    })
  };
}
var defaultSESHttpAuthSchemeProvider = (authParameters) => {
  const options3 = [];
  switch (authParameters.operation) {
    default: {
      options3.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options3;
};
var resolveHttpAuthSchemeConfig = (config7) => {
  const config_0 = import_core.resolveAwsSdkSigV4Config(config7);
  return Object.assign(config_0, {
    authSchemePreference: normalizeProvider(config7.authSchemePreference ?? [])
  });
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options3) => {
  return Object.assign(options3, {
    useDualstackEndpoint: options3.useDualstackEndpoint ?? false,
    useFipsEndpoint: options3.useFipsEndpoint ?? false,
    defaultSigningName: "ses"
  });
};
var commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
// ../../../../node_modules/@aws-sdk/client-ses/package.json
var package_default = {
  name: "@aws-sdk/client-ses",
  description: "AWS SDK for JavaScript Ses Client for Node.js, Browser and React Native",
  version: "3.835.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-ses",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo ses"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.835.0",
    "@aws-sdk/credential-provider-node": "3.835.0",
    "@aws-sdk/middleware-host-header": "3.821.0",
    "@aws-sdk/middleware-logger": "3.821.0",
    "@aws-sdk/middleware-recursion-detection": "3.821.0",
    "@aws-sdk/middleware-user-agent": "3.835.0",
    "@aws-sdk/region-config-resolver": "3.821.0",
    "@aws-sdk/types": "3.821.0",
    "@aws-sdk/util-endpoints": "3.828.0",
    "@aws-sdk/util-user-agent-browser": "3.821.0",
    "@aws-sdk/util-user-agent-node": "3.835.0",
    "@smithy/config-resolver": "^4.1.4",
    "@smithy/core": "^3.5.3",
    "@smithy/fetch-http-handler": "^5.0.4",
    "@smithy/hash-node": "^4.0.4",
    "@smithy/invalid-dependency": "^4.0.4",
    "@smithy/middleware-content-length": "^4.0.4",
    "@smithy/middleware-endpoint": "^4.1.12",
    "@smithy/middleware-retry": "^4.1.13",
    "@smithy/middleware-serde": "^4.0.8",
    "@smithy/middleware-stack": "^4.0.4",
    "@smithy/node-config-provider": "^4.1.3",
    "@smithy/node-http-handler": "^4.0.6",
    "@smithy/protocol-http": "^5.1.2",
    "@smithy/smithy-client": "^4.4.4",
    "@smithy/types": "^4.3.1",
    "@smithy/url-parser": "^4.0.4",
    "@smithy/util-base64": "^4.0.0",
    "@smithy/util-body-length-browser": "^4.0.0",
    "@smithy/util-body-length-node": "^4.0.0",
    "@smithy/util-defaults-mode-browser": "^4.0.20",
    "@smithy/util-defaults-mode-node": "^4.0.20",
    "@smithy/util-endpoints": "^3.0.6",
    "@smithy/util-middleware": "^4.0.4",
    "@smithy/util-retry": "^4.0.6",
    "@smithy/util-utf8": "^4.0.0",
    "@smithy/util-waiter": "^4.0.5",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~5.8.3"
  },
  engines: {
    node: ">=18.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ses",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-ses"
  }
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/runtimeConfig.js
var import_core3 = __toESM(require_dist_cjs3(), 1);

// ../../../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var import_property_provider2 = __toESM(require_dist_cjs2(), 1);

// ../../../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var import_property_provider = __toESM(require_dist_cjs2(), 1);
var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
var remoteProvider = async (init2) => {
  const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await import("./chunk-mgjy4dwe.js");
  if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
    init2.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
    const { fromHttp } = await import("./chunk-5rv9pvew.js");
    return import_property_provider.chain(fromHttp(init2), fromContainerMetadata(init2));
  }
  if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
    return async () => {
      throw new import_property_provider.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init2.logger });
    };
  }
  init2.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
  return fromInstanceMetadata(init2);
};

// ../../../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var multipleCredentialSourceWarningEmitted = false;
var defaultProvider = (init2 = {}) => import_property_provider2.memoize(import_property_provider2.chain(async () => {
  const profile = init2.profile ?? process.env[ENV_PROFILE];
  if (profile) {
    const envStaticCredentialsAreSet = process.env[ENV_KEY] && process.env[ENV_SECRET];
    if (envStaticCredentialsAreSet) {
      if (!multipleCredentialSourceWarningEmitted) {
        const warnFn = init2.logger?.warn && init2.logger?.constructor?.name !== "NoOpLogger" ? init2.logger.warn : console.warn;
        warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
        multipleCredentialSourceWarningEmitted = true;
      }
    }
    throw new import_property_provider2.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
      logger: init2.logger,
      tryNextLink: true
    });
  }
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
  return fromEnv(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init2;
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    throw new import_property_provider2.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init2.logger });
  }
  const { fromSSO } = await import("./chunk-h3w05fx3.js");
  return fromSSO(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
  const { fromIni } = await import("./chunk-w57b764x.js");
  return fromIni(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
  const { fromProcess } = await import("./chunk-m7ygbbgr.js");
  return fromProcess(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
  const { fromTokenFile } = await import("./chunk-2ea0xrr4.js");
  return fromTokenFile(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
  return (await remoteProvider(init2))();
}, async () => {
  throw new import_property_provider2.CredentialsProviderError("Could not load credentials from any providers", {
    tryNextLink: false,
    logger: init2.logger
  });
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh);
var credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
var credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;
// ../../../../node_modules/@aws-sdk/client-ses/dist-es/runtimeConfig.shared.js
var import_core2 = __toESM(require_dist_cjs3(), 1);

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/endpoint/ruleset.js
var s2 = "required";
var t2 = "fn";
var u = "argv";
var v = "ref";
var a = true;
var b = "isSet";
var c3 = "booleanEquals";
var d = "error";
var e2 = "endpoint";
var f = "tree";
var g2 = "PartitionResult";
var h9 = { [s2]: false, type: "String" };
var i = { [s2]: true, default: false, type: "Boolean" };
var j = { [v]: "Endpoint" };
var k2 = { [t2]: c3, [u]: [{ [v]: "UseFIPS" }, true] };
var l2 = { [t2]: c3, [u]: [{ [v]: "UseDualStack" }, true] };
var m2 = {};
var n3 = { [t2]: "getAttr", [u]: [{ [v]: g2 }, "supportsFIPS"] };
var o2 = { [t2]: c3, [u]: [true, { [t2]: "getAttr", [u]: [{ [v]: g2 }, "supportsDualStack"] }] };
var p2 = [k2];
var q = [l2];
var r3 = [{ [v]: "Region" }];
var _data = { version: "1.0", parameters: { Region: h9, UseDualStack: i, UseFIPS: i, Endpoint: h9 }, rules: [{ conditions: [{ [t2]: b, [u]: [j] }], rules: [{ conditions: p2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: j, properties: m2, headers: m2 }, type: e2 }], type: f }, { conditions: [{ [t2]: b, [u]: r3 }], rules: [{ conditions: [{ [t2]: "aws.partition", [u]: r3, assign: g2 }], rules: [{ conditions: [k2, l2], rules: [{ conditions: [{ [t2]: c3, [u]: [a, n3] }, o2], rules: [{ endpoint: { url: "https://email-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m2, headers: m2 }, type: e2 }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: p2, rules: [{ conditions: [{ [t2]: c3, [u]: [n3, a] }], rules: [{ endpoint: { url: "https://email-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m2, headers: m2 }, type: e2 }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: q, rules: [{ conditions: [o2], rules: [{ endpoint: { url: "https://email.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m2, headers: m2 }, type: e2 }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://email.{Region}.{PartitionResult#dnsSuffix}", properties: m2, headers: m2 }, type: e2 }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
var ruleSet = _data;

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/endpoint/endpointResolver.js
var cache2 = new EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
});
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return cache2.get(endpointParams, () => resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config7) => {
  return {
    apiVersion: "2010-12-01",
    base64Decoder: config7?.base64Decoder ?? fromBase64,
    base64Encoder: config7?.base64Encoder ?? toBase64,
    disableHostPrefix: config7?.disableHostPrefix ?? false,
    endpointProvider: config7?.endpointProvider ?? defaultEndpointResolver,
    extensions: config7?.extensions ?? [],
    httpAuthSchemeProvider: config7?.httpAuthSchemeProvider ?? defaultSESHttpAuthSchemeProvider,
    httpAuthSchemes: config7?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core2.AwsSdkSigV4Signer
      }
    ],
    logger: config7?.logger ?? new NoOpLogger,
    serviceId: config7?.serviceId ?? "SES",
    urlParser: config7?.urlParser ?? parseUrl,
    utf8Decoder: config7?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config7?.utf8Encoder ?? toUtf8
  };
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/runtimeConfig.js
var getRuntimeConfig2 = (config7) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config7);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config7);
  import_core3.emitWarningIfUnsupportedVersion(process.version);
  const loaderConfig = {
    profile: config7?.profile,
    logger: clientSharedValues.logger
  };
  return {
    ...clientSharedValues,
    ...config7,
    runtime: "node",
    defaultsMode,
    authSchemePreference: config7?.authSchemePreference ?? loadConfig(import_core3.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
    bodyLengthChecker: config7?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config7?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config7?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    maxAttempts: config7?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config7),
    region: config7?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, { ...NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
    requestHandler: NodeHttpHandler.create(config7?.requestHandler ?? defaultConfigProvider),
    retryMode: config7?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }, config7),
    sha256: config7?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config7?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config7?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    useFipsEndpoint: config7?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    userAgentAppId: config7?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
  };
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig = (config7) => {
  return {
    httpAuthSchemes: config7.httpAuthSchemes(),
    httpAuthSchemeProvider: config7.httpAuthSchemeProvider(),
    credentials: config7.credentials()
  };
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/runtimeExtensions.js
var resolveRuntimeExtensions = (runtimeConfig, extensions2) => {
  const extensionConfiguration = Object.assign(getAwsRegionExtensionConfiguration(runtimeConfig), getDefaultExtensionConfiguration(runtimeConfig), getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
  extensions2.forEach((extension2) => extension2.configure(extensionConfiguration));
  return Object.assign(runtimeConfig, resolveAwsRegionExtensionConfiguration(extensionConfiguration), resolveDefaultRuntimeConfig(extensionConfiguration), resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/SESClient.js
class SESClient extends Client {
  config;
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    super(_config_0);
    this.initConfig = _config_0;
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveRetryConfig(_config_2);
    const _config_4 = resolveRegionConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveEndpointConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
    this.config = _config_8;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(import_core4.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultSESHttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config7) => new import_core4.DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config7.credentials
      })
    }));
    this.middlewareStack.use(import_core4.getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/protocols/Aws_query.js
var import_core5 = __toESM(require_dist_cjs3(), 1);

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/models/SESServiceException.js
class SESServiceException extends ServiceException {
  constructor(options3) {
    super(options3);
    Object.setPrototypeOf(this, SESServiceException.prototype);
  }
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/models/models_0.js
class AccountSendingPausedException extends SESServiceException {
  name = "AccountSendingPausedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "AccountSendingPausedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, AccountSendingPausedException.prototype);
  }
}

class AlreadyExistsException extends SESServiceException {
  name = "AlreadyExistsException";
  $fault = "client";
  Name;
  constructor(opts) {
    super({
      name: "AlreadyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, AlreadyExistsException.prototype);
    this.Name = opts.Name;
  }
}
class CannotDeleteException extends SESServiceException {
  name = "CannotDeleteException";
  $fault = "client";
  Name;
  constructor(opts) {
    super({
      name: "CannotDeleteException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CannotDeleteException.prototype);
    this.Name = opts.Name;
  }
}

class LimitExceededException extends SESServiceException {
  name = "LimitExceededException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, LimitExceededException.prototype);
  }
}

class RuleSetDoesNotExistException extends SESServiceException {
  name = "RuleSetDoesNotExistException";
  $fault = "client";
  Name;
  constructor(opts) {
    super({
      name: "RuleSetDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, RuleSetDoesNotExistException.prototype);
    this.Name = opts.Name;
  }
}
class ConfigurationSetAlreadyExistsException extends SESServiceException {
  name = "ConfigurationSetAlreadyExistsException";
  $fault = "client";
  ConfigurationSetName;
  constructor(opts) {
    super({
      name: "ConfigurationSetAlreadyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ConfigurationSetAlreadyExistsException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
  }
}
class ConfigurationSetDoesNotExistException extends SESServiceException {
  name = "ConfigurationSetDoesNotExistException";
  $fault = "client";
  ConfigurationSetName;
  constructor(opts) {
    super({
      name: "ConfigurationSetDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ConfigurationSetDoesNotExistException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
  }
}

class ConfigurationSetSendingPausedException extends SESServiceException {
  name = "ConfigurationSetSendingPausedException";
  $fault = "client";
  ConfigurationSetName;
  constructor(opts) {
    super({
      name: "ConfigurationSetSendingPausedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ConfigurationSetSendingPausedException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
  }
}

class InvalidConfigurationSetException extends SESServiceException {
  name = "InvalidConfigurationSetException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidConfigurationSetException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidConfigurationSetException.prototype);
  }
}
class EventDestinationAlreadyExistsException extends SESServiceException {
  name = "EventDestinationAlreadyExistsException";
  $fault = "client";
  ConfigurationSetName;
  EventDestinationName;
  constructor(opts) {
    super({
      name: "EventDestinationAlreadyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, EventDestinationAlreadyExistsException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
    this.EventDestinationName = opts.EventDestinationName;
  }
}

class InvalidCloudWatchDestinationException extends SESServiceException {
  name = "InvalidCloudWatchDestinationException";
  $fault = "client";
  ConfigurationSetName;
  EventDestinationName;
  constructor(opts) {
    super({
      name: "InvalidCloudWatchDestinationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidCloudWatchDestinationException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
    this.EventDestinationName = opts.EventDestinationName;
  }
}

class InvalidFirehoseDestinationException extends SESServiceException {
  name = "InvalidFirehoseDestinationException";
  $fault = "client";
  ConfigurationSetName;
  EventDestinationName;
  constructor(opts) {
    super({
      name: "InvalidFirehoseDestinationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidFirehoseDestinationException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
    this.EventDestinationName = opts.EventDestinationName;
  }
}

class InvalidSNSDestinationException extends SESServiceException {
  name = "InvalidSNSDestinationException";
  $fault = "client";
  ConfigurationSetName;
  EventDestinationName;
  constructor(opts) {
    super({
      name: "InvalidSNSDestinationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidSNSDestinationException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
    this.EventDestinationName = opts.EventDestinationName;
  }
}

class InvalidTrackingOptionsException extends SESServiceException {
  name = "InvalidTrackingOptionsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidTrackingOptionsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidTrackingOptionsException.prototype);
  }
}

class TrackingOptionsAlreadyExistsException extends SESServiceException {
  name = "TrackingOptionsAlreadyExistsException";
  $fault = "client";
  ConfigurationSetName;
  constructor(opts) {
    super({
      name: "TrackingOptionsAlreadyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TrackingOptionsAlreadyExistsException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
  }
}

class CustomVerificationEmailInvalidContentException extends SESServiceException {
  name = "CustomVerificationEmailInvalidContentException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "CustomVerificationEmailInvalidContentException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CustomVerificationEmailInvalidContentException.prototype);
  }
}

class CustomVerificationEmailTemplateAlreadyExistsException extends SESServiceException {
  name = "CustomVerificationEmailTemplateAlreadyExistsException";
  $fault = "client";
  CustomVerificationEmailTemplateName;
  constructor(opts) {
    super({
      name: "CustomVerificationEmailTemplateAlreadyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CustomVerificationEmailTemplateAlreadyExistsException.prototype);
    this.CustomVerificationEmailTemplateName = opts.CustomVerificationEmailTemplateName;
  }
}

class FromEmailAddressNotVerifiedException extends SESServiceException {
  name = "FromEmailAddressNotVerifiedException";
  $fault = "client";
  FromEmailAddress;
  constructor(opts) {
    super({
      name: "FromEmailAddressNotVerifiedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, FromEmailAddressNotVerifiedException.prototype);
    this.FromEmailAddress = opts.FromEmailAddress;
  }
}
class InvalidLambdaFunctionException extends SESServiceException {
  name = "InvalidLambdaFunctionException";
  $fault = "client";
  FunctionArn;
  constructor(opts) {
    super({
      name: "InvalidLambdaFunctionException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidLambdaFunctionException.prototype);
    this.FunctionArn = opts.FunctionArn;
  }
}

class InvalidS3ConfigurationException extends SESServiceException {
  name = "InvalidS3ConfigurationException";
  $fault = "client";
  Bucket;
  constructor(opts) {
    super({
      name: "InvalidS3ConfigurationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidS3ConfigurationException.prototype);
    this.Bucket = opts.Bucket;
  }
}

class InvalidSnsTopicException extends SESServiceException {
  name = "InvalidSnsTopicException";
  $fault = "client";
  Topic;
  constructor(opts) {
    super({
      name: "InvalidSnsTopicException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidSnsTopicException.prototype);
    this.Topic = opts.Topic;
  }
}

class RuleDoesNotExistException extends SESServiceException {
  name = "RuleDoesNotExistException";
  $fault = "client";
  Name;
  constructor(opts) {
    super({
      name: "RuleDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, RuleDoesNotExistException.prototype);
    this.Name = opts.Name;
  }
}

class InvalidTemplateException extends SESServiceException {
  name = "InvalidTemplateException";
  $fault = "client";
  TemplateName;
  constructor(opts) {
    super({
      name: "InvalidTemplateException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidTemplateException.prototype);
    this.TemplateName = opts.TemplateName;
  }
}
class CustomVerificationEmailTemplateDoesNotExistException extends SESServiceException {
  name = "CustomVerificationEmailTemplateDoesNotExistException";
  $fault = "client";
  CustomVerificationEmailTemplateName;
  constructor(opts) {
    super({
      name: "CustomVerificationEmailTemplateDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CustomVerificationEmailTemplateDoesNotExistException.prototype);
    this.CustomVerificationEmailTemplateName = opts.CustomVerificationEmailTemplateName;
  }
}

class EventDestinationDoesNotExistException extends SESServiceException {
  name = "EventDestinationDoesNotExistException";
  $fault = "client";
  ConfigurationSetName;
  EventDestinationName;
  constructor(opts) {
    super({
      name: "EventDestinationDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, EventDestinationDoesNotExistException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
    this.EventDestinationName = opts.EventDestinationName;
  }
}

class TrackingOptionsDoesNotExistException extends SESServiceException {
  name = "TrackingOptionsDoesNotExistException";
  $fault = "client";
  ConfigurationSetName;
  constructor(opts) {
    super({
      name: "TrackingOptionsDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TrackingOptionsDoesNotExistException.prototype);
    this.ConfigurationSetName = opts.ConfigurationSetName;
  }
}
class TemplateDoesNotExistException extends SESServiceException {
  name = "TemplateDoesNotExistException";
  $fault = "client";
  TemplateName;
  constructor(opts) {
    super({
      name: "TemplateDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TemplateDoesNotExistException.prototype);
    this.TemplateName = opts.TemplateName;
  }
}
class InvalidDeliveryOptionsException extends SESServiceException {
  name = "InvalidDeliveryOptionsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidDeliveryOptionsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidDeliveryOptionsException.prototype);
  }
}

class InvalidPolicyException extends SESServiceException {
  name = "InvalidPolicyException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidPolicyException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidPolicyException.prototype);
  }
}

class InvalidRenderingParameterException extends SESServiceException {
  name = "InvalidRenderingParameterException";
  $fault = "client";
  TemplateName;
  constructor(opts) {
    super({
      name: "InvalidRenderingParameterException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidRenderingParameterException.prototype);
    this.TemplateName = opts.TemplateName;
  }
}

class MailFromDomainNotVerifiedException extends SESServiceException {
  name = "MailFromDomainNotVerifiedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "MailFromDomainNotVerifiedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, MailFromDomainNotVerifiedException.prototype);
  }
}

class MessageRejected extends SESServiceException {
  name = "MessageRejected";
  $fault = "client";
  constructor(opts) {
    super({
      name: "MessageRejected",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, MessageRejected.prototype);
  }
}

class MissingRenderingAttributeException extends SESServiceException {
  name = "MissingRenderingAttributeException";
  $fault = "client";
  TemplateName;
  constructor(opts) {
    super({
      name: "MissingRenderingAttributeException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, MissingRenderingAttributeException.prototype);
    this.TemplateName = opts.TemplateName;
  }
}
class ProductionAccessNotGrantedException extends SESServiceException {
  name = "ProductionAccessNotGrantedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ProductionAccessNotGrantedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ProductionAccessNotGrantedException.prototype);
  }
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/protocols/Aws_query.js
var se_CloneReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CloneReceiptRuleSetRequest(input2, context),
    [_A]: _CRRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateConfigurationSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateConfigurationSetRequest(input2, context),
    [_A]: _CCS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateConfigurationSetEventDestinationCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateConfigurationSetEventDestinationRequest(input2, context),
    [_A]: _CCSED,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateConfigurationSetTrackingOptionsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateConfigurationSetTrackingOptionsRequest(input2, context),
    [_A]: _CCSTO,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateCustomVerificationEmailTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateCustomVerificationEmailTemplateRequest(input2, context),
    [_A]: _CCVET,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateReceiptFilterCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateReceiptFilterRequest(input2, context),
    [_A]: _CRF,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateReceiptRuleCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateReceiptRuleRequest(input2, context),
    [_A]: _CRR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateReceiptRuleSetRequest(input2, context),
    [_A]: _CRRSr,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_CreateTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_CreateTemplateRequest(input2, context),
    [_A]: _CT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteConfigurationSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteConfigurationSetRequest(input2, context),
    [_A]: _DCS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteConfigurationSetEventDestinationCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteConfigurationSetEventDestinationRequest(input2, context),
    [_A]: _DCSED,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteConfigurationSetTrackingOptionsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteConfigurationSetTrackingOptionsRequest(input2, context),
    [_A]: _DCSTO,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteCustomVerificationEmailTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteCustomVerificationEmailTemplateRequest(input2, context),
    [_A]: _DCVET,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteIdentityCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteIdentityRequest(input2, context),
    [_A]: _DI,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteIdentityPolicyCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteIdentityPolicyRequest(input2, context),
    [_A]: _DIP,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteReceiptFilterCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteReceiptFilterRequest(input2, context),
    [_A]: _DRF,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteReceiptRuleCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteReceiptRuleRequest(input2, context),
    [_A]: _DRR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteReceiptRuleSetRequest(input2, context),
    [_A]: _DRRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteTemplateRequest(input2, context),
    [_A]: _DT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DeleteVerifiedEmailAddressCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteVerifiedEmailAddressRequest(input2, context),
    [_A]: _DVEA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DescribeActiveReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeActiveReceiptRuleSetRequest(input2, context),
    [_A]: _DARRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DescribeConfigurationSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeConfigurationSetRequest(input2, context),
    [_A]: _DCSe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DescribeReceiptRuleCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeReceiptRuleRequest(input2, context),
    [_A]: _DRRe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_DescribeReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeReceiptRuleSetRequest(input2, context),
    [_A]: _DRRSe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetAccountSendingEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  const body = buildFormUrlencodedString({
    [_A]: _GASE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetCustomVerificationEmailTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetCustomVerificationEmailTemplateRequest(input2, context),
    [_A]: _GCVET,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetIdentityDkimAttributesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetIdentityDkimAttributesRequest(input2, context),
    [_A]: _GIDA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetIdentityMailFromDomainAttributesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetIdentityMailFromDomainAttributesRequest(input2, context),
    [_A]: _GIMFDA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetIdentityNotificationAttributesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetIdentityNotificationAttributesRequest(input2, context),
    [_A]: _GINA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetIdentityPoliciesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetIdentityPoliciesRequest(input2, context),
    [_A]: _GIP,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetIdentityVerificationAttributesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetIdentityVerificationAttributesRequest(input2, context),
    [_A]: _GIVA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetSendQuotaCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  const body = buildFormUrlencodedString({
    [_A]: _GSQ,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetSendStatisticsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  const body = buildFormUrlencodedString({
    [_A]: _GSS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_GetTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetTemplateRequest(input2, context),
    [_A]: _GT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListConfigurationSetsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListConfigurationSetsRequest(input2, context),
    [_A]: _LCS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListCustomVerificationEmailTemplatesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListCustomVerificationEmailTemplatesRequest(input2, context),
    [_A]: _LCVET,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListIdentitiesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListIdentitiesRequest(input2, context),
    [_A]: _LI,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListIdentityPoliciesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListIdentityPoliciesRequest(input2, context),
    [_A]: _LIP,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListReceiptFiltersCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListReceiptFiltersRequest(input2, context),
    [_A]: _LRF,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListReceiptRuleSetsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListReceiptRuleSetsRequest(input2, context),
    [_A]: _LRRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListTemplatesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListTemplatesRequest(input2, context),
    [_A]: _LT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ListVerifiedEmailAddressesCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  const body = buildFormUrlencodedString({
    [_A]: _LVEA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_PutConfigurationSetDeliveryOptionsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutConfigurationSetDeliveryOptionsRequest(input2, context),
    [_A]: _PCSDO,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_PutIdentityPolicyCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutIdentityPolicyRequest(input2, context),
    [_A]: _PIP,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_ReorderReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ReorderReceiptRuleSetRequest(input2, context),
    [_A]: _RRRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendBounceCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendBounceRequest(input2, context),
    [_A]: _SB,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendBulkTemplatedEmailCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendBulkTemplatedEmailRequest(input2, context),
    [_A]: _SBTE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendCustomVerificationEmailCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendCustomVerificationEmailRequest(input2, context),
    [_A]: _SCVE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendEmailCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendEmailRequest(input2, context),
    [_A]: _SE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendRawEmailCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendRawEmailRequest(input2, context),
    [_A]: _SRE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SendTemplatedEmailCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SendTemplatedEmailRequest(input2, context),
    [_A]: _STE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetActiveReceiptRuleSetCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetActiveReceiptRuleSetRequest(input2, context),
    [_A]: _SARRS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetIdentityDkimEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetIdentityDkimEnabledRequest(input2, context),
    [_A]: _SIDE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetIdentityFeedbackForwardingEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetIdentityFeedbackForwardingEnabledRequest(input2, context),
    [_A]: _SIFFE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetIdentityHeadersInNotificationsEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetIdentityHeadersInNotificationsEnabledRequest(input2, context),
    [_A]: _SIHINE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetIdentityMailFromDomainCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetIdentityMailFromDomainRequest(input2, context),
    [_A]: _SIMFD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetIdentityNotificationTopicCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetIdentityNotificationTopicRequest(input2, context),
    [_A]: _SINT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_SetReceiptRulePositionCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetReceiptRulePositionRequest(input2, context),
    [_A]: _SRRP,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_TestRenderTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_TestRenderTemplateRequest(input2, context),
    [_A]: _TRT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateAccountSendingEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateAccountSendingEnabledRequest(input2, context),
    [_A]: _UASE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateConfigurationSetEventDestinationCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateConfigurationSetEventDestinationRequest(input2, context),
    [_A]: _UCSED,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateConfigurationSetReputationMetricsEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateConfigurationSetReputationMetricsEnabledRequest(input2, context),
    [_A]: _UCSRME,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateConfigurationSetSendingEnabledCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateConfigurationSetSendingEnabledRequest(input2, context),
    [_A]: _UCSSE,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateConfigurationSetTrackingOptionsCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateConfigurationSetTrackingOptionsRequest(input2, context),
    [_A]: _UCSTO,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateCustomVerificationEmailTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateCustomVerificationEmailTemplateRequest(input2, context),
    [_A]: _UCVET,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateReceiptRuleCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateReceiptRuleRequest(input2, context),
    [_A]: _URR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_UpdateTemplateCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UpdateTemplateRequest(input2, context),
    [_A]: _UT,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_VerifyDomainDkimCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_VerifyDomainDkimRequest(input2, context),
    [_A]: _VDD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_VerifyDomainIdentityCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_VerifyDomainIdentityRequest(input2, context),
    [_A]: _VDI,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_VerifyEmailAddressCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_VerifyEmailAddressRequest(input2, context),
    [_A]: _VEA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var se_VerifyEmailIdentityCommand = async (input2, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_VerifyEmailIdentityRequest(input2, context),
    [_A]: _VEI,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
var de_CloneReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CloneReceiptRuleSetResponse(data.CloneReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateConfigurationSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateConfigurationSetResponse(data.CreateConfigurationSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateConfigurationSetEventDestinationCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateConfigurationSetEventDestinationResponse(data.CreateConfigurationSetEventDestinationResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateConfigurationSetTrackingOptionsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateConfigurationSetTrackingOptionsResponse(data.CreateConfigurationSetTrackingOptionsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateCustomVerificationEmailTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_CreateReceiptFilterCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateReceiptFilterResponse(data.CreateReceiptFilterResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateReceiptRuleCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateReceiptRuleResponse(data.CreateReceiptRuleResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateReceiptRuleSetResponse(data.CreateReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CreateTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_CreateTemplateResponse(data.CreateTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteConfigurationSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteConfigurationSetResponse(data.DeleteConfigurationSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteConfigurationSetEventDestinationCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteConfigurationSetEventDestinationResponse(data.DeleteConfigurationSetEventDestinationResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteConfigurationSetTrackingOptionsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteConfigurationSetTrackingOptionsResponse(data.DeleteConfigurationSetTrackingOptionsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteCustomVerificationEmailTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_DeleteIdentityCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteIdentityResponse(data.DeleteIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteIdentityPolicyCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteIdentityPolicyResponse(data.DeleteIdentityPolicyResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteReceiptFilterCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteReceiptFilterResponse(data.DeleteReceiptFilterResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteReceiptRuleCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteReceiptRuleResponse(data.DeleteReceiptRuleResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteReceiptRuleSetResponse(data.DeleteReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DeleteTemplateResponse(data.DeleteTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DeleteVerifiedEmailAddressCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_DescribeActiveReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DescribeActiveReceiptRuleSetResponse(data.DescribeActiveReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DescribeConfigurationSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DescribeConfigurationSetResponse(data.DescribeConfigurationSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DescribeReceiptRuleCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DescribeReceiptRuleResponse(data.DescribeReceiptRuleResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_DescribeReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_DescribeReceiptRuleSetResponse(data.DescribeReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetAccountSendingEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetAccountSendingEnabledResponse(data.GetAccountSendingEnabledResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetCustomVerificationEmailTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetCustomVerificationEmailTemplateResponse(data.GetCustomVerificationEmailTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetIdentityDkimAttributesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetIdentityDkimAttributesResponse(data.GetIdentityDkimAttributesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetIdentityMailFromDomainAttributesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetIdentityMailFromDomainAttributesResponse(data.GetIdentityMailFromDomainAttributesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetIdentityNotificationAttributesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetIdentityNotificationAttributesResponse(data.GetIdentityNotificationAttributesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetIdentityPoliciesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetIdentityPoliciesResponse(data.GetIdentityPoliciesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetIdentityVerificationAttributesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetIdentityVerificationAttributesResponse(data.GetIdentityVerificationAttributesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetSendQuotaCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetSendQuotaResponse(data.GetSendQuotaResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetSendStatisticsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetSendStatisticsResponse(data.GetSendStatisticsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_GetTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_GetTemplateResponse(data.GetTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListConfigurationSetsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListConfigurationSetsResponse(data.ListConfigurationSetsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListCustomVerificationEmailTemplatesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListCustomVerificationEmailTemplatesResponse(data.ListCustomVerificationEmailTemplatesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListIdentitiesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListIdentitiesResponse(data.ListIdentitiesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListIdentityPoliciesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListIdentityPoliciesResponse(data.ListIdentityPoliciesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListReceiptFiltersCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListReceiptFiltersResponse(data.ListReceiptFiltersResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListReceiptRuleSetsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListReceiptRuleSetsResponse(data.ListReceiptRuleSetsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListTemplatesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListTemplatesResponse(data.ListTemplatesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ListVerifiedEmailAddressesCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ListVerifiedEmailAddressesResponse(data.ListVerifiedEmailAddressesResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_PutConfigurationSetDeliveryOptionsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_PutConfigurationSetDeliveryOptionsResponse(data.PutConfigurationSetDeliveryOptionsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_PutIdentityPolicyCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_PutIdentityPolicyResponse(data.PutIdentityPolicyResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_ReorderReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_ReorderReceiptRuleSetResponse(data.ReorderReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendBounceCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendBounceResponse(data.SendBounceResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendBulkTemplatedEmailCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendBulkTemplatedEmailResponse(data.SendBulkTemplatedEmailResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendCustomVerificationEmailCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendCustomVerificationEmailResponse(data.SendCustomVerificationEmailResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendEmailCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendEmailResponse(data.SendEmailResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendRawEmailCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendRawEmailResponse(data.SendRawEmailResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SendTemplatedEmailCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SendTemplatedEmailResponse(data.SendTemplatedEmailResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetActiveReceiptRuleSetCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetActiveReceiptRuleSetResponse(data.SetActiveReceiptRuleSetResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetIdentityDkimEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetIdentityDkimEnabledResponse(data.SetIdentityDkimEnabledResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetIdentityFeedbackForwardingEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetIdentityFeedbackForwardingEnabledResponse(data.SetIdentityFeedbackForwardingEnabledResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetIdentityHeadersInNotificationsEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetIdentityHeadersInNotificationsEnabledResponse(data.SetIdentityHeadersInNotificationsEnabledResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetIdentityMailFromDomainCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetIdentityMailFromDomainResponse(data.SetIdentityMailFromDomainResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetIdentityNotificationTopicCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetIdentityNotificationTopicResponse(data.SetIdentityNotificationTopicResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_SetReceiptRulePositionCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_SetReceiptRulePositionResponse(data.SetReceiptRulePositionResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_TestRenderTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_TestRenderTemplateResponse(data.TestRenderTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_UpdateAccountSendingEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_UpdateConfigurationSetEventDestinationCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_UpdateConfigurationSetEventDestinationResponse(data.UpdateConfigurationSetEventDestinationResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_UpdateConfigurationSetReputationMetricsEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_UpdateConfigurationSetSendingEnabledCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_UpdateConfigurationSetTrackingOptionsCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_UpdateConfigurationSetTrackingOptionsResponse(data.UpdateConfigurationSetTrackingOptionsResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_UpdateCustomVerificationEmailTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_UpdateReceiptRuleCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_UpdateReceiptRuleResponse(data.UpdateReceiptRuleResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_UpdateTemplateCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_UpdateTemplateResponse(data.UpdateTemplateResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_VerifyDomainDkimCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_VerifyDomainDkimResponse(data.VerifyDomainDkimResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_VerifyDomainIdentityCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_VerifyDomainIdentityResponse(data.VerifyDomainIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_VerifyEmailAddressCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  await import_protocols.collectBody(output2.body, context);
  const response = {
    $metadata: deserializeMetadata(output2)
  };
  return response;
};
var de_VerifyEmailIdentityCommand = async (output2, context) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context);
  }
  const data = await import_core5.parseXmlBody(output2.body, context);
  let contents = {};
  contents = de_VerifyEmailIdentityResponse(data.VerifyEmailIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
var de_CommandError = async (output2, context) => {
  const parsedOutput = {
    ...output2,
    body: await import_core5.parseXmlErrorBody(output2.body, context)
  };
  const errorCode = loadQueryErrorCode(output2, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExists":
    case "com.amazonaws.ses#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "LimitExceeded":
    case "com.amazonaws.ses#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "RuleSetDoesNotExist":
    case "com.amazonaws.ses#RuleSetDoesNotExistException":
      throw await de_RuleSetDoesNotExistExceptionRes(parsedOutput, context);
    case "ConfigurationSetAlreadyExists":
    case "com.amazonaws.ses#ConfigurationSetAlreadyExistsException":
      throw await de_ConfigurationSetAlreadyExistsExceptionRes(parsedOutput, context);
    case "InvalidConfigurationSet":
    case "com.amazonaws.ses#InvalidConfigurationSetException":
      throw await de_InvalidConfigurationSetExceptionRes(parsedOutput, context);
    case "ConfigurationSetDoesNotExist":
    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
      throw await de_ConfigurationSetDoesNotExistExceptionRes(parsedOutput, context);
    case "EventDestinationAlreadyExists":
    case "com.amazonaws.ses#EventDestinationAlreadyExistsException":
      throw await de_EventDestinationAlreadyExistsExceptionRes(parsedOutput, context);
    case "InvalidCloudWatchDestination":
    case "com.amazonaws.ses#InvalidCloudWatchDestinationException":
      throw await de_InvalidCloudWatchDestinationExceptionRes(parsedOutput, context);
    case "InvalidFirehoseDestination":
    case "com.amazonaws.ses#InvalidFirehoseDestinationException":
      throw await de_InvalidFirehoseDestinationExceptionRes(parsedOutput, context);
    case "InvalidSNSDestination":
    case "com.amazonaws.ses#InvalidSNSDestinationException":
      throw await de_InvalidSNSDestinationExceptionRes(parsedOutput, context);
    case "InvalidTrackingOptions":
    case "com.amazonaws.ses#InvalidTrackingOptionsException":
      throw await de_InvalidTrackingOptionsExceptionRes(parsedOutput, context);
    case "TrackingOptionsAlreadyExistsException":
    case "com.amazonaws.ses#TrackingOptionsAlreadyExistsException":
      throw await de_TrackingOptionsAlreadyExistsExceptionRes(parsedOutput, context);
    case "CustomVerificationEmailInvalidContent":
    case "com.amazonaws.ses#CustomVerificationEmailInvalidContentException":
      throw await de_CustomVerificationEmailInvalidContentExceptionRes(parsedOutput, context);
    case "CustomVerificationEmailTemplateAlreadyExists":
    case "com.amazonaws.ses#CustomVerificationEmailTemplateAlreadyExistsException":
      throw await de_CustomVerificationEmailTemplateAlreadyExistsExceptionRes(parsedOutput, context);
    case "FromEmailAddressNotVerified":
    case "com.amazonaws.ses#FromEmailAddressNotVerifiedException":
      throw await de_FromEmailAddressNotVerifiedExceptionRes(parsedOutput, context);
    case "InvalidLambdaFunction":
    case "com.amazonaws.ses#InvalidLambdaFunctionException":
      throw await de_InvalidLambdaFunctionExceptionRes(parsedOutput, context);
    case "InvalidS3Configuration":
    case "com.amazonaws.ses#InvalidS3ConfigurationException":
      throw await de_InvalidS3ConfigurationExceptionRes(parsedOutput, context);
    case "InvalidSnsTopic":
    case "com.amazonaws.ses#InvalidSnsTopicException":
      throw await de_InvalidSnsTopicExceptionRes(parsedOutput, context);
    case "RuleDoesNotExist":
    case "com.amazonaws.ses#RuleDoesNotExistException":
      throw await de_RuleDoesNotExistExceptionRes(parsedOutput, context);
    case "InvalidTemplate":
    case "com.amazonaws.ses#InvalidTemplateException":
      throw await de_InvalidTemplateExceptionRes(parsedOutput, context);
    case "EventDestinationDoesNotExist":
    case "com.amazonaws.ses#EventDestinationDoesNotExistException":
      throw await de_EventDestinationDoesNotExistExceptionRes(parsedOutput, context);
    case "TrackingOptionsDoesNotExistException":
    case "com.amazonaws.ses#TrackingOptionsDoesNotExistException":
      throw await de_TrackingOptionsDoesNotExistExceptionRes(parsedOutput, context);
    case "CannotDelete":
    case "com.amazonaws.ses#CannotDeleteException":
      throw await de_CannotDeleteExceptionRes(parsedOutput, context);
    case "CustomVerificationEmailTemplateDoesNotExist":
    case "com.amazonaws.ses#CustomVerificationEmailTemplateDoesNotExistException":
      throw await de_CustomVerificationEmailTemplateDoesNotExistExceptionRes(parsedOutput, context);
    case "TemplateDoesNotExist":
    case "com.amazonaws.ses#TemplateDoesNotExistException":
      throw await de_TemplateDoesNotExistExceptionRes(parsedOutput, context);
    case "InvalidDeliveryOptions":
    case "com.amazonaws.ses#InvalidDeliveryOptionsException":
      throw await de_InvalidDeliveryOptionsExceptionRes(parsedOutput, context);
    case "InvalidPolicy":
    case "com.amazonaws.ses#InvalidPolicyException":
      throw await de_InvalidPolicyExceptionRes(parsedOutput, context);
    case "MessageRejected":
    case "com.amazonaws.ses#MessageRejected":
      throw await de_MessageRejectedRes(parsedOutput, context);
    case "AccountSendingPausedException":
    case "com.amazonaws.ses#AccountSendingPausedException":
      throw await de_AccountSendingPausedExceptionRes(parsedOutput, context);
    case "ConfigurationSetSendingPausedException":
    case "com.amazonaws.ses#ConfigurationSetSendingPausedException":
      throw await de_ConfigurationSetSendingPausedExceptionRes(parsedOutput, context);
    case "MailFromDomainNotVerifiedException":
    case "com.amazonaws.ses#MailFromDomainNotVerifiedException":
      throw await de_MailFromDomainNotVerifiedExceptionRes(parsedOutput, context);
    case "ProductionAccessNotGranted":
    case "com.amazonaws.ses#ProductionAccessNotGrantedException":
      throw await de_ProductionAccessNotGrantedExceptionRes(parsedOutput, context);
    case "InvalidRenderingParameter":
    case "com.amazonaws.ses#InvalidRenderingParameterException":
      throw await de_InvalidRenderingParameterExceptionRes(parsedOutput, context);
    case "MissingRenderingAttribute":
    case "com.amazonaws.ses#MissingRenderingAttributeException":
      throw await de_MissingRenderingAttributeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output: output2,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
};
var de_AccountSendingPausedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_AccountSendingPausedException(body.Error, context);
  const exception = new AccountSendingPausedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_AlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_AlreadyExistsException(body.Error, context);
  const exception = new AlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_CannotDeleteExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_CannotDeleteException(body.Error, context);
  const exception = new CannotDeleteException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ConfigurationSetAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConfigurationSetAlreadyExistsException(body.Error, context);
  const exception = new ConfigurationSetAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ConfigurationSetDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConfigurationSetDoesNotExistException(body.Error, context);
  const exception = new ConfigurationSetDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ConfigurationSetSendingPausedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConfigurationSetSendingPausedException(body.Error, context);
  const exception = new ConfigurationSetSendingPausedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_CustomVerificationEmailInvalidContentExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_CustomVerificationEmailInvalidContentException(body.Error, context);
  const exception = new CustomVerificationEmailInvalidContentException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_CustomVerificationEmailTemplateAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_CustomVerificationEmailTemplateAlreadyExistsException(body.Error, context);
  const exception = new CustomVerificationEmailTemplateAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_CustomVerificationEmailTemplateDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_CustomVerificationEmailTemplateDoesNotExistException(body.Error, context);
  const exception = new CustomVerificationEmailTemplateDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_EventDestinationAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_EventDestinationAlreadyExistsException(body.Error, context);
  const exception = new EventDestinationAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_EventDestinationDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_EventDestinationDoesNotExistException(body.Error, context);
  const exception = new EventDestinationDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_FromEmailAddressNotVerifiedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_FromEmailAddressNotVerifiedException(body.Error, context);
  const exception = new FromEmailAddressNotVerifiedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidCloudWatchDestinationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidCloudWatchDestinationException(body.Error, context);
  const exception = new InvalidCloudWatchDestinationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidConfigurationSetExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidConfigurationSetException(body.Error, context);
  const exception = new InvalidConfigurationSetException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidDeliveryOptionsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidDeliveryOptionsException(body.Error, context);
  const exception = new InvalidDeliveryOptionsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidFirehoseDestinationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidFirehoseDestinationException(body.Error, context);
  const exception = new InvalidFirehoseDestinationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidLambdaFunctionExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidLambdaFunctionException(body.Error, context);
  const exception = new InvalidLambdaFunctionException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidPolicyExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidPolicyException(body.Error, context);
  const exception = new InvalidPolicyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidRenderingParameterExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidRenderingParameterException(body.Error, context);
  const exception = new InvalidRenderingParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidS3ConfigurationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidS3ConfigurationException(body.Error, context);
  const exception = new InvalidS3ConfigurationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidSNSDestinationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidSNSDestinationException(body.Error, context);
  const exception = new InvalidSNSDestinationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidSnsTopicExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidSnsTopicException(body.Error, context);
  const exception = new InvalidSnsTopicException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidTemplateExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidTemplateException(body.Error, context);
  const exception = new InvalidTemplateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidTrackingOptionsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidTrackingOptionsException(body.Error, context);
  const exception = new InvalidTrackingOptionsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_LimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_LimitExceededException(body.Error, context);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_MailFromDomainNotVerifiedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_MailFromDomainNotVerifiedException(body.Error, context);
  const exception = new MailFromDomainNotVerifiedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_MessageRejectedRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_MessageRejected(body.Error, context);
  const exception = new MessageRejected({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_MissingRenderingAttributeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_MissingRenderingAttributeException(body.Error, context);
  const exception = new MissingRenderingAttributeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ProductionAccessNotGrantedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ProductionAccessNotGrantedException(body.Error, context);
  const exception = new ProductionAccessNotGrantedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_RuleDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_RuleDoesNotExistException(body.Error, context);
  const exception = new RuleDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_RuleSetDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_RuleSetDoesNotExistException(body.Error, context);
  const exception = new RuleSetDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_TemplateDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_TemplateDoesNotExistException(body.Error, context);
  const exception = new TemplateDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_TrackingOptionsAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_TrackingOptionsAlreadyExistsException(body.Error, context);
  const exception = new TrackingOptionsAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_TrackingOptionsDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_TrackingOptionsDoesNotExistException(body.Error, context);
  const exception = new TrackingOptionsDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var se_AddHeaderAction = (input2, context) => {
  const entries = {};
  if (input2[_HN] != null) {
    entries[_HN] = input2[_HN];
  }
  if (input2[_HV] != null) {
    entries[_HV] = input2[_HV];
  }
  return entries;
};
var se_AddressList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_Body = (input2, context) => {
  const entries = {};
  if (input2[_T] != null) {
    const memberEntries = se_Content(input2[_T], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Text.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_H] != null) {
    const memberEntries = se_Content(input2[_H], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Html.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_BounceAction = (input2, context) => {
  const entries = {};
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  if (input2[_SRC] != null) {
    entries[_SRC] = input2[_SRC];
  }
  if (input2[_SC] != null) {
    entries[_SC] = input2[_SC];
  }
  if (input2[_M] != null) {
    entries[_M] = input2[_M];
  }
  if (input2[_S] != null) {
    entries[_S] = input2[_S];
  }
  return entries;
};
var se_BouncedRecipientInfo = (input2, context) => {
  const entries = {};
  if (input2[_R] != null) {
    entries[_R] = input2[_R];
  }
  if (input2[_RA] != null) {
    entries[_RA] = input2[_RA];
  }
  if (input2[_BT] != null) {
    entries[_BT] = input2[_BT];
  }
  if (input2[_RDF] != null) {
    const memberEntries = se_RecipientDsnFields(input2[_RDF], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RecipientDsnFields.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_BouncedRecipientInfoList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_BouncedRecipientInfo(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_BulkEmailDestination = (input2, context) => {
  const entries = {};
  if (input2[_D] != null) {
    const memberEntries = se_Destination(input2[_D], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Destination.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RT] != null) {
    const memberEntries = se_MessageTagList(input2[_RT], context);
    if (input2[_RT]?.length === 0) {
      entries.ReplacementTags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReplacementTags.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RTD] != null) {
    entries[_RTD] = input2[_RTD];
  }
  return entries;
};
var se_BulkEmailDestinationList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_BulkEmailDestination(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_CloneReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_ORSN] != null) {
    entries[_ORSN] = input2[_ORSN];
  }
  return entries;
};
var se_CloudWatchDestination = (input2, context) => {
  const entries = {};
  if (input2[_DC] != null) {
    const memberEntries = se_CloudWatchDimensionConfigurations(input2[_DC], context);
    if (input2[_DC]?.length === 0) {
      entries.DimensionConfigurations = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DimensionConfigurations.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CloudWatchDimensionConfiguration = (input2, context) => {
  const entries = {};
  if (input2[_DN] != null) {
    entries[_DN] = input2[_DN];
  }
  if (input2[_DVS] != null) {
    entries[_DVS] = input2[_DVS];
  }
  if (input2[_DDV] != null) {
    entries[_DDV] = input2[_DDV];
  }
  return entries;
};
var se_CloudWatchDimensionConfigurations = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_CloudWatchDimensionConfiguration(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_ConfigurationSet = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  return entries;
};
var se_ConfigurationSetAttributeList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_ConnectAction = (input2, context) => {
  const entries = {};
  if (input2[_IARN] != null) {
    entries[_IARN] = input2[_IARN];
  }
  if (input2[_IAMRARN] != null) {
    entries[_IAMRARN] = input2[_IAMRARN];
  }
  return entries;
};
var se_Content = (input2, context) => {
  const entries = {};
  if (input2[_Da] != null) {
    entries[_Da] = input2[_Da];
  }
  if (input2[_C] != null) {
    entries[_C] = input2[_C];
  }
  return entries;
};
var se_CreateConfigurationSetEventDestinationRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_ED] != null) {
    const memberEntries = se_EventDestination(input2[_ED], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EventDestination.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CreateConfigurationSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_CS] != null) {
    const memberEntries = se_ConfigurationSet(input2[_CS], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConfigurationSet.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CreateConfigurationSetTrackingOptionsRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_TO] != null) {
    const memberEntries = se_TrackingOptions(input2[_TO], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TrackingOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CreateCustomVerificationEmailTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  if (input2[_FEA] != null) {
    entries[_FEA] = input2[_FEA];
  }
  if (input2[_TS] != null) {
    entries[_TS] = input2[_TS];
  }
  if (input2[_TC] != null) {
    entries[_TC] = input2[_TC];
  }
  if (input2[_SRURL] != null) {
    entries[_SRURL] = input2[_SRURL];
  }
  if (input2[_FRURL] != null) {
    entries[_FRURL] = input2[_FRURL];
  }
  return entries;
};
var se_CreateReceiptFilterRequest = (input2, context) => {
  const entries = {};
  if (input2[_F] != null) {
    const memberEntries = se_ReceiptFilter(input2[_F], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CreateReceiptRuleRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_Af] != null) {
    entries[_Af] = input2[_Af];
  }
  if (input2[_Ru] != null) {
    const memberEntries = se_ReceiptRule(input2[_Ru], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Rule.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_CreateReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  return entries;
};
var se_CreateTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_Te] != null) {
    const memberEntries = se_Template(input2[_Te], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Template.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DeleteConfigurationSetEventDestinationRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_EDN] != null) {
    entries[_EDN] = input2[_EDN];
  }
  return entries;
};
var se_DeleteConfigurationSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  return entries;
};
var se_DeleteConfigurationSetTrackingOptionsRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  return entries;
};
var se_DeleteCustomVerificationEmailTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  return entries;
};
var se_DeleteIdentityPolicyRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_PN] != null) {
    entries[_PN] = input2[_PN];
  }
  return entries;
};
var se_DeleteIdentityRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  return entries;
};
var se_DeleteReceiptFilterRequest = (input2, context) => {
  const entries = {};
  if (input2[_FN] != null) {
    entries[_FN] = input2[_FN];
  }
  return entries;
};
var se_DeleteReceiptRuleRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_RN] != null) {
    entries[_RN] = input2[_RN];
  }
  return entries;
};
var se_DeleteReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  return entries;
};
var se_DeleteTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  return entries;
};
var se_DeleteVerifiedEmailAddressRequest = (input2, context) => {
  const entries = {};
  if (input2[_EA] != null) {
    entries[_EA] = input2[_EA];
  }
  return entries;
};
var se_DeliveryOptions = (input2, context) => {
  const entries = {};
  if (input2[_TP] != null) {
    entries[_TP] = input2[_TP];
  }
  return entries;
};
var se_DescribeActiveReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  return entries;
};
var se_DescribeConfigurationSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_CSAN] != null) {
    const memberEntries = se_ConfigurationSetAttributeList(input2[_CSAN], context);
    if (input2[_CSAN]?.length === 0) {
      entries.ConfigurationSetAttributeNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConfigurationSetAttributeNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DescribeReceiptRuleRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_RN] != null) {
    entries[_RN] = input2[_RN];
  }
  return entries;
};
var se_DescribeReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  return entries;
};
var se_Destination = (input2, context) => {
  const entries = {};
  if (input2[_TAo] != null) {
    const memberEntries = se_AddressList(input2[_TAo], context);
    if (input2[_TAo]?.length === 0) {
      entries.ToAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ToAddresses.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CA] != null) {
    const memberEntries = se_AddressList(input2[_CA], context);
    if (input2[_CA]?.length === 0) {
      entries.CcAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CcAddresses.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_BA] != null) {
    const memberEntries = se_AddressList(input2[_BA], context);
    if (input2[_BA]?.length === 0) {
      entries.BccAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BccAddresses.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EventDestination = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  if (input2[_MET] != null) {
    const memberEntries = se_EventTypes(input2[_MET], context);
    if (input2[_MET]?.length === 0) {
      entries.MatchingEventTypes = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MatchingEventTypes.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_KFD] != null) {
    const memberEntries = se_KinesisFirehoseDestination(input2[_KFD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `KinesisFirehoseDestination.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CWD] != null) {
    const memberEntries = se_CloudWatchDestination(input2[_CWD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CloudWatchDestination.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_SNSD] != null) {
    const memberEntries = se_SNSDestination(input2[_SNSD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SNSDestination.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EventTypes = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_ExtensionField = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  if (input2[_Va] != null) {
    entries[_Va] = input2[_Va];
  }
  return entries;
};
var se_ExtensionFieldList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ExtensionField(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_GetCustomVerificationEmailTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  return entries;
};
var se_GetIdentityDkimAttributesRequest = (input2, context) => {
  const entries = {};
  if (input2[_Id] != null) {
    const memberEntries = se_IdentityList(input2[_Id], context);
    if (input2[_Id]?.length === 0) {
      entries.Identities = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Identities.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetIdentityMailFromDomainAttributesRequest = (input2, context) => {
  const entries = {};
  if (input2[_Id] != null) {
    const memberEntries = se_IdentityList(input2[_Id], context);
    if (input2[_Id]?.length === 0) {
      entries.Identities = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Identities.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetIdentityNotificationAttributesRequest = (input2, context) => {
  const entries = {};
  if (input2[_Id] != null) {
    const memberEntries = se_IdentityList(input2[_Id], context);
    if (input2[_Id]?.length === 0) {
      entries.Identities = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Identities.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetIdentityPoliciesRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_PNo] != null) {
    const memberEntries = se_PolicyNameList(input2[_PNo], context);
    if (input2[_PNo]?.length === 0) {
      entries.PolicyNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetIdentityVerificationAttributesRequest = (input2, context) => {
  const entries = {};
  if (input2[_Id] != null) {
    const memberEntries = se_IdentityList(input2[_Id], context);
    if (input2[_Id]?.length === 0) {
      entries.Identities = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Identities.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  return entries;
};
var se_IdentityList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_KinesisFirehoseDestination = (input2, context) => {
  const entries = {};
  if (input2[_IAMRARN] != null) {
    entries[_IAMRARN] = input2[_IAMRARN];
  }
  if (input2[_DSARN] != null) {
    entries[_DSARN] = input2[_DSARN];
  }
  return entries;
};
var se_LambdaAction = (input2, context) => {
  const entries = {};
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  if (input2[_FA] != null) {
    entries[_FA] = input2[_FA];
  }
  if (input2[_IT] != null) {
    entries[_IT] = input2[_IT];
  }
  return entries;
};
var se_ListConfigurationSetsRequest = (input2, context) => {
  const entries = {};
  if (input2[_NT] != null) {
    entries[_NT] = input2[_NT];
  }
  if (input2[_MI] != null) {
    entries[_MI] = input2[_MI];
  }
  return entries;
};
var se_ListCustomVerificationEmailTemplatesRequest = (input2, context) => {
  const entries = {};
  if (input2[_NT] != null) {
    entries[_NT] = input2[_NT];
  }
  if (input2[_MR] != null) {
    entries[_MR] = input2[_MR];
  }
  return entries;
};
var se_ListIdentitiesRequest = (input2, context) => {
  const entries = {};
  if (input2[_ITd] != null) {
    entries[_ITd] = input2[_ITd];
  }
  if (input2[_NT] != null) {
    entries[_NT] = input2[_NT];
  }
  if (input2[_MI] != null) {
    entries[_MI] = input2[_MI];
  }
  return entries;
};
var se_ListIdentityPoliciesRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  return entries;
};
var se_ListReceiptFiltersRequest = (input2, context) => {
  const entries = {};
  return entries;
};
var se_ListReceiptRuleSetsRequest = (input2, context) => {
  const entries = {};
  if (input2[_NT] != null) {
    entries[_NT] = input2[_NT];
  }
  return entries;
};
var se_ListTemplatesRequest = (input2, context) => {
  const entries = {};
  if (input2[_NT] != null) {
    entries[_NT] = input2[_NT];
  }
  if (input2[_MI] != null) {
    entries[_MI] = input2[_MI];
  }
  return entries;
};
var se_Message = (input2, context) => {
  const entries = {};
  if (input2[_Su] != null) {
    const memberEntries = se_Content(input2[_Su], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Subject.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_B] != null) {
    const memberEntries = se_Body(input2[_B], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Body.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MessageDsn = (input2, context) => {
  const entries = {};
  if (input2[_RM] != null) {
    entries[_RM] = input2[_RM];
  }
  if (input2[_AD] != null) {
    entries[_AD] = serializeDateTime(input2[_AD]);
  }
  if (input2[_EF] != null) {
    const memberEntries = se_ExtensionFieldList(input2[_EF], context);
    if (input2[_EF]?.length === 0) {
      entries.ExtensionFields = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExtensionFields.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MessageTag = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  if (input2[_Va] != null) {
    entries[_Va] = input2[_Va];
  }
  return entries;
};
var se_MessageTagList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MessageTag(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_PolicyNameList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_PutConfigurationSetDeliveryOptionsRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_DO] != null) {
    const memberEntries = se_DeliveryOptions(input2[_DO], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DeliveryOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_PutIdentityPolicyRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_PN] != null) {
    entries[_PN] = input2[_PN];
  }
  if (input2[_P] != null) {
    entries[_P] = input2[_P];
  }
  return entries;
};
var se_RawMessage = (input2, context) => {
  const entries = {};
  if (input2[_Da] != null) {
    entries[_Da] = context.base64Encoder(input2[_Da]);
  }
  return entries;
};
var se_ReceiptAction = (input2, context) => {
  const entries = {};
  if (input2[_SA] != null) {
    const memberEntries = se_S3Action(input2[_SA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `S3Action.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_BAo] != null) {
    const memberEntries = se_BounceAction(input2[_BAo], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BounceAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_WA] != null) {
    const memberEntries = se_WorkmailAction(input2[_WA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `WorkmailAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_LA] != null) {
    const memberEntries = se_LambdaAction(input2[_LA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LambdaAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_SAt] != null) {
    const memberEntries = se_StopAction(input2[_SAt], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StopAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_AHA] != null) {
    const memberEntries = se_AddHeaderAction(input2[_AHA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddHeaderAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_SNSA] != null) {
    const memberEntries = se_SNSAction(input2[_SNSA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SNSAction.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CAo] != null) {
    const memberEntries = se_ConnectAction(input2[_CAo], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectAction.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_ReceiptActionsList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ReceiptAction(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_ReceiptFilter = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  if (input2[_IF] != null) {
    const memberEntries = se_ReceiptIpFilter(input2[_IF], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpFilter.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_ReceiptIpFilter = (input2, context) => {
  const entries = {};
  if (input2[_P] != null) {
    entries[_P] = input2[_P];
  }
  if (input2[_Ci] != null) {
    entries[_Ci] = input2[_Ci];
  }
  return entries;
};
var se_ReceiptRule = (input2, context) => {
  const entries = {};
  if (input2[_N] != null) {
    entries[_N] = input2[_N];
  }
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  if (input2[_TP] != null) {
    entries[_TP] = input2[_TP];
  }
  if (input2[_Re] != null) {
    const memberEntries = se_RecipientsList(input2[_Re], context);
    if (input2[_Re]?.length === 0) {
      entries.Recipients = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Recipients.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_Ac] != null) {
    const memberEntries = se_ReceiptActionsList(input2[_Ac], context);
    if (input2[_Ac]?.length === 0) {
      entries.Actions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Actions.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_SEc] != null) {
    entries[_SEc] = input2[_SEc];
  }
  return entries;
};
var se_ReceiptRuleNamesList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_RecipientDsnFields = (input2, context) => {
  const entries = {};
  if (input2[_FR] != null) {
    entries[_FR] = input2[_FR];
  }
  if (input2[_A] != null) {
    entries[_A] = input2[_A];
  }
  if (input2[_RMe] != null) {
    entries[_RMe] = input2[_RMe];
  }
  if (input2[_St] != null) {
    entries[_St] = input2[_St];
  }
  if (input2[_DCi] != null) {
    entries[_DCi] = input2[_DCi];
  }
  if (input2[_LAD] != null) {
    entries[_LAD] = serializeDateTime(input2[_LAD]);
  }
  if (input2[_EF] != null) {
    const memberEntries = se_ExtensionFieldList(input2[_EF], context);
    if (input2[_EF]?.length === 0) {
      entries.ExtensionFields = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExtensionFields.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_RecipientsList = (input2, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input2) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_ReorderReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_RNu] != null) {
    const memberEntries = se_ReceiptRuleNamesList(input2[_RNu], context);
    if (input2[_RNu]?.length === 0) {
      entries.RuleNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RuleNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_S3Action = (input2, context) => {
  const entries = {};
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  if (input2[_BN] != null) {
    entries[_BN] = input2[_BN];
  }
  if (input2[_OKP] != null) {
    entries[_OKP] = input2[_OKP];
  }
  if (input2[_KKA] != null) {
    entries[_KKA] = input2[_KKA];
  }
  if (input2[_IRA] != null) {
    entries[_IRA] = input2[_IRA];
  }
  return entries;
};
var se_SendBounceRequest = (input2, context) => {
  const entries = {};
  if (input2[_OMI] != null) {
    entries[_OMI] = input2[_OMI];
  }
  if (input2[_BS] != null) {
    entries[_BS] = input2[_BS];
  }
  if (input2[_Ex] != null) {
    entries[_Ex] = input2[_Ex];
  }
  if (input2[_MD] != null) {
    const memberEntries = se_MessageDsn(input2[_MD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageDsn.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_BRIL] != null) {
    const memberEntries = se_BouncedRecipientInfoList(input2[_BRIL], context);
    if (input2[_BRIL]?.length === 0) {
      entries.BouncedRecipientInfoList = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BouncedRecipientInfoList.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_BSA] != null) {
    entries[_BSA] = input2[_BSA];
  }
  return entries;
};
var se_SendBulkTemplatedEmailRequest = (input2, context) => {
  const entries = {};
  if (input2[_So] != null) {
    entries[_So] = input2[_So];
  }
  if (input2[_SAo] != null) {
    entries[_SAo] = input2[_SAo];
  }
  if (input2[_RTA] != null) {
    const memberEntries = se_AddressList(input2[_RTA], context);
    if (input2[_RTA]?.length === 0) {
      entries.ReplyToAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReplyToAddresses.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RP] != null) {
    entries[_RP] = input2[_RP];
  }
  if (input2[_RPA] != null) {
    entries[_RPA] = input2[_RPA];
  }
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_DTe] != null) {
    const memberEntries = se_MessageTagList(input2[_DTe], context);
    if (input2[_DTe]?.length === 0) {
      entries.DefaultTags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DefaultTags.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_Te] != null) {
    entries[_Te] = input2[_Te];
  }
  if (input2[_TAe] != null) {
    entries[_TAe] = input2[_TAe];
  }
  if (input2[_DTD] != null) {
    entries[_DTD] = input2[_DTD];
  }
  if (input2[_De] != null) {
    const memberEntries = se_BulkEmailDestinationList(input2[_De], context);
    if (input2[_De]?.length === 0) {
      entries.Destinations = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Destinations.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_SendCustomVerificationEmailRequest = (input2, context) => {
  const entries = {};
  if (input2[_EA] != null) {
    entries[_EA] = input2[_EA];
  }
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  return entries;
};
var se_SendEmailRequest = (input2, context) => {
  const entries = {};
  if (input2[_So] != null) {
    entries[_So] = input2[_So];
  }
  if (input2[_D] != null) {
    const memberEntries = se_Destination(input2[_D], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Destination.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_M] != null) {
    const memberEntries = se_Message(input2[_M], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Message.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RTA] != null) {
    const memberEntries = se_AddressList(input2[_RTA], context);
    if (input2[_RTA]?.length === 0) {
      entries.ReplyToAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReplyToAddresses.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RP] != null) {
    entries[_RP] = input2[_RP];
  }
  if (input2[_SAo] != null) {
    entries[_SAo] = input2[_SAo];
  }
  if (input2[_RPA] != null) {
    entries[_RPA] = input2[_RPA];
  }
  if (input2[_Ta] != null) {
    const memberEntries = se_MessageTagList(input2[_Ta], context);
    if (input2[_Ta]?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  return entries;
};
var se_SendRawEmailRequest = (input2, context) => {
  const entries = {};
  if (input2[_So] != null) {
    entries[_So] = input2[_So];
  }
  if (input2[_De] != null) {
    const memberEntries = se_AddressList(input2[_De], context);
    if (input2[_De]?.length === 0) {
      entries.Destinations = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Destinations.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RMa] != null) {
    const memberEntries = se_RawMessage(input2[_RMa], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RawMessage.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_FAr] != null) {
    entries[_FAr] = input2[_FAr];
  }
  if (input2[_SAo] != null) {
    entries[_SAo] = input2[_SAo];
  }
  if (input2[_RPA] != null) {
    entries[_RPA] = input2[_RPA];
  }
  if (input2[_Ta] != null) {
    const memberEntries = se_MessageTagList(input2[_Ta], context);
    if (input2[_Ta]?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  return entries;
};
var se_SendTemplatedEmailRequest = (input2, context) => {
  const entries = {};
  if (input2[_So] != null) {
    entries[_So] = input2[_So];
  }
  if (input2[_D] != null) {
    const memberEntries = se_Destination(input2[_D], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Destination.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RTA] != null) {
    const memberEntries = se_AddressList(input2[_RTA], context);
    if (input2[_RTA]?.length === 0) {
      entries.ReplyToAddresses = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReplyToAddresses.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_RP] != null) {
    entries[_RP] = input2[_RP];
  }
  if (input2[_SAo] != null) {
    entries[_SAo] = input2[_SAo];
  }
  if (input2[_RPA] != null) {
    entries[_RPA] = input2[_RPA];
  }
  if (input2[_Ta] != null) {
    const memberEntries = se_MessageTagList(input2[_Ta], context);
    if (input2[_Ta]?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_Te] != null) {
    entries[_Te] = input2[_Te];
  }
  if (input2[_TAe] != null) {
    entries[_TAe] = input2[_TAe];
  }
  if (input2[_TD] != null) {
    entries[_TD] = input2[_TD];
  }
  return entries;
};
var se_SetActiveReceiptRuleSetRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  return entries;
};
var se_SetIdentityDkimEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_DE] != null) {
    entries[_DE] = input2[_DE];
  }
  return entries;
};
var se_SetIdentityFeedbackForwardingEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_FE] != null) {
    entries[_FE] = input2[_FE];
  }
  return entries;
};
var se_SetIdentityHeadersInNotificationsEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_NTo] != null) {
    entries[_NTo] = input2[_NTo];
  }
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  return entries;
};
var se_SetIdentityMailFromDomainRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_MFD] != null) {
    entries[_MFD] = input2[_MFD];
  }
  if (input2[_BOMXF] != null) {
    entries[_BOMXF] = input2[_BOMXF];
  }
  return entries;
};
var se_SetIdentityNotificationTopicRequest = (input2, context) => {
  const entries = {};
  if (input2[_I] != null) {
    entries[_I] = input2[_I];
  }
  if (input2[_NTo] != null) {
    entries[_NTo] = input2[_NTo];
  }
  if (input2[_ST] != null) {
    entries[_ST] = input2[_ST];
  }
  return entries;
};
var se_SetReceiptRulePositionRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_RN] != null) {
    entries[_RN] = input2[_RN];
  }
  if (input2[_Af] != null) {
    entries[_Af] = input2[_Af];
  }
  return entries;
};
var se_SNSAction = (input2, context) => {
  const entries = {};
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  if (input2[_En] != null) {
    entries[_En] = input2[_En];
  }
  return entries;
};
var se_SNSDestination = (input2, context) => {
  const entries = {};
  if (input2[_TARN] != null) {
    entries[_TARN] = input2[_TARN];
  }
  return entries;
};
var se_StopAction = (input2, context) => {
  const entries = {};
  if (input2[_Sc] != null) {
    entries[_Sc] = input2[_Sc];
  }
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  return entries;
};
var se_Template = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  if (input2[_SP] != null) {
    entries[_SP] = input2[_SP];
  }
  if (input2[_TPe] != null) {
    entries[_TPe] = input2[_TPe];
  }
  if (input2[_HP] != null) {
    entries[_HP] = input2[_HP];
  }
  return entries;
};
var se_TestRenderTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  if (input2[_TD] != null) {
    entries[_TD] = input2[_TD];
  }
  return entries;
};
var se_TrackingOptions = (input2, context) => {
  const entries = {};
  if (input2[_CRD] != null) {
    entries[_CRD] = input2[_CRD];
  }
  return entries;
};
var se_UpdateAccountSendingEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  return entries;
};
var se_UpdateConfigurationSetEventDestinationRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_ED] != null) {
    const memberEntries = se_EventDestination(input2[_ED], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EventDestination.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_UpdateConfigurationSetReputationMetricsEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  return entries;
};
var se_UpdateConfigurationSetSendingEnabledRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_E] != null) {
    entries[_E] = input2[_E];
  }
  return entries;
};
var se_UpdateConfigurationSetTrackingOptionsRequest = (input2, context) => {
  const entries = {};
  if (input2[_CSN] != null) {
    entries[_CSN] = input2[_CSN];
  }
  if (input2[_TO] != null) {
    const memberEntries = se_TrackingOptions(input2[_TO], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TrackingOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_UpdateCustomVerificationEmailTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_TN] != null) {
    entries[_TN] = input2[_TN];
  }
  if (input2[_FEA] != null) {
    entries[_FEA] = input2[_FEA];
  }
  if (input2[_TS] != null) {
    entries[_TS] = input2[_TS];
  }
  if (input2[_TC] != null) {
    entries[_TC] = input2[_TC];
  }
  if (input2[_SRURL] != null) {
    entries[_SRURL] = input2[_SRURL];
  }
  if (input2[_FRURL] != null) {
    entries[_FRURL] = input2[_FRURL];
  }
  return entries;
};
var se_UpdateReceiptRuleRequest = (input2, context) => {
  const entries = {};
  if (input2[_RSN] != null) {
    entries[_RSN] = input2[_RSN];
  }
  if (input2[_Ru] != null) {
    const memberEntries = se_ReceiptRule(input2[_Ru], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Rule.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_UpdateTemplateRequest = (input2, context) => {
  const entries = {};
  if (input2[_Te] != null) {
    const memberEntries = se_Template(input2[_Te], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Template.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_VerifyDomainDkimRequest = (input2, context) => {
  const entries = {};
  if (input2[_Do] != null) {
    entries[_Do] = input2[_Do];
  }
  return entries;
};
var se_VerifyDomainIdentityRequest = (input2, context) => {
  const entries = {};
  if (input2[_Do] != null) {
    entries[_Do] = input2[_Do];
  }
  return entries;
};
var se_VerifyEmailAddressRequest = (input2, context) => {
  const entries = {};
  if (input2[_EA] != null) {
    entries[_EA] = input2[_EA];
  }
  return entries;
};
var se_VerifyEmailIdentityRequest = (input2, context) => {
  const entries = {};
  if (input2[_EA] != null) {
    entries[_EA] = input2[_EA];
  }
  return entries;
};
var se_WorkmailAction = (input2, context) => {
  const entries = {};
  if (input2[_TA] != null) {
    entries[_TA] = input2[_TA];
  }
  if (input2[_OA] != null) {
    entries[_OA] = input2[_OA];
  }
  return entries;
};
var de_AccountSendingPausedException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_AddHeaderAction = (output2, context) => {
  const contents = {};
  if (output2[_HN] != null) {
    contents[_HN] = exports_dist_es.expectString(output2[_HN]);
  }
  if (output2[_HV] != null) {
    contents[_HV] = exports_dist_es.expectString(output2[_HV]);
  }
  return contents;
};
var de_AddressList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_AlreadyExistsException = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_BounceAction = (output2, context) => {
  const contents = {};
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  if (output2[_SRC] != null) {
    contents[_SRC] = exports_dist_es.expectString(output2[_SRC]);
  }
  if (output2[_SC] != null) {
    contents[_SC] = exports_dist_es.expectString(output2[_SC]);
  }
  if (output2[_M] != null) {
    contents[_M] = exports_dist_es.expectString(output2[_M]);
  }
  if (output2[_S] != null) {
    contents[_S] = exports_dist_es.expectString(output2[_S]);
  }
  return contents;
};
var de_BulkEmailDestinationStatus = (output2, context) => {
  const contents = {};
  if (output2[_St] != null) {
    contents[_St] = exports_dist_es.expectString(output2[_St]);
  }
  if (output2[_Er] != null) {
    contents[_Er] = exports_dist_es.expectString(output2[_Er]);
  }
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_BulkEmailDestinationStatusList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_BulkEmailDestinationStatus(entry, context);
  });
};
var de_CannotDeleteException = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_CloneReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CloudWatchDestination = (output2, context) => {
  const contents = {};
  if (output2.DimensionConfigurations === "") {
    contents[_DC] = [];
  } else if (output2[_DC] != null && output2[_DC][_me] != null) {
    contents[_DC] = de_CloudWatchDimensionConfigurations(getArrayIfSingleItem(output2[_DC][_me]), context);
  }
  return contents;
};
var de_CloudWatchDimensionConfiguration = (output2, context) => {
  const contents = {};
  if (output2[_DN] != null) {
    contents[_DN] = exports_dist_es.expectString(output2[_DN]);
  }
  if (output2[_DVS] != null) {
    contents[_DVS] = exports_dist_es.expectString(output2[_DVS]);
  }
  if (output2[_DDV] != null) {
    contents[_DDV] = exports_dist_es.expectString(output2[_DDV]);
  }
  return contents;
};
var de_CloudWatchDimensionConfigurations = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_CloudWatchDimensionConfiguration(entry, context);
  });
};
var de_ConfigurationSet = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  return contents;
};
var de_ConfigurationSetAlreadyExistsException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_ConfigurationSetDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_ConfigurationSets = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_ConfigurationSet(entry, context);
  });
};
var de_ConfigurationSetSendingPausedException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_ConnectAction = (output2, context) => {
  const contents = {};
  if (output2[_IARN] != null) {
    contents[_IARN] = exports_dist_es.expectString(output2[_IARN]);
  }
  if (output2[_IAMRARN] != null) {
    contents[_IAMRARN] = exports_dist_es.expectString(output2[_IAMRARN]);
  }
  return contents;
};
var de_CreateConfigurationSetEventDestinationResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateConfigurationSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateConfigurationSetTrackingOptionsResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateReceiptFilterResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateReceiptRuleResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CreateTemplateResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_CustomVerificationEmailInvalidContentException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_CustomVerificationEmailTemplate = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_FEA] != null) {
    contents[_FEA] = exports_dist_es.expectString(output2[_FEA]);
  }
  if (output2[_TS] != null) {
    contents[_TS] = exports_dist_es.expectString(output2[_TS]);
  }
  if (output2[_SRURL] != null) {
    contents[_SRURL] = exports_dist_es.expectString(output2[_SRURL]);
  }
  if (output2[_FRURL] != null) {
    contents[_FRURL] = exports_dist_es.expectString(output2[_FRURL]);
  }
  return contents;
};
var de_CustomVerificationEmailTemplateAlreadyExistsException = (output2, context) => {
  const contents = {};
  if (output2[_CVETN] != null) {
    contents[_CVETN] = exports_dist_es.expectString(output2[_CVETN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_CustomVerificationEmailTemplateDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_CVETN] != null) {
    contents[_CVETN] = exports_dist_es.expectString(output2[_CVETN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_CustomVerificationEmailTemplates = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_CustomVerificationEmailTemplate(entry, context);
  });
};
var de_DeleteConfigurationSetEventDestinationResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteConfigurationSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteConfigurationSetTrackingOptionsResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteIdentityPolicyResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteIdentityResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteReceiptFilterResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteReceiptRuleResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeleteTemplateResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_DeliveryOptions = (output2, context) => {
  const contents = {};
  if (output2[_TP] != null) {
    contents[_TP] = exports_dist_es.expectString(output2[_TP]);
  }
  return contents;
};
var de_DescribeActiveReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  if (output2[_Me] != null) {
    contents[_Me] = de_ReceiptRuleSetMetadata(output2[_Me], context);
  }
  if (output2.Rules === "") {
    contents[_Rul] = [];
  } else if (output2[_Rul] != null && output2[_Rul][_me] != null) {
    contents[_Rul] = de_ReceiptRulesList(getArrayIfSingleItem(output2[_Rul][_me]), context);
  }
  return contents;
};
var de_DescribeConfigurationSetResponse = (output2, context) => {
  const contents = {};
  if (output2[_CS] != null) {
    contents[_CS] = de_ConfigurationSet(output2[_CS], context);
  }
  if (output2.EventDestinations === "") {
    contents[_EDv] = [];
  } else if (output2[_EDv] != null && output2[_EDv][_me] != null) {
    contents[_EDv] = de_EventDestinations(getArrayIfSingleItem(output2[_EDv][_me]), context);
  }
  if (output2[_TO] != null) {
    contents[_TO] = de_TrackingOptions(output2[_TO], context);
  }
  if (output2[_DO] != null) {
    contents[_DO] = de_DeliveryOptions(output2[_DO], context);
  }
  if (output2[_RO] != null) {
    contents[_RO] = de_ReputationOptions(output2[_RO], context);
  }
  return contents;
};
var de_DescribeReceiptRuleResponse = (output2, context) => {
  const contents = {};
  if (output2[_Ru] != null) {
    contents[_Ru] = de_ReceiptRule(output2[_Ru], context);
  }
  return contents;
};
var de_DescribeReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  if (output2[_Me] != null) {
    contents[_Me] = de_ReceiptRuleSetMetadata(output2[_Me], context);
  }
  if (output2.Rules === "") {
    contents[_Rul] = [];
  } else if (output2[_Rul] != null && output2[_Rul][_me] != null) {
    contents[_Rul] = de_ReceiptRulesList(getArrayIfSingleItem(output2[_Rul][_me]), context);
  }
  return contents;
};
var de_DkimAttributes = (output2, context) => {
  return output2.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = de_IdentityDkimAttributes(pair["value"], context);
    return acc;
  }, {});
};
var de_EventDestination = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_E] != null) {
    contents[_E] = exports_dist_es.parseBoolean(output2[_E]);
  }
  if (output2.MatchingEventTypes === "") {
    contents[_MET] = [];
  } else if (output2[_MET] != null && output2[_MET][_me] != null) {
    contents[_MET] = de_EventTypes(getArrayIfSingleItem(output2[_MET][_me]), context);
  }
  if (output2[_KFD] != null) {
    contents[_KFD] = de_KinesisFirehoseDestination(output2[_KFD], context);
  }
  if (output2[_CWD] != null) {
    contents[_CWD] = de_CloudWatchDestination(output2[_CWD], context);
  }
  if (output2[_SNSD] != null) {
    contents[_SNSD] = de_SNSDestination(output2[_SNSD], context);
  }
  return contents;
};
var de_EventDestinationAlreadyExistsException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_EDN] != null) {
    contents[_EDN] = exports_dist_es.expectString(output2[_EDN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_EventDestinationDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_EDN] != null) {
    contents[_EDN] = exports_dist_es.expectString(output2[_EDN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_EventDestinations = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_EventDestination(entry, context);
  });
};
var de_EventTypes = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_FromEmailAddressNotVerifiedException = (output2, context) => {
  const contents = {};
  if (output2[_FEA] != null) {
    contents[_FEA] = exports_dist_es.expectString(output2[_FEA]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_GetAccountSendingEnabledResponse = (output2, context) => {
  const contents = {};
  if (output2[_E] != null) {
    contents[_E] = exports_dist_es.parseBoolean(output2[_E]);
  }
  return contents;
};
var de_GetCustomVerificationEmailTemplateResponse = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_FEA] != null) {
    contents[_FEA] = exports_dist_es.expectString(output2[_FEA]);
  }
  if (output2[_TS] != null) {
    contents[_TS] = exports_dist_es.expectString(output2[_TS]);
  }
  if (output2[_TC] != null) {
    contents[_TC] = exports_dist_es.expectString(output2[_TC]);
  }
  if (output2[_SRURL] != null) {
    contents[_SRURL] = exports_dist_es.expectString(output2[_SRURL]);
  }
  if (output2[_FRURL] != null) {
    contents[_FRURL] = exports_dist_es.expectString(output2[_FRURL]);
  }
  return contents;
};
var de_GetIdentityDkimAttributesResponse = (output2, context) => {
  const contents = {};
  if (output2.DkimAttributes === "") {
    contents[_DA] = {};
  } else if (output2[_DA] != null && output2[_DA][_e] != null) {
    contents[_DA] = de_DkimAttributes(getArrayIfSingleItem(output2[_DA][_e]), context);
  }
  return contents;
};
var de_GetIdentityMailFromDomainAttributesResponse = (output2, context) => {
  const contents = {};
  if (output2.MailFromDomainAttributes === "") {
    contents[_MFDA] = {};
  } else if (output2[_MFDA] != null && output2[_MFDA][_e] != null) {
    contents[_MFDA] = de_MailFromDomainAttributes(getArrayIfSingleItem(output2[_MFDA][_e]), context);
  }
  return contents;
};
var de_GetIdentityNotificationAttributesResponse = (output2, context) => {
  const contents = {};
  if (output2.NotificationAttributes === "") {
    contents[_NA] = {};
  } else if (output2[_NA] != null && output2[_NA][_e] != null) {
    contents[_NA] = de_NotificationAttributes(getArrayIfSingleItem(output2[_NA][_e]), context);
  }
  return contents;
};
var de_GetIdentityPoliciesResponse = (output2, context) => {
  const contents = {};
  if (output2.Policies === "") {
    contents[_Po] = {};
  } else if (output2[_Po] != null && output2[_Po][_e] != null) {
    contents[_Po] = de_PolicyMap(getArrayIfSingleItem(output2[_Po][_e]), context);
  }
  return contents;
};
var de_GetIdentityVerificationAttributesResponse = (output2, context) => {
  const contents = {};
  if (output2.VerificationAttributes === "") {
    contents[_VA] = {};
  } else if (output2[_VA] != null && output2[_VA][_e] != null) {
    contents[_VA] = de_VerificationAttributes(getArrayIfSingleItem(output2[_VA][_e]), context);
  }
  return contents;
};
var de_GetSendQuotaResponse = (output2, context) => {
  const contents = {};
  if (output2[_MHS] != null) {
    contents[_MHS] = exports_dist_es.strictParseFloat(output2[_MHS]);
  }
  if (output2[_MSR] != null) {
    contents[_MSR] = exports_dist_es.strictParseFloat(output2[_MSR]);
  }
  if (output2[_SLH] != null) {
    contents[_SLH] = exports_dist_es.strictParseFloat(output2[_SLH]);
  }
  return contents;
};
var de_GetSendStatisticsResponse = (output2, context) => {
  const contents = {};
  if (output2.SendDataPoints === "") {
    contents[_SDP] = [];
  } else if (output2[_SDP] != null && output2[_SDP][_me] != null) {
    contents[_SDP] = de_SendDataPointList(getArrayIfSingleItem(output2[_SDP][_me]), context);
  }
  return contents;
};
var de_GetTemplateResponse = (output2, context) => {
  const contents = {};
  if (output2[_Te] != null) {
    contents[_Te] = de_Template(output2[_Te], context);
  }
  return contents;
};
var de_IdentityDkimAttributes = (output2, context) => {
  const contents = {};
  if (output2[_DE] != null) {
    contents[_DE] = exports_dist_es.parseBoolean(output2[_DE]);
  }
  if (output2[_DVSk] != null) {
    contents[_DVSk] = exports_dist_es.expectString(output2[_DVSk]);
  }
  if (output2.DkimTokens === "") {
    contents[_DTk] = [];
  } else if (output2[_DTk] != null && output2[_DTk][_me] != null) {
    contents[_DTk] = de_VerificationTokenList(getArrayIfSingleItem(output2[_DTk][_me]), context);
  }
  return contents;
};
var de_IdentityList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_IdentityMailFromDomainAttributes = (output2, context) => {
  const contents = {};
  if (output2[_MFD] != null) {
    contents[_MFD] = exports_dist_es.expectString(output2[_MFD]);
  }
  if (output2[_MFDS] != null) {
    contents[_MFDS] = exports_dist_es.expectString(output2[_MFDS]);
  }
  if (output2[_BOMXF] != null) {
    contents[_BOMXF] = exports_dist_es.expectString(output2[_BOMXF]);
  }
  return contents;
};
var de_IdentityNotificationAttributes = (output2, context) => {
  const contents = {};
  if (output2[_BTo] != null) {
    contents[_BTo] = exports_dist_es.expectString(output2[_BTo]);
  }
  if (output2[_CTo] != null) {
    contents[_CTo] = exports_dist_es.expectString(output2[_CTo]);
  }
  if (output2[_DTel] != null) {
    contents[_DTel] = exports_dist_es.expectString(output2[_DTel]);
  }
  if (output2[_FE] != null) {
    contents[_FE] = exports_dist_es.parseBoolean(output2[_FE]);
  }
  if (output2[_HIBNE] != null) {
    contents[_HIBNE] = exports_dist_es.parseBoolean(output2[_HIBNE]);
  }
  if (output2[_HICNE] != null) {
    contents[_HICNE] = exports_dist_es.parseBoolean(output2[_HICNE]);
  }
  if (output2[_HIDNE] != null) {
    contents[_HIDNE] = exports_dist_es.parseBoolean(output2[_HIDNE]);
  }
  return contents;
};
var de_IdentityVerificationAttributes = (output2, context) => {
  const contents = {};
  if (output2[_VS] != null) {
    contents[_VS] = exports_dist_es.expectString(output2[_VS]);
  }
  if (output2[_VT] != null) {
    contents[_VT] = exports_dist_es.expectString(output2[_VT]);
  }
  return contents;
};
var de_InvalidCloudWatchDestinationException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_EDN] != null) {
    contents[_EDN] = exports_dist_es.expectString(output2[_EDN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidConfigurationSetException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidDeliveryOptionsException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidFirehoseDestinationException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_EDN] != null) {
    contents[_EDN] = exports_dist_es.expectString(output2[_EDN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidLambdaFunctionException = (output2, context) => {
  const contents = {};
  if (output2[_FA] != null) {
    contents[_FA] = exports_dist_es.expectString(output2[_FA]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidPolicyException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidRenderingParameterException = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidS3ConfigurationException = (output2, context) => {
  const contents = {};
  if (output2[_Bu] != null) {
    contents[_Bu] = exports_dist_es.expectString(output2[_Bu]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidSNSDestinationException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_EDN] != null) {
    contents[_EDN] = exports_dist_es.expectString(output2[_EDN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidSnsTopicException = (output2, context) => {
  const contents = {};
  if (output2[_To] != null) {
    contents[_To] = exports_dist_es.expectString(output2[_To]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidTemplateException = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_InvalidTrackingOptionsException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_KinesisFirehoseDestination = (output2, context) => {
  const contents = {};
  if (output2[_IAMRARN] != null) {
    contents[_IAMRARN] = exports_dist_es.expectString(output2[_IAMRARN]);
  }
  if (output2[_DSARN] != null) {
    contents[_DSARN] = exports_dist_es.expectString(output2[_DSARN]);
  }
  return contents;
};
var de_LambdaAction = (output2, context) => {
  const contents = {};
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  if (output2[_FA] != null) {
    contents[_FA] = exports_dist_es.expectString(output2[_FA]);
  }
  if (output2[_IT] != null) {
    contents[_IT] = exports_dist_es.expectString(output2[_IT]);
  }
  return contents;
};
var de_LimitExceededException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_ListConfigurationSetsResponse = (output2, context) => {
  const contents = {};
  if (output2.ConfigurationSets === "") {
    contents[_CSo] = [];
  } else if (output2[_CSo] != null && output2[_CSo][_me] != null) {
    contents[_CSo] = de_ConfigurationSets(getArrayIfSingleItem(output2[_CSo][_me]), context);
  }
  if (output2[_NT] != null) {
    contents[_NT] = exports_dist_es.expectString(output2[_NT]);
  }
  return contents;
};
var de_ListCustomVerificationEmailTemplatesResponse = (output2, context) => {
  const contents = {};
  if (output2.CustomVerificationEmailTemplates === "") {
    contents[_CVET] = [];
  } else if (output2[_CVET] != null && output2[_CVET][_me] != null) {
    contents[_CVET] = de_CustomVerificationEmailTemplates(getArrayIfSingleItem(output2[_CVET][_me]), context);
  }
  if (output2[_NT] != null) {
    contents[_NT] = exports_dist_es.expectString(output2[_NT]);
  }
  return contents;
};
var de_ListIdentitiesResponse = (output2, context) => {
  const contents = {};
  if (output2.Identities === "") {
    contents[_Id] = [];
  } else if (output2[_Id] != null && output2[_Id][_me] != null) {
    contents[_Id] = de_IdentityList(getArrayIfSingleItem(output2[_Id][_me]), context);
  }
  if (output2[_NT] != null) {
    contents[_NT] = exports_dist_es.expectString(output2[_NT]);
  }
  return contents;
};
var de_ListIdentityPoliciesResponse = (output2, context) => {
  const contents = {};
  if (output2.PolicyNames === "") {
    contents[_PNo] = [];
  } else if (output2[_PNo] != null && output2[_PNo][_me] != null) {
    contents[_PNo] = de_PolicyNameList(getArrayIfSingleItem(output2[_PNo][_me]), context);
  }
  return contents;
};
var de_ListReceiptFiltersResponse = (output2, context) => {
  const contents = {};
  if (output2.Filters === "") {
    contents[_Fi] = [];
  } else if (output2[_Fi] != null && output2[_Fi][_me] != null) {
    contents[_Fi] = de_ReceiptFilterList(getArrayIfSingleItem(output2[_Fi][_me]), context);
  }
  return contents;
};
var de_ListReceiptRuleSetsResponse = (output2, context) => {
  const contents = {};
  if (output2.RuleSets === "") {
    contents[_RS] = [];
  } else if (output2[_RS] != null && output2[_RS][_me] != null) {
    contents[_RS] = de_ReceiptRuleSetsLists(getArrayIfSingleItem(output2[_RS][_me]), context);
  }
  if (output2[_NT] != null) {
    contents[_NT] = exports_dist_es.expectString(output2[_NT]);
  }
  return contents;
};
var de_ListTemplatesResponse = (output2, context) => {
  const contents = {};
  if (output2.TemplatesMetadata === "") {
    contents[_TM] = [];
  } else if (output2[_TM] != null && output2[_TM][_me] != null) {
    contents[_TM] = de_TemplateMetadataList(getArrayIfSingleItem(output2[_TM][_me]), context);
  }
  if (output2[_NT] != null) {
    contents[_NT] = exports_dist_es.expectString(output2[_NT]);
  }
  return contents;
};
var de_ListVerifiedEmailAddressesResponse = (output2, context) => {
  const contents = {};
  if (output2.VerifiedEmailAddresses === "") {
    contents[_VEAe] = [];
  } else if (output2[_VEAe] != null && output2[_VEAe][_me] != null) {
    contents[_VEAe] = de_AddressList(getArrayIfSingleItem(output2[_VEAe][_me]), context);
  }
  return contents;
};
var de_MailFromDomainAttributes = (output2, context) => {
  return output2.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = de_IdentityMailFromDomainAttributes(pair["value"], context);
    return acc;
  }, {});
};
var de_MailFromDomainNotVerifiedException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_MessageRejected = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_MissingRenderingAttributeException = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_NotificationAttributes = (output2, context) => {
  return output2.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = de_IdentityNotificationAttributes(pair["value"], context);
    return acc;
  }, {});
};
var de_PolicyMap = (output2, context) => {
  return output2.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = exports_dist_es.expectString(pair["value"]);
    return acc;
  }, {});
};
var de_PolicyNameList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_ProductionAccessNotGrantedException = (output2, context) => {
  const contents = {};
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_PutConfigurationSetDeliveryOptionsResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_PutIdentityPolicyResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_ReceiptAction = (output2, context) => {
  const contents = {};
  if (output2[_SA] != null) {
    contents[_SA] = de_S3Action(output2[_SA], context);
  }
  if (output2[_BAo] != null) {
    contents[_BAo] = de_BounceAction(output2[_BAo], context);
  }
  if (output2[_WA] != null) {
    contents[_WA] = de_WorkmailAction(output2[_WA], context);
  }
  if (output2[_LA] != null) {
    contents[_LA] = de_LambdaAction(output2[_LA], context);
  }
  if (output2[_SAt] != null) {
    contents[_SAt] = de_StopAction(output2[_SAt], context);
  }
  if (output2[_AHA] != null) {
    contents[_AHA] = de_AddHeaderAction(output2[_AHA], context);
  }
  if (output2[_SNSA] != null) {
    contents[_SNSA] = de_SNSAction(output2[_SNSA], context);
  }
  if (output2[_CAo] != null) {
    contents[_CAo] = de_ConnectAction(output2[_CAo], context);
  }
  return contents;
};
var de_ReceiptActionsList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_ReceiptAction(entry, context);
  });
};
var de_ReceiptFilter = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_IF] != null) {
    contents[_IF] = de_ReceiptIpFilter(output2[_IF], context);
  }
  return contents;
};
var de_ReceiptFilterList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_ReceiptFilter(entry, context);
  });
};
var de_ReceiptIpFilter = (output2, context) => {
  const contents = {};
  if (output2[_P] != null) {
    contents[_P] = exports_dist_es.expectString(output2[_P]);
  }
  if (output2[_Ci] != null) {
    contents[_Ci] = exports_dist_es.expectString(output2[_Ci]);
  }
  return contents;
};
var de_ReceiptRule = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_E] != null) {
    contents[_E] = exports_dist_es.parseBoolean(output2[_E]);
  }
  if (output2[_TP] != null) {
    contents[_TP] = exports_dist_es.expectString(output2[_TP]);
  }
  if (output2.Recipients === "") {
    contents[_Re] = [];
  } else if (output2[_Re] != null && output2[_Re][_me] != null) {
    contents[_Re] = de_RecipientsList(getArrayIfSingleItem(output2[_Re][_me]), context);
  }
  if (output2.Actions === "") {
    contents[_Ac] = [];
  } else if (output2[_Ac] != null && output2[_Ac][_me] != null) {
    contents[_Ac] = de_ReceiptActionsList(getArrayIfSingleItem(output2[_Ac][_me]), context);
  }
  if (output2[_SEc] != null) {
    contents[_SEc] = exports_dist_es.parseBoolean(output2[_SEc]);
  }
  return contents;
};
var de_ReceiptRuleSetMetadata = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_CTr] != null) {
    contents[_CTr] = exports_dist_es.expectNonNull(exports_dist_es.parseRfc3339DateTimeWithOffset(output2[_CTr]));
  }
  return contents;
};
var de_ReceiptRuleSetsLists = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_ReceiptRuleSetMetadata(entry, context);
  });
};
var de_ReceiptRulesList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_ReceiptRule(entry, context);
  });
};
var de_RecipientsList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_ReorderReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_ReputationOptions = (output2, context) => {
  const contents = {};
  if (output2[_SEe] != null) {
    contents[_SEe] = exports_dist_es.parseBoolean(output2[_SEe]);
  }
  if (output2[_RME] != null) {
    contents[_RME] = exports_dist_es.parseBoolean(output2[_RME]);
  }
  if (output2[_LFS] != null) {
    contents[_LFS] = exports_dist_es.expectNonNull(exports_dist_es.parseRfc3339DateTimeWithOffset(output2[_LFS]));
  }
  return contents;
};
var de_RuleDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_RuleSetDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_S3Action = (output2, context) => {
  const contents = {};
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  if (output2[_BN] != null) {
    contents[_BN] = exports_dist_es.expectString(output2[_BN]);
  }
  if (output2[_OKP] != null) {
    contents[_OKP] = exports_dist_es.expectString(output2[_OKP]);
  }
  if (output2[_KKA] != null) {
    contents[_KKA] = exports_dist_es.expectString(output2[_KKA]);
  }
  if (output2[_IRA] != null) {
    contents[_IRA] = exports_dist_es.expectString(output2[_IRA]);
  }
  return contents;
};
var de_SendBounceResponse = (output2, context) => {
  const contents = {};
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_SendBulkTemplatedEmailResponse = (output2, context) => {
  const contents = {};
  if (output2.Status === "") {
    contents[_St] = [];
  } else if (output2[_St] != null && output2[_St][_me] != null) {
    contents[_St] = de_BulkEmailDestinationStatusList(getArrayIfSingleItem(output2[_St][_me]), context);
  }
  return contents;
};
var de_SendCustomVerificationEmailResponse = (output2, context) => {
  const contents = {};
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_SendDataPoint = (output2, context) => {
  const contents = {};
  if (output2[_Ti] != null) {
    contents[_Ti] = exports_dist_es.expectNonNull(exports_dist_es.parseRfc3339DateTimeWithOffset(output2[_Ti]));
  }
  if (output2[_DAe] != null) {
    contents[_DAe] = exports_dist_es.strictParseLong(output2[_DAe]);
  }
  if (output2[_Bo] != null) {
    contents[_Bo] = exports_dist_es.strictParseLong(output2[_Bo]);
  }
  if (output2[_Co] != null) {
    contents[_Co] = exports_dist_es.strictParseLong(output2[_Co]);
  }
  if (output2[_Rej] != null) {
    contents[_Rej] = exports_dist_es.strictParseLong(output2[_Rej]);
  }
  return contents;
};
var de_SendDataPointList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_SendDataPoint(entry, context);
  });
};
var de_SendEmailResponse = (output2, context) => {
  const contents = {};
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_SendRawEmailResponse = (output2, context) => {
  const contents = {};
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_SendTemplatedEmailResponse = (output2, context) => {
  const contents = {};
  if (output2[_MIe] != null) {
    contents[_MIe] = exports_dist_es.expectString(output2[_MIe]);
  }
  return contents;
};
var de_SetActiveReceiptRuleSetResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetIdentityDkimEnabledResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetIdentityFeedbackForwardingEnabledResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetIdentityHeadersInNotificationsEnabledResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetIdentityMailFromDomainResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetIdentityNotificationTopicResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SetReceiptRulePositionResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_SNSAction = (output2, context) => {
  const contents = {};
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  if (output2[_En] != null) {
    contents[_En] = exports_dist_es.expectString(output2[_En]);
  }
  return contents;
};
var de_SNSDestination = (output2, context) => {
  const contents = {};
  if (output2[_TARN] != null) {
    contents[_TARN] = exports_dist_es.expectString(output2[_TARN]);
  }
  return contents;
};
var de_StopAction = (output2, context) => {
  const contents = {};
  if (output2[_Sc] != null) {
    contents[_Sc] = exports_dist_es.expectString(output2[_Sc]);
  }
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  return contents;
};
var de_Template = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_SP] != null) {
    contents[_SP] = exports_dist_es.expectString(output2[_SP]);
  }
  if (output2[_TPe] != null) {
    contents[_TPe] = exports_dist_es.expectString(output2[_TPe]);
  }
  if (output2[_HP] != null) {
    contents[_HP] = exports_dist_es.expectString(output2[_HP]);
  }
  return contents;
};
var de_TemplateDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_TN] != null) {
    contents[_TN] = exports_dist_es.expectString(output2[_TN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_TemplateMetadata = (output2, context) => {
  const contents = {};
  if (output2[_N] != null) {
    contents[_N] = exports_dist_es.expectString(output2[_N]);
  }
  if (output2[_CTr] != null) {
    contents[_CTr] = exports_dist_es.expectNonNull(exports_dist_es.parseRfc3339DateTimeWithOffset(output2[_CTr]));
  }
  return contents;
};
var de_TemplateMetadataList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return de_TemplateMetadata(entry, context);
  });
};
var de_TestRenderTemplateResponse = (output2, context) => {
  const contents = {};
  if (output2[_RTe] != null) {
    contents[_RTe] = exports_dist_es.expectString(output2[_RTe]);
  }
  return contents;
};
var de_TrackingOptions = (output2, context) => {
  const contents = {};
  if (output2[_CRD] != null) {
    contents[_CRD] = exports_dist_es.expectString(output2[_CRD]);
  }
  return contents;
};
var de_TrackingOptionsAlreadyExistsException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_TrackingOptionsDoesNotExistException = (output2, context) => {
  const contents = {};
  if (output2[_CSN] != null) {
    contents[_CSN] = exports_dist_es.expectString(output2[_CSN]);
  }
  if (output2[_m] != null) {
    contents[_m] = exports_dist_es.expectString(output2[_m]);
  }
  return contents;
};
var de_UpdateConfigurationSetEventDestinationResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_UpdateConfigurationSetTrackingOptionsResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_UpdateReceiptRuleResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_UpdateTemplateResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_VerificationAttributes = (output2, context) => {
  return output2.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = de_IdentityVerificationAttributes(pair["value"], context);
    return acc;
  }, {});
};
var de_VerificationTokenList = (output2, context) => {
  return (output2 || []).filter((e3) => e3 != null).map((entry) => {
    return exports_dist_es.expectString(entry);
  });
};
var de_VerifyDomainDkimResponse = (output2, context) => {
  const contents = {};
  if (output2.DkimTokens === "") {
    contents[_DTk] = [];
  } else if (output2[_DTk] != null && output2[_DTk][_me] != null) {
    contents[_DTk] = de_VerificationTokenList(getArrayIfSingleItem(output2[_DTk][_me]), context);
  }
  return contents;
};
var de_VerifyDomainIdentityResponse = (output2, context) => {
  const contents = {};
  if (output2[_VT] != null) {
    contents[_VT] = exports_dist_es.expectString(output2[_VT]);
  }
  return contents;
};
var de_VerifyEmailIdentityResponse = (output2, context) => {
  const contents = {};
  return contents;
};
var de_WorkmailAction = (output2, context) => {
  const contents = {};
  if (output2[_TA] != null) {
    contents[_TA] = exports_dist_es.expectString(output2[_TA]);
  }
  if (output2[_OA] != null) {
    contents[_OA] = exports_dist_es.expectString(output2[_OA]);
  }
  return contents;
};
var deserializeMetadata = (output2) => ({
  httpStatusCode: output2.statusCode,
  requestId: output2.headers["x-amzn-requestid"] ?? output2.headers["x-amzn-request-id"] ?? output2.headers["x-amz-request-id"],
  extendedRequestId: output2.headers["x-amz-id-2"],
  cfId: output2.headers["x-amz-cf-id"]
});
var throwDefaultError = withBaseException(SESServiceException);
var buildHttpRpcRequest = async (context, headers, path3, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path3 : basePath + path3,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var SHARED_HEADERS = {
  "content-type": "application/x-www-form-urlencoded"
};
var _ = "2010-12-01";
var _A = "Action";
var _AD = "ArrivalDate";
var _AHA = "AddHeaderAction";
var _Ac = "Actions";
var _Af = "After";
var _B = "Body";
var _BA = "BccAddresses";
var _BAo = "BounceAction";
var _BN = "BucketName";
var _BOMXF = "BehaviorOnMXFailure";
var _BRIL = "BouncedRecipientInfoList";
var _BS = "BounceSender";
var _BSA = "BounceSenderArn";
var _BT = "BounceType";
var _BTo = "BounceTopic";
var _Bo = "Bounces";
var _Bu = "Bucket";
var _C = "Charset";
var _CA = "CcAddresses";
var _CAo = "ConnectAction";
var _CCS = "CreateConfigurationSet";
var _CCSED = "CreateConfigurationSetEventDestination";
var _CCSTO = "CreateConfigurationSetTrackingOptions";
var _CCVET = "CreateCustomVerificationEmailTemplate";
var _CRD = "CustomRedirectDomain";
var _CRF = "CreateReceiptFilter";
var _CRR = "CreateReceiptRule";
var _CRRS = "CloneReceiptRuleSet";
var _CRRSr = "CreateReceiptRuleSet";
var _CS = "ConfigurationSet";
var _CSAN = "ConfigurationSetAttributeNames";
var _CSN = "ConfigurationSetName";
var _CSo = "ConfigurationSets";
var _CT = "CreateTemplate";
var _CTo = "ComplaintTopic";
var _CTr = "CreatedTimestamp";
var _CVET = "CustomVerificationEmailTemplates";
var _CVETN = "CustomVerificationEmailTemplateName";
var _CWD = "CloudWatchDestination";
var _Ci = "Cidr";
var _Co = "Complaints";
var _D = "Destination";
var _DA = "DkimAttributes";
var _DARRS = "DescribeActiveReceiptRuleSet";
var _DAe = "DeliveryAttempts";
var _DC = "DimensionConfigurations";
var _DCS = "DeleteConfigurationSet";
var _DCSED = "DeleteConfigurationSetEventDestination";
var _DCSTO = "DeleteConfigurationSetTrackingOptions";
var _DCSe = "DescribeConfigurationSet";
var _DCVET = "DeleteCustomVerificationEmailTemplate";
var _DCi = "DiagnosticCode";
var _DDV = "DefaultDimensionValue";
var _DE = "DkimEnabled";
var _DI = "DeleteIdentity";
var _DIP = "DeleteIdentityPolicy";
var _DN = "DimensionName";
var _DO = "DeliveryOptions";
var _DRF = "DeleteReceiptFilter";
var _DRR = "DeleteReceiptRule";
var _DRRS = "DeleteReceiptRuleSet";
var _DRRSe = "DescribeReceiptRuleSet";
var _DRRe = "DescribeReceiptRule";
var _DSARN = "DeliveryStreamARN";
var _DT = "DeleteTemplate";
var _DTD = "DefaultTemplateData";
var _DTe = "DefaultTags";
var _DTel = "DeliveryTopic";
var _DTk = "DkimTokens";
var _DVEA = "DeleteVerifiedEmailAddress";
var _DVS = "DimensionValueSource";
var _DVSk = "DkimVerificationStatus";
var _Da = "Data";
var _De = "Destinations";
var _Do = "Domain";
var _E = "Enabled";
var _EA = "EmailAddress";
var _ED = "EventDestination";
var _EDN = "EventDestinationName";
var _EDv = "EventDestinations";
var _EF = "ExtensionFields";
var _En = "Encoding";
var _Er = "Error";
var _Ex = "Explanation";
var _F = "Filter";
var _FA = "FunctionArn";
var _FAr = "FromArn";
var _FE = "ForwardingEnabled";
var _FEA = "FromEmailAddress";
var _FN = "FilterName";
var _FR = "FinalRecipient";
var _FRURL = "FailureRedirectionURL";
var _Fi = "Filters";
var _GASE = "GetAccountSendingEnabled";
var _GCVET = "GetCustomVerificationEmailTemplate";
var _GIDA = "GetIdentityDkimAttributes";
var _GIMFDA = "GetIdentityMailFromDomainAttributes";
var _GINA = "GetIdentityNotificationAttributes";
var _GIP = "GetIdentityPolicies";
var _GIVA = "GetIdentityVerificationAttributes";
var _GSQ = "GetSendQuota";
var _GSS = "GetSendStatistics";
var _GT = "GetTemplate";
var _H = "Html";
var _HIBNE = "HeadersInBounceNotificationsEnabled";
var _HICNE = "HeadersInComplaintNotificationsEnabled";
var _HIDNE = "HeadersInDeliveryNotificationsEnabled";
var _HN = "HeaderName";
var _HP = "HtmlPart";
var _HV = "HeaderValue";
var _I = "Identity";
var _IAMRARN = "IAMRoleARN";
var _IARN = "InstanceARN";
var _IF = "IpFilter";
var _IRA = "IamRoleArn";
var _IT = "InvocationType";
var _ITd = "IdentityType";
var _Id = "Identities";
var _KFD = "KinesisFirehoseDestination";
var _KKA = "KmsKeyArn";
var _LA = "LambdaAction";
var _LAD = "LastAttemptDate";
var _LCS = "ListConfigurationSets";
var _LCVET = "ListCustomVerificationEmailTemplates";
var _LFS = "LastFreshStart";
var _LI = "ListIdentities";
var _LIP = "ListIdentityPolicies";
var _LRF = "ListReceiptFilters";
var _LRRS = "ListReceiptRuleSets";
var _LT = "ListTemplates";
var _LVEA = "ListVerifiedEmailAddresses";
var _M = "Message";
var _MD = "MessageDsn";
var _MET = "MatchingEventTypes";
var _MFD = "MailFromDomain";
var _MFDA = "MailFromDomainAttributes";
var _MFDS = "MailFromDomainStatus";
var _MHS = "Max24HourSend";
var _MI = "MaxItems";
var _MIe = "MessageId";
var _MR = "MaxResults";
var _MSR = "MaxSendRate";
var _Me = "Metadata";
var _N = "Name";
var _NA = "NotificationAttributes";
var _NT = "NextToken";
var _NTo = "NotificationType";
var _OA = "OrganizationArn";
var _OKP = "ObjectKeyPrefix";
var _OMI = "OriginalMessageId";
var _ORSN = "OriginalRuleSetName";
var _P = "Policy";
var _PCSDO = "PutConfigurationSetDeliveryOptions";
var _PIP = "PutIdentityPolicy";
var _PN = "PolicyName";
var _PNo = "PolicyNames";
var _Po = "Policies";
var _R = "Recipient";
var _RA = "RecipientArn";
var _RDF = "RecipientDsnFields";
var _RM = "ReportingMta";
var _RME = "ReputationMetricsEnabled";
var _RMa = "RawMessage";
var _RMe = "RemoteMta";
var _RN = "RuleName";
var _RNu = "RuleNames";
var _RO = "ReputationOptions";
var _RP = "ReturnPath";
var _RPA = "ReturnPathArn";
var _RRRS = "ReorderReceiptRuleSet";
var _RS = "RuleSets";
var _RSN = "RuleSetName";
var _RT = "ReplacementTags";
var _RTA = "ReplyToAddresses";
var _RTD = "ReplacementTemplateData";
var _RTe = "RenderedTemplate";
var _Re = "Recipients";
var _Rej = "Rejects";
var _Ru = "Rule";
var _Rul = "Rules";
var _S = "Sender";
var _SA = "S3Action";
var _SARRS = "SetActiveReceiptRuleSet";
var _SAo = "SourceArn";
var _SAt = "StopAction";
var _SB = "SendBounce";
var _SBTE = "SendBulkTemplatedEmail";
var _SC = "StatusCode";
var _SCVE = "SendCustomVerificationEmail";
var _SDP = "SendDataPoints";
var _SE = "SendEmail";
var _SEc = "ScanEnabled";
var _SEe = "SendingEnabled";
var _SIDE = "SetIdentityDkimEnabled";
var _SIFFE = "SetIdentityFeedbackForwardingEnabled";
var _SIHINE = "SetIdentityHeadersInNotificationsEnabled";
var _SIMFD = "SetIdentityMailFromDomain";
var _SINT = "SetIdentityNotificationTopic";
var _SLH = "SentLast24Hours";
var _SNSA = "SNSAction";
var _SNSD = "SNSDestination";
var _SP = "SubjectPart";
var _SRC = "SmtpReplyCode";
var _SRE = "SendRawEmail";
var _SRRP = "SetReceiptRulePosition";
var _SRURL = "SuccessRedirectionURL";
var _ST = "SnsTopic";
var _STE = "SendTemplatedEmail";
var _Sc = "Scope";
var _So = "Source";
var _St = "Status";
var _Su = "Subject";
var _T = "Text";
var _TA = "TopicArn";
var _TARN = "TopicARN";
var _TAe = "TemplateArn";
var _TAo = "ToAddresses";
var _TC = "TemplateContent";
var _TD = "TemplateData";
var _TM = "TemplatesMetadata";
var _TN = "TemplateName";
var _TO = "TrackingOptions";
var _TP = "TlsPolicy";
var _TPe = "TextPart";
var _TRT = "TestRenderTemplate";
var _TS = "TemplateSubject";
var _Ta = "Tags";
var _Te = "Template";
var _Ti = "Timestamp";
var _To = "Topic";
var _UASE = "UpdateAccountSendingEnabled";
var _UCSED = "UpdateConfigurationSetEventDestination";
var _UCSRME = "UpdateConfigurationSetReputationMetricsEnabled";
var _UCSSE = "UpdateConfigurationSetSendingEnabled";
var _UCSTO = "UpdateConfigurationSetTrackingOptions";
var _UCVET = "UpdateCustomVerificationEmailTemplate";
var _URR = "UpdateReceiptRule";
var _UT = "UpdateTemplate";
var _V = "Version";
var _VA = "VerificationAttributes";
var _VDD = "VerifyDomainDkim";
var _VDI = "VerifyDomainIdentity";
var _VEA = "VerifyEmailAddress";
var _VEAe = "VerifiedEmailAddresses";
var _VEI = "VerifyEmailIdentity";
var _VS = "VerificationStatus";
var _VT = "VerificationToken";
var _Va = "Value";
var _WA = "WorkmailAction";
var _e = "entry";
var _m = "message";
var _me = "member";
var buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => import_protocols2.extendedEncodeURIComponent(key) + "=" + import_protocols2.extendedEncodeURIComponent(value)).join("&");
var loadQueryErrorCode = (output2, data) => {
  if (data.Error?.Code !== undefined) {
    return data.Error.Code;
  }
  if (output2.statusCode == 404) {
    return "NotFound";
  }
};

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CloneReceiptRuleSetCommand.js
class CloneReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CloneReceiptRuleSet", {}).n("SESClient", "CloneReceiptRuleSetCommand").f(undefined, undefined).ser(se_CloneReceiptRuleSetCommand).de(de_CloneReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateConfigurationSetCommand.js
class CreateConfigurationSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateConfigurationSet", {}).n("SESClient", "CreateConfigurationSetCommand").f(undefined, undefined).ser(se_CreateConfigurationSetCommand).de(de_CreateConfigurationSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateConfigurationSetEventDestinationCommand.js
class CreateConfigurationSetEventDestinationCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateConfigurationSetEventDestination", {}).n("SESClient", "CreateConfigurationSetEventDestinationCommand").f(undefined, undefined).ser(se_CreateConfigurationSetEventDestinationCommand).de(de_CreateConfigurationSetEventDestinationCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateConfigurationSetTrackingOptionsCommand.js
class CreateConfigurationSetTrackingOptionsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateConfigurationSetTrackingOptions", {}).n("SESClient", "CreateConfigurationSetTrackingOptionsCommand").f(undefined, undefined).ser(se_CreateConfigurationSetTrackingOptionsCommand).de(de_CreateConfigurationSetTrackingOptionsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateCustomVerificationEmailTemplateCommand.js
class CreateCustomVerificationEmailTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateCustomVerificationEmailTemplate", {}).n("SESClient", "CreateCustomVerificationEmailTemplateCommand").f(undefined, undefined).ser(se_CreateCustomVerificationEmailTemplateCommand).de(de_CreateCustomVerificationEmailTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateReceiptFilterCommand.js
class CreateReceiptFilterCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateReceiptFilter", {}).n("SESClient", "CreateReceiptFilterCommand").f(undefined, undefined).ser(se_CreateReceiptFilterCommand).de(de_CreateReceiptFilterCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateReceiptRuleCommand.js
class CreateReceiptRuleCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateReceiptRule", {}).n("SESClient", "CreateReceiptRuleCommand").f(undefined, undefined).ser(se_CreateReceiptRuleCommand).de(de_CreateReceiptRuleCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateReceiptRuleSetCommand.js
class CreateReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateReceiptRuleSet", {}).n("SESClient", "CreateReceiptRuleSetCommand").f(undefined, undefined).ser(se_CreateReceiptRuleSetCommand).de(de_CreateReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/CreateTemplateCommand.js
class CreateTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "CreateTemplate", {}).n("SESClient", "CreateTemplateCommand").f(undefined, undefined).ser(se_CreateTemplateCommand).de(de_CreateTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteConfigurationSetCommand.js
class DeleteConfigurationSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteConfigurationSet", {}).n("SESClient", "DeleteConfigurationSetCommand").f(undefined, undefined).ser(se_DeleteConfigurationSetCommand).de(de_DeleteConfigurationSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteConfigurationSetEventDestinationCommand.js
class DeleteConfigurationSetEventDestinationCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteConfigurationSetEventDestination", {}).n("SESClient", "DeleteConfigurationSetEventDestinationCommand").f(undefined, undefined).ser(se_DeleteConfigurationSetEventDestinationCommand).de(de_DeleteConfigurationSetEventDestinationCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteConfigurationSetTrackingOptionsCommand.js
class DeleteConfigurationSetTrackingOptionsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteConfigurationSetTrackingOptions", {}).n("SESClient", "DeleteConfigurationSetTrackingOptionsCommand").f(undefined, undefined).ser(se_DeleteConfigurationSetTrackingOptionsCommand).de(de_DeleteConfigurationSetTrackingOptionsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteCustomVerificationEmailTemplateCommand.js
class DeleteCustomVerificationEmailTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteCustomVerificationEmailTemplate", {}).n("SESClient", "DeleteCustomVerificationEmailTemplateCommand").f(undefined, undefined).ser(se_DeleteCustomVerificationEmailTemplateCommand).de(de_DeleteCustomVerificationEmailTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteIdentityCommand.js
class DeleteIdentityCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteIdentity", {}).n("SESClient", "DeleteIdentityCommand").f(undefined, undefined).ser(se_DeleteIdentityCommand).de(de_DeleteIdentityCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteIdentityPolicyCommand.js
class DeleteIdentityPolicyCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteIdentityPolicy", {}).n("SESClient", "DeleteIdentityPolicyCommand").f(undefined, undefined).ser(se_DeleteIdentityPolicyCommand).de(de_DeleteIdentityPolicyCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteReceiptFilterCommand.js
class DeleteReceiptFilterCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteReceiptFilter", {}).n("SESClient", "DeleteReceiptFilterCommand").f(undefined, undefined).ser(se_DeleteReceiptFilterCommand).de(de_DeleteReceiptFilterCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteReceiptRuleCommand.js
class DeleteReceiptRuleCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteReceiptRule", {}).n("SESClient", "DeleteReceiptRuleCommand").f(undefined, undefined).ser(se_DeleteReceiptRuleCommand).de(de_DeleteReceiptRuleCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteReceiptRuleSetCommand.js
class DeleteReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteReceiptRuleSet", {}).n("SESClient", "DeleteReceiptRuleSetCommand").f(undefined, undefined).ser(se_DeleteReceiptRuleSetCommand).de(de_DeleteReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteTemplateCommand.js
class DeleteTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteTemplate", {}).n("SESClient", "DeleteTemplateCommand").f(undefined, undefined).ser(se_DeleteTemplateCommand).de(de_DeleteTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DeleteVerifiedEmailAddressCommand.js
class DeleteVerifiedEmailAddressCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DeleteVerifiedEmailAddress", {}).n("SESClient", "DeleteVerifiedEmailAddressCommand").f(undefined, undefined).ser(se_DeleteVerifiedEmailAddressCommand).de(de_DeleteVerifiedEmailAddressCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DescribeActiveReceiptRuleSetCommand.js
class DescribeActiveReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DescribeActiveReceiptRuleSet", {}).n("SESClient", "DescribeActiveReceiptRuleSetCommand").f(undefined, undefined).ser(se_DescribeActiveReceiptRuleSetCommand).de(de_DescribeActiveReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DescribeConfigurationSetCommand.js
class DescribeConfigurationSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DescribeConfigurationSet", {}).n("SESClient", "DescribeConfigurationSetCommand").f(undefined, undefined).ser(se_DescribeConfigurationSetCommand).de(de_DescribeConfigurationSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DescribeReceiptRuleCommand.js
class DescribeReceiptRuleCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DescribeReceiptRule", {}).n("SESClient", "DescribeReceiptRuleCommand").f(undefined, undefined).ser(se_DescribeReceiptRuleCommand).de(de_DescribeReceiptRuleCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/DescribeReceiptRuleSetCommand.js
class DescribeReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "DescribeReceiptRuleSet", {}).n("SESClient", "DescribeReceiptRuleSetCommand").f(undefined, undefined).ser(se_DescribeReceiptRuleSetCommand).de(de_DescribeReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetAccountSendingEnabledCommand.js
class GetAccountSendingEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetAccountSendingEnabled", {}).n("SESClient", "GetAccountSendingEnabledCommand").f(undefined, undefined).ser(se_GetAccountSendingEnabledCommand).de(de_GetAccountSendingEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetCustomVerificationEmailTemplateCommand.js
class GetCustomVerificationEmailTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetCustomVerificationEmailTemplate", {}).n("SESClient", "GetCustomVerificationEmailTemplateCommand").f(undefined, undefined).ser(se_GetCustomVerificationEmailTemplateCommand).de(de_GetCustomVerificationEmailTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityDkimAttributesCommand.js
class GetIdentityDkimAttributesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetIdentityDkimAttributes", {}).n("SESClient", "GetIdentityDkimAttributesCommand").f(undefined, undefined).ser(se_GetIdentityDkimAttributesCommand).de(de_GetIdentityDkimAttributesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityMailFromDomainAttributesCommand.js
class GetIdentityMailFromDomainAttributesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetIdentityMailFromDomainAttributes", {}).n("SESClient", "GetIdentityMailFromDomainAttributesCommand").f(undefined, undefined).ser(se_GetIdentityMailFromDomainAttributesCommand).de(de_GetIdentityMailFromDomainAttributesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityNotificationAttributesCommand.js
class GetIdentityNotificationAttributesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetIdentityNotificationAttributes", {}).n("SESClient", "GetIdentityNotificationAttributesCommand").f(undefined, undefined).ser(se_GetIdentityNotificationAttributesCommand).de(de_GetIdentityNotificationAttributesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityPoliciesCommand.js
class GetIdentityPoliciesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetIdentityPolicies", {}).n("SESClient", "GetIdentityPoliciesCommand").f(undefined, undefined).ser(se_GetIdentityPoliciesCommand).de(de_GetIdentityPoliciesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityVerificationAttributesCommand.js
class GetIdentityVerificationAttributesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetIdentityVerificationAttributes", {}).n("SESClient", "GetIdentityVerificationAttributesCommand").f(undefined, undefined).ser(se_GetIdentityVerificationAttributesCommand).de(de_GetIdentityVerificationAttributesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetSendQuotaCommand.js
class GetSendQuotaCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetSendQuota", {}).n("SESClient", "GetSendQuotaCommand").f(undefined, undefined).ser(se_GetSendQuotaCommand).de(de_GetSendQuotaCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetSendStatisticsCommand.js
class GetSendStatisticsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetSendStatistics", {}).n("SESClient", "GetSendStatisticsCommand").f(undefined, undefined).ser(se_GetSendStatisticsCommand).de(de_GetSendStatisticsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/GetTemplateCommand.js
class GetTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "GetTemplate", {}).n("SESClient", "GetTemplateCommand").f(undefined, undefined).ser(se_GetTemplateCommand).de(de_GetTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListConfigurationSetsCommand.js
class ListConfigurationSetsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListConfigurationSets", {}).n("SESClient", "ListConfigurationSetsCommand").f(undefined, undefined).ser(se_ListConfigurationSetsCommand).de(de_ListConfigurationSetsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListCustomVerificationEmailTemplatesCommand.js
class ListCustomVerificationEmailTemplatesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListCustomVerificationEmailTemplates", {}).n("SESClient", "ListCustomVerificationEmailTemplatesCommand").f(undefined, undefined).ser(se_ListCustomVerificationEmailTemplatesCommand).de(de_ListCustomVerificationEmailTemplatesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListIdentitiesCommand.js
class ListIdentitiesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListIdentities", {}).n("SESClient", "ListIdentitiesCommand").f(undefined, undefined).ser(se_ListIdentitiesCommand).de(de_ListIdentitiesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListIdentityPoliciesCommand.js
class ListIdentityPoliciesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListIdentityPolicies", {}).n("SESClient", "ListIdentityPoliciesCommand").f(undefined, undefined).ser(se_ListIdentityPoliciesCommand).de(de_ListIdentityPoliciesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListReceiptFiltersCommand.js
class ListReceiptFiltersCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListReceiptFilters", {}).n("SESClient", "ListReceiptFiltersCommand").f(undefined, undefined).ser(se_ListReceiptFiltersCommand).de(de_ListReceiptFiltersCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListReceiptRuleSetsCommand.js
class ListReceiptRuleSetsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListReceiptRuleSets", {}).n("SESClient", "ListReceiptRuleSetsCommand").f(undefined, undefined).ser(se_ListReceiptRuleSetsCommand).de(de_ListReceiptRuleSetsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListTemplatesCommand.js
class ListTemplatesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListTemplates", {}).n("SESClient", "ListTemplatesCommand").f(undefined, undefined).ser(se_ListTemplatesCommand).de(de_ListTemplatesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ListVerifiedEmailAddressesCommand.js
class ListVerifiedEmailAddressesCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ListVerifiedEmailAddresses", {}).n("SESClient", "ListVerifiedEmailAddressesCommand").f(undefined, undefined).ser(se_ListVerifiedEmailAddressesCommand).de(de_ListVerifiedEmailAddressesCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/PutConfigurationSetDeliveryOptionsCommand.js
class PutConfigurationSetDeliveryOptionsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "PutConfigurationSetDeliveryOptions", {}).n("SESClient", "PutConfigurationSetDeliveryOptionsCommand").f(undefined, undefined).ser(se_PutConfigurationSetDeliveryOptionsCommand).de(de_PutConfigurationSetDeliveryOptionsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/PutIdentityPolicyCommand.js
class PutIdentityPolicyCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "PutIdentityPolicy", {}).n("SESClient", "PutIdentityPolicyCommand").f(undefined, undefined).ser(se_PutIdentityPolicyCommand).de(de_PutIdentityPolicyCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/ReorderReceiptRuleSetCommand.js
class ReorderReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "ReorderReceiptRuleSet", {}).n("SESClient", "ReorderReceiptRuleSetCommand").f(undefined, undefined).ser(se_ReorderReceiptRuleSetCommand).de(de_ReorderReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendBounceCommand.js
class SendBounceCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendBounce", {}).n("SESClient", "SendBounceCommand").f(undefined, undefined).ser(se_SendBounceCommand).de(de_SendBounceCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendBulkTemplatedEmailCommand.js
class SendBulkTemplatedEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendBulkTemplatedEmail", {}).n("SESClient", "SendBulkTemplatedEmailCommand").f(undefined, undefined).ser(se_SendBulkTemplatedEmailCommand).de(de_SendBulkTemplatedEmailCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendCustomVerificationEmailCommand.js
class SendCustomVerificationEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendCustomVerificationEmail", {}).n("SESClient", "SendCustomVerificationEmailCommand").f(undefined, undefined).ser(se_SendCustomVerificationEmailCommand).de(de_SendCustomVerificationEmailCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendEmailCommand.js
class SendEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendEmail", {}).n("SESClient", "SendEmailCommand").f(undefined, undefined).ser(se_SendEmailCommand).de(de_SendEmailCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendRawEmailCommand.js
class SendRawEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendRawEmail", {}).n("SESClient", "SendRawEmailCommand").f(undefined, undefined).ser(se_SendRawEmailCommand).de(de_SendRawEmailCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SendTemplatedEmailCommand.js
class SendTemplatedEmailCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SendTemplatedEmail", {}).n("SESClient", "SendTemplatedEmailCommand").f(undefined, undefined).ser(se_SendTemplatedEmailCommand).de(de_SendTemplatedEmailCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetActiveReceiptRuleSetCommand.js
class SetActiveReceiptRuleSetCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetActiveReceiptRuleSet", {}).n("SESClient", "SetActiveReceiptRuleSetCommand").f(undefined, undefined).ser(se_SetActiveReceiptRuleSetCommand).de(de_SetActiveReceiptRuleSetCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetIdentityDkimEnabledCommand.js
class SetIdentityDkimEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetIdentityDkimEnabled", {}).n("SESClient", "SetIdentityDkimEnabledCommand").f(undefined, undefined).ser(se_SetIdentityDkimEnabledCommand).de(de_SetIdentityDkimEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetIdentityFeedbackForwardingEnabledCommand.js
class SetIdentityFeedbackForwardingEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetIdentityFeedbackForwardingEnabled", {}).n("SESClient", "SetIdentityFeedbackForwardingEnabledCommand").f(undefined, undefined).ser(se_SetIdentityFeedbackForwardingEnabledCommand).de(de_SetIdentityFeedbackForwardingEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetIdentityHeadersInNotificationsEnabledCommand.js
class SetIdentityHeadersInNotificationsEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetIdentityHeadersInNotificationsEnabled", {}).n("SESClient", "SetIdentityHeadersInNotificationsEnabledCommand").f(undefined, undefined).ser(se_SetIdentityHeadersInNotificationsEnabledCommand).de(de_SetIdentityHeadersInNotificationsEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetIdentityMailFromDomainCommand.js
class SetIdentityMailFromDomainCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetIdentityMailFromDomain", {}).n("SESClient", "SetIdentityMailFromDomainCommand").f(undefined, undefined).ser(se_SetIdentityMailFromDomainCommand).de(de_SetIdentityMailFromDomainCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetIdentityNotificationTopicCommand.js
class SetIdentityNotificationTopicCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetIdentityNotificationTopic", {}).n("SESClient", "SetIdentityNotificationTopicCommand").f(undefined, undefined).ser(se_SetIdentityNotificationTopicCommand).de(de_SetIdentityNotificationTopicCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/SetReceiptRulePositionCommand.js
class SetReceiptRulePositionCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "SetReceiptRulePosition", {}).n("SESClient", "SetReceiptRulePositionCommand").f(undefined, undefined).ser(se_SetReceiptRulePositionCommand).de(de_SetReceiptRulePositionCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/TestRenderTemplateCommand.js
class TestRenderTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "TestRenderTemplate", {}).n("SESClient", "TestRenderTemplateCommand").f(undefined, undefined).ser(se_TestRenderTemplateCommand).de(de_TestRenderTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateAccountSendingEnabledCommand.js
class UpdateAccountSendingEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateAccountSendingEnabled", {}).n("SESClient", "UpdateAccountSendingEnabledCommand").f(undefined, undefined).ser(se_UpdateAccountSendingEnabledCommand).de(de_UpdateAccountSendingEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateConfigurationSetEventDestinationCommand.js
class UpdateConfigurationSetEventDestinationCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateConfigurationSetEventDestination", {}).n("SESClient", "UpdateConfigurationSetEventDestinationCommand").f(undefined, undefined).ser(se_UpdateConfigurationSetEventDestinationCommand).de(de_UpdateConfigurationSetEventDestinationCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateConfigurationSetReputationMetricsEnabledCommand.js
class UpdateConfigurationSetReputationMetricsEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateConfigurationSetReputationMetricsEnabled", {}).n("SESClient", "UpdateConfigurationSetReputationMetricsEnabledCommand").f(undefined, undefined).ser(se_UpdateConfigurationSetReputationMetricsEnabledCommand).de(de_UpdateConfigurationSetReputationMetricsEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateConfigurationSetSendingEnabledCommand.js
class UpdateConfigurationSetSendingEnabledCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateConfigurationSetSendingEnabled", {}).n("SESClient", "UpdateConfigurationSetSendingEnabledCommand").f(undefined, undefined).ser(se_UpdateConfigurationSetSendingEnabledCommand).de(de_UpdateConfigurationSetSendingEnabledCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateConfigurationSetTrackingOptionsCommand.js
class UpdateConfigurationSetTrackingOptionsCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateConfigurationSetTrackingOptions", {}).n("SESClient", "UpdateConfigurationSetTrackingOptionsCommand").f(undefined, undefined).ser(se_UpdateConfigurationSetTrackingOptionsCommand).de(de_UpdateConfigurationSetTrackingOptionsCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateCustomVerificationEmailTemplateCommand.js
class UpdateCustomVerificationEmailTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateCustomVerificationEmailTemplate", {}).n("SESClient", "UpdateCustomVerificationEmailTemplateCommand").f(undefined, undefined).ser(se_UpdateCustomVerificationEmailTemplateCommand).de(de_UpdateCustomVerificationEmailTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateReceiptRuleCommand.js
class UpdateReceiptRuleCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateReceiptRule", {}).n("SESClient", "UpdateReceiptRuleCommand").f(undefined, undefined).ser(se_UpdateReceiptRuleCommand).de(de_UpdateReceiptRuleCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/UpdateTemplateCommand.js
class UpdateTemplateCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "UpdateTemplate", {}).n("SESClient", "UpdateTemplateCommand").f(undefined, undefined).ser(se_UpdateTemplateCommand).de(de_UpdateTemplateCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/VerifyDomainDkimCommand.js
class VerifyDomainDkimCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "VerifyDomainDkim", {}).n("SESClient", "VerifyDomainDkimCommand").f(undefined, undefined).ser(se_VerifyDomainDkimCommand).de(de_VerifyDomainDkimCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/VerifyDomainIdentityCommand.js
class VerifyDomainIdentityCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "VerifyDomainIdentity", {}).n("SESClient", "VerifyDomainIdentityCommand").f(undefined, undefined).ser(se_VerifyDomainIdentityCommand).de(de_VerifyDomainIdentityCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/VerifyEmailAddressCommand.js
class VerifyEmailAddressCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "VerifyEmailAddress", {}).n("SESClient", "VerifyEmailAddressCommand").f(undefined, undefined).ser(se_VerifyEmailAddressCommand).de(de_VerifyEmailAddressCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/commands/VerifyEmailIdentityCommand.js
class VerifyEmailIdentityCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config7, o3) {
  return [
    getSerdePlugin(config7, this.serialize, this.deserialize),
    getEndpointPlugin(config7, Command2.getEndpointParameterInstructions())
  ];
}).s("SimpleEmailService", "VerifyEmailIdentity", {}).n("SESClient", "VerifyEmailIdentityCommand").f(undefined, undefined).ser(se_VerifyEmailIdentityCommand).de(de_VerifyEmailIdentityCommand).build() {
}

// ../../../../node_modules/@aws-sdk/client-ses/dist-es/SES.js
var commands = {
  CloneReceiptRuleSetCommand,
  CreateConfigurationSetCommand,
  CreateConfigurationSetEventDestinationCommand,
  CreateConfigurationSetTrackingOptionsCommand,
  CreateCustomVerificationEmailTemplateCommand,
  CreateReceiptFilterCommand,
  CreateReceiptRuleCommand,
  CreateReceiptRuleSetCommand,
  CreateTemplateCommand,
  DeleteConfigurationSetCommand,
  DeleteConfigurationSetEventDestinationCommand,
  DeleteConfigurationSetTrackingOptionsCommand,
  DeleteCustomVerificationEmailTemplateCommand,
  DeleteIdentityCommand,
  DeleteIdentityPolicyCommand,
  DeleteReceiptFilterCommand,
  DeleteReceiptRuleCommand,
  DeleteReceiptRuleSetCommand,
  DeleteTemplateCommand,
  DeleteVerifiedEmailAddressCommand,
  DescribeActiveReceiptRuleSetCommand,
  DescribeConfigurationSetCommand,
  DescribeReceiptRuleCommand,
  DescribeReceiptRuleSetCommand,
  GetAccountSendingEnabledCommand,
  GetCustomVerificationEmailTemplateCommand,
  GetIdentityDkimAttributesCommand,
  GetIdentityMailFromDomainAttributesCommand,
  GetIdentityNotificationAttributesCommand,
  GetIdentityPoliciesCommand,
  GetIdentityVerificationAttributesCommand,
  GetSendQuotaCommand,
  GetSendStatisticsCommand,
  GetTemplateCommand,
  ListConfigurationSetsCommand,
  ListCustomVerificationEmailTemplatesCommand,
  ListIdentitiesCommand,
  ListIdentityPoliciesCommand,
  ListReceiptFiltersCommand,
  ListReceiptRuleSetsCommand,
  ListTemplatesCommand,
  ListVerifiedEmailAddressesCommand,
  PutConfigurationSetDeliveryOptionsCommand,
  PutIdentityPolicyCommand,
  ReorderReceiptRuleSetCommand,
  SendBounceCommand,
  SendBulkTemplatedEmailCommand,
  SendCustomVerificationEmailCommand,
  SendEmailCommand,
  SendRawEmailCommand,
  SendTemplatedEmailCommand,
  SetActiveReceiptRuleSetCommand,
  SetIdentityDkimEnabledCommand,
  SetIdentityFeedbackForwardingEnabledCommand,
  SetIdentityHeadersInNotificationsEnabledCommand,
  SetIdentityMailFromDomainCommand,
  SetIdentityNotificationTopicCommand,
  SetReceiptRulePositionCommand,
  TestRenderTemplateCommand,
  UpdateAccountSendingEnabledCommand,
  UpdateConfigurationSetEventDestinationCommand,
  UpdateConfigurationSetReputationMetricsEnabledCommand,
  UpdateConfigurationSetSendingEnabledCommand,
  UpdateConfigurationSetTrackingOptionsCommand,
  UpdateCustomVerificationEmailTemplateCommand,
  UpdateReceiptRuleCommand,
  UpdateTemplateCommand,
  VerifyDomainDkimCommand,
  VerifyDomainIdentityCommand,
  VerifyEmailAddressCommand,
  VerifyEmailIdentityCommand
};

class SES extends SESClient {
}
createAggregatedClient(commands, SES);

// ../email/src/drivers/ses.ts
import { config as config7 } from "@stacksjs/config";
class SESDriver extends BaseEmailDriver {
  name = "ses";
  client = null;
  getClient() {
    if (!this.client) {
      const credentials = {
        accessKeyId: config7?.services?.ses?.credentials?.accessKeyId ?? "",
        secretAccessKey: config7?.services?.ses?.credentials?.secretAccessKey ?? ""
      };
      this.client = new SES({
        region: config7?.services?.ses?.region || "us-east-1",
        credentials
      });
    }
    return this.client;
  }
  async send(message, options3) {
    try {
      this.validateMessage(message);
      let htmlContent;
      if (message.template) {
        const templ = await template(message.template, options3);
        if (templ && "html" in templ) {
          htmlContent = templ.html;
        }
      }
      const messageBody = {};
      if (htmlContent) {
        messageBody.Html = {
          Charset: config7.email.charset || "UTF-8",
          Data: htmlContent
        };
      }
      if (message.text) {
        messageBody.Text = {
          Charset: config7.email.charset || "UTF-8",
          Data: message.text
        };
      }
      if (Object.keys(messageBody).length === 0) {
        throw new Error("Email must have either HTML or text content");
      }
      const params = {
        Source: this.formatSourceAddress({
          address: message.from?.address || config7.email.from?.address || "",
          name: message.from?.name || config7.email.from?.name
        }),
        Destination: {
          ToAddresses: this.formatAddresses(message.to),
          CcAddresses: this.formatAddresses(message.cc),
          BccAddresses: this.formatAddresses(message.bcc)
        },
        Message: {
          Body: messageBody,
          Subject: {
            Charset: config7.email.charset || "UTF-8",
            Data: message.subject
          }
        }
      };
      const response = await this.getClient().send(new SendEmailCommand(params));
      return this.handleSuccess(message, response.MessageId);
    } catch (error2) {
      return this.handleError(error2, message);
    }
  }
  formatSourceAddress(from2) {
    return from2.name ? `${from2.name} <${from2.address}>` : from2.address;
  }
  formatAddresses(addresses) {
    if (!addresses)
      return [];
    if (typeof addresses === "string")
      return [addresses];
    return addresses.map((addr) => typeof addr === "string" ? addr : addr.address);
  }
}
// ../email/src/email.ts
import { config as config8 } from "@stacksjs/config";
class Mail {
  drivers = new Map;
  defaultDriver;
  constructor(options3 = {}) {
    this.defaultDriver = options3.defaultDriver || config8.email.default || "ses";
    this.registerDefaultDrivers();
  }
  registerDefaultDrivers() {
    this.drivers.set("ses", new SESDriver);
    this.drivers.set("sendgrid", new SendGridDriver);
    this.drivers.set("mailgun", new MailgunDriver);
    this.drivers.set("mailtrap", new MailtrapDriver);
  }
  async send(message) {
    const driver = this.drivers.get(this.defaultDriver);
    if (!driver)
      throw new Error(`Email driver '${this.defaultDriver}' is not available`);
    const defaultFrom = {
      name: config8.email.from?.name || "Stacks",
      address: config8.email.from?.address || "no-reply@stacksjs.org"
    };
    return driver.send({
      ...message,
      from: message.from || defaultFrom
    });
  }
  use(driver) {
    if (!this.drivers.has(driver)) {
      throw new Error(`Email driver '${driver}' is not available`);
    }
    this.defaultDriver = driver;
    return this;
  }
}
var mail = new Mail({ defaultDriver: "mailtrap" });
// ../auth/src/user.ts
var currentUser;
async function getCurrentUser() {
  if (currentUser)
    return currentUser;
  const token2 = request.bearerToken();
  if (!token2)
    return;
  currentUser = await Auth.getUserFromToken(token2);
  return currentUser;
}
// ../router/src/uploaded-file.ts
class UploadedFile {
  file;
  constructor(file) {
    this.file = file;
  }
  getClientOriginalName() {
    return this.file.name;
  }
  getClientOriginalExtension() {
    const name3 = this.getClientOriginalName();
    const lastDotIndex = name3.lastIndexOf(".");
    return lastDotIndex !== -1 ? name3.substring(lastDotIndex + 1) : "";
  }
  getMimeType() {
    return this.file.type;
  }
  getSize() {
    return this.file.size;
  }
  isValid() {
    return this.getSize() > 0;
  }
  guessExtension() {
    const mimeType = this.getMimeType();
    const extensionMap = {
      "image/jpeg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp",
      "image/svg+xml": "svg",
      "application/pdf": "pdf",
      "text/plain": "txt",
      "text/html": "html",
      "text/css": "css",
      "text/javascript": "js",
      "application/javascript": "js",
      "application/json": "json",
      "application/xml": "xml",
      "application/zip": "zip",
      "application/x-zip-compressed": "zip",
      "audio/mpeg": "mp3",
      "audio/wav": "wav",
      "video/mp4": "mp4",
      "video/webm": "webm",
      "video/ogg": "ogv"
    };
    return extensionMap[mimeType] || this.getClientOriginalExtension();
  }
  extension() {
    return this.guessExtension();
  }
  getFilename() {
    const name3 = this.getClientOriginalName();
    const lastDotIndex = name3.lastIndexOf(".");
    return lastDotIndex !== -1 ? name3.substring(0, lastDotIndex) : name3;
  }
  getFile() {
    return this.file;
  }
  async getBuffer() {
    return await this.file.arrayBuffer();
  }
  getBlob() {
    return this.file;
  }
  async getString() {
    return await this.file.text();
  }
}

// ../router/src/request.ts
var numericFields = new Set([
  "id",
  "age",
  "count",
  "quantity",
  "amount",
  "price",
  "total",
  "score",
  "rating",
  "duration",
  "size",
  "weight",
  "height",
  "width",
  "length",
  "distance",
  "speed",
  "temperature",
  "volume",
  "capacity",
  "density",
  "pressure",
  "force",
  "energy",
  "power",
  "frequency",
  "voltage",
  "current",
  "resistance",
  "time",
  "date",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond",
  "microsecond",
  "nanosecond"
]);

class Request {
  query = {};
  params = {};
  headers = {};
  files = {};
  sanitizeString(input2) {
    let sanitized = input2.replace(/\0/g, "");
    sanitized = sanitized.replace(/<[^>]*>/g, "");
    sanitized = sanitized.replace(/(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|EXEC|DECLARE)\b)/gi, "");
    sanitized = sanitized.replace(/[;&|`$]/g, "");
    sanitized = sanitized.replace(/javascript:/gi, "");
    sanitized = sanitized.replace(/on\w+=/gi, "");
    return sanitized.trim();
  }
  sanitizeValue(value) {
    if (typeof value === "string")
      return this.sanitizeString(value);
    if (Array.isArray(value))
      return value.map((item) => this.sanitizeValue(item));
    if (value && typeof value === "object") {
      return Object.fromEntries(Object.entries(value).map(([k3, v2]) => [this.sanitizeString(k3), this.sanitizeValue(v2)]));
    }
    return value;
  }
  addQuery(url) {
    const sanitizedQuery = {};
    for (const [key, value] of url.searchParams) {
      const sanitizedKey = this.sanitizeString(key.trim());
      const sanitizedValue = this.sanitizeValue(value);
      sanitizedQuery[sanitizedKey] = sanitizedValue;
    }
    this.query = sanitizedQuery;
  }
  addBodies(params) {
    this.query = this.sanitizeValue(params);
  }
  addParam(param) {
    this.params = this.sanitizeValue(param);
  }
  addHeaders(headerParams) {
    this.headers = headerParams;
  }
  addFiles(files) {
    for (const [key, fileOrFiles] of Object.entries(files)) {
      if (Array.isArray(fileOrFiles)) {
        this.files[key] = fileOrFiles.map((file) => new UploadedFile(file));
      } else {
        this.files[key] = new UploadedFile(fileOrFiles);
      }
    }
  }
  async addFilesFromFormData(formData) {
    const files = {};
    for (const [key, value] of formData.entries()) {
      if (value && typeof value === "object" && "name" in value && "size" in value) {
        if (key in files) {
          const existing = files[key];
          if (Array.isArray(existing)) {
            existing.push(value);
          } else {
            files[key] = [existing, value];
          }
        } else {
          files[key] = value;
        }
      }
    }
    this.addFiles(files);
  }
  static async fromFormData(formData) {
    const request2 = new Request;
    await request2.addFilesFromFormData(formData);
    return request2;
  }
  get(element, defaultValue) {
    const value = this.query[element];
    if (!value)
      return defaultValue;
    if (typeof value === typeof defaultValue)
      return value;
    if (typeof value === "string") {
      const trimmedValue = value.trim();
      try {
        return JSON.parse(trimmedValue);
      } catch {
        return trimmedValue;
      }
    }
    return value;
  }
  all() {
    return this.query;
  }
  async validate(attributes) {
    if (attributes)
      await customValidate(attributes, this.all());
  }
  has(element) {
    return element in this.query;
  }
  isEmpty() {
    return Object.keys(this.query).length === 0;
  }
  extractParamsFromRoute(routePattern, pathname) {
    const pattern2 = new RegExp(`^${routePattern.replace(/:(\w+)/g, (match2, paramName) => `(?<${paramName}>\\w+)`)}$`);
    const match = pattern2.exec(pathname);
    if (match?.groups)
      this.params = match.groups;
  }
  header(headerParam) {
    return this.headers.get(headerParam);
  }
  getHeaders() {
    return this.headers;
  }
  Header(headerParam) {
    return this.headers.get(headerParam);
  }
  getParam(key) {
    const value = this.params[key];
    if (numericFields.has(key)) {
      const numValue = Number(value);
      return Number.isNaN(numValue) ? 0 : numValue;
    }
    return value;
  }
  route(key) {
    return this.getParam(key);
  }
  bearerToken() {
    const authorizationHeader = this.headers.get("authorization");
    if (authorizationHeader?.startsWith("Bearer ")) {
      return authorizationHeader.substring(7);
    }
    return null;
  }
  getParams() {
    return this.params;
  }
  getParamAsInt(key) {
    const value = this.getParam(key);
    return value ? Number.parseInt(value.toString()) : null;
  }
  browser() {
    return this.headers.get("user-agent");
  }
  ip() {
    return this.ipForRateLimit();
  }
  ipForRateLimit() {
    const ipHeaders = [
      "cf-connecting-ip",
      "x-real-ip",
      "x-client-ip",
      "x-forwarded-for",
      "x-forwarded",
      "forwarded-for",
      "forwarded",
      "x-appengine-user-ip",
      "x-cluster-client-ip",
      "x-azure-clientip",
      "x-aws-via",
      "true-client-ip",
      "fastly-client-ip",
      "x-vercel-forwarded-for",
      "x-netlify-ip"
    ];
    for (const header of ipHeaders) {
      const ip2 = this.headers.get(header);
      if (ip2) {
        return ip2.split(",")[0].trim();
      }
    }
    return null;
  }
  getMethod() {
    const method = this.headers.get("x-http-method-override") || this.headers.get("x-method-override") || this.headers.get("x-requested-with") || this.headers.get("method") || "GET";
    return method.toUpperCase();
  }
  async user() {
    return await getCurrentUser();
  }
  file(key) {
    const fileOrFiles = this.files[key];
    if (!fileOrFiles) {
      return null;
    }
    if (Array.isArray(fileOrFiles)) {
      return fileOrFiles[0] || null;
    }
    return fileOrFiles;
  }
  getFiles(key) {
    const fileOrFiles = this.files[key];
    if (!fileOrFiles) {
      return [];
    }
    if (Array.isArray(fileOrFiles)) {
      return fileOrFiles;
    }
    return [fileOrFiles];
  }
  hasFile(key) {
    return key in this.files;
  }
  allFiles() {
    return this.files;
  }
}
var request = new Request;
// ../router/src/response.ts
class Response2 {
  json(data, statusCode = 200) {
    const isErrorStatus = statusCode >= 400;
    return {
      status: statusCode,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(isErrorStatus ? { errors: data } : { data })
    };
  }
  success(data) {
    return this.json(data, 200);
  }
  created(data) {
    return this.json(data, 201);
  }
  noContent() {
    return {
      status: 204,
      headers: { "Content-Type": "application/json" },
      body: ""
    };
  }
  error(message, statusCode = 500) {
    return this.json({ error: message }, statusCode);
  }
  forbidden(message) {
    return this.error(message, 403);
  }
  unauthorized(message) {
    return this.error(message, 401);
  }
  notFound(message) {
    return this.error(message, 404);
  }
}
var response = new Response2;
// ../router/src/server.ts
import { config as config13 } from "@stacksjs/config";
import { log as log13 } from "@stacksjs/logging";
import { path as path3 } from "@stacksjs/path";

// ../realtime/src/broadcast.ts
import { config as config12 } from "@stacksjs/config";
import { appPath } from "@stacksjs/path";

// ../realtime/src/drivers/bun.ts
import { log as log9 } from "@stacksjs/logging";

class BunSocket {
  server = null;
  isConnectedState = false;
  subscribers = new Map;
  constructor() {}
  setServer(server) {
    this.server = server;
    this.isConnectedState = true;
  }
  async connect() {
    this.isConnectedState = true;
  }
  async disconnect() {
    this.isConnectedState = false;
    this.subscribers.clear();
  }
  subscribe(channel, callback) {
    if (!this.subscribers.has(channel)) {
      this.subscribers.set(channel, new Set);
    }
    this.subscribers.get(channel)?.add(callback);
  }
  unsubscribe(channel) {
    this.subscribers.delete(channel);
  }
  publish(channel, data) {
    if (!this.server) {
      throw new Error("WebSocket server not initialized.");
    }
    this.server.publish(channel, JSON.stringify(data));
  }
  broadcast(channel, event, data, type = "public") {
    if (!this.server) {
      throw new Error("WebSocket server not initialized.");
    }
    const channelName = type === "public" ? channel : `${type}-${channel}`;
    this.server.publish(channelName, JSON.stringify({
      event,
      channel: channelName,
      data
    }));
    log9.info(`Broadcasted event "${event}" to ${type} channel: ${channel}`);
  }
  isConnected() {
    return this.isConnectedState;
  }
  getWebSocketConfig() {
    return {
      open: (ws3) => {
        ws3.data = {
          clientId: Math.random().toString(36).slice(2),
          subscriptions: new Set
        };
        log9.info("Client connected:", ws3.data.clientId);
      },
      message: (ws3, message) => {
        try {
          const data = typeof message === "string" ? JSON.parse(message) : message;
          if (data.type === "subscribe") {
            this.handleSubscription(ws3, data.channel);
          } else {
            const subscribers = this.subscribers.get(data.channel);
            if (subscribers) {
              subscribers.forEach((callback) => callback(data));
            }
          }
        } catch (error2) {
          log9.error("Error processing WebSocket message:", error2);
        }
      },
      close: async (ws3) => {
        ws3.data.subscriptions.forEach((channel) => {
          ws3.unsubscribe(channel);
        });
        try {
          await db.insertInto("websockets").values({
            type: "disconnection",
            socket: ws3.data.clientId,
            details: "WebSocket connection closed",
            time: new Date().toISOString()
          });
        } catch (error2) {
          log9.error("Failed to store WebSocket disconnection event:", error2);
        }
        log9.info("Client disconnected:", ws3.data.clientId);
      },
      drain: (ws3) => {
        log9.info("WebSocket drain:", ws3.data.clientId);
      }
    };
  }
  handleSubscription(ws3, channel) {
    if (channel.startsWith("private-") || channel.startsWith("presence-")) {
      ws3.subscribe(channel);
      ws3.data.subscriptions.add(channel);
      log9.info(`Client ${ws3.data.clientId} joined ${channel}`);
    } else {
      ws3.subscribe(channel);
      ws3.data.subscriptions.add(channel);
      log9.info(`Client ${ws3.data.clientId} joined ${channel}`);
    }
  }
}

// ../realtime/src/drivers/pusher.ts
var import_pusher = __toESM(require_pusher(), 1);
import { config as config10 } from "@stacksjs/config";
import { log as log11 } from "@stacksjs/logging";

// ../realtime/src/ws.ts
import { log as log10 } from "@stacksjs/logging";
async function storeWebSocketEvent(type, socket, details) {
  try {
    await db.insertInto("websockets").values({
      type,
      socket,
      details,
      time: new Date().getTime()
    });
  } catch (error2) {
    log10.error("Failed to store WebSocket event:", error2);
  }
}

// ../realtime/src/drivers/pusher.ts
class PusherDriver {
  pusher = null;
  isConnectedState = false;
  channels = new Map;
  currentChannel = "default";
  currentEvent = "message";
  currentData;
  channelType = "public";
  shouldExcludeCurrentUser = false;
  constructor() {
    if (!config10.realtime.pusher?.appId || !config10.realtime.pusher?.key || !config10.realtime.pusher?.secret) {
      throw new Error("Pusher driver requires appId, key, and secret in realtime configuration");
    }
  }
  async connect() {
    if (this.pusher) {
      return;
    }
    this.pusher = new import_pusher.default({
      appId: config10.realtime.pusher?.appId || "",
      key: config10.realtime.pusher?.key || "",
      secret: config10.realtime.pusher?.secret || "",
      cluster: config10.realtime.pusher?.cluster || "mt1",
      useTLS: config10.realtime.pusher?.useTLS ?? true
    });
    await storeWebSocketEvent("success", "pusher", "Pusher connection established");
    this.isConnectedState = true;
    log11.info("Pusher connection established");
  }
  async disconnect() {
    if (!this.pusher) {
      return;
    }
    await storeWebSocketEvent("disconnection", "pusher", "Pusher connection closed");
    this.channels.clear();
    this.pusher = null;
    this.isConnectedState = false;
    log11.info("Pusher connection closed");
  }
  subscribe(channel, callback) {
    if (!this.pusher) {
      throw new Error("Pusher not initialized. Call connect() first.");
    }
    this.channels.set(channel, callback);
    log11.info(`Subscribed to channel: ${channel}`);
  }
  unsubscribe(channel) {
    if (!this.pusher) {
      throw new Error("Pusher not initialized. Call connect() first.");
    }
    this.channels.delete(channel);
    log11.info(`Unsubscribed from channel: ${channel}`);
  }
  publish(channel, data) {
    if (!this.pusher) {
      throw new Error("Pusher not initialized. Call connect() first.");
    }
    this.pusher.trigger(channel, "message", data);
    log11.info(`Published to channel: ${channel}`);
  }
  broadcast(channel, event, data, type = "public") {
    if (!this.pusher) {
      throw new Error("Pusher not initialized. Call connect() first.");
    }
    const channelName = type === "public" ? channel : `${type}-${channel}`;
    this.pusher.trigger(channelName, event, {
      event,
      channel: channelName,
      data
    });
    log11.info(`Broadcasted event "${event}" to ${type} channel: ${channel}`);
  }
  isConnected() {
    return this.isConnectedState;
  }
  async broadcastEvent() {
    if (!this.pusher) {
      await this.connect();
    }
    const channelName = this.channelType === "public" ? this.currentChannel : `${this.channelType}-${this.currentChannel}`;
    if (!this.pusher) {
      throw new Error("Failed to connect to Pusher");
    }
    if (this.shouldExcludeCurrentUser) {
      log11.warn("Excluding current user is not supported in Pusher driver");
    }
    this.pusher.trigger(channelName, this.currentEvent, {
      event: this.currentEvent,
      channel: channelName,
      data: this.currentData
    });
    log11.info(`Broadcasted event "${this.currentEvent}" to ${this.channelType} channel: ${this.currentChannel}`);
  }
  async broadcastEventNow() {
    await this.broadcastEvent();
  }
  setChannel(channel) {
    this.currentChannel = channel;
    return this;
  }
  excludeCurrentUser() {
    this.shouldExcludeCurrentUser = true;
    return this;
  }
  setPresenceChannel() {
    this.channelType = "presence";
    return this;
  }
  setPrivateChannel() {
    this.channelType = "private";
    return this;
  }
  setEvent(event, data) {
    this.currentEvent = event;
    this.currentData = data;
    return this;
  }
}

// ../realtime/src/drivers/socket.ts
import { config as config11 } from "@stacksjs/config";
import { log as log12 } from "@stacksjs/logging";

// ../../../../node_modules/socket.io/wrapper.mjs
var import_dist = __toESM(require_dist2(), 1);
var { Server, Namespace, Socket } = import_dist.default;

// ../realtime/src/drivers/socket.ts
class SocketDriver {
  io = null;
  isConnectedState = false;
  currentChannel = "default";
  currentEvent = "message";
  currentData;
  channelType = "public";
  shouldExcludeCurrentUser = false;
  options = {
    port: config11.realtime?.socket?.port,
    host: config11.realtime?.socket?.host
  };
  async connect() {
    if (this.io) {
      return;
    }
    this.io = new Server({
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      },
      ...this.options
    });
    this.io.on("connection", async (socket) => {
      log12.info("Client connected:", socket.id);
      await storeWebSocketEvent("success", socket.id, "Socket.IO connection established");
      socket.on("disconnect", async () => {
        log12.info("Client disconnected:", socket.id);
        await storeWebSocketEvent("disconnection", socket.id, "Socket.IO connection closed");
      });
      socket.on("subscribe", (channel) => {
        if (channel.startsWith("private-") || channel.startsWith("presence-")) {
          socket.join(channel);
          log12.info(`Client ${socket.id} joined ${channel}`);
        }
      });
    });
    this.isConnectedState = true;
  }
  async disconnect() {
    if (this.io) {
      this.io.close();
      this.io = null;
      this.isConnectedState = false;
    }
  }
  subscribe(channel, callback) {
    if (!this.io) {
      throw new Error("Socket.IO server not initialized. Call connect() first.");
    }
    this.io.on("connection", (socket) => {
      socket.on(channel, callback);
    });
  }
  unsubscribe(channel) {
    if (!this.io) {
      throw new Error("Socket.IO server not initialized. Call connect() first.");
    }
    this.io.sockets.removeAllListeners(channel);
  }
  publish(channel, data) {
    if (!this.io) {
      throw new Error("Socket.IO server not initialized. Call connect() first.");
    }
    this.io.emit(channel, data);
  }
  broadcast(channel, event, data, type = "public") {
    if (!this.io) {
      throw new Error("Socket.IO server not initialized. Call connect() first.");
    }
    const channelName = type === "public" ? channel : `${type}-${channel}`;
    if (type !== "public") {
      const room = this.io.sockets.adapter.rooms.get(channelName);
      if (!room) {
        log12.warn(`No clients connected to ${type} channel: ${channel}`);
        return;
      }
    }
    if (this.shouldExcludeCurrentUser) {
      this.io.to(channelName).emit(event, {
        event,
        channel: channelName,
        data
      });
    } else {
      this.io.emit(event, {
        event,
        channel: channelName,
        data
      });
    }
    log12.info(`Broadcasted event "${event}" to ${type} channel: ${channel}`);
  }
  isConnected() {
    return this.isConnectedState;
  }
  async broadcastEvent() {
    if (!this.io) {
      await this.connect();
    }
    const channelName = this.channelType === "public" ? this.currentChannel : `${this.channelType}-${this.currentChannel}`;
    if (!this.io) {
      throw new Error("Failed to connect to Socket.IO server");
    }
    if (this.channelType !== "public") {
      const room = this.io.sockets.adapter.rooms.get(channelName);
      if (!room) {
        log12.warn(`No clients connected to ${this.channelType} channel: ${this.currentChannel}`);
        return;
      }
    }
    this.io.to(channelName).emit(this.currentEvent, {
      event: this.currentEvent,
      channel: channelName,
      data: this.currentData
    });
    log12.info(`Broadcasted event "${this.currentEvent}" to ${this.channelType} channel: ${this.currentChannel}`);
  }
  async broadcastEventNow() {
    await this.broadcastEvent();
  }
  setChannel(channel) {
    this.currentChannel = channel;
    return this;
  }
  excludeCurrentUser() {
    this.shouldExcludeCurrentUser = true;
    return this;
  }
  setPresenceChannel() {
    this.channelType = "presence";
    return this;
  }
  setPrivateChannel() {
    this.channelType = "private";
    return this;
  }
  setEvent(event, data) {
    this.currentEvent = event;
    this.currentData = data;
    return this;
  }
}

// ../realtime/src/factory.ts
class RealtimeFactory {
  static instance;
  drivers = new Map;
  constructor() {}
  static getInstance() {
    if (!RealtimeFactory.instance) {
      RealtimeFactory.instance = new RealtimeFactory;
    }
    return RealtimeFactory.instance;
  }
  getDriver(type) {
    if (!this.drivers.has(type)) {
      switch (type) {
        case "socket":
          this.drivers.set(type, new SocketDriver);
          break;
        case "pusher":
          this.drivers.set(type, new PusherDriver);
          break;
        case "bun":
          this.drivers.set(type, new BunSocket);
          break;
        default:
          throw new Error(`Unsupported driver type: ${type}`);
      }
    }
    const driver = this.drivers.get(type);
    if (!driver) {
      throw new Error(`Driver not found for type: ${type}`);
    }
    return driver;
  }
}

// ../realtime/src/broadcast.ts
class Broadcast {
  driver;
  constructor() {
    this.driver = RealtimeFactory.getInstance().getDriver(config12.realtime.driver || "socket");
  }
  async connect() {
    await this.driver.connect();
  }
  async disconnect() {
    await this.driver.disconnect();
  }
  subscribe(channel, callback) {
    this.driver.subscribe(channel, callback);
  }
  unsubscribe(channel) {
    this.driver.unsubscribe(channel);
  }
  broadcast(channel, event, data, type = "public") {
    const channelName = type === "public" ? channel : `${type}-${channel}`;
    this.driver.broadcast(channelName, event, data, type);
  }
  isConnected() {
    return this.driver.isConnected();
  }
}
// ../realtime/src/channel.ts
class Channel {
  channel;
  broadcastInstance = new Broadcast;
  constructor(channel) {
    this.channel = channel;
  }
  async private(event, data) {
    await this.broadcastInstance.connect();
    this.broadcastInstance.broadcast(this.channel, event, data, "private");
  }
  async public(event, data) {
    await this.broadcastInstance.connect();
    this.broadcastInstance.broadcast(this.channel, event, data, "public");
  }
  async presence(event, data) {
    await this.broadcastInstance.connect();
    this.broadcastInstance.broadcast(this.channel, event, data, "presence");
  }
}
// ../router/src/server.ts
import { fs, globSync } from "@stacksjs/storage";
// ../router/src/static.ts
class StaticRouteManager {
  staticRoutes = {};
  addHtmlFile(uri, htmlFile) {
    const normalizedUri = uri.startsWith("/") ? uri : `/${uri}`;
    this.staticRoutes[normalizedUri] = htmlFile;
  }
  async getStaticConfig() {
    await route.importRoutes();
    return this.staticRoutes;
  }
}
var staticRoute = new StaticRouteManager;
// ../router/src/utils.ts
import { ok as ok2 } from "@stacksjs/error-handling";
import { path as path4 } from "@stacksjs/path";
async function findRequestInstance(requestInstance) {
  const frameworkDirectory = path4.storagePath("framework/requests");
  const filePath = path4.join(frameworkDirectory, `${requestInstance}.ts`);
  const reqInstance = await import(filePath);
  return reqInstance[camelCase(requestInstance)];
}
async function extractDefaultRequest() {
  const requestPath = path4.frameworkPath(`core/router/src/request.ts`);
  const requestInstance = await import(requestPath);
  return requestInstance.request;
}
// ../router/src/router.ts
class Router {
  routes = [];
  path = "";
  addRoute(method, uri, callback, statusCode) {
    const name3 = uri.replace(/\//g, ".").replace(/:/g, "");
    const pattern2 = new RegExp(`^${uri.replace(/:[a-z]+/gi, (_match) => {
      return "([a-zA-Z0-9-]+)";
    })}$`);
    log14.debug(`Adding route: ${method} ${uri} with name ${name3}`);
    this.routes.push({
      name: name3,
      method,
      url: uri,
      uri,
      callback,
      pattern: pattern2,
      statusCode,
      paramNames: []
    });
    return this;
  }
  get(path5, callback) {
    this.path = this.normalizePath(path5);
    log14.debug(`Normalized Path: ${this.path}`);
    const uri = this.prepareUri(this.path);
    log14.debug(`Prepared URI: ${uri}`);
    if (typeof callback === "string" && callback.endsWith(".html")) {
      staticRoute.addHtmlFile(uri, callback);
      return this.addRoute("GET", uri, async () => callback, 200);
    }
    return this.addRoute("GET", uri, callback, 200);
  }
  async email(path5) {
    path5 = pascalCase(path5);
    const emailModule = (await import(p3.userNotificationsPath(path5))).default;
    const callback = emailModule.handle;
    const uri = this.prepareUri(path5);
    this.addRoute("GET", uri, callback, 200);
    return this;
  }
  async health() {
    let healthPath = p3.userActionsPath("HealthAction");
    if (!fs2.existsSync(healthPath))
      healthPath = p3.storagePath("framework/defaults/actions/HealthAction");
    const healthModule = (await import(healthPath)).default;
    const callback = healthModule.handle;
    const path5 = healthModule.path ?? `/health`;
    this.addRoute("GET", path5, callback, 200);
    return this;
  }
  async job(path5) {
    path5 = pascalCase(path5);
    const job = (await import(p3.userJobsPath(`${path5}.ts`))).default;
    if (!job.handle) {
      handleError2(`Job at path ${path5} does not have a handle method`);
      return this;
    }
    return this.addRoute("GET", this.prepareUri(path5), job.handle, 200);
  }
  async action(path5) {
    if (!path5)
      return this;
    if (path5?.endsWith(".ts")) {
      const action = (await import(p3.userActionsPath(path5))).default;
      path5 = action.path ?? kebabCase(path5);
      return this.addRoute(action.method ?? "GET", path5, action.handle, 200);
    }
    path5 = pascalCase(path5);
    try {
      const action = (await import(p3.userActionsPath(path5))).default;
      return this.addRoute(action.method ?? "GET", this.prepareUri(path5), action.handle, 200);
    } catch (error2) {
      handleError2(`Could not find Action for path: ${path5}`, error2);
      return this;
    }
  }
  post(path5, callback) {
    this.path = this.normalizePath(path5);
    const uri = this.prepareUri(this.path);
    return this.addRoute("POST", uri, callback, 201);
  }
  view(path5, htmlFile) {
    this.path = this.normalizePath(path5);
    const uri = this.prepareUri(this.path);
    staticRoute.addHtmlFile(uri, htmlFile);
    return this.addRoute("GET", uri, async () => htmlFile, 200);
  }
  getStaticConfig() {
    return staticRoute.getStaticConfig();
  }
  redirect(path5, callback, _status) {
    return this.addRoute("GET", path5, callback, 302);
  }
  delete(path5, callback) {
    return this.addRoute("DELETE", this.prepareUri(path5), callback, 204);
  }
  patch(path5, callback) {
    this.path = this.normalizePath(path5);
    log14.debug(`Normalized Path: ${this.path}`);
    const uri = this.prepareUri(this.path);
    log14.debug(`Prepared URI: ${uri}`);
    return this.addRoute("PATCH", uri, callback, 202);
  }
  put(path5, callback) {
    this.path = this.normalizePath(path5);
    const uri = this.prepareUri(this.path);
    return this.addRoute("PUT", uri, callback, 202);
  }
  group(options3, callback) {
    if (typeof options3 === "string")
      options3 = options3.startsWith("/") ? options3.slice(1) : options3;
    let cb;
    if (typeof options3 === "function") {
      cb = options3;
      options3 = {};
    }
    if (!callback)
      throw new Error("Missing callback function for your route group.");
    cb = callback;
    const { middleware: middleware2 = [] } = options3;
    const originalRoutes = this.routes;
    this.routes = [];
    cb();
    if (typeof options3 === "object") {
      this.routes.forEach((r4) => {
        if (middleware2.length)
          r4.middleware = middleware2;
        const prefix2 = options3.prefix || "/";
        const formattedPrefix = prefix2.startsWith("/") ? prefix2 : `/${prefix2}`;
        if (options3.prefix) {
          r4.path = formattedPrefix + r4.uri;
          r4.uri = formattedPrefix + r4.uri;
          r4.url = r4.uri;
        }
        originalRoutes.push(r4);
        return this;
      });
    }
    this.routes = originalRoutes;
    return this;
  }
  name(name3) {
    this.routes[this.routes.length - 1].name = name3;
    return this;
  }
  middleware(middleware2) {
    this.routes[this.routes.length - 1].middleware = middleware2;
    return this;
  }
  prefix(prefix2) {
    this.routes[this.routes.length - 1].prefix = prefix2;
    return this;
  }
  async getRoutes() {
    await this.importRoutes();
    return this.routes;
  }
  async importRoutes() {
    await import("./chunk-aj1aatfj.js");
    await import("./chunk-nxyhs95s.js");
  }
  async resolveCallback(callback) {
    if (callback instanceof Promise) {
      const actionModule = await callback;
      return actionModule.default;
    }
    if (typeof callback === "string")
      return await this.importCallbackFromPath(callback, this.path);
    return callback;
  }
  async importCallbackFromPath(callbackPath, originalPath) {
    let modulePath = callbackPath;
    let importPathFunction = p3.appPath;
    if (callbackPath.startsWith("../"))
      importPathFunction = p3.routesPath;
    if (modulePath.includes("OrmAction"))
      importPathFunction = p3.storagePath;
    modulePath = modulePath.endsWith(".ts") ? modulePath.slice(0, -3) : modulePath;
    let requestInstance = await extractDefaultRequest();
    try {
      if (modulePath.includes("Controller")) {
        const [controllerPath, methodName = "index"] = modulePath.split("@");
        const controller = await import(importPathFunction(controllerPath));
        const instance = new controller.default;
        if (typeof instance[methodName] !== "function")
          throw new Error(`Method ${methodName} not found in controller ${controllerPath}`);
        const newPath2 = controller.default.path ?? originalPath;
        this.updatePathIfNeeded(newPath2, originalPath);
        const result3 = await instance[methodName](requestInstance);
        if (isObject(result3) && "status" in result3 && typeof result3.status === "number" && "headers" in result3 && isObject(result3.headers) && "body" in result3) {
          return result3;
        }
        if (isObject(result3)) {
          return response.json(result3);
        }
        return response.success(result3);
      }
      let actionModule = null;
      if (modulePath.includes("storage/framework/orm"))
        actionModule = await import(modulePath);
      else if (modulePath.includes("Actions"))
        actionModule = await import(p3.projectPath(`app/${modulePath}.ts`));
      else if (modulePath.includes("OrmAction"))
        actionModule = await import(p3.storagePath(`/framework/actions/src/${modulePath}.ts`));
      else
        actionModule = await import(importPathFunction(modulePath));
      const newPath = actionModule.default.path ?? originalPath;
      this.updatePathIfNeeded(newPath, originalPath);
      if (actionModule.default.requestFile)
        requestInstance = await findRequestInstance(actionModule.default.requestFile);
      if (isObjectNotEmpty(actionModule.default.validations) && requestInstance)
        await customValidate(actionModule.default.validations, requestInstance.all());
      const result2 = await actionModule.default.handle(requestInstance);
      if (isObject(result2) && "status" in result2 && typeof result2.status === "number" && "headers" in result2 && isObject(result2.headers) && "body" in result2) {
        return result2;
      }
      if (isObject(result2)) {
        return response.json(result2);
      }
      return response.success(result2);
    } catch (error2) {
      if (error2.status === 422)
        return response.json(JSON.parse(error2.message), 422);
      if (!error2.status)
        return response.error(error2.message);
      return response.error(error2.message, error2.status);
    }
  }
  normalizePath(path5) {
    return path5.endsWith("/") ? path5.slice(0, -1) : path5;
  }
  prepareUri(path5) {
    if (path5.startsWith("/"))
      path5 = path5.slice(1);
    path5 = `/${path5}`;
    return path5.endsWith("/") ? path5.slice(0, -1) : path5;
  }
  updatePathIfNeeded(newPath, originalPath) {
    if (newPath !== originalPath) {
      this.path = newPath;
    }
  }
}
var route = new Router;

export { route };
