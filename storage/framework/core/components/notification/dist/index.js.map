{"version":3,"file":"index.js","names":["subscriber: (toast: ToastT | ToastToDismiss) => void","data: ToastT","data: ExternalToast & {\n      message?: string | Component\n      type?: ToastTypes\n      promise?: PromiseT\n    }","id?: number | string","message: string | Component","data?: ExternalToast","promise: PromiseT<ToastData>","data?: PromiseData<ToastData>","id: string | number | undefined","result: ['resolve', ToastData] | ['reject', unknown]","component: Component","data: any","visible","action: Action | Component","toast","defaultRichColors","unstyled","index","expanded","expandByDefault","toasts","style","closeButtonAriaLabel","cn","classes","icons","descriptionClass","cancelButtonStyle","actionButtonStyle","containerAriaLabel","dir","theme","richColors","offset","gap","style","$attrs","icons","toastOptions","duration","invert","visibleToasts","closeButton","expand","pauseWhenPageIsHidden","cn","plugin: Plugin"],"sources":["../src/state.ts","../src/components/icons/Loader.vue","../src/components/icons/Loader.vue","../src/composables/useIsDocumentHidden.ts","../src/types.ts","../src/components/Toast.vue","../src/components/Toast.vue","../src/components/Toaster.vue","../src/components/Toaster.vue","../src/composables/useNotification.ts","../src/index.ts"],"sourcesContent":["import type { Component } from 'vue'\nimport type { ExternalToast, PromiseData, PromiseT, ToastT, ToastToDismiss, ToastTypes } from './types'\n\nlet toastsCounter = 0\n\nclass Observer {\n  subscribers: Array<(toast: ExternalToast | ToastToDismiss) => void>\n  toasts: Array<ToastT | ToastToDismiss>\n\n  constructor() {\n    this.subscribers = []\n    this.toasts = []\n  }\n\n  // We use arrow functions to maintain the correct `this` reference\n  subscribe = (subscriber: (toast: ToastT | ToastToDismiss) => void) => {\n    this.subscribers.push(subscriber as any)\n\n    return () => {\n      const index = this.subscribers.indexOf(subscriber as any)\n      this.subscribers.splice(index, 1)\n    }\n  }\n\n  publish = (data: ToastT) => {\n    this.subscribers.forEach(subscriber => subscriber(data))\n  }\n\n  addToast = (data: ToastT) => {\n    this.publish(data)\n    this.toasts = [...this.toasts, data]\n  }\n\n  create = (\n    data: ExternalToast & {\n      message?: string | Component\n      type?: ToastTypes\n      promise?: PromiseT\n    },\n  ) => {\n    const { message, ...rest } = data\n    const id = typeof data.id === 'number' || (data.id && data.id?.length > 0) ? data.id : toastsCounter++\n    const alreadyExists = this.toasts.find((toast) => {\n      return toast.id === id\n    })\n    const dismissible = data.dismissible === undefined ? true : data.dismissible\n\n    if (alreadyExists) {\n      this.toasts = this.toasts.map((toast) => {\n        if (toast.id === id) {\n          this.publish({ ...toast, ...data, id, title: message })\n          return {\n            ...toast,\n            ...data,\n            id,\n            dismissible,\n            title: message,\n          }\n        }\n\n        return toast\n      })\n    }\n    else {\n      this.addToast({ title: message, ...rest, dismissible, id })\n    }\n\n    return id\n  }\n\n  dismiss = (id?: number | string) => {\n    if (!id) {\n      this.toasts.forEach((toast) => {\n        this.subscribers.forEach(subscriber => subscriber({ id: toast.id, dismiss: true }))\n      })\n    }\n\n    this.subscribers.forEach(subscriber => subscriber({ id, dismiss: true }))\n    return id\n  }\n\n  message = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, message, type: 'default' })\n  }\n\n  error = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, type: 'error', message })\n  }\n\n  success = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, type: 'success', message })\n  }\n\n  info = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, type: 'info', message })\n  }\n\n  warning = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, type: 'warning', message })\n  }\n\n  loading = (message: string | Component, data?: ExternalToast) => {\n    return this.create({ ...data, type: 'loading', message })\n  }\n\n  promise = <ToastData>(promise: PromiseT<ToastData>, data?: PromiseData<ToastData>) => {\n    if (!data) {\n      // Nothing to show\n      return\n    }\n\n    let id: string | number | undefined\n    if (data.loading !== undefined) {\n      id = this.create({\n        ...data,\n        promise,\n        type: 'loading',\n        message: data.loading,\n        description: typeof data.description !== 'function' ? data.description : undefined,\n      })\n    }\n\n    const p = promise instanceof Promise ? promise : promise()\n\n    let shouldDismiss = id !== undefined\n    let result: ['resolve', ToastData] | ['reject', unknown]\n\n    const originalPromise = p\n      .then(async (response) => {\n        result = ['resolve', response]\n        if (isHttpResponse(response) && !response.ok) {\n          shouldDismiss = false\n          const message = typeof data.error === 'function'\n            ? await (data.error as (msg: string) => Promise<string>)(`HTTP error! status: ${response.status}`)\n            : data.error\n          const description = typeof data.description === 'function'\n            // @ts-expect-error - unsure atm\n            ? await data.description(`HTTP error! status: ${response.status}`)\n            : data.description\n          this.create({ id, type: 'error', message, description })\n        }\n        else if (data.success !== undefined) {\n          shouldDismiss = false\n          const message\n            = typeof data.success === 'function'\n              ? await (data.success as (response: ToastData) => Promise<string>)(response)\n              : data.success\n          const description\n            = typeof data.description === 'function'\n              ? await (data.description as (response: ToastData) => Promise<string>)(response)\n              : data.description\n          this.create({ id, type: 'success', message, description })\n        }\n      })\n      .catch(async (error) => {\n        result = ['reject', error]\n        if (data.error !== undefined) {\n          shouldDismiss = false\n          const message\n            = typeof data.error === 'function'\n              ? await (data.error as (error: unknown) => Promise<string>)(error)\n              : data.error\n          const description\n            = typeof data.description === 'function'\n              ? await (data.description as (error: unknown) => Promise<string>)(error)\n              : data.description\n          this.create({ id, type: 'error', message, description })\n        }\n      })\n      .finally(() => {\n        if (shouldDismiss) {\n          // Toast is still in load state (and will be indefinitely â€” dismiss it)\n          this.dismiss(id)\n          id = undefined\n        }\n\n        data.finally?.()\n      })\n\n    const unwrap = () =>\n      new Promise<ToastData>((resolve, reject) =>\n        originalPromise.then(() => (result[0] === 'reject' ? reject(result[1]) : resolve(result[1]))).catch(reject),\n      )\n\n    if (typeof id !== 'string' && typeof id !== 'number') {\n      // cannot Object.assign on undefined\n      return { unwrap }\n    }\n\n    return Object.assign(id, { unwrap })\n  }\n\n  // We can't provide the toast we just created as a prop as we didn't create it yet, so we can create a default toast object, I just don't know how to use function in argument when calling()?\n  custom = (component: Component, data?: ExternalToast) => {\n    const id = data?.id || toastsCounter++\n    this.publish({ component, id, ...data })\n    return id\n  }\n}\n\nexport const ToastState = new Observer()\n\n// bind this to the toast function\nfunction toastFunction(message: string | Component, data?: ExternalToast) {\n  const id = data?.id || toastsCounter++\n\n  ToastState.create({\n    message,\n    id,\n    type: 'default',\n    ...data,\n  })\n\n  return id\n}\n\nfunction isHttpResponse(data: any): data is Response {\n  return (\n    data\n    && typeof data === 'object'\n    && 'ok' in data\n    && typeof data.ok === 'boolean'\n    && 'status' in data\n    && typeof data.status === 'number'\n  )\n}\n\nconst basicToast = toastFunction\n\nconst getHistory = () => ToastState.toasts\n\n// We use `Object.assign` to maintain the correct types as we would lose them otherwise\nexport const notification = Object.assign(\n  basicToast,\n  {\n    success: ToastState.success,\n    info: ToastState.info,\n    warning: ToastState.warning,\n    error: ToastState.error,\n    custom: ToastState.custom,\n    message: ToastState.message,\n    promise: ToastState.promise,\n    dismiss: ToastState.dismiss,\n    loading: ToastState.loading,\n  },\n  {\n    getHistory,\n  },\n)\nexport const toast = notification\n","<script lang=\"ts\" setup>\ndefineProps<{\n  visible: boolean\n}>()\n\nconst bars = Array.from({ length: 12 }).fill(0)\n</script>\n\n<template>\n  <div class=\"sonner-loading-wrapper\" :data-visible=\"visible\">\n    <div class=\"sonner-spinner\">\n      <template v-for=\"bar in bars\" :key=\"`spinner-bar-${bar}`\">\n        <div class=\"sonner-loading-bar\" />\n      </template>\n    </div>\n  </div>\n</template>\n","<script lang=\"ts\" setup>\ndefineProps<{\n  visible: boolean\n}>()\n\nconst bars = Array.from({ length: 12 }).fill(0)\n</script>\n\n<template>\n  <div class=\"sonner-loading-wrapper\" :data-visible=\"visible\">\n    <div class=\"sonner-spinner\">\n      <template v-for=\"bar in bars\" :key=\"`spinner-bar-${bar}`\">\n        <div class=\"sonner-loading-bar\" />\n      </template>\n    </div>\n  </div>\n</template>\n","import { ref, watchEffect } from 'vue'\n\nexport function useIsDocumentHidden() {\n  const isDocumentHidden = ref(false)\n\n  watchEffect(() => {\n    const callback = () => {\n      isDocumentHidden.value = document.hidden\n    }\n    document.addEventListener('visibilitychange', callback)\n    return () => window.removeEventListener('visibilitychange', callback)\n  })\n\n  return {\n    isDocumentHidden,\n  }\n}\n","import type { Component, CSSProperties } from 'vue'\n\nexport type ToastTypes = 'normal' | 'action' | 'success' | 'info' | 'warning' | 'error' | 'loading' | 'default'\nexport type NotificationTypes = ToastTypes\n\nexport type PromiseT<Data = any> = Promise<Data> | (() => Promise<Data>)\n\nexport type PromiseTResult<Data = any> =\n  | string\n  | Component\n  | ((data: Data) => Component | string | Promise<Component | string>)\n\nexport type PromiseExternalToast = Omit<ExternalToast, 'description'>\n\nexport type PromiseData<ToastData = any> = ExternalToast & {\n  loading?: string | Component\n  success?: PromiseTResult<ToastData>\n  error?: PromiseTResult\n  description?: PromiseTResult\n  finally?: () => void | Promise<void>\n}\n\nexport interface ToastClasses {\n  toast?: string\n  title?: string\n  description?: string\n  loader?: string\n  closeButton?: string\n  cancelButton?: string\n  actionButton?: string\n  success?: string\n  error?: string\n  info?: string\n  warning?: string\n  loading?: string\n  default?: string\n  content?: string\n  icon?: string\n}\n\nexport interface ToastIcons {\n  success?: Component\n  info?: Component\n  warning?: Component\n  error?: Component\n  loading?: Component\n  close?: Component\n}\n\nexport interface Action {\n  label: Component | string\n  onClick: (event: MouseEvent) => void\n  actionButtonStyle?: CSSProperties\n}\n\nexport interface ToastT<T extends Component = Component> {\n  id: number | string\n  title?: string | Component\n  type?: ToastTypes\n  icon?: Component\n  component?: T\n  componentProps?: any\n  richColors?: boolean\n  invert?: boolean\n  closeButton?: boolean\n  dismissible?: boolean\n  description?: string | Component\n  duration?: number\n  delete?: boolean\n  important?: boolean\n  action?: Action | Component\n  cancel?: Action | Component\n  onDismiss?: (toast: ToastT) => void\n  onAutoClose?: (toast: ToastT) => void\n  promise?: PromiseT\n  cancelButtonStyle?: CSSProperties\n  actionButtonStyle?: CSSProperties\n  style?: CSSProperties\n  unstyled?: boolean\n  class?: string\n  classes?: ToastClasses\n  descriptionClass?: string\n  position?: Position\n}\n\nexport function isAction(action: Action | Component): action is Action {\n  return (action as Action).label !== undefined\n}\n\nexport type Position = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'top-center' | 'bottom-center'\n\nexport interface HeightT {\n  height: number\n  toastId: number | string\n  position: Position\n}\n\nexport interface ToastOptions {\n  class?: string\n  closeButton?: boolean\n  descriptionClass?: string\n  style?: CSSProperties\n  cancelButtonStyle?: CSSProperties\n  actionButtonStyle?: CSSProperties\n  duration?: number\n  unstyled?: boolean\n  classes?: ToastClasses\n}\n\nexport type CnFunction = (...classes: Array<string | undefined>) => string\n\nexport interface ToasterProps {\n  invert?: boolean\n  theme?: Theme\n  position?: Position\n  hotkey?: string[]\n  richColors?: boolean\n  expand?: boolean\n  duration?: number\n  gap?: number\n  visibleToasts?: number\n  closeButton?: boolean\n  toastOptions?: ToastOptions\n  class?: string\n  style?: CSSProperties\n  offset?: string | number\n  dir?: 'rtl' | 'ltr' | 'auto'\n  icons?: ToastIcons\n  containerAriaLabel?: string\n  pauseWhenPageIsHidden?: boolean\n  cn?: CnFunction\n}\nexport type NotificationProps = ToasterProps\n\nexport interface ToastProps {\n  toast: ToastT\n  toasts: ToastT[]\n  index: number\n  expanded: boolean\n  invert: boolean\n  heights: HeightT[]\n  gap?: number\n  position: Position\n  visibleToasts: number\n  expandByDefault: boolean\n  closeButton: boolean\n  interacting: boolean\n  style?: CSSProperties\n  cancelButtonStyle?: CSSProperties\n  actionButtonStyle?: CSSProperties\n  duration?: number\n  class: string\n  unstyled?: boolean\n  descriptionClass?: string\n  loadingIcon?: Component\n  classes?: ToastClasses\n  icons?: ToastIcons\n  closeButtonAriaLabel?: string\n  pauseWhenPageIsHidden: boolean\n  cn: CnFunction\n  defaultRichColors?: boolean\n}\n\nexport enum SwipeStateTypes {\n  SwipedOut = 'SwipedOut',\n  SwipedBack = 'SwipedBack',\n  NotSwiped = 'NotSwiped',\n}\n\nexport type Theme = 'light' | 'dark' | 'system'\n\nexport interface ToastToDismiss {\n  id: number | string\n  dismiss: boolean\n}\n\nexport type ExternalToast<T extends Component = Component> = Omit<\n  ToastT<T>,\n  'id' | 'type' | 'title' | 'promise' | 'delete'\n> & {\n  id?: number | string\n}\n","<script lang=\"ts\" setup>\nimport { computed, onMounted, onUnmounted, ref, watchEffect } from 'vue'\nimport { useIsDocumentHidden } from '../composables/useIsDocumentHidden'\nimport { type HeightT, isAction, type ToastProps, type ToastT } from '../types'\nimport '../styles/styles.css'\n\nconst props = defineProps<ToastProps>()\n\nconst emit = defineEmits<{\n  (e: 'update:heights', heights: HeightT[]): void\n  (e: 'removeToast', toast: ToastT): void\n}>()\n\n// Default lifetime of a toasts (in ms)\nconst TOAST_LIFETIME = 4000\nconst SWIPE_THRESHOLD = 20\nconst TIME_BEFORE_UNMOUNT = 200\n\nconst mounted = ref(false)\nconst removed = ref(false)\nconst swiping = ref(false)\nconst swipeOut = ref(false)\nconst offsetBeforeRemove = ref(0)\nconst initialHeight = ref(0)\nconst dragStartTime = ref<Date | null>(null)\nconst toastRef = ref<HTMLLIElement | null>(null)\nconst isFront = computed(() => props.index === 0)\nconst isVisible = computed(() => props.index + 1 <= props.visibleToasts)\nconst toastType = computed(() => props.toast.type)\nconst dismissible = computed(() => props.toast.dismissible !== false)\nconst toastClass = computed(() => props.toast.class || '')\nconst toastDescriptionClass = computed(() => props.descriptionClass || '')\n\nconst toastStyle = props.toast.style || {}\n\n// Height index is used to calculate the offset as it gets updated before the toast array, which means we can calculate the new layout faster.\nconst heightIndex = computed(() => props.heights.findIndex(height => height.toastId === props.toast.id) || 0)\nconst closeButton = computed(() => props.toast.closeButton ?? props.closeButton)\nconst duration = computed(() => props.toast.duration || props.duration || TOAST_LIFETIME)\n\nconst closeTimerStartTimeRef = ref(0)\nconst offset = ref(0)\nconst lastCloseTimerStartTimeRef = ref(0)\nconst pointerStartRef = ref<{ x: number, y: number } | null>(null)\nconst coords = computed(() => props.position.split('-'))\nconst y = computed(() => coords.value[0])\nconst x = computed(() => coords.value[1])\nconst isStringOfTitle = computed(() => typeof props.toast.title !== 'string')\nconst isStringOfDescription = computed(() => typeof props.toast.description !== 'string')\n\nconst toastsHeightBefore = computed(() => {\n  return props.heights.reduce((prev, curr, reducerIndex) => {\n    // Calculate offset up untill current  toast\n    if (reducerIndex >= heightIndex.value) {\n      return prev\n    }\n\n    return prev + curr.height\n  }, 0)\n})\nconst isDocumentHidden = useIsDocumentHidden()\nconst invert = computed(() => props.toast.invert || props.invert)\nconst disabled = computed(() => toastType.value === 'loading')\n\nonMounted(() => {\n  if (!mounted.value)\n    return\n\n  const toastNode = toastRef.value\n  const originalHeight = toastNode?.style.height\n  let newHeight = 0\n  if (toastNode) {\n    toastNode.style.height = 'auto'\n    newHeight = toastNode.getBoundingClientRect().height\n    toastNode.style.height = originalHeight || ''\n  }\n  initialHeight.value = newHeight\n\n  let newHeightArr\n  const alreadyExists = props.heights.find(height => height.toastId === props.toast.id)\n\n  if (!alreadyExists) {\n    newHeightArr = [\n      {\n        toastId: props.toast.id,\n        height: newHeight,\n        position: props.toast.position,\n      },\n      ...props.heights,\n    ]\n  }\n  else {\n    newHeightArr = props.heights.map(height =>\n      height.toastId === props.toast.id ? { ...height, height: newHeight } : height,\n    )\n  }\n\n  emit('update:heights', newHeightArr as HeightT[])\n})\n\nfunction deleteToast() {\n  // Save the offset for the exit swipe animation\n  removed.value = true\n  offsetBeforeRemove.value = offset.value\n  const height = props.heights.filter(height => height.toastId !== props.toast.id)\n  emit('update:heights', height)\n\n  setTimeout(() => {\n    emit('removeToast', props.toast)\n  }, TIME_BEFORE_UNMOUNT)\n}\n\nfunction handleCloseToast() {\n  if (disabled.value || !dismissible.value) {\n    return\n  }\n\n  deleteToast()\n  props.toast.onDismiss?.(props.toast)\n}\n\nfunction onPointerDown(event: PointerEvent) {\n  if (disabled.value || !dismissible.value)\n    return\n  dragStartTime.value = new Date()\n  offsetBeforeRemove.value = offset.value\n  // Ensure we maintain correct pointer capture even when going outside of the toast (e.g. when swiping)\n  ;(event.target as HTMLElement).setPointerCapture(event.pointerId)\n  if ((event.target as HTMLElement).tagName === 'BUTTON')\n    return\n  swiping.value = true\n  pointerStartRef.value = { x: event.clientX, y: event.clientY }\n}\n\nfunction onPointerUp() {\n  if (swipeOut.value)\n    return\n  pointerStartRef.value = null\n\n  const swipeAmount = Number(toastRef.value?.style.getPropertyValue('--swipe-amount').replace('px', '') || 0)\n\n  const timeTaken = new Date().getTime() - (dragStartTime.value?.getTime() || 0)\n  const velocity = Math.abs(swipeAmount) / timeTaken\n\n  // Remove only if threshold is met\n  if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {\n    offsetBeforeRemove.value = offset.value\n    props.toast.onDismiss?.(props.toast)\n    deleteToast()\n    swipeOut.value = true\n    return\n  }\n\n  toastRef.value?.style.setProperty('--swipe-amount', '0px')\n  swiping.value = false\n}\n\nfunction onPointerMove(event: PointerEvent) {\n  if (!pointerStartRef.value || !dismissible.value)\n    return\n\n  const yPosition = event.clientY - pointerStartRef.value.y\n  const xPosition = event.clientX - pointerStartRef.value.x\n\n  const clamp = coords.value[0] === 'top' ? Math.min : Math.max\n  const clampedY = clamp(0, yPosition)\n  const swipeStartThreshold = event.pointerType === 'touch' ? 10 : 2\n  const isAllowedToSwipe = Math.abs(clampedY) > swipeStartThreshold\n\n  if (isAllowedToSwipe) {\n    toastRef.value?.style.setProperty('--swipe-amount', `${yPosition}px`)\n  }\n  else if (Math.abs(xPosition) > swipeStartThreshold) {\n    // User is swiping in wrong direction so we disable swipe gesture\n    // for the current pointer down interaction\n    pointerStartRef.value = null\n  }\n}\n\nwatchEffect(() => {\n  offset.value = heightIndex.value * (props?.gap || 0) + toastsHeightBefore.value\n})\n\nwatchEffect((onInvalidate) => {\n  if (\n    (props.toast.promise && toastType.value === 'loading')\n    || props.toast.duration === Number.POSITIVE_INFINITY\n    || props.toast.type === 'loading'\n  ) {\n    return\n  }\n  let timeoutId: ReturnType<typeof setTimeout>\n  let remainingTime = duration.value\n\n  // Pause the timer on each hover\n  const pauseTimer = () => {\n    if (lastCloseTimerStartTimeRef.value < closeTimerStartTimeRef.value) {\n      // Get the elapsed time since the timer started\n      const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.value\n\n      remainingTime = remainingTime - elapsedTime\n    }\n\n    lastCloseTimerStartTimeRef.value = new Date().getTime()\n  }\n\n  const startTimer = () => {\n    if (remainingTime === Number.POSITIVE_INFINITY)\n      return\n    closeTimerStartTimeRef.value = new Date().getTime()\n\n    // Let the toast know it has started\n    timeoutId = setTimeout(() => {\n      props.toast.onAutoClose?.(props.toast)\n      deleteToast()\n    }, remainingTime)\n  }\n\n  if (props.expanded || props.interacting || (props.pauseWhenPageIsHidden && isDocumentHidden)) {\n    pauseTimer()\n  }\n  else {\n    startTimer()\n  }\n\n  onInvalidate(() => {\n    clearTimeout(timeoutId)\n  })\n})\n\n// watchEffect(() => {\n//   if (props.toast.delete) {\n//     deleteToast()\n//   }\n// })\n\nonMounted(() => {\n  if (toastRef.value) {\n    const height = toastRef.value.getBoundingClientRect().height\n    // Add toast height tot heights array after the toast is mounted\n    initialHeight.value = height\n\n    const newHeights = [\n      { toastId: props.toast.id, height, position: props.toast.position || 'top-right' },\n      ...props.heights,\n    ]\n    emit('update:heights', newHeights)\n  }\n  mounted.value = true\n})\n\nonUnmounted(() => {\n  if (toastRef.value) {\n    const newHeights = props.heights.filter(height => height.toastId !== props.toast.id)\n    emit('update:heights', newHeights)\n  }\n})\n</script>\n\n<template>\n  <li\n    ref=\"toastRef\"\n    :aria-live=\"toast.important ? 'assertive' : 'polite'\"\n    aria-atomic=\"true\"\n    role=\"status\"\n    tabindex=\"0\"\n    data-sonner-toast=\"true\"\n    :class=\"toastClass\"\n    :data-rich-colors=\"toast.richColors ?? defaultRichColors\"\n    :data-styled=\"!Boolean(toast.component || toast?.unstyled || unstyled)\"\n    :data-mounted=\"mounted\"\n    :data-promise=\"Boolean(toast.promise)\"\n    :data-removed=\"removed\"\n    :data-visible=\"isVisible\"\n    :data-y-position=\"y\"\n    :data-x-position=\"x\"\n    :data-index=\"index\"\n    :data-front=\"isFront\"\n    :data-swiping=\"swiping\"\n    :data-dismissible=\"dismissible\"\n    :data-type=\"toastType\"\n    :data-invert=\"invert\"\n    :data-swipe-out=\"swipeOut\"\n    :data-expanded=\"Boolean(expanded || (expandByDefault && mounted))\"\n    :style=\"{\n      '--index': index,\n      '--toasts-before': index,\n      '--z-index': toasts.length - index,\n      '--offset': `${removed ? offsetBeforeRemove : offset}px`,\n      '--initial-height': expandByDefault ? 'auto' : `${initialHeight}px`,\n      ...style,\n      ...toastStyle,\n    }\"\n    @pointerdown=\"onPointerDown\"\n    @pointerup=\"onPointerUp\"\n    @pointermove=\"onPointerMove\"\n  >\n    <template v-if=\"closeButton && !toast.component\">\n      <button\n        :aria-label=\"closeButtonAriaLabel || 'Close toast'\"\n        :data-disabled=\"disabled\"\n        data-close-button=\"true\"\n        :class=\"cn(classes?.closeButton, toast?.classes?.closeButton)\"\n        @click=\"handleCloseToast\"\n      >\n        <template v-if=\"icons?.close\">\n          <component :is=\"icons?.close\" />\n        </template>\n        <template v-else>\n          <slot name=\"close-icon\" />\n        </template>\n      </button>\n    </template>\n\n    <template v-if=\"toast.component\">\n      <component\n        :is=\"toast.component\"\n        v-bind=\"toast.componentProps\"\n        :on-close-toast=\"deleteToast\"\n      />\n    </template>\n\n    <template v-else>\n      <template v-if=\"toastType !== 'default' || toast.icon || toast.promise\">\n        <div data-icon=\"\">\n          <template\n            v-if=\"(toast.promise || toastType === 'loading') && !toast.icon\"\n          >\n            <slot name=\"loading-icon\" />\n          </template>\n\n          <component :is=\"toast.icon\" v-if=\"toast.icon\" />\n\n          <template v-else>\n            <slot v-if=\"toastType === 'success'\" name=\"success-icon\" />\n            <slot v-else-if=\"toastType === 'error'\" name=\"error-icon\" />\n            <slot v-else-if=\"toastType === 'warning'\" name=\"warning-icon\" />\n            <slot v-else-if=\"toastType === 'info'\" name=\"info-icon\" />\n          </template>\n        </div>\n      </template>\n\n      <div data-content=\"\">\n        <div data-title=\"\" :class=\"cn(classes?.title, toast.classes?.title)\">\n          <template v-if=\"isStringOfTitle\">\n            <component :is=\"toast.title\" v-bind=\"toast.componentProps\" />\n          </template>\n          <template v-else>\n            {{ toast.title }}\n          </template>\n        </div>\n\n        <template v-if=\"toast.description\">\n          <div\n            data-description=\"\"\n            :class=\"\n              cn(\n                descriptionClass,\n                toastDescriptionClass,\n                classes?.description,\n                toast.classes?.description,\n              )\n            \"\n          >\n            <template v-if=\"isStringOfDescription\">\n              <component\n                :is=\"toast.description\"\n                v-bind=\"toast.componentProps\"\n              />\n            </template>\n            <template v-else>\n              {{ toast.description }}\n            </template>\n          </div>\n        </template>\n      </div>\n      <template v-if=\"toast.cancel\">\n        <button\n          :style=\"toast.cancelButtonStyle || cancelButtonStyle\"\n          :class=\"cn(classes?.cancelButton, toast.classes?.cancelButton)\"\n          data-button\n          data-cancel\n          @click=\"\n            (event) => {\n              if (!isAction(toast.cancel!)) return;\n              if (!dismissible) return;\n              toast.cancel?.onClick?.(event);\n              deleteToast();\n            }\n          \"\n        >\n          {{ isAction(toast.cancel) ? toast.cancel?.label : toast.cancel }}\n        </button>\n      </template>\n      <template v-if=\"toast.action\">\n        <button\n          :style=\"toast.actionButtonStyle || actionButtonStyle\"\n          :class=\"cn(classes?.actionButton, toast.classes?.actionButton)\"\n          data-button\n          data-action\n          @click=\"\n            (event) => {\n              if (!isAction(toast.action!)) return;\n              if (event.defaultPrevented) return;\n              toast.action?.onClick?.(event);\n              deleteToast();\n            }\n          \"\n        >\n          {{ isAction(toast.action) ? toast.action?.label : toast.action }}\n        </button>\n      </template>\n    </template>\n  </li>\n</template>\n","<script lang=\"ts\" setup>\nimport { computed, onMounted, onUnmounted, ref, watchEffect } from 'vue'\nimport { useIsDocumentHidden } from '../composables/useIsDocumentHidden'\nimport { type HeightT, isAction, type ToastProps, type ToastT } from '../types'\nimport '../styles/styles.css'\n\nconst props = defineProps<ToastProps>()\n\nconst emit = defineEmits<{\n  (e: 'update:heights', heights: HeightT[]): void\n  (e: 'removeToast', toast: ToastT): void\n}>()\n\n// Default lifetime of a toasts (in ms)\nconst TOAST_LIFETIME = 4000\nconst SWIPE_THRESHOLD = 20\nconst TIME_BEFORE_UNMOUNT = 200\n\nconst mounted = ref(false)\nconst removed = ref(false)\nconst swiping = ref(false)\nconst swipeOut = ref(false)\nconst offsetBeforeRemove = ref(0)\nconst initialHeight = ref(0)\nconst dragStartTime = ref<Date | null>(null)\nconst toastRef = ref<HTMLLIElement | null>(null)\nconst isFront = computed(() => props.index === 0)\nconst isVisible = computed(() => props.index + 1 <= props.visibleToasts)\nconst toastType = computed(() => props.toast.type)\nconst dismissible = computed(() => props.toast.dismissible !== false)\nconst toastClass = computed(() => props.toast.class || '')\nconst toastDescriptionClass = computed(() => props.descriptionClass || '')\n\nconst toastStyle = props.toast.style || {}\n\n// Height index is used to calculate the offset as it gets updated before the toast array, which means we can calculate the new layout faster.\nconst heightIndex = computed(() => props.heights.findIndex(height => height.toastId === props.toast.id) || 0)\nconst closeButton = computed(() => props.toast.closeButton ?? props.closeButton)\nconst duration = computed(() => props.toast.duration || props.duration || TOAST_LIFETIME)\n\nconst closeTimerStartTimeRef = ref(0)\nconst offset = ref(0)\nconst lastCloseTimerStartTimeRef = ref(0)\nconst pointerStartRef = ref<{ x: number, y: number } | null>(null)\nconst coords = computed(() => props.position.split('-'))\nconst y = computed(() => coords.value[0])\nconst x = computed(() => coords.value[1])\nconst isStringOfTitle = computed(() => typeof props.toast.title !== 'string')\nconst isStringOfDescription = computed(() => typeof props.toast.description !== 'string')\n\nconst toastsHeightBefore = computed(() => {\n  return props.heights.reduce((prev, curr, reducerIndex) => {\n    // Calculate offset up untill current  toast\n    if (reducerIndex >= heightIndex.value) {\n      return prev\n    }\n\n    return prev + curr.height\n  }, 0)\n})\nconst isDocumentHidden = useIsDocumentHidden()\nconst invert = computed(() => props.toast.invert || props.invert)\nconst disabled = computed(() => toastType.value === 'loading')\n\nonMounted(() => {\n  if (!mounted.value)\n    return\n\n  const toastNode = toastRef.value\n  const originalHeight = toastNode?.style.height\n  let newHeight = 0\n  if (toastNode) {\n    toastNode.style.height = 'auto'\n    newHeight = toastNode.getBoundingClientRect().height\n    toastNode.style.height = originalHeight || ''\n  }\n  initialHeight.value = newHeight\n\n  let newHeightArr\n  const alreadyExists = props.heights.find(height => height.toastId === props.toast.id)\n\n  if (!alreadyExists) {\n    newHeightArr = [\n      {\n        toastId: props.toast.id,\n        height: newHeight,\n        position: props.toast.position,\n      },\n      ...props.heights,\n    ]\n  }\n  else {\n    newHeightArr = props.heights.map(height =>\n      height.toastId === props.toast.id ? { ...height, height: newHeight } : height,\n    )\n  }\n\n  emit('update:heights', newHeightArr as HeightT[])\n})\n\nfunction deleteToast() {\n  // Save the offset for the exit swipe animation\n  removed.value = true\n  offsetBeforeRemove.value = offset.value\n  const height = props.heights.filter(height => height.toastId !== props.toast.id)\n  emit('update:heights', height)\n\n  setTimeout(() => {\n    emit('removeToast', props.toast)\n  }, TIME_BEFORE_UNMOUNT)\n}\n\nfunction handleCloseToast() {\n  if (disabled.value || !dismissible.value) {\n    return\n  }\n\n  deleteToast()\n  props.toast.onDismiss?.(props.toast)\n}\n\nfunction onPointerDown(event: PointerEvent) {\n  if (disabled.value || !dismissible.value)\n    return\n  dragStartTime.value = new Date()\n  offsetBeforeRemove.value = offset.value\n  // Ensure we maintain correct pointer capture even when going outside of the toast (e.g. when swiping)\n  ;(event.target as HTMLElement).setPointerCapture(event.pointerId)\n  if ((event.target as HTMLElement).tagName === 'BUTTON')\n    return\n  swiping.value = true\n  pointerStartRef.value = { x: event.clientX, y: event.clientY }\n}\n\nfunction onPointerUp() {\n  if (swipeOut.value)\n    return\n  pointerStartRef.value = null\n\n  const swipeAmount = Number(toastRef.value?.style.getPropertyValue('--swipe-amount').replace('px', '') || 0)\n\n  const timeTaken = new Date().getTime() - (dragStartTime.value?.getTime() || 0)\n  const velocity = Math.abs(swipeAmount) / timeTaken\n\n  // Remove only if threshold is met\n  if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {\n    offsetBeforeRemove.value = offset.value\n    props.toast.onDismiss?.(props.toast)\n    deleteToast()\n    swipeOut.value = true\n    return\n  }\n\n  toastRef.value?.style.setProperty('--swipe-amount', '0px')\n  swiping.value = false\n}\n\nfunction onPointerMove(event: PointerEvent) {\n  if (!pointerStartRef.value || !dismissible.value)\n    return\n\n  const yPosition = event.clientY - pointerStartRef.value.y\n  const xPosition = event.clientX - pointerStartRef.value.x\n\n  const clamp = coords.value[0] === 'top' ? Math.min : Math.max\n  const clampedY = clamp(0, yPosition)\n  const swipeStartThreshold = event.pointerType === 'touch' ? 10 : 2\n  const isAllowedToSwipe = Math.abs(clampedY) > swipeStartThreshold\n\n  if (isAllowedToSwipe) {\n    toastRef.value?.style.setProperty('--swipe-amount', `${yPosition}px`)\n  }\n  else if (Math.abs(xPosition) > swipeStartThreshold) {\n    // User is swiping in wrong direction so we disable swipe gesture\n    // for the current pointer down interaction\n    pointerStartRef.value = null\n  }\n}\n\nwatchEffect(() => {\n  offset.value = heightIndex.value * (props?.gap || 0) + toastsHeightBefore.value\n})\n\nwatchEffect((onInvalidate) => {\n  if (\n    (props.toast.promise && toastType.value === 'loading')\n    || props.toast.duration === Number.POSITIVE_INFINITY\n    || props.toast.type === 'loading'\n  ) {\n    return\n  }\n  let timeoutId: ReturnType<typeof setTimeout>\n  let remainingTime = duration.value\n\n  // Pause the timer on each hover\n  const pauseTimer = () => {\n    if (lastCloseTimerStartTimeRef.value < closeTimerStartTimeRef.value) {\n      // Get the elapsed time since the timer started\n      const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.value\n\n      remainingTime = remainingTime - elapsedTime\n    }\n\n    lastCloseTimerStartTimeRef.value = new Date().getTime()\n  }\n\n  const startTimer = () => {\n    if (remainingTime === Number.POSITIVE_INFINITY)\n      return\n    closeTimerStartTimeRef.value = new Date().getTime()\n\n    // Let the toast know it has started\n    timeoutId = setTimeout(() => {\n      props.toast.onAutoClose?.(props.toast)\n      deleteToast()\n    }, remainingTime)\n  }\n\n  if (props.expanded || props.interacting || (props.pauseWhenPageIsHidden && isDocumentHidden)) {\n    pauseTimer()\n  }\n  else {\n    startTimer()\n  }\n\n  onInvalidate(() => {\n    clearTimeout(timeoutId)\n  })\n})\n\n// watchEffect(() => {\n//   if (props.toast.delete) {\n//     deleteToast()\n//   }\n// })\n\nonMounted(() => {\n  if (toastRef.value) {\n    const height = toastRef.value.getBoundingClientRect().height\n    // Add toast height tot heights array after the toast is mounted\n    initialHeight.value = height\n\n    const newHeights = [\n      { toastId: props.toast.id, height, position: props.toast.position || 'top-right' },\n      ...props.heights,\n    ]\n    emit('update:heights', newHeights)\n  }\n  mounted.value = true\n})\n\nonUnmounted(() => {\n  if (toastRef.value) {\n    const newHeights = props.heights.filter(height => height.toastId !== props.toast.id)\n    emit('update:heights', newHeights)\n  }\n})\n</script>\n\n<template>\n  <li\n    ref=\"toastRef\"\n    :aria-live=\"toast.important ? 'assertive' : 'polite'\"\n    aria-atomic=\"true\"\n    role=\"status\"\n    tabindex=\"0\"\n    data-sonner-toast=\"true\"\n    :class=\"toastClass\"\n    :data-rich-colors=\"toast.richColors ?? defaultRichColors\"\n    :data-styled=\"!Boolean(toast.component || toast?.unstyled || unstyled)\"\n    :data-mounted=\"mounted\"\n    :data-promise=\"Boolean(toast.promise)\"\n    :data-removed=\"removed\"\n    :data-visible=\"isVisible\"\n    :data-y-position=\"y\"\n    :data-x-position=\"x\"\n    :data-index=\"index\"\n    :data-front=\"isFront\"\n    :data-swiping=\"swiping\"\n    :data-dismissible=\"dismissible\"\n    :data-type=\"toastType\"\n    :data-invert=\"invert\"\n    :data-swipe-out=\"swipeOut\"\n    :data-expanded=\"Boolean(expanded || (expandByDefault && mounted))\"\n    :style=\"{\n      '--index': index,\n      '--toasts-before': index,\n      '--z-index': toasts.length - index,\n      '--offset': `${removed ? offsetBeforeRemove : offset}px`,\n      '--initial-height': expandByDefault ? 'auto' : `${initialHeight}px`,\n      ...style,\n      ...toastStyle,\n    }\"\n    @pointerdown=\"onPointerDown\"\n    @pointerup=\"onPointerUp\"\n    @pointermove=\"onPointerMove\"\n  >\n    <template v-if=\"closeButton && !toast.component\">\n      <button\n        :aria-label=\"closeButtonAriaLabel || 'Close toast'\"\n        :data-disabled=\"disabled\"\n        data-close-button=\"true\"\n        :class=\"cn(classes?.closeButton, toast?.classes?.closeButton)\"\n        @click=\"handleCloseToast\"\n      >\n        <template v-if=\"icons?.close\">\n          <component :is=\"icons?.close\" />\n        </template>\n        <template v-else>\n          <slot name=\"close-icon\" />\n        </template>\n      </button>\n    </template>\n\n    <template v-if=\"toast.component\">\n      <component\n        :is=\"toast.component\"\n        v-bind=\"toast.componentProps\"\n        :on-close-toast=\"deleteToast\"\n      />\n    </template>\n\n    <template v-else>\n      <template v-if=\"toastType !== 'default' || toast.icon || toast.promise\">\n        <div data-icon=\"\">\n          <template\n            v-if=\"(toast.promise || toastType === 'loading') && !toast.icon\"\n          >\n            <slot name=\"loading-icon\" />\n          </template>\n\n          <component :is=\"toast.icon\" v-if=\"toast.icon\" />\n\n          <template v-else>\n            <slot v-if=\"toastType === 'success'\" name=\"success-icon\" />\n            <slot v-else-if=\"toastType === 'error'\" name=\"error-icon\" />\n            <slot v-else-if=\"toastType === 'warning'\" name=\"warning-icon\" />\n            <slot v-else-if=\"toastType === 'info'\" name=\"info-icon\" />\n          </template>\n        </div>\n      </template>\n\n      <div data-content=\"\">\n        <div data-title=\"\" :class=\"cn(classes?.title, toast.classes?.title)\">\n          <template v-if=\"isStringOfTitle\">\n            <component :is=\"toast.title\" v-bind=\"toast.componentProps\" />\n          </template>\n          <template v-else>\n            {{ toast.title }}\n          </template>\n        </div>\n\n        <template v-if=\"toast.description\">\n          <div\n            data-description=\"\"\n            :class=\"\n              cn(\n                descriptionClass,\n                toastDescriptionClass,\n                classes?.description,\n                toast.classes?.description,\n              )\n            \"\n          >\n            <template v-if=\"isStringOfDescription\">\n              <component\n                :is=\"toast.description\"\n                v-bind=\"toast.componentProps\"\n              />\n            </template>\n            <template v-else>\n              {{ toast.description }}\n            </template>\n          </div>\n        </template>\n      </div>\n      <template v-if=\"toast.cancel\">\n        <button\n          :style=\"toast.cancelButtonStyle || cancelButtonStyle\"\n          :class=\"cn(classes?.cancelButton, toast.classes?.cancelButton)\"\n          data-button\n          data-cancel\n          @click=\"\n            (event) => {\n              if (!isAction(toast.cancel!)) return;\n              if (!dismissible) return;\n              toast.cancel?.onClick?.(event);\n              deleteToast();\n            }\n          \"\n        >\n          {{ isAction(toast.cancel) ? toast.cancel?.label : toast.cancel }}\n        </button>\n      </template>\n      <template v-if=\"toast.action\">\n        <button\n          :style=\"toast.actionButtonStyle || actionButtonStyle\"\n          :class=\"cn(classes?.actionButton, toast.classes?.actionButton)\"\n          data-button\n          data-action\n          @click=\"\n            (event) => {\n              if (!isAction(toast.action!)) return;\n              if (event.defaultPrevented) return;\n              toast.action?.onClick?.(event);\n              deleteToast();\n            }\n          \"\n        >\n          {{ isAction(toast.action) ? toast.action?.label : toast.action }}\n        </button>\n      </template>\n    </template>\n  </li>\n</template>\n","<script lang=\"ts\">\n// Visible toasts amount\nconst VISIBLE_TOASTS_AMOUNT = 3\n// Viewport padding\nconst VIEWPORT_OFFSET = '32px'\n// Default toast width\nconst TOAST_WIDTH = 356\n// Default gap between toasts\nconst GAP = 14\n\nfunction _cn(...classes: (string | undefined)[]) {\n  return classes.filter(Boolean).join(' ')\n}\n</script>\n\n<script lang=\"ts\" setup>\n/* eslint import/first: 0 */\nimport type {\n  HeightT,\n  Position,\n  ToasterProps,\n  ToastT,\n  ToastToDismiss,\n} from '../types'\nimport { computed, nextTick, ref, useAttrs, watch, watchEffect } from 'vue'\nimport { ToastState } from '../state'\nimport LoaderIcon from './icons/Loader.vue'\nimport Toast from './Toast.vue'\n\ndefineOptions({\n  name: 'Toaster',\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ToasterProps>(), {\n  invert: false,\n  position: 'bottom-right',\n  hotkey: () => ['altKey', 'KeyT'],\n  expand: false,\n  closeButton: false,\n  class: '',\n  offset: VIEWPORT_OFFSET,\n  theme: 'light',\n  richColors: false,\n  style: () => ({}),\n  visibleToasts: VISIBLE_TOASTS_AMOUNT,\n  toastOptions: () => ({}),\n  dir: 'auto',\n  gap: GAP,\n  containerAriaLabel: 'Notifications',\n  pauseWhenPageIsHidden: false,\n  cn: _cn,\n})\n\nconst isClient = typeof window !== 'undefined' && typeof document !== 'undefined'\n\nfunction getDocumentDirection(): ToasterProps['dir'] {\n  if (typeof window === 'undefined')\n    return 'ltr'\n  if (typeof document === 'undefined')\n    return 'ltr' // For Fresh purpose\n\n  const dirAttribute = document.documentElement.getAttribute('dir')\n\n  if (dirAttribute === 'auto' || !dirAttribute) {\n    return window.getComputedStyle(document.documentElement)\n      .direction as ToasterProps['dir']\n  }\n\n  return dirAttribute as ToasterProps['dir']\n}\n\nconst attrs = useAttrs()\nconst toasts = ref<ToastT[]>([])\nconst possiblePositions = computed(() => {\n  const posList = toasts.value\n    .filter(toast => toast.position)\n    .map(toast => toast.position) as Position[]\n  return posList.length > 0\n    ? Array.from(new Set([props.position].concat(posList)))\n    : [props.position]\n})\nconst heights = ref<HeightT[]>([])\nconst expanded = ref(false)\nconst interacting = ref(false)\nconst actualTheme = ref(\n  props.theme !== 'system'\n    ? props.theme\n    : typeof window !== 'undefined'\n      ? window.matchMedia\n      && window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light'\n      : 'light',\n)\n\nconst listRef = ref<HTMLOListElement[] | HTMLOListElement | null>(null)\nconst lastFocusedElementRef = ref<HTMLElement | null>(null)\nconst isFocusWithinRef = ref(false)\n\nconst hotkeyLabel = props.hotkey\n  .join('+')\n  .replace(/Key/g, '')\n  .replace(/Digit/g, '')\n\nfunction removeToast(toastToRemove: ToastT) {\n  if (!toasts.value.find(toast => toast.id === toastToRemove.id)?.delete) {\n    ToastState.dismiss(toastToRemove.id)\n  }\n\n  toasts.value = toasts.value.filter(({ id }) => id !== toastToRemove.id)\n}\n\nfunction onBlur(event: FocusEvent | any) {\n  if (\n    isFocusWithinRef.value\n    && !event.currentTarget?.contains?.(event.relatedTarget)\n  ) {\n    isFocusWithinRef.value = false\n    if (lastFocusedElementRef.value) {\n      lastFocusedElementRef.value.focus({ preventScroll: true })\n      lastFocusedElementRef.value = null\n    }\n  }\n}\n\nfunction onFocus(event: FocusEvent | any) {\n  const isNotDismissible\n    = event.target instanceof HTMLElement\n    && event.target.dataset.dismissible === 'false'\n\n  if (isNotDismissible)\n    return\n\n  if (!isFocusWithinRef.value) {\n    isFocusWithinRef.value = true\n    lastFocusedElementRef.value = event.relatedTarget as HTMLElement\n  }\n}\n\nfunction onPointerDown(event: PointerEvent) {\n  if (event.target) {\n    const isNotDismissible\n      = event.target instanceof HTMLElement\n      && event.target.dataset.dismissible === 'false'\n\n    if (isNotDismissible)\n      return\n  }\n  interacting.value = false\n}\n\nwatchEffect((onInvalidate) => {\n  const unsubscribe = ToastState.subscribe((toast) => {\n    if ((toast as ToastToDismiss).dismiss) {\n      toasts.value = toasts.value.map(t =>\n        t.id === toast.id ? { ...t, delete: true } : t,\n      )\n      return\n    }\n\n    nextTick(() => {\n      const indexOfExistingToast = toasts.value.findIndex(\n        t => t.id === toast.id,\n      )\n\n      // Update the toast if it already exists\n      if (indexOfExistingToast !== -1) {\n        toasts.value = [\n          ...toasts.value.slice(0, indexOfExistingToast),\n          { ...toasts.value[indexOfExistingToast], ...toast },\n          ...toasts.value.slice(indexOfExistingToast + 1),\n        ]\n      }\n      else {\n        toasts.value = [toast, ...toasts.value]\n      }\n    })\n  })\n\n  onInvalidate(() => {\n    unsubscribe()\n  })\n})\n\nwatch(\n  () => props.theme,\n  (newTheme) => {\n    if (newTheme !== 'system') {\n      actualTheme.value = newTheme\n      return\n    }\n\n    if (newTheme === 'system') {\n      // check if current preference is dark\n      if (\n        window.matchMedia\n        && window.matchMedia('(prefers-color-scheme: dark)').matches\n      ) {\n        // it's currently dark\n        actualTheme.value = 'dark'\n      }\n      else {\n        // it's not dark\n        actualTheme.value = 'light'\n      }\n    }\n\n    if (typeof window === 'undefined')\n      return\n\n    window\n      .matchMedia('(prefers-color-scheme: dark)')\n      .addEventListener('change', ({ matches }) => {\n        if (matches) {\n          actualTheme.value = 'dark'\n        }\n        else {\n          actualTheme.value = 'light'\n        }\n      })\n  },\n)\n\nwatch(\n  () => listRef.value,\n  () => {\n    if (listRef.value) {\n      return () => {\n        if (lastFocusedElementRef.value) {\n          lastFocusedElementRef.value.focus({ preventScroll: true })\n          lastFocusedElementRef.value = null\n          isFocusWithinRef.value = false\n        }\n      }\n    }\n  },\n)\n\nwatchEffect(() => {\n  // Ensure expanded is always false when no toasts are present / only one left\n  if (toasts.value.length <= 1) {\n    expanded.value = false\n  }\n})\n\nwatchEffect((onInvalidate) => {\n  function handleKeyDown(event: KeyboardEvent) {\n    const isHotkeyPressed = props.hotkey.every(\n      key => (event as any)[key] || event.code === key,\n    )\n\n    const listRefItem = Array.isArray(listRef.value)\n      ? listRef.value[0]\n      : listRef.value\n\n    if (isHotkeyPressed) {\n      expanded.value = true\n      listRefItem?.focus()\n    }\n\n    const isItemActive\n      = document.activeElement === listRef.value\n      || listRefItem?.contains(document.activeElement)\n\n    if (event.code === 'Escape' && isItemActive) {\n      expanded.value = false\n    }\n  }\n\n  if (!isClient)\n    return\n\n  document.addEventListener('keydown', handleKeyDown)\n\n  onInvalidate(() => {\n    document.removeEventListener('keydown', handleKeyDown)\n  })\n})\n</script>\n\n<template>\n  <!-- Remove item from normal navigation flow, only available via hotkey -->\n  <section :aria-label=\"`${containerAriaLabel} ${hotkeyLabel}`\" :tabIndex=\"-1\">\n    <template v-for=\"(pos, index) in possiblePositions\" :key=\"pos\">\n      <ol\n        ref=\"listRef\"\n        data-sonner-toaster\n        :class=\"props.class\"\n        :dir=\"dir === 'auto' ? getDocumentDirection() : dir\"\n        :tabIndex=\"-1\"\n        :data-theme=\"theme\"\n        :data-rich-colors=\"richColors\"\n        :data-y-position=\"pos.split('-')[0]\"\n        :data-x-position=\"pos.split('-')[1]\"\n        :style=\"\n          {\n            '--front-toast-height': `${heights[0]?.height}px`,\n            '--offset': typeof offset === 'number' ? `${offset}px` : offset || VIEWPORT_OFFSET,\n            '--width': `${TOAST_WIDTH}px`,\n            '--gap': `${gap}px`,\n            ...style,\n            ...(attrs as Record<string, Record<string, any>>).style,\n          }\n        \"\n        v-bind=\"$attrs\"\n        @blur=\"onBlur\"\n        @focus=\"onFocus\"\n        @mouseenter=\"() => (expanded = true)\"\n        @mousemove=\"() => (expanded = true)\"\n        @mouseleave=\"\n          () => {\n            // Avoid setting expanded to false when interacting with a toast, e.g. swiping\n            if (!interacting) {\n              expanded = false\n            }\n          }\n        \"\n        @pointerdown=\"onPointerDown\"\n        @pointerup=\"() => (interacting = false)\"\n      >\n        <template\n          v-for=\"(toast, idx) in toasts.filter(\n            (toast) =>\n              (!toast.position && index === 0) || toast.position === pos,\n          )\"\n          :key=\"toast.id\"\n        >\n          <Toast\n            :heights=\"heights.filter((h) => h.position === toast.position)\"\n            :icons=\"icons\"\n            :index=\"idx\"\n            :toast=\"toast\"\n            :default-rich-colors=\"richColors\"\n            :duration=\"toastOptions?.duration ?? duration\"\n            :class=\"toastOptions?.class ?? ''\"\n            :description-class=\"toastOptions?.descriptionClass\"\n            :invert=\"invert\"\n            :visible-toasts=\"visibleToasts\"\n            :close-button=\"toastOptions?.closeButton ?? closeButton\"\n            :interacting=\"interacting\"\n            :position=\"pos\"\n            :style=\"toastOptions?.style\"\n            :unstyled=\"toastOptions?.unstyled\"\n            :classes=\"toastOptions?.classes\"\n            :cancel-button-style=\"toastOptions?.cancelButtonStyle\"\n            :action-button-style=\"toastOptions?.actionButtonStyle\"\n            :toasts=\"toasts.filter((t) => t.position === toast.position)\"\n            :expand-by-default=\"expand\"\n            :gap=\"gap\"\n            :expanded=\"expanded\"\n            :pause-when-page-is-hidden=\"pauseWhenPageIsHidden\"\n            :cn=\"cn\"\n            @update:heights=\"\n              (h) => {\n                heights = h\n              }\n            \"\n            @remove-toast=\"removeToast\"\n          >\n            <template #close-icon>\n              <slot name=\"close-icon\">\n                <div class=\"i-ic:outline-close h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #loading-icon>\n              <slot name=\"loading-icon\">\n                <LoaderIcon :visible=\"toast.type === 'loading'\" />\n              </slot>\n            </template>\n\n            <template #success-icon>\n              <slot name=\"success-icon\">\n                <div class=\"i-ic:baseline-check-circle h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #error-icon>\n              <slot name=\"error-icon\">\n                <div class=\"i-ic:baseline-error h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #warning-icon>\n              <slot name=\"warning-icon\">\n                <div class=\"i-ic:baseline-warning h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #info-icon>\n              <slot name=\"info-icon\">\n                <div class=\"i-ic:baseline-info h-5 w-5\" />\n              </slot>\n            </template>\n          </Toast>\n        </template>\n      </ol>\n    </template>\n  </section>\n</template>\n","<script lang=\"ts\">\n// Visible toasts amount\nconst VISIBLE_TOASTS_AMOUNT = 3\n// Viewport padding\nconst VIEWPORT_OFFSET = '32px'\n// Default toast width\nconst TOAST_WIDTH = 356\n// Default gap between toasts\nconst GAP = 14\n\nfunction _cn(...classes: (string | undefined)[]) {\n  return classes.filter(Boolean).join(' ')\n}\n</script>\n\n<script lang=\"ts\" setup>\n/* eslint import/first: 0 */\nimport type {\n  HeightT,\n  Position,\n  ToasterProps,\n  ToastT,\n  ToastToDismiss,\n} from '../types'\nimport { computed, nextTick, ref, useAttrs, watch, watchEffect } from 'vue'\nimport { ToastState } from '../state'\nimport LoaderIcon from './icons/Loader.vue'\nimport Toast from './Toast.vue'\n\ndefineOptions({\n  name: 'Toaster',\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ToasterProps>(), {\n  invert: false,\n  position: 'bottom-right',\n  hotkey: () => ['altKey', 'KeyT'],\n  expand: false,\n  closeButton: false,\n  class: '',\n  offset: VIEWPORT_OFFSET,\n  theme: 'light',\n  richColors: false,\n  style: () => ({}),\n  visibleToasts: VISIBLE_TOASTS_AMOUNT,\n  toastOptions: () => ({}),\n  dir: 'auto',\n  gap: GAP,\n  containerAriaLabel: 'Notifications',\n  pauseWhenPageIsHidden: false,\n  cn: _cn,\n})\n\nconst isClient = typeof window !== 'undefined' && typeof document !== 'undefined'\n\nfunction getDocumentDirection(): ToasterProps['dir'] {\n  if (typeof window === 'undefined')\n    return 'ltr'\n  if (typeof document === 'undefined')\n    return 'ltr' // For Fresh purpose\n\n  const dirAttribute = document.documentElement.getAttribute('dir')\n\n  if (dirAttribute === 'auto' || !dirAttribute) {\n    return window.getComputedStyle(document.documentElement)\n      .direction as ToasterProps['dir']\n  }\n\n  return dirAttribute as ToasterProps['dir']\n}\n\nconst attrs = useAttrs()\nconst toasts = ref<ToastT[]>([])\nconst possiblePositions = computed(() => {\n  const posList = toasts.value\n    .filter(toast => toast.position)\n    .map(toast => toast.position) as Position[]\n  return posList.length > 0\n    ? Array.from(new Set([props.position].concat(posList)))\n    : [props.position]\n})\nconst heights = ref<HeightT[]>([])\nconst expanded = ref(false)\nconst interacting = ref(false)\nconst actualTheme = ref(\n  props.theme !== 'system'\n    ? props.theme\n    : typeof window !== 'undefined'\n      ? window.matchMedia\n      && window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light'\n      : 'light',\n)\n\nconst listRef = ref<HTMLOListElement[] | HTMLOListElement | null>(null)\nconst lastFocusedElementRef = ref<HTMLElement | null>(null)\nconst isFocusWithinRef = ref(false)\n\nconst hotkeyLabel = props.hotkey\n  .join('+')\n  .replace(/Key/g, '')\n  .replace(/Digit/g, '')\n\nfunction removeToast(toastToRemove: ToastT) {\n  if (!toasts.value.find(toast => toast.id === toastToRemove.id)?.delete) {\n    ToastState.dismiss(toastToRemove.id)\n  }\n\n  toasts.value = toasts.value.filter(({ id }) => id !== toastToRemove.id)\n}\n\nfunction onBlur(event: FocusEvent | any) {\n  if (\n    isFocusWithinRef.value\n    && !event.currentTarget?.contains?.(event.relatedTarget)\n  ) {\n    isFocusWithinRef.value = false\n    if (lastFocusedElementRef.value) {\n      lastFocusedElementRef.value.focus({ preventScroll: true })\n      lastFocusedElementRef.value = null\n    }\n  }\n}\n\nfunction onFocus(event: FocusEvent | any) {\n  const isNotDismissible\n    = event.target instanceof HTMLElement\n    && event.target.dataset.dismissible === 'false'\n\n  if (isNotDismissible)\n    return\n\n  if (!isFocusWithinRef.value) {\n    isFocusWithinRef.value = true\n    lastFocusedElementRef.value = event.relatedTarget as HTMLElement\n  }\n}\n\nfunction onPointerDown(event: PointerEvent) {\n  if (event.target) {\n    const isNotDismissible\n      = event.target instanceof HTMLElement\n      && event.target.dataset.dismissible === 'false'\n\n    if (isNotDismissible)\n      return\n  }\n  interacting.value = false\n}\n\nwatchEffect((onInvalidate) => {\n  const unsubscribe = ToastState.subscribe((toast) => {\n    if ((toast as ToastToDismiss).dismiss) {\n      toasts.value = toasts.value.map(t =>\n        t.id === toast.id ? { ...t, delete: true } : t,\n      )\n      return\n    }\n\n    nextTick(() => {\n      const indexOfExistingToast = toasts.value.findIndex(\n        t => t.id === toast.id,\n      )\n\n      // Update the toast if it already exists\n      if (indexOfExistingToast !== -1) {\n        toasts.value = [\n          ...toasts.value.slice(0, indexOfExistingToast),\n          { ...toasts.value[indexOfExistingToast], ...toast },\n          ...toasts.value.slice(indexOfExistingToast + 1),\n        ]\n      }\n      else {\n        toasts.value = [toast, ...toasts.value]\n      }\n    })\n  })\n\n  onInvalidate(() => {\n    unsubscribe()\n  })\n})\n\nwatch(\n  () => props.theme,\n  (newTheme) => {\n    if (newTheme !== 'system') {\n      actualTheme.value = newTheme\n      return\n    }\n\n    if (newTheme === 'system') {\n      // check if current preference is dark\n      if (\n        window.matchMedia\n        && window.matchMedia('(prefers-color-scheme: dark)').matches\n      ) {\n        // it's currently dark\n        actualTheme.value = 'dark'\n      }\n      else {\n        // it's not dark\n        actualTheme.value = 'light'\n      }\n    }\n\n    if (typeof window === 'undefined')\n      return\n\n    window\n      .matchMedia('(prefers-color-scheme: dark)')\n      .addEventListener('change', ({ matches }) => {\n        if (matches) {\n          actualTheme.value = 'dark'\n        }\n        else {\n          actualTheme.value = 'light'\n        }\n      })\n  },\n)\n\nwatch(\n  () => listRef.value,\n  () => {\n    if (listRef.value) {\n      return () => {\n        if (lastFocusedElementRef.value) {\n          lastFocusedElementRef.value.focus({ preventScroll: true })\n          lastFocusedElementRef.value = null\n          isFocusWithinRef.value = false\n        }\n      }\n    }\n  },\n)\n\nwatchEffect(() => {\n  // Ensure expanded is always false when no toasts are present / only one left\n  if (toasts.value.length <= 1) {\n    expanded.value = false\n  }\n})\n\nwatchEffect((onInvalidate) => {\n  function handleKeyDown(event: KeyboardEvent) {\n    const isHotkeyPressed = props.hotkey.every(\n      key => (event as any)[key] || event.code === key,\n    )\n\n    const listRefItem = Array.isArray(listRef.value)\n      ? listRef.value[0]\n      : listRef.value\n\n    if (isHotkeyPressed) {\n      expanded.value = true\n      listRefItem?.focus()\n    }\n\n    const isItemActive\n      = document.activeElement === listRef.value\n      || listRefItem?.contains(document.activeElement)\n\n    if (event.code === 'Escape' && isItemActive) {\n      expanded.value = false\n    }\n  }\n\n  if (!isClient)\n    return\n\n  document.addEventListener('keydown', handleKeyDown)\n\n  onInvalidate(() => {\n    document.removeEventListener('keydown', handleKeyDown)\n  })\n})\n</script>\n\n<template>\n  <!-- Remove item from normal navigation flow, only available via hotkey -->\n  <section :aria-label=\"`${containerAriaLabel} ${hotkeyLabel}`\" :tabIndex=\"-1\">\n    <template v-for=\"(pos, index) in possiblePositions\" :key=\"pos\">\n      <ol\n        ref=\"listRef\"\n        data-sonner-toaster\n        :class=\"props.class\"\n        :dir=\"dir === 'auto' ? getDocumentDirection() : dir\"\n        :tabIndex=\"-1\"\n        :data-theme=\"theme\"\n        :data-rich-colors=\"richColors\"\n        :data-y-position=\"pos.split('-')[0]\"\n        :data-x-position=\"pos.split('-')[1]\"\n        :style=\"\n          {\n            '--front-toast-height': `${heights[0]?.height}px`,\n            '--offset': typeof offset === 'number' ? `${offset}px` : offset || VIEWPORT_OFFSET,\n            '--width': `${TOAST_WIDTH}px`,\n            '--gap': `${gap}px`,\n            ...style,\n            ...(attrs as Record<string, Record<string, any>>).style,\n          }\n        \"\n        v-bind=\"$attrs\"\n        @blur=\"onBlur\"\n        @focus=\"onFocus\"\n        @mouseenter=\"() => (expanded = true)\"\n        @mousemove=\"() => (expanded = true)\"\n        @mouseleave=\"\n          () => {\n            // Avoid setting expanded to false when interacting with a toast, e.g. swiping\n            if (!interacting) {\n              expanded = false\n            }\n          }\n        \"\n        @pointerdown=\"onPointerDown\"\n        @pointerup=\"() => (interacting = false)\"\n      >\n        <template\n          v-for=\"(toast, idx) in toasts.filter(\n            (toast) =>\n              (!toast.position && index === 0) || toast.position === pos,\n          )\"\n          :key=\"toast.id\"\n        >\n          <Toast\n            :heights=\"heights.filter((h) => h.position === toast.position)\"\n            :icons=\"icons\"\n            :index=\"idx\"\n            :toast=\"toast\"\n            :default-rich-colors=\"richColors\"\n            :duration=\"toastOptions?.duration ?? duration\"\n            :class=\"toastOptions?.class ?? ''\"\n            :description-class=\"toastOptions?.descriptionClass\"\n            :invert=\"invert\"\n            :visible-toasts=\"visibleToasts\"\n            :close-button=\"toastOptions?.closeButton ?? closeButton\"\n            :interacting=\"interacting\"\n            :position=\"pos\"\n            :style=\"toastOptions?.style\"\n            :unstyled=\"toastOptions?.unstyled\"\n            :classes=\"toastOptions?.classes\"\n            :cancel-button-style=\"toastOptions?.cancelButtonStyle\"\n            :action-button-style=\"toastOptions?.actionButtonStyle\"\n            :toasts=\"toasts.filter((t) => t.position === toast.position)\"\n            :expand-by-default=\"expand\"\n            :gap=\"gap\"\n            :expanded=\"expanded\"\n            :pause-when-page-is-hidden=\"pauseWhenPageIsHidden\"\n            :cn=\"cn\"\n            @update:heights=\"\n              (h) => {\n                heights = h\n              }\n            \"\n            @remove-toast=\"removeToast\"\n          >\n            <template #close-icon>\n              <slot name=\"close-icon\">\n                <div class=\"i-ic:outline-close h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #loading-icon>\n              <slot name=\"loading-icon\">\n                <LoaderIcon :visible=\"toast.type === 'loading'\" />\n              </slot>\n            </template>\n\n            <template #success-icon>\n              <slot name=\"success-icon\">\n                <div class=\"i-ic:baseline-check-circle h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #error-icon>\n              <slot name=\"error-icon\">\n                <div class=\"i-ic:baseline-error h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #warning-icon>\n              <slot name=\"warning-icon\">\n                <div class=\"i-ic:baseline-warning h-5 w-5\" />\n              </slot>\n            </template>\n\n            <template #info-icon>\n              <slot name=\"info-icon\">\n                <div class=\"i-ic:baseline-info h-5 w-5\" />\n              </slot>\n            </template>\n          </Toast>\n        </template>\n      </ol>\n    </template>\n  </section>\n</template>\n","import type { Ref } from 'vue'\nimport type { ToastT } from '../types'\nimport { ref, watchEffect } from 'vue'\nimport { ToastState } from '../state'\n\nexport function useNotification(): {\n  activeToasts: Ref<ToastT[]>\n} {\n  const activeToasts = ref<ToastT[]>([])\n\n  watchEffect((onInvalidate) => {\n    const unsubscribe = ToastState.subscribe((toast) => {\n      if ('dismiss' in toast && toast.dismiss) {\n        return activeToasts.value.filter(t => t.id !== toast.id)\n      }\n\n      const existingToastIndex = activeToasts.value.findIndex(t => t.id === toast.id)\n      if (existingToastIndex !== -1) {\n        const updatedToasts = [...activeToasts.value]\n        updatedToasts[existingToastIndex] = {\n          ...updatedToasts[existingToastIndex],\n          ...toast,\n        }\n\n        activeToasts.value = updatedToasts\n      }\n      else {\n        activeToasts.value = [toast, ...activeToasts.value]\n      }\n    })\n\n    onInvalidate(() => {\n      unsubscribe()\n    })\n  })\n\n  return {\n    activeToasts,\n  }\n}\n","import type { Plugin } from 'vue'\nimport type { Action, ExternalToast, NotificationProps, ToastClasses, ToastT, ToastToDismiss } from './types'\nimport { Toaster as Notification, Toaster } from './components'\nimport { useNotification } from './composables/useNotification'\nimport { notification, toast } from './state'\n\nexport {\n  type Action,\n  type ExternalToast,\n  Notification,\n  notification,\n  type NotificationProps,\n  toast,\n  type ToastClasses,\n  Toaster,\n  type ToastT,\n  type ToastToDismiss,\n  useNotification,\n}\n\nconst plugin: Plugin = {\n  install(app) {\n    app.component('Notification', Notification)\n  },\n}\n\nexport default plugin\n"],"mappings":""}