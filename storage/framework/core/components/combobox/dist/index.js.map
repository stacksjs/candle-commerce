{"version":3,"file":"index.js","names":["b","i","d","b","u","e","r","i","s","f","p","t","t","e","o","o","s","e","t","r","i","n","i","o","e","s","e","r","o","r","n","o","e","o","e","l","n","u","r","n","e","t","i","d","t","e","r","n","s","c","i","r","t","n","o","c","e","N","n","T","o","t","h","w","r","f","M","l","y","i","t","i","u","e","t","n","m","r","o","w","e","n","t","r","i","o","f","l","s","e","r","t","c","o","n","p","C","d","u","E","i","T","M","r","t","e","n","f","i","l","u","o","e","o","n","t","i","e","t","d","o","p","r","l","u","c","f","n","o","e","r","t","i","n","l","d","w","h","u","c","f","s","g","O","k","x","u","e","a","t","n","i","r","d","o","p","n","i","e","p","t","o","r","r","f","t","n","e","t","d","e","n","r","u","l","i","f","n","t","r","s","e","i","s","t","r","n","o","f","h","r","y","ee","H","m","c","x","f","o","re","u","e","k","J","te","z","de","S","v","d","E","w","t","n","s","b","A","Te","O","pe","_","i","L","l","T","P","le","j","ve","ce","Re","G","g","X","se","Ie","Oe","Pe","Se","U","Z","W","N","F","me","he","ae","be","oe","Q","Y","Ce","ge","fe","ye","we","xe","plugin: Plugin"],"sources":["../../../../../../node_modules/@tanstack/virtual-core/dist/esm/utils.js","../../../../../../node_modules/@tanstack/virtual-core/dist/esm/index.js","../../../../../../node_modules/@tanstack/vue-virtual/dist/esm/index.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-controllable.js","../../../../../../node_modules/@headlessui/vue/dist/utils/micro-task.js","../../../../../../node_modules/@headlessui/vue/dist/utils/disposables.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-disposables.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-frame-debounce.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-id.js","../../../../../../node_modules/@headlessui/vue/dist/utils/dom.js","../../../../../../node_modules/@headlessui/vue/dist/utils/match.js","../../../../../../node_modules/@headlessui/vue/dist/utils/env.js","../../../../../../node_modules/@headlessui/vue/dist/utils/owner.js","../../../../../../node_modules/@headlessui/vue/dist/utils/focus-management.js","../../../../../../node_modules/@headlessui/vue/dist/utils/platform.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-document-event.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-window-event.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-outside-click.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-resolve-button-type.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-tracked-pointer.js","../../../../../../node_modules/@headlessui/vue/dist/hooks/use-tree-walker.js","../../../../../../node_modules/@headlessui/vue/dist/utils/render.js","../../../../../../node_modules/@headlessui/vue/dist/internal/hidden.js","../../../../../../node_modules/@headlessui/vue/dist/internal/open-closed.js","../../../../../../node_modules/@headlessui/vue/dist/keyboard.js","../../../../../../node_modules/@headlessui/vue/dist/mouse.js","../../../../../../node_modules/@headlessui/vue/dist/utils/document-ready.js","../../../../../../node_modules/@headlessui/vue/dist/utils/active-element-history.js","../../../../../../node_modules/@headlessui/vue/dist/utils/calculate-active-index.js","../../../../../../node_modules/@headlessui/vue/dist/utils/form.js","../../../../../../node_modules/@headlessui/vue/dist/components/combobox/combobox.js","../src/index.ts"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      let attempts = 0;\n      const maxAttempts = 10;\n      const tryScroll = (currentAlign) => {\n        if (!this.targetWindow) return;\n        const offsetInfo = this.getOffsetForIndex(index, currentAlign);\n        if (!offsetInfo) {\n          console.warn(\"Failed to get offset for index:\", index);\n          return;\n        }\n        const [offset, align] = offsetInfo;\n        this._scrollToOffset(offset, { adjustments: void 0, behavior });\n        this.targetWindow.requestAnimationFrame(() => {\n          const currentOffset = this.getScrollOffset();\n          const afterInfo = this.getOffsetForIndex(index, align);\n          if (!afterInfo) {\n            console.warn(\"Failed to get offset for index:\", index);\n            return;\n          }\n          if (!approxEqual(afterInfo[0], currentOffset)) {\n            scheduleRetry(align);\n          }\n        });\n      };\n      const scheduleRetry = (align) => {\n        if (!this.targetWindow) return;\n        attempts++;\n        if (attempts < maxAttempts) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"Schedule retry\", attempts, maxAttempts);\n          }\n          this.targetWindow.requestAnimationFrame(() => tryScroll(align));\n        } else {\n          console.warn(\n            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`\n          );\n        }\n      };\n      tryScroll(initialAlign);\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n","import { elementScroll, observeElementOffset, observeElementRect, windowScroll, observeWindowOffset, observeWindowRect, Virtualizer } from \"@tanstack/virtual-core\";\nexport * from \"@tanstack/virtual-core\";\nimport { computed, unref, shallowRef, watch, triggerRef, onScopeDispose } from \"vue\";\nfunction useVirtualizerBase(options) {\n  const virtualizer = new Virtualizer(unref(options));\n  const state = shallowRef(virtualizer);\n  const cleanup = virtualizer._didMount();\n  watch(\n    () => unref(options).getScrollElement(),\n    (el) => {\n      if (el) {\n        virtualizer._willUpdate();\n      }\n    },\n    {\n      immediate: true\n    }\n  );\n  watch(\n    () => unref(options),\n    (options2) => {\n      virtualizer.setOptions({\n        ...options2,\n        onChange: (instance, sync) => {\n          var _a;\n          triggerRef(state);\n          (_a = options2.onChange) == null ? void 0 : _a.call(options2, instance, sync);\n        }\n      });\n      virtualizer._willUpdate();\n      triggerRef(state);\n    },\n    {\n      immediate: true\n    }\n  );\n  onScopeDispose(cleanup);\n  return state;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase(\n    computed(() => ({\n      observeElementRect,\n      observeElementOffset,\n      scrollToFn: elementScroll,\n      ...unref(options)\n    }))\n  );\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase(\n    computed(() => ({\n      getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n      observeElementRect: observeWindowRect,\n      observeElementOffset: observeWindowOffset,\n      scrollToFn: windowScroll,\n      initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n      ...unref(options)\n    }))\n  );\n}\nexport {\n  useVirtualizer,\n  useWindowVirtualizer\n};\n//# sourceMappingURL=index.js.map\n","import{computed as p,ref as s}from\"vue\";function d(u,e,r){let i=s(r==null?void 0:r.value),f=p(()=>u.value!==void 0);return[p(()=>f.value?u.value:i.value),function(t){return f.value||(i.value=t),e==null?void 0:e(t)}]}export{d as useControllable};\n","function t(e){typeof queueMicrotask==\"function\"?queueMicrotask(e):Promise.resolve().then(e).catch(o=>setTimeout(()=>{throw o}))}export{t as microTask};\n","import{microTask as n}from'./micro-task.js';function o(){let a=[],s={addEventListener(e,t,r,i){return e.addEventListener(t,r,i),s.add(()=>e.removeEventListener(t,r,i))},requestAnimationFrame(...e){let t=requestAnimationFrame(...e);s.add(()=>cancelAnimationFrame(t))},nextFrame(...e){s.requestAnimationFrame(()=>{s.requestAnimationFrame(...e)})},setTimeout(...e){let t=setTimeout(...e);s.add(()=>clearTimeout(t))},microTask(...e){let t={current:!0};return n(()=>{t.current&&e[0]()}),s.add(()=>{t.current=!1})},style(e,t,r){let i=e.style.getPropertyValue(t);return Object.assign(e.style,{[t]:r}),this.add(()=>{Object.assign(e.style,{[t]:i})})},group(e){let t=o();return e(t),this.add(()=>t.dispose())},add(e){return a.push(e),()=>{let t=a.indexOf(e);if(t>=0)for(let r of a.splice(t,1))r()}},dispose(){for(let e of a.splice(0))e()}};return s}export{o as disposables};\n","import{onUnmounted as s}from\"vue\";import{disposables as e}from'../utils/disposables.js';function i(){let o=e();return s(()=>o.dispose()),o}export{i as useDisposables};\n","import{useDisposables as r}from'./use-disposables.js';function t(){let e=r();return o=>{e.dispose(),e.nextFrame(o)}}export{t as useFrameDebounce};\n","var r;import*as e from\"vue\";let n=Symbol(\"headlessui.useid\"),o=0;const i=(r=e.useId)!=null?r:function(){return e.inject(n,()=>`${++o}`)()};function s(t){e.provide(n,t)}export{s as provideUseId,i as useId};\n","function o(e){var l;if(e==null||e.value==null)return null;let n=(l=e.value.$el)!=null?l:e.value;return n instanceof Node?n:null}export{o as dom};\n","function u(r,n,...a){if(r in n){let e=n[r];return typeof e==\"function\"?e(...a):e}let t=new Error(`Tried to handle \"${r}\" but there is no handler defined. Only defined handlers are: ${Object.keys(n).map(e=>`\"${e}\"`).join(\", \")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,u),t}export{u as match};\n","var i=Object.defineProperty;var d=(t,e,r)=>e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var n=(t,e,r)=>(d(t,typeof e!=\"symbol\"?e+\"\":e,r),r);class s{constructor(){n(this,\"current\",this.detect());n(this,\"currentId\",0)}set(e){this.current!==e&&(this.currentId=0,this.current=e)}reset(){this.set(this.detect())}nextId(){return++this.currentId}get isServer(){return this.current===\"server\"}get isClient(){return this.current===\"client\"}detect(){return typeof window==\"undefined\"||typeof document==\"undefined\"?\"server\":\"client\"}}let c=new s;export{c as env};\n","import{dom as o}from'./dom.js';import{env as t}from'./env.js';function i(r){if(t.isServer)return null;if(r instanceof Node)return r.ownerDocument;if(r!=null&&r.hasOwnProperty(\"value\")){let n=o(r);if(n)return n.ownerDocument}return document}export{i as getOwnerDocument};\n","import{nextTick as b}from\"vue\";import{match as M}from'./match.js';import{getOwnerDocument as f}from'./owner.js';let c=[\"[contentEditable=true]\",\"[tabindex]\",\"a[href]\",\"area[href]\",\"button:not([disabled])\",\"iframe\",\"input:not([disabled])\",\"select:not([disabled])\",\"textarea:not([disabled])\"].map(e=>`${e}:not([tabindex='-1'])`).join(\",\");var N=(n=>(n[n.First=1]=\"First\",n[n.Previous=2]=\"Previous\",n[n.Next=4]=\"Next\",n[n.Last=8]=\"Last\",n[n.WrapAround=16]=\"WrapAround\",n[n.NoScroll=32]=\"NoScroll\",n))(N||{}),T=(o=>(o[o.Error=0]=\"Error\",o[o.Overflow=1]=\"Overflow\",o[o.Success=2]=\"Success\",o[o.Underflow=3]=\"Underflow\",o))(T||{}),F=(t=>(t[t.Previous=-1]=\"Previous\",t[t.Next=1]=\"Next\",t))(F||{});function E(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(c)).sort((r,t)=>Math.sign((r.tabIndex||Number.MAX_SAFE_INTEGER)-(t.tabIndex||Number.MAX_SAFE_INTEGER)))}var h=(t=>(t[t.Strict=0]=\"Strict\",t[t.Loose=1]=\"Loose\",t))(h||{});function w(e,r=0){var t;return e===((t=f(e))==null?void 0:t.body)?!1:M(r,{[0](){return e.matches(c)},[1](){let l=e;for(;l!==null;){if(l.matches(c))return!0;l=l.parentElement}return!1}})}function _(e){let r=f(e);b(()=>{r&&!w(r.activeElement,0)&&S(e)})}var y=(t=>(t[t.Keyboard=0]=\"Keyboard\",t[t.Mouse=1]=\"Mouse\",t))(y||{});typeof window!=\"undefined\"&&typeof document!=\"undefined\"&&(document.addEventListener(\"keydown\",e=>{e.metaKey||e.altKey||e.ctrlKey||(document.documentElement.dataset.headlessuiFocusVisible=\"\")},!0),document.addEventListener(\"click\",e=>{e.detail===1?delete document.documentElement.dataset.headlessuiFocusVisible:e.detail===0&&(document.documentElement.dataset.headlessuiFocusVisible=\"\")},!0));function S(e){e==null||e.focus({preventScroll:!0})}let H=[\"textarea\",\"input\"].join(\",\");function I(e){var r,t;return(t=(r=e==null?void 0:e.matches)==null?void 0:r.call(e,H))!=null?t:!1}function O(e,r=t=>t){return e.slice().sort((t,l)=>{let o=r(t),i=r(l);if(o===null||i===null)return 0;let n=o.compareDocumentPosition(i);return n&Node.DOCUMENT_POSITION_FOLLOWING?-1:n&Node.DOCUMENT_POSITION_PRECEDING?1:0})}function v(e,r){return P(E(),r,{relativeTo:e})}function P(e,r,{sorted:t=!0,relativeTo:l=null,skipElements:o=[]}={}){var m;let i=(m=Array.isArray(e)?e.length>0?e[0].ownerDocument:document:e==null?void 0:e.ownerDocument)!=null?m:document,n=Array.isArray(e)?t?O(e):e:E(e);o.length>0&&n.length>1&&(n=n.filter(s=>!o.includes(s))),l=l!=null?l:i.activeElement;let x=(()=>{if(r&5)return 1;if(r&10)return-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),p=(()=>{if(r&1)return 0;if(r&2)return Math.max(0,n.indexOf(l))-1;if(r&4)return Math.max(0,n.indexOf(l))+1;if(r&8)return n.length-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),L=r&32?{preventScroll:!0}:{},a=0,d=n.length,u;do{if(a>=d||a+d<=0)return 0;let s=p+a;if(r&16)s=(s+d)%d;else{if(s<0)return 3;if(s>=d)return 1}u=n[s],u==null||u.focus(L),a+=x}while(u!==i.activeElement);return r&6&&I(u)&&u.select(),2}export{N as Focus,T as FocusResult,h as FocusableMode,S as focusElement,v as focusFrom,P as focusIn,E as getFocusableElements,w as isFocusableElement,_ as restoreFocusIfNecessary,O as sortByDomNode};\n","function t(){return/iPhone/gi.test(window.navigator.platform)||/Mac/gi.test(window.navigator.platform)&&window.navigator.maxTouchPoints>0}function i(){return/Android/gi.test(window.navigator.userAgent)}function n(){return t()||i()}export{i as isAndroid,t as isIOS,n as isMobile};\n","import{watchEffect as r}from\"vue\";import{env as m}from'../utils/env.js';function u(e,t,n){m.isServer||r(o=>{document.addEventListener(e,t,n),o(()=>document.removeEventListener(e,t,n))})}export{u as useDocumentEvent};\n","import{watchEffect as i}from\"vue\";import{env as r}from'../utils/env.js';function w(e,n,t){r.isServer||i(o=>{window.addEventListener(e,n,t),o(()=>window.removeEventListener(e,n,t))})}export{w as useWindowEvent};\n","import{computed as s,ref as E}from\"vue\";import{dom as p}from'../utils/dom.js';import{FocusableMode as d,isFocusableElement as C}from'../utils/focus-management.js';import{isMobile as T}from'../utils/platform.js';import{useDocumentEvent as i}from'./use-document-event.js';import{useWindowEvent as M}from'./use-window-event.js';function w(f,m,l=s(()=>!0)){function a(e,r){if(!l.value||e.defaultPrevented)return;let t=r(e);if(t===null||!t.getRootNode().contains(t))return;let c=function o(n){return typeof n==\"function\"?o(n()):Array.isArray(n)||n instanceof Set?n:[n]}(f);for(let o of c){if(o===null)continue;let n=o instanceof HTMLElement?o:p(o);if(n!=null&&n.contains(t)||e.composed&&e.composedPath().includes(n))return}return!C(t,d.Loose)&&t.tabIndex!==-1&&e.preventDefault(),m(e,t)}let u=E(null);i(\"pointerdown\",e=>{var r,t;l.value&&(u.value=((t=(r=e.composedPath)==null?void 0:r.call(e))==null?void 0:t[0])||e.target)},!0),i(\"mousedown\",e=>{var r,t;l.value&&(u.value=((t=(r=e.composedPath)==null?void 0:r.call(e))==null?void 0:t[0])||e.target)},!0),i(\"click\",e=>{T()||u.value&&(a(e,()=>u.value),u.value=null)},!0),i(\"touchend\",e=>a(e,()=>e.target instanceof HTMLElement?e.target:null),!0),M(\"blur\",e=>a(e,()=>window.document.activeElement instanceof HTMLIFrameElement?window.document.activeElement:null),!0)}export{w as useOutsideClick};\n","import{onMounted as i,ref as f,watchEffect as l}from\"vue\";import{dom as o}from'../utils/dom.js';function r(t,e){if(t)return t;let n=e!=null?e:\"button\";if(typeof n==\"string\"&&n.toLowerCase()===\"button\")return\"button\"}function s(t,e){let n=f(r(t.value.type,t.value.as));return i(()=>{n.value=r(t.value.type,t.value.as)}),l(()=>{var u;n.value||o(e)&&o(e)instanceof HTMLButtonElement&&!((u=o(e))!=null&&u.hasAttribute(\"type\"))&&(n.value=\"button\")}),n}export{s as useResolveButtonType};\n","import{ref as o}from\"vue\";function r(e){return[e.screenX,e.screenY]}function u(){let e=o([-1,-1]);return{wasMoved(n){let t=r(n);return e.value[0]===t[0]&&e.value[1]===t[1]?!1:(e.value=t,!0)},update(n){e.value=r(n)}}}export{u as useTrackedPointer};\n","import{watchEffect as p}from\"vue\";import{getOwnerDocument as u}from'../utils/owner.js';function i({container:e,accept:t,walk:d,enabled:o}){p(()=>{let r=e.value;if(!r||o!==void 0&&!o.value)return;let l=u(e);if(!l)return;let c=Object.assign(f=>t(f),{acceptNode:t}),n=l.createTreeWalker(r,NodeFilter.SHOW_ELEMENT,c,!1);for(;n.nextNode();)d(n.currentNode)})}export{i as useTreeWalker};\n","import{cloneVNode as O,Fragment as x,h as k}from\"vue\";import{match as w}from'./match.js';var N=(o=>(o[o.None=0]=\"None\",o[o.RenderStrategy=1]=\"RenderStrategy\",o[o.Static=2]=\"Static\",o))(N||{}),S=(e=>(e[e.Unmount=0]=\"Unmount\",e[e.Hidden=1]=\"Hidden\",e))(S||{});function A({visible:r=!0,features:t=0,ourProps:e,theirProps:o,...i}){var a;let n=j(o,e),l=Object.assign(i,{props:n});if(r||t&2&&n.static)return y(l);if(t&1){let d=(a=n.unmount)==null||a?0:1;return w(d,{[0](){return null},[1](){return y({...i,props:{...n,hidden:!0,style:{display:\"none\"}}})}})}return y(l)}function y({props:r,attrs:t,slots:e,slot:o,name:i}){var m,h;let{as:n,...l}=T(r,[\"unmount\",\"static\"]),a=(m=e.default)==null?void 0:m.call(e,o),d={};if(o){let u=!1,c=[];for(let[p,f]of Object.entries(o))typeof f==\"boolean\"&&(u=!0),f===!0&&c.push(p);u&&(d[\"data-headlessui-state\"]=c.join(\" \"))}if(n===\"template\"){if(a=b(a!=null?a:[]),Object.keys(l).length>0||Object.keys(t).length>0){let[u,...c]=a!=null?a:[];if(!v(u)||c.length>0)throw new Error(['Passing props on \"template\"!',\"\",`The current component <${i} /> is rendering a \"template\".`,\"However we need to passthrough the following props:\",Object.keys(l).concat(Object.keys(t)).map(s=>s.trim()).filter((s,g,R)=>R.indexOf(s)===g).sort((s,g)=>s.localeCompare(g)).map(s=>`  - ${s}`).join(`\n`),\"\",\"You can apply a few solutions:\",['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"template\".',\"Render a single element as the child so that we can forward the props onto that element.\"].map(s=>`  - ${s}`).join(`\n`)].join(`\n`));let p=j((h=u.props)!=null?h:{},l,d),f=O(u,p,!0);for(let s in p)s.startsWith(\"on\")&&(f.props||(f.props={}),f.props[s]=p[s]);return f}return Array.isArray(a)&&a.length===1?a[0]:a}return k(n,Object.assign({},l,d),{default:()=>a})}function b(r){return r.flatMap(t=>t.type===x?b(t.children):[t])}function j(...r){var o;if(r.length===0)return{};if(r.length===1)return r[0];let t={},e={};for(let i of r)for(let n in i)n.startsWith(\"on\")&&typeof i[n]==\"function\"?((o=e[n])!=null||(e[n]=[]),e[n].push(i[n])):t[n]=i[n];if(t.disabled||t[\"aria-disabled\"])return Object.assign(t,Object.fromEntries(Object.keys(e).map(i=>[i,void 0])));for(let i in e)Object.assign(t,{[i](n,...l){let a=e[i];for(let d of a){if(n instanceof Event&&n.defaultPrevented)return;d(n,...l)}}});return t}function E(r){let t=Object.assign({},r);for(let e in t)t[e]===void 0&&delete t[e];return t}function T(r,t=[]){let e=Object.assign({},r);for(let o of t)o in e&&delete e[o];return e}function v(r){return r==null?!1:typeof r.type==\"string\"||typeof r.type==\"object\"||typeof r.type==\"function\"}export{N as Features,S as RenderStrategy,E as compact,T as omit,A as render};\n","import{defineComponent as a}from\"vue\";import{render as p}from'../utils/render.js';var u=(e=>(e[e.None=1]=\"None\",e[e.Focusable=2]=\"Focusable\",e[e.Hidden=4]=\"Hidden\",e))(u||{});let f=a({name:\"Hidden\",props:{as:{type:[Object,String],default:\"div\"},features:{type:Number,default:1}},setup(t,{slots:n,attrs:i}){return()=>{var r;let{features:e,...d}=t,o={\"aria-hidden\":(e&2)===2?!0:(r=d[\"aria-hidden\"])!=null?r:void 0,hidden:(e&4)===4?!0:void 0,style:{position:\"fixed\",top:1,left:1,width:1,height:0,padding:0,margin:-1,overflow:\"hidden\",clip:\"rect(0, 0, 0, 0)\",whiteSpace:\"nowrap\",borderWidth:\"0\",...(e&4)===4&&(e&2)!==2&&{display:\"none\"}}};return p({ourProps:o,theirProps:d,slot:{},attrs:i,slots:n,name:\"Hidden\"})}}});export{u as Features,f as Hidden};\n","import{inject as p,provide as r}from\"vue\";let n=Symbol(\"Context\");var i=(e=>(e[e.Open=1]=\"Open\",e[e.Closed=2]=\"Closed\",e[e.Closing=4]=\"Closing\",e[e.Opening=8]=\"Opening\",e))(i||{});function s(){return l()!==null}function l(){return p(n,null)}function t(o){r(n,o)}export{i as State,s as hasOpenClosed,l as useOpenClosed,t as useOpenClosedProvider};\n","var o=(r=>(r.Space=\" \",r.Enter=\"Enter\",r.Escape=\"Escape\",r.Backspace=\"Backspace\",r.Delete=\"Delete\",r.ArrowLeft=\"ArrowLeft\",r.ArrowUp=\"ArrowUp\",r.ArrowRight=\"ArrowRight\",r.ArrowDown=\"ArrowDown\",r.Home=\"Home\",r.End=\"End\",r.PageUp=\"PageUp\",r.PageDown=\"PageDown\",r.Tab=\"Tab\",r))(o||{});export{o as Keys};\n","var g=(f=>(f[f.Left=0]=\"Left\",f[f.Right=2]=\"Right\",f))(g||{});export{g as MouseButton};\n","function t(n){function e(){document.readyState!==\"loading\"&&(n(),document.removeEventListener(\"DOMContentLoaded\",e))}typeof window!=\"undefined\"&&typeof document!=\"undefined\"&&(document.addEventListener(\"DOMContentLoaded\",e),e())}export{t as onDocumentReady};\n","import{onDocumentReady as d}from'./document-ready.js';let t=[];d(()=>{function e(n){n.target instanceof HTMLElement&&n.target!==document.body&&t[0]!==n.target&&(t.unshift(n.target),t=t.filter(r=>r!=null&&r.isConnected),t.splice(10))}window.addEventListener(\"click\",e,{capture:!0}),window.addEventListener(\"mousedown\",e,{capture:!0}),window.addEventListener(\"focus\",e,{capture:!0}),document.body.addEventListener(\"click\",e,{capture:!0}),document.body.addEventListener(\"mousedown\",e,{capture:!0}),document.body.addEventListener(\"focus\",e,{capture:!0})});export{t as history};\n","function u(l){throw new Error(\"Unexpected object: \"+l)}var c=(i=>(i[i.First=0]=\"First\",i[i.Previous=1]=\"Previous\",i[i.Next=2]=\"Next\",i[i.Last=3]=\"Last\",i[i.Specific=4]=\"Specific\",i[i.Nothing=5]=\"Nothing\",i))(c||{});function f(l,n){let t=n.resolveItems();if(t.length<=0)return null;let r=n.resolveActiveIndex(),s=r!=null?r:-1;switch(l.focus){case 0:{for(let e=0;e<t.length;++e)if(!n.resolveDisabled(t[e],e,t))return e;return r}case 1:{s===-1&&(s=t.length);for(let e=s-1;e>=0;--e)if(!n.resolveDisabled(t[e],e,t))return e;return r}case 2:{for(let e=s+1;e<t.length;++e)if(!n.resolveDisabled(t[e],e,t))return e;return r}case 3:{for(let e=t.length-1;e>=0;--e)if(!n.resolveDisabled(t[e],e,t))return e;return r}case 4:{for(let e=0;e<t.length;++e)if(n.resolveId(t[e],e,t)===l.id)return e;return r}case 5:return null;default:u(l)}}export{c as Focus,f as calculateActiveIndex};\n","function e(i={},s=null,t=[]){for(let[r,n]of Object.entries(i))o(t,f(s,r),n);return t}function f(i,s){return i?i+\"[\"+s+\"]\":s}function o(i,s,t){if(Array.isArray(t))for(let[r,n]of t.entries())o(i,f(s,r.toString()),n);else t instanceof Date?i.push([s,t.toISOString()]):typeof t==\"boolean\"?i.push([s,t?\"1\":\"0\"]):typeof t==\"string\"?i.push([s,t]):typeof t==\"number\"?i.push([s,`${t}`]):t==null?i.push([s,\"\"]):e(t,s,i)}function p(i){var t,r;let s=(t=i==null?void 0:i.form)!=null?t:i.closest(\"form\");if(s){for(let n of s.elements)if(n!==i&&(n.tagName===\"INPUT\"&&n.type===\"submit\"||n.tagName===\"BUTTON\"&&n.type===\"submit\"||n.nodeName===\"INPUT\"&&n.type===\"image\")){n.click();return}(r=s.requestSubmit)==null||r.call(s)}}export{p as attemptSubmit,e as objectToFormEntries};\n","import{useVirtualizer as re}from\"@tanstack/vue-virtual\";import{cloneVNode as de,computed as m,defineComponent as H,Fragment as se,h as z,inject as ee,nextTick as N,onMounted as X,onUnmounted as fe,provide as te,reactive as ve,ref as k,toRaw as L,watch as J,watchEffect as Y}from\"vue\";import{useControllable as pe}from'../../hooks/use-controllable.js';import{useFrameDebounce as be}from'../../hooks/use-frame-debounce.js';import{useId as W}from'../../hooks/use-id.js';import{useOutsideClick as ce}from'../../hooks/use-outside-click.js';import{useResolveButtonType as me}from'../../hooks/use-resolve-button-type.js';import{useTrackedPointer as xe}from'../../hooks/use-tracked-pointer.js';import{useTreeWalker as ge}from'../../hooks/use-tree-walker.js';import{Features as Se,Hidden as Oe}from'../../internal/hidden.js';import{State as G,useOpenClosed as Ce,useOpenClosedProvider as Re}from'../../internal/open-closed.js';import{Keys as F}from'../../keyboard.js';import{MouseButton as ye}from'../../mouse.js';import{history as oe}from'../../utils/active-element-history.js';import{calculateActiveIndex as le,Focus as P}from'../../utils/calculate-active-index.js';import{disposables as ae}from'../../utils/disposables.js';import{dom as x}from'../../utils/dom.js';import{sortByDomNode as Te}from'../../utils/focus-management.js';import{objectToFormEntries as Ie}from'../../utils/form.js';import{match as _}from'../../utils/match.js';import{getOwnerDocument as he}from'../../utils/owner.js';import{isMobile as we}from'../../utils/platform.js';import{compact as Pe,Features as Q,omit as Z,render as U}from'../../utils/render.js';function De(a,h){return a===h}var Ee=(r=>(r[r.Open=0]=\"Open\",r[r.Closed=1]=\"Closed\",r))(Ee||{}),Ve=(r=>(r[r.Single=0]=\"Single\",r[r.Multi=1]=\"Multi\",r))(Ve||{}),ke=(y=>(y[y.Pointer=0]=\"Pointer\",y[y.Focus=1]=\"Focus\",y[y.Other=2]=\"Other\",y))(ke||{});let ne=Symbol(\"ComboboxContext\");function K(a){let h=ee(ne,null);if(h===null){let r=new Error(`<${a} /> is missing a parent <Combobox /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(r,K),r}return h}let ie=Symbol(\"VirtualContext\"),Ae=H({name:\"VirtualProvider\",setup(a,{slots:h}){let r=K(\"VirtualProvider\"),y=m(()=>{let c=x(r.optionsRef);if(!c)return{start:0,end:0};let f=window.getComputedStyle(c);return{start:parseFloat(f.paddingBlockStart||f.paddingTop),end:parseFloat(f.paddingBlockEnd||f.paddingBottom)}}),o=re(m(()=>({scrollPaddingStart:y.value.start,scrollPaddingEnd:y.value.end,count:r.virtual.value.options.length,estimateSize(){return 40},getScrollElement(){return x(r.optionsRef)},overscan:12}))),u=m(()=>{var c;return(c=r.virtual.value)==null?void 0:c.options}),e=k(0);return J([u],()=>{e.value+=1}),te(ie,r.virtual.value?o:null),()=>[z(\"div\",{style:{position:\"relative\",width:\"100%\",height:`${o.value.getTotalSize()}px`},ref:c=>{if(c){if(typeof process!=\"undefined\"&&process.env.JEST_WORKER_ID!==void 0||r.activationTrigger.value===0)return;r.activeOptionIndex.value!==null&&r.virtual.value.options.length>r.activeOptionIndex.value&&o.value.scrollToIndex(r.activeOptionIndex.value)}}},o.value.getVirtualItems().map(c=>de(h.default({option:r.virtual.value.options[c.index],open:r.comboboxState.value===0})[0],{key:`${e.value}-${c.index}`,\"data-index\":c.index,\"aria-setsize\":r.virtual.value.options.length,\"aria-posinset\":c.index+1,style:{position:\"absolute\",top:0,left:0,transform:`translateY(${c.start}px)`,overflowAnchor:\"none\"}})))]}}),lt=H({name:\"Combobox\",emits:{\"update:modelValue\":a=>!0},props:{as:{type:[Object,String],default:\"template\"},disabled:{type:[Boolean],default:!1},by:{type:[String,Function],nullable:!0,default:null},modelValue:{type:[Object,String,Number,Boolean],default:void 0},defaultValue:{type:[Object,String,Number,Boolean],default:void 0},form:{type:String,optional:!0},name:{type:String,optional:!0},nullable:{type:Boolean,default:!1},multiple:{type:[Boolean],default:!1},immediate:{type:[Boolean],default:!1},virtual:{type:Object,default:null}},inheritAttrs:!1,setup(a,{slots:h,attrs:r,emit:y}){let o=k(1),u=k(null),e=k(null),c=k(null),f=k(null),S=k({static:!1,hold:!1}),v=k([]),d=k(null),D=k(2),E=k(!1);function w(t=n=>n){let n=d.value!==null?v.value[d.value]:null,s=t(v.value.slice()),b=s.length>0&&s[0].dataRef.order.value!==null?s.sort((C,A)=>C.dataRef.order.value-A.dataRef.order.value):Te(s,C=>x(C.dataRef.domRef)),O=n?b.indexOf(n):null;return O===-1&&(O=null),{options:b,activeOptionIndex:O}}let M=m(()=>a.multiple?1:0),$=m(()=>a.nullable),[B,p]=pe(m(()=>a.modelValue),t=>y(\"update:modelValue\",t),m(()=>a.defaultValue)),R=m(()=>B.value===void 0?_(M.value,{[1]:[],[0]:void 0}):B.value),V=null,i=null;function I(t){return _(M.value,{[0](){return p==null?void 0:p(t)},[1]:()=>{let n=L(l.value.value).slice(),s=L(t),b=n.findIndex(O=>l.compare(s,L(O)));return b===-1?n.push(s):n.splice(b,1),p==null?void 0:p(n)}})}let T=m(()=>{});J([T],([t],[n])=>{if(l.virtual.value&&t&&n&&d.value!==null){let s=t.indexOf(n[d.value]);s!==-1?d.value=s:d.value=null}});let l={comboboxState:o,value:R,mode:M,compare(t,n){if(typeof a.by==\"string\"){let s=a.by;return(t==null?void 0:t[s])===(n==null?void 0:n[s])}return a.by===null?De(t,n):a.by(t,n)},calculateIndex(t){return l.virtual.value?a.by===null?l.virtual.value.options.indexOf(t):l.virtual.value.options.findIndex(n=>l.compare(n,t)):v.value.findIndex(n=>l.compare(n.dataRef.value,t))},defaultValue:m(()=>a.defaultValue),nullable:$,immediate:m(()=>!1),virtual:m(()=>null),inputRef:e,labelRef:u,buttonRef:c,optionsRef:f,disabled:m(()=>a.disabled),options:v,change(t){p(t)},activeOptionIndex:m(()=>{if(E.value&&d.value===null&&(l.virtual.value?l.virtual.value.options.length>0:v.value.length>0)){if(l.virtual.value){let n=l.virtual.value.options.findIndex(s=>{var b;return!((b=l.virtual.value)!=null&&b.disabled(s))});if(n!==-1)return n}let t=v.value.findIndex(n=>!n.dataRef.disabled);if(t!==-1)return t}return d.value}),activationTrigger:D,optionsPropsRef:S,closeCombobox(){E.value=!1,!a.disabled&&o.value!==1&&(o.value=1,d.value=null)},openCombobox(){if(E.value=!0,!a.disabled&&o.value!==0){if(l.value.value){let t=l.calculateIndex(l.value.value);t!==-1&&(d.value=t)}o.value=0}},setActivationTrigger(t){D.value=t},goToOption(t,n,s){E.value=!1,V!==null&&cancelAnimationFrame(V),V=requestAnimationFrame(()=>{if(a.disabled||f.value&&!S.value.static&&o.value===1)return;if(l.virtual.value){d.value=t===P.Specific?n:le({focus:t},{resolveItems:()=>l.virtual.value.options,resolveActiveIndex:()=>{var C,A;return(A=(C=l.activeOptionIndex.value)!=null?C:l.virtual.value.options.findIndex(j=>{var q;return!((q=l.virtual.value)!=null&&q.disabled(j))}))!=null?A:null},resolveDisabled:C=>l.virtual.value.disabled(C),resolveId(){throw new Error(\"Function not implemented.\")}}),D.value=s!=null?s:2;return}let b=w();if(b.activeOptionIndex===null){let C=b.options.findIndex(A=>!A.dataRef.disabled);C!==-1&&(b.activeOptionIndex=C)}let O=t===P.Specific?n:le({focus:t},{resolveItems:()=>b.options,resolveActiveIndex:()=>b.activeOptionIndex,resolveId:C=>C.id,resolveDisabled:C=>C.dataRef.disabled});d.value=O,D.value=s!=null?s:2,v.value=b.options})},selectOption(t){let n=v.value.find(b=>b.id===t);if(!n)return;let{dataRef:s}=n;I(s.value)},selectActiveOption(){if(l.activeOptionIndex.value!==null){if(l.virtual.value)I(l.virtual.value.options[l.activeOptionIndex.value]);else{let{dataRef:t}=v.value[l.activeOptionIndex.value];I(t.value)}l.goToOption(P.Specific,l.activeOptionIndex.value)}},registerOption(t,n){let s=ve({id:t,dataRef:n});if(l.virtual.value){v.value.push(s);return}i&&cancelAnimationFrame(i);let b=w(O=>(O.push(s),O));d.value===null&&l.isSelected(n.value.value)&&(b.activeOptionIndex=b.options.indexOf(s)),v.value=b.options,d.value=b.activeOptionIndex,D.value=2,b.options.some(O=>!x(O.dataRef.domRef))&&(i=requestAnimationFrame(()=>{let O=w();v.value=O.options,d.value=O.activeOptionIndex}))},unregisterOption(t,n){if(V!==null&&cancelAnimationFrame(V),n&&(E.value=!0),l.virtual.value){v.value=v.value.filter(b=>b.id!==t);return}let s=w(b=>{let O=b.findIndex(C=>C.id===t);return O!==-1&&b.splice(O,1),b});v.value=s.options,d.value=s.activeOptionIndex,D.value=2},isSelected(t){return _(M.value,{[0]:()=>l.compare(L(l.value.value),L(t)),[1]:()=>L(l.value.value).some(n=>l.compare(L(n),L(t)))})},isActive(t){return d.value===l.calculateIndex(t)}};ce([e,c,f],()=>l.closeCombobox(),m(()=>o.value===0)),te(ne,l),Re(m(()=>_(o.value,{[0]:G.Open,[1]:G.Closed})));let g=m(()=>{var t;return(t=x(e))==null?void 0:t.closest(\"form\")});return X(()=>{J([g],()=>{if(!g.value||a.defaultValue===void 0)return;function t(){l.change(a.defaultValue)}return g.value.addEventListener(\"reset\",t),()=>{var n;(n=g.value)==null||n.removeEventListener(\"reset\",t)}},{immediate:!0})}),()=>{var C,A,j;let{name:t,disabled:n,form:s,...b}=a,O={open:o.value===0,disabled:n,activeIndex:l.activeOptionIndex.value,activeOption:l.activeOptionIndex.value===null?null:l.virtual.value?l.virtual.value.options[(C=l.activeOptionIndex.value)!=null?C:0]:(j=(A=l.options.value[l.activeOptionIndex.value])==null?void 0:A.dataRef.value)!=null?j:null,value:R.value};return z(se,[...t!=null&&R.value!=null?Ie({[t]:R.value}).map(([q,ue])=>z(Oe,Pe({features:Se.Hidden,key:q,as:\"input\",type:\"hidden\",hidden:!0,readOnly:!0,form:s,disabled:n,name:q,value:ue}))):[],U({theirProps:{...r,...Z(b,[\"by\",\"defaultValue\",\"immediate\",\"modelValue\",\"multiple\",\"nullable\",\"onUpdate:modelValue\",\"virtual\"])},ourProps:{},slot:O,slots:h,attrs:r,name:\"Combobox\"})])}}}),at=H({name:\"ComboboxLabel\",props:{as:{type:[Object,String],default:\"label\"},id:{type:String,default:null}},setup(a,{attrs:h,slots:r}){var e;let y=(e=a.id)!=null?e:`headlessui-combobox-label-${W()}`,o=K(\"ComboboxLabel\");function u(){var c;(c=x(o.inputRef))==null||c.focus({preventScroll:!0})}return()=>{let c={open:o.comboboxState.value===0,disabled:o.disabled.value},{...f}=a,S={id:y,ref:o.labelRef,onClick:u};return U({ourProps:S,theirProps:f,slot:c,attrs:h,slots:r,name:\"ComboboxLabel\"})}}}),nt=H({name:\"ComboboxButton\",props:{as:{type:[Object,String],default:\"button\"},id:{type:String,default:null}},setup(a,{attrs:h,slots:r,expose:y}){var S;let o=(S=a.id)!=null?S:`headlessui-combobox-button-${W()}`,u=K(\"ComboboxButton\");y({el:u.buttonRef,$el:u.buttonRef});function e(v){u.disabled.value||(u.comboboxState.value===0?u.closeCombobox():(v.preventDefault(),u.openCombobox()),N(()=>{var d;return(d=x(u.inputRef))==null?void 0:d.focus({preventScroll:!0})}))}function c(v){switch(v.key){case F.ArrowDown:v.preventDefault(),v.stopPropagation(),u.comboboxState.value===1&&u.openCombobox(),N(()=>{var d;return(d=u.inputRef.value)==null?void 0:d.focus({preventScroll:!0})});return;case F.ArrowUp:v.preventDefault(),v.stopPropagation(),u.comboboxState.value===1&&(u.openCombobox(),N(()=>{u.value.value||u.goToOption(P.Last)})),N(()=>{var d;return(d=u.inputRef.value)==null?void 0:d.focus({preventScroll:!0})});return;case F.Escape:if(u.comboboxState.value!==0)return;v.preventDefault(),u.optionsRef.value&&!u.optionsPropsRef.value.static&&v.stopPropagation(),u.closeCombobox(),N(()=>{var d;return(d=u.inputRef.value)==null?void 0:d.focus({preventScroll:!0})});return}}let f=me(m(()=>({as:a.as,type:h.type})),u.buttonRef);return()=>{var E,w;let v={open:u.comboboxState.value===0,disabled:u.disabled.value,value:u.value.value},{...d}=a,D={ref:u.buttonRef,id:o,type:f.value,tabindex:\"-1\",\"aria-haspopup\":\"listbox\",\"aria-controls\":(E=x(u.optionsRef))==null?void 0:E.id,\"aria-expanded\":u.comboboxState.value===0,\"aria-labelledby\":u.labelRef.value?[(w=x(u.labelRef))==null?void 0:w.id,o].join(\" \"):void 0,disabled:u.disabled.value===!0?!0:void 0,onKeydown:c,onClick:e};return U({ourProps:D,theirProps:d,slot:v,attrs:h,slots:r,name:\"ComboboxButton\"})}}}),it=H({name:\"ComboboxInput\",props:{as:{type:[Object,String],default:\"input\"},static:{type:Boolean,default:!1},unmount:{type:Boolean,default:!0},displayValue:{type:Function},defaultValue:{type:String,default:void 0},id:{type:String,default:null}},emits:{change:a=>!0},setup(a,{emit:h,attrs:r,slots:y,expose:o}){var V;let u=(V=a.id)!=null?V:`headlessui-combobox-input-${W()}`,e=K(\"ComboboxInput\"),c=m(()=>he(x(e.inputRef))),f={value:!1};o({el:e.inputRef,$el:e.inputRef});function S(){e.change(null);let i=x(e.optionsRef);i&&(i.scrollTop=0),e.goToOption(P.Nothing)}let v=m(()=>{var I;let i=e.value.value;return x(e.inputRef)?typeof a.displayValue!=\"undefined\"&&i!==void 0?(I=a.displayValue(i))!=null?I:\"\":typeof i==\"string\"?i:\"\":\"\"});X(()=>{J([v,e.comboboxState,c],([i,I],[T,l])=>{if(f.value)return;let g=x(e.inputRef);g&&((l===0&&I===1||i!==T)&&(g.value=i),requestAnimationFrame(()=>{var s;if(f.value||!g||((s=c.value)==null?void 0:s.activeElement)!==g)return;let{selectionStart:t,selectionEnd:n}=g;Math.abs((n!=null?n:0)-(t!=null?t:0))===0&&t===0&&g.setSelectionRange(g.value.length,g.value.length)}))},{immediate:!0}),J([e.comboboxState],([i],[I])=>{if(i===0&&I===1){if(f.value)return;let T=x(e.inputRef);if(!T)return;let l=T.value,{selectionStart:g,selectionEnd:t,selectionDirection:n}=T;T.value=\"\",T.value=l,n!==null?T.setSelectionRange(g,t,n):T.setSelectionRange(g,t)}})});let d=k(!1);function D(){d.value=!0}function E(){ae().nextFrame(()=>{d.value=!1})}let w=be();function M(i){switch(f.value=!0,w(()=>{f.value=!1}),i.key){case F.Enter:if(f.value=!1,e.comboboxState.value!==0||d.value)return;if(i.preventDefault(),i.stopPropagation(),e.activeOptionIndex.value===null){e.closeCombobox();return}e.selectActiveOption(),e.mode.value===0&&e.closeCombobox();break;case F.ArrowDown:return f.value=!1,i.preventDefault(),i.stopPropagation(),_(e.comboboxState.value,{[0]:()=>e.goToOption(P.Next),[1]:()=>e.openCombobox()});case F.ArrowUp:return f.value=!1,i.preventDefault(),i.stopPropagation(),_(e.comboboxState.value,{[0]:()=>e.goToOption(P.Previous),[1]:()=>{e.openCombobox(),N(()=>{e.value.value||e.goToOption(P.Last)})}});case F.Home:if(i.shiftKey)break;return f.value=!1,i.preventDefault(),i.stopPropagation(),e.goToOption(P.First);case F.PageUp:return f.value=!1,i.preventDefault(),i.stopPropagation(),e.goToOption(P.First);case F.End:if(i.shiftKey)break;return f.value=!1,i.preventDefault(),i.stopPropagation(),e.goToOption(P.Last);case F.PageDown:return f.value=!1,i.preventDefault(),i.stopPropagation(),e.goToOption(P.Last);case F.Escape:if(f.value=!1,e.comboboxState.value!==0)return;i.preventDefault(),e.optionsRef.value&&!e.optionsPropsRef.value.static&&i.stopPropagation(),e.nullable.value&&e.mode.value===0&&e.value.value===null&&S(),e.closeCombobox();break;case F.Tab:if(f.value=!1,e.comboboxState.value!==0)return;e.mode.value===0&&e.activationTrigger.value!==1&&e.selectActiveOption(),e.closeCombobox();break}}function $(i){h(\"change\",i),e.nullable.value&&e.mode.value===0&&i.target.value===\"\"&&S(),e.openCombobox()}function B(i){var T,l,g;let I=(T=i.relatedTarget)!=null?T:oe.find(t=>t!==i.currentTarget);if(f.value=!1,!((l=x(e.optionsRef))!=null&&l.contains(I))&&!((g=x(e.buttonRef))!=null&&g.contains(I))&&e.comboboxState.value===0)return i.preventDefault(),e.mode.value===0&&(e.nullable.value&&e.value.value===null?S():e.activationTrigger.value!==1&&e.selectActiveOption()),e.closeCombobox()}function p(i){var T,l,g;let I=(T=i.relatedTarget)!=null?T:oe.find(t=>t!==i.currentTarget);(l=x(e.buttonRef))!=null&&l.contains(I)||(g=x(e.optionsRef))!=null&&g.contains(I)||e.disabled.value||e.immediate.value&&e.comboboxState.value!==0&&(e.openCombobox(),ae().nextFrame(()=>{e.setActivationTrigger(1)}))}let R=m(()=>{var i,I,T,l;return(l=(T=(I=a.defaultValue)!=null?I:e.defaultValue.value!==void 0?(i=a.displayValue)==null?void 0:i.call(a,e.defaultValue.value):null)!=null?T:e.defaultValue.value)!=null?l:\"\"});return()=>{var t,n,s,b,O,C,A;let i={open:e.comboboxState.value===0},{displayValue:I,onChange:T,...l}=a,g={\"aria-controls\":(t=e.optionsRef.value)==null?void 0:t.id,\"aria-expanded\":e.comboboxState.value===0,\"aria-activedescendant\":e.activeOptionIndex.value===null?void 0:e.virtual.value?(n=e.options.value.find(j=>!e.virtual.value.disabled(j.dataRef.value)&&e.compare(j.dataRef.value,e.virtual.value.options[e.activeOptionIndex.value])))==null?void 0:n.id:(s=e.options.value[e.activeOptionIndex.value])==null?void 0:s.id,\"aria-labelledby\":(C=(b=x(e.labelRef))==null?void 0:b.id)!=null?C:(O=x(e.buttonRef))==null?void 0:O.id,\"aria-autocomplete\":\"list\",id:u,onCompositionstart:D,onCompositionend:E,onKeydown:M,onInput:$,onFocus:p,onBlur:B,role:\"combobox\",type:(A=r.type)!=null?A:\"text\",tabIndex:0,ref:e.inputRef,defaultValue:R.value,disabled:e.disabled.value===!0?!0:void 0};return U({ourProps:g,theirProps:l,slot:i,attrs:r,slots:y,features:Q.RenderStrategy|Q.Static,name:\"ComboboxInput\"})}}}),ut=H({name:\"ComboboxOptions\",props:{as:{type:[Object,String],default:\"ul\"},static:{type:Boolean,default:!1},unmount:{type:Boolean,default:!0},hold:{type:[Boolean],default:!1}},setup(a,{attrs:h,slots:r,expose:y}){let o=K(\"ComboboxOptions\"),u=`headlessui-combobox-options-${W()}`;y({el:o.optionsRef,$el:o.optionsRef}),Y(()=>{o.optionsPropsRef.value.static=a.static}),Y(()=>{o.optionsPropsRef.value.hold=a.hold});let e=Ce(),c=m(()=>e!==null?(e.value&G.Open)===G.Open:o.comboboxState.value===0);ge({container:m(()=>x(o.optionsRef)),enabled:m(()=>o.comboboxState.value===0),accept(S){return S.getAttribute(\"role\")===\"option\"?NodeFilter.FILTER_REJECT:S.hasAttribute(\"role\")?NodeFilter.FILTER_SKIP:NodeFilter.FILTER_ACCEPT},walk(S){S.setAttribute(\"role\",\"none\")}});function f(S){S.preventDefault()}return()=>{var D,E,w;let S={open:o.comboboxState.value===0},v={\"aria-labelledby\":(w=(D=x(o.labelRef))==null?void 0:D.id)!=null?w:(E=x(o.buttonRef))==null?void 0:E.id,id:u,ref:o.optionsRef,role:\"listbox\",\"aria-multiselectable\":o.mode.value===1?!0:void 0,onMousedown:f},d=Z(a,[\"hold\"]);return U({ourProps:v,theirProps:d,slot:S,attrs:h,slots:o.virtual.value&&o.comboboxState.value===0?{...r,default:()=>[z(Ae,{},r.default)]}:r,features:Q.RenderStrategy|Q.Static,visible:c.value,name:\"ComboboxOptions\"})}}}),rt=H({name:\"ComboboxOption\",props:{as:{type:[Object,String],default:\"li\"},value:{type:[Object,String,Number,Boolean]},disabled:{type:Boolean,default:!1},order:{type:[Number],default:null}},setup(a,{slots:h,attrs:r,expose:y}){let o=K(\"ComboboxOption\"),u=`headlessui-combobox-option-${W()}`,e=k(null),c=m(()=>a.disabled);y({el:e,$el:e});let f=m(()=>{var p;return o.virtual.value?o.activeOptionIndex.value===o.calculateIndex(a.value):o.activeOptionIndex.value===null?!1:((p=o.options.value[o.activeOptionIndex.value])==null?void 0:p.id)===u}),S=m(()=>o.isSelected(a.value)),v=ee(ie,null),d=m(()=>({disabled:a.disabled,value:a.value,domRef:e,order:m(()=>a.order)}));X(()=>o.registerOption(u,d)),fe(()=>o.unregisterOption(u,f.value)),Y(()=>{let p=x(e);p&&(v==null||v.value.measureElement(p))}),Y(()=>{o.comboboxState.value===0&&f.value&&(o.virtual.value||o.activationTrigger.value!==0&&N(()=>{var p,R;return(R=(p=x(e))==null?void 0:p.scrollIntoView)==null?void 0:R.call(p,{block:\"nearest\"})}))});function D(p){p.preventDefault(),p.button===ye.Left&&(c.value||(o.selectOption(u),we()||requestAnimationFrame(()=>{var R;return(R=x(o.inputRef))==null?void 0:R.focus({preventScroll:!0})}),o.mode.value===0&&o.closeCombobox()))}function E(){var R;if(a.disabled||(R=o.virtual.value)!=null&&R.disabled(a.value))return o.goToOption(P.Nothing);let p=o.calculateIndex(a.value);o.goToOption(P.Specific,p)}let w=xe();function M(p){w.update(p)}function $(p){var V;if(!w.wasMoved(p)||a.disabled||(V=o.virtual.value)!=null&&V.disabled(a.value)||f.value)return;let R=o.calculateIndex(a.value);o.goToOption(P.Specific,R,0)}function B(p){var R;w.wasMoved(p)&&(a.disabled||(R=o.virtual.value)!=null&&R.disabled(a.value)||f.value&&(o.optionsPropsRef.value.hold||o.goToOption(P.Nothing)))}return()=>{let{disabled:p}=a,R={active:f.value,selected:S.value,disabled:p},V={id:u,ref:e,role:\"option\",tabIndex:p===!0?void 0:-1,\"aria-disabled\":p===!0?!0:void 0,\"aria-selected\":S.value,disabled:void 0,onMousedown:D,onFocus:E,onPointerenter:M,onMouseenter:M,onPointermove:$,onMousemove:$,onPointerleave:B,onMouseleave:B},i=Z(a,[\"order\",\"value\"]);return U({ourProps:V,theirProps:i,slot:R,attrs:r,slots:h,name:\"ComboboxOption\"})}}});export{lt as Combobox,nt as ComboboxButton,it as ComboboxInput,at as ComboboxLabel,rt as ComboboxOption,ut as ComboboxOptions};\n","import type { Plugin } from 'vue'\nimport {\n  Combobox,\n  ComboboxButton,\n  ComboboxInput,\n  ComboboxOption,\n  ComboboxOptions,\n} from '@headlessui/vue'\n\nconst plugin: Plugin = {\n  install(app) {\n    Object.entries({ Combobox, ComboboxInput, ComboboxButton, ComboboxOptions, ComboboxOption }).forEach(([name, component]) => {\n      app.component(name, component)\n    })\n  },\n}\n\nexport { Combobox, ComboboxButton, ComboboxInput, ComboboxOption, ComboboxOptions }\nexport default plugin\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],"mappings":""}