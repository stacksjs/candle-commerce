import { createHooks } from "./dist-DKfj0q3M.js";
import { createApp, createSSRApp, defineComponent, isRef, onMounted, ref, toValue } from "./vue.runtime.esm-bundler-DZNPpFiL.js";
import { createMemoryHistory, createRouter, createWebHistory } from "./vue-router-GmlYkBpz.js";

//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/shared/unhead.yem5I2v_.mjs
const DupeableTags = /* @__PURE__ */ new Set([
	"link",
	"style",
	"script",
	"noscript"
]);
const TagsWithInnerContent = /* @__PURE__ */ new Set([
	"title",
	"titleTemplate",
	"script",
	"style",
	"noscript"
]);
const HasElementTags = /* @__PURE__ */ new Set([
	"base",
	"meta",
	"link",
	"style",
	"script",
	"noscript"
]);
const ValidHeadTags = /* @__PURE__ */ new Set([
	"title",
	"base",
	"htmlAttrs",
	"bodyAttrs",
	"meta",
	"link",
	"style",
	"script",
	"noscript"
]);
const UniqueTags = /* @__PURE__ */ new Set([
	"base",
	"title",
	"titleTemplate",
	"bodyAttrs",
	"htmlAttrs",
	"templateParams"
]);
const TagConfigKeys = /* @__PURE__ */ new Set([
	"key",
	"tagPosition",
	"tagPriority",
	"tagDuplicateStrategy",
	"innerHTML",
	"textContent",
	"processTemplateParams"
]);
const UsesMergeStrategy = /* @__PURE__ */ new Set([
	"templateParams",
	"htmlAttrs",
	"bodyAttrs"
]);
const MetaTagsArrayable = /* @__PURE__ */ new Set([
	"theme-color",
	"google-site-verification",
	"og",
	"article",
	"book",
	"profile",
	"twitter",
	"author"
]);

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/shared/unhead.Di5OD67x.mjs
const allowedMetaProperties = [
	"name",
	"property",
	"http-equiv"
];
const StandardSingleMetaTags = /* @__PURE__ */ new Set([
	"viewport",
	"description",
	"keywords",
	"robots"
]);
function isMetaArrayDupeKey(v) {
	const parts = v.split(":");
	if (!parts.length) return false;
	return MetaTagsArrayable.has(parts[1]);
}
function dedupeKey(tag) {
	const { props, tag: name } = tag;
	if (UniqueTags.has(name)) return name;
	if (name === "link" && props.rel === "canonical") return "canonical";
	if (props.charset) return "charset";
	if (tag.tag === "meta") {
		for (const n of allowedMetaProperties) if (props[n] !== void 0) {
			const propValue = props[n];
			const isStructured = propValue.includes(":");
			const isStandardSingle = StandardSingleMetaTags.has(propValue);
			const shouldAlwaysDedupe = isStructured || isStandardSingle;
			const keyPart = !shouldAlwaysDedupe && tag.key ? `:key:${tag.key}` : "";
			return `${name}:${propValue}${keyPart}`;
		}
	}
	if (tag.key) return `${name}:key:${tag.key}`;
	if (props.id) return `${name}:id:${props.id}`;
	if (TagsWithInnerContent.has(name)) {
		const v = tag.textContent || tag.innerHTML;
		if (v) return `${name}:content:${v}`;
	}
}
function hashTag(tag) {
	const dedupe = tag._h || tag._d;
	if (dedupe) return dedupe;
	const inner = tag.textContent || tag.innerHTML;
	if (inner) return inner;
	return `${tag.tag}:${Object.entries(tag.props).map(([k, v]) => `${k}:${String(v)}`).join(",")}`;
}
function walkResolver(val, resolve, key) {
	const type = typeof val;
	if (type === "function") {
		if (!key || key !== "titleTemplate" && !(key[0] === "o" && key[1] === "n")) val = val();
	}
	let v;
	if (resolve) v = resolve(key, val);
	if (Array.isArray(v)) return v.map((r) => walkResolver(r, resolve));
	if (v?.constructor === Object) {
		const next = {};
		for (const key2 of Object.keys(v)) next[key2] = walkResolver(v[key2], resolve, key2);
		return next;
	}
	return v;
}
function normalizeStyleClassProps(key, value) {
	const store = key === "style" ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();
	function processValue(rawValue) {
		const value2 = rawValue.trim();
		if (!value2) return;
		if (key === "style") {
			const [k, ...v] = value2.split(":").map((s) => s.trim());
			if (k && v.length) store.set(k, v.join(":"));
		} else value2.split(" ").filter(Boolean).forEach((c) => store.add(c));
	}
	if (typeof value === "string") key === "style" ? value.split(";").forEach(processValue) : processValue(value);
	else if (Array.isArray(value)) value.forEach((item) => processValue(item));
	else if (value && typeof value === "object") Object.entries(value).forEach(([k, v]) => {
		if (v && v !== "false") key === "style" ? store.set(k.trim(), v) : processValue(k);
	});
	return store;
}
function normalizeProps(tag, input) {
	tag.props = tag.props || {};
	if (!input) return tag;
	Object.entries(input).forEach(([key, value]) => {
		if (value === null) {
			tag.props[key] = null;
			return;
		}
		if (key === "class" || key === "style") {
			tag.props[key] = normalizeStyleClassProps(key, value);
			return;
		}
		if (TagConfigKeys.has(key)) {
			if (["textContent", "innerHTML"].includes(key) && typeof value === "object") {
				let type = input.type;
				if (!input.type) type = "application/json";
				if (!type?.endsWith("json") && type !== "speculationrules") return;
				input.type = type;
				tag.props.type = type;
				tag[key] = JSON.stringify(value);
			} else tag[key] = value;
			return;
		}
		const strValue = String(value);
		const isDataKey = key.startsWith("data-");
		if (strValue === "true" || strValue === "") tag.props[key] = isDataKey ? strValue : true;
		else if (!value && isDataKey && strValue === "false") tag.props[key] = "false";
		else if (value !== void 0) tag.props[key] = value;
	});
	return tag;
}
function normalizeTag(tagName, _input) {
	const input = typeof _input === "object" && typeof _input !== "function" ? _input : { [tagName === "script" || tagName === "noscript" || tagName === "style" ? "innerHTML" : "textContent"]: _input };
	const tag = normalizeProps({
		tag: tagName,
		props: {}
	}, input);
	if (tag.key && DupeableTags.has(tag.tag)) tag.props["data-hid"] = tag._h = tag.key;
	if (tag.tag === "script" && typeof tag.innerHTML === "object") {
		tag.innerHTML = JSON.stringify(tag.innerHTML);
		tag.props.type = tag.props.type || "application/json";
	}
	return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({
		...tag,
		props: {
			...tag.props,
			content: v
		}
	})) : tag;
}
function normalizeEntryToTags(input, propResolvers) {
	if (!input) return [];
	if (typeof input === "function") input = input();
	const resolvers = (key, val) => {
		for (let i = 0; i < propResolvers.length; i++) val = propResolvers[i](key, val);
		return val;
	};
	input = resolvers(void 0, input);
	const tags = [];
	input = walkResolver(input, resolvers);
	Object.entries(input || {}).forEach(([key, value]) => {
		if (value === void 0) return;
		for (const v of Array.isArray(value) ? value : [value]) tags.push(normalizeTag(key, v));
	});
	return tags.flat();
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/shared/unhead.DZbvapt-.mjs
const sortTags = (a, b) => a._w === b._w ? a._p - b._p : a._w - b._w;
const TAG_WEIGHTS = {
	base: -10,
	title: 10
};
const TAG_ALIASES = {
	critical: -8,
	high: -1,
	low: 2
};
const WEIGHT_MAP = {
	meta: {
		"content-security-policy": -30,
		"charset": -20,
		"viewport": -15
	},
	link: {
		"preconnect": 20,
		"stylesheet": 60,
		"preload": 70,
		"modulepreload": 70,
		"prefetch": 90,
		"dns-prefetch": 90,
		"prerender": 90
	},
	script: {
		async: 30,
		defer: 80,
		sync: 50
	},
	style: {
		imported: 40,
		sync: 60
	}
};
const ImportStyleRe = /@import/;
const isTruthy = (val) => val === "" || val === true;
function tagWeight(head, tag) {
	if (typeof tag.tagPriority === "number") return tag.tagPriority;
	let weight = 100;
	const offset = TAG_ALIASES[tag.tagPriority] || 0;
	const weightMap = head.resolvedOptions.disableCapoSorting ? {
		link: {},
		script: {},
		style: {}
	} : WEIGHT_MAP;
	if (tag.tag in TAG_WEIGHTS) weight = TAG_WEIGHTS[tag.tag];
	else if (tag.tag === "meta") {
		const metaType = tag.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : tag.props.charset ? "charset" : tag.props.name === "viewport" ? "viewport" : null;
		if (metaType) weight = WEIGHT_MAP.meta[metaType];
	} else if (tag.tag === "link" && tag.props.rel) weight = weightMap.link[tag.props.rel];
	else if (tag.tag === "script") {
		if (isTruthy(tag.props.async)) weight = weightMap.script.async;
		else if (tag.props.src && !isTruthy(tag.props.defer) && !isTruthy(tag.props.async) && tag.props.type !== "module" && !tag.props.type?.endsWith("json")) weight = weightMap.script.sync;
		else if (isTruthy(tag.props.defer) && tag.props.src && !isTruthy(tag.props.async)) weight = weightMap.script.defer;
	} else if (tag.tag === "style") weight = tag.innerHTML && ImportStyleRe.test(tag.innerHTML) ? weightMap.style.imported : weightMap.style.sync;
	return (weight || 100) + offset;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/shared/unhead.Bkc50x9u.mjs
function registerPlugin(head, p) {
	const plugin = typeof p === "function" ? p(head) : p;
	const key = plugin.key || String(head.plugins.size + 1);
	const exists = head.plugins.get(key);
	if (!exists) {
		head.plugins.set(key, plugin);
		head.hooks.addHooks(plugin.hooks || {});
	}
}
/* @__NO_SIDE_EFFECTS__ */
function createUnhead(resolvedOptions = {}) {
	const hooks = createHooks();
	hooks.addHooks(resolvedOptions.hooks || {});
	const ssr = !resolvedOptions.document;
	const entries = /* @__PURE__ */ new Map();
	const plugins = /* @__PURE__ */ new Map();
	const normalizeQueue = [];
	const head = {
		_entryCount: 1,
		plugins,
		dirty: false,
		resolvedOptions,
		hooks,
		ssr,
		entries,
		headEntries() {
			return [...entries.values()];
		},
		use: (p) => registerPlugin(head, p),
		push(input, _options) {
			const options = { ..._options || {} };
			delete options.head;
			const _i = options._index ?? head._entryCount++;
			const inst = {
				_i,
				input,
				options
			};
			const _ = {
				_poll(rm = false) {
					head.dirty = true;
					!rm && normalizeQueue.push(_i);
					hooks.callHook("entries:updated", head);
				},
				dispose() {
					if (entries.delete(_i)) _._poll(true);
				},
				patch(input2) {
					if (!options.mode || options.mode === "server" && ssr || options.mode === "client" && !ssr) {
						inst.input = input2;
						entries.set(_i, inst);
						_._poll();
					}
				}
			};
			_.patch(input);
			return _;
		},
		async resolveTags() {
			const ctx = {
				tagMap: /* @__PURE__ */ new Map(),
				tags: [],
				entries: [...head.entries.values()]
			};
			await hooks.callHook("entries:resolve", ctx);
			while (normalizeQueue.length) {
				const i = normalizeQueue.shift();
				const e = entries.get(i);
				if (e) {
					const normalizeCtx = {
						tags: normalizeEntryToTags(e.input, resolvedOptions.propResolvers || []).map((t) => Object.assign(t, e.options)),
						entry: e
					};
					await hooks.callHook("entries:normalize", normalizeCtx);
					e._tags = normalizeCtx.tags.map((t, i2) => {
						t._w = tagWeight(head, t);
						t._p = (e._i << 10) + i2;
						t._d = dedupeKey(t);
						return t;
					});
				}
			}
			let hasFlatMeta = false;
			ctx.entries.flatMap((e) => (e._tags || []).map((t) => ({
				...t,
				props: { ...t.props }
			}))).sort(sortTags).reduce((acc, next) => {
				const k = String(next._d || next._p);
				if (!acc.has(k)) return acc.set(k, next);
				const prev = acc.get(k);
				const strategy = next?.tagDuplicateStrategy || (UsesMergeStrategy.has(next.tag) ? "merge" : null) || (next.key && next.key === prev.key ? "merge" : null);
				if (strategy === "merge") {
					const newProps = { ...prev.props };
					Object.entries(next.props).forEach(([p, v]) => newProps[p] = p === "style" ? new Map([...prev.props.style || /* @__PURE__ */ new Map(), ...v]) : p === "class" ? /* @__PURE__ */ new Set([...prev.props.class || /* @__PURE__ */ new Set(), ...v]) : v);
					acc.set(k, {
						...next,
						props: newProps
					});
				} else if (next._p >> 10 === prev._p >> 10 && next.tag === "meta" && isMetaArrayDupeKey(k)) {
					acc.set(k, Object.assign([...Array.isArray(prev) ? prev : [prev], next], next));
					hasFlatMeta = true;
				} else if (next._w === prev._w ? next._p > prev._p : next?._w < prev?._w) acc.set(k, next);
				return acc;
			}, ctx.tagMap);
			const title = ctx.tagMap.get("title");
			const titleTemplate = ctx.tagMap.get("titleTemplate");
			head._title = title?.textContent;
			if (titleTemplate) {
				const titleTemplateFn = titleTemplate?.textContent;
				head._titleTemplate = titleTemplateFn;
				if (titleTemplateFn) {
					let newTitle = typeof titleTemplateFn === "function" ? titleTemplateFn(title?.textContent) : titleTemplateFn;
					if (typeof newTitle === "string" && !head.plugins.has("template-params")) newTitle = newTitle.replace("%s", title?.textContent || "");
					if (title) newTitle === null ? ctx.tagMap.delete("title") : ctx.tagMap.set("title", {
						...title,
						textContent: newTitle
					});
					else {
						titleTemplate.tag = "title";
						titleTemplate.textContent = newTitle;
					}
				}
			}
			ctx.tags = Array.from(ctx.tagMap.values());
			if (hasFlatMeta) ctx.tags = ctx.tags.flat().sort(sortTags);
			await hooks.callHook("tags:beforeResolve", ctx);
			await hooks.callHook("tags:resolve", ctx);
			await hooks.callHook("tags:afterResolve", ctx);
			const finalTags = [];
			for (const t of ctx.tags) {
				const { innerHTML, tag, props } = t;
				if (!ValidHeadTags.has(tag)) continue;
				if (Object.keys(props).length === 0 && !t.innerHTML && !t.textContent) continue;
				if (tag === "meta" && !props.content && !props["http-equiv"] && !props.charset) continue;
				if (tag === "script" && innerHTML) {
					if (props.type?.endsWith("json")) {
						const v = typeof innerHTML === "string" ? innerHTML : JSON.stringify(innerHTML);
						t.innerHTML = v.replace(/</g, "\\u003C");
					} else if (typeof innerHTML === "string") t.innerHTML = innerHTML.replace(new RegExp(`</${tag}`, "g"), `<\\/${tag}`);
					t._d = dedupeKey(t);
				}
				finalTags.push(t);
			}
			return finalTags;
		}
	};
	(resolvedOptions?.plugins || []).forEach((p) => registerPlugin(head, p));
	head.hooks.callHook("init", head);
	resolvedOptions.init?.forEach((e) => e && head.push(e));
	return head;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/client.mjs
async function renderDOMHead(head, options = {}) {
	const dom = options.document || head.resolvedOptions.document;
	if (!dom || !head.dirty) return;
	const beforeRenderCtx = {
		shouldRender: true,
		tags: []
	};
	await head.hooks.callHook("dom:beforeRender", beforeRenderCtx);
	if (!beforeRenderCtx.shouldRender) return;
	if (head._domUpdatePromise) return head._domUpdatePromise;
	head._domUpdatePromise = new Promise(async (resolve) => {
		const dupeKeyCounter = /* @__PURE__ */ new Map();
		const resolveTagPromise = new Promise((resolve2) => {
			head.resolveTags().then((tags2) => {
				resolve2(tags2.map((tag) => {
					const count = dupeKeyCounter.get(tag._d) || 0;
					const res = {
						tag,
						id: (count ? `${tag._d}:${count}` : tag._d) || hashTag(tag),
						shouldRender: true
					};
					if (tag._d && isMetaArrayDupeKey(tag._d)) dupeKeyCounter.set(tag._d, count + 1);
					return res;
				}));
			});
		});
		let state = head._dom;
		if (!state) {
			state = {
				title: dom.title,
				elMap: (/* @__PURE__ */ new Map()).set("htmlAttrs", dom.documentElement).set("bodyAttrs", dom.body)
			};
			for (const key of ["body", "head"]) {
				const children = dom[key]?.children;
				for (const c of children) {
					const tag = c.tagName.toLowerCase();
					if (!HasElementTags.has(tag)) continue;
					const next = normalizeProps({
						tag,
						props: {}
					}, {
						innerHTML: c.innerHTML,
						...c.getAttributeNames().reduce((props, name) => {
							props[name] = c.getAttribute(name);
							return props;
						}, {}) || {}
					});
					next.key = c.getAttribute("data-hid") || void 0;
					next._d = dedupeKey(next) || hashTag(next);
					if (state.elMap.has(next._d)) {
						let count = 1;
						let k = next._d;
						while (state.elMap.has(k)) k = `${next._d}:${count++}`;
						state.elMap.set(k, c);
					} else state.elMap.set(next._d, c);
				}
			}
		}
		state.pendingSideEffects = { ...state.sideEffects };
		state.sideEffects = {};
		function track(id, scope, fn) {
			const k = `${id}:${scope}`;
			state.sideEffects[k] = fn;
			delete state.pendingSideEffects[k];
		}
		function trackCtx({ id, $el, tag }) {
			const isAttrTag = tag.tag.endsWith("Attrs");
			state.elMap.set(id, $el);
			if (!isAttrTag) {
				if (tag.textContent && tag.textContent !== $el.textContent) $el.textContent = tag.textContent;
				if (tag.innerHTML && tag.innerHTML !== $el.innerHTML) $el.innerHTML = tag.innerHTML;
				track(id, "el", () => {
					$el?.remove();
					state.elMap.delete(id);
				});
			}
			for (const k in tag.props) {
				if (!Object.prototype.hasOwnProperty.call(tag.props, k)) continue;
				const value = tag.props[k];
				if (k.startsWith("on") && typeof value === "function") {
					const dataset = $el?.dataset;
					if (dataset && dataset[`${k}fired`]) {
						const ek = k.slice(0, -5);
						value.call($el, new Event(ek.substring(2)));
					}
					if ($el.getAttribute(`data-${k}`) !== "") {
						(tag.tag === "bodyAttrs" ? dom.defaultView : $el).addEventListener(k.substring(2), value.bind($el));
						$el.setAttribute(`data-${k}`, "");
					}
					continue;
				}
				const ck = `attr:${k}`;
				if (k === "class") {
					if (!value) continue;
					for (const c of value) {
						isAttrTag && track(id, `${ck}:${c}`, () => $el.classList.remove(c));
						!$el.classList.contains(c) && $el.classList.add(c);
					}
				} else if (k === "style") {
					if (!value) continue;
					for (const [k2, v] of value) {
						track(id, `${ck}:${k2}`, () => {
							$el.style.removeProperty(k2);
						});
						$el.style.setProperty(k2, v);
					}
				} else if (value !== false && value !== null) {
					$el.getAttribute(k) !== value && $el.setAttribute(k, value === true ? "" : String(value));
					isAttrTag && track(id, ck, () => $el.removeAttribute(k));
				}
			}
		}
		const pending = [];
		const frag = {
			bodyClose: void 0,
			bodyOpen: void 0,
			head: void 0
		};
		const tags = await resolveTagPromise;
		for (const ctx of tags) {
			const { tag, shouldRender, id } = ctx;
			if (!shouldRender) continue;
			if (tag.tag === "title") {
				dom.title = tag.textContent;
				track("title", "", () => dom.title = state.title);
				continue;
			}
			ctx.$el = ctx.$el || state.elMap.get(id);
			if (ctx.$el) trackCtx(ctx);
			else if (HasElementTags.has(tag.tag)) pending.push(ctx);
		}
		for (const ctx of pending) {
			const pos = ctx.tag.tagPosition || "head";
			ctx.$el = dom.createElement(ctx.tag.tag);
			trackCtx(ctx);
			frag[pos] = frag[pos] || dom.createDocumentFragment();
			frag[pos].appendChild(ctx.$el);
		}
		for (const ctx of tags) await head.hooks.callHook("dom:renderTag", ctx, dom, track);
		frag.head && dom.head.appendChild(frag.head);
		frag.bodyOpen && dom.body.insertBefore(frag.bodyOpen, dom.body.firstChild);
		frag.bodyClose && dom.body.appendChild(frag.bodyClose);
		for (const k in state.pendingSideEffects) state.pendingSideEffects[k]();
		head._dom = state;
		await head.hooks.callHook("dom:rendered", { renders: tags });
		resolve();
	}).finally(() => {
		head._domUpdatePromise = void 0;
		head.dirty = false;
	});
	return head._domUpdatePromise;
}
function createHead$3(options = {}) {
	const render = options.domOptions?.render || renderDOMHead;
	options.document = options.document || (typeof window !== "undefined" ? document : void 0);
	const initialPayload = options.document?.head.querySelector("script[id=\"unhead:payload\"]")?.innerHTML || false;
	return createUnhead({
		...options,
		plugins: [...options.plugins || [], {
			key: "client",
			hooks: { "entries:updated": render }
		}],
		init: [initialPayload ? JSON.parse(initialPayload) : false, ...options.init || []]
	});
}
function createDebouncedFn(callee, delayer) {
	let ctxId = 0;
	return () => {
		const delayFnCtxId = ++ctxId;
		delayer(() => {
			if (ctxId === delayFnCtxId) callee();
		});
	};
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/dist/shared/vue.N9zWjxoK.mjs
const VueResolver = (_, value) => {
	return isRef(value) ? toValue(value) : value;
};

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/dist/shared/vue.BYLJNEcq.mjs
const headSymbol = "usehead";
function vueInstall(head) {
	const plugin = { install(app) {
		app.config.globalProperties.$unhead = head;
		app.config.globalProperties.$head = head;
		app.provide(headSymbol, head);
	} };
	return plugin.install;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/dist/client.mjs
function createHead(options = {}) {
	const head = createHead$3({
		domOptions: { render: createDebouncedFn(() => renderDOMHead(head), (fn) => setTimeout(fn, 0)) },
		...options
	});
	head.install = vueInstall(head);
	return head;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/node_modules/unhead/dist/server.mjs
/* @__NO_SIDE_EFFECTS__ */
function createHead$2(options = {}) {
	const unhead = createUnhead({
		...options,
		document: false,
		propResolvers: [...options.propResolvers || [], (k, v) => {
			if (k && k.startsWith("on") && typeof v === "function") return `this.dataset.${k}fired = true`;
			return v;
		}],
		init: [options.disableDefaults ? void 0 : {
			htmlAttrs: { lang: "en" },
			meta: [{ charset: "utf-8" }, {
				name: "viewport",
				content: "width=device-width, initial-scale=1"
			}]
		}, ...options.init || []]
	});
	unhead._ssrPayload = {};
	unhead.use({
		key: "server",
		hooks: { "tags:resolve": function(ctx) {
			const title = ctx.tagMap.get("title");
			const titleTemplate = ctx.tagMap.get("titleTemplate");
			let payload = {
				title: title?.mode === "server" ? unhead._title : void 0,
				titleTemplate: titleTemplate?.mode === "server" ? unhead._titleTemplate : void 0
			};
			if (Object.keys(unhead._ssrPayload || {}).length > 0) payload = {
				...unhead._ssrPayload,
				...payload
			};
			if (Object.values(payload).some(Boolean)) ctx.tags.push({
				tag: "script",
				innerHTML: JSON.stringify(payload),
				props: {
					id: "unhead:payload",
					type: "application/json"
				}
			});
		} }
	});
	return unhead;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/node_modules/@unhead/vue/dist/server.mjs
function createHead$1(options = {}) {
	const head = createHead$2({
		...options,
		propResolvers: [VueResolver]
	});
	head.install = vueInstall(head);
	return head;
}

//#endregion
//#region ../../../../node_modules/vite-ssg/dist/shared/vite-ssg.ETIvV-80.mjs
function documentReady(_passThrough) {
	if (document.readyState === "loading") return new Promise((resolve) => {
		document.addEventListener("DOMContentLoaded", () => resolve(_passThrough));
	});
	return Promise.resolve(_passThrough);
}
const ClientOnly = defineComponent({ setup(props, { slots }) {
	const mounted = ref(false);
	onMounted(() => mounted.value = true);
	return () => {
		if (!mounted.value) return slots.placeholder && slots.placeholder({});
		return slots.default && slots.default({});
	};
} });

//#endregion
//#region ../../../../node_modules/vite-ssg/dist/shared/vite-ssg.C6pK7rvr.mjs
function deserializeState(state) {
	try {
		return JSON.parse(state || "{}");
	} catch (error) {
		console.error("[SSG] On state deserialization -", error, state);
		return {};
	}
}

//#endregion
//#region ../../../../node_modules/vite-ssg/dist/index.mjs
function ViteSSG(App, routerOptions, fn, options) {
	const { transformState, registerComponents = true, useHead = true, rootContainer = "#app" } = options ?? {};
	async function createApp$1(routePath) {
		const app = import.meta.env.SSR || options?.hydration ? createSSRApp(App) : createApp(App);
		let head;
		if (useHead) app.use(head = import.meta.env.SSR ? createHead$1() : createHead());
		const router = createRouter({
			history: import.meta.env.SSR ? createMemoryHistory(routerOptions.base) : createWebHistory(routerOptions.base),
			...routerOptions
		});
		const { routes } = routerOptions;
		if (registerComponents) app.component("ClientOnly", ClientOnly);
		const appRenderCallbacks = [];
		const onSSRAppRendered = import.meta.env.SSR ? (cb) => appRenderCallbacks.push(cb) : () => {};
		const triggerOnSSRAppRendered = () => {
			return Promise.all(appRenderCallbacks.map((cb) => cb()));
		};
		const context = {
			app,
			head,
			isClient: !import.meta.env.SSR,
			router,
			routes,
			onSSRAppRendered,
			triggerOnSSRAppRendered,
			initialState: {},
			transformState,
			routePath
		};
		if (!import.meta.env.SSR) {
			await documentReady();
			context.initialState = transformState?.(window.__INITIAL_STATE__ || {}) || deserializeState(window.__INITIAL_STATE__);
		}
		await fn?.(context);
		app.use(router);
		let entryRoutePath;
		let isFirstRoute = true;
		router.beforeEach((to, from, next) => {
			if (isFirstRoute || entryRoutePath && entryRoutePath === to.path) {
				isFirstRoute = false;
				entryRoutePath = to.path;
				to.meta.state = context.initialState;
			}
			next();
		});
		if (import.meta.env.SSR) {
			const route = context.routePath ?? "/";
			router.push(route);
			await router.isReady();
			context.initialState = router.currentRoute.value.meta.state || {};
		}
		const initialState = context.initialState;
		return {
			...context,
			initialState
		};
	}
	if (!import.meta.env.SSR) (async () => {
		const { app, router } = await createApp$1();
		await router.isReady();
		app.mount(rootContainer, true);
	})();
	return createApp$1;
}

//#endregion
export { ViteSSG };
//# sourceMappingURL=vite-ssg.js.map