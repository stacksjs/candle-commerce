import { createHooks } from "./dist-DKfj0q3M.js";
import { getCurrentInstance, hasInjectionContext, inject, isRef, onActivated, onBeforeUnmount, onDeactivated, onMounted, onScopeDispose, ref, toValue, watch, watchEffect } from "./vue.runtime.esm-bundler-DZNPpFiL.js";

//#region ../../../../node_modules/unhead/dist/shared/unhead.yem5I2v_.mjs
const DupeableTags = /* @__PURE__ */ new Set([
	"link",
	"style",
	"script",
	"noscript"
]);
const TagsWithInnerContent = /* @__PURE__ */ new Set([
	"title",
	"titleTemplate",
	"script",
	"style",
	"noscript"
]);
const ValidHeadTags = /* @__PURE__ */ new Set([
	"title",
	"base",
	"htmlAttrs",
	"bodyAttrs",
	"meta",
	"link",
	"style",
	"script",
	"noscript"
]);
const UniqueTags = /* @__PURE__ */ new Set([
	"base",
	"title",
	"titleTemplate",
	"bodyAttrs",
	"htmlAttrs",
	"templateParams"
]);
const TagConfigKeys = /* @__PURE__ */ new Set([
	"key",
	"tagPosition",
	"tagPriority",
	"tagDuplicateStrategy",
	"innerHTML",
	"textContent",
	"processTemplateParams"
]);
const ScriptNetworkEvents = /* @__PURE__ */ new Set(["onload", "onerror"]);
const UsesMergeStrategy = /* @__PURE__ */ new Set([
	"templateParams",
	"htmlAttrs",
	"bodyAttrs"
]);
const MetaTagsArrayable = /* @__PURE__ */ new Set([
	"theme-color",
	"google-site-verification",
	"og",
	"article",
	"book",
	"profile",
	"twitter",
	"author"
]);

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.DQc16pHI.mjs
const NAMESPACES = {
	META: /* @__PURE__ */ new Set(["twitter"]),
	OG: /* @__PURE__ */ new Set([
		"og",
		"book",
		"article",
		"profile",
		"fb"
	]),
	MEDIA: /* @__PURE__ */ new Set([
		"ogImage",
		"ogVideo",
		"ogAudio",
		"twitterImage"
	]),
	HTTP_EQUIV: /* @__PURE__ */ new Set([
		"contentType",
		"defaultStyle",
		"xUaCompatible"
	])
};
const META_ALIASES = {
	articleExpirationTime: "article:expiration_time",
	articleModifiedTime: "article:modified_time",
	articlePublishedTime: "article:published_time",
	bookReleaseDate: "book:release_date",
	fbAppId: "fb:app_id",
	ogAudioSecureUrl: "og:audio:secure_url",
	ogAudioUrl: "og:audio",
	ogImageSecureUrl: "og:image:secure_url",
	ogImageUrl: "og:image",
	ogSiteName: "og:site_name",
	ogVideoSecureUrl: "og:video:secure_url",
	ogVideoUrl: "og:video",
	profileFirstName: "profile:first_name",
	profileLastName: "profile:last_name",
	profileUsername: "profile:username",
	msapplicationConfig: "msapplication-Config",
	msapplicationTileColor: "msapplication-TileColor",
	msapplicationTileImage: "msapplication-TileImage"
};
const MetaPackingSchema = {
	appleItunesApp: { unpack: {
		entrySeparator: ", ",
		resolve: ({ key, value }) => `${fixKeyCase(key)}=${value}`
	} },
	refresh: {
		metaKey: "http-equiv",
		unpack: {
			entrySeparator: ";",
			resolve: ({ key, value }) => key === "seconds" ? `${value}` : void 0
		}
	},
	robots: { unpack: {
		entrySeparator: ", ",
		resolve: ({ key, value }) => typeof value === "boolean" ? fixKeyCase(key) : `${fixKeyCase(key)}:${value}`
	} },
	contentSecurityPolicy: {
		metaKey: "http-equiv",
		unpack: {
			entrySeparator: "; ",
			resolve: ({ key, value }) => `${fixKeyCase(key)} ${value}`
		}
	},
	charset: {}
};
function fixKeyCase(key) {
	const updated = key.replace(/([A-Z])/g, "-$1").toLowerCase();
	const prefixIndex = updated.indexOf("-");
	return prefixIndex === -1 ? updated : NAMESPACES.META.has(updated.slice(0, prefixIndex)) || NAMESPACES.OG.has(updated.slice(0, prefixIndex)) ? key.replace(/([A-Z])/g, ":$1").toLowerCase() : updated;
}
function sanitizeObject(input) {
	return Object.fromEntries(Object.entries(input).filter(([k, v]) => String(v) !== "false" && k));
}
function transformObject(obj) {
	return Array.isArray(obj) ? obj.map(transformObject) : !obj || typeof obj !== "object" ? obj : Object.fromEntries(Object.entries(obj).map(([k, v]) => [fixKeyCase(k), transformObject(v)]));
}
function unpackToString(value, options = {}) {
	const { entrySeparator = "", keyValueSeparator = "", wrapValue, resolve } = options;
	return Object.entries(value).map(([key, val]) => {
		if (resolve) {
			const resolved = resolve({
				key,
				value: val
			});
			if (resolved !== void 0) return resolved;
		}
		const processedVal = typeof val === "object" ? unpackToString(val, options) : typeof val === "number" ? val.toString() : typeof val === "string" && wrapValue ? `${wrapValue}${val.replace(new RegExp(wrapValue, "g"), `\\${wrapValue}`)}${wrapValue}` : val;
		return `${key}${keyValueSeparator}${processedVal}`;
	}).join(entrySeparator);
}
function handleObjectEntry(key, value) {
	const sanitizedValue = sanitizeObject(value);
	const fixedKey = fixKeyCase(key);
	const attr = resolveMetaKeyType(fixedKey);
	if (!MetaTagsArrayable.has(fixedKey)) return [{
		[attr]: fixedKey,
		...sanitizedValue
	}];
	const input = Object.fromEntries(Object.entries(sanitizedValue).map(([k, v]) => [`${key}${k === "url" ? "" : `${k[0].toUpperCase()}${k.slice(1)}`}`, v]));
	return unpackMeta(input || {}).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));
}
function resolveMetaKeyType(key) {
	if (MetaPackingSchema[key]?.metaKey === "http-equiv" || NAMESPACES.HTTP_EQUIV.has(key)) return "http-equiv";
	const fixed = fixKeyCase(key);
	const colonIndex = fixed.indexOf(":");
	return colonIndex === -1 ? "name" : NAMESPACES.OG.has(fixed.slice(0, colonIndex)) ? "property" : "name";
}
function resolveMetaKeyValue(key) {
	return META_ALIASES[key] || fixKeyCase(key);
}
function resolvePackedMetaObjectValue(value, key) {
	if (key === "refresh") return `${value.seconds};url=${value.url}`;
	return unpackToString(transformObject(value), {
		keyValueSeparator: "=",
		entrySeparator: ", ",
		resolve: ({ value: value2, key: key2 }) => value2 === null ? "" : typeof value2 === "boolean" ? key2 : void 0,
		...MetaPackingSchema[key]?.unpack
	});
}
function unpackMeta(input) {
	const extras = [];
	const primitives = {};
	for (const [key, value] of Object.entries(input)) {
		if (Array.isArray(value)) {
			if (key === "themeColor") {
				value.forEach((v) => {
					if (typeof v === "object" && v !== null) extras.push({
						name: "theme-color",
						...v
					});
				});
				continue;
			}
			for (const v of value) if (typeof v === "object" && v !== null) {
				const urlProps = [];
				const otherProps = [];
				for (const [propKey, propValue] of Object.entries(v)) {
					const metaKey = `${key}${propKey === "url" ? "" : `:${propKey}`}`;
					const meta2 = unpackMeta({ [metaKey]: propValue });
					(propKey === "url" ? urlProps : otherProps).push(...meta2);
				}
				extras.push(...urlProps, ...otherProps);
			} else extras.push(...typeof v === "string" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));
			continue;
		}
		if (typeof value === "object" && value) if (NAMESPACES.MEDIA.has(key)) {
			const prefix = key.startsWith("twitter") ? "twitter" : "og";
			const type = key.replace(/^(og|twitter)/, "").toLowerCase();
			const metaKey = prefix === "twitter" ? "name" : "property";
			if (value.url) extras.push({
				[metaKey]: `${prefix}:${type}`,
				content: value.url
			});
			if (value.secureUrl) extras.push({
				[metaKey]: `${prefix}:${type}:secure_url`,
				content: value.secureUrl
			});
			for (const [propKey, propValue] of Object.entries(value)) if (propKey !== "url" && propKey !== "secureUrl") extras.push({
				[metaKey]: `${prefix}:${type}:${propKey}`,
				content: propValue
			});
		} else if (MetaTagsArrayable.has(fixKeyCase(key))) extras.push(...handleObjectEntry(key, value));
		else primitives[key] = sanitizeObject(value);
		else primitives[key] = value;
	}
	const meta = Object.entries(primitives).map(([key, value]) => {
		if (key === "charset") return { charset: value === null ? "_null" : value };
		const metaKey = resolveMetaKeyType(key);
		const keyValue = resolveMetaKeyValue(key);
		const processedValue = value === null ? "_null" : typeof value === "object" ? resolvePackedMetaObjectValue(value, key) : typeof value === "number" ? value.toString() : value;
		return metaKey === "http-equiv" ? {
			"http-equiv": keyValue,
			"content": processedValue
		} : {
			[metaKey]: keyValue,
			content: processedValue
		};
	});
	return [...extras, ...meta].map((m) => !("content" in m) ? m : m.content === "_null" ? {
		...m,
		content: null
	} : m);
}

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.CApf5sj3.mjs
function defineHeadPlugin(plugin) {
	return plugin;
}
const FlatMetaPlugin = /* @__PURE__ */ defineHeadPlugin({
	key: "flatMeta",
	hooks: { "entries:normalize": (ctx) => {
		const tagsToAdd = [];
		ctx.tags = ctx.tags.map((t) => {
			if (t.tag !== "_flatMeta") return t;
			tagsToAdd.push(unpackMeta(t.props).map((p) => ({
				...t,
				tag: "meta",
				props: p
			})));
			return false;
		}).filter(Boolean).concat(...tagsToAdd);
	} }
});
const WhitelistAttributes = {
	htmlAttrs: /* @__PURE__ */ new Set([
		"class",
		"style",
		"lang",
		"dir"
	]),
	bodyAttrs: /* @__PURE__ */ new Set(["class", "style"]),
	meta: /* @__PURE__ */ new Set([
		"name",
		"property",
		"charset",
		"content",
		"media"
	]),
	noscript: /* @__PURE__ */ new Set(["textContent"]),
	style: /* @__PURE__ */ new Set([
		"media",
		"textContent",
		"nonce",
		"title",
		"blocking"
	]),
	script: /* @__PURE__ */ new Set([
		"type",
		"textContent",
		"nonce",
		"blocking"
	]),
	link: /* @__PURE__ */ new Set([
		"color",
		"crossorigin",
		"fetchpriority",
		"href",
		"hreflang",
		"imagesrcset",
		"imagesizes",
		"integrity",
		"media",
		"referrerpolicy",
		"rel",
		"sizes",
		"type"
	])
};
function acceptDataAttrs(value) {
	return Object.fromEntries(Object.entries(value || {}).filter(([key]) => key === "id" || key.startsWith("data-")));
}
function makeTagSafe(tag) {
	let next = {};
	const { tag: type, props: prev } = tag;
	switch (type) {
		case "title":
		case "titleTemplate":
		case "templateParams":
			next = prev;
			break;
		case "htmlAttrs":
		case "bodyAttrs":
			WhitelistAttributes[type].forEach((attr) => {
				if (prev[attr]) next[attr] = prev[attr];
			});
			break;
		case "style":
			next = acceptDataAttrs(prev);
			WhitelistAttributes.style.forEach((key) => {
				if (prev[key]) next[key] = prev[key];
			});
			break;
		case "meta":
			WhitelistAttributes.meta.forEach((key) => {
				if (prev[key]) next[key] = prev[key];
			});
			break;
		case "link":
			WhitelistAttributes.link.forEach((key) => {
				const val = prev[key];
				if (!val) return;
				if (key === "rel" && (val === "canonical" || val === "modulepreload" || val === "prerender" || val === "preload" || val === "prefetch")) return;
				if (key === "href") {
					if (val.includes("javascript:") || val.includes("data:")) return;
					next[key] = val;
				} else if (val) next[key] = val;
			});
			if (!next.href && !next.imagesrcset || !next.rel) return false;
			break;
		case "noscript":
			WhitelistAttributes.noscript.forEach((key) => {
				if (prev[key]) next[key] = prev[key];
			});
			break;
		case "script":
			if (!tag.textContent || !prev.type?.endsWith("json")) return false;
			WhitelistAttributes.script.forEach((s) => {
				if (prev[s] === "textContent") try {
					const jsonVal = typeof prev[s] === "string" ? JSON.parse(prev[s]) : prev[s];
					next[s] = JSON.stringify(jsonVal, null, 0);
				} catch {}
				else if (prev[s]) next[s] = prev[s];
			});
			break;
	}
	if (!Object.keys(next).length && !tag.tag.endsWith("Attrs")) return false;
	tag.props = {
		...acceptDataAttrs(prev),
		...next
	};
	return tag;
}
const SafeInputPlugin = defineHeadPlugin({
	key: "safe",
	hooks: { "entries:normalize": (ctx) => {
		if (ctx.entry.options?._safe) ctx.tags = ctx.tags.reduce((acc, tag) => {
			const safeTag = makeTagSafe(tag);
			if (safeTag) acc.push(safeTag);
			return acc;
		}, []);
	} }
});

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.Di5OD67x.mjs
const allowedMetaProperties = [
	"name",
	"property",
	"http-equiv"
];
const StandardSingleMetaTags = /* @__PURE__ */ new Set([
	"viewport",
	"description",
	"keywords",
	"robots"
]);
function isMetaArrayDupeKey(v) {
	const parts = v.split(":");
	if (!parts.length) return false;
	return MetaTagsArrayable.has(parts[1]);
}
function dedupeKey(tag) {
	const { props, tag: name } = tag;
	if (UniqueTags.has(name)) return name;
	if (name === "link" && props.rel === "canonical") return "canonical";
	if (props.charset) return "charset";
	if (tag.tag === "meta") {
		for (const n of allowedMetaProperties) if (props[n] !== void 0) {
			const propValue = props[n];
			const isStructured = propValue.includes(":");
			const isStandardSingle = StandardSingleMetaTags.has(propValue);
			const shouldAlwaysDedupe = isStructured || isStandardSingle;
			const keyPart = !shouldAlwaysDedupe && tag.key ? `:key:${tag.key}` : "";
			return `${name}:${propValue}${keyPart}`;
		}
	}
	if (tag.key) return `${name}:key:${tag.key}`;
	if (props.id) return `${name}:id:${props.id}`;
	if (TagsWithInnerContent.has(name)) {
		const v = tag.textContent || tag.innerHTML;
		if (v) return `${name}:content:${v}`;
	}
}
function walkResolver(val, resolve, key) {
	const type = typeof val;
	if (type === "function") {
		if (!key || key !== "titleTemplate" && !(key[0] === "o" && key[1] === "n")) val = val();
	}
	let v;
	if (resolve) v = resolve(key, val);
	if (Array.isArray(v)) return v.map((r) => walkResolver(r, resolve));
	if (v?.constructor === Object) {
		const next = {};
		for (const key2 of Object.keys(v)) next[key2] = walkResolver(v[key2], resolve, key2);
		return next;
	}
	return v;
}
function normalizeStyleClassProps(key, value) {
	const store = key === "style" ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();
	function processValue(rawValue) {
		const value2 = rawValue.trim();
		if (!value2) return;
		if (key === "style") {
			const [k, ...v] = value2.split(":").map((s) => s.trim());
			if (k && v.length) store.set(k, v.join(":"));
		} else value2.split(" ").filter(Boolean).forEach((c) => store.add(c));
	}
	if (typeof value === "string") key === "style" ? value.split(";").forEach(processValue) : processValue(value);
	else if (Array.isArray(value)) value.forEach((item) => processValue(item));
	else if (value && typeof value === "object") Object.entries(value).forEach(([k, v]) => {
		if (v && v !== "false") key === "style" ? store.set(k.trim(), v) : processValue(k);
	});
	return store;
}
function normalizeProps(tag, input) {
	tag.props = tag.props || {};
	if (!input) return tag;
	Object.entries(input).forEach(([key, value]) => {
		if (value === null) {
			tag.props[key] = null;
			return;
		}
		if (key === "class" || key === "style") {
			tag.props[key] = normalizeStyleClassProps(key, value);
			return;
		}
		if (TagConfigKeys.has(key)) {
			if (["textContent", "innerHTML"].includes(key) && typeof value === "object") {
				let type = input.type;
				if (!input.type) type = "application/json";
				if (!type?.endsWith("json") && type !== "speculationrules") return;
				input.type = type;
				tag.props.type = type;
				tag[key] = JSON.stringify(value);
			} else tag[key] = value;
			return;
		}
		const strValue = String(value);
		const isDataKey = key.startsWith("data-");
		if (strValue === "true" || strValue === "") tag.props[key] = isDataKey ? strValue : true;
		else if (!value && isDataKey && strValue === "false") tag.props[key] = "false";
		else if (value !== void 0) tag.props[key] = value;
	});
	return tag;
}
function normalizeTag(tagName, _input) {
	const input = typeof _input === "object" && typeof _input !== "function" ? _input : { [tagName === "script" || tagName === "noscript" || tagName === "style" ? "innerHTML" : "textContent"]: _input };
	const tag = normalizeProps({
		tag: tagName,
		props: {}
	}, input);
	if (tag.key && DupeableTags.has(tag.tag)) tag.props["data-hid"] = tag._h = tag.key;
	if (tag.tag === "script" && typeof tag.innerHTML === "object") {
		tag.innerHTML = JSON.stringify(tag.innerHTML);
		tag.props.type = tag.props.type || "application/json";
	}
	return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({
		...tag,
		props: {
			...tag.props,
			content: v
		}
	})) : tag;
}
function normalizeEntryToTags(input, propResolvers) {
	if (!input) return [];
	if (typeof input === "function") input = input();
	const resolvers = (key, val) => {
		for (let i = 0; i < propResolvers.length; i++) val = propResolvers[i](key, val);
		return val;
	};
	input = resolvers(void 0, input);
	const tags = [];
	input = walkResolver(input, resolvers);
	Object.entries(input || {}).forEach(([key, value]) => {
		if (value === void 0) return;
		for (const v of Array.isArray(value) ? value : [value]) tags.push(normalizeTag(key, v));
	});
	return tags.flat();
}

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.DZbvapt-.mjs
const sortTags = (a, b) => a._w === b._w ? a._p - b._p : a._w - b._w;
const TAG_WEIGHTS = {
	base: -10,
	title: 10
};
const TAG_ALIASES = {
	critical: -8,
	high: -1,
	low: 2
};
const WEIGHT_MAP = {
	meta: {
		"content-security-policy": -30,
		"charset": -20,
		"viewport": -15
	},
	link: {
		"preconnect": 20,
		"stylesheet": 60,
		"preload": 70,
		"modulepreload": 70,
		"prefetch": 90,
		"dns-prefetch": 90,
		"prerender": 90
	},
	script: {
		async: 30,
		defer: 80,
		sync: 50
	},
	style: {
		imported: 40,
		sync: 60
	}
};
const ImportStyleRe = /@import/;
const isTruthy = (val) => val === "" || val === true;
function tagWeight(head, tag) {
	if (typeof tag.tagPriority === "number") return tag.tagPriority;
	let weight = 100;
	const offset = TAG_ALIASES[tag.tagPriority] || 0;
	const weightMap = head.resolvedOptions.disableCapoSorting ? {
		link: {},
		script: {},
		style: {}
	} : WEIGHT_MAP;
	if (tag.tag in TAG_WEIGHTS) weight = TAG_WEIGHTS[tag.tag];
	else if (tag.tag === "meta") {
		const metaType = tag.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : tag.props.charset ? "charset" : tag.props.name === "viewport" ? "viewport" : null;
		if (metaType) weight = WEIGHT_MAP.meta[metaType];
	} else if (tag.tag === "link" && tag.props.rel) weight = weightMap.link[tag.props.rel];
	else if (tag.tag === "script") {
		if (isTruthy(tag.props.async)) weight = weightMap.script.async;
		else if (tag.props.src && !isTruthy(tag.props.defer) && !isTruthy(tag.props.async) && tag.props.type !== "module" && !tag.props.type?.endsWith("json")) weight = weightMap.script.sync;
		else if (isTruthy(tag.props.defer) && tag.props.src && !isTruthy(tag.props.async)) weight = weightMap.script.defer;
	} else if (tag.tag === "style") weight = tag.innerHTML && ImportStyleRe.test(tag.innerHTML) ? weightMap.style.imported : weightMap.style.sync;
	return (weight || 100) + offset;
}

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.CAk5S5m6.mjs
function registerPlugin(head, p) {
	const plugin = typeof p === "function" ? p(head) : p;
	const key = plugin.key || String(head.plugins.size + 1);
	const exists = head.plugins.get(key);
	if (!exists) {
		head.plugins.set(key, plugin);
		head.hooks.addHooks(plugin.hooks || {});
	}
}
/* @__NO_SIDE_EFFECTS__ */
function createUnhead(resolvedOptions = {}) {
	const hooks = createHooks();
	hooks.addHooks(resolvedOptions.hooks || {});
	const ssr = !resolvedOptions.document;
	const entries = /* @__PURE__ */ new Map();
	const plugins = /* @__PURE__ */ new Map();
	const normalizeQueue = /* @__PURE__ */ new Set();
	const head = {
		_entryCount: 1,
		plugins,
		dirty: false,
		resolvedOptions,
		hooks,
		ssr,
		entries,
		headEntries() {
			return [...entries.values()];
		},
		use: (p) => registerPlugin(head, p),
		push(input, _options) {
			const options = { ..._options || {} };
			delete options.head;
			const _i = options._index ?? head._entryCount++;
			const inst = {
				_i,
				input,
				options
			};
			const _ = {
				_poll(rm = false) {
					head.dirty = true;
					!rm && normalizeQueue.add(_i);
					hooks.callHook("entries:updated", head);
				},
				dispose() {
					if (entries.delete(_i)) head.invalidate();
				},
				patch(input2) {
					if (!options.mode || options.mode === "server" && ssr || options.mode === "client" && !ssr) {
						inst.input = input2;
						entries.set(_i, inst);
						_._poll();
					}
				}
			};
			_.patch(input);
			return _;
		},
		async resolveTags() {
			const ctx = {
				tagMap: /* @__PURE__ */ new Map(),
				tags: [],
				entries: [...head.entries.values()]
			};
			await hooks.callHook("entries:resolve", ctx);
			while (normalizeQueue.size) {
				const i = normalizeQueue.values().next().value;
				normalizeQueue.delete(i);
				const e = entries.get(i);
				if (e) {
					const normalizeCtx = {
						tags: normalizeEntryToTags(e.input, resolvedOptions.propResolvers || []).map((t) => Object.assign(t, e.options)),
						entry: e
					};
					await hooks.callHook("entries:normalize", normalizeCtx);
					e._tags = normalizeCtx.tags.map((t, i2) => {
						t._w = tagWeight(head, t);
						t._p = (e._i << 10) + i2;
						t._d = dedupeKey(t);
						return t;
					});
				}
			}
			let hasFlatMeta = false;
			ctx.entries.flatMap((e) => (e._tags || []).map((t) => ({
				...t,
				props: { ...t.props }
			}))).sort(sortTags).reduce((acc, next) => {
				const k = String(next._d || next._p);
				if (!acc.has(k)) return acc.set(k, next);
				const prev = acc.get(k);
				const strategy = next?.tagDuplicateStrategy || (UsesMergeStrategy.has(next.tag) ? "merge" : null) || (next.key && next.key === prev.key ? "merge" : null);
				if (strategy === "merge") {
					const newProps = { ...prev.props };
					Object.entries(next.props).forEach(([p, v]) => newProps[p] = p === "style" ? new Map([...prev.props.style || /* @__PURE__ */ new Map(), ...v]) : p === "class" ? /* @__PURE__ */ new Set([...prev.props.class || /* @__PURE__ */ new Set(), ...v]) : v);
					acc.set(k, {
						...next,
						props: newProps
					});
				} else if (next._p >> 10 === prev._p >> 10 && next.tag === "meta" && isMetaArrayDupeKey(k)) {
					acc.set(k, Object.assign([...Array.isArray(prev) ? prev : [prev], next], next));
					hasFlatMeta = true;
				} else if (next._w === prev._w ? next._p > prev._p : next?._w < prev?._w) acc.set(k, next);
				return acc;
			}, ctx.tagMap);
			const title = ctx.tagMap.get("title");
			const titleTemplate = ctx.tagMap.get("titleTemplate");
			head._title = title?.textContent;
			if (titleTemplate) {
				const titleTemplateFn = titleTemplate?.textContent;
				head._titleTemplate = titleTemplateFn;
				if (titleTemplateFn) {
					let newTitle = typeof titleTemplateFn === "function" ? titleTemplateFn(title?.textContent) : titleTemplateFn;
					if (typeof newTitle === "string" && !head.plugins.has("template-params")) newTitle = newTitle.replace("%s", title?.textContent || "");
					if (title) newTitle === null ? ctx.tagMap.delete("title") : ctx.tagMap.set("title", {
						...title,
						textContent: newTitle
					});
					else {
						titleTemplate.tag = "title";
						titleTemplate.textContent = newTitle;
					}
				}
			}
			ctx.tags = Array.from(ctx.tagMap.values());
			if (hasFlatMeta) ctx.tags = ctx.tags.flat().sort(sortTags);
			await hooks.callHook("tags:beforeResolve", ctx);
			await hooks.callHook("tags:resolve", ctx);
			await hooks.callHook("tags:afterResolve", ctx);
			const finalTags = [];
			for (const t of ctx.tags) {
				const { innerHTML, tag, props } = t;
				if (!ValidHeadTags.has(tag)) continue;
				if (Object.keys(props).length === 0 && !t.innerHTML && !t.textContent) continue;
				if (tag === "meta" && !props.content && !props["http-equiv"] && !props.charset) continue;
				if (tag === "script" && innerHTML) {
					if (props.type?.endsWith("json")) {
						const v = typeof innerHTML === "string" ? innerHTML : JSON.stringify(innerHTML);
						t.innerHTML = v.replace(/</g, "\\u003C");
					} else if (typeof innerHTML === "string") t.innerHTML = innerHTML.replace(new RegExp(`</${tag}`, "g"), `<\\/${tag}`);
					t._d = dedupeKey(t);
				}
				finalTags.push(t);
			}
			return finalTags;
		},
		invalidate() {
			for (const entry of entries.values()) normalizeQueue.add(entry._i);
			head.dirty = true;
			hooks.callHook("entries:updated", head);
		}
	};
	(resolvedOptions?.plugins || []).forEach((p) => registerPlugin(head, p));
	head.hooks.callHook("init", head);
	resolvedOptions.init?.forEach((e) => e && head.push(e));
	return head;
}

//#endregion
//#region ../../../../node_modules/unhead/dist/shared/unhead.B578PsDV.mjs
function createNoopedRecordingProxy(instance = {}) {
	const stack = [];
	let stackIdx = -1;
	const handler = (reuseStack = false) => ({
		get(_, prop, receiver) {
			if (!reuseStack) {
				const v = Reflect.get(_, prop, receiver);
				if (typeof v !== "undefined") return v;
				stackIdx++;
				stack[stackIdx] = [];
			}
			stack[stackIdx].push({
				type: "get",
				key: prop
			});
			return new Proxy(() => {}, handler(true));
		},
		apply(_, __, args) {
			stack[stackIdx].push({
				type: "apply",
				key: "",
				args
			});
			return void 0;
		}
	});
	return {
		proxy: new Proxy(instance || {}, handler()),
		stack
	};
}
function createForwardingProxy(target) {
	const handler = {
		get(_, prop, receiver) {
			const v = Reflect.get(_, prop, receiver);
			if (typeof v === "object") return new Proxy(v, handler);
			return v;
		},
		apply(_, __, args) {
			Reflect.apply(_, __, args);
			return void 0;
		}
	};
	return new Proxy(target, handler);
}
function replayProxyRecordings(target, stack) {
	stack.forEach((recordings) => {
		let context = target;
		let prevContext = target;
		recordings.forEach(({ type, key, args }) => {
			if (type === "get") {
				prevContext = context;
				context = context[key];
			} else if (type === "apply") context = context.call(prevContext, ...args);
		});
	});
}
function resolveScriptKey(input) {
	return input.key || input.src || (typeof input.innerHTML === "string" ? input.innerHTML : "");
}
const PreconnectServerModes = ["preconnect", "dns-prefetch"];
function useScript$1(head, _input, _options) {
	const input = typeof _input === "string" ? { src: _input } : _input;
	const options = _options || {};
	const id = resolveScriptKey(input);
	const prevScript = head._scripts?.[id];
	if (prevScript) {
		prevScript.setupTriggerHandler(options.trigger);
		return prevScript;
	}
	options.beforeInit?.();
	const syncStatus = (s) => {
		script.status = s;
		head.hooks.callHook(`script:updated`, hookCtx);
	};
	ScriptNetworkEvents.forEach((fn) => {
		const k = fn;
		const _fn = typeof input[k] === "function" ? input[k].bind(options.eventContext) : null;
		input[k] = (e) => {
			syncStatus(fn === "onload" ? "loaded" : fn === "onerror" ? "error" : "loading");
			_fn?.(e);
		};
	});
	const _cbs = {
		loaded: [],
		error: []
	};
	const _uniqueCbs = /* @__PURE__ */ new Set();
	const _registerCb = (key, cb, options2) => {
		if (head.ssr) return;
		if (options2?.key) {
			const key2 = `${options2?.key}:${options2.key}`;
			if (_uniqueCbs.has(key2)) return;
			_uniqueCbs.add(key2);
		}
		if (_cbs[key]) {
			const i = _cbs[key].push(cb);
			return () => _cbs[key]?.splice(i - 1, 1);
		}
		cb(script.instance);
		return () => {};
	};
	const loadPromise = new Promise((resolve) => {
		if (head.ssr) return;
		const emit = (api) => requestAnimationFrame(() => resolve(api));
		const _ = head.hooks.hook("script:updated", ({ script: script2 }) => {
			const status = script2.status;
			if (script2.id === id && (status === "loaded" || status === "error")) {
				if (status === "loaded") if (typeof options.use === "function") {
					const api = options.use();
					if (api) emit(api);
				} else emit({});
				else if (status === "error") resolve(false);
				_();
			}
		});
	});
	const script = {
		_loadPromise: loadPromise,
		instance: !head.ssr && options?.use?.() || null,
		proxy: null,
		id,
		status: "awaitingLoad",
		remove() {
			script._triggerAbortController?.abort();
			script._triggerPromises = [];
			script._warmupEl?.dispose();
			if (script.entry) {
				script.entry.dispose();
				script.entry = void 0;
				syncStatus("removed");
				delete head._scripts?.[id];
				return true;
			}
			return false;
		},
		warmup(rel) {
			const { src } = input;
			const isCrossOrigin = !src.startsWith("/") || src.startsWith("//");
			const isPreconnect = rel && PreconnectServerModes.includes(rel);
			let href = src;
			if (!rel || isPreconnect && !isCrossOrigin) return;
			if (isPreconnect) {
				const $url = new URL(src);
				href = `${$url.protocol}//${$url.host}`;
			}
			const link = {
				href,
				rel,
				crossorigin: typeof input.crossorigin !== "undefined" ? input.crossorigin : isCrossOrigin ? "anonymous" : void 0,
				referrerpolicy: typeof input.referrerpolicy !== "undefined" ? input.referrerpolicy : isCrossOrigin ? "no-referrer" : void 0,
				fetchpriority: typeof input.fetchpriority !== "undefined" ? input.fetchpriority : "low",
				integrity: input.integrity,
				as: rel === "preload" ? "script" : void 0
			};
			script._warmupEl = head.push({ link: [link] }, {
				head,
				tagPriority: "high"
			});
			return script._warmupEl;
		},
		load(cb) {
			script._triggerAbortController?.abort();
			script._triggerPromises = [];
			if (!script.entry) {
				syncStatus("loading");
				const defaults = {
					defer: true,
					fetchpriority: "low"
				};
				if (input.src && (input.src.startsWith("http") || input.src.startsWith("//"))) {
					defaults.crossorigin = "anonymous";
					defaults.referrerpolicy = "no-referrer";
				}
				script.entry = head.push({ script: [{
					...defaults,
					...input
				}] }, options);
			}
			if (cb) _registerCb("loaded", cb);
			return loadPromise;
		},
		onLoaded(cb, options2) {
			return _registerCb("loaded", cb, options2);
		},
		onError(cb, options2) {
			return _registerCb("error", cb, options2);
		},
		setupTriggerHandler(trigger) {
			if (script.status !== "awaitingLoad") return;
			if ((typeof trigger === "undefined" || trigger === "client") && !head.ssr || trigger === "server") script.load();
			else if (trigger instanceof Promise) {
				if (head.ssr) return;
				if (!script._triggerAbortController) {
					script._triggerAbortController = new AbortController();
					script._triggerAbortPromise = new Promise((resolve) => {
						script._triggerAbortController.signal.addEventListener("abort", () => {
							script._triggerAbortController = null;
							resolve();
						});
					});
				}
				script._triggerPromises = script._triggerPromises || [];
				const idx = script._triggerPromises.push(Promise.race([trigger.then((v) => typeof v === "undefined" || v ? script.load : void 0), script._triggerAbortPromise]).catch(() => {}).then((res) => {
					res?.();
				}).finally(() => {
					script._triggerPromises?.splice(idx, 1);
				}));
			} else if (typeof trigger === "function") trigger(script.load);
		},
		_cbs
	};
	loadPromise.then((api) => {
		if (api !== false) {
			script.instance = api;
			_cbs.loaded?.forEach((cb) => cb(api));
			_cbs.loaded = null;
		} else {
			_cbs.error?.forEach((cb) => cb());
			_cbs.error = null;
		}
	});
	const hookCtx = { script };
	script.setupTriggerHandler(options.trigger);
	if (options.use) {
		const { proxy, stack } = createNoopedRecordingProxy(head.ssr ? {} : options.use() || {});
		script.proxy = proxy;
		script.onLoaded((instance) => {
			replayProxyRecordings(instance, stack);
			script.proxy = createForwardingProxy(instance);
		});
	}
	if (!options.warmupStrategy && (typeof options.trigger === "undefined" || options.trigger === "client")) options.warmupStrategy = "preload";
	if (options.warmupStrategy) script.warmup(options.warmupStrategy);
	head._scripts = Object.assign(head._scripts || {}, { [id]: script });
	return script;
}

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/shared/vue.N9zWjxoK.mjs
const VueResolver = (_, value) => {
	return isRef(value) ? toValue(value) : value;
};

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/shared/vue.BYLJNEcq.mjs
const headSymbol = "usehead";
function injectHead() {
	if (hasInjectionContext()) {
		const instance = inject(headSymbol);
		if (!instance) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
		return instance;
	}
	throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
}
function useHead(input, options = {}) {
	const head = options.head || injectHead();
	return head.ssr ? head.push(input || {}, options) : clientUseHead(head, input, options);
}
function clientUseHead(head, input, options = {}) {
	const deactivated = ref(false);
	let entry;
	watchEffect(() => {
		const i = deactivated.value ? {} : walkResolver(input, VueResolver);
		if (entry) entry.patch(i);
		else entry = head.push(i, options);
	});
	const vm = getCurrentInstance();
	if (vm) {
		onBeforeUnmount(() => {
			entry.dispose();
		});
		onDeactivated(() => {
			deactivated.value = true;
		});
		onActivated(() => {
			deactivated.value = false;
		});
	}
	return entry;
}
function useHeadSafe(input = {}, options = {}) {
	const head = options.head || injectHead();
	head.use(SafeInputPlugin);
	options._safe = true;
	return useHead(input, options);
}
function useSeoMeta(input = {}, options = {}) {
	const head = options.head || injectHead();
	head.use(FlatMetaPlugin);
	const { title, titleTemplate,...meta } = input;
	return useHead({
		title,
		titleTemplate,
		_flatMeta: meta
	}, options);
}
function useServerHead(input, options = {}) {
	return useHead(input, {
		...options,
		mode: "server"
	});
}
function useServerHeadSafe(input, options = {}) {
	return useHeadSafe(input, {
		...options,
		mode: "server"
	});
}
function useServerSeoMeta(input, options = {}) {
	return useSeoMeta(input, {
		...options,
		mode: "server"
	});
}

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/utils.mjs
function resolveUnrefHeadInput(input) {
	return walkResolver(input, VueResolver);
}

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/shared/vue.nvpYXC6D.mjs
const VueHeadMixin = { created() {
	let source = false;
	const instance = getCurrentInstance();
	if (!instance) return;
	const options = instance.type;
	if (!options || !("head" in options)) return;
	source = typeof options.head === "function" ? () => options.head.call(instance.proxy) : options.head;
	source && useHead(source);
} };

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/shared/vue.cHBs6zvy.mjs
function registerVueScopeHandlers(script, scope) {
	if (!scope) return;
	const _registerCb = (key, cb) => {
		if (!script._cbs[key]) {
			cb(script.instance);
			return () => {};
		}
		let i = script._cbs[key].push(cb);
		const destroy = () => {
			if (i) {
				script._cbs[key]?.splice(i - 1, 1);
				i = null;
			}
		};
		onScopeDispose(destroy);
		return destroy;
	};
	script.onLoaded = (cb) => _registerCb("loaded", cb);
	script.onError = (cb) => _registerCb("error", cb);
	onScopeDispose(() => {
		script._triggerAbortController?.abort();
	});
}
function useScript(_input, _options) {
	const input = typeof _input === "string" ? { src: _input } : _input;
	const options = _options || {};
	const head = options?.head || injectHead();
	options.head = head;
	const scope = getCurrentInstance();
	options.eventContext = scope;
	if (scope && typeof options.trigger === "undefined") options.trigger = onMounted;
	else if (isRef(options.trigger)) {
		const refTrigger = options.trigger;
		let off;
		options.trigger = new Promise((resolve) => {
			off = watch(refTrigger, (val) => {
				if (val) resolve(true);
			}, { immediate: true });
			onScopeDispose(() => resolve(false), true);
		}).then((val) => {
			off?.();
			return val;
		});
	}
	head._scriptStatusWatcher = head._scriptStatusWatcher || head.hooks.hook("script:updated", ({ script: s }) => {
		s._statusRef.value = s.status;
	});
	const script = useScript$1(head, input, options);
	script._statusRef = script._statusRef || ref(script.status);
	registerVueScopeHandlers(script, scope);
	return new Proxy(script, { get(_, key, a) {
		return Reflect.get(_, key === "status" ? "_statusRef" : key, a);
	} });
}

//#endregion
//#region ../../../../node_modules/@unhead/vue/dist/index.mjs
const unheadVueComposablesImports = { "@unhead/vue": [
	"injectHead",
	"useHead",
	"useSeoMeta",
	"useHeadSafe",
	"useServerHead",
	"useServerSeoMeta",
	"useServerHeadSafe"
] };
const createHeadCore = createUnhead;

//#endregion
export { VueHeadMixin, createHeadCore, createUnhead, headSymbol, injectHead, resolveUnrefHeadInput, unheadVueComposablesImports, useHead, useHeadSafe, useScript, useSeoMeta, useServerHead, useServerHeadSafe, useServerSeoMeta };
//# sourceMappingURL=@unhead_vue.js.map